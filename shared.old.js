(() => {
  const __dcg_chunk_exports__ = {};
  var _5 =
    ((e) =>
      typeof require != "undefined"
        ? require
        : typeof Proxy != "undefined"
        ? new Proxy(e, {
          get: (t, n) => (typeof require != "undefined" ? require : t)[n],
        })
        : e)(function (e) {
        if (typeof require != "undefined") {
          return require.apply(this, arguments);
        }
        throw Error('Dynamic require of "' + e + '" is not supported');
      });
  var L5 = (e, t) => () => (e && (t = e(e = 0)), t);
  var w5 =
      (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    ia = (e, t) => {
      for (var n in t) {
        Object.defineProperty(e, n, { get: t[n], enumerable: true });
      }
    },
    VF = (e, t, n, r) => {
      if (t && typeof t == "object" || typeof t == "function") {
        for (let s of Object.getOwnPropertyNames(t)) {
          !Object.prototype.hasOwnProperty.call(e, s) && s !== n &&
            Object.defineProperty(e, s, {
              get: () => t[s],
              enumerable: !(r = Object.getOwnPropertyDescriptor(t, s)) ||
                r.enumerable,
            });
        }
      }
      return e;
    };
  var F5 = (
    e,
    t,
    n,
  ) => (n = e != null ? Object.create(Object.getPrototypeOf(e)) : {},
    VF(
      t || !e || !e.__esModule
        ? Object.defineProperty(n, "default", { value: e, enumerable: true })
        : n,
      e,
    ));
  var V5 = (() => {
    for (var e = new Uint8Array(128), t = 0; t < 64; t++) {
      e[t < 26 ? t + 65 : t < 52 ? t + 71 : t < 62 ? t - 4 : t * 4 - 205] = t;
    }
    return (n) => {
      for (
        var r = n.length,
          s = new Uint8Array(
            (r - (n[r - 1] == "=") - (n[r - 2] == "=")) * 3 / 4 | 0,
          ),
          i = 0,
          o = 0;
        i < r;
      ) {
        var a = e[n.charCodeAt(i++)],
          u = e[n.charCodeAt(i++)],
          c = e[n.charCodeAt(i++)],
          l = e[n.charCodeAt(i++)];
        s[o++] = a << 2 | u >> 4, s[o++] = u << 4 | c >> 2, s[o++] = c << 6 | l;
      }
      return s;
    };
  })();
  var Z1 = function () {
      {
        let e = function () {},
          t = [
            "log",
            "info",
            "warn",
            "error",
            "assert",
            "dir",
            "clear",
            "profile",
            "profileEnd",
            "time",
            "timeEnd",
            "group",
            "groupCollapsed",
            "groupEnd",
            "trace",
          ],
          n = {},
          r = function (s) {
            typeof window != "undefined" && window.console && window.console[s]
              ? n[s] = function () {
                Function.prototype.apply.call(
                  window.console[s],
                  window.console,
                  arguments,
                );
              }
              : n[s] = e;
          };
        return t.forEach(r), n;
      }
    }(),
    G5 = Z1,
    {
      log: k5,
      warn: H5,
      error: z5,
      assert: U5,
      dir: q5,
      clear: $5,
      profile: Y5,
      profileEnd: X5,
      time: Z5,
      timeEnd: W5,
      group: j5,
      groupCollapsed: J5,
      groupEnd: Q5,
      trace: K5,
    } = Z1;
  var Oo = {};
  ia(Oo, {
    DEFAULT_COMPLEX_EVALUATION_LABEL_OPTIONS: () =>
      DEFAULT_COMPLEX_EVALUATION_LABEL_OPTIONS,
    DEFAULT_EVALUATION_LABEL_OPTIONS: () => DEFAULT_EVALUATION_LABEL_OPTIONS,
    canDisplayAsFraction: () => canDisplayAsFraction,
    complexNumberLabel: () => complexNumberLabel,
    complexPlainMathNumberLabel: () => complexPlainMathNumberLabel,
    formatSymbol: () => formatSymbol,
    identifierToHTML: () => identifierToHTML,
    identifierToLatex: () => identifierToLatex,
    latexToIdentifier: () => latexToIdentifier,
    numericLabel: () => numericLabel,
    point: () => point,
    trimLatex: () => trimLatex,
    truncatedHTMLLabel: () => truncatedHTMLLabel,
    truncatedLatexLabel: () => truncatedLatexLabel,
    truncatedPlainmathLabel: () => truncatedPlainmathLabel,
    value: () => value,
  });
  function W1(e, t, n) {
    if (e = _l(e), n > 0) {
      let r = _l(t);
      return e < r && (e += 2 * Math.PI), (e - r) / n;
    } else {
      let r = _l(t + n);
      return e < r && (e += 2 * Math.PI), 1 + (e - r) / n;
    }
  }
  function Bm(e, t, n) {
    e = _l(e);
    let r = _l(t), s = _l(t + n);
    if (n < 0) {
      let i = r;
      r = s, s = i;
    }
    return r < s ? r <= e && e <= s : r <= e || e <= s;
  }
  function _l(e) {
    let t = 2 * Math.PI;
    return (e % t + t) % t;
  }
  function tY(e, t) {
    if (!(isNaN(e) || isNaN(t))) {
      return e >= 0 ? Math.atan(t / e) : Math.atan(t / e) + Math.PI;
    }
  }
  var MathHypot = Math.hypot;
  function Va(e, t) {
    return e > 0 == t > 0 ? e + .5 * (t - e) : .5 * (e + t);
  }
  function GF(e, t, n, r, s, i) {
    return e * r + t * s + n * i;
  }
  function to(e, t, n, r, s, i, o, a, u) {
    let c = MathHypot(o - r, a - s, u - i);
    return c === 0 ? 0 : GF(
      (e - r) / c,
      (t - s) / c,
      (n - i) / c,
      (o - r) / c,
      (a - s) / c,
      (u - i) / c,
    );
  }
  function kF(e, t, n, r, s, i) {
    let o = to(e, t, 0, n, r, 0, s, i, 0);
    return o <= 0
      ? [n, r]
      : o >= 1
      ? [s, i]
      : [n + o * (s - n), r + o * (i - r)];
  }
  function HF(e, t, n, r, s, i, o, a, u) {
    let c = to(e, t, n, r, s, i, o, a, u);
    return c <= 0
      ? [r, s, i]
      : c >= 1
      ? [o, a, u]
      : [r + c * (o - r), s + c * (a - s), i + c * (u - i)];
  }
  function rY(e, t, n, r, s, i, o, a) {
    let u = to(e, t, 0, n, r, 0, s, i, 0);
    return u <= 0 && !o
      ? [n, r]
      : u >= 1 && !a
      ? [s, i]
      : [n + u * (s - n), r + u * (i - r)];
  }
  function j1(e, t, n, r, s, i) {
    let o = kF(e, t, n, r, s, i);
    return MathHypot(e - o[0], t - o[1]);
  }
  function J1(e, t, n, r, s, i, o, a, u) {
    let c = HF(e, t, n, r, s, i, o, a, u);
    return MathHypot(e - c[0], t - c[1], n - c[2]);
  }
  function sY(e, t, n, r, s, i, o) {
    let a = Math.atan2(t - r, e - n);
    if (Bm(a, i, o - i)) return [s * Math.cos(a) + n, s * Math.sin(a) + r];
  }
  function si(e, t, n = 1) {
    if (e === t) return true;
    if (!isFinite(e) || !isFinite(t)) return false;
    if (n > 50) {
      throw new Error(
        "Within " + (52 - n) + " bits isn't really approximate any more",
      );
    }
    let r = Math.max(Math.max(Math.abs(e), Math.abs(t)), 1),
      s = n === 1 ? .5 : Math.pow(.5, n);
    return r === r + s * Math.abs(t - e);
  }
  function iY(e) {
    return Math.round(e - .5) + .5;
  }
  function toFraction1(e, t = 1e6) {
    if (e === 1 / 0) return { n: 1 / 0, d: 1 };
    if (e === -1 / 0) return { n: -1 / 0, d: 1 };
    if (!isFinite(e)) return { n: NaN, d: 1 };
    let n, r = 0, s = 1, i = 1, o = 0, a, u;
    for (
      ;
      n = Math.floor(e),
        a = n * s + r,
        u = n * o + i,
        !(u > t || (r = s, i = o, s = a, o = u, e === n));
    ) e = 1 / (e - n);
    return { n: s, d: o };
  }
  var Gm = typeof self == "object" && self.self === self && self ||
      typeof global == "object" && global.global === global && global ||
      Function("return this")() || {},
    zm = Array.prototype,
    ax = Object.prototype,
    Q1 = typeof Symbol != "undefined" ? Symbol.prototype : null,
    aY = zm.push,
    sD = zm.slice,
    km = ax.toString,
    zF = ax.hasOwnProperty,
    UF = Array.isArray,
    K1 = Object.keys,
    eD = Object.create,
    iD = Gm.isNaN,
    qF = Gm.isFinite,
    ix = function () {};
  function Nr(e) {
    if (e instanceof Nr) return e;
    if (!(this instanceof Nr)) return new Nr(e);
    this._wrapped = e;
  }
  var uY = Nr.VERSION = "1.10.2";
  function Um(e, t, n) {
    if (t === void 0) return e;
    switch (n == null ? 3 : n) {
      case 1:
        return function (r) {
          return e.call(t, r);
        };
      case 3:
        return function (r, s, i) {
          return e.call(t, r, s, i);
        };
      case 4:
        return function (r, s, i, o) {
          return e.call(t, r, s, i, o);
        };
    }
    return function () {
      return e.apply(t, arguments);
    };
  }
  function oD(e, t, n) {
    return e == null
      ? bV
      : Ga(e)
      ? Um(e, t, n)
      : Bl(e) && !Vl(e)
      ? xV(e)
      : bD(e);
  }
  Nr.iteratee = aD;
  function aD(e, t) {
    return oD(e, t, 1 / 0);
  }
  function vo(e, t, n) {
    return Nr.iteratee !== aD ? Nr.iteratee(e, t) : oD(e, t, n);
  }
  function Ni(e, t) {
    return t = t == null ? e.length - 1 : +t, function () {
      for (
        var n = Math.max(arguments.length - t, 0), r = Array(n), s = 0;
        s < n;
        s++
      ) r[s] = arguments[s + t];
      switch (t) {
        case 0:
          return e.call(this, r);
        case 1:
          return e.call(this, arguments[0], r);
        case 2:
          return e.call(this, arguments[0], arguments[1], r);
      }
      var i = Array(t + 1);
      for (s = 0; s < t; s++) i[s] = arguments[s];
      return i[t] = r, e.apply(this, i);
    };
  }
  function $F(e) {
    if (!Bl(e)) return {};
    if (eD) return eD(e);
    ix.prototype = e;
    var t = new ix();
    return ix.prototype = null, t;
  }
  function uD(e) {
    return function (t) {
      return t == null ? void 0 : t[e];
    };
  }
  function wl(e, t) {
    return e != null && zF.call(e, t);
  }
  function cD(e, t) {
    for (var n = t.length, r = 0; r < n; r++) {
      if (e == null) return;
      e = e[t[r]];
    }
    return n ? e : void 0;
  }
  var YF = Math.pow(2, 53) - 1, du = uD("length");
  function Ri(e) {
    var t = du(e);
    return typeof t == "number" && t >= 0 && t <= YF;
  }
  function Fl(e, t, n) {
    t = Um(t, n);
    var r, s;
    if (Ri(e)) { for (r = 0, s = e.length; r < s; r++) t(e[r], r, e); }
    else {
      var i = gi(e);
      for (r = 0, s = i.length; r < s; r++) t(e[i[r]], i[r], e);
    }
    return e;
  }
  function qm(e, t, n) {
    t = vo(t, n);
    for (
      var r = !Ri(e) && gi(e), s = (r || e).length, i = Array(s), o = 0;
      o < s;
      o++
    ) {
      var a = r ? r[o] : o;
      i[o] = t(e[a], a, e);
    }
    return i;
  }
  function lD(e) {
    var t = function (n, r, s, i) {
      var o = !Ri(n) && gi(n), a = (o || n).length, u = e > 0 ? 0 : a - 1;
      for (i || (s = n[o ? o[u] : u], u += e); u >= 0 && u < a; u += e) {
        var c = o ? o[u] : u;
        s = r(s, n[c], c, n);
      }
      return s;
    };
    return function (n, r, s, i) {
      var o = arguments.length >= 3;
      return t(n, Um(r, i, 4), s, o);
    };
  }
  var cY = lD(1), lY = lD(-1);
  function XF(e, t, n) {
    var r = [];
    return t = vo(t, n),
      Fl(e, function (s, i, o) {
        t(s, i, o) && r.push(s);
      }),
      r;
  }
  function pY(e, t, n) {
    t = vo(t, n);
    for (var r = !Ri(e) && gi(e), s = (r || e).length, i = 0; i < s; i++) {
      var o = r ? r[i] : i;
      if (!t(e[o], o, e)) return false;
    }
    return true;
  }
  function dY(e, t, n) {
    t = vo(t, n);
    for (var r = !Ri(e) && gi(e), s = (r || e).length, i = 0; i < s; i++) {
      var o = r ? r[i] : i;
      if (t(e[o], o, e)) return true;
    }
    return false;
  }
  function Ll(e, t, n, r) {
    return Ri(e) || (e = Md(e)),
      (typeof n != "number" || r) && (n = 0),
      eV(e, t, n) >= 0;
  }
  var fY = Ni(function (e, t, n) {
    var r, s;
    return Ga(t) ? s = t : Vl(t) && (r = t.slice(0, -1), t = t[t.length - 1]),
      qm(e, function (i) {
        var o = s;
        if (!o) {
          if (r && r.length && (i = cD(i, r)), i == null) return;
          o = i[t];
        }
        return o == null ? o : o.apply(i, n);
      });
  });
  function pD(e, t) {
    return qm(e, bD(t));
  }
  function ZF(e, t, n) {
    var r = -1 / 0, s = -1 / 0, i, o;
    if (
      t == null || typeof t == "number" && typeof e[0] != "object" && e != null
    ) {
      e = Ri(e) ? e : Md(e);
      for (var a = 0, u = e.length; a < u; a++) {
        i = e[a], i != null && i > r && (r = i);
      }
    } else {t = vo(t, n),
        Fl(e, function (c, l, p) {
          o = t(c, l, p),
            (o > s || o === -1 / 0 && r === -1 / 0) && (r = c, s = o);
        });}
    return r;
  }
  function mY(e, t, n) {
    var r = 1 / 0, s = 1 / 0, i, o;
    if (
      t == null || typeof t == "number" && typeof e[0] != "object" && e != null
    ) {
      e = Ri(e) ? e : Md(e);
      for (var a = 0, u = e.length; a < u; a++) {
        i = e[a], i != null && i < r && (r = i);
      }
    } else {t = vo(t, n),
        Fl(e, function (c, l, p) {
          o = t(c, l, p),
            (o < s || o === 1 / 0 && r === 1 / 0) && (r = c, s = o);
        });}
    return r;
  }
  function yY(e) {
    return WF(e, 1 / 0);
  }
  function WF(e, t, n) {
    if (t == null || n) return Ri(e) || (e = Md(e)), e[nD(e.length - 1)];
    var r = Ri(e) ? cV(e) : Md(e), s = du(r);
    t = Math.max(Math.min(t, s), 0);
    for (var i = s - 1, o = 0; o < t; o++) {
      var a = nD(o, i), u = r[o];
      r[o] = r[a], r[a] = u;
    }
    return r.slice(0, t);
  }
  function gY(e, t, n) {
    var r = 0;
    return t = vo(t, n),
      pD(
        qm(e, function (s, i, o) {
          return { value: s, index: r++, criteria: t(s, i, o) };
        }).sort(function (s, i) {
          var o = s.criteria, a = i.criteria;
          if (o !== a) {
            if (o > a || o === void 0) return 1;
            if (o < a || a === void 0) return -1;
          }
          return s.index - i.index;
        }),
        "value",
      );
  }
  function $m(e, t) {
    return function (n, r, s) {
      var i = t ? [[], []] : {};
      return r = vo(r, s),
        Fl(n, function (o, a) {
          var u = r(o, a, n);
          e(i, o, u);
        }),
        i;
    };
  }
  var hY = $m(function (e, t, n) {
      wl(e, n) ? e[n].push(t) : e[n] = [t];
    }),
    bY = $m(function (e, t, n) {
      e[n] = t;
    }),
    xY = $m(function (e, t, n) {
      wl(e, n) ? e[n]++ : e[n] = 1;
    });
  function TY(e) {
    return e == null ? 0 : Ri(e) ? e.length : gi(e).length;
  }
  var IY = $m(function (e, t, n) {
    e[n ? 0 : 1].push(t);
  }, true);
  function Tc(e, t, n, r) {
    r = r || [];
    for (var s = r.length, i = 0, o = du(e); i < o; i++) {
      var a = e[i];
      if (Ri(a) && (Vl(a) || Hm(a))) {
        if (t) {
          for (var u = 0, c = a.length; u < c;) r[s++] = a[u++];
        } else Tc(a, t, n, r), s = r.length;
      } else n || (r[s++] = a);
    }
    return r;
  }
  function PY(e, t) {
    return Tc(e, t, false);
  }
  var EY = Ni(function (e, t) {
    return cx(e, t);
  });
  function ux(e, t, n, r) {
    hV(t) || (r = n, n = t, t = false), n != null && (n = vo(n, r));
    for (var s = [], i = [], o = 0, a = du(e); o < a; o++) {
      var u = e[o], c = n ? n(u, o, e) : u;
      t && !n
        ? ((!o || i !== c) && s.push(u), i = c)
        : n
        ? Ll(i, c) || (i.push(c), s.push(u))
        : Ll(s, u) || s.push(u);
    }
    return s;
  }
  var MY = Ni(function (e) {
    return ux(Tc(e, true, true));
  });
  var cx = Ni(function (e, t) {
    return t = Tc(t, true, true),
      XF(e, function (n) {
        return !Ll(t, n);
      });
  });
  function jF(e) {
    for (var t = e && ZF(e, du).length || 0, n = Array(t), r = 0; r < t; r++) {
      n[r] = pD(e, r);
    }
    return n;
  }
  var CY = Ni(jF);
  function dD(e) {
    return function (t, n, r) {
      n = vo(n, r);
      for (var s = du(t), i = e > 0 ? 0 : s - 1; i >= 0 && i < s; i += e) {
        if (n(t[i], i, t)) return i;
      }
      return -1;
    };
  }
  var JF = dD(1), QF = dD(-1);
  function KF(e, t, n, r) {
    n = vo(n, r, 1);
    for (var s = n(t), i = 0, o = du(e); i < o;) {
      var a = Math.floor((i + o) / 2);
      n(e[a]) < s ? i = a + 1 : o = a;
    }
    return i;
  }
  function fD(e, t, n) {
    return function (r, s, i) {
      var o = 0, a = du(r);
      if (typeof i == "number") {
        e > 0
          ? o = i >= 0 ? i : Math.max(i + a, o)
          : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1;
      } else if (n && i && a) return i = n(r, s), r[i] === s ? i : -1;
      if (s !== s) return i = t(sD.call(r, o, a), gV), i >= 0 ? i + o : -1;
      for (i = e > 0 ? o : a - 1; i >= 0 && i < a; i += e) {
        if (r[i] === s) return i;
      }
      return -1;
    };
  }
  var eV = fD(1, JF, KF), DY = fD(-1, QF);
  function SY(e, t) {
    if (t == null || t < 1) return [];
    for (var n = [], r = 0, s = e.length; r < s;) n.push(sD.call(e, r, r += t));
    return n;
  }
  function mD(e, t, n, r, s) {
    if (!(r instanceof t)) return e.apply(n, s);
    var i = $F(e.prototype), o = e.apply(i, s);
    return Bl(o) ? o : i;
  }
  var tV = Ni(function (e, t, n) {
      if (!Ga(e)) throw new TypeError("Bind must be called on a function");
      var r = Ni(function (s) {
        return mD(e, r, t, this, n.concat(s));
      });
      return r;
    }),
    Ym = Ni(function (e, t) {
      var n = Ym.placeholder,
        r = function () {
          for (var s = 0, i = t.length, o = Array(i), a = 0; a < i; a++) {
            o[a] = t[a] === n ? arguments[s++] : t[a];
          }
          for (; s < arguments.length;) o.push(arguments[s++]);
          return mD(e, r, this, this, o);
        };
      return r;
    });
  Ym.placeholder = Nr;
  var vY = Ni(function (e, t) {
    t = Tc(t, false, false);
    var n = t.length;
    if (n < 1) throw new Error("bindAll must be passed function names");
    for (; n--;) {
      var r = t[n];
      e[r] = tV(e[r], e);
    }
  });
  var yD = Ni(function (e, t, n) {
      return setTimeout(function () {
        return e.apply(null, n);
      }, t);
    }),
    OY = Ym(yD, Nr, 1);
  function NY(e, t, n) {
    var r, s, i, o, a = 0;
    n || (n = {});
    var u = function () {
        a = n.leading === false ? 0 : rD(),
          r = null,
          o = e.apply(s, i),
          r || (s = i = null);
      },
      c = function () {
        var l = rD();
        !a && n.leading === false && (a = l);
        var p = t - (l - a);
        return s = this,
          i = arguments,
          p <= 0 || p > t
            ? (r && (clearTimeout(r), r = null),
              a = l,
              o = e.apply(s, i),
              r || (s = i = null))
            : !r && n.trailing !== false && (r = setTimeout(u, p)),
          o;
      };
    return c.cancel = function () {
      clearTimeout(r), a = 0, r = s = i = null;
    },
      c;
  }
  function RY(e, t, n) {
    var r,
      s,
      i = function (a, u) {
        r = null, u && (s = e.apply(a, u));
      },
      o = Ni(function (a) {
        if (r && clearTimeout(r), n) {
          var u = !r;
          r = setTimeout(i, t), u && (s = e.apply(this, a));
        } else r = yD(i, t, this, a);
        return s;
      });
    return o.cancel = function () {
      clearTimeout(r), r = null;
    },
      o;
  }
  function nV(e) {
    return function () {
      return !e.apply(this, arguments);
    };
  }
  function rV(e, t) {
    var n;
    return function () {
      return --e > 0 && (n = t.apply(this, arguments)), e <= 1 && (t = null), n;
    };
  }
  var AY = Ym(rV, 2),
    gD = !{ toString: null }.propertyIsEnumerable("toString"),
    tD = [
      "valueOf",
      "isPrototypeOf",
      "toString",
      "propertyIsEnumerable",
      "hasOwnProperty",
      "toLocaleString",
    ];
  function hD(e, t) {
    var n = tD.length,
      r = e.constructor,
      s = Ga(r) && r.prototype || ax,
      i = "constructor";
    for (wl(e, i) && !Ll(t, i) && t.push(i); n--;) {
      i = tD[n], i in e && e[i] !== s[i] && !Ll(t, i) && t.push(i);
    }
  }
  function gi(e) {
    if (!Bl(e)) return [];
    if (K1) return K1(e);
    var t = [];
    for (var n in e) wl(e, n) && t.push(n);
    return gD && hD(e, t), t;
  }
  function lx(e) {
    if (!Bl(e)) return [];
    var t = [];
    for (var n in e) t.push(n);
    return gD && hD(e, t), t;
  }
  function Md(e) {
    for (var t = gi(e), n = t.length, r = Array(n), s = 0; s < n; s++) {
      r[s] = e[t[s]];
    }
    return r;
  }
  function sV(e) {
    for (var t = {}, n = gi(e), r = 0, s = n.length; r < s; r++) {
      t[e[n[r]]] = n[r];
    }
    return t;
  }
  function px(e, t) {
    return function (n) {
      var r = arguments.length;
      if (t && (n = Object(n)), r < 2 || n == null) return n;
      for (var s = 1; s < r; s++) {
        for (var i = arguments[s], o = e(i), a = o.length, u = 0; u < a; u++) {
          var c = o[u];
          (!t || n[c] === void 0) && (n[c] = i[c]);
        }
      }
      return n;
    };
  }
  var iV = px(lx), oV = px(gi);
  function aV(e, t, n) {
    return t in n;
  }
  var uV = Ni(function (e, t) {
      var n = {}, r = t[0];
      if (e == null) return n;
      Ga(r)
        ? (t.length > 1 && (r = Um(r, t[1])), t = lx(e))
        : (r = aV, t = Tc(t, false, false), e = Object(e));
      for (var s = 0, i = t.length; s < i; s++) {
        var o = t[s], a = e[o];
        r(a, o, e) && (n[o] = a);
      }
      return n;
    }),
    _Y = Ni(function (e, t) {
      var n = t[0], r;
      return Ga(n)
        ? (n = nV(n), t.length > 1 && (r = t[1]))
        : (t = qm(Tc(t, false, false), String),
          n = function (s, i) {
            return !Ll(t, i);
          }),
        uV(e, n, r);
    }),
    LY = px(lx, true);
  function cV(e) {
    return Bl(e) ? Vl(e) ? e.slice() : iV({}, e) : e;
  }
  function lV(e, t) {
    var n = gi(t), r = n.length;
    if (e == null) return !r;
    for (var s = Object(e), i = 0; i < r; i++) {
      var o = n[i];
      if (t[o] !== s[o] || !(o in s)) return false;
    }
    return true;
  }
  function ox(e, t, n, r) {
    if (e === t) return e !== 0 || 1 / e === 1 / t;
    if (e == null || t == null) return false;
    if (e !== e) return t !== t;
    var s = typeof e;
    return s !== "function" && s !== "object" && typeof t != "object"
      ? false
      : pV(e, t, n, r);
  }
  function pV(e, t, n, r) {
    e instanceof Nr && (e = e._wrapped), t instanceof Nr && (t = t._wrapped);
    var s = km.call(e);
    if (s !== km.call(t)) return false;
    switch (s) {
      case "[object RegExp]":
      case "[object String]":
        return "" + e == "" + t;
      case "[object Number]":
        return +e != +e ? +t != +t : +e == 0 ? 1 / +e === 1 / t : +e == +t;
      case "[object Date]":
      case "[object Boolean]":
        return +e == +t;
      case "[object Symbol]":
        return Q1.valueOf.call(e) === Q1.valueOf.call(t);
    }
    var i = s === "[object Array]";
    if (!i) {
      if (typeof e != "object" || typeof t != "object") return false;
      var o = e.constructor, a = t.constructor;
      if (
        o !== a && !(Ga(o) && o instanceof o && Ga(a) && a instanceof a) &&
        "constructor" in e && "constructor" in t
      ) return false;
    }
    n = n || [], r = r || [];
    for (var u = n.length; u--;) if (n[u] === e) return r[u] === t;
    if (n.push(e), r.push(t), i) {
      if (u = e.length, u !== t.length) return false;
      for (; u--;) if (!ox(e[u], t[u], n, r)) return false;
    } else {
      var c = gi(e), l;
      if (u = c.length, gi(t).length !== u) return false;
      for (; u--;) {
        if (l = c[u], !(wl(t, l) && ox(e[l], t[l], n, r))) return false;
      }
    }
    return n.pop(), r.pop(), true;
  }
  function ws(e, t) {
    return ox(e, t);
  }
  function wY(e) {
    return e == null
      ? true
      : Ri(e) && (Vl(e) || dV(e) || Hm(e))
      ? e.length === 0
      : gi(e).length === 0;
  }
  function Ai(e) {
    return function (t) {
      return km.call(t) === "[object " + e + "]";
    };
  }
  var Vl = UF || Ai("Array");
  function Bl(e) {
    var t = typeof e;
    return t === "function" || t === "object" && !!e;
  }
  var Hm = Ai("Arguments"),
    Ga = Ai("Function"),
    dV = Ai("String"),
    fV = Ai("Number"),
    FY = Ai("Date"),
    VY = Ai("RegExp"),
    BY = Ai("Error"),
    mV = Ai("Symbol"),
    GY = Ai("Map"),
    kY = Ai("WeakMap"),
    HY = Ai("Set"),
    zY = Ai("WeakSet");
  (function () {
    Hm(arguments) || (Hm = function (e) {
      return wl(e, "callee");
    });
  })();
  var yV = Gm.document && Gm.document.childNodes;
  typeof /./ != "function" && typeof Int8Array != "object" &&
    typeof yV != "function" && (Ga = function (e) {
      return typeof e == "function" || false;
    });
  function UY(e) {
    return !mV(e) && qF(e) && !iD(parseFloat(e));
  }
  function gV(e) {
    return fV(e) && iD(e);
  }
  function hV(e) {
    return e === true || e === false || km.call(e) === "[object Boolean]";
  }
  function bV(e) {
    return e;
  }
  function bD(e) {
    return Vl(e)
      ? function (t) {
        return cD(t, e);
      }
      : uD(e);
  }
  function xV(e) {
    return e = oV({}, e), function (t) {
      return lV(t, e);
    };
  }
  function nD(e, t) {
    return t == null && (t = e, e = 0),
      e + Math.floor(Math.random() * (t - e + 1));
  }
  var rD = Date.now || function () {
      return new Date().getTime();
    },
    xD = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;",
    },
    TV = sV(xD);
  function TD(e) {
    var t = function (i) {
        return e[i];
      },
      n = "(?:" + gi(e).join("|") + ")",
      r = RegExp(n),
      s = RegExp(n, "g");
    return function (i) {
      return i = i == null ? "" : "" + i, r.test(i) ? i.replace(s, t) : i;
    };
  }
  var ID = TD(xD), qY = TD(TV);
  var IV = 0;
  function $Y(e) {
    var t = ++IV + "";
    return e ? e + t : t;
  }
  var YY = Nr.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g,
  };
  function PD(e, t) {
    return e._chain ? Nr(t).chain() : t;
  }
  Fl(
    ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],
    function (e) {
      var t = zm[e];
      Nr.prototype[e] = function () {
        var n = this._wrapped;
        return t.apply(n, arguments),
          (e === "shift" || e === "splice") && n.length === 0 && delete n[0],
          PD(this, n);
      };
    },
  );
  Fl(["concat", "join", "slice"], function (e) {
    var t = zm[e];
    Nr.prototype[e] = function () {
      return PD(this, t.apply(this._wrapped, arguments));
    };
  });
  Nr.prototype.value = function () {
    return this._wrapped;
  };
  Nr.prototype.valueOf = Nr.prototype.toJSON = Nr.prototype.value;
  Nr.prototype.toString = function () {
    return String(this._wrapped);
  };
  function value(e, t = e, n = false) {
    if (isNaN(e) || !isFinite(e)) {
      return { string: "undefined", latex: "undefined", value: e };
    }
    if (e === 0) return { string: "0", latex: "0", value: e };
    Math.abs(e) > Math.abs(t) && (t = e);
    let r = toFraction1(e / Math.PI, 24),
      s,
      i,
      o,
      a,
      u,
      c,
      l = n ? DV(t) : CV(t);
    if (l && si(r.n / r.d * Math.PI, e, 3)) {
      return r.n === 0
        ? (s = "0", a = "0")
        : r.n === 1
        ? (s = "\u03C0", a = "\\pi")
        : r.n === -1
        ? (s = "-\u03C0", a = "-\\pi")
        : (s = r.n.toString() + "\u03C0", a = r.n.toString() + "\\pi"),
        r.d === 1
          ? (i = "", u = "")
          : (i = "/" + r.d.toString(), u = r.d.toString()),
        o = s + i,
        u === ""
          ? c = a
          : a[0] === "-"
          ? c = `-\\frac{${a.slice(1)}}{${u}}`
          : c = `\\frac{${a}}{${u}}`,
        { string: o, latex: c, value: r.n / r.d * Math.PI };
    }
    if (l) {
      return o = MV(ED(e.toFixed(dx(t)))),
        { string: o, latex: o, value: parseFloat(o) };
    }
    {
      let p = mx(e.toExponential(dx(t / e))).split("e"),
        f = p[0] === "1" && n ? "10" : p[0] + "\xD710",
        d = p[1].replace("+", "");
      return o = mx(e.toExponential(dx(t / e))).replace("+", ""),
        c = `${p[0]}\\times10^{${d}}`,
        {
          string: o,
          latex: c,
          mantissa: f,
          superscript: d,
          value: parseFloat(o),
        };
    }
  }
  function point(e, t, n, r) {
    let s = value(e, t), i = value(r(s.value), n);
    return [s, i];
  }
  var EV = /\.?0+$/;
  function ED(e) {
    return e.indexOf(".") === -1 ? e : e.replace(EV, "");
  }
  function mx(e) {
    let t = /\.?0+e/;
    return e.replace(t, "e");
  }
  function MV(e) {
    return e === "-0" ? "0" : e;
  }
  function CV(e) {
    return e = Math.abs(e), 1e-4 < e && e < 1e7;
  }
  function DV(e) {
    return e = Math.abs(e), .001 < e && e < 1e4;
  }
  var SV = 5, vV = 5;
  function dx(e) {
    return e = Math.abs(e),
      e = Math.max(e, 1e-16),
      Math.max(SV, Math.floor(vV + 1.5 - Math.log10(e)));
  }
  var MD = {
      zeroCutoff: 0,
      smallCutoff: .001,
      bigCutoff: 1e6,
      digits: 10,
      displayAsFraction: false,
      addEllipses: false,
      alwaysEmitImaginary: false,
      spaceConstrained: false,
    },
    DEFAULT_EVALUATION_LABEL_OPTIONS = {
      smallCutoff: 1e-6,
      bigCutoff: 1e9,
      digits: 12,
    },
    DEFAULT_COMPLEX_EVALUATION_LABEL_OPTIONS = {
      ...DEFAULT_EVALUATION_LABEL_OPTIONS,
      smallCutoff: 1e-4,
      bigCutoff: 1e6,
      digits: 9,
      scientificNotationDigits: 4,
      spaceConstrained: true,
    };
  function DD(e) {
    return 1e6 / Math.sqrt(Math.abs(e));
  }
  function canDisplayAsFraction(e) {
    let t = DD(e);
    if (t < 1 || t > 1e12) return false;
    let { n, d: r } = toFraction1(e, t);
    return r === 1 ? false : e === e + Math.pow(2, -3) * Math.abs(n / r - e);
  }
  function numericLabel(e, t) {
    var g;
    let {
        zeroCutoff: n,
        smallCutoff: r,
        bigCutoff: s,
        digits: i,
        displayAsFraction: o,
        addEllipses: a,
        spaceConstrained: u,
      } = { ...MD, ...t },
      c = (g = t == null ? void 0 : t.scientificNotationDigits) != null
        ? g
        : i - 2;
    if (isNaN(e) || !isFinite(e)) return { type: "undefined" };
    if (e === 0 || Math.abs(e) < n) return { type: "decimal", value: "0" };
    let p = mx(e.toExponential(c)).match(/([\d\.\-]+)e\+?([\d\-]+)/);
    if (!p) return { type: "undefined" };
    let f = parseInt(p[2], 10), d = f >= i;
    if (canDisplayAsFraction(e) && o) {
      let m = toFraction1(e, DD(e));
      return {
        type: "fraction",
        numerator: m.n.toString(),
        denominator: m.d.toString(),
      };
    } else {
      if (Math.abs(e) > s || Math.abs(e) < r || d) {
        return { type: "scientific", mantissa: p[1], exponent: p[2] };
      }
      {
        let m = ED(e.toPrecision(u && f < 0 ? i + f : i));
        return e !== window.Number(m) && a && (m += "..."),
          { type: "decimal", value: m };
      }
    }
  }
  function truncatedHTMLLabel(e, t) {
    let n = numericLabel(e, t);
    switch (n.type) {
      case "undefined":
        return "undefined";
      case "decimal":
        return n.value;
      case "scientific":
        return n.mantissa + "<span class='dcg-cross'>\xD7</span>10<sup>" +
          n.exponent + "</sup>";
      case "fraction":
        return n.denominator === "1"
          ? n.numerator
          : `${n.numerator}/${n.denominator}`;
      default:
        return n;
    }
  }
  function truncatedPlainmathLabel(e, t) {
    let n = numericLabel(e, t);
    switch (n.type) {
      case "undefined":
        return "undefined";
      case "decimal":
        return n.value;
      case "scientific":
        return n.mantissa + " * 10^" + n.exponent;
      case "fraction":
        return n.denominator === "1"
          ? n.numerator
          : `${n.numerator}/${n.denominator}`;
      default:
        return n;
    }
  }
  function truncatedLatexLabel(e, t) {
    let n = numericLabel(e, t);
    switch (n.type) {
      case "undefined":
        return "undefined";
      case "decimal":
        return n.value;
      case "scientific":
        return n.mantissa + "\\times10^{" + n.exponent + "}";
      case "fraction":
        return n.denominator === "1"
          ? n.numerator
          : n.numerator[0] === "-"
          ? `-\\frac{${n.numerator.slice(1)}}{${n.denominator}}`
          : `\\frac{${n.numerator}}{${n.denominator}}`;
      default:
        return n;
    }
  }
  function formatSymbol(e) {
    if (e.startsWith("_base_case")) {
      let [n, r, s] = e.split(":"), i = [];
      for (let o of s.split(",")) {
        let a = parseFloat(o);
        isNaN(a) ? i.push(formatSymbol(o)) : i.push(truncatedPlainmathLabel(a));
      }
      return `${formatSymbol(r)}(${i.join(",")})`;
    }
    e = e.replace("\\", "");
    let t = {
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03F5",
      varepsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      vartheta: "\u03D1",
      iota: "\u03B9",
      kappa: "\u03BA",
      varkappa: "\u03F0",
      lambda: "\u03BB",
      mu: "\u03BC",
      xi: "\u03BE",
      pi: "\u03C0",
      varpi: "\u03D6",
      rho: "\u03C1",
      varrho: "\u03F1",
      sigma: "\u03C3",
      varsigma: "\u03C2",
      tau: "\u03C4",
      phi: "\u03D5",
      varphi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      Gamma: "\u0393",
      Delta: "\u0394",
      Theta: "\u0398",
      Lambda: "\u039B",
      Xi: "\u039E",
      Pi: "\u03A0",
      Sigma: "\u03A3",
      Phi: "\u03A6",
      Psi: "\u03A8",
      Omega: "\u03A9",
      div: "\xF7",
      cdot: "\u22C5",
      times: "\xD7",
      lt: "<",
      gt: ">",
      le: "\u2264",
      ge: "\u2265",
      sim: "\u223C",
      ldots: "\u2026",
      prime: "\u2032",
      approx: "\u2248",
      to: "\u2192",
      "->": "\u2192",
      "<=": "\u2264",
      ">=": "\u2265",
    };
    return t.hasOwnProperty(e) ? t[e] : e;
  }
  function identifierToLatex(e) {
    let t = e.match(/^\$(\d+)$/);
    if (t) return `\\token{${t[1]}}`;
    let n = e.split("_"), r = "";
    return n[0].length > 1 && (r += "\\"),
      r += n[0],
      n[1] && (r += "_{" + n[1] + "}"),
      r;
  }
  function identifierToHTML(e) {
    if (!e) return "";
    let t = e.split("_");
    t[0] = formatSymbol(t[0]);
    let n = t.map(ID);
    return n[1] && (n[1] = "<sub>" + n[1] + "</sub>"), n.join("");
  }
  function latexToIdentifier(e) {
    let t = e.match(/\\token\{(\d+)\}/);
    return t
      ? `$${t[1]}`
      : (e = e.replace(/\\operatorname\{(.*)\}/, "$1"),
        e.replace(/[{}\\]/g, ""));
  }
  function trimLatex(e) {
    return e.replace(/^(\\ |\s|\\space(?![a-zA-Z]))+/, "").replace(
      /(\\ |\s|\\space(?![a-zA-Z]))+$/,
      "",
    );
  }
  function complexNumberLabel(e, t = {}, n = "latex") {
    let r = { ...MD, ...t },
      { alwaysEmitImaginary: s } = r,
      i = n === "latex" ? truncatedLatexLabel : truncatedHTMLLabel,
      [o, a] = [
        e[0] !== 0 ? i(e[0], r) : void 0,
        e[1] !== 0 || s ? i(Math.abs(e[1]), r) : void 0,
      ];
    return o === "undefined" || a === "undefined"
      ? "undefined"
      : o && a
      ? `${o}${e[1] >= 0 ? "+" : "-"}${a !== "1" ? `${a}` : ""}i`
      : a
      ? `${e[1] >= 0 ? "" : "-"}${a !== "1" ? `${a}` : ""}i`
      : o != null
      ? o
      : "0";
  }
  function complexPlainMathNumberLabel(e, t = {}) {
    let [n, r] = [
      e[0] !== 0 ? truncatedPlainmathLabel(e[0], t) : void 0,
      e[1] !== 0 ? truncatedPlainmathLabel(Math.abs(e[1]), t) : void 0,
    ];
    if (n === "undefined" || r === "undefined") return "undefined";
    let s = r != null && r.includes(" * ") || r != null && r.includes("/")
      ? " "
      : "";
    return n && r
      ? `${n}${e[1] > 0 ? " + " : " - "}${r !== "1" ? `${r}${s}` : ""}i`
      : r
      ? `${e[1] > 0 ? "" : "-"}${r !== "1" ? `${r}${s}` : ""}i`
      : n != null
      ? n
      : "0";
  }
  var Ht = {};
  ia(Ht, {
    actionMergeFreeVariable: () => OT,
    addArgumentsToDefinition: () => Zd,
    addTypeError: () => Fx,
    adjacentMixedNumber: () => Ty,
    adjacentNumbers: () => eI,
    andTypeError: () => Xx,
    ansUndefined: () => EP,
    assignmentsUnsupported: () => tf,
    badEqualitySlice: () => ca,
    badForInputListDependency: () => OP,
    badForIntervalDependency: () => NP,
    badImplicitCall: () => xy,
    badIntegralBoundDependency: () => xP,
    badLogExponent: () => hI,
    badProductBoundDependency: () => lP,
    badSampleSize: () => IP,
    badSumBoundDependency: () => cP,
    badSymbolContext: () => Kd,
    badTrigExponent: () => gI,
    badTupleDimensions: () => KT,
    baseCaseCannotDependOnRecursiveParameter: () => Ox,
    baseCaseTooComplicatedUsePiecewise: () => wd,
    baseCasesMustAllHaveSameReturnType: () => Ld,
    binaryOperatorMissingOperand: () => $d,
    blankExpression: () => Xd,
    boxplotBreadthInvalid: () => kT,
    boxplotOffsetInvalid: () => GT,
    cannotAssignColor: () => HI,
    cannotRedefine: () => Zl,
    cannotRestrict: () => kI,
    cannotRestrictWithEquality: () => zI,
    cannotSubscript: () => EI,
    cantCombineSphericalAndCylindrical: () => Oy,
    cdfMaxInvalid: () => FI,
    cdfMaxLessThanMin: () => VI,
    cdfMinInvalid: () => wI,
    cdfRequiresArguments: () => zT,
    cdfTooManyArguments: () => UT,
    clickableObjectAlreadyAssigned: () => WV,
    clickableObjectAssignmentNotDefined: () => ZV,
    clickableObjectAssignmentNotIdentifier: () => jV,
    clickableObjectInvalidExpression: () => JV,
    colonMissingCondition: () => TI,
    colorArity: () => XT,
    combineTypeError: () => yy,
    comparatorTypeError: () => Yx,
    complexPlottedTableCell: () => zV,
    complicatedDoubleInequality: () => Ly,
    complicatedPolarImplicit: () => WI,
    computedColumnHeader: () => UP,
    constantUnsupported: () => _c,
    coordinateAccessTypeError: () => jx,
    customRegressionsUnsupported: () => CP,
    cycle: () => MI,
    deeplyNested: () => _T,
    dependsOnDeletedGeoObject: () => GP,
    derivativeMissingBody: () => hP,
    derivativeTypeError: () => dT,
    derivativeTypeErrorRespect: () => fT,
    derivativeVariableTypeError: () => mT,
    differentialWithSuperscript: () => fP,
    distributionAsFunction: () => Vy,
    divideTypeError: () => Hx,
    domainMaxInvalid: () => _I,
    domainMaxLessThanMin: () => LI,
    domainMinInvalid: () => AI,
    dotLHSConstantNumberError: () => ly,
    dotLHSTypeError: () => tT,
    dotRHSPropertyError: () => nT,
    duplicateFunctionParameter: () => II,
    duplicateUpdateRules: () => CT,
    eachBaseCaseArgumentMustBeSimple: () => ay,
    emptyParen: () => Yd,
    emptyPipe: () => yI,
    emptyRadical: () => dI,
    emptyRadicalIndex: () => fI,
    emptySquareBracket: () => mI,
    emptySubscript: () => Ey,
    emptySuperscript: () => aI,
    equationRequired: () => wy,
    equationsUnsupported: () => Ua,
    eventHandlerTypeError: () => kd,
    expectedArgumentToBeButFound: () => Lx,
    exponentTypeError: () => zx,
    featureUnavailable: () => rf,
    fractionEmpty: () => oI,
    fractionMissingDenominator: () => iI,
    fractionMissingNumerator: () => sI,
    fractionsUnavailable: () => Uy,
    functionDefinitionsUnsupported: () => nf,
    functionNameAsParameter: () => PI,
    functionNotDefined: () => Dy,
    functionOnlyWorksInComplexMode: () => VD,
    functionRequiresNumberOfArguments: () => _x,
    functionTypeError: () => Hs,
    functionUnsupported: () => Li,
    geometryLengthTypeError: () => Kx,
    getLogInternalErrors: () => GV,
    gpuLongProduct: () => BT,
    gpuLongSum: () => VT,
    gpuMaxListSize: () => Oc,
    gpuUnsupportedFunction: () => Xl,
    gpuUnsupportedIntegral: () => FT,
    gpuVariableListLength: () => mu,
    gpuVariableProduct: () => hy,
    gpuVariableSum: () => gy,
    heterogeneousList: () => Hd,
    identifierAsFunction: () => Iy,
    identifierIsNotFunction: () => Py,
    illegalBinWidth: () => Qd,
    illegalDotCall: () => Gd,
    implicitsDisabled: () => ZI,
    incorrectProductLowerBound: () => uP,
    incorrectSumLowerBound: () => aP,
    indexTypeError: () => Bd,
    inequalitiesDisabled: () => Ry,
    inequalitiesUnsupported: () => Lc,
    integralArgumentTypeError: () => pT,
    integralLowerBoundTypeError: () => cT,
    integralMissingBody: () => gP,
    integralMissingBound: () => pP,
    integralMissingDifferential: () => dP,
    integralUpperBoundTypeError: () => lT,
    internal: () => U,
    invalidDependentFirstTableColumn: () => UV,
    invalidDoubleEquality3d: () => JI,
    invalidDoubleInequality3d: () => jI,
    invalidDoubleInequalityVariables: () => Ay,
    invalidFirstTableColumn: () => eP,
    invalidFunctionName: () => zy,
    invalidHalfEmptyRange: () => sP,
    invalidImplicitVariables: () => Ac,
    invalidImplicitVariables3d: () => YI,
    invalidInequalityVariables: () => $I,
    invalidIntervalComprehensionArity: () => HP,
    invalidIntervalComprehensionParameter: () => Jl,
    invalidIntervalComprehensionReturnType: () => kP,
    invalidLHS: () => UI,
    invalidNestedIntervalComprehension: () => zP,
    invalidOperatorName: () => cI,
    invalidRegressionParameter: () => tP,
    invalidSubscript: () => uI,
    invalidTableEntry: () => Wd,
    invalidTableHeader: () => KI,
    listComprehensionIncorrectInput: () => vP,
    listComprehensionInputListTypeError: () => SP,
    listTypeError: () => vc,
    logScaleBoxPlot: () => AT,
    logScaleDotPlot: () => RT,
    logScaleHistogram: () => NT,
    logScaleTypeError: () => Yl,
    logbaseUnsupported: () => MP,
    malformedList: () => QT,
    malformedPoint: () => JT,
    matrixAddDimensions: () => KV,
    matrixAssignment: () => QV,
    matrixElementTypeError: () => sB,
    matrixFractionalPower: () => nB,
    matrixInvalidVariable: () => iB,
    matrixMultiplyDimensions: () => tB,
    matrixPowerDimensions: () => rB,
    matrixSubtractDimensions: () => eB,
    maxListSize: () => zd,
    methodRequiresList: () => so,
    mismatchedBraces: () => bP,
    mismatchedDoubleInequality: () => _y,
    mixedComparatorChain: () => qx,
    mixedRestrictionEquation: () => wT,
    multipleEqualityRestrictions: () => LT,
    multiplyDefined: () => Wl,
    multiplyTypeError: () => Vd,
    multiplyTypeError2D: () => Gx,
    multiplyTypeError3D: () => kx,
    multiplyTypeErrorCross: () => Bx,
    negativeTypeError: () => Ux,
    nonArithmeticRange: () => Jd,
    nonListDoubleReducer: () => jd,
    nonListParameterizedReducer: () => rP,
    nonSquareDeterminant: () => qV,
    nonSquareInverse: () => YV,
    nonSquareTrace: () => $V,
    opaque: () => Fd,
    optimizationError: () => nP,
    orTypeError: () => Zx,
    parameterAlreadyDefined: () => Sy,
    parenthesesUnavailable: () => DP,
    pdfWrongArity: () => HT,
    percentMissingOf: () => TP,
    piecewiseBranchTypeError: () => gT,
    piecewiseConditionTypeError: () => fy,
    piecewiseMissingCondition: () => bI,
    piecewisePartMissingCondition: () => xI,
    pointTypeError: () => Wx,
    pointsUnsupported: () => Fc,
    polygonTwoNumbersError: () => Ud,
    polygonUnsupportedIn3d: () => ky,
    primeVariableTypeError: () => yT,
    primeWithoutParen: () => Cy,
    primedFunctionArity: () => Nc,
    productArgumentTypeError: () => uT,
    productInfiniteBoundError: () => dy,
    productLowerBoundTypeError: () => oT,
    productMissingBody: () => yP,
    productMissingBound: () => oP,
    productUpperBoundTypeError: () => aT,
    randomArity: () => $T,
    randomFromBroadcastDistribution: () => YT,
    recursionCyclicDependency: () => Nx,
    recursionDoesNotTerminate: () => Rx,
    recursionInRegression: () => xT,
    recursiveDepthExceeded: () => Ax,
    recursiveFunctionCannotDependOnFreeVariable: () => vx,
    recursiveFunctionMissingBaseCase: () => oy,
    recursiveFunctionMissingBaseCaseWithMetadata: () => Sx,
    regressionTypeError: () => PT,
    regressionsUnsupported: () => wc,
    selfReferentialBaseCase: () => CI,
    selfReferentialFunctions: () => Rc,
    setLogInternalErrors: () => Dx,
    shadowedIndex: () => vy,
    shadowedIntegrationVariable: () => By,
    shadowedListComprehensionInput: () => qy,
    singleVariableImplicitEquationsDisabled: () => XI,
    singularInverse: () => XV,
    sliderLimitReferencesExport: () => SI,
    sliderMaxInvalid: () => OI,
    sliderMaxLessThanMin: () => NI,
    sliderMinInvalid: () => vI,
    sliderStepInvalid: () => RI,
    substitutionAmbiguousComma: () => yu,
    substitutionBodyAction: () => aB,
    substitutionBodyDependsOnRegression: () => FP,
    substitutionDuplicateSymbol: () => VP,
    substitutionFunctionLHS: () => uf,
    substitutionIllegalLHS: () => af,
    substitutionInvalidAssignments: () => of,
    substitutionLocalLHS: () => wP,
    substitutionNested: () => $y,
    substitutionRecursiveCallLHS: () => BP,
    substitutionTypeError: () => oB,
    substitutionUnsupportedInterval: () => Yy,
    subtractTypeError: () => Vx,
    sumArgumentTypeError: () => iT,
    sumInfiniteBoundError: () => py,
    sumLowerBoundTypeError: () => rT,
    sumMissingBody: () => mP,
    sumMissingBound: () => iP,
    sumUpperBoundTypeError: () => sT,
    superscriptWithPrime: () => pI,
    tableEntryTypeError: () => bT,
    tableHeaderTypeError: () => hT,
    tableRegressionInvalidData: () => IT,
    tableRegressionLogWithNegative: () => HV,
    tableRegressionTypeError: () => TT,
    tdistWrongArity: () => qT,
    threeDLengthTypeError: () => eT,
    tickerMinStepNonNegativeNumber: () => DI,
    tokenWithSubscript: () => tI,
    tooManyArguments: () => by,
    tooManyVariables: () => rn,
    transformationDefinitionTypeError: () => Jx,
    transformationTypeError: () => Qx,
    ttestListTooShort: () => jl,
    unaryOperatorMissingLeft: () => nI,
    unaryOperatorMissingRight: () => rI,
    unexpectedEquality: () => wx,
    unexpectedInequality: () => cy,
    unexpectedPrime: () => My,
    unexpectedSubscript: () => lI,
    unexpectedSymbol: () => ks,
    unexportableTableRegression: () => qP,
    unplottableEqualityChain: () => QI,
    unplottableLongInequalityChain: () => $x,
    unplottablePolarFunction: () => qI,
    unrecognizedSymbol: () => uy,
    updateRuleFunctionLHS: () => vT,
    updateRuleIllegalLHS: () => ST,
    updateRuleLocalLHS: () => my,
    updateRuleNonIdentifierLHS: () => MT,
    updateRuleTypeError: () => ET,
    updateRuleUndefinedLHS: () => DT,
    useRForCylindricalCoordinates: () => GI,
    useRhoForSphericalCoordinates: () => BI,
    variableAsFunction: () => Fy,
    variableLengthDistributionList: () => sf,
    variableLengthIntegralDependsOnIntegrationVariable: () => LP,
    variableLengthProductBodyDependsOnIndex: () => _P,
    variableLengthSumBodyDependsOnIndex: () => AP,
    variableLengthTopLevelList: () => RP,
    variableSeed: () => PP,
    variableUnsupported: () => Hy,
    variablesUnsupported: () => ef,
    warnComplexImplicit: () => Ny,
    writeIntegral: () => Gy,
    wrongArity: () => Ao,
    wrongArityLengthAsCount: () => ZT,
    wrongDoubleReducerArity: () => qd,
    wrongParameterizedReducerArity: () => WT,
    zeroArgReducer: () => jT,
  });
  function Cd(e) {
    return { __isLocalizableNumericValue: true, value: e };
  }
  function WY(e) {
    return e && e.__isLocalizableNumericValue;
  }
  function E(e, t) {
    return { key: e, vars: t };
  }
  var ka = () => ({ type: "empty" }),
    dr = () => NV([-1 / 0, 1 / 0]),
    aa = () => bi([-1 / 0, 1 / 0]),
    bi = (e) => Wm(e, true),
    NV = (e) => Wm(e, false),
    Wm = (e, t) =>
      isNaN(e[0]) || isNaN(e[1]) || e[1] < e[0]
        ? ka()
        : { type: "interval", bounds: e, tight: t };
  function Fs(e) {
    return e.type === "empty";
  }
  function hi(e) {
    return Fs(e) || e.tight;
  }
  var Hl = (e, t) => {
      if (t === 0) return e > 0 ? aa() : ka();
      let n = -e / t, r = t < 0 ? [-1 / 0, n] : [n, 1 / 0];
      return bi(r);
    },
    Gn = (e, t) => {
      if (Fs(e) || Fs(t)) return ka();
      let n = [
          Math.max(e.bounds[0], t.bounds[0]),
          Math.min(e.bounds[1], t.bounds[1]),
        ],
        r = hi(e) && hi(t);
      return Wm(n, r);
    },
    Sd = (e, t) => {
      if (Fs(e)) return t;
      if (Fs(t)) return e;
      let n = [
          Math.min(e.bounds[0], t.bounds[0]),
          Math.max(e.bounds[1], t.bounds[1]),
        ],
        r;
      return !hi(e) && !hi(t)
        ? r = false
        : hi(e) && !hi(t)
        ? r = e.bounds[0] <= t.bounds[0] && e.bounds[1] >= t.bounds[1]
        : !hi(e) && hi(t)
        ? r = t.bounds[0] <= e.bounds[0] && t.bounds[1] >= e.bounds[1]
        : r = e.bounds[0] <= t.bounds[1] && t.bounds[0] <= e.bounds[1],
        Wm(n, r);
    },
    OD = (e, t, n) => {
      if (Fs(e)) return n;
      let r = Gn(e, t);
      return hi(e)
        ? (e.bounds[0] > -1 / 0 &&
          (r = Sd(r, Gn(bi([-1 / 0, e.bounds[0]]), n))),
          e.bounds[1] < 1 / 0 && (r = Sd(r, Gn(bi([e.bounds[1], 1 / 0]), n))))
        : r = Sd(r, Gn(n, dr())),
        r;
    };
  function Vs(e, t, n) {
    return { input: e, start: t, end: n };
  }
  function No(e, t) {
    return Vs(e, t, t);
  }
  function Bs(e, t) {
    if (e.input !== t.input) {
      throw new Error(
        "Programming Error: cannot form a span on different inputs",
      );
    }
    return Vs(e.input, e.start, t.end);
  }
  function Yn(e) {
    return e.input.slice(e.start, e.end);
  }
  var Ie = {};
  ia(Ie, {
    Action: () => Action,
    AngleMarker: () => AngleMarker,
    Any: () => Any,
    Arc: () => Arc,
    Bool: () => Bool,
    BroadcastableArg: () => ey,
    Circle: () => Circle,
    Complex: () => Complex,
    DirectedAngleMarker: () => DirectedAngleMarker,
    Distribution: () => Distribution,
    EmptyList: () => EmptyList,
    ErrorType: () => ErrorType,
    Line: () => Line,
    ListArgType: () => Km,
    ListOfAngleMarker: () => ListOfAngleMarker,
    ListOfAny: () => ListOfAny,
    ListOfArc: () => ListOfArc,
    ListOfBool: () => ListOfBool,
    ListOfCircle: () => ListOfCircle,
    ListOfColor: () => ListOfColor,
    ListOfComplex: () => ListOfComplex,
    ListOfDirectedAngleMarker: () => ListOfDirectedAngleMarker,
    ListOfDistribution: () => ListOfDistribution,
    ListOfLine: () => ListOfLine,
    ListOfMapInterval2DComplex: () => ListOfMapInterval2ToComplex,
    ListOfMapInterval2DPoint: () => ListOfMapInterval2ToPoint,
    ListOfMapInterval2DPoint3D: () => ListOfMapInterval2DPoint3D,
    ListOfMapIntervalComplex: () => ListOfMapIntervalComplex,
    ListOfMapIntervalPoint: () => ListOfMapIntervalPoint,
    ListOfMapIntervalPoint3D: () => ListOfMapIntervalPoint3D,
    ListOfNumber: () => ListOfNumber,
    ListOfNumberNC: () => ro,
    ListOfPoint: () => ListOfPoint,
    ListOfPoint3D: () => ListOfPoint3D,
    ListOfPolygon: () => ListOfPolygon,
    ListOfRay: () => ListOfRay,
    ListOfRestriction: () => ListOfRestriction,
    ListOfSegment: () => ListOfSegment,
    ListOfSegment3D: () => ListOfSegment3D,
    ListOfSphere3D: () => ListOfSphere3D,
    ListOfTone: () => ListOfTone,
    ListOfTransformation: () => ListOfTransformation,
    ListOfTriangle3D: () => ListOfTriangle3D,
    ListOfVector: () => ListOfVector,
    ListOfVector3D: () => ListOfVector3D,
    MapInterval2DComplex: () => MapInterval2ToComplex,
    MapInterval2DPoint: () => MapInterval2ToPoint,
    MapInterval2DPoint3D: () => MapInterval2DPoint3D,
    MapIntervalComplex: () => MapIntervalComplex,
    MapIntervalPoint: () => MapIntervalPoint,
    MapIntervalPoint3D: () => MapIntervalPoint3D,
    NoCoerceComplexToReal: () => Nd,
    Number: () => Number,
    NumberNC: () => Te,
    Point: () => Point,
    Point3D: () => Point3D,
    Polygon: () => Polygon,
    RGBColor: () => RGBColor,
    Ray: () => Ray,
    Restriction: () => Restriction,
    SeedType: () => SeedType,
    Segment: () => Segment,
    Segment3D: () => Segment3D,
    Sphere3D: () => Sphere3D,
    Tone: () => Tone,
    Transformation: () => Transformation,
    Triangle3D: () => Triangle3D,
    TupleTypeMap: () => zl,
    UNKNOWN_RETURN_TYPE: () => FV,
    Union: () => Qn,
    Vector: () => Vector,
    Vector3D: () => Vector3D,
    allListTypes: () => ii,
    allTupleTypes: () => hx,
    allValueTypes: () => RV,
    angleTypes: () => Tx,
    assertTypeIsOneOf: () => za,
    broadcastArg: () => oi,
    broadcastable: () => Ae,
    commonCoerceableType: () => fu,
    commonCoerceableTypeWithBroadcast: () => Ha,
    elementType: () => Ve,
    getAllowedTypesForArg: () => Ad,
    hasListType: () => wn,
    hasMapType: () => Ix,
    isEligibleForBroadcast: () => ty,
    isGeometryType: () => vd,
    isList: () => j,
    isMapOrListOfMap: () => ua,
    isMultipliableElementType: () => bx,
    isOneOf: () => Od,
    isSubType: () => _i,
    isSubTypeOrCoercible: () => kn,
    isSubTypeOrNonComplexCoercible: () => Ec,
    isSummableElementType: () => $l,
    isTypeOrListOfType: () => se,
    isValidOnLogScales: () => Ul,
    listArg: () => Rd,
    listType: () => vn,
    mapType: () => Px,
    multipliableElementTypes: () => Jm,
    prettyPrint: () => oe,
    repr: () => at,
    signature: () => kt,
    straightTypes: () => Qm,
    summableElementTypes: () => ql,
    typeSatisfiesArgType: () => ny,
    typeSatisfiesArgTypeUncoerced: () => Mc,
    valueTypes: () => RD,
    variadicMinCount: () => _r,
    vectorTypes: () => xx,
  });
  function jm(e, t) {
    return t ? vn(e) : e;
  }
  function _i(e, t) {
    return e === EmptyList && j(t) || t === ListOfAny && j(e) ||
        t === Any && !j(e)
      ? true
      : e === t;
  }
  function kn(e, t) {
    if (e === void 0) return false;
    if (_i(e, t)) return true;
    j(e) && j(t) && t !== EmptyList && (e = Ve(e), t = Ve(t));
    let n = t;
    switch (e) {
      case AngleMarker:
      case DirectedAngleMarker:
      case Restriction:
      case Number:
      case Complex:
        return n === Number || n === Complex;
      default:
        return false;
    }
  }
  function Ec(e, t) {
    return t === Number && e === Complex ||
        t === ListOfNumber && e === ListOfComplex
      ? false
      : kn(e, t);
  }
  function fu(e, t) {
    if (_i(e, t)) return t;
    if (_i(t, e)) return e;
    let n = j(e);
    if (n != j(t)) return;
    let r = jm(Complex, n);
    if (e === r && kn(t, r)) return r;
    if (t === r && kn(e, r)) return r;
    let s = jm(Number, n);
    if (kn(e, s) && kn(t, s)) {
      let i = jm(AngleMarker, n), o = jm(DirectedAngleMarker, n);
      return e === i && t === o || e === o && t === i ? void 0 : s;
    }
  }
  function Ha(e, t) {
    return j(e) && wn(t)
      ? fu(e, vn(t))
      : wn(e) && j(t)
      ? fu(vn(e), t)
      : fu(e, t);
  }
  var Any = 0,
    Number = 1,
    Bool = 2,
    Point = 3,
    Distribution = 4,
    Action = 5,
    ListOfAny = 6,
    ListOfNumber = 7,
    ListOfBool = 8,
    ListOfPoint = 9,
    ListOfDistribution = 10,
    EmptyList = 11,
    ErrorType = 12,
    SeedType = 13,
    RGBColor = 14,
    ListOfColor = 15,
    Polygon = 16,
    ListOfPolygon = 17,
    Segment = 18,
    ListOfSegment = 19,
    Circle = 20,
    ListOfCircle = 21,
    Arc = 22,
    ListOfArc = 23,
    Line = 24,
    ListOfLine = 25,
    Ray = 26,
    ListOfRay = 27,
    AngleMarker = 28,
    ListOfAngleMarker = 29,
    DirectedAngleMarker = 30,
    ListOfDirectedAngleMarker = 31,
    Transformation = 32,
    ListOfTransformation = 33,
    Vector = 34,
    ListOfVector = 35,
    Restriction = 36,
    ListOfRestriction = 37,
    Complex = 38,
    ListOfComplex = 39,
    Tone = 50,
    ListOfTone = 51,
    Point3D = 100,
    ListOfPoint3D = 101,
    Segment3D = 102,
    ListOfSegment3D = 103,
    Triangle3D = 104,
    ListOfTriangle3D = 105,
    Sphere3D = 106,
    ListOfSphere3D = 107,
    Vector3D = 108,
    ListOfVector3D = 109,
    MapIntervalPoint = 200,
    MapIntervalPoint3D = 201,
    MapInterval2ToPoint = 202,
    MapInterval2DPoint3D = 203,
    ListOfMapIntervalPoint = 204,
    ListOfMapIntervalPoint3D = 205,
    ListOfMapInterval2ToPoint = 206,
    ListOfMapInterval2DPoint3D = 207,
    MapIntervalComplex = 208,
    MapInterval2ToComplex = 209,
    ListOfMapIntervalComplex = 210,
    ListOfMapInterval2ToComplex = 211,
    RD = {
      Any: Any,
      Number: Number,
      Bool: Bool,
      Complex: Complex,
      ListOfComplex: ListOfComplex,
      Point: Point,
      Point3D: Point3D,
      Distribution: Distribution,
      Action: Action,
      ListOfAny: ListOfAny,
      ListOfNumber: ListOfNumber,
      ListOfBool: ListOfBool,
      ListOfPoint: ListOfPoint,
      ListOfPoint3D: ListOfPoint3D,
      ListOfDistribution: ListOfDistribution,
      EmptyList: EmptyList,
      ErrorType: ErrorType,
      SeedType: SeedType,
      RGBColor: RGBColor,
      ListOfColor: ListOfColor,
      Polygon: Polygon,
      ListOfPolygon: ListOfPolygon,
      Segment: Segment,
      ListOfSegment: ListOfSegment,
      Circle: Circle,
      ListOfCircle: ListOfCircle,
      Arc: Arc,
      ListOfArc: ListOfArc,
      Line: Line,
      ListOfLine: ListOfLine,
      Ray: Ray,
      ListOfRay: ListOfRay,
      Vector: Vector,
      ListOfVector: ListOfVector,
      Restriction: Restriction,
      ListOfRestriction: ListOfRestriction,
      AngleMarker: AngleMarker,
      ListOfAngleMarker: ListOfAngleMarker,
      DirectedAngleMarker: DirectedAngleMarker,
      ListOfDirectedAngleMarker: ListOfDirectedAngleMarker,
      Transformation: Transformation,
      ListOfTransformation: ListOfTransformation,
      Segment3D: Segment3D,
      ListOfSegment3D: ListOfSegment3D,
      Triangle3D: Triangle3D,
      ListOfTriangle3D: ListOfTriangle3D,
      Sphere3D: Sphere3D,
      ListOfSphere3D: ListOfSphere3D,
      Vector3D: Vector3D,
      ListOfVector3D: ListOfVector3D,
      Tone: Tone,
      ListOfTone: ListOfTone,
      MapIntervalPoint: MapIntervalPoint,
      MapIntervalComplex: MapIntervalComplex,
      MapIntervalPoint3D: MapIntervalPoint3D,
      MapInterval2ToPoint: MapInterval2ToPoint,
      MapInterval2ToComplex: MapInterval2ToComplex,
      MapInterval2DPoint3D: MapInterval2DPoint3D,
      ListOfMapIntervalPoint: ListOfMapIntervalPoint,
      ListOfMapIntervalComplex: ListOfMapIntervalComplex,
      ListOfMapIntervalPoint3D: ListOfMapIntervalPoint3D,
      ListOfMapInterval2ToPoint: ListOfMapInterval2ToPoint,
      ListOfMapInterval2ToComplex: ListOfMapInterval2ToComplex,
      ListOfMapInterval2DPoint3D: ListOfMapInterval2DPoint3D,
    },
    zl = {
      [Point]: [Number, Number],
      [Point3D]: [Number, Number, Number],
      [Complex]: [Number, Number],
    },
    Qn = class e {
      constructor(t, { coerceComplexToReal: n }) {
        this.types = t;
        this.coerceComplexToReal = n;
      }
      static of(t, n = { coerceComplexToReal: true }) {
        return new e(t, n);
      }
      getTypes() {
        return this.types;
      }
    },
    RV = Object.values(RD),
    AV = Object.keys(zl).map(parseFloat),
    hx = Qn.of(AV);
  function at(e) {
    switch (e) {
      case Any:
        return "Any";
      case Number:
        return "Number";
      case Bool:
        return "Bool";
      case Complex:
        return "Complex";
      case Point:
        return "Point";
      case Point3D:
        return "Point3D";
      case Distribution:
        return "Distribution";
      case Action:
        return "Action";
      case ListOfAny:
        return "ListOfAny";
      case ListOfNumber:
        return "ListOfNumber";
      case ListOfBool:
        return "ListOfBool";
      case ListOfComplex:
        return "ListOfComplex";
      case ListOfPoint:
        return "ListOfPoint";
      case ListOfPoint3D:
        return "ListOfPoint3D";
      case ListOfDistribution:
        return "ListOfDistribution";
      case EmptyList:
        return "EmptyList";
      case ErrorType:
        return "ErrorType";
      case SeedType:
        return "SeedType";
      case RGBColor:
        return "RGBColor";
      case ListOfColor:
        return "ListOfColor";
      case Polygon:
        return "Polygon";
      case ListOfPolygon:
        return "ListOfPolygon";
      case Segment:
        return "Segment";
      case ListOfSegment:
        return "ListOfSegment";
      case Circle:
        return "Circle";
      case ListOfCircle:
        return "ListOfCircle";
      case Arc:
        return "Arc";
      case ListOfArc:
        return "ListOfArc";
      case Line:
        return "Line";
      case ListOfLine:
        return "ListOfLine";
      case Ray:
        return "Ray";
      case ListOfRay:
        return "ListOfRay";
      case Vector:
        return "Vector";
      case ListOfVector:
        return "ListOfVector";
      case Restriction:
        return "Restriction";
      case ListOfRestriction:
        return "ListOfRestriction";
      case AngleMarker:
        return "Angle";
      case ListOfAngleMarker:
        return "ListOfAngle";
      case DirectedAngleMarker:
        return "DirectedAngle";
      case ListOfDirectedAngleMarker:
        return "ListOfDirectedAngle";
      case Transformation:
        return "Transformation";
      case ListOfTransformation:
        return "ListOfTransformation";
      case Segment3D:
        return "Segment3D";
      case ListOfSegment3D:
        return "ListOfSegment3D";
      case Vector3D:
        return "Vector3D";
      case ListOfVector3D:
        return "ListOfVector3D";
      case Triangle3D:
        return "Triangle3D";
      case ListOfTriangle3D:
        return "ListOfTriangle3D";
      case Sphere3D:
        return "Sphere3D";
      case ListOfSphere3D:
        return "ListOfSphere3D";
      case Tone:
        return "Tone";
      case ListOfTone:
        return "ListOfTone";
      case MapIntervalPoint:
        return "MapIntervalPoint";
      case MapIntervalComplex:
        return "MapIntervalComplex";
      case MapIntervalPoint3D:
        return "MapIntervalPoint3D";
      case MapInterval2ToPoint:
        return "MapInterval2ToPoint";
      case MapInterval2ToComplex:
        return "MapInterval2ToComplex";
      case MapInterval2DPoint3D:
        return "MapInterval2DPoint3D";
      case ListOfMapIntervalPoint:
        return "ListOfMapIntervalPoint";
      case ListOfMapIntervalComplex:
        return "ListOfMapIntervalComplex";
      case ListOfMapIntervalPoint3D:
        return "ListOfMapIntervalPoint3D";
      case ListOfMapInterval2ToPoint:
        return "ListOfMapInterval2ToPoint";
      case ListOfMapInterval2ToComplex:
        return "ListOfMapInterval2ToComplex";
      case ListOfMapInterval2DPoint3D:
        return "ListOfMapInterval2DPoint3D";
      default:
        let t = e;
        throw new Error(`Invalid type: ${t}`);
    }
  }
  function oe(e, t) {
    var r;
    let n = (r = t == null ? void 0 : t.specifyPointDimensions) != null
      ? r
      : false;
    switch (e) {
      case Any:
        return E("shared-calculator-label-value-type-any");
      case Number:
        return E("shared-calculator-label-value-type-number");
      case Bool:
        return E("shared-calculator-label-value-type-bool");
      case Complex:
        return E("shared-calculator-label-value-type-complex");
      case Point:
        return n
          ? E("shared-calculator-label-value-type-point2d")
          : E("shared-calculator-label-value-type-point");
      case Point3D:
        return E("shared-calculator-label-value-type-point3d");
      case Distribution:
        return E("shared-calculator-label-value-type-distribution");
      case Action:
        return E("shared-calculator-label-value-type-action");
      case ListOfAny:
        return E("shared-calculator-label-value-type-list-of-any");
      case ListOfNumber:
        return E("shared-calculator-label-value-type-list-of-numbers");
      case ListOfBool:
        return E("shared-calculator-label-value-type-list-of-bool");
      case ListOfComplex:
        return E("shared-calculator-label-value-type-list-of-complex");
      case ListOfPoint:
        return n
          ? E("shared-calculator-label-value-type-list-of-2d-points")
          : E("shared-calculator-label-value-type-list-of-points");
      case ListOfPoint3D:
        return E("shared-calculator-label-value-type-list-of-3d-points");
      case ListOfDistribution:
        return E("shared-calculator-label-value-type-list-of-distributions");
      case EmptyList:
        return E("shared-calculator-label-value-type-empty-list");
      case ErrorType:
        return E("shared-calculator-label-value-type-error");
      case SeedType:
        return E("shared-calculator-label-value-type-seed");
      case RGBColor:
        return E("shared-calculator-label-value-type-color");
      case ListOfColor:
        return E("shared-calculator-label-value-type-list-of-colors");
      case Polygon:
        return E("shared-calculator-label-value-type-polygon");
      case ListOfPolygon:
        return E("shared-calculator-label-value-type-list-of-polygons");
      case Segment:
        return E("shared-calculator-label-value-type-segment");
      case ListOfSegment:
        return E("shared-calculator-label-value-type-list-of-segments");
      case Circle:
        return E("shared-calculator-label-value-type-circle");
      case ListOfCircle:
        return E("shared-calculator-label-value-type-list-of-circles");
      case Arc:
        return E("shared-calculator-label-value-type-arc");
      case ListOfArc:
        return E("shared-calculator-label-value-type-list-of-arcs");
      case Line:
        return E("shared-calculator-label-value-type-line");
      case ListOfLine:
        return E("shared-calculator-label-value-type-list-of-lines");
      case Ray:
        return E("shared-calculator-label-value-type-ray");
      case ListOfRay:
        return E("shared-calculator-label-value-type-list-of-rays");
      case Vector:
        return E("shared-calculator-label-value-type-vector");
      case ListOfVector:
        return E("shared-calculator-label-value-type-list-of-vectors");
      case Restriction:
        return E("shared-calculator-label-value-type-restriction");
      case ListOfRestriction:
        return E("shared-calculator-label-value-type-list-of-restrictions");
      case AngleMarker:
        return E("shared-calculator-label-value-type-angle");
      case ListOfAngleMarker:
        return E("shared-calculator-label-value-type-list-of-angles");
      case DirectedAngleMarker:
        return E("shared-calculator-label-value-type-directed-angle");
      case ListOfDirectedAngleMarker:
        return E("shared-calculator-label-value-type-list-of-directed-angles");
      case Transformation:
        return E("shared-calculator-label-value-type-transformation");
      case ListOfTransformation:
        return E("shared-calculator-label-value-type-list-of-transformations");
      case Segment3D:
        return E("shared-calculator-label-value-type-segment3d");
      case ListOfSegment3D:
        return E("shared-calculator-label-value-type-list-of-segment3d");
      case Vector3D:
        return E("shared-calculator-label-value-type-vector3d");
      case ListOfVector3D:
        return E("shared-calculator-label-value-type-list-of-vector3d");
      case Triangle3D:
        return E("shared-calculator-label-value-type-triangle3d");
      case ListOfTriangle3D:
        return E("shared-calculator-label-value-type-list-of-triangle3d");
      case Sphere3D:
        return E("shared-calculator-label-value-type-sphere3d");
      case ListOfSphere3D:
        return E("shared-calculator-label-value-type-list-of-sphere3d");
      case Tone:
        return E("shared-calculator-label-value-type-tone");
      case ListOfTone:
        return E("shared-calculator-label-value-type-list-of-tone");
      case MapIntervalPoint:
      case MapInterval2ToPoint:
        return E("shared-calculator-label-value-type-lambda-point");
      case MapIntervalComplex:
      case MapInterval2ToComplex:
        return E("shared-calculator-label-value-type-lambda-complex");
      case MapIntervalPoint3D:
      case MapInterval2DPoint3D:
        return E("shared-calculator-label-value-type-lambda-point3d");
      case ListOfMapIntervalPoint:
      case ListOfMapInterval2ToPoint:
        return E("shared-calculator-label-value-type-list-of-lambda-point");
      case ListOfMapIntervalComplex:
      case ListOfMapInterval2ToComplex:
        return E("shared-calculator-label-value-type-list-of-lambda-complex");
      case ListOfMapIntervalPoint3D:
      case ListOfMapInterval2DPoint3D:
        return E("shared-calculator-label-value-type-list-of-lambda-point3d");
      default:
        let s = e;
        throw new Error(`Invalid type: ${s}`);
    }
  }
  var _V = [
      ListOfAny,
      ListOfNumber,
      ListOfBool,
      ListOfComplex,
      ListOfRestriction,
      ListOfPoint,
      ListOfPoint3D,
      ListOfDistribution,
      EmptyList,
      ListOfColor,
      ListOfPolygon,
      ListOfSegment,
      ListOfCircle,
      ListOfArc,
      ListOfLine,
      ListOfRay,
      ListOfVector,
      ListOfAngleMarker,
      ListOfDirectedAngleMarker,
      ListOfTransformation,
      ListOfSegment3D,
      ListOfVector3D,
      ListOfTriangle3D,
      ListOfSphere3D,
      ListOfTone,
      ListOfMapIntervalPoint,
      ListOfMapIntervalComplex,
      ListOfMapIntervalPoint3D,
      ListOfMapInterval2ToPoint,
      ListOfMapInterval2ToComplex,
      ListOfMapInterval2DPoint3D,
    ],
    ii = Qn.of(_V, { coerceComplexToReal: false }),
    eX = {
      [ListOfAny]: Any,
      [EmptyList]: Number,
      [ListOfNumber]: Number,
      [ListOfBool]: Bool,
      [ListOfComplex]: Complex,
      [ListOfRestriction]: Restriction,
      [ListOfPoint]: Point,
      [ListOfPoint3D]: Point3D,
      [ListOfDistribution]: Distribution,
      [ListOfColor]: RGBColor,
      [ListOfPolygon]: Polygon,
      [ListOfSegment]: Segment,
      [ListOfCircle]: Circle,
      [ListOfArc]: Arc,
      [ListOfLine]: Line,
      [ListOfRay]: Ray,
      [ListOfVector]: Vector,
      [ListOfAngleMarker]: AngleMarker,
      [ListOfDirectedAngleMarker]: DirectedAngleMarker,
      [ListOfTransformation]: Transformation,
      [ListOfSegment3D]: Segment3D,
      [ListOfVector3D]: Vector3D,
      [ListOfTriangle3D]: Triangle3D,
      [ListOfSphere3D]: Sphere3D,
      [ListOfTone]: Tone,
      [ListOfMapIntervalPoint]: MapIntervalPoint,
      [ListOfMapIntervalComplex]: MapIntervalComplex,
      [ListOfMapIntervalPoint3D]: MapIntervalPoint3D,
      [ListOfMapInterval2ToPoint]: MapInterval2ToPoint,
      [ListOfMapInterval2ToComplex]: MapInterval2ToComplex,
      [ListOfMapInterval2DPoint3D]: MapInterval2DPoint3D,
    };
  function j(e) {
    switch (e) {
      case void 0:
        return false;
      case ListOfAny:
      case ListOfNumber:
      case ListOfBool:
      case ListOfComplex:
      case ListOfRestriction:
      case ListOfPoint:
      case ListOfPoint3D:
      case ListOfDistribution:
      case ListOfColor:
      case ListOfPolygon:
      case ListOfSegment:
      case ListOfCircle:
      case ListOfArc:
      case ListOfLine:
      case ListOfRay:
      case ListOfVector:
      case ListOfAngleMarker:
      case ListOfDirectedAngleMarker:
      case ListOfTransformation:
      case ListOfSegment3D:
      case ListOfVector3D:
      case ListOfTriangle3D:
      case ListOfSphere3D:
      case ListOfTone:
      case ListOfMapIntervalPoint:
      case ListOfMapIntervalComplex:
      case ListOfMapIntervalPoint3D:
      case ListOfMapInterval2ToPoint:
      case ListOfMapInterval2ToComplex:
      case ListOfMapInterval2DPoint3D:
        return true;
      case EmptyList:
        return true;
      case Any:
      case Number:
      case Bool:
      case Complex:
      case Restriction:
      case Point:
      case Point3D:
      case Distribution:
      case ErrorType:
      case SeedType:
      case RGBColor:
      case Action:
      case Polygon:
      case Segment:
      case Circle:
      case Arc:
      case Line:
      case Ray:
      case Vector:
      case AngleMarker:
      case DirectedAngleMarker:
      case Transformation:
      case Segment3D:
      case Vector3D:
      case Triangle3D:
      case Tone:
      case Sphere3D:
      case MapIntervalPoint:
      case MapIntervalComplex:
      case MapIntervalPoint3D:
      case MapInterval2ToPoint:
      case MapInterval2ToComplex:
      case MapInterval2DPoint3D:
        return false;
      default:
        throw new Error(`Invalid type: ${e}`);
    }
  }
  function Ve(e) {
    switch (e) {
      case EmptyList:
      case ListOfNumber:
        return Number;
      case ListOfBool:
        return Bool;
      case ListOfComplex:
        return Complex;
      case ListOfRestriction:
        return Restriction;
      case ListOfPoint:
        return Point;
      case ListOfPoint3D:
        return Point3D;
      case ListOfDistribution:
        return Distribution;
      case ListOfColor:
        return RGBColor;
      case ListOfPolygon:
        return Polygon;
      case ListOfSegment3D:
        return Segment3D;
      case ListOfVector3D:
        return Vector3D;
      case ListOfTriangle3D:
        return Triangle3D;
      case ListOfSphere3D:
        return Sphere3D;
      case ListOfAny:
        return Any;
      case ListOfSegment:
        return Segment;
      case ListOfCircle:
        return Circle;
      case ListOfArc:
        return Arc;
      case ListOfLine:
        return Line;
      case ListOfRay:
        return Ray;
      case ListOfVector:
        return Vector;
      case ListOfAngleMarker:
        return AngleMarker;
      case ListOfDirectedAngleMarker:
        return DirectedAngleMarker;
      case ListOfTransformation:
        return Transformation;
      case ListOfTone:
        return Tone;
      case ListOfMapIntervalPoint:
        return MapIntervalPoint;
      case ListOfMapIntervalComplex:
        return MapIntervalComplex;
      case ListOfMapIntervalPoint3D:
        return MapIntervalPoint3D;
      case ListOfMapInterval2ToPoint:
        return MapInterval2ToPoint;
      case ListOfMapInterval2ToComplex:
        return MapInterval2ToComplex;
      case ListOfMapInterval2DPoint3D:
        return MapInterval2DPoint3D;
      case Any:
      case Number:
      case Bool:
      case Complex:
      case Point:
      case Point3D:
      case Distribution:
      case ErrorType:
      case SeedType:
      case RGBColor:
      case Action:
      case Polygon:
      case Segment:
      case Circle:
      case Arc:
      case Line:
      case Ray:
      case Vector:
      case Restriction:
      case AngleMarker:
      case DirectedAngleMarker:
      case Transformation:
      case Segment3D:
      case Vector3D:
      case Triangle3D:
      case Sphere3D:
      case Tone:
      case MapIntervalPoint:
      case MapIntervalComplex:
      case MapIntervalPoint3D:
      case MapInterval2ToPoint:
      case MapInterval2ToComplex:
      case MapInterval2DPoint3D:
        throw new Error("Type " + at(e) + " does not implement elementType.");
      default:
        let t = e;
        throw new Error(`Invalid type: ${t}`);
    }
  }
  function vn(e) {
    switch (e) {
      case Any:
        return ListOfAny;
      case Number:
        return ListOfNumber;
      case Bool:
        return ListOfBool;
      case Complex:
        return ListOfComplex;
      case Restriction:
        return ListOfRestriction;
      case Point:
        return ListOfPoint;
      case Point3D:
        return ListOfPoint3D;
      case Distribution:
        return ListOfDistribution;
      case RGBColor:
        return ListOfColor;
      case Polygon:
        return ListOfPolygon;
      case Segment:
        return ListOfSegment;
      case Circle:
        return ListOfCircle;
      case Arc:
        return ListOfArc;
      case Line:
        return ListOfLine;
      case Ray:
        return ListOfRay;
      case Vector:
        return ListOfVector;
      case AngleMarker:
        return ListOfAngleMarker;
      case DirectedAngleMarker:
        return ListOfDirectedAngleMarker;
      case Transformation:
        return ListOfTransformation;
      case Segment3D:
        return ListOfSegment3D;
      case Vector3D:
        return ListOfVector3D;
      case Triangle3D:
        return ListOfTriangle3D;
      case Sphere3D:
        return ListOfSphere3D;
      case Tone:
        return ListOfTone;
      case MapIntervalPoint:
        return ListOfMapIntervalPoint;
      case MapIntervalComplex:
        return ListOfMapIntervalComplex;
      case MapIntervalPoint3D:
        return ListOfMapIntervalPoint3D;
      case MapInterval2ToPoint:
        return ListOfMapInterval2ToPoint;
      case MapInterval2ToComplex:
        return ListOfMapInterval2ToComplex;
      case MapInterval2DPoint3D:
        return ListOfMapInterval2DPoint3D;
      case EmptyList:
      case ListOfNumber:
      case ListOfBool:
      case ListOfComplex:
      case ListOfRestriction:
      case ListOfPoint:
      case ListOfPoint3D:
      case ListOfDistribution:
      case ListOfColor:
      case ListOfPolygon:
      case ListOfSegment:
      case ListOfCircle:
      case ListOfArc:
      case ListOfLine:
      case ListOfRay:
      case ListOfVector:
      case ListOfAngleMarker:
      case ListOfDirectedAngleMarker:
      case ListOfTransformation:
      case ListOfSegment3D:
      case ListOfVector3D:
      case ListOfTriangle3D:
      case ListOfSphere3D:
      case ListOfAny:
      case ListOfTone:
      case ErrorType:
      case SeedType:
      case Action:
      case ListOfMapIntervalPoint:
      case ListOfMapIntervalComplex:
      case ListOfMapIntervalPoint3D:
      case ListOfMapInterval2ToPoint:
      case ListOfMapInterval2ToComplex:
      case ListOfMapInterval2DPoint3D:
        throw new Error("Type " + at(e) + " does not implement listType.");
      default:
        let t = e;
        throw new Error(`Invalid type: ${t}`);
    }
  }
  function wn(e) {
    switch (e) {
      case Any:
      case Number:
      case Bool:
      case Complex:
      case Restriction:
      case Point:
      case Point3D:
      case Distribution:
      case RGBColor:
      case Polygon:
      case Segment:
      case Circle:
      case Arc:
      case Line:
      case Ray:
      case Vector:
      case AngleMarker:
      case DirectedAngleMarker:
      case Transformation:
      case Segment3D:
      case Vector3D:
      case Triangle3D:
      case Sphere3D:
      case Tone:
      case MapIntervalPoint:
      case MapIntervalComplex:
      case MapIntervalPoint3D:
      case MapInterval2ToPoint:
      case MapInterval2ToComplex:
      case MapInterval2DPoint3D:
        return true;
      case EmptyList:
      case ListOfNumber:
      case ListOfBool:
      case ListOfComplex:
      case ListOfRestriction:
      case ListOfPoint:
      case ListOfPoint3D:
      case ListOfDistribution:
      case ListOfColor:
      case ListOfPolygon:
      case ListOfSegment:
      case ListOfCircle:
      case ListOfArc:
      case ListOfLine:
      case ListOfRay:
      case ListOfVector:
      case ListOfAngleMarker:
      case ListOfDirectedAngleMarker:
      case ListOfTransformation:
      case ListOfSegment3D:
      case ListOfVector3D:
      case ListOfTriangle3D:
      case ListOfSphere3D:
      case ListOfAny:
      case ListOfTone:
      case ListOfMapIntervalPoint:
      case ListOfMapIntervalComplex:
      case ListOfMapIntervalPoint3D:
      case ListOfMapInterval2ToPoint:
      case ListOfMapInterval2ToComplex:
      case ListOfMapInterval2DPoint3D:
      case SeedType:
      case Action:
      case ErrorType:
        return false;
      default:
        throw new Error(`Invalid type: ${e}`);
    }
  }
  function vd(e) {
    if (e === void 0) return false;
    switch (e) {
      case Point:
      case Polygon:
      case Segment:
      case Circle:
      case Arc:
      case Line:
      case Ray:
      case Vector:
      case AngleMarker:
      case DirectedAngleMarker:
      case Transformation:
        return true;
      default:
        return false;
    }
  }
  function Ul(e) {
    switch (e) {
      case Number:
      case Any:
      case Bool:
      case Complex:
      case Restriction:
      case Point:
      case Distribution:
      case Action:
      case ListOfAny:
      case ListOfNumber:
      case ListOfBool:
      case ListOfComplex:
      case ListOfRestriction:
      case ListOfPoint:
      case ListOfDistribution:
      case EmptyList:
      case ErrorType:
      case SeedType:
      case RGBColor:
      case ListOfColor:
      case Tone:
      case ListOfTone:
        return true;
      case Point3D:
      case ListOfPoint3D:
      case Segment3D:
      case ListOfSegment3D:
      case Vector3D:
      case ListOfVector3D:
      case Triangle3D:
      case ListOfTriangle3D:
      case Sphere3D:
      case ListOfSphere3D:
      case Polygon:
      case ListOfPolygon:
      case Segment:
      case ListOfSegment:
      case Circle:
      case ListOfCircle:
      case Arc:
      case ListOfArc:
      case Line:
      case ListOfLine:
      case Ray:
      case ListOfRay:
      case Vector:
      case ListOfVector:
      case AngleMarker:
      case ListOfAngleMarker:
      case DirectedAngleMarker:
      case ListOfDirectedAngleMarker:
      case Transformation:
      case ListOfTransformation:
      case MapIntervalPoint:
      case MapIntervalComplex:
      case MapIntervalPoint3D:
      case MapInterval2ToPoint:
      case MapInterval2ToComplex:
      case MapInterval2DPoint3D:
      case ListOfMapIntervalPoint:
      case ListOfMapIntervalComplex:
      case ListOfMapIntervalPoint3D:
      case ListOfMapInterval2ToPoint:
      case ListOfMapInterval2ToComplex:
      case ListOfMapInterval2DPoint3D:
        return false;
      default:
        let t = e;
        throw new Error(`Invalid type: ${t}`);
    }
  }
  function Od(e, t) {
    for (let n of t) if (e === n) return true;
    return false;
  }
  var ql = [Number, Complex, Point, Point3D];
  function $l(e) {
    return ql.includes(e);
  }
  var Jm = [Number, Complex];
  function bx(e) {
    return Jm.includes(e);
  }
  var Qm = Qn.of([Line, Ray, Segment, Vector]),
    xx = Qn.of([Vector, Vector3D]),
    Tx = Qn.of([AngleMarker, DirectedAngleMarker]);
  function se(e, t) {
    return e === void 0
      ? false
      : e === t
      ? true
      : j(e)
      ? e === EmptyList ? true : Ve(e) === t
      : false;
  }
  function ua(e) {
    return Od(e, [
      MapIntervalPoint,
      MapIntervalComplex,
      MapIntervalPoint3D,
      MapInterval2ToPoint,
      MapInterval2ToComplex,
      MapInterval2DPoint3D,
      ListOfMapIntervalPoint,
      ListOfMapIntervalComplex,
      ListOfMapIntervalPoint3D,
      ListOfMapInterval2ToPoint,
      ListOfMapInterval2ToComplex,
      ListOfMapInterval2DPoint3D,
    ]);
  }
  var AD = {
      [Point]: MapIntervalPoint,
      [Complex]: MapIntervalComplex,
      [Point3D]: MapIntervalPoint3D,
    },
    LV = {
      [Point]: MapInterval2ToPoint,
      [Complex]: MapInterval2ToComplex,
      [Point3D]: MapInterval2DPoint3D,
    };
  function Ix(e) {
    return AD[e] !== void 0;
  }
  function Px(e, t) {
    let n = t === 1 ? AD[e] : LV[e];
    if (n === void 0) {
      throw new Error(`Unexpected return type for map: ${at(e)}`);
    }
    return n;
  }
  function za(e, t) {
    if (!Od(e, t)) {
      throw new Error(
        `Programming error: expected one of ${t.map(at)} but found ${
          e && at(e)
        } instead.`,
      );
    }
  }
  var FV = Symbol("UNKNOWN_RETURN_TYPE");
  function _D(e) {
    return typeof e == "object" && e.type === "variadic";
  }
  function _r(e, t) {
    return { type: "variadic", initial: new Array(t).fill(e), rest: e };
  }
  var Ex = class {
      constructor(t, n) {
        this.argTypes = t;
        this.productContext = n;
        this.minArity = this.argTypes.length,
          this.maxArity = this.argTypes.length;
      }
      argTypeAtIndex(t) {
        if (!(t > this.argTypes.length - 1)) return this.argTypes[t];
      }
      matches(t) {
        return LD(this, t);
      }
      satisfiesPolicy(t) {
        return t.is3dProduct()
          ? this.productContext["3d"]
          : t.isGeometryEnabled()
          ? this.productContext.geometry
          : this.productContext.graphing;
      }
    },
    Mx = class {
      constructor(t, n) {
        this.productContext = n;
        this.maxArity = void 0;
        this.initial = t.initial,
          this.rest = t.rest,
          this.minArity = this.initial.length;
      }
      argTypeAtIndex(t) {
        return t < this.initial.length ? this.initial[t] : this.rest;
      }
      matches(t) {
        return LD(this, t);
      }
      satisfiesPolicy(t) {
        return t.is3dProduct()
          ? this.productContext["3d"]
          : t.isGeometryEnabled()
          ? this.productContext.geometry
          : this.productContext.graphing;
      }
    };
  function LD(e, t) {
    return e.maxArity !== void 0 && e.maxArity < t.length
      ? false
      : !!t.every((n, r) => {
        if (n === void 0) return true;
        let s = e.argTypeAtIndex(r);
        return s === void 0 ? false : ny(n, s);
      });
  }
  var Nd = class {
      constructor(t) {
        this.arg = t;
        this.coerceComplexToReal = false;
      }
      getTypes() {
        return typeof this.arg == "number" ? [this.arg] : this.arg.getTypes();
      }
    },
    Te = new Nd(Number),
    ro = new Nd(ListOfNumber),
    Km = class {
      constructor(t) {
        typeof t == "number"
          ? (this.coerceComplexToReal = t === Number, this.nodeTypes = [vn(t)])
          : (this.coerceComplexToReal = t.coerceComplexToReal,
            this.nodeTypes = t.getTypes().map(vn));
      }
      getTypes() {
        return this.nodeTypes;
      }
    };
  function Rd(e) {
    return new Km(e);
  }
  var ey = class {
    constructor(t) {
      if (typeof t == "number") {
        this.coerceComplexToReal = t === Number, this.nodeTypes = [t, vn(t)];
      } else {
        this.coerceComplexToReal = t.coerceComplexToReal, this.nodeTypes = [];
        for (let n of t.getTypes()) this.nodeTypes.push(n, vn(n));
      }
    }
    getTypes() {
      return this.nodeTypes;
    }
  };
  function ty(e) {
    return typeof e == "number"
      ? wn(e)
      : e instanceof Qn
      ? e.types.every(ty)
      : false;
  }
  function oi(e) {
    return new ey(e);
  }
  function kt(e, t = {}) {
    let n = { geometry: true, "3d": true, graphing: true, ...t };
    return _D(e) ? new Mx(e, n) : new Ex(e, n);
  }
  function Ae(e, t = {}) {
    return _D(e)
      ? kt(
        { type: "variadic", initial: e.initial.map(oi), rest: oi(e.rest) },
        t,
      )
      : kt(e.map(oi), t);
  }
  function ny(e, t) {
    if (typeof t == "number") return kn(e, t);
    {
      let n = t.getTypes();
      return t.coerceComplexToReal
        ? n.some((r) => kn(e, r))
        : n.some((r) => Ec(e, r));
    }
  }
  function Mc(e, t) {
    return typeof t == "number" ? _i(e, t) : t.getTypes().some((r) => _i(e, r));
  }
  function Ad(e, t) {
    let n = new Set();
    for (let r of e) {
      let s = r.argTypeAtIndex(t);
      if (s === void 0) continue;
      let i = VV(s);
      for (let o of i) n.add(o);
    }
    return [...n];
  }
  function VV(e) {
    return typeof e == "number" ? [e] : e.getTypes();
  }
  function BV(e) {
    return !e || e[0].type === "none" && e[1].type === "none"
      ? "NONE"
      : e[1].type === "none"
      ? "X"
      : e[0].type === "none"
      ? "Y"
      : "XY";
  }
  function wD(e, t) {
    let n = BV(t);
    switch (e) {
      case "NONE":
        return "NONE";
      case "AUTO":
        return n;
      case "XY":
        return n;
      case "X":
        return n === "X" || n === "XY" ? "X" : "NONE";
      case "Y":
        return n === "Y" || n === "XY" ? "Y" : "NONE";
      default:
        return "NONE";
    }
  }
  var Yt = class {
    constructor() {
      this.localFrameID = void 0;
      this._dependencies = [],
        this._optionalDependencies = [],
        this._updateSymbols = [],
        this._scope = {
          definitions: [],
          dependencies: [],
          substitutionDependencies: [],
          scopes: [],
        },
        this._exports = [],
        this.metaData = { extraDepNodes: [] },
        this.userData = {};
    }
    getDefaultDragMode(t) {
      return "NONE";
    }
    setInputSpan(t) {
      this._inputSpan = t;
    }
    getInputString() {
      return this._inputSpan === void 0 ? "" : Yn(this._inputSpan);
    }
    getInputSpan() {
      return this._inputSpan;
    }
    shouldExportAns() {
      return false;
    }
    getAnsVariable() {
      return this.shouldExportAns() && this.userData &&
          this.userData.hasOwnProperty("index")
        ? ["ans_" + this.userData.index]
        : [];
    }
    addDependency(t) {
      this._dependencies.indexOf(t) === -1 && this._dependencies.push(t),
        this._scope.dependencies.indexOf(t) === -1 &&
        this._scope.dependencies.push(t);
    }
    addDependencies(t) {
      for (let n = 0; n < t.length; n++) this.addDependency(t[n]);
    }
    addOptionalDependencies(t) {
      for (let n = 0; n < t.length; n++) {
        let r = t[n];
        this._dependencies.indexOf(r) === -1 && this._dependencies.push(r),
          this._optionalDependencies.indexOf(r) === -1 &&
          this._optionalDependencies.push(r);
      }
    }
    addUpdateSymbol(t) {
      this._dependencies.indexOf(t) === -1 && this._dependencies.push(t),
        this._updateSymbols.indexOf(t) === -1 && this._updateSymbols.push(t);
    }
    addSubstitutionDependencies(t) {
      for (let n = 0; n < t.length; n++) {
        let r = t[n];
        if (this._dependencies.indexOf(r) === -1) {
          throw new Error(
            "Programming error: substitution dependency " + r +
              " must also be registered as a regular dependency",
          );
        }
        this._scope.substitutionDependencies.indexOf(r) === -1 &&
          this._scope.substitutionDependencies.push(r);
      }
    }
    mergeDependencies(...t) {
      for (let n = 0; n < t.length; n++) {
        let r = t[n];
        for (let s = 0; s < r._dependencies.length; s++) {
          this._dependencies.indexOf(r._dependencies[s]) === -1 &&
            this._dependencies.push(r._dependencies[s]);
        }
        for (let s = 0; s < r._updateSymbols.length; s++) {
          this._updateSymbols.indexOf(r._updateSymbols[s]) === -1 &&
            this._updateSymbols.push(r._updateSymbols[s]);
        }
        for (let s = 0; s < r._scope.dependencies.length; s++) {
          this._scope.dependencies.indexOf(r._scope.dependencies[s]) === -1 &&
            this._scope.dependencies.push(r._scope.dependencies[s]);
        }
        for (let s = 0; s < r._scope.substitutionDependencies.length; s++) {
          this._scope.substitutionDependencies.indexOf(
                r._scope.substitutionDependencies[s],
              ) === -1 &&
            this._scope.substitutionDependencies.push(
              r._scope.substitutionDependencies[s],
            );
        }
        this.addOptionalDependencies(r.getOptionalDependencies()),
          Array.prototype.push.apply(this._scope.scopes, r._scope.scopes);
      }
    }
    mergeDependenciesInScope(t, n, r, s) {
      let i = r.getScope(),
        o = {
          kind: t,
          definitions: n,
          dependencies: i.dependencies,
          substitutionDependencies: i.substitutionDependencies,
          scopes: i.scopes,
          functionDefinitionSymbol: s == null
            ? void 0
            : s.functionDefinitionSymbol,
        };
      this._scope.scopes.push(o);
      for (let a = 0; a < r._dependencies.length; a++) {
        let u = r._dependencies[a];
        !n.includes(u) && !this._dependencies.includes(u) &&
          this._dependencies.push(u);
      }
      for (let a = 0; a < r._updateSymbols.length; a++) {
        this._updateSymbols.indexOf(r._updateSymbols[a]) === -1 &&
          this._updateSymbols.push(r._updateSymbols[a]);
      }
      this.addOptionalDependencies(r.getOptionalDependencies());
    }
    getDependencies() {
      return this._dependencies;
    }
    graphmodeDependencies(t, n) {
      return this.getDependencies();
    }
    getOptionalDependencies() {
      return this._optionalDependencies;
    }
    getUpdateSymbols() {
      return this._updateSymbols;
    }
    getScope() {
      return this._scope;
    }
    dependsOn(t) {
      return this._dependencies.indexOf(t) > -1;
    }
    getExports(t) {
      let n = this._exports || [];
      if (this.userData && "id" in this.userData) {
        let r = this.userData.id;
        n = n.concat(["idref_" + r]);
      }
      return t.ansEnabled() && (n = n.concat(this.getAnsVariable())), n;
    }
    getLegalExports(t) {
      return this.getExports(t).filter((n) => !t.assignmentForbidden(n));
    }
    exportsSymbol(t) {
      return this._exports.indexOf(t) > -1;
    }
    exportTo(t, n, r) {
      let s = [], i = this.getLegalExports(t);
      for (let o = 0; o < i.length; o++) {
        let a = i[o];
        if (r[a]) return s;
        r[a] = n.blocksExport ? n : this, s.push(a);
      }
      return s;
    }
    getOperator() {
      return this.operator || "=";
    }
    isInequality() {
      return false;
    }
    isShadeBetween() {
      return false;
    }
    getEvaluationInfo() {
      return false;
    }
    shouldPromoteToSlider(t) {
      return false;
    }
    getSliderVariables(t, n, r) {
      let s = t.sliderVariables(r != null ? r : n.getDependencies());
      return n.valueType === Point || n.valueType === ListOfPoint ||
          n.valueType === Point3D ||
          n.valueType === ListOfPoint3D || n.valueType === Complex ||
          n.valueType === ListOfComplex
        ? t.is3dPolicy()
          ? s.includes("t") && !s.includes("u") && !s.includes("v")
            ? s.filter((i) => i != "t")
            : !s.includes("t") && (s.includes("u") || s.includes("v"))
            ? s.filter((i) => i != "u" && i != "v")
            : s
          : s.filter((i) => !t.validParametricVariable(i))
        : s;
    }
    getCompiledDerivative() {
      let t = this.getDependencies();
      return this.takeDerivative(t[0] || "x").getCompiledFunction();
    }
    asValue() {}
    boundDomain(t) {
      return dr();
    }
    getCursorContext() {}
    polynomialOrder(t) {}
    getPolynomialCoefficients(t) {}
    asTypedValue() {}
    asCompilerValue() {}
    substitute(t) {}
    getExpressionType(t, n) {}
    tableInfo(t, n) {}
    analyze(t, n, r) {
      throw U(`Node ${this.type} does not define analyze.`);
    }
    analyzeFourFunction(t, n, r) {}
    analyzeScientific(t, n, r) {}
    analyzeSingleExpressionScientific(t, n, r) {}
    getGraphMode(t, n) {}
    getMoveStrategy(t, n, r, s) {}
  };
  var v = class extends Yt {
    constructor(n) {
      super();
      this.isError = true;
      this._msg = n, this.blocksExport = true;
    }
    evaluateOnce(n) {
      return this._msg;
    }
    getError() {
      return this._msg;
    }
    setDependencies(n) {
      return this.addDependencies(n), this;
    }
    setActionValue(n) {
      this.actionValue = n;
    }
    allowExport() {
      return this.blocksExport = false, this;
    }
    setCursorContext(n) {
      this.cursorContext = n;
    }
    getCursorContext() {
      return this.cursorContext;
    }
  };
  var _d = { real: true, imag: true, conj: true, arg: true },
    FD = Object.keys(_d);
  var Cc = class {
    constructor(t) {
      this.singleExpression = t.singleExpression;
    }
    isGeometryEnabled() {
      return false;
    }
    is3dProduct() {
      return false;
    }
    is3dPolicy() {
      return false;
    }
    isComplexEnabled() {
      return false;
    }
    isRecursionEnabled() {
      return false;
    }
    polygonUnsupportedPreferTriangle() {
      return false;
    }
    areAllScalesLinear() {
      return true;
    }
    assignmentForbidden(t) {
      return t.slice(0, 3) !== "ans";
    }
    isValidSlider(t) {
      return false;
    }
    sliderVariables() {
      return [];
    }
    graphingEnabled() {
      return false;
    }
    ansEnabled() {
      return !this.singleExpression;
    }
    dimensionVarsEnabled() {
      return false;
    }
    disabledFeatures() {
      return [
        "Sum",
        "Product",
        "Integral",
        "List",
        "Derivative",
        "Piecewise",
        "Restriction",
        "Norm",
        "Exponent",
        "PercentOf",
        "Substitution",
      ];
    }
    shouldIncludeFunctionParametersInRandomSeed() {
      return true;
    }
  };
  var iy = false;
  function Dx(e) {
    iy = e;
  }
  function GV() {
    return iy;
  }
  function kV(...e) {
    iy && console.error(...e);
  }
  function U(e) {
    if (iy) {
      let t = e instanceof Error ? e : new Error(`${e}`);
      return kV(t.stack),
        new v(E("shared-calculator-error-internal-error", { msg: t.message }));
    }
    return new v(E("shared-calculator-error-parse-error"));
  }
  function oy(e) {
    let t = e.length, n = e[0];
    return new v(
      E("shared-calculator-error-recursion-missing-base-case", {
        count: Cd(t),
        lastSymbol: formatSymbol(n),
        symbols: e.slice(1).map((r) => formatSymbol(r)).join("', '"),
      }),
    );
  }
  function Sx(e, t) {
    let n = oy(e);
    return n.recursionMetadata = t, n;
  }
  function vx(e) {
    return new v(
      E("shared-calculator-error-recursion-base-case-free-variable", {
        freeVariable: formatSymbol(e),
      }),
    );
  }
  function Ox(e) {
    return new v(
      E("shared-calculator-error-recursion-base-case-free-variable", {
        freeVariable: formatSymbol(e),
      }),
    );
  }
  function Ld({ blockExport: e }) {
    let t = new v(E("shared-calculator-error-recursion-base-case-same-type"));
    return e || t.allowExport(), t;
  }
  function wd() {
    return new v(
      E("shared-calculator-error-recursion-base-case-too-complicated"),
    );
  }
  function ay() {
    return new v(
      E("shared-calculator-error-recursion-base-case-argument-non-number"),
    );
  }
  function Nx() {
    return new v(E("shared-calculator-error-recursion-does-not-terminate"));
  }
  function Rx() {
    return new v(E("shared-calculator-error-recursion-does-not-terminate"));
  }
  function Ax() {
    return new v(E("shared-calculator-error-recursion-depth-limit-exceeded"));
  }
  function _x(e, t) {
    return new v(
      E("shared-calculator-error-recursion-wrong-arity", {
        fnSymbol: formatSymbol(e),
        count: Cd(t),
      }),
    );
  }
  function Lx(e, t, n, { blockExport: r }) {
    let s = new v(
      E("shared-calculator-error-recursion-argument-type", {
        index: e + 1,
        expectedType: t,
        foundType: n,
      }),
    );
    return r || s.allowExport(), s;
  }
  function Fd() {
    return new v(E("shared-calculator-error-parse-error"));
  }
  function uy(e) {
    return e = formatSymbol(e),
      new v(E("shared-calculator-error-unrecognized-symbol", { symbol: e }));
  }
  function cy() {
    return new v(E("shared-calculator-error-unexpected-inequality"));
  }
  function wx() {
    return new v(E("shared-calculator-error-unexpected-equality"));
  }
  function ks(e) {
    return e = formatSymbol(e),
      new v(E("shared-calculator-error-unexpected-symbol", { symbol: e }));
  }
  function Fx(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-add-type-error", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function Vx(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-subtract-type-error", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function Vd(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-multiply-type-error", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function Bx(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-multiply-type-error-cross", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function Gx(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-multiply-type-error-2d", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function kx(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-multiply-type-error-3d", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function Hx(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-divide-type-error", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function zx(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-exponent-type-error", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function Ux(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-negative-type-error", { symbol: e[0] }),
    );
    return t || n.allowExport(), n;
  }
  function qx() {
    return new v(E("shared-calculator-error-mixed-comparator-chain"));
  }
  function $x() {
    return new v(
      E("shared-calculator-error-unplottable-long-inequality-chain"),
    );
  }
  function Yx(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-comparator-type-error", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function Xx(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-operator-type-error", {
        symbol: "and",
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function Zx(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-operator-type-error", {
        symbol: "or",
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function vc(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-list-type-error", { symbol1: e[0] }),
    );
    return t || n.allowExport(), n;
  }
  function Wx(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-point-type-error", {
        symbol1: e,
        symbol2: oe(Point),
      }),
    );
    return t || n.allowExport(), n;
  }
  function Bd(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-index-type-error", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function jx(e, t, { blockExport: n }) {
    let r = new v(
      E("shared-calculator-error-coordinate-access-type-error", {
        coordinate: t,
        symbol: e[0],
      }),
    );
    return n || r.allowExport(), r;
  }
  function Hs(e, t, { blockExport: n }) {
    let r;
    switch (t.length) {
      case 1:
        r = new v(
          E("shared-calculator-error-function-type-error-1", {
            fn: formatSymbol(e),
            arg: t[0],
          }),
        );
        break;
      case 2:
        r = new v(
          E("shared-calculator-error-function-type-error-2", {
            fn: formatSymbol(e),
            arg1: t[0],
            arg2: t[1],
          }),
        );
        break;
      default:
        r = new v(
          E("shared-calculator-error-function-type-error-many", {
            fn: formatSymbol(e),
          }),
        );
        break;
    }
    return n || r.allowExport(), r;
  }
  var Cx = {
    translate: "translation",
    rotate: "rotation",
    dilate: "dilation",
    reflect: "reflection",
  };
  function Jx(e, t, n, { blockExport: r }) {
    let s = [];
    if (n.maxArity === void 0) return Hs(e, t, { blockExport: r });
    for (let a = 1; a < n.argTypes.length; a++) {
      let u = n.argTypes[a];
      typeof u == "number" ? s.push(oe(u)) : s.push(oe(u.getTypes()[0]));
    }
    let i = "";
    switch (s.length) {
      case 1:
        i = E(
          t.length > s.length
            ? "shared-calculator-error-transformation-definition-expected-types-use-fewer-1"
            : "shared-calculator-error-transformation-definition-expected-types-1",
          { arg: s[0] },
        );
        break;
      case 2:
        i = E(
          t.length > s.length
            ? "shared-calculator-error-transformation-definition-expected-types-use-fewer-2"
            : "shared-calculator-error-transformation-definition-expected-types-2",
          { arg1: s[0], arg2: s[1] },
        );
        break;
    }
    let o;
    switch (t.length) {
      case 1:
        o = new v(
          E(
            t.length < s.length
              ? "shared-calculator-error-transformation-definition-type-error-use-more-1"
              : "shared-calculator-error-transformation-definition-type-error-1",
            { fn: formatSymbol(Cx[e]), arg: t[0], expectedTypeMessage: i },
          ),
        );
        break;
      case 2:
        o = new v(
          E(
            t.length < s.length
              ? "shared-calculator-error-transformation-definition-type-error-use-more-2"
              : "shared-calculator-error-transformation-definition-type-error-2",
            {
              fn: formatSymbol(Cx[e]),
              arg1: t[0],
              arg2: t[1],
              expectedTypeMessage: i,
            },
          ),
        );
        break;
      default:
        o = new v(
          E(
            "shared-calculator-error-transformation-definition-type-error-many",
            { fn: formatSymbol(Cx[e]) },
          ),
        );
        break;
    }
    return r || o.allowExport(), o;
  }
  function Qx(e, t, { blockExport: n }) {
    let r;
    switch (t.length) {
      case 1:
        r = new v(
          E("shared-calculator-error-transformation-type-error-1", {
            fn: formatSymbol(e),
            arg: t[0],
          }),
        );
        break;
      case 2:
        r = new v(
          E("shared-calculator-error-transformation-type-error-2", {
            fn: formatSymbol(e),
            arg1: t[0],
            arg2: t[1],
          }),
        );
        break;
      default:
        r = new v(
          E("shared-calculator-error-transformation-type-error-many", {
            fn: formatSymbol(e),
          }),
        );
        break;
    }
    return n || r.allowExport(), r;
  }
  function Kx(e, t, { blockExport: n }) {
    let r = formatSymbol(e),
      s = formatSymbol("count"),
      i = new v(
        E("shared-calculator-error-geometry-length-type-error", {
          fn: r,
          alternativeFn: s,
          arg: t,
        }),
      );
    return n || i.allowExport(), i;
  }
  function eT(e, t, { blockExport: n }) {
    let r = formatSymbol(e),
      s = formatSymbol("count"),
      i = new v(
        E("shared-calculator-error-3d-length-type-error", {
          fn: r,
          alternativeFn: s,
          arg: t,
        }),
      );
    return n || i.allowExport(), i;
  }
  function Gd(e) {
    return new v(
      E("shared-calculator-error-illegal-dot-call", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function tT(e, t, { blockExport: n }) {
    let r = new v(
      E("shared-calculator-error-dot-lhs-type-error", {
        symbol: formatSymbol(e),
        type: t,
      }),
    );
    return n || r.allowExport(), r;
  }
  function ly() {
    return new v(E("shared-calculator-error-dot-lhs-constant-number"));
  }
  function nT(e) {
    return new v(
      E("shared-calculator-error-dot-rhs-property-error", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function rT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-sum-lower-bound-type-error", { symbol: e[0] }),
    );
    return t || n.allowExport(), n;
  }
  function sT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-sum-upper-bound-type-error", { symbol: e[0] }),
    );
    return t || n.allowExport(), n;
  }
  function py() {
    return new v(E("shared-calculator-error-sum-infinite-bound-type-error"));
  }
  function iT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-sum-argument-type-error", { symbol: e[0] }),
    );
    return t || n.allowExport(), n;
  }
  function oT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-product-lower-bound-type-error", {
        symbol: e[0],
      }),
    );
    return t || n.allowExport(), n;
  }
  function aT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-product-upper-bound-type-error", {
        symbol: e[0],
      }),
    );
    return t || n.allowExport(), n;
  }
  function dy() {
    return new v(
      E("shared-calculator-error-product-infinite-bound-type-error"),
    );
  }
  function uT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-product-argument-type-error", {
        symbol: e[0],
      }),
    );
    return t || n.allowExport(), n;
  }
  function cT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-integral-lower-bound-type-error", {
        symbol: e[0],
      }),
    );
    return t || n.allowExport(), n;
  }
  function lT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-integral-upper-bound-type-error", {
        symbol: e[0],
      }),
    );
    return t || n.allowExport(), n;
  }
  function pT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-integral-argument-type-error", {
        symbol: e[0],
      }),
    );
    return t || n.allowExport(), n;
  }
  function dT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-derivative-type-error", { symbol: e[0] }),
    );
    return t || n.allowExport(), n;
  }
  function fT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-derivative-type-error-respect", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function mT(e, t, { blockExport: n }) {
    let r = new v(
      E("shared-calculator-error-derivative-variable-type-error", {
        symbol1: formatSymbol(e),
        symbol2: t[0],
      }),
    );
    return n || r.allowExport(), r;
  }
  function yT(e, t, { blockExport: n }) {
    let r = new v(
      E("shared-calculator-error-prime-variable-type-error", {
        symbol1: formatSymbol(e),
        symbol2: t[0],
      }),
    );
    return n || r.allowExport(), r;
  }
  function fy(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-piecewise-condition-type-error", {
        symbol1: oe(Bool),
        symbol2: e[0],
      }),
    );
    return t || n.allowExport(), n;
  }
  function gT(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-piecewise-branch-type-error", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function hT(e) {
    return new v(
      E("shared-calculator-error-table-header-type-error", { symbol: e[0] }),
    );
  }
  function bT(e) {
    return new v(
      E("shared-calculator-error-table-entry-type-error", { symbol: e[0] }),
    );
  }
  function xT() {
    return new v(E("shared-calculator-error-regression-recursion"));
  }
  function TT(e) {
    return new v(
      E("shared-calculator-error-table-regression-type-error", { symbol: e }),
    );
  }
  function IT() {
    return new v(E("shared-calculator-error-table-regression-invalid-data"));
  }
  function HV() {
    return new v(
      E("shared-calculator-error-table-regression-log-with-negative"),
    );
  }
  function PT(e) {
    return new v(
      E("shared-calculator-error-regression-type-error", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
  }
  function ET(e) {
    return new v(
      E("shared-calculator-error-update-rule-type-error", { symbol: e }),
    );
  }
  function MT() {
    return new v(
      E("shared-calculator-error-update-rule-non-identifier-lhs", {
        arrow: "\u2192",
        example: "a",
      }),
    );
  }
  function CT(e) {
    return new v(
      E("shared-calculator-error-duplicate-update-rules", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function DT(e) {
    return new v(
      E("shared-calculator-error-update-rule-undefined-lhs", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function ST(e) {
    return new v(
      E("shared-calculator-error-update-rule-illegal-lhs", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function vT(e) {
    return new v(
      E("shared-calculator-error-update-rule-function-lhs", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function my(e) {
    return new v(
      E("shared-calculator-error-update-rule-local-lhs", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function OT(e) {
    let t = e.filter((n) => n.scope === "free").map((n) => n.symbol);
    return new v(
      E("shared-calculator-error-action-merge-free-variable", {
        symbol: formatSymbol(t[0] || ""),
      }),
    ).setDependencies(t).allowExport();
  }
  function kd(e) {
    return new v(
      E("shared-calculator-error-event-handler-type-error", {
        example: "a\u2192a+1",
      }),
    );
  }
  function Hd({ blockExport: e }) {
    let t = new v(E("shared-calculator-error-heterogeneous-list"));
    return e || t.allowExport(), t;
  }
  function yy(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-combine-type-error", {
        symbol1: e[0],
        symbol2: e[1],
      }),
    );
    return t || n.allowExport(), n;
  }
  function Yl(e) {
    return new v(
      E("shared-calculator-error-log-scale-type-error", { symbol: e }),
    ).allowExport();
  }
  function NT() {
    return new v(E("shared-calculator-error-log-scale-histogram"));
  }
  function RT() {
    return new v(E("shared-calculator-error-log-scale-dot-plot"));
  }
  function AT() {
    return new v(E("shared-calculator-error-log-scale-box-plot"));
  }
  function _T() {
    return new v(E("shared-calculator-error-deeply-nested")).allowExport();
  }
  function LT() {
    return new v(E("shared-calculator-error-3d-multiple-equality-restrictions"))
      .allowExport();
  }
  function wT() {
    return new v(E("shared-calculator-error-3d-mixed-restriction-equation"))
      .allowExport();
  }
  function ca() {
    return new v(E("shared-calculator-error-3d-bad-equality-slice"))
      .allowExport();
  }
  function mu(e) {
    return new v(
      E("shared-calculator-error-gpu-variable-list-length", {
        symbol: formatSymbol(
          e.filter((t) => t.symbol !== "globalRandomSeed")[0].symbol,
        ),
      }),
    );
  }
  function gy(e) {
    return new v(
      E("shared-calculator-error-gpu-variable-sum", {
        symbol: formatSymbol(e[0].symbol),
      }),
    );
  }
  function hy(e) {
    return new v(
      E("shared-calculator-error-gpu-variable-product", {
        symbol: formatSymbol(e[0].symbol),
      }),
    );
  }
  function Xl(e) {
    return new v(
      E("shared-calculator-error-gpu-function-unsupported", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function FT() {
    return new v(E("shared-calculator-error-gpu-integral-unsupported"));
  }
  function VT() {
    return new v(
      E("shared-calculator-error-gpu-long-sum", {
        maxTermCount: (1e3).toLocaleString(),
      }),
    );
  }
  function BT() {
    return new v(
      E("shared-calculator-error-gpu-long-product", {
        maxTermCount: (1e3).toLocaleString(),
      }),
    );
  }
  function Oc() {
    return new v(
      E("shared-calculator-error-gpu-max-list-size", {
        maxListSize: (100).toLocaleString(),
      }),
    );
  }
  function zd() {
    return new v(
      E("shared-calculator-error-max-list-size", {
        maxListSize: (1e4).toLocaleString(),
      }),
    ).allowExport();
  }
  function Ud() {
    return new v(E("shared-calculator-error-two-numbers-error"));
  }
  function GT() {
    return new v(E("shared-calculator-error-boxplot-offset-invalid"));
  }
  function kT() {
    return new v(E("shared-calculator-error-boxplot-breadth-invalid"));
  }
  function by(e, t) {
    return new v(
      E("shared-calculator-error-too-many-arguments", { symbol: e, max: t }),
    );
  }
  function HT() {
    let e = E("shared-calculator-error-pdf-wrong-arity-recommendation"),
      t = E("shared-calculator-error-pdf-wrong-arity", { recommendation: e });
    return new v(t);
  }
  function zT() {
    let e = E("shared-calculator-error-cdf-wrong-arity-recommendation"),
      t = E("shared-calculator-error-cdf-wrong-arity", { recommendation: e });
    return new v(t);
  }
  function UT() {
    let e = E("shared-calculator-error-cdf-too-many-arguments-recommendation"),
      t = E("shared-calculator-error-cdf-too-many-arguments", {
        recommendation: e,
      });
    return new v(t);
  }
  function qT() {
    return new v(E("shared-calculator-error-tdist-wrong-arity"));
  }
  function $T() {
    return new v(E("shared-calculator-error-random-arity"));
  }
  function YT() {
    return new v(
      E("shared-calculator-error-random-from-broadcast-distribution"),
    );
  }
  function XT(e) {
    let t = e === "rgb" ? [150, 30, 100] : [180, .5, .5],
      n = E("shared-calculator-error-color-arity-recommendation", {
        recommendation: formatSymbol(e) + "(" + t.join(", ") + ")",
      }),
      r = E("shared-calculator-error-color-arity", {
        symbol: e,
        recommendation: n,
      });
    return new v(r);
  }
  function Ao(e, t, n, r) {
    e = formatSymbol(e);
    let s, i;
    if (t === 1) {
      i = r.includeUsageExample
        ? E("shared-calculator-error-wrong-arity-supplement", {
          recommendation: r.usageExample || e + "(x)",
        })
        : "",
        n > 1
          ? s = E("shared-calculator-error-wrong-arity-single-arg-too-many", {
            dependency: e,
            supplement: i,
          })
          : s = E("shared-calculator-error-wrong-arity-single-arg-too-few", {
            dependency: e,
            supplement: i,
          });
    } else {
      let o = [], a = r.usageExample;
      if (!a) {
        for (let u = 0; u < t; u++) o[u] = u + 1;
        a = formatSymbol(e) + "(" + o.join(", ") + ")";
      }
      i = r.includeUsageExample
        ? E("shared-calculator-error-wrong-arity-supplement", {
          recommendation: a,
        })
        : "",
        s = E("shared-calculator-error-wrong-arity-many-arg", {
          dependency: e,
          assignment_arity: t,
          supplement: i,
        });
    }
    return new v(s);
  }
  function ZT() {
    let e = E("shared-calculator-error-wrong-arity-supplement", {
        recommendation: "length(x)",
      }),
      t = E("shared-calculator-error-wrong-arity-single-arg-too-few", {
        dependency: "length",
        supplement: e,
      });
    return new v(t);
  }
  function WT(e) {
    return new v(
      E("shared-calculator-error-wrong-two-arg-arity", {
        symbol: formatSymbol(e),
        recommendation: formatSymbol(e) + "([1,2,3], 1)",
      }),
    );
  }
  function qd(e) {
    return new v(
      E("shared-calculator-error-wrong-two-arg-arity", {
        symbol: formatSymbol(e),
        recommendation: formatSymbol(e) + "([1,2,3], [3,2,1])",
      }),
    );
  }
  function Nc() {
    return new v(E("shared-calculator-error-primed-function-arity"));
  }
  function jT(e) {
    return new v(
      E("shared-calculator-error-zero-arg-reducer", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function JT() {
    return new v(E("shared-calculator-error-malformed-point"));
  }
  function QT() {
    return new v(E("shared-calculator-error-malformed-list"));
  }
  function KT(e) {
    return new v(
      E("shared-calculator-error-bad-tuple-dimensions", { symbol: e }),
    );
  }
  function xy(e) {
    return e = formatSymbol(e),
      new v(E("shared-calculator-error-bad-implicit-call", { symbol: e }));
  }
  function eI(e, t) {
    return new v(
      E("shared-calculator-error-adjacent-numbers", { left: e, right: t }),
    );
  }
  function Ty(e) {
    return new v(
      E("shared-calculator-error-adjacent-mixed-number", { mixedNumber: e }),
    );
  }
  function tI() {
    return new v(E("shared-calculator-error-token-with-subscript"));
  }
  function Iy(e) {
    return e = formatSymbol(e),
      new v(E("shared-calculator-error-identifier-as-function", { symbol: e }));
  }
  function Py(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-identifier-is-not-function", { symbol: e }),
      );
  }
  function $d(e) {
    return e = formatSymbol(e),
      e === "%" && (e = "% of"),
      new v(
        E("shared-calculator-error-binary-operator-missing-operand", {
          symbol: e,
        }),
      );
  }
  function nI(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-unary-operator-missing-left", { symbol: e }),
      );
  }
  function rI(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-unary-operator-missing-right", {
          symbol: e,
        }),
      );
  }
  function sI() {
    return new v(E("shared-calculator-error-fraction-missing-numerator"));
  }
  function iI() {
    return new v(E("shared-calculator-error-fraction-missing-denominator"));
  }
  function oI() {
    return new v(E("shared-calculator-error-fraction-empty"));
  }
  function Ey() {
    return new v(E("shared-calculator-error-empty-subscript"));
  }
  function aI() {
    return new v(E("shared-calculator-error-empty-superscript"));
  }
  function uI(e) {
    return e = formatSymbol(e),
      new v(E("shared-calculator-error-invalid-subscript", { symbol: e }));
  }
  function cI() {
    return new v(E("shared-calculator-error-invalid-operator-name"));
  }
  function lI() {
    return new v(E("shared-calculator-error-unexpected-subscript"));
  }
  function pI() {
    return new v(E("shared-calculator-error-superscript-with-prime"));
  }
  function My() {
    return new v(E("shared-calculator-error-unexpected-prime"));
  }
  function Cy() {
    return new v(E("shared-calculator-error-prime-without-paren"));
  }
  function dI() {
    return new v(E("shared-calculator-error-empty-radical"));
  }
  function fI() {
    return new v(E("shared-calculator-error-empty-radical-index"));
  }
  function Yd() {
    return new v(E("shared-calculator-error-empty-paren"));
  }
  function mI() {
    return new v(E("shared-calculator-error-empty-square-bracket"));
  }
  function yI() {
    return new v(E("shared-calculator-error-empty-pipe"));
  }
  function gI(e) {
    let t = e + "^2", n = e + "^-1";
    return new v(
      E("shared-calculator-error-bad-trig-exponent", { form1: t, form2: n }),
    );
  }
  function hI(e) {
    let t = e + "^2";
    return new v(E("shared-calculator-error-bad-log-exponent", { form: t }));
  }
  function bI() {
    return new v(E("shared-calculator-error-piecewise-missing-condition"));
  }
  function xI() {
    return new v(E("shared-calculator-error-piecewise-part-missing-condition"));
  }
  function TI() {
    return new v(E("shared-calculator-error-colon-missing-condition"));
  }
  function Xd() {
    let e = new v(E("shared-calculator-error-blank-expression"));
    return e.silent = true, e;
  }
  function Dy(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-function-not-defined", { dependency: e }),
      );
  }
  function Sy(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-parameter-already-defined", {
          dependency: e,
        }),
      );
  }
  function II(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-duplicate-function-parameter", {
          dependency: e,
        }),
      );
  }
  function PI(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-function-name-as-parameter", {
          dependency: e,
        }),
      );
  }
  function Zl(e, t) {
    return e = formatSymbol(e),
      t === void 0
        ? new v(E("shared-calculator-error-cannot-redefine", { symbol: e }))
        : new v(
          E("shared-calculator-error-cannot-redefine-root", {
            symbol: e,
            symbolRoot: t,
          }),
        );
  }
  function EI(e) {
    return e = formatSymbol(e),
      new v(E("shared-calculator-error-cannot-subscript", { symbol: e }));
  }
  function Wl(e) {
    return e = formatSymbol(e),
      new v(E("shared-calculator-error-multiply-defined", { dependency: e }));
  }
  function vy(e) {
    return e = formatSymbol(e),
      new v(E("shared-calculator-error-shadowed-index", { symbol: e }));
  }
  function MI(e) {
    e = e.map(formatSymbol);
    let t = e.pop() || "",
      n = new v(
        E("shared-calculator-error-dependency-cycle", {
          symbols: e.join("', '"),
          lastSymbol: t,
        }),
      );
    return n.isCyclicDependencyError = true, n;
  }
  function Rc(e, t) {
    let n = e.length, r = e[0];
    return t.suggestAlternativeFunctionName && n == 1
      ? new v(
        E("shared-calculator-error-self-referential-suggest-alternative", {
          symbol: formatSymbol(r),
        }),
      )
      : new v(
        E("shared-calculator-error-self-referential-functions", {
          symbols: e.slice(1).map((s) => formatSymbol(s)).join("', '"),
          lastSymbol: formatSymbol(r),
          count: Cd(n),
        }),
      );
  }
  function CI(e) {
    return new v(
      E("shared-calculator-error-self-referential-base-case", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function DI() {
    return new v(E("shared-calculator-error-ticker-min-step-nonnegative"));
  }
  function SI(e) {
    return new v(
      E("shared-calculator-error-slider-limit-references-export", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function vI() {
    return new v(E("shared-calculator-error-slider-min-invalid"));
  }
  function OI() {
    return new v(E("shared-calculator-error-slider-max-invalid"));
  }
  function NI() {
    return new v(E("shared-calculator-error-slider-max-less-than-min"));
  }
  function RI() {
    return new v(E("shared-calculator-error-slider-step-invalid"));
  }
  function AI() {
    return new v(E("shared-calculator-error-domain-min-invalid"));
  }
  function _I() {
    return new v(E("shared-calculator-error-domain-max-invalid"));
  }
  function LI() {
    return new v(E("shared-calculator-error-domain-max-less-than-min"));
  }
  function wI() {
    return new v(E("shared-calculator-error-cdf-min-invalid"));
  }
  function FI() {
    return new v(E("shared-calculator-error-cdf-max-invalid"));
  }
  function VI() {
    return new v(E("shared-calculator-error-cdf-max-less-than-min"));
  }
  function BI() {
    return new v(
      E("shared-calculator-error-use-rho-for-spherical-coordinates"),
    );
  }
  function GI() {
    return new v(
      E("shared-calculator-error-use-r-for-cylindrical-coordinates"),
    );
  }
  function Oy() {
    return new v(
      E("shared-calculator-error-cant-combine-spherical-and-cylindrical"),
    );
  }
  function rn(e) {
    if (e = e.map(formatSymbol), e.length === 0) {
      return new v(E("shared-calculator-error-too-many-variables-no-symbols"));
    }
    let t = e.pop() || "";
    return e.length > 0
      ? new v(
        E("shared-calculator-error-too-many-variables-many-symbols", {
          variables: e.join("', '"),
          lastVariable: t,
        }),
      )
      : new v(
        E("shared-calculator-error-too-many-variables-one-symbol", {
          variable: t,
        }),
      );
  }
  function kI(e) {
    return new v(
      E("shared-calculator-error-cannot-restrict", {
        variable: formatSymbol(e),
      }),
    );
  }
  function HI(e) {
    return new v(
      E("shared-calculator-error-cannot-assign-color", {
        variable: formatSymbol(e),
      }),
    );
  }
  function zI(e) {
    return new v(
      E("shared-calculator-error-cannot-restrict-with-equality", {
        variable: formatSymbol(e),
      }),
    );
  }
  function Zd(e, t, n) {
    e = e.map(formatSymbol), t = formatSymbol(t), n = n.map(formatSymbol);
    let r = t + "(" + n.join(",") + "," + e.join(",") + ")",
      s = e.pop() || "",
      i = { symbols: e.join("', '"), lastSymbol: s, newSignature: r };
    return e.length
      ? new v(E("shared-calculator-error-add-arguments-to-definition-many", i))
      : new v(E("shared-calculator-error-add-arguments-to-definition-one", i));
  }
  function UI(e) {
    return e = formatSymbol(e),
      new v(E("shared-calculator-error-invalid-lhs", { symbol: e }));
  }
  function qI() {
    return new v(E("shared-calculator-error-unplottable-polar-function"));
  }
  function $I() {
    return new v(E("shared-calculator-error-invalid-inequality-variables"));
  }
  function Ac() {
    return new v(E("shared-calculator-error-invalid-implicit-variables"));
  }
  function YI() {
    return new v(E("shared-calculator-error-invalid-implicit-variables-3d"));
  }
  function XI() {
    return new v(
      E("shared-calculator-error-single-variable-implicit-equations-disabled"),
    );
  }
  function ZI() {
    return new v(E("shared-calculator-error-implicits-disabled"));
  }
  function Ny(e) {
    let t = new v(
      e === "="
        ? E("graphing-calculator-error-nan-blame-complex-coercion")
        : E("shared-calculator-error-complex-operation-undefined", {
          symbol: formatSymbol(e),
        }),
    );
    return t.warning = t.getError(), t.silent = true, t;
  }
  function zV() {
    return new v(E("shared-calculator-error-complex-table-point-coordinate"));
  }
  function Ry() {
    return new v(E("shared-calculator-error-inequalities-disabled"));
  }
  function WI() {
    return new v(E("shared-calculator-error-complicated-polar-implicit"));
  }
  function jI() {
    return new v(E("shared-calculator-error-invalid-double-inequality-3d"));
  }
  function JI() {
    return new v(E("shared-calculator-error-invalid-double-equality-3d"));
  }
  function QI() {
    return new v(E("shared-calculator-error-unplottable-chained-equality"));
  }
  function Ay() {
    return new v(
      E("shared-calculator-error-invalid-double-inequality-variables"),
    );
  }
  function _y() {
    return new v(
      E("shared-calculator-error-mismatched-double-inequality", {
        example: "1 < y < 2",
      }),
    );
  }
  function Ly() {
    return new v(E("shared-calculator-error-complicated-double-inequality"));
  }
  function wy(e) {
    return e
      ? (e = formatSymbol(e),
        new v(
          E("shared-calculator-error-equation-required-symbol", {
            lhs: e + "=",
          }),
        ))
      : new v(E("shared-calculator-error-equation-required"));
  }
  function Fy(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-variable-as-function", { dependency: e }),
      );
  }
  function Vy(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-distribution-as-function", { symbol: e }),
      );
  }
  function KI(e) {
    return new v(
      E("shared-calculator-error-invalid-table-header", { supplement: e }),
    );
  }
  function Wd(e) {
    return new v(
      E("shared-calculator-error-invalid-table-entry", { supplement: e }),
    );
  }
  function eP() {
    return new v(
      E("shared-calculator-error-invalid-first-table-column", {
        most: "'y', 'r',",
        last: "'\u03B8'",
      }),
    );
  }
  function UV() {
    return new v(
      E("shared-calculator-error-invalid-dependent-first-table-column"),
    );
  }
  function tP(e) {
    return new v(
      E("shared-calculator-error-invalid-regression-parameter", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function nP() {
    return new v(E("shared-calculator-error-optimization-error"));
  }
  function jd(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-non-list-double-reducer", {
        symbol: formatSymbol(e),
        recommendation: formatSymbol(e) + "([1,2,3], [3,2,1])",
      }),
    );
    return t || n.allowExport(), n;
  }
  function rP(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-non-list-parameterized-reducer", {
        symbol: formatSymbol(e),
        recommendation: formatSymbol(e) + "([1,2,3], 1)",
      }),
    );
    return t || n.allowExport(), n;
  }
  function so(e, { blockExport: t }) {
    let n = new v(
      E("shared-calculator-error-method-requires-list", {
        symbol: formatSymbol(e),
        recommendation: formatSymbol(e) + "([1,2,3])",
      }),
    );
    return t || n.allowExport(), n;
  }
  function Jd() {
    return new v(E("shared-calculator-error-non-arithmetic-range"))
      .allowExport();
  }
  function sP() {
    return new v(E("shared-calculator-error-invalid-half-empty-range"));
  }
  function iP() {
    return new v(E("shared-calculator-error-sum-missing-bound"));
  }
  function oP() {
    return new v(E("shared-calculator-error-product-missing-bound"));
  }
  function aP() {
    return new v(E("shared-calculator-error-incorrect-sum-lower-bound"));
  }
  function uP() {
    return new v(E("shared-calculator-error-incorrect-product-lower-bound"));
  }
  function cP(e) {
    return new v(
      E("shared-calculator-error-bad-sum-bound-dependency", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function lP(e) {
    return new v(
      E("shared-calculator-error-bad-product-bound-dependency", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function pP() {
    return new v(E("shared-calculator-error-integral-missing-bound"));
  }
  function dP() {
    return new v(E("shared-calculator-error-integral-missing-differential"));
  }
  function fP() {
    return new v(E("shared-calculator-error-differential-with-superscript"));
  }
  function mP() {
    return new v(E("shared-calculator-error-sum-missing-body"));
  }
  function yP() {
    return new v(E("shared-calculator-error-product-missing-body"));
  }
  function gP() {
    return new v(E("shared-calculator-error-integral-missing-body"));
  }
  function hP() {
    return new v(E("shared-calculator-error-derivative-missing-body"));
  }
  function bP(e, t) {
    return e = formatSymbol(e),
      t = formatSymbol(t),
      new v(
        E("shared-calculator-error-mismatched-braces", {
          symbol1: e,
          symbol2: t,
        }),
      );
  }
  function By(e) {
    return new v(
      E("shared-calculator-error-shadowed-integration-variable", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function xP(e) {
    return new v(
      E("shared-calculator-error-bad-integral-bound-dependency", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function TP() {
    return new v(E("shared-calculator-error-percent-missing-of"));
  }
  function Qd(e) {
    return e = formatSymbol(e),
      new v(E("shared-calculator-error-illegal-bin-width", { symbol: e }));
  }
  function jl(e) {
    return e = formatSymbol(e),
      new v(E("shared-calculator-error-ttest-list-too-short", { symbol: e }));
  }
  function IP() {
    return new v(E("shared-calculator-error-bad-sample-size"));
  }
  function PP(e) {
    return new v(
      E("shared-calculator-error-variable-seed", {
        symbol: formatSymbol(e[0].symbol),
      }),
    ).setDependencies(e.filter((t) => t.scope === "free").map((t) => t.symbol))
      .allowExport();
  }
  function Kd(e) {
    return new v(
      E("shared-calculator-error-bad-symbol-context", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function Gy() {
    return new v(
      E("shared-calculator-error-write-integral", {
        command: "integral",
        symbol: "\u222B",
      }),
    );
  }
  function EP() {
    return new v(E("shared-calculator-error-ans-undefined"));
  }
  function ef(e) {
    return new v(
      E("shared-calculator-error-variables-unsupported", {
        variable: formatSymbol(e),
      }),
    );
  }
  function ky() {
    return new v(E("shared-calculator-error-polygon-unsupported-in-3d"));
  }
  function VD(e) {
    return new v(
      E("shared-calculator-error-function-only-works-in-complex", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function Li(e, t) {
    return t != null && t.is3dPolicy() && e === "polygon"
      ? ky()
      : !!t && !(t != null && t.isGeometryEnabled()) && !(t instanceof Cc) &&
          !t.isComplexEnabled() && FD.indexOf(e) !== -1
      ? VD(e)
      : new v(
        E("shared-calculator-error-function-unsupported", {
          symbol: formatSymbol(e),
        }),
      );
  }
  function MP() {
    return new v(E("shared-calculator-error-logbase-unsupported"));
  }
  function _c(e) {
    return new v(
      E("shared-calculator-error-constant-unsupported", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function Hy(e) {
    return new v(
      E("shared-calculator-error-variable-unsupported", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function zy(e) {
    return new v(
      E("shared-calculator-error-variable-invalid-function-name", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function tf() {
    return new v(E("shared-calculator-error-assignments-unsupported"));
  }
  function nf() {
    return new v(E("shared-calculator-error-function-definition-unsupported"));
  }
  function Ua() {
    return new v(E("shared-calculator-error-equations-unsupported"));
  }
  function Lc() {
    return new v(E("shared-calculator-error-inequalities-unsupported"));
  }
  function wc() {
    return new v(E("shared-calculator-error-regressions-unsupported"));
  }
  function CP() {
    return new v(E("shared-calculator-error-custom-regressions-unsupported"));
  }
  function Fc() {
    return new v(E("shared-calculator-error-points-unsupported"));
  }
  function rf() {
    return new v(E("shared-calculator-error-feature-unavailable"));
  }
  function Uy() {
    return new v(E("basic-calculator-error-fractions-unavailable"));
  }
  function DP() {
    return new v(E("basic-calculator-error-parentheses-unavailable"));
  }
  function qV() {
    return new v(E("shared-calculator-error-non-square-determinant"));
  }
  function $V() {
    return new v(E("shared-calculator-error-non-square-trace"));
  }
  function YV() {
    return new v(E("shared-calculator-error-non-square-inverse"));
  }
  function XV() {
    return new v(E("shared-calculator-error-non-singular-inverse"));
  }
  function ZV(e) {
    return new v(
      E("shared-calculator-error-clickable-object-assignment-not-defined", {
        symbol: e,
      }),
    );
  }
  function WV(e) {
    return new v(
      E("shared-calculator-error-multiply-defined", { dependency: e }),
    );
  }
  function jV() {
    return new v(
      E("shared-calculator-error-clickable-object-assignment-not-identifier"),
    );
  }
  function JV() {
    return new v(
      E("shared-calculator-error-clickable-object-invalid-expression"),
    );
  }
  function QV() {
    return new v(E("shared-calculator-error-matrix-assignment"));
  }
  function KV() {
    return new v(E("shared-calculator-error-matrix-add-dimensions"));
  }
  function eB() {
    return new v(E("shared-calculator-error-matrix-subtract-dimensions"));
  }
  function tB() {
    return new v(E("shared-calculator-error-matrix-multiply-dimensions"));
  }
  function nB() {
    return new v(E("shared-calculator-error-matrix-fractional-power"));
  }
  function rB() {
    return new v(E("shared-calculator-error-matrix-power-dimensions"));
  }
  function sB(e) {
    return new v(
      E("shared-calculator-error-matrix-element-type-error", { arg: e[0] }),
    );
  }
  function iB(e) {
    return new v(
      E("shared-calculator-error-matrix-invalid-variable", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function SP(e, t, n, { blockExport: r }) {
    let s = "[1...10]";
    n && !/[\\]/.test(n) && (s = `[${n}]`);
    let i = new v(
      E("shared-calculator-error-list-comprehension-input-type-error", {
        identifier: e,
        actual: t,
        example: s,
      }),
    );
    return r || i.allowExport(), i;
  }
  function vP() {
    return new v(
      E("shared-calculator-error-incorrect-list-comprehension-input"),
    );
  }
  function qy(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-shadowed-list-comprehension-input", {
          symbol: e,
        }),
      );
  }
  function OP(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-bad-for-input-list-dependency", {
          symbol: e,
        }),
      );
  }
  function NP(e) {
    return e = formatSymbol(e),
      new v(
        E("shared-calculator-error-bad-for-interval-dependency", { symbol: e }),
      );
  }
  function RP(e) {
    let t = e.filter((n) => n.scope === "free").map((n) => n.symbol);
    return new v(
      E("shared-calculator-error-variable-length-top-level-list", {
        symbol: formatSymbol(t[0] || ""),
      }),
    ).setDependencies(t).allowExport();
  }
  function sf(e) {
    return new v(
      E("shared-calculator-error-variable-length-distribution-list", {
        symbol: e[0].symbol,
      }),
    ).setDependencies(e.filter((t) => t.scope === "free").map((t) => t.symbol));
  }
  function AP(e) {
    return new v(
      E("shared-calculator-error-variable-length-sum-body-depends-on-index", {
        symbol: e,
      }),
    );
  }
  function _P(e) {
    return new v(
      E(
        "shared-calculator-error-variable-length-product-body-depends-on-index",
        { symbol: e },
      ),
    );
  }
  function LP(e) {
    return new v(
      E(
        "shared-calculator-error-variable-length-integral-depends-on-integration-var",
        { symbol: e },
      ),
    );
  }
  function oB(e, t) {
    return new v(
      E("shared-calculator-error-substitution-type-error", {
        actual: oe(e),
        expected: oe(t),
      }),
    );
  }
  function of() {
    return new v(E("shared-calculator-error-substitution-invalid-assignments"));
  }
  function wP(e) {
    return new v(
      E("shared-calculator-error-substitution-local-lhs", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function af(e) {
    return new v(
      E("shared-calculator-error-substitution-illegal-lhs", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function uf(e) {
    return new v(
      E("shared-calculator-error-substitution-function-lhs", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function FP(e, t, n) {
    return new v(
      E(
        "shared-calculator-error-substitution-body-regression-parameter-dependency",
        {
          globalVariable: formatSymbol(e),
          regressionParameter: formatSymbol(t),
          operator: n,
        },
      ),
    );
  }
  function aB() {
    return new v(E("shared-calculator-error-substitution-body-action"));
  }
  function $y() {
    return new v(E("shared-calculator-error-substitution-nested"));
  }
  function yu(e) {
    return new v(
      E("shared-calculator-error-substitution-ambiguous-comma", {
        operation: e,
      }),
    );
  }
  function VP(e) {
    return new v(
      E("shared-calculator-error-substitution-duplicate-assignment", {
        symbol: formatSymbol(e),
      }),
    );
  }
  function BP(e, t, n) {
    return new v(
      E("shared-calculator-error-substitution-recursive-call-lhs", {
        operator: e,
        globalVariable: formatSymbol(t),
        fnSymbol: formatSymbol(n),
      }),
    );
  }
  function GP() {
    return new v(E("shared-calculator-error-depends-on-deleted-geo-object"));
  }
  function kP(e) {
    return new v(
      E("shared-calculator-error-invalid-interval-comprehension-return-type", {
        type: oe(e),
      }),
    );
  }
  function HP(e, t) {
    return new v(
      E("shared-calculator-error-bad-interval-comprehension-arity", {
        type: oe(e),
        count: Cd(t),
      }),
    );
  }
  function Jl(e) {
    return new v(
      E(
        "shared-calculator-error-invalid-interval-comprehension-invalid-bound",
        { identifier: e },
      ),
    );
  }
  function zP() {
    return new v(E("shared-calculator-error-nested-interval-comprehension"));
  }
  function Yy() {
    return new v(
      E("shared-calculator-error-substitution-unsupported-interval"),
    );
  }
  function UP(e) {
    return new v(
      E("shared-calculator-error-table-regression-invalid-export-identifier", {
        latex: "`" + e + "`",
      }),
    );
  }
  function qP(e) {
    return new v(
      e.length === 1
        ? E(
          "graphing-calculator-error-table-regression-unexportable-reserved-variable-single",
          { variable: "`" + e[0] + "`" },
        )
        : E(
          "graphing-calculator-error-table-regression-unexportable-reserved-variables-many",
        ),
    );
  }
  function We(e) {
    return Object.keys(e);
  }
  function Tn(e) {
    return Object.create(e);
  }
  var BD = Symbol("DEPENDENCY_ORDER");
  function GD(e) {
    let t = e[BD];
    if (!t) throw U("Missing dependency order.");
    return t;
  }
  function $P(e, t) {
    e[BD] = t;
  }
  function gu(e) {
    return typeof e != "object" || !e ? false : e.type === "Action";
  }
  function bX(e) {
    return j(e.valueType);
  }
  var Gi = {};
  ia(Gi, {
    LruCache: () => LruCache,
    RECURSIVE_COMPUTATION_LIMIT: () => RECURSIVE_COMPUTATION_LIMIT,
    RECURSIVE_DEPTH_LIMIT: () => RECURSIVE_DEPTH_LIMIT,
    RecursiveFunctionResult: () => RecursiveFunctionResult,
    SYMBOL_DIVERGES: () => SYMBOL_DIVERGES,
    TerminationStatus: () => TerminationStatus,
    _complexGCD: () => _complexGCD,
    acosh: () => acosh,
    acot: () => acot,
    acoth: () => acoth,
    acsc: () => acsc,
    acsch: () => acsch,
    addTangentAngle: () => addTangentAngle,
    addTangentArc: () => addTangentArc,
    addTangentCircle: () => addTangentCircle,
    addTangentLine: () => addTangentLine,
    addTangentPolygon: () => addTangentPolygon,
    addTangentRay: () => addTangentRay,
    addTangentSegment: () => addTangentSegment,
    addTangentSegmentThreeD: () => addTangentSegmentThreeD,
    addTangentTransformation: () => addTangentTransformation,
    addTangentVector: () => addTangentVector,
    angleMarkerMultiplier: () => angleMarkerMultiplier,
    angleMarkerRawDelta: () => angleMarkerRawDelta,
    angleStart: () => angleStart,
    angleVertex: () => angleVertex,
    anglebisector: () => anglebisector,
    arc: () => arc,
    arcArcIntersection: () => arcArcIntersection,
    arcCenter: () => arcCenter,
    arcCircleIntersection: () => arcCircleIntersection,
    arcFirstPoint: () => arcFirstPoint,
    arcGlider: () => arcGlider,
    arcLineIntersection: () => arcLineIntersection,
    arcMiddlePoint: () => arcMiddlePoint,
    arcOmega: () => arcOmega,
    arcThirdPoint: () => arcThirdPoint,
    arg: () => arg,
    argMax: () => argMax,
    argMin: () => argMin,
    asec: () => asec,
    asech: () => asech,
    asinh: () => asinh,
    atanh: () => atanh,
    basePointFromVector: () => basePointFromVector,
    basePointFromVectorThreeD: () => basePointFromVectorThreeD,
    bernoulliTable: () => bernoulliTable,
    binomSample: () => binomSample,
    binomcdf: () => binomcdf,
    binompdf: () => binompdf,
    center: () => center,
    chooseNonIncidentPoint: () => chooseNonIncidentPoint,
    circle: () => circle,
    circleArcIntersection: () => circleArcIntersection,
    circleCircleIntersection: () => circleCircleIntersection,
    circleGlider: () => circleGlider,
    circleLineIntersection: () => circleLineIntersection,
    clamp: () => clamp,
    coerceComplexToReal: () => coerceComplexToReal,
    coerceRealToComplex: () => coerceRealToComplex,
    common_log: () => common_log,
    compareComplexLexicographic: () => compareComplexLexicographic,
    complex: () => complex,
    complexAcos: () => complexAcos,
    complexAcosh: () => complexAcosh,
    complexAcot: () => complexAcot,
    complexAcoth: () => complexAcoth,
    complexAcsc: () => complexAcsc,
    complexAcsch: () => complexAcsch,
    complexAsec: () => complexAsec,
    complexAsech: () => complexAsech,
    complexAsin: () => complexAsin,
    complexAsinh: () => complexAsinh,
    complexAtan: () => complexAtan,
    complexAtanh: () => complexAtanh,
    complexCeil: () => complexCeil,
    complexCommonLog: () => complexCommonLog,
    complexCos: () => complexCos,
    complexCosh: () => complexCosh,
    complexCot: () => complexCot,
    complexCoth: () => complexCoth,
    complexCsc: () => complexCsc,
    complexCsch: () => complexCsch,
    complexDivide: () => complexDivide,
    complexExp: () => complexExp,
    complexFloor: () => complexFloor,
    complexFromPolarRounded: () => complexFromPolarRounded,
    complexGCD: () => complexGCD,
    complexLCM: () => complexLCM,
    complexListGCD: () => complexListGCD,
    complexListLCM: () => complexListLCM,
    complexLog: () => complexLog,
    complexLogbase: () => complexLogbase,
    complexMod: () => complexMod,
    complexMultiplyPoints: () => complexMultiplyPoints,
    complexPow: () => complexPow,
    complexPowReal: () => complexPowReal,
    complexReciprocal: () => complexReciprocal,
    complexRound: () => complexRound,
    complexSec: () => complexSec,
    complexSech: () => complexSech,
    complexSin: () => complexSin,
    complexSinh: () => complexSinh,
    complexSortPerm: () => complexSortPerm,
    complexSqrt: () => complexSqrt,
    complexTan: () => complexTan,
    complexTanh: () => complexTanh,
    composeTransformation: () => composeTransformation,
    conj: () => conj,
    corr: () => corr,
    cos: () => cos,
    cosh: () => cosh,
    cot: () => cot,
    cotDerivative: () => cotDerivative,
    coth: () => coth,
    cov: () => cov,
    covp: () => covp,
    csc: () => csc,
    csch: () => csch,
    dilation: () => dilation,
    directedAngleMarker: () => directedAngleMarker,
    directedAngleStart: () => directedAngleStart,
    directedAngleVertex: () => directedAngleVertex,
    directedCoterminalAngle: () => directedCoterminalAngle,
    distance: () => distance,
    distanceThreeD: () => distanceThreeD,
    elementsAt: () => elementsAt,
    erf: () => erf,
    erfcx: () => erfcx,
    executeRecursiveFunction: () => executeRecursiveFunction,
    expm1: () => expm1,
    factorial: () => factorial,
    frequency: () => frequency,
    gcd: () => gcd,
    getArcDetails: () => getArcDetails,
    getBroadcastTargetElements: () => getBroadcastTargetElements,
    getRecursiveDepthLimit: () => getRecursiveDepthLimit,
    handleRecursionLimitExceeded: () => handleRecursionLimitExceeded,
    hsv: () => hsv,
    hypot: () => hypot,
    identity: () => identity,
    imag: () => imag,
    invBinom: () => invBinom,
    invNorm: () => invNorm,
    invPoisson: () => invPoisson,
    invT: () => invT,
    invUniform: () => invUniform,
    invertTransformation: () => invertTransformation,
    isDegenerateArc: () => isDegenerateArc,
    itscore: () => itscore,
    ittest: () => ittest,
    lcm: () => lcm,
    line: () => line,
    lineArcIntersection: () => lineArcIntersection,
    lineCircleIntersection: () => lineCircleIntersection,
    lineGlider: () => lineGlider,
    lineLineIntersection: () => lineLineIntersection,
    listGCD: () => listGCD,
    listLCM: () => listLCM,
    listLength: () => listLength,
    listMax: () => listMax,
    listMin: () => listMin,
    log: () => log,
    log1p: () => log1p,
    log_base: () => log_base,
    lowerQuantileIndex: () => lowerQuantileIndex,
    lowerQuartileIndex: () => lowerQuartileIndex,
    mad: () => mad,
    mathVector: () => mathVector,
    mathVectorThreeD: () => mathVectorThreeD,
    md5Spyable: () => md5Spyable,
    mean: () => mean,
    median: () => median,
    mod: () => mod,
    nCr: () => nCr,
    nPr: () => nPr,
    normalSample: () => normalSample,
    normalcdf: () => normalcdf,
    normalpdf: () => normalpdf,
    parallel: () => parallel,
    peelableCoerceComplexToReal: () => peelableCoerceComplexToReal,
    perpendicular: () => perpendicular,
    pointDet: () => pointDet,
    pointDot: () => pointDot,
    pointPerp: () => pointPerp,
    poissonSample: () => poissonSample,
    poissoncdf: () => poissoncdf,
    poissonpdf: () => poissonpdf,
    polyGamma: () => polyGamma,
    polygon: () => polygon,
    polygonArea: () => polygonArea,
    polygonEdgeByParameter: () => polygonEdgeByParameter,
    polygonEdges: () => polygonEdges,
    polygonGlider: () => polygonGlider,
    polygonInteriorDirectedAngles: () => polygonInteriorDirectedAngles,
    polygonInteriorUndirectedAngles: () => polygonInteriorUndirectedAngles,
    polygonPerimeter: () => polygonPerimeter,
    pow: () => pow,
    quad: () => quad,
    quantile: () => quantile,
    quartile: () => quartile,
    quartileIndex: () => quartileIndex,
    radius: () => radius,
    random: () => random,
    randomPerm: () => randomPerm,
    rank: () => rank,
    rawTransform: () => rawTransform,
    rawTransformConj: () => rawTransformConj,
    ray: () => ray,
    rayGlider: () => rayGlider,
    real: () => real,
    recursionCacheKey: () => recursionCacheKey,
    recursionDiverges: () => recursionDiverges,
    recursionMissingCacheEntry: () => recursionMissingCacheEntry,
    recursionSuccess: () => recursionSuccess,
    reflection: () => reflection,
    restriction: () => restriction,
    restrictionToBoolean: () => restrictionToBoolean,
    rgb: () => rgb,
    rotation: () => rotation,
    scaleTangentAngle: () => scaleTangentAngle,
    scaleTangentArc: () => scaleTangentArc,
    scaleTangentCircle: () => scaleTangentCircle,
    scaleTangentLine: () => scaleTangentLine,
    scaleTangentPolygon: () => scaleTangentPolygon,
    scaleTangentRay: () => scaleTangentRay,
    scaleTangentSegment: () => scaleTangentSegment,
    scaleTangentTransformation: () => scaleTangentTransformation,
    sec: () => sec,
    sech: () => sech,
    segment: () => segment,
    segmentGlider: () => segmentGlider,
    segmentThreeD: () => segmentThreeD,
    segmentThreeDGlider: () => segmentThreeDGlider,
    select: () => select,
    serializeNonNumericSeedPart: () => serializeNonNumericSeedPart,
    shuffle: () => shuffle,
    sign: () => sign,
    sin: () => sin,
    sinh: () => sinh,
    sortPerm: () => sortPerm,
    spearman: () => spearman,
    sphere: () => sphere,
    sqrtxsqm1: () => sqrtxsqm1,
    sqrtxsqp1: () => sqrtxsqp1,
    stats: () => stats,
    stdev: () => stdev,
    stdevp: () => stdevp,
    supplementAngle: () => supplementAngle,
    tSample: () => tSample,
    tan: () => tan,
    tanh: () => tanh,
    tcdf: () => tcdf,
    testingOnlySetRecursiveDepthLimit: () => testingOnlySetRecursiveDepthLimit,
    toFraction: () => toFraction,
    tone: () => tone,
    total: () => total,
    tpdf: () => tpdf,
    transformAngleMarker: () => transformAngleMarker,
    transformArc: () => transformArc,
    transformCircle: () => transformCircle,
    transformLine: () => transformLine,
    transformPoint: () => transformPoint,
    transformPolygon: () => transformPolygon,
    transformRay: () => transformRay,
    transformScaleFactor: () => transformScaleFactor,
    transformSegment: () => transformSegment,
    transformVector: () => transformVector,
    transformWithoutTranslation: () => transformWithoutTranslation,
    translation: () => translation,
    triangle: () => triangle,
    tscore: () => tscore,
    ttest: () => ttest,
    undirectedAngleMarker: () => undirectedAngleMarker,
    undirectedCoterminalAngle: () => undirectedCoterminalAngle,
    uniformSample: () => uniformSample,
    uniformcdf: () => uniformcdf,
    uniformpdf: () => uniformpdf,
    uniquePerm: () => uniquePerm,
    upperQuantileIndex: () => upperQuantileIndex,
    upperQuartileIndex: () => upperQuartileIndex,
    validateRangeLength: () => validateRangeLength,
    validateSampleCount: () => validateSampleCount,
    variance: () => variance,
    varp: () => varp,
    vector: () => vector,
    vectorDisplacementAsPoint: () => vectorDisplacementAsPoint,
    vectorThreeD: () => vectorThreeD,
    vectorThreeDDisplacementAsPoint: () => vectorThreeDDisplacementAsPoint,
    vertices: () => vertices,
    volume: () => volume,
  });
  var kD = function () {
    "use strict";
    function e(g, m) {
      let h = (g & 65535) + (m & 65535);
      return (g >> 16) + (m >> 16) + (h >> 16) << 16 | h & 65535;
    }
    function t(g, m) {
      return g << m | g >>> 32 - m;
    }
    function n(g, m, h, x, T, b) {
      return e(t(e(e(m, g), e(x, b)), T), h);
    }
    function r(g, m, h, x, T, b, M) {
      return n(m & h | ~m & x, g, m, T, b, M);
    }
    function s(g, m, h, x, T, b, M) {
      return n(m & x | h & ~x, g, m, T, b, M);
    }
    function i(g, m, h, x, T, b, M) {
      return n(m ^ h ^ x, g, m, T, b, M);
    }
    function o(g, m, h, x, T, b, M) {
      return n(h ^ (m | ~x), g, m, T, b, M);
    }
    function a(g, m) {
      g[m >> 5] |= 128 << m % 32, g[(m + 64 >>> 9 << 4) + 14] = m;
      let h,
        x,
        T,
        b,
        M,
        P = 1732584193,
        D = -271733879,
        S = -1732584194,
        O = 271733878;
      for (h = 0; h < g.length; h += 16) {
        x = P,
          T = D,
          b = S,
          M = O,
          P = r(P, D, S, O, g[h], 7, -680876936),
          O = r(O, P, D, S, g[h + 1], 12, -389564586),
          S = r(S, O, P, D, g[h + 2], 17, 606105819),
          D = r(D, S, O, P, g[h + 3], 22, -1044525330),
          P = r(P, D, S, O, g[h + 4], 7, -176418897),
          O = r(O, P, D, S, g[h + 5], 12, 1200080426),
          S = r(S, O, P, D, g[h + 6], 17, -1473231341),
          D = r(D, S, O, P, g[h + 7], 22, -45705983),
          P = r(P, D, S, O, g[h + 8], 7, 1770035416),
          O = r(O, P, D, S, g[h + 9], 12, -1958414417),
          S = r(S, O, P, D, g[h + 10], 17, -42063),
          D = r(D, S, O, P, g[h + 11], 22, -1990404162),
          P = r(P, D, S, O, g[h + 12], 7, 1804603682),
          O = r(O, P, D, S, g[h + 13], 12, -40341101),
          S = r(S, O, P, D, g[h + 14], 17, -1502002290),
          D = r(D, S, O, P, g[h + 15], 22, 1236535329),
          P = s(P, D, S, O, g[h + 1], 5, -165796510),
          O = s(O, P, D, S, g[h + 6], 9, -1069501632),
          S = s(S, O, P, D, g[h + 11], 14, 643717713),
          D = s(D, S, O, P, g[h], 20, -373897302),
          P = s(P, D, S, O, g[h + 5], 5, -701558691),
          O = s(O, P, D, S, g[h + 10], 9, 38016083),
          S = s(S, O, P, D, g[h + 15], 14, -660478335),
          D = s(D, S, O, P, g[h + 4], 20, -405537848),
          P = s(P, D, S, O, g[h + 9], 5, 568446438),
          O = s(O, P, D, S, g[h + 14], 9, -1019803690),
          S = s(S, O, P, D, g[h + 3], 14, -187363961),
          D = s(D, S, O, P, g[h + 8], 20, 1163531501),
          P = s(P, D, S, O, g[h + 13], 5, -1444681467),
          O = s(O, P, D, S, g[h + 2], 9, -51403784),
          S = s(S, O, P, D, g[h + 7], 14, 1735328473),
          D = s(D, S, O, P, g[h + 12], 20, -1926607734),
          P = i(P, D, S, O, g[h + 5], 4, -378558),
          O = i(O, P, D, S, g[h + 8], 11, -2022574463),
          S = i(S, O, P, D, g[h + 11], 16, 1839030562),
          D = i(D, S, O, P, g[h + 14], 23, -35309556),
          P = i(P, D, S, O, g[h + 1], 4, -1530992060),
          O = i(O, P, D, S, g[h + 4], 11, 1272893353),
          S = i(S, O, P, D, g[h + 7], 16, -155497632),
          D = i(D, S, O, P, g[h + 10], 23, -1094730640),
          P = i(P, D, S, O, g[h + 13], 4, 681279174),
          O = i(O, P, D, S, g[h], 11, -358537222),
          S = i(S, O, P, D, g[h + 3], 16, -722521979),
          D = i(D, S, O, P, g[h + 6], 23, 76029189),
          P = i(P, D, S, O, g[h + 9], 4, -640364487),
          O = i(O, P, D, S, g[h + 12], 11, -421815835),
          S = i(S, O, P, D, g[h + 15], 16, 530742520),
          D = i(D, S, O, P, g[h + 2], 23, -995338651),
          P = o(P, D, S, O, g[h], 6, -198630844),
          O = o(O, P, D, S, g[h + 7], 10, 1126891415),
          S = o(S, O, P, D, g[h + 14], 15, -1416354905),
          D = o(D, S, O, P, g[h + 5], 21, -57434055),
          P = o(P, D, S, O, g[h + 12], 6, 1700485571),
          O = o(O, P, D, S, g[h + 3], 10, -1894986606),
          S = o(S, O, P, D, g[h + 10], 15, -1051523),
          D = o(D, S, O, P, g[h + 1], 21, -2054922799),
          P = o(P, D, S, O, g[h + 8], 6, 1873313359),
          O = o(O, P, D, S, g[h + 15], 10, -30611744),
          S = o(S, O, P, D, g[h + 6], 15, -1560198380),
          D = o(D, S, O, P, g[h + 13], 21, 1309151649),
          P = o(P, D, S, O, g[h + 4], 6, -145523070),
          O = o(O, P, D, S, g[h + 11], 10, -1120210379),
          S = o(S, O, P, D, g[h + 2], 15, 718787259),
          D = o(D, S, O, P, g[h + 9], 21, -343485551),
          P = e(P, x),
          D = e(D, T),
          S = e(S, b),
          O = e(O, M);
      }
      return [P, D, S, O];
    }
    function u(g) {
      let m, h = "", x = g.length * 32;
      for (m = 0; m < x; m += 8) {
        h += String.fromCharCode(g[m >> 5] >>> m % 32 & 255);
      }
      return h;
    }
    function c(g) {
      let m, h = [];
      for (h[(g.length >> 2) - 1] = void 0, m = 0; m < h.length; m += 1) {
        h[m] = 0;
      }
      let x = g.length * 8;
      for (m = 0; m < x; m += 8) {
        h[m >> 5] |= (g.charCodeAt(m / 8) & 255) << m % 32;
      }
      return h;
    }
    function l(g) {
      return u(a(c(g), g.length * 8));
    }
    function p(g) {
      let m = "0123456789abcdef", h = "", x, T;
      for (T = 0; T < g.length; T += 1) {
        x = g.charCodeAt(T), h += m.charAt(x >>> 4 & 15) + m.charAt(x & 15);
      }
      return h;
    }
    function f(g) {
      return unescape(encodeURIComponent(g));
    }
    function d(g) {
      return l(f(g));
    }
    function y(g) {
      return p(d(g));
    }
    return y;
  }();
  function wi(e, t, n) {
    return e > 0 == t > 0 ? n === 1 ? t : e + n * (t - e) : e * (1 - n) + t * n;
  }
  function ar(e, t, n) {
    return [wi(e[0], t[0], n), wi(e[1], t[1], n)];
  }
  function Fi(e, t, n) {
    return [wi(e[0], t[0], n), wi(e[1], t[1], n), wi(e[2], t[2], n)];
  }
  function cf(e, t) {
    return [e[0] + t[0], e[1] + t[1]];
  }
  function HD(e, t) {
    return [e[0] - t[0], e[1] - t[1]];
  }
  function YP(e, t) {
    return [e[0] - t[0], e[1] - t[1], e[2] - t[2]];
  }
  function XP(e, t) {
    return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
  }
  function qa(e, t) {
    return Ql(YP(e, t));
  }
  function Xy(e, t, n) {
    return [wi(e[0], t[0], n[0]), wi(e[1], t[1], n[1])];
  }
  function zD(e, t) {
    return [e[0] * t, e[1] * t];
  }
  function Ql(e) {
    let [t, n, r] = e;
    return t * t + n * n + r * r;
  }
  function Kl(e, t) {
    let n = e[1] * t[2] - e[2] * t[1],
      r = e[2] * t[0] - e[0] * t[2],
      s = e[0] * t[1] - e[1] * t[0],
      i = Math.sqrt(n * n + r * r + s * s);
    return [n / i, r / i, s / i];
  }
  function ep(e, t, n) {
    e = Math.fround(e), t = Math.fround(t), n = Math.fround(n);
    let r = Math.fround(e * e + t * t + n * n);
    return isFinite(r) && r != 0;
  }
  function la([e, t, n]) {
    return isFinite(e) && isFinite(t) && isFinite(n);
  }
  function xi(e, t) {
    let n;
    e > t && (n = e, e = t, t = n);
    let r = e > 0, s = t > 0, i = Math.abs(e) > .01, o = Math.abs(t) > .01;
    if (i || o) return Va(e, t);
    if (e === 0) return t * Math.abs(t);
    if (t === 0) return e * Math.abs(e);
    if (r !== s) return 0;
    let a = r ? Math.sqrt(e * t) : -Math.sqrt(e * t);
    return a >= e && t >= a ? a : Va(e, t);
  }
  function QP(e, t, n, r, s) {
    if (!(isNaN(t) || isNaN(r) || t < 0 == r < 0)) {
      for (;;) {
        let i = xi(e, n), o = s(i);
        if (!isFinite(o)) return;
        if (i === e || i === n) {
          return Math.abs(t) <= Math.abs(r) ? [e, t] : [n, r];
        }
        if (o === 0) return pf(e, t, i, o, n, r, s);
        t < 0 != o < 0 ? (n = i, r = o) : (e = i, t = o);
      }
    }
  }
  function QD(e, t, n, r, s) {
    if (!(ZP(t) || ZP(r)) && WP(t, r)) {
      for (;;) {
        let i = xi(e, n), o = s(i);
        if (ZP(o)) return;
        if (i === e || i === n) return i;
        if (WP(t, o)) n = i, r = o;
        else if (WP(o, r)) e = i, t = o;
        else return;
      }
    }
  }
  function ZP(e) {
    for (let t of e) if (isNaN(t)) return true;
    return false;
  }
  function WP(e, t) {
    for (let n = 0; n < e.length; n++) if (!uB(e[n], t[n])) return false;
    return true;
  }
  function uB(e, t) {
    return e <= 0 && t >= 0 || e >= 0 && t <= 0;
  }
  function pf(e, t, n, r, s, i, o) {
    let a;
    if (!isFinite(r)) return;
    isFinite(t) || (a = xs(e, t, n, r, o), a !== void 0 && (e = a, t = o(e))),
      isFinite(i) || (a = xs(n, r, s, i, o), a !== void 0 && (s = a, i = o(a)));
    let u, c;
    t === r ? u = [e, t] : u = UD(e, t, n, r, o, r),
      i === r ? c = [s, i] : c = UD(n, r, s, i, o, r);
    let l;
    return u && c && (l = xi(u[0], c[0])), l !== void 0 ? [l, o(l)] : void 0;
  }
  function xs(e, t, n, r, s) {
    if (isFinite(t) !== isFinite(r)) {
      for (;;) {
        let i = xi(e, n), o = s(i);
        if (i === e || i === n) return isFinite(t) ? e : n;
        isFinite(o) !== isFinite(t) ? (n = i, r = o) : (e = i, t = o);
      }
    }
  }
  function Zy(e, t, n, r, s) {
    if (la(t) !== la(r)) {
      for (;;) {
        let i = xi(e, n), o = s(i);
        if (i === e || i === n) return la(t) ? e : n;
        la(o) !== la(t) ? (n = i, r = o) : (e = i, t = o);
      }
    }
  }
  function UD(e, t, n, r, s, i) {
    if (t === i != (r === i)) {
      for (;;) {
        let o = xi(e, n), a = s(o);
        if (o === e || o === n) return t === i ? [e, t] : [n, r];
        a === i != (t === i) ? (n = o, r = a) : (e = o, t = a);
      }
    }
  }
  function KD(e, t, n, r, s, i, o) {
    if (
      e < n && n < s && isFinite(t) && isFinite(r) && isFinite(i) && t !== r &&
      r !== i && r > t == r > i
    ) {
      for (;;) {
        let a = xi(e, n), u = o(a), c = xi(n, s), l = o(c);
        if (!isFinite(u) || !isFinite(l)) return;
        if (a === e || a === n || c === n || c === s) {
          return u > r == r > t ? [a, u] : l > r == r > t ? [c, l] : [n, r];
        }
        if (u === r || l === r) return pf(e, t, n, r, s, i, o);
        r > t && u > t && u > r || r < t && u < t && u < r
          ? (s = n, i = r, n = a, r = u)
          : r > t && l > r && l > i || r < t && l < r && l < i
          ? (e = n, t = r, n = c, r = l)
          : (e = a, t = u, s = c, i = l);
      }
    }
  }
  function Vi([e, t], [n, r]) {
    return (n - e) * (n - e) + (r - t) * (r - t);
  }
  function qD(e, t, n, r, s, i) {
    let o = i(e), a = i(t), u = i(n), c = Vi(o, r), l = Vi(a, r), p = Vi(u, r);
    if (
      !(t <= e || n <= t) && !(!isFinite(c) || !isFinite(l) || !isFinite(p)) &&
      !(l >= c || l >= p)
    ) {
      for (;;) {
        if (Math.abs(u[0] - o[0]) < s && Math.abs(u[1] - o[1]) < s) {
          return [e, n];
        }
        let f = xi(e, t),
          d = i(f),
          y = Vi(d, r),
          g = xi(t, n),
          m = i(g),
          h = Vi(m, r);
        if (!isFinite(y) || !isFinite(h)) {
          return;
        }
        if (f === e || f === t || g === t || g === n) {
          return y < l && y < h ? [f, f] : h < y && h < l ? [g, g] : [t, t];
        }
        if (
          (y === l || h === l) &&
          (t = .5 * (f + t), a = i(t), l = Vi(a, r), y === l || h === l)
        ) return [e, n];
        y < l && y < h
          ? ([n, t] = [t, f], [u, a] = [a, d], [p, l] = [l, y])
          : h < y && h < l
          ? ([e, t] = [t, g], [o, a] = [a, m], [c, l] = [l, h])
          : ([e, n] = [f, g], [o, u] = [d, m], [c, p] = [y, h]);
      }
    }
  }
  function $D(e, t, n) {
    return t === void 0 && (t = -1 / 0),
      n === void 0 && (n = 1 / 0),
      Math.min(n, Math.max(t, e));
  }
  function jP(e, t, n, r, s, i) {
    let o;
    if (r !== void 0 && s !== void 0) {
      let p = .5 * (r + s);
      o = n + .01 * (n < p ? s - r : r - s);
    } else o = Math.abs(n) > 1 ? n * 1.00001 : n + 1e-5;
    let a = e(n), u = e(o), c = Vi(a, t), l = Vi(u, t);
    if (!(!isFinite(c) || !isFinite(l))) {
      if (c === l) return [n, o];
      for (
        l > c && ([n, o] = [o, n], [a, u] = [u, a], [c, l] = [l, c]);
        isFinite(n) && isFinite(o) && n !== o;
      ) {
        if (s !== void 0 && o > s) return [s, s];
        if (r !== void 0 && o < r) return [r, r];
        let p = n + 3 * (o - n), f = e(p), d = Vi(f, t);
        if (!isFinite(d)) return [n, o];
        if (d === l) return [n, o];
        if (d > l) {
          let y = o > n ? qD(n, o, p, t, i, e) : qD(p, o, n, t, i, e);
          return y && [$D(y[0], r, s), $D(y[1], r, s)];
        }
        [n, c, o, l] = [o, l, p, d];
      }
      return [n, o];
    }
  }
  function YD(e, t, n, r) {
    return n
      ? r
        ? Math.min(Vi(e(r[0]), t), Vi(e(r[1]), t)) <
          Math.min(Vi(e(n[0]), t), Vi(e(n[1]), t))
        : false
      : true;
  }
  function EX(e, t, n, r, s, i) {
    let o = jP(e, t, n, r, s, i);
    if (r !== void 0) {
      let a = jP(e, t, r, r, s, i);
      YD(e, t, o, a) && (o = a);
    }
    if (s !== void 0) {
      let a = jP(e, t, s, r, s, i);
      YD(e, t, o, a) && (o = a);
    }
    return o;
  }
  function XD(e, t, n, r, s, i, o, a) {
    let u = Math.abs(r - t), c = Math.abs(i - r), l = Math.abs(a - i);
    return u > c && u > l ? [e, n] : l > c && l > u ? [s, o] : [n, s];
  }
  function tp(e, t, n, r, s, i, o, a = 0) {
    if (
      !((n - e) * (s - n) <= 0) &&
      !(!isFinite(e) || !isFinite(n) || !isFinite(s)) &&
      !(!isFinite(t) || !isFinite(i))
    ) {
      if (!isFinite(r)) {
        let u = xs(e, t, n, r, o), c = xs(n, r, s, i, o);
        return u === void 0 || c === void 0 ? void 0 : [u, c];
      }
      if (!(Math.abs(r - ((s - n) * t + (n - e) * i) / (s - e)) < a)) {
        for (;;) {
          let u = xi(e, n),
            c = o(u),
            l = xi(n, s),
            p = o(l),
            f = Math.abs(c - Va(t, r)),
            d = Math.abs(r - Va(c, p)),
            y = Math.abs(p - Va(r, i));
          if (f <= a && d <= a && y <= a) {
            return;
          }
          if (!isFinite(c)) {
            let g = xs(e, t, u, c, o), m = xs(u, c, s, i, o);
            return g === void 0 || m === void 0 ? void 0 : [g, m];
          }
          if (!isFinite(p)) {
            let g = xs(e, t, l, p, o), m = xs(l, p, s, i, o);
            return g === void 0 || m === void 0 ? void 0 : [g, m];
          }
          if (
            (u === e || u === n) && (l === n || l === s)
          ) return Math.abs(r - t) > Math.abs(i - r) ? [e, n] : [n, s];
          if (u === e || u === n) return XD(e, t, n, r, l, p, s, i);
          if (l === n || l === s) return XD(e, t, u, c, n, r, s, i);
          f > y && f >= d
            ? (s = n, i = r, n = u, r = c)
            : y > f && y >= d
            ? (e = n, t = r, n = l, r = p)
            : (e = u, t = c, s = l, i = p);
        }
      }
    }
  }
  var $a = (Math.sqrt(5) - 1) / 2;
  function lf(e, t) {
    return e > 0 == t > 0 ? e + $a * (t - e) : (1 - $a) * e + $a * t;
  }
  function hu(e, t) {
    let n;
    e > t && (n = e, e = t, t = n);
    let r = e > 0, s = t > 0, i = Math.abs(e) > .01, o = Math.abs(t) > .01;
    if (i || o) return lf(e, t);
    if (e === 0) return t * Math.abs(t);
    if (t === 0) return e * Math.abs(e);
    if (r !== s) return 0;
    let a = r ? Math.sqrt(e * t) : -Math.sqrt(e * t);
    return a >= e && t >= a ? a : lf(e, t);
  }
  function eS(e, t, n, r, s, i) {
    if (!isFinite(e) || !isFinite(n) || !isFinite(t) || !isFinite(r)) return;
    e > n && ([e, t, n, r] = [n, r, e, t]);
    let o = hu(e, n), a = s(o);
    if (Math.abs(a - lf(t, r)) <= i) return;
    let u = hu(e, o), c = s(u);
    for (;;) {
      let l = Math.abs(c - lf(t, a)), p = Math.abs(a - lf(r, c));
      if (l <= i && p <= i) return;
      if (l > p) {
        if (
          n = o, r = a, o = u, a = c, u = hu(e, o), c = s(u), u === e || u === o
        ) return WD(e, t, o, a, n, r);
        if (!isFinite(c)) return ZD(e, t, u, c, n, r, s);
      } else {
        if (
          e = u, t = c, u = o, c = a, o = hu(n, o), a = s(o), o === n || o === u
        ) return WD(e, t, u, c, n, r);
        if (!isFinite(a)) return ZD(e, t, o, a, n, r, s);
      }
    }
  }
  function ZD(e, t, n, r, s, i, o) {
    let a = xs(e, t, n, r, o), u = xs(n, r, s, i, o);
    if (!(a === void 0 || u === void 0)) return [a, u];
  }
  function WD(e, t, n, r, s, i) {
    return Math.abs(r - t) > Math.abs(i - r) ? [e, n] : [n, s];
  }
  function JP(e, t, n) {
    let r = e[0] * (1 - $a) + t[0] * $a - n[0],
      s = e[1] * (1 - $a) + t[1] * $a - n[1],
      i = e[2] * (1 - $a) + t[2] * $a - n[2];
    return r * r + s * s + i * i;
  }
  function Wy(e, t, n, r, s, i, o, a) {
    if (!isFinite(e) || !isFinite(n) || !la(t) || !la(r)) return;
    e > n && ([e, t, n, r] = [n, r, e, t]);
    let u = hu(e, n), c = s(u), l = i * i;
    if (JP(t, r, c) <= l) return;
    let p = hu(e, u), f = s(p);
    for (;;) {
      let d = JP(t, c, f), y = JP(r, f, c);
      if (d <= l && y <= l) return n - e < a ? p : void 0;
      if (d > y) {
        if (
          n = u,
            r = c,
            u = p,
            c = f,
            p = hu(e, u),
            f = s(p),
            p === e || u - p <= o
        ) return JD(e, t, u, c, n, r);
        if (!la(f)) return jD(e, t, p, f, n, r, s);
      } else {
        if (
          e = p,
            t = f,
            p = u,
            f = c,
            u = hu(n, u),
            c = s(u),
            u === n || u - p <= o
        ) return JD(e, t, p, f, n, r);
        if (!la(c)) return jD(e, t, u, c, n, r, s);
      }
    }
  }
  function jD(e, t, n, r, s, i, o) {
    let a = Zy(e, t, n, r, o), u = Zy(n, r, s, i, o);
    if (!(a === void 0 || u === void 0)) return [a, u];
  }
  function JD(e, t, n, r, s, i) {
    return qa(r, t) > qa(i, r) ? [e, n] : [n, s];
  }
  var df = class {
    constructor(t) {
      this.comparator = t;
      this._data = [];
    }
    size() {
      return this._data.length;
    }
    queue(t) {
      let n = this._data.length;
      for (this._data.push(t); n > 0;) {
        let r = n - 1 >>> 1;
        if (this.comparator(this._data[n], this._data[r]) < 0) {
          let s = this._data[r];
          this._data[r] = this._data[n], this._data[n] = s, n = r;
        } else break;
      }
    }
    dequeue() {
      let t = this._data[0], n = this._data.pop();
      if (this._data.length > 0 && n !== void 0) {
        this._data[0] = n;
        let r = 0, s = this._data.length - 1;
        for (;;) {
          let i = (r << 1) + 1, o = i + 1, a = r;
          if (
            i <= s && this.comparator(this._data[i], this._data[a]) < 0 &&
            (a = i),
              o <= s && this.comparator(this._data[o], this._data[a]) < 0 &&
              (a = o),
              a !== r
          ) {
            let u = this._data[a];
            this._data[a] = this._data[r], this._data[r] = u, r = a;
          } else break;
        }
      }
      return t;
    }
    peek() {
      return this._data[0];
    }
    clear() {
      this._data.length = 0;
    }
  };
  function lB(e, t) {
    let n = e.start[1] - e.end[1],
      r = e.end[0] - e.start[0],
      s = t.start[1] - t.end[1],
      i = t.end[0] - t.start[0],
      o = n * e.end[0] + r * e.end[1],
      a = s * t.end[0] + i * t.end[1],
      u = n * i - s * r;
    if (u !== 0) return (n * a - s * o) / u;
  }
  function pB(e, t, n) {
    if (n.xSlope >= t.xSlope) return;
    if (t.scanlineX === n.scanlineX) return e;
    let r = t.start[1] > t.end[1] ? t.start : t.end,
      s = n.start[1] > n.end[1] ? n.start : n.end,
      i = r[1];
    if (s[1] < r[1]) { if (i = s[1], KP(i, t) < s[0]) return; }
    else if (r[1] < s[1]) {
      let a = KP(i, n);
      if (r[0] < a) return;
    } else if (r[0] < s[0]) return;
    let o = lB(t, n);
    if (o !== void 0) return Math.max(Math.min(o, i), e);
  }
  function KP(e, t) {
    let n = t.end[0], r = t.start[0], s = t.end[1], i = t.start[1];
    if (s === e) return n;
    if (i === e) return r;
    {
      let o = (e - s) / (i - s), a = (1 - o) * n + o * r;
      if (n < r) {
        if (a <= n) return n;
        if (r <= a) return r;
      } else {
        if (a <= r) return r;
        if (n <= a) return n;
      }
      return a;
    }
  }
  function eE(e) {
    let t = 0, n = 0, r = false, s = 0;
    for (let { scanlineX: i, isClockwise: o } of e) {
      o ? s += 1 : s -= 1,
        s !== 0 && !r
          ? (r = true, n = i)
          : s === 0 && r && (r = false, t += i - n);
    }
    return t;
  }
  var ff = class {
    constructor(t) {
      this.scanlineY = -1 / 0;
      let n = 1;
      this.activeEdges = [],
        this.events = new df((r, s) => r.y - s.y),
        this.scanlineY = -1 / 0,
        this.polygonLength = t.length - 1;
      for (let r = t.length - 1; r >= 1; r--) {
        let s = t[r],
          i = t[r - 1],
          o = {
            id: n++,
            index: r - 1,
            end: s,
            start: i,
            scanlineX: 0,
            xSlope: 1 / 0,
            isClockwise: i[1] > s[1],
            skipIntersectionWith: {},
          };
        i[1] > s[1]
          ? (this.events.queue({ type: "+", y: s[1], edge: o }),
            this.events.queue({ type: "-", y: i[1], edge: o }),
            o.xSlope = (i[0] - s[0]) / (i[1] - s[1]),
            o.scanlineX = s[0])
          : s[1] > i[1]
          ? (this.events.queue({ type: "+", y: i[1], edge: o }),
            this.events.queue({ type: "-", y: s[1], edge: o }),
            o.xSlope = (s[0] - i[0]) / (s[1] - i[1]),
            o.scanlineX = i[0])
          : this.events.queue({ type: "h", y: i[1], edge: o });
      }
    }
    nextScanline() {
      var i;
      let t, n = this.events.peek();
      if (!n) return;
      if (n.y <= this.scanlineY) {
        throw new Error(
          "Programming error: expected next event to begin a new scanline",
        );
      }
      this.scanlineY = n.y, this.updateActiveEdgeScanlineIntersections();
      let r = eE(this.activeEdges), s = [];
      for (; t = this.events.dequeue();) {
        if (
          t.type === "x"
            ? this.swapActiveEdges(t)
            : t.type === "+"
            ? this.insertActiveEdge(t)
            : t.type === "-" && this.removeActiveEdge(t),
            s.push(t),
            ((i = this.events.peek()) == null ? void 0 : i.y) !== this.scanlineY
        ) {
          return {
            y: this.scanlineY,
            activeEdges: this.activeEdges,
            lengthBeforeProcessingEvents: r,
            events: s,
          };
        }
      }
    }
    updateActiveEdgeScanlineIntersections() {
      let t = -1 / 0;
      for (let n of this.activeEdges) {
        let r = KP(this.scanlineY, n);
        r < t ? r = t : t = r, n.scanlineX = r;
      }
    }
    insertActiveEdge(t) {
      let n = this.activeEdges,
        r = t.edge,
        s = t.y,
        { xSlope: i, scanlineX: o } = r,
        a;
      for (a = 0; a < n.length; a++) {
        let u = n[a];
        if (o < u.scanlineX || o === u.scanlineX && i <= u.xSlope) break;
      }
      n.splice(a, 0, r),
        this.checkIntersection(s, n[a - 1], r),
        this.checkIntersection(s, r, n[a + 1]);
    }
    checkIntersection(t, n, r) {
      if (
        !n || !r || n.index === (r.index + 1) % this.polygonLength ||
        r.index === (n.index + 1) % this.polygonLength
      ) return;
      if (n.id < r.id) { if (n.skipIntersectionWith[r.id]) return; }
      else if (r.skipIntersectionWith[n.id]) return;
      let s = pB(t, n, r);
      if (s === void 0) return;
      n.id < r.id
        ? n.skipIntersectionWith[r.id] = true
        : r.skipIntersectionWith[n.id] = true;
      let i = { type: "x", y: s, edge1: n, edge2: r };
      this.events.queue(i);
    }
    removeActiveEdge(t) {
      let n = this.activeEdges, r = t.edge, s = t.y, i = n.indexOf(r);
      n.splice(i, 1), this.checkIntersection(s, n[i - 1], n[i]);
    }
    swapActiveEdges(t) {
      let n = this.activeEdges,
        r = t.edge1,
        s = t.edge2,
        i = t.y,
        o = n.indexOf(r),
        a = o + 1;
      o === -1 || n[a] !== s
        ? r.id < s.id
          ? delete r.skipIntersectionWith[s.id]
          : delete s.skipIntersectionWith[r.id]
        : (n[o] = s,
          n[a] = r,
          this.checkIntersection(i, n[o - 1], s),
          this.checkIntersection(i, r, n[a + 1]));
    }
    static debugEvent(t) {
      let n = `y=${t.y} `;
      return n += t.type === "x"
        ? `[x ${t.edge1.index}/${t.edge2.index}]`
        : `[${t.type} ${t.edge.index}] (${t.edge.end})-(${t.edge.start})`,
        n;
    }
    debugState() {
      return `y=${this.scanlineY}
${this.activeEdges.map((t) => `[${t.index}] ${t.scanlineX}`)}`;
    }
  };
  function dB(e) {
    let t = e.slice(0, 2), n = e.slice(-2);
    return t[0] !== n[0] || t[1] !== n[1] ? [...e, ...t] : e;
  }
  function vX(e, t) {
    if (!e) return false;
    let n = dB(e), [r, s] = t, i = 0;
    for (let o = n.length - 1; o >= 3; o -= 2) {
      let a = n[o - 3], u = n[o - 2], c = n[o - 1], l = n[o];
      u > s != l > s && r < (c - a) * (s - u) / (l - u) + a &&
        (u > l ? i += 1 : u < l && (i -= 1));
    }
    return i !== 0;
  }
  function nS(e) {
    if (
      e.length < 4 || e[0][0] !== e[e.length - 1][0] ||
      e[0][1] !== e[e.length - 1][1]
    ) return 0;
    let t = new ff(e), n, r = 0, s;
    for (; s = t.nextScanline();) {
      let i = s.lengthBeforeProcessingEvents;
      n && (r += .5 * (s.y - n.y) * (i + n.length)),
        n = { y: s.y, length: eE(s.activeEdges) };
    }
    return r;
  }
  function rS(e) {
    if (!e.length) return [];
    if (e[0][0] !== e[e.length - 1][0] || e[0][1] !== e[e.length - 1][1]) {
      throw new Error(
        "Programming error: expected last point to be a duplicate of the first point.",
      );
    }
    for (let f = 0; f < e.length - 1; f++) {
      if (e[f][0] === e[f + 1][0] && e[f][1] === e[f + 1][1]) {
        throw new Error(
          `Programming error: unexpected duplicate point at ${f + 1}`,
        );
      }
    }
    let t = new ff(e), n = e.slice(0, -1).map(() => 0), r;
    for (; r = t.nextScanline();) {
      for (let f of r.events) {
        let d = {};
        if (f.type === "h") {
          let y = f.edge;
          d[y.index] = {
            xMin: Math.min(y.end[0], y.start[0]),
            xMax: Math.max(y.end[0], y.start[0]),
            dx: y.end[0] - y.start[0],
          };
        } else if (f.type === "x") {
          let y = f.edge1,
            g = f.edge2,
            m = tS([y.start, y.end], [g.start, g.end]),
            h = m > 0 ? -1 : m < 0 ? 1 : 0;
          n[y.index] += h, n[g.index] -= h;
        }
        for (let y of r.activeEdges) {
          let g = y.end[1] - y.start[1];
          for (let m in d) {
            let { xMin: h, xMax: x, dx: T } = d[m];
            if (h < y.scanlineX && y.scanlineX < x) {
              let b = T * g, M = b > 0 ? -1 : b < 0 ? 1 : 0;
              n[m] += M, n[y.index] -= M;
            }
          }
        }
      }
    }
    let s = e.slice(0, -1).map(() => 0), i = e[0][1], o = 0;
    for (let f = 1; f < e.length; f++) e[f][1] < i && (i = e[f][1], o = f);
    let a = e.length - 1,
      u = o > 0 ? o - 1 : a - 1,
      c = (o + 1) % a,
      p = tS([e[u], e[o]], [e[o], e[c]]) > 0 ? 1 : 0;
    s[o] = p > 0 ? -1 : 1;
    for (let f = 0; f < a - 1; f++) {
      let d = (o + f) % a;
      p += n[d], s[(d + 1) % a] = p > 0 ? -1 : 1;
    }
    return s;
  }
  function tS(e, t) {
    let n = e[1][0] - e[0][0],
      r = e[1][1] - e[0][1],
      s = t[1][0] - t[0][0],
      i = t[1][1] - t[0][1];
    return n * i - r * s;
  }
  var fB = tp,
    jy = xs,
    mB = 3.154019550531224,
    sS = Math.pow(2, -13),
    bu = sS * sS,
    iS = bu * bu,
    tE = bu,
    rE = 32,
    _o = [],
    xu = [];
  function yB(e, t) {
    for (let n = rE; n > 0; n--) {
      let r = mB / rE * n,
        s = Math.sinh(r),
        i = Math.cosh(Math.PI / 2 * s),
        o = 1 / (Math.exp(Math.PI / 2 * s) * i),
        a = Math.cosh(r) / (i * i);
      e.push(o), t.push(a);
    }
  }
  yB(_o, xu);
  var uS = 0;
  for (let e = 0; e < xu.length; e++) uS += xu[e];
  var Jy = 1 / (1 + 2 * uS);
  function zs(e, t, n) {
    return .5 * (t * (2 - n) + e * n);
  }
  function gB(e, t, n) {
    let r = .5 * (t + n), s = fB(t, e(t), r, e(r), n, e(n), e);
    return s ? .5 * (s[0] + s[1]) : r;
  }
  function mf(e, t, n, r, s) {
    return { x1: e, x2: t, value: n, error: r, minerror: s };
  }
  function oS(e, t, n) {
    let r = Math.abs(e(zs(t, n, bu))),
      s = Math.abs(e(zs(t, n, 2 * bu))),
      i = Math.abs(e(zs(t, n, 4 * bu)));
    return r < bu || s < bu ? false : r > 1.95 * s && s > 1.95 * i;
  }
  function nE(e, t, n) {
    let r = zs(n, t, _o[0]),
      s = zs(t, n, _o[0]),
      i = e(r),
      o = e(s),
      a = zs(t, n, 1),
      u = e(a),
      c,
      l;
    if (isFinite(u) && !isFinite(i)) {
      if (c = jy(r, i, a, u, e), Math.abs((c - t) / (n - t)) > tE) {
        return mf(t, n, NaN, NaN, NaN);
      }
      t = c, i = e(t);
    }
    if (isFinite(u) && !isFinite(o)) {
      if (l = jy(a, u, s, o, e), Math.abs((l - n) / (n - t)) > tE) {
        return mf(t, n, NaN, NaN, NaN);
      }
      n = l, o = e(n);
    }
    if (isFinite(i) && isFinite(o) && !isFinite(u)) {
      if (
        c = jy(r, i, a, u, e),
          l = jy(a, u, s, o, e),
          Math.abs((l - c) / (n - t)) > tE
      ) return mf(t, n, NaN, NaN, NaN);
      u = .5 * (c + l);
    }
    if (oS(e, t, n) || oS(e, n, t)) return mf(t, n, NaN, NaN, NaN);
    let p = u, f = 0, d = 0, y = 0, g = 0, m = 0, h = 0;
    for (let _ = 0; _ < rE; _ += 4) {
      m = e(zs(t, n, _o[_])),
        h = e(zs(n, t, _o[_])),
        g = Math.max(g, Math.abs(m), Math.abs(h)),
        f += xu[_] * (m + h),
        m = e(zs(t, n, _o[_ + 1])),
        h = e(zs(n, t, _o[_ + 1])),
        g = Math.max(g, Math.abs(m), Math.abs(h)),
        y += xu[_ + 1] * (m + h),
        m = e(zs(t, n, _o[_ + 2])),
        h = e(zs(n, t, _o[_ + 2])),
        g = Math.max(g, Math.abs(m), Math.abs(h)),
        d += xu[_ + 2] * (m + h),
        m = e(zs(t, n, _o[_ + 3])),
        h = e(zs(n, t, _o[_ + 3])),
        g = Math.max(g, Math.abs(m), Math.abs(h)),
        y += xu[_ + 3] * (m + h);
    }
    let x = p + f,
      T = x + d,
      b = T + y,
      M = Math.abs(d - x),
      P = Math.abs(y - T),
      D = Jy * (n - t) * b,
      S = Jy * Math.abs(n - t) * g * xu[0],
      O;
    return M === 0
      ? O = Jy * Math.abs(n - t) * P
      : O = Jy * Math.abs(n - t) * P * (P / M) * (P / M),
      O = Math.max(O, S),
      mf(t, n, D, O, S);
  }
  function aS(e) {
    let t = -1 / 0, n = -1 / 0, r = -1, s = 0;
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      s += o.value,
        o.error > t && (t = o.error, r = i),
        o.minerror > n && (n = o.minerror);
    }
    return { maxerror: t, maxminerror: n, maxindex: r, totalvalue: s };
  }
  function yf(e, t, n, r = 32) {
    if (isNaN(t) || isNaN(n)) return NaN;
    let s = 1;
    if (t > n) {
      let a = t;
      t = n, n = a, s = -1;
    }
    if (t === 1 / 0 && n === 1 / 0) return NaN;
    if (t === -1 / 0 && n === -1 / 0) return NaN;
    if (t === -1 / 0 && n === 1 / 0) {
      return s * yf(
        (a) =>
          e(a / ((1 + a) * (1 - a))) * (1 + a * a) /
          ((1 + a) * (1 + a) * (1 - a) * (1 - a)),
        -1,
        1,
        r,
      );
    }
    if (t === -1 / 0) {
      return s * yf((a) => -e(n - a / (1 - a)) / ((1 - a) * (1 - a)), 1, 0, r);
    }
    if (n === 1 / 0) {
      return s * yf((a) => e(t + a / (1 - a)) / ((1 - a) * (1 - a)), 0, 1, r);
    }
    let i = [nE(e, t, n)], o = aS(i);
    for (
      let a = 1;
      a < r &&
      !(Math.abs(o.maxerror / o.totalvalue) <= 32 * iS ||
        o.maxerror <= 32 * iS || o.maxerror <= 32 * o.maxminerror ||
        !isFinite(o.maxerror) || !isFinite(o.maxminerror));
      a++
    ) {
      let u = i[i.length - 1];
      i[i.length - 1] = i[o.maxindex], i[o.maxindex] = u;
      let c = i.pop(), l = gB(e, zs(c.x2, c.x1, .125), zs(c.x1, c.x2, .125));
      i.push(nE(e, c.x1, l)), i.push(nE(e, l, c.x2)), o = aS(i);
    }
    return !isFinite(o.maxerror) || !isFinite(o.maxminerror)
      ? NaN
      : Math.abs(o.totalvalue) <= 10 * o.maxminerror
      ? 0
      : s * o.totalvalue;
  }
  function Ya(e, t, n) {
    e.prototype = t.prototype = n, n.constructor = e;
  }
  function Tu(e, t) {
    var n = Object.create(e.prototype);
    for (var r in t) n[r] = t[r];
    return n;
  }
  function da() {}
  var Iu = .7,
    Gc = 1 / Iu,
    np = "\\s*([+-]?\\d+)\\s*",
    gf = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    pa = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    bB = /^#([0-9a-f]{3,8})$/,
    xB = new RegExp(`^rgb\\(${np},${np},${np}\\)$`),
    TB = new RegExp(`^rgb\\(${pa},${pa},${pa}\\)$`),
    IB = new RegExp(`^rgba\\(${np},${np},${np},${gf}\\)$`),
    PB = new RegExp(`^rgba\\(${pa},${pa},${pa},${gf}\\)$`),
    EB = new RegExp(`^hsl\\(${gf},${pa},${pa}\\)$`),
    MB = new RegExp(`^hsla\\(${gf},${pa},${pa},${gf}\\)$`),
    cS = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    };
  Ya(da, hf, {
    copy(e) {
      return Object.assign(new this.constructor(), this, e);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: lS,
    formatHex: lS,
    formatHex8: CB,
    formatHsl: DB,
    formatRgb: pS,
    toString: pS,
  });
  function lS() {
    return this.rgb().formatHex();
  }
  function CB() {
    return this.rgb().formatHex8();
  }
  function DB() {
    return hS(this).formatHsl();
  }
  function pS() {
    return this.rgb().formatRgb();
  }
  function hf(e) {
    var t, n;
    return e = (e + "").trim().toLowerCase(),
      (t = bB.exec(e))
        ? (n = t[1].length,
          t = parseInt(t[1], 16),
          n === 6 ? dS(t) : n === 3
            ? new Lr(
              t >> 8 & 15 | t >> 4 & 240,
              t >> 4 & 15 | t & 240,
              (t & 15) << 4 | t & 15,
              1,
            )
            : n === 8
            ? Qy(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255)
            : n === 4
            ? Qy(
              t >> 12 & 15 | t >> 8 & 240,
              t >> 8 & 15 | t >> 4 & 240,
              t >> 4 & 15 | t & 240,
              ((t & 15) << 4 | t & 15) / 255,
            )
            : null)
        : (t = xB.exec(e))
        ? new Lr(t[1], t[2], t[3], 1)
        : (t = TB.exec(e))
        ? new Lr(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1)
        : (t = IB.exec(e))
        ? Qy(t[1], t[2], t[3], t[4])
        : (t = PB.exec(e))
        ? Qy(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4])
        : (t = EB.exec(e))
        ? yS(t[1], t[2] / 100, t[3] / 100, 1)
        : (t = MB.exec(e))
        ? yS(t[1], t[2] / 100, t[3] / 100, t[4])
        : cS.hasOwnProperty(e)
        ? dS(cS[e])
        : e === "transparent"
        ? new Lr(NaN, NaN, NaN, 0)
        : null;
  }
  function dS(e) {
    return new Lr(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
  }
  function Qy(e, t, n, r) {
    return r <= 0 && (e = t = n = NaN), new Lr(e, t, n, r);
  }
  function bf(e) {
    return e instanceof da || (e = hf(e)),
      e ? (e = e.rgb(), new Lr(e.r, e.g, e.b, e.opacity)) : new Lr();
  }
  function kc(e, t, n, r) {
    return arguments.length === 1 ? bf(e) : new Lr(e, t, n, r == null ? 1 : r);
  }
  function Lr(e, t, n, r) {
    this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
  }
  Ya(
    Lr,
    kc,
    Tu(da, {
      brighter(e) {
        return e = e == null ? Gc : Math.pow(Gc, e),
          new Lr(this.r * e, this.g * e, this.b * e, this.opacity);
      },
      darker(e) {
        return e = e == null ? Iu : Math.pow(Iu, e),
          new Lr(this.r * e, this.g * e, this.b * e, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Lr(Bc(this.r), Bc(this.g), Bc(this.b), eg(this.opacity));
      },
      displayable() {
        return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g &&
          this.g < 255.5 && -.5 <= this.b && this.b < 255.5 &&
          0 <= this.opacity && this.opacity <= 1;
      },
      hex: fS,
      formatHex: fS,
      formatHex8: SB,
      formatRgb: mS,
      toString: mS,
    }),
  );
  function fS() {
    return `#${Vc(this.r)}${Vc(this.g)}${Vc(this.b)}`;
  }
  function SB() {
    return `#${Vc(this.r)}${Vc(this.g)}${Vc(this.b)}${
      Vc((isNaN(this.opacity) ? 1 : this.opacity) * 255)
    }`;
  }
  function mS() {
    let e = eg(this.opacity);
    return `${e === 1 ? "rgb(" : "rgba("}${Bc(this.r)}, ${Bc(this.g)}, ${
      Bc(this.b)
    }${e === 1 ? ")" : `, ${e})`}`;
  }
  function eg(e) {
    return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
  }
  function Bc(e) {
    return Math.max(0, Math.min(255, Math.round(e) || 0));
  }
  function Vc(e) {
    return e = Bc(e), (e < 16 ? "0" : "") + e.toString(16);
  }
  function yS(e, t, n, r) {
    return r <= 0
      ? e = t = n = NaN
      : n <= 0 || n >= 1
      ? e = t = NaN
      : t <= 0 && (e = NaN),
      new Lo(e, t, n, r);
  }
  function hS(e) {
    if (e instanceof Lo) return new Lo(e.h, e.s, e.l, e.opacity);
    if (e instanceof da || (e = hf(e)), !e) return new Lo();
    if (e instanceof Lo) return e;
    e = e.rgb();
    var t = e.r / 255,
      n = e.g / 255,
      r = e.b / 255,
      s = Math.min(t, n, r),
      i = Math.max(t, n, r),
      o = NaN,
      a = i - s,
      u = (i + s) / 2;
    return a
      ? (t === i
        ? o = (n - r) / a + (n < r) * 6
        : n === i
        ? o = (r - t) / a + 2
        : o = (t - n) / a + 4,
        a /= u < .5 ? i + s : 2 - i - s,
        o *= 60)
      : a = u > 0 && u < 1 ? 0 : o,
      new Lo(o, a, u, e.opacity);
  }
  function tg(e, t, n, r) {
    return arguments.length === 1 ? hS(e) : new Lo(e, t, n, r == null ? 1 : r);
  }
  function Lo(e, t, n, r) {
    this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
  }
  Ya(
    Lo,
    tg,
    Tu(da, {
      brighter(e) {
        return e = e == null ? Gc : Math.pow(Gc, e),
          new Lo(this.h, this.s, this.l * e, this.opacity);
      },
      darker(e) {
        return e = e == null ? Iu : Math.pow(Iu, e),
          new Lo(this.h, this.s, this.l * e, this.opacity);
      },
      rgb() {
        var e = this.h % 360 + (this.h < 0) * 360,
          t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
          n = this.l,
          r = n + (n < .5 ? n : 1 - n) * t,
          s = 2 * n - r;
        return new Lr(
          sE(e >= 240 ? e - 240 : e + 120, s, r),
          sE(e, s, r),
          sE(e < 120 ? e + 240 : e - 120, s, r),
          this.opacity,
        );
      },
      clamp() {
        return new Lo(gS(this.h), Ky(this.s), Ky(this.l), eg(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l &&
          this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
      },
      formatHsl() {
        let e = eg(this.opacity);
        return `${e === 1 ? "hsl(" : "hsla("}${gS(this.h)}, ${
          Ky(this.s) * 100
        }%, ${Ky(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
      },
    }),
  );
  function gS(e) {
    return e = (e || 0) % 360, e < 0 ? e + 360 : e;
  }
  function Ky(e) {
    return Math.max(0, Math.min(1, e || 0));
  }
  function sE(e, t, n) {
    return (e < 60
      ? t + (n - t) * e / 60
      : e < 180
      ? n
      : e < 240
      ? t + (n - t) * (240 - e) / 60
      : t) * 255;
  }
  var ng = Math.PI / 180, rg = 180 / Math.PI;
  var sg = 18,
    bS = .96422,
    xS = 1,
    TS = .82521,
    IS = 4 / 29,
    rp = 6 / 29,
    PS = 3 * rp * rp,
    vB = rp * rp * rp;
  function ES(e) {
    if (e instanceof fa) return new fa(e.l, e.a, e.b, e.opacity);
    if (e instanceof Xa) return CS(e);
    e instanceof Lr || (e = bf(e));
    var t = uE(e.r),
      n = uE(e.g),
      r = uE(e.b),
      s = iE((.2225045 * t + .7168786 * n + .0606169 * r) / xS),
      i,
      o;
    return t === n && n === r
      ? i = o = s
      : (i = iE((.4360747 * t + .3850649 * n + .1430804 * r) / bS),
        o = iE((.0139322 * t + .0971045 * n + .7141733 * r) / TS)),
      new fa(116 * s - 16, 500 * (i - s), 200 * (s - o), e.opacity);
  }
  function cE(e, t, n, r) {
    return arguments.length === 1 ? ES(e) : new fa(e, t, n, r == null ? 1 : r);
  }
  function fa(e, t, n, r) {
    this.l = +e, this.a = +t, this.b = +n, this.opacity = +r;
  }
  Ya(
    fa,
    cE,
    Tu(da, {
      brighter(e) {
        return new fa(
          this.l + sg * (e == null ? 1 : e),
          this.a,
          this.b,
          this.opacity,
        );
      },
      darker(e) {
        return new fa(
          this.l - sg * (e == null ? 1 : e),
          this.a,
          this.b,
          this.opacity,
        );
      },
      rgb() {
        var e = (this.l + 16) / 116,
          t = isNaN(this.a) ? e : e + this.a / 500,
          n = isNaN(this.b) ? e : e - this.b / 200;
        return t = bS * oE(t),
          e = xS * oE(e),
          n = TS * oE(n),
          new Lr(
            aE(3.1338561 * t - 1.6168667 * e - .4906146 * n),
            aE(-.9787684 * t + 1.9161415 * e + .033454 * n),
            aE(.0719453 * t - .2289914 * e + 1.4052427 * n),
            this.opacity,
          );
      },
    }),
  );
  function iE(e) {
    return e > vB ? Math.pow(e, 1 / 3) : e / PS + IS;
  }
  function oE(e) {
    return e > rp ? e * e * e : PS * (e - IS);
  }
  function aE(e) {
    return 255 *
      (e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055);
  }
  function uE(e) {
    return (e /= 255) <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);
  }
  function OB(e) {
    if (e instanceof Xa) return new Xa(e.h, e.c, e.l, e.opacity);
    if (e instanceof fa || (e = ES(e)), e.a === 0 && e.b === 0) {
      return new Xa(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
    }
    var t = Math.atan2(e.b, e.a) * rg;
    return new Xa(
      t < 0 ? t + 360 : t,
      Math.sqrt(e.a * e.a + e.b * e.b),
      e.l,
      e.opacity,
    );
  }
  function MS(e, t, n, r) {
    return arguments.length === 1 ? OB(e) : new Xa(e, t, n, r == null ? 1 : r);
  }
  function Xa(e, t, n, r) {
    this.h = +e, this.c = +t, this.l = +n, this.opacity = +r;
  }
  function CS(e) {
    if (isNaN(e.h)) return new fa(e.l, 0, 0, e.opacity);
    var t = e.h * ng;
    return new fa(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
  }
  Ya(
    Xa,
    MS,
    Tu(da, {
      brighter(e) {
        return new Xa(
          this.h,
          this.c,
          this.l + sg * (e == null ? 1 : e),
          this.opacity,
        );
      },
      darker(e) {
        return new Xa(
          this.h,
          this.c,
          this.l - sg * (e == null ? 1 : e),
          this.opacity,
        );
      },
      rgb() {
        return CS(this).rgb();
      },
    }),
  );
  var OS = -.14861,
    lE = 1.78277,
    pE = -.29227,
    ig = -.90649,
    xf = 1.97294,
    DS = xf * ig,
    SS = xf * lE,
    vS = lE * pE - ig * OS;
  function NB(e) {
    if (e instanceof Hc) return new Hc(e.h, e.s, e.l, e.opacity);
    e instanceof Lr || (e = bf(e));
    var t = e.r / 255,
      n = e.g / 255,
      r = e.b / 255,
      s = (vS * r + DS * t - SS * n) / (vS + DS - SS),
      i = r - s,
      o = (xf * (n - s) - pE * i) / ig,
      a = Math.sqrt(o * o + i * i) / (xf * s * (1 - s)),
      u = a ? Math.atan2(o, i) * rg - 120 : NaN;
    return new Hc(u < 0 ? u + 360 : u, a, s, e.opacity);
  }
  function dE(e, t, n, r) {
    return arguments.length === 1 ? NB(e) : new Hc(e, t, n, r == null ? 1 : r);
  }
  function Hc(e, t, n, r) {
    this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
  }
  Ya(
    Hc,
    dE,
    Tu(da, {
      brighter(e) {
        return e = e == null ? Gc : Math.pow(Gc, e),
          new Hc(this.h, this.s, this.l * e, this.opacity);
      },
      darker(e) {
        return e = e == null ? Iu : Math.pow(Iu, e),
          new Hc(this.h, this.s, this.l * e, this.opacity);
      },
      rgb() {
        var e = isNaN(this.h) ? 0 : (this.h + 120) * ng,
          t = +this.l,
          n = isNaN(this.s) ? 0 : this.s * t * (1 - t),
          r = Math.cos(e),
          s = Math.sin(e);
        return new Lr(
          255 * (t + n * (OS * r + lE * s)),
          255 * (t + n * (pE * r + ig * s)),
          255 * (t + n * (xf * r)),
          this.opacity,
        );
      },
    }),
  );
  function gcd1(e, t) {
    if (!isFinite(e) || !isFinite(t)) return NaN;
    if (
      e = Math.round(e),
        t = Math.round(t),
        e < 0 && (e = -e),
        t < 0 && (t = -t),
        t > e
    ) {
      let r = t;
      t = e, e = r;
    }
    if (t === 0) return e;
    let n = e % t;
    for (; n > 0;) e = t, t = n, n = e % t;
    return t;
  }
  function pow1(e, t) {
    if (isNaN(e) && t === 0) return NaN;
    if (e >= 0 || t === Math.floor(t)) return Math.pow(e, t);
    let n = toFraction1(t, 100);
    return si(n.n / n.d, t, 2) && n.d % 2 === 1
      ? (n.n % 2 === 0 ? 1 : -1) * Math.pow(-e, t)
      : NaN;
  }
  var fE = [
      Bool,
      Restriction,
      Number,
      Complex,
      Point,
      Point3D,
      Segment3D,
      Vector3D,
      Triangle3D,
      Sphere3D,
      Action,
      RGBColor,
      Polygon,
      Segment,
      Circle,
      Arc,
      Line,
      Ray,
      Vector,
      AngleMarker,
      DirectedAngleMarker,
      Transformation,
      Tone,
    ],
    AB = new Set(fE),
    Tf = Qn.of(fE.filter((e) => wn(e))),
    If = Qn.of(fE.filter((e) => !wn(e)));
  function io(e) {
    return AB.has(e);
  }
  function NS(e) {
    return io(e);
  }
  function ls(e) {
    return AS(e, NaN);
  }
  function RS(e) {
    return AS(e, 0);
  }
  function AS(e, t) {
    switch (e) {
      case Number:
        return t;
      case Point:
        return [t, t];
      case Point3D:
        return [t, t, t];
      case Segment3D:
      case Vector3D:
        return [[t, t, t], [t, t, t]];
      case Triangle3D:
        return [[t, t, t], [t, t, t], [t, t, t]];
      case Sphere3D:
        return [[[t, t, t], [t, t, t], [t, t, t]], t];
      case RGBColor:
        return [t, t, t];
      case Action:
        return { type: "Action", updateRules: {} };
      case Segment:
      case Ray:
      case Line:
        return [[t, t], [t, t]];
      case Vector:
        return [[t, t], [t, t]];
      case Circle:
        return [[t, t], t];
      case Arc:
        return [[t, t], [t, t], [t, t]];
      case Bool:
      case Restriction:
        return false;
      case Polygon:
        return [];
      case Transformation:
        return [[t, t], [t, t], false];
      case AngleMarker:
      case DirectedAngleMarker:
        return [[t, t], t, t, t];
      case Tone:
        return [t, t];
      case Complex:
        return [t, t];
      default:
        let n = e;
        throw new Error(
          `${n} does not have a ${t === 0 ? "zero" : "NaN"} type.`,
        );
    }
  }
  function _S(e, t) {
    return ws(ls(e), t);
  }
  var md5Spyable = { spy: kD },
    {
      cosh: cosh,
      sinh: sinh,
      tanh: tanh,
      acosh: acosh,
      asinh: asinh,
      atanh: atanh,
      expm1: expm1,
      log1p: log1p,
      sign: sign,
      hypot: hypot,
    } = Math,
    toFraction = toFraction1,
    gcd = gcd1,
    pow = pow1,
    SYMBOL_DIVERGES = Symbol("DIVERGES"),
    RecursiveFunctionResult = ((
      n,
    ) => (n[n.SUCCESS = 0] = "SUCCESS",
      n[n.MISSING_CACHE_ENTRY = 1] = "MISSING_CACHE_ENTRY",
      n))(RecursiveFunctionResult || {}),
    LruCacheClass = class LruCacheClass {
      constructor(t = LruCacheClass.defaultLimit, n) {
        this.limit = t;
        this.computeSize = n;
        this.currentSize = 0;
        this.cache = new Map();
      }
      get(t) {
        let n = this.cache.get(t);
        return n && (this.cache.delete(t), this.cache.set(t, n)),
          n == null ? void 0 : n.value;
      }
      set(t, n) {
        let r = this.computeSize ? this.computeSize(n) : 1;
        if (this.currentSize + r >= this.limit) {
          let s = this.cache.keys().next().value;
          this.cache.delete(s);
        }
        this.cache.set(t, { size: r, value: n });
      }
    };
  LruCacheClass.defaultLimit = 1e5;
  var LruCache = LruCacheClass,
    RECURSIVE_DEPTH_LIMIT = 1e4,
    RECURSIVE_COMPUTATION_LIMIT = RECURSIVE_DEPTH_LIMIT * 2;
  function getRecursiveDepthLimit() {
    return RECURSIVE_DEPTH_LIMIT;
  }
  function testingOnlySetRecursiveDepthLimit(e) {
    RECURSIVE_DEPTH_LIMIT = e;
  }
  var TerminationStatus = ((
    n,
  ) => (n[n.DoesNotTerminate = 0] = "DoesNotTerminate",
    n[n.DepthLimitExceeded = 1] = "DepthLimitExceeded",
    n))(TerminationStatus || {});
  function recursionDiverges(e, t) {
    if (io(t)) return e.recursionTerminationStatus = 0, ls(t);
    throw Rx();
  }
  function handleRecursionLimitExceeded(e, t) {
    if (io(t)) return e.recursionTerminationStatus = 1, ls(t);
    throw Ax();
  }
  var LS = new WeakMap();
  function getBroadcastTargetElements(e) {
    let t = LS.get(e);
    return t || (t = new Set(e), LS.set(e, t)), t;
  }
  function recursionCacheKey(e) {
    return `${e.fn}:${JSON.stringify(e.args)}`;
  }
  function recursionSuccess(e, t) {
    return { status: 0, result: [e, t] };
  }
  function recursionMissingCacheEntry(e) {
    return { status: 1, stackFrame: e };
  }
  function executeRecursiveFunction(e, t, n, r) {
    let s = e.recursiveFunctionCache || new LruCache(), i = [];
    i.push(r);
    let o = 0;
    for (; i.length > 0;) {
      if (
        i.length > RECURSIVE_DEPTH_LIMIT || o++ > RECURSIVE_COMPUTATION_LIMIT
      ) return handleRecursionLimitExceeded(e, n);
      let a = i.pop(), { fn: u, args: c } = a, l = t[u](s, ...c);
      if (l === SYMBOL_DIVERGES) return recursionDiverges(e, n);
      if ((l == null ? void 0 : l.status) === 1) {
        i.push({ fn: u, args: c }), i.push(l.stackFrame);
      } else {
        let p = recursionCacheKey(a);
        s.set(p, l.result);
      }
    }
    return s.get(recursionCacheKey(r))[0];
  }
  var sqrtxsqp1 = function (e) {
      let t = e * e;
      return 1 + t === 1 ? 1 : 1 + t === t ? Math.abs(e) : Math.sqrt(t + 1);
    },
    sqrtxsqm1 = function (e) {
      let t = e * e;
      return t < 1 ? NaN : t - 1 === t ? Math.abs(e) : Math.sqrt(t - 1);
    };
  function clamp(e, t, n) {
    return Math.max(t, Math.min(n, e));
  }
  function mod(e, t) {
    let n = e % t;
    return e * t < 0 && n !== 0 ? n + t : n;
  }
  function lcm(e, t) {
    if (e = Math.round(e), t = Math.round(t), !isFinite(e) || !isFinite(t)) {
      return NaN;
    }
    if (e === 0 && t === 0) return 0;
    let n = gcd(e, t);
    return Math.abs(e / n * t);
  }
  function listGCD(e) {
    if (e.length === 0) return NaN;
    if (e.length === 1) return gcd(e[0], 0);
    let t = e[0];
    for (let n = 1; n < e.length; n++) t = gcd(t, e[n]);
    return t;
  }
  function listLCM(e) {
    if (e.length === 0) return NaN;
    if (e.length === 1) return lcm(e[0], 1);
    let t = e[0];
    for (let n = 1; n < e.length; n++) t = lcm(t, e[n]);
    return t;
  }
  function complexListGCD(e) {
    if (e.length === 0) return [NaN, NaN];
    if (e.length === 1) return complexGCD(e[0], [0, 0]);
    let t = e[0];
    for (let n = 1; n < e.length; n++) t = complexGCD(t, e[n]);
    return t;
  }
  function complexListLCM(e) {
    if (e.length === 0) return [NaN, NaN];
    if (e.length === 1) return complexLCM(e[0], [1, 0]);
    let t = e[0];
    for (let n = 1; n < e.length; n++) t = complexLCM(t, e[n]);
    return t;
  }
  function nCr(e, t) {
    if (isNaN(e)) return e;
    if (isNaN(t)) return t;
    if (!isFinite(e) && !isFinite(t)) return NaN;
    if (t === 0 || e === t) return 1;
    if (e === 0) return Bi(t);
    let n = isFinite(e) && e === Math.round(e),
      r = isFinite(t) && t === Math.round(t);
    if (e < 0 && t < 0 && e - t < 0) {
      return n && r ? 0 : Bi(e - t) * Bi(t) / (Bi(e) * nCr(-e, -t));
    }
    if (e < 0 && t > 0 && e - t < 0) {
      return n && r
        ? Math.pow(-1, t) * nCr(t - e - 1, t)
        : Bi(e - t) / Bi(e) * nCr(-(e - t), t);
    }
    if (e < 0 && t < 0 && e - t > 0) {
      return n && r
        ? Math.pow(-1, e - t) * nCr(-t - 1, e - t)
        : Bi(t) / Bi(e) * nCr(-t, -e);
    }
    if (e > 0 && t < 0 && e - t > 0) {
      let a = Math.abs(e) > Math.abs(t) ? -t : e;
      return Bi(t) / nCr(e - t, a);
    }
    if (e > 0 && t > 0 && e - t < 0) return Bi(e - t) / nCr(t, e);
    if (e < 0 || t < 0 || e - t < 0 || e < 15 && t < 15 && e - t < 15) {
      return nPr(e, t) / factorial(t);
    }
    let s = Ti(e) - Ti(t) - Ti(e - t) - (e - t) * log1p(-t / e),
      i = Math.sqrt(e / (2 * Math.PI * t * (e - t))) * Math.pow(e / t, t) *
        Math.exp(s);
    return n && r && e > 0 && t > 0 && e - t > 0 ? Math.round(i) : i;
  }
  function nPr(e, t) {
    if (isNaN(e)) return e;
    if (isNaN(t)) return t;
    if (!isFinite(e) && !isFinite(t)) return NaN;
    if (t === 0) return 1;
    if (e === 0) return 1 / factorial(-t);
    if (e === t) return factorial(e);
    let n = isFinite(e) && e === Math.round(e),
      r = isFinite(t) && t === Math.round(t);
    if (e < 0 && e - t < 0) {
      return n && r
        ? Math.pow(-1, t) * nPr(t - e - 1, t)
        : Bi(e - t) / Bi(e) * nPr(-(e - t), t);
    }
    if (e < 0 || e - t < 0 || e < 15 && e - t < 15) {
      return factorial(e) / factorial(e - t);
    }
    let s = Ti(e) - Ti(e - t) - (e - t) * log1p(-t / e),
      i = Math.sqrt(e / (e - t)) * Ig(e, t) * Math.exp(s);
    return n && r && e > 0 && t > 0 && e - t > 0 ? Math.round(i) : i;
  }
  function factorial(e) {
    if (e === -1 / 0) return NaN;
    let t = Math.round(e) === e;
    if (e < 0) return t ? 1 / 0 : 1 / (Bi(e) * wS(-e));
    let n = wS(e);
    return t ? Math.round(n) : n;
  }
  function wS(e) {
    return e > 171 ? 1 / 0 : e < 14 ? ZB(e) : JB(e);
  }
  function ZB(e) {
    let t = 4.077131788261185,
      n = 7.024675027156382,
      r = 6.657107767450176,
      s = 3.766266976716022,
      i = 1.2792371666711133,
      o = .24304596436338005,
      a = .020049769312165774,
      u = 4.154347453162709,
      c = 7.270007565107539,
      l = 6.97805297331391,
      p = 3.989651532924167,
      f = 1.367176195613119,
      d = .26175627691546965,
      y = .021742722739397567,
      g = 1 + e * (t + e * (n + e * (r + e * (s + e * (i + e * (o + e * a)))))),
      m = 1 + e * (u + e * (c + e * (l + e * (p + e * (f + e * (d + e * y)))))),
      h = e + 1,
      x = 1 - (h - e);
    return Ig(h, e) * Math.sqrt(h + (2 * e + 1) * x) * (g / m);
  }
  var WB = Math.pow(2, 27) + 1;
  function jB(e) {
    let t = WB * e;
    return t - (t - e);
  }
  var mE = .3678794428706169, yE = -16991745912462731e-25;
  function Ig(e, t) {
    let n = jB(e), r = e - n, s = e * (mE + yE);
    if (s === 0) return Math.pow(e / Math.E, t);
    let i = n * mE - s + n * yE + r * mE + r * yE;
    return Math.pow(s, t) * (1 + t * (i / s));
  }
  function JB(e) {
    return Ig(e, e) * Math.sqrt(2 * Math.PI * e) * Math.exp(ov(e));
  }
  var bernoulliTable = [
    1 / 6,
    -1 / 30,
    1 / 42,
    -1 / 30,
    5 / 66,
    -691 / 2730,
    7 / 6,
    -3617 / 510,
    43867 / 798,
    -174611 / 330,
    854513 / 138,
    -236364091 / 2730,
    8553103 / 6,
    -23749461029 / 870,
  ];
  function cotDerivative(e, t) {
    if (e !== Math.floor(e)) return NaN;
    if (e < 0) return NaN;
    if (e === 0) return 1 / tan(t);
    let n = sin(t);
    if (e === 1) return -1 / (n * n);
    let r = cos(t);
    if (e === 2) return 2 * r / (n * n * n);
    let s = [0, 2], i = [];
    for (let a = 3; a <= e; a++) {
      i = [];
      for (let u = 0; u < a; u++) {
        let c = 0, l = 0;
        u > 0 && (c = (a - u + 1) * s[u - 1]),
          u + 2 < a && (l = (u + 1) * s[u + 1]),
          i.push(-(c + l));
      }
      s = i;
    }
    let o = 0;
    for (let a = e - 1; a >= 0; a--) o = i[a] + r * o;
    return o / Math.pow(n, e + 1);
  }
  function polyGamma(e, t) {
    if (e < 0) return NaN;
    if (e !== Math.floor(e)) return NaN;
    let n = e % 2 === 0 ? -1 : 1;
    if (t < 0) {
      return -n * polyGamma(e, 1 - t) -
        Math.pow(Math.PI, e + 1) * cotDerivative(e, Math.PI * t);
    }
    let r = factorial(e), s = 0, i = Math.pow(t, -(e + 1));
    for (; t < 10;) s += i, t++, i = Math.pow(t, -(e + 1));
    s += e === 0 ? -Math.log(t) : i * t / e, s += .5 * i;
    let o = bernoulliTable,
      a = e + 1,
      u = 2,
      c = i * t * a / u,
      l = 1 / (t * t);
    for (let p = 1; p <= 14; p++) {
      c *= l, s += c * o[p - 1], a++, u++, c *= a / u, a++, u++, c *= a / u;
    }
    return r * n * s;
  }
  function log(e) {
    let t = Math.log(e);
    return Math.exp(Math.round(t)) === e ? Math.round(t) : t;
  }
  function dg(e, t) {
    if (t === 0) return NaN;
    let n;
    return t === Math.E
      ? n = Math.log(e)
      : t === 2 && Math.log2
      ? n = Math.log2(e)
      : t === 10 && Math.log10
      ? n = Math.log10(e)
      : n = Math.log(e) / Math.log(t),
      Math.pow(t, Math.round(n)) === e ? Math.round(n) : n;
  }
  function common_log(e) {
    return dg(e, 10);
  }
  function complexLogbase(e, t) {
    let [n, r] = e, [s, i] = t;
    return i === 0 && s === 0
      ? [NaN, NaN]
      : n === 0 && r === 0
      ? [-1 / 0, 0]
      : i === 0 && r === 0 && s > 0
      ? n > 0 ? complex(dg(n, s), 0) : complex(dg(-n, s), Math.PI / Math.log(s))
      : complexDivide(complexLog(e), complexLog(t));
  }
  function complexCommonLog(e) {
    return complexLogbase(e, [10, 0]);
  }
  var iv = 1 / Math.PI;
  function Pg(e) {
    return e > 1e12 ? false : Math.round(iv * e) * Math.PI === e;
  }
  function Eg(e) {
    if (e > 1e12) return false;
    let t = Math.round(2 * iv * e);
    return t % 2 === 1 && t * Math.PI === 2 * e;
  }
  function sin(e) {
    return Pg(Math.abs(e)) ? 0 : Math.sin(e);
  }
  function cos(e) {
    return Eg(Math.abs(e)) ? 0 : Math.cos(e);
  }
  function tan(e) {
    let t = Math.abs(e);
    return Pg(t) ? 0 : Eg(t) ? 1 / 0 : Math.tan(e);
  }
  function sec(e) {
    return Eg(Math.abs(e)) ? 1 / 0 : 1 / Math.cos(e);
  }
  function csc(e) {
    return Pg(Math.abs(e)) ? 1 / 0 : 1 / Math.sin(e);
  }
  function cot(e) {
    let t = Math.abs(e);
    return Pg(t) ? 1 / 0 : Eg(t) ? 0 : 1 / Math.tan(e);
  }
  function acot(e) {
    return e > 0 ? Math.atan(1 / e) : Math.PI / 2 - Math.atan(e);
  }
  function acsc(e) {
    return Math.asin(1 / e);
  }
  function asec(e) {
    return Math.acos(1 / e);
  }
  function sech(e) {
    return 1 / cosh(e);
  }
  function csch(e) {
    return 1 / sinh(e);
  }
  function coth(e) {
    return 1 / tanh(e);
  }
  function asech(e) {
    return acosh(1 / e);
  }
  function acsch(e) {
    return asinh(1 / e);
  }
  function acoth(e) {
    return atanh(1 / e);
  }
  function f3(e) {
    if (e === 0 || isNaN(e)) return e;
    if (!isFinite(e)) return NaN;
    if (e === Math.floor(e)) return e > 0 ? 0 : -0;
    let t = Math.round(2 * e),
      n = -.5 * t + e,
      r = t & 2 ? -1 : 1,
      s = t & 1 ? Math.cos(Math.PI * n) : Math.sin(Math.PI * n);
    return r * s;
  }
  function Bi(e) {
    return e === 1 / 0 || e === -1 / 0
      ? 0
      : e === 0
      ? 1
      : f3(e) / (Math.PI * e);
  }
  function mean(e) {
    let t = 0;
    for (let n = 0; n < e.length; n++) t += e[n];
    return t / e.length;
  }
  function total(e) {
    let t = 0;
    for (let n = 0; n < e.length; n++) t += e[n];
    return t;
  }
  function TE(e) {
    return e > 50
      ? Math.exp(
        .5 * ((1 - e) * log1p(-1 / (e - 1)) - 1) + Ti(.5 * (e - 1)) -
          Ti(.5 * (e - 2)),
      ) * Math.sqrt((1 - 1 / e) / (2 * Math.PI))
      : e / (e + 1) * factorial((e + 1) / 2) /
        (factorial(e / 2) * Math.sqrt(e * Math.PI));
  }
  function cp(e, t, n = e - t) {
    if (Math.abs(n) < .1 * (e + t)) {
      let r = n / (e + t), s = n * n / (e + t), i = 2 * e * r;
      for (let o = 1; o < 10; o++) {
        i *= r * r;
        let a = s + i / (2 * o + 1);
        if (a == s) return a;
        s = a;
      }
    }
    return e * Math.log(e / t) + t - e;
  }
  var y3 = [
    0,
    .08106146679532726,
    .0413406959554093,
    .02767792568499834,
    .020790672103765093,
    .016644691189821193,
    .013876128823070748,
    .01189670994589177,
    .010411265261972096,
    .009255462182712733,
    .00833056343336287,
    .007573675487951841,
    .00694284010720953,
    .006408994188004207,
    .0059513701127588475,
    .005554733551962801,
  ];
  function Ti(e) {
    return e > 15
      ? ov(e)
      : e < 0
      ? NaN
      : e === Math.floor(e)
      ? y3[e]
      : Math.log(factorial(e) / (Ig(e, e) * Math.sqrt(2 * Math.PI * e)));
  }
  function ov(e) {
    let t = .08333333333333333,
      n = .002777777777777778,
      r = .0007936507936507937,
      s = .0005952380952380953,
      i = .0008417508417508417,
      o = e * e;
    return (t - (n - (r - (s - i / o) / o) / o) / o) / e;
  }
  function tpdf(e, t) {
    return t <= 0 ? NaN : TE(t) * Math.pow(1 + e * e / t, -((t + 1) / 2));
  }
  function qc(e, t) {
    if (t > 0) return 1 - qc(e, -t);
    if (t === -1 / 0) return 0;
    if (t === 0) return .5;
    if (e >= 40 && t > -1) return .5 + TE(e) * g3(e, t);
    if (t / e < -1e3) {
      let r = t * t;
      return TE(e) * Math.pow(e, .5 * (e - 1)) * Math.pow(Math.abs(t), -e) *
        (1 -
          e * e * (e + 1) * (1 / (2 + e) + e * (e + 3) / (4 * (4 + e) * r)) /
            (2 * r));
    }
    let n = Math.sqrt(t * t + e);
    return h3((t + n) / (2 * n), e / 2, e / 2);
  }
  function g3(e, t) {
    let n = t * t / e, r = t, s = r;
    for (let i = 1; i <= 15; i++) {
      r *= -(2 * i - 1) / (2 * i + 1) * (.5 * (e + 1) + i - 1) / i * n, s += r;
    }
    return s;
  }
  function tcdf(e, t, n) {
    return n <= 0
      ? NaN
      : e === -1 / 0
      ? qc(n, t)
      : e > 0 && t > 0
      ? qc(n, -e) - qc(n, -t)
      : qc(n, t) - qc(n, e);
  }
  function h3(e, t, n) {
    if (e < 0 || e > 1) {
      throw new RangeError("First argument must be between 0 and 1.");
    }
    if (t === 1 && n === 1) return e;
    if (e === 0) return 0;
    if (e === 1) return 1;
    if (t === 0) return 1;
    if (n === 0) return 0;
    {
      let r = Ti(t + n) - Ti(t) - Ti(n) - cp(t, (t + n) * e) -
          cp(n, (t + n) * (1 - e), (t + n) * e - t),
        s = Math.exp(r) * Math.sqrt(t * n / (2 * Math.PI * (t + n)));
      return e < (t + 1) / (t + n + 2)
        ? s * FS(e, t, n) / t
        : 1 - s * FS(1 - e, n, t) / n;
    }
  }
  function FS(e, t, n) {
    let r = Math.pow(2, -52),
      s = 1e-300,
      i = t + n,
      o = t + 1,
      a = t - 1,
      u = 1,
      c = 1 - i * e / o;
    Math.abs(c) < s && (c = s), c = 1 / c;
    let l = c;
    for (let p = 1; p <= 100; p++) {
      let f = 2 * p, d = p * (n - p) * e / ((a + f) * (t + f));
      c = 1 + d * c,
        Math.abs(c) < s && (c = s),
        u = 1 + d / u,
        Math.abs(u) < s && (u = s),
        c = 1 / c,
        l *= c * u,
        d = -(t + p) * (i + p) * e / ((t + f) * (o + f)),
        c = 1 + d * c,
        Math.abs(c) < s && (c = s),
        u = 1 + d / u,
        Math.abs(u) < s && (u = s),
        c = 1 / c;
      let y = c * u;
      if (l *= y, Math.abs(y - 1) <= r) return l;
    }
    return l;
  }
  function b3(e, t) {
    let n = Math.pow(2, -52),
      r = 1e-300,
      s = 1,
      i = e,
      o = s / i,
      a = s / r,
      u = 1 / i,
      c = 2,
      l = 0,
      p = i,
      f = -(e - 1),
      d = 0;
    do f -= 1,
      p += 1,
      u = u * f * t + p,
      u === 0 && (u = r),
      a = p + f * t / a,
      a === 0 && (a = r),
      u = 1 / u,
      l = a * u,
      o = o * l,
      d += 1,
      p += 1,
      u = u * d * t + p,
      u === 0 && (u = r),
      a = p + d * t / a,
      a === 0 && (a = r),
      u = 1 / u,
      l = a * u,
      o *= l,
      c += 2; while (c < 100 && Math.abs(l - 1) > n);
    return o;
  }
  function x3(e, t) {
    let n = Math.pow(2, -52),
      r = 1e-300,
      s = 1,
      i = t + 1 - e,
      o = s / i,
      a = s / r,
      u = 1 / i,
      c = 2,
      l = 0,
      p = i;
    do {
      let f = -(c - 1) * (c - e - 1);
      p += 2,
        u = u * f + p,
        u === 0 && (u = r),
        a = p + f / a,
        a === 0 && (a = r),
        u = 1 / u,
        l = a * u,
        o *= l,
        c += 1;
    } while (c < 100 && Math.abs(l - 1) > n);
    return o;
  }
  function T3(e, t) {
    let n = t / e,
      r = sign(t - e) * Math.sqrt(2 * cp(1, n)),
      s = [
        1,
        -.3333333333333333,
        .08333333333333333,
        -.014814814814814815,
        .0011574074074074073,
        .0003527336860670194,
        -.0001787551440329218,
        3919263178522438e-20,
        -2185448510679992e-21,
        -185406221071516e-20,
        8296711340953087e-22,
        -17665952736826078e-23,
        6707853543401498e-24,
        10261809784240309e-24,
        -4382036018453353e-24,
        914769958223679e-24,
        -25514193994946248e-27,
        -5830772132550426e-26,
        24361948020667415e-27,
        -50276692801141755e-28,
        11004392031956135e-29,
        3371763262400985e-28,
        -1392388722418162e-28,
        28534893807047445e-30,
        -5139111834242572e-31,
        -19752288294349442e-31,
        8099521156704561e-31,
      ],
      i = s.length - 2,
      o = 0,
      a = 0,
      u = 0,
      c = 0;
    for (; i >= 0; i--) {
      u = (i + 2) * o / e + s[i + 1], c = r * c + u, o = a, a = u;
    }
    if (c = e / (e + o) * c, t < e) {
      let l = Math.exp(-.5 * e * r * r) *
        (.5 * erfcx(-r * Math.sqrt(e / 2)) - c / Math.sqrt(2 * Math.PI * e));
      return isFinite(l) ? 1 - l : 1;
    } else {
      let l = Math.exp(-.5 * e * r * r) *
        (.5 * erfcx(r * Math.sqrt(e / 2)) + c / Math.sqrt(2 * Math.PI * e));
      return isFinite(l) ? l : 0;
    }
  }
  function VS(e, t, n) {
    return (e - t) / (Math.SQRT2 * Math.abs(n));
  }
  function Pf(e) {
    return e < 0
      ? .5 * Math.exp(-e * e) * erfcx(-e)
      : 1 - .5 * Math.exp(-e * e) * erfcx(e);
  }
  function normalcdf(e, t, n, r) {
    let s = VS(t, n, r);
    if (e === -1 / 0) return Pf(s);
    let i = VS(e, n, r);
    return i > 0 && s > 0 ? Pf(-i) - Pf(-s) : Pf(s) - Pf(i);
  }
  function normalpdf(e, t, n) {
    return 1 / Math.sqrt(2 * Math.PI * n * n) *
      Math.exp(-(e - t) * (e - t) / (2 * n * n));
  }
  function serializeNonNumericSeedPart(e, t) {
    return `t${e}:${bg(t)}`;
  }
  function random(e) {
    let t = md5Spyable.spy(e),
      n = parseInt(t.slice(0, 8), 16) & 2097151,
      r = parseInt(t.slice(8, 16), 16);
    return (n * 4294967296 + r) / 9007199254740992;
  }
  function av(e, t) {
    for (let n = t.length - 1; n > 0; n--) {
      let r = e + "::sc" + n, s = Math.floor(random(r) * (n + 1)), i = t[n];
      t[n] = t[s], t[s] = i;
    }
  }
  function shuffle(e, t) {
    let n = t.slice();
    return av(e, n), n;
  }
  function randomPerm(e, t) {
    let n = [];
    for (let r = 0; r < t; r++) n.push(r);
    return av(e, n), n;
  }
  function uniformSample(e, t, n) {
    return random(e) * (n - t) + t;
  }
  function normalSample(e, t, n) {
    let r = 0, s, i, o, a;
    do s = e + "::sc" + r,
      r += 1,
      i = uniformSample(s, 0, 1) * 2 - 1,
      s = e + "::sc" + r,
      r += 1,
      o = uniformSample(s, 0, 1) * 2 - 1,
      a = i * i + o * o; while (a >= 1 || a === 0);
    let u = Math.sqrt(-2 * Math.log(a) / a);
    return t + n * i * u;
  }
  function tSample(e, t) {
    if (t <= 0) return NaN;
    let n = 0, r, s, i, o;
    do r = e + "::sc" + n,
      n += 1,
      s = uniformSample(r, 0, 1) * 2 - 1,
      r = e + "::sc" + n,
      n += 1,
      i = uniformSample(r, 0, 1) * 2 - 1,
      o = s * s + i * i; while (o > 1);
    let a = s * s / o, u = t * (Math.pow(o, -2 / t) - 1);
    return r = e + "::sc" + n,
      n += 1,
      (uniformSample(r, 0, 1) < .5 ? -1 : 1) * Math.sqrt(a * u);
  }
  function binomSample(e, t, n) {
    return t = clamp(Math.round(t), 0, 1 / 0),
      t === 1 / 0
        ? NaN
        : (n = clamp(n, 0, 1), invBinom(uniformSample(e, 0, 1), t, n));
  }
  function poissonSample(e, t) {
    return t < 0 ? NaN : invPoisson(uniformSample(e, 0, 1), t);
  }
  function cg(e, t, n) {
    return e >= t
      ? 1
      : e < 0
      ? 0
      : e < Math.floor((t + 1) * n)
      ? BS(e, t, n)
      : 1 - BS(t - e - 1, t, 1 - n);
  }
  function BS(e, t, n) {
    let r = (1 - n) / n, s = binompdf(e, t, n), i = s;
    for (; e > 0 && (s *= e / (t - e + 1) * r, i + s !== i); e--) i += s;
    return i;
  }
  function binomcdf(e, t, n, r) {
    return n = clamp(Math.round(n), 0, 1 / 0),
      n === 1 / 0
        ? NaN
        : (r = clamp(r, 0, 1),
          t < 0
            ? 0
            : (e = Math.ceil(e),
              t = Math.floor(t),
              e === -1 / 0 ? cg(t, n, r) : cg(t, n, r) - cg(e - 1, n, r)));
  }
  function binompdf(e, t, n) {
    if (e = Math.round(e), t = clamp(Math.round(t), 0, 1 / 0), t === 1 / 0) {
      return NaN;
    }
    if (n = clamp(n, 0, 1), e < 0 || e > t) return 0;
    if (n === 0) return e === 0 ? 1 : 0;
    if (n === 1) return e === t ? 1 : 0;
    if (e === 0) return Math.exp(t * log1p(-n));
    if (e === t) return Math.pow(n, t);
    let r = Ti(t) - Ti(e) - Ti(t - e) - cp(e, t * n) -
      cp(t - e, t * (1 - n), t * n - e);
    return Math.exp(r) * Math.sqrt(t / (2 * Math.PI * e * (t - e)));
  }
  function poissonpdf(e, t) {
    return t < 0
      ? NaN
      : (e = Math.round(e),
        e < 0
          ? 0
          : t === 0
          ? e === 0 ? 1 : 0
          : e === 0
          ? Math.exp(-t)
          : Math.exp(-Ti(e) - cp(e, t)) / Math.sqrt(2 * Math.PI * e));
  }
  function Ef(e, t) {
    if (isNaN(e) || isNaN(t)) return NaN;
    if (e === 1 / 0) return 1;
    if (e = Math.floor(e), e < 0) return 0;
    if (t === 0) return 1;
    if (e + 1 > 12 && 2.35 * (e + 1) > t && .3 * (e + 1) < t) {
      return T3(e + 1, t);
    }
    if (e + 1 >= t) {
      let n = b3(e + 1, t);
      return isFinite(n) ? 1 - t * poissonpdf(e, t) * n : 1;
    } else {
      let n = x3(e + 1, t);
      return isFinite(n) ? t * poissonpdf(e, t) * n : 0;
    }
  }
  function poissoncdf(e, t, n) {
    return n < 0
      ? NaN
      : (e = Math.ceil(e),
        t = Math.floor(t),
        t < 0 ? 0 : e === -1 / 0 ? Ef(t, n) : Ef(t, n) - Ef(e - 1, n));
  }
  function uniformpdf(e, t, n) {
    return n <= t ? NaN : e < t || e > n ? 0 : 1 / (n - t);
  }
  function GS(e, t, n) {
    return n <= t ? NaN : e < t ? 0 : e > n ? 1 : (e - t) / (n - t);
  }
  function uniformcdf(e, t, n, r) {
    return GS(t, n, r) - GS(e, n, r);
  }
  function erf(e) {
    let t = -e * e;
    return t < -750
      ? e >= 0 ? 1 : -1
      : e >= .065
      ? 1 - Math.exp(t) * erfcx(e)
      : e <= -.065
      ? Math.exp(t) * erfcx(-e) - 1
      : e *
        (1.1283791670955126 +
          t *
            (.37612638903183754 +
              t *
                (.11283791670955126 +
                  t * (.026866170645131252 + t * .005223977625442188))));
  }
  function erfcx(e) {
    let t = .9999999999999999,
      n = 2.224574423459406,
      r = 2.444115549920689,
      s = 1.7057986861852539,
      i = .8257463703357973,
      o = .28647031042892007,
      a = .07124513844341643,
      u = .012296749268608364,
      c = .001347817214557592,
      l = 7263959403471071e-20,
      p = 1,
      f = 3.352953590554884,
      d = 5.227518529742423,
      y = 5.003720878235473,
      g = 3.266590890998987,
      m = 1.5255421920765353,
      h = .5185887413188858,
      x = .12747319185915415,
      T = .02185979575963238,
      b = .0023889438122503674,
      M = .00012875032817508128;
    if (e < 0) {
      return e < -6.1 ? 2 * Math.exp(e * e) : 2 * Math.exp(e * e) - erfcx(-e);
    }
    if (e > 50) {
      let P = .5641895835477563, D = e * e;
      return e > 5e7
        ? P / e
        : P * (D * (D + 4.5) + 2) / (e * (D * (D + 5) + 3.75));
    } else {
      let P = t +
          e *
            (n +
              e *
                (r +
                  e *
                    (s +
                      e *
                        (i + e * (o + e * (a + e * (u + e * (c + e * l)))))))),
        D = p +
          e *
            (f +
              e *
                (d +
                  e *
                    (y +
                      e *
                        (g +
                          e *
                            (m +
                              e *
                                (h + e * (x + e * (T + e * (b + e * M)))))))));
      return P / D;
    }
  }
  function invNorm(e) {
    let t = -39.6968302866538,
      n = 220.946098424521,
      r = -275.928510446969,
      s = 138.357751867269,
      i = -30.6647980661472,
      o = 2.50662827745924,
      a = -54.4760987982241,
      u = 161.585836858041,
      c = -155.698979859887,
      l = 66.8013118877197,
      p = -13.2806815528857,
      f = -.00778489400243029,
      d = -.322396458041136,
      y = -2.40075827716184,
      g = -2.54973253934373,
      m = 4.37466414146497,
      h = 2.93816398269878,
      x = .00778469570904146,
      T = .32246712907004,
      b = 2.445134137143,
      M = 3.75440866190742,
      P = .02425,
      D,
      S,
      O;
    return e > .5
      ? -invNorm(1 - e)
      : e === .5
      ? 0
      : e < 0
      ? NaN
      : e === 0
      ? -1 / 0
      : (e < P
        ? (D = Math.sqrt(-2 * Math.log(e)),
          O = (((((f * D + d) * D + y) * D + g) * D + m) * D + h) /
            ((((x * D + T) * D + b) * D + M) * D + 1))
        : (D = e - .5,
          S = D * D,
          O = (((((t * S + n) * S + r) * S + s) * S + i) * S + o) * D /
            (((((a * S + u) * S + c) * S + l) * S + p) * S + 1)),
        O -
        Math.sqrt(2 * Math.PI) *
          (.5 * erfcx(-O / Math.SQRT2) - Math.exp(.5 * O * O) * e));
  }
  function invPoisson(e, t) {
    if (t < 0 || e < 0 || e > 1) return NaN;
    if (t === 0 || e === 0) return 0;
    if (e === 1) return 1 / 0;
    let n = -1, r = Math.ceil(t);
    for (; Ef(r, t) < e;) r = 2 * r;
    let s = Math.floor(n + (r - n) / 2);
    for (; n < s && s < r;) {
      Ef(s, t) < e ? n = s : r = s, s = Math.floor(n + (r - n) / 2);
    }
    return r;
  }
  function invBinom(e, t, n) {
    if (t !== Math.round(t)) return NaN;
    if (n < 0 || n > 1) return NaN;
    if (e < 0 || e > 1) return NaN;
    if (e === 0) return 0;
    if (e === 1) return t;
    if (t === 0) return 0;
    if (n === 1) return t;
    if (n === 0) return 0;
    let r = -1, s = t, i = Math.floor(r + (s - r) / 2);
    for (; r < i && i < s;) {
      cg(i, t, n) < e ? r = i : s = i, i = Math.floor(r + (s - r) / 2);
    }
    return s;
  }
  function invT(e, t) {
    if (isNaN(t) || t <= 0 || e < 0 || e > 1) return NaN;
    if (e === 0) return -1 / 0;
    if (e === 1) return 1 / 0;
    if (t === 1 || t === 2 || t === 4) return gE(t, e);
    let n, r;
    if (e === .5) return 0;
    if (e > .5) {
      n = t > 1 ? invNorm(e) : gE(1, e),
        r = t > 1
          ? gE(1, e)
          : Math.pow(tpdf(0, t) * Math.pow(t, (t - 1) / 2) / (1 - e), 1 / t);
    } else return -invT(1 - e, t);
    return R3(t, e, n, r);
  }
  function gE(e, t) {
    let n = 4 * t * (1 - t);
    switch (e) {
      case 1:
        return Math.tan(Math.PI * (t - .5));
      case 2:
        return 2 * (t - .5) * Math.sqrt(2 / n);
      case 4:
        let r = Math.cos(Math.acos(Math.sqrt(n)) / 3) / Math.sqrt(n);
        return sign(t - .5) * 2 * Math.sqrt(r - 1);
      default:
        throw new Error("_invTSimple() must be called with 1, 2, or 4 df.");
    }
  }
  function R3(e, t, n, r) {
    if (!isFinite(n) || !isFinite(r)) return NaN;
    let s = n, i = r;
    for (;;) {
      let o = xi(s, i), a = qc(e, o);
      if (o === s || o === i) return a > t ? s : i;
      a < t ? s = o : i = o;
    }
  }
  function invUniform(e, t, n) {
    return e < 0 || e > 1 || n <= t
      ? NaN
      : e === 0
      ? t
      : e === 1
      ? n
      : t + e * (n - t);
  }
  function tscore(e, t) {
    let n = stdev(e);
    return (mean(e) - t) * Math.sqrt(e.length) / n;
  }
  function itscore(e, t) {
    let n = e.length,
      r = mean(e),
      s = stdev(e),
      i = t.length,
      o = mean(t),
      a = stdev(t),
      u = Math.sqrt(((n - 1) * s * s + (i - 1) * a * a) / (n + i - 2));
    return (r - o) / (u * Math.sqrt(1 / n + 1 / i));
  }
  function op(e, t, n) {
    return n < 0
      ? tcdf(-1 / 0, e, t)
      : n > 0
      ? tcdf(-1 / 0, -e, t)
      : 2 * tcdf(-1 / 0, -Math.abs(e), t);
  }
  function ttest(e, t) {
    arguments.length === 1 && (t = 0);
    let n = tscore(e, t), r = e.length - 1;
    return {
      lessThan: op(n, r, -1),
      greaterThan: op(n, r, 1),
      notEqual: op(n, r, 0),
    };
  }
  function ittest(e, t) {
    let n = itscore(e, t), r = e.length + t.length - 2;
    return {
      lessThan: op(n, r, -1),
      greaterThan: op(n, r, 1),
      notEqual: op(n, r, 0),
    };
  }
  function stats(e) {
    return {
      min: listMin(e),
      q1: quartile(e, 1),
      median: median(e),
      q3: quartile(e, 3),
      max: listMax(e),
    };
  }
  function listLength(e) {
    return e.length;
  }
  function listMin(e) {
    if (e.length < 1) return NaN;
    let t = e[0];
    if (isNaN(t)) return NaN;
    for (let n = 1; n < e.length; n++) {
      if (isNaN(e[n])) return NaN;
      e[n] < t && (t = e[n]);
    }
    return t;
  }
  function listMax(e) {
    if (e.length < 1) return NaN;
    let t = e[0];
    if (isNaN(t)) return NaN;
    for (let n = 1; n < e.length; n++) {
      if (isNaN(e[n])) return NaN;
      e[n] >= t && (t = e[n]);
    }
    return t;
  }
  function quantile(e, t) {
    if (!isFinite(t) || t < 0 || t > 1) return NaN;
    if (e.some(isNaN)) return NaN;
    if (e.length === 0) return NaN;
    let n = e.length, r = sortPerm(e), s = t * (n - 1);
    return Math.floor(s) === s
      ? e[r[s]]
      : (Math.ceil(s) - s) * e[r[Math.floor(s)]] +
        (s - Math.floor(s)) * e[r[Math.ceil(s)]];
  }
  function quartile(e, t) {
    if (!isFinite(t) || t < 0 || t > 4) return NaN;
    if (e.some(isNaN)) return NaN;
    let n = sortPerm(e),
      r = quartileIndex(e, t),
      s = Math.floor(r),
      i = Math.ceil(r);
    return (e[n[s]] + e[n[i]]) / 2;
  }
  function IE(e, t) {
    let n = e - t;
    return Number.isNaN(n) ? +Number.isNaN(e) - +Number.isNaN(t) : n;
  }
  function compareComplexLexicographic(e, t) {
    return IE(e[0], t[0]) || IE(e[1], t[1]);
  }
  function yv(e) {
    let t = [];
    for (let n = 0; n < e; n++) t.push(n);
    return t;
  }
  function sortPerm(e) {
    return yv(e.length).sort((t, n) => IE(e[t], e[n]));
  }
  function complexSortPerm(e) {
    return yv(e.length).sort((t, n) => compareComplexLexicographic(e[t], e[n]));
  }
  function quartileIndex(e, t) {
    t = Math.round(t);
    let n = e.length, r = n % 2 === 1, s;
    return n === 1
      ? 0
      : (t === 0 && (s = 0),
        t === 2 && (s = (n - 1) / 2),
        t === 4 && (s = n - 1),
        t === 1 && (s = r ? (n + 1) / 4 - 1 : (n + 2) / 4 - 1),
        t === 3 && (s = r ? (3 * n + 3) / 4 - 1 : (3 * n + 2) / 4 - 1),
        s === void 0 ? NaN : s);
  }
  function upperQuantileIndex(e, t) {
    return sortPerm(e)[Math.ceil(t * (e.length - 1))] + 1;
  }
  function lowerQuantileIndex(e, t) {
    return sortPerm(e)[Math.floor(t * (e.length - 1))] + 1;
  }
  function upperQuartileIndex(e, t) {
    return sortPerm(e)[Math.ceil(quartileIndex(e, t))] + 1;
  }
  function lowerQuartileIndex(e, t) {
    return sortPerm(e)[Math.floor(quartileIndex(e, t))] + 1;
  }
  function median(e) {
    return quantile(e, .5);
  }
  function argMin(e) {
    if (e.length < 1) return 0;
    let t = e[0];
    if (isNaN(t)) return 0;
    let n = 0;
    for (let r = 1; r < e.length; r++) {
      if (isNaN(e[r])) return 0;
      e[r] < t && (n = r, t = e[r]);
    }
    return n + 1;
  }
  function argMax(e) {
    if (e.length < 1) return 0;
    let t = e[0];
    if (isNaN(t)) return 0;
    let n = 0;
    for (let r = 1; r < e.length; r++) {
      if (e[r] >= t) {
        if (isNaN(e[r])) return 0;
        n = r, t = e[r];
      }
    }
    return n + 1;
  }
  function varp(e) {
    let t = mean(e), n = 0;
    for (let r = 0; r < e.length; r++) {
      let s = e[r] - t;
      n += s * s;
    }
    return n / e.length;
  }
  function mad(e) {
    let t = mean(e), n = 0;
    for (let r = 0; r < e.length; r++) n += Math.abs(e[r] - t);
    return n / e.length;
  }
  function variance(e) {
    let t = e.length;
    return varp(e) * t / (t - 1);
  }
  function covp(e, t) {
    let n = Math.min(e.length, t.length);
    e.length !== n && (e = e.slice(0, n)),
      t.length !== n && (t = t.slice(0, n));
    let r = mean(e), s = mean(t), i = 0;
    for (let o = 0; o < n; o++) i += (e[o] - r) * (t[o] - s);
    return i / n;
  }
  function cov(e, t) {
    let n = Math.min(e.length, t.length);
    return covp(e, t) * n / (n - 1);
  }
  function corr(e, t) {
    let n = Math.min(e.length, t.length);
    e.length !== n && (e = e.slice(0, n)),
      t.length !== n && (t = t.slice(0, n));
    let r = mean(e), s = mean(t), i = 0, o = 0, a = 0;
    for (let u = 0; u < n; u++) {
      let c = e[u] - r, l = t[u] - s;
      i += c * c, o += l * l, a += c * l;
    }
    return a / Math.sqrt(i * o);
  }
  function validateRangeLength(e, t, n, r) {
    let s = e[0];
    for (let o = 2; o < e.length; o++) {
      let a = V(Ps(ai(e[o], s), n));
      if (!si(a, o, 10)) return 0;
    }
    let i = V(r);
    for (let o = 0; o < t.length - 1; o++) {
      let a = V(Ps(ai(t[o], s), n));
      if (!si(a, i - t.length + o, 10)) return 0;
    }
    return !isFinite(i) || i < e.length || i < t.length ? 0 : i;
  }
  function validateSampleCount(e) {
    return e < 0 || !isFinite(e) ? 0 : e;
  }
  function rank(e) {
    let t = e.length;
    if (t === 0) return [];
    let n = [], r = [];
    for (let a = 0; a < t; a++) r.push([e[a], a]);
    r.sort((a, u) => {
      let c = a[0], l = u[0];
      return c === 1 / 0 && l === 1 / 0 || c === -1 / 0 && l === -1 / 0
        ? 0
        : c - l;
    });
    let s = 0, i = 1, o = 1;
    for (; s < t;) {
      let a = s;
      for (; a < t - 1 && r[a][0] === r[a + 1][0];) a += 1;
      o = a - s + 1;
      let u;
      for (a = 0; a < o; a++) {
        u = r[s + a][1], n[u] = isNaN(e[u]) ? NaN : i + .5 * (o - 1);
      }
      i += o, s += o;
    }
    return n;
  }
  function spearman(e, t) {
    let n = Math.min(e.length, t.length);
    return e.length !== n && (e = e.slice(0, n)),
      t.length !== n && (t = t.slice(0, n)),
      corr(rank(e), rank(t));
  }
  function stdev(e) {
    return Math.sqrt(variance(e));
  }
  function stdevp(e) {
    return Math.sqrt(varp(e));
  }
  var quad = yf;
  function distance(e, t) {
    return hypot(t[0] - e[0], t[1] - e[1]);
  }
  function distanceThreeD(e, t) {
    return hypot(t[0] - e[0], hypot(t[1] - e[1], t[2] - e[2]));
  }
  function rgb(e, t, n) {
    return [
      clamp(Math.round(e), 0, 255),
      clamp(Math.round(t), 0, 255),
      clamp(Math.round(n), 0, 255),
    ];
  }
  function hsv(e, t, n) {
    isFinite(e) || (e = 0), t = clamp(t, 0, 1), n = clamp(n, 0, 1);
    let r = n * (1 - t / 2);
    r === 0 || r === 1 ? t = 0 : t = (n - r) / Math.min(r, 1 - r);
    let { r: s, g: i, b: o } = tg(e, t, r).rgb();
    return rgb(s, i, o);
  }
  function polygon(e) {
    return e;
  }
  function segmentThreeD(e, t) {
    return [e, t];
  }
  function triangle(e, t, n) {
    return [e, t, n];
  }
  function sphere(e, t) {
    return [e, t];
  }
  function vertices(e) {
    return e;
  }
  function polygonEdges(e) {
    let t = [];
    if (e.length === 0) return [];
    for (let n = 0; n < e.length - 1; n++) t.push([e[n], e[n + 1]]);
    return t.push([e[e.length - 1], e[0]]), t;
  }
  function polygonArea(e) {
    if (e.length == 0) return 0;
    let t = [...e, e[0]];
    return nS(t);
  }
  function polygonPerimeter(e) {
    let t = 0;
    for (let n = 0; n < e.length - 1; n++) {
      let [r, s] = e[n], [i, o] = e[n + 1];
      t += MathHypot(i - r, o - s);
    }
    if (e.length > 1) {
      let [n, r] = e[e.length - 1], [s, i] = e[0];
      t += MathHypot(s - n, i - r);
    }
    return t;
  }
  function t2(e) {
    let t = false;
    for (let n = 0; n < e.length; n++) {
      let r = (n + 1) % e.length;
      e[n][0] === e[r][0] && e[n][1] === e[r][1] && (t = true);
    }
    return t
      ? e.filter((n, r) => {
        let s = e[r === 0 ? e.length - 1 : r - 1];
        return n[0] !== s[0] || n[1] !== s[1];
      })
      : e;
  }
  function n2(e) {
    let [t, n, r, s] = e;
    return [t, r >= 0 ? n : n + r, r >= 0 ? r : -r, s];
  }
  function Tv(e, t, n) {
    if (e.length === 0) return [];
    if (e = t2(e), e.length === 0) return [];
    let r = rS([...e, e[0]]), s = [];
    for (let i = 0; i < e.length; i++) {
      let o = e[i > 0 ? i - 1 : e.length - 1],
        a = e[i],
        u = e[i < e.length - 1 ? i + 1 : 0],
        c = r[i] === 1,
        l = N2(o, a, u, c ? "counterclockwise" : "clockwise", n);
      s.push(t ? l : n2(l));
    }
    return s;
  }
  function polygonInteriorUndirectedAngles(e, t) {
    return Tv(e, false, t);
  }
  function polygonInteriorDirectedAngles(e, t) {
    return Tv(e, true, t);
  }
  function segment(e, t) {
    return [e, t];
  }
  var line = segment, ray = segment;
  function vector(e, t) {
    let n = [t[0] - e[0], t[1] - e[1]], r = [e[0], e[1]];
    return mathVector(n, r);
  }
  function mathVector(e, t) {
    return [e, t];
  }
  function vectorDisplacementAsPoint(e) {
    return e[0];
  }
  function basePointFromVector(e) {
    return e[1];
  }
  function vectorThreeD(e, t) {
    let n = [t[0] - e[0], t[1] - e[1], t[2] - e[2]], r = [e[0], e[1], e[2]];
    return mathVectorThreeD(n, r);
  }
  function mathVectorThreeD(e, t) {
    return [e, t];
  }
  function vectorThreeDDisplacementAsPoint(e) {
    return e[0];
  }
  function basePointFromVectorThreeD(e) {
    return e[1];
  }
  function identity(e) {
    return e;
  }
  function circle(e, t) {
    return [e, t];
  }
  function center(e) {
    return e[0];
  }
  function radius(e) {
    return e[1];
  }
  function arc(e, t, n) {
    return [e, t, n];
  }
  function arcCenter([e, t, n]) {
    let [r, s] = e,
      [i, o] = t,
      [a, u] = n,
      c = i * i + o * o,
      l = (r * r + s * s - c) / 2,
      p = (c - a * a - u * u) / 2,
      f = (r - i) * (o - u) - (i - a) * (s - o);
    f = 1 / f;
    let d = (l * (o - u) - p * (s - o)) * f,
      y = ((r - i) * p - (i - a) * l) * f;
    return [d, y];
  }
  function arcFirstPoint(e) {
    return e[0];
  }
  function arcMiddlePoint(e) {
    return e[1];
  }
  function arcThirdPoint(e) {
    return e[2];
  }
  function arcOmega(e) {
    let [[t, n], [r, s], [i, o]] = e,
      a = r - t,
      u = s - n,
      c = i - r,
      l = o - s;
    return 2 * Math.atan2(a * l - c * u, a * c + u * l);
  }
  function isDegenerateArc(e) {
    let t = Math.abs(arcOmega(e));
    return t < 1e-9 || t > 2 * Math.PI - 1e-9;
  }
  function angleVertex(e) {
    return e[0];
  }
  function angleStart(e) {
    return e[1];
  }
  function directedAngleVertex(e) {
    return e[0];
  }
  function directedAngleStart(e) {
    return e[1];
  }
  function Ev(e) {
    return Math.abs(e) === Math.PI
      ? Math.PI
      : mod(e + Math.PI, 2 * Math.PI) - Math.PI;
  }
  function directedAngleMarker(e, t, n, r) {
    return [e, Ev(t), n, r];
  }
  function undirectedAngleMarker([e, t, n, r]) {
    return [e, t, n, r];
  }
  function angleMarkerRawDelta(e) {
    return e[2];
  }
  function angleMarkerMultiplier(e) {
    return e[3];
  }
  function directedCoterminalAngle(e) {
    let [t, n, r, s] = e,
      i = Math.PI * 2,
      o = r === 0 ? i : r > 0 ? r - i : r + i;
    return [t, n, o, s];
  }
  function undirectedCoterminalAngle(e) {
    let [t, n, r, s] = directedCoterminalAngle(e);
    return [t, n, r, s];
  }
  function supplementAngle(e) {
    let [t, n, r, s] = e, i = r >= 0 ? Math.PI - r : -Math.PI - r;
    return [t, Ev(n + r), i, s];
  }
  function N2(e, t, n, r, s) {
    let i = e[0] - t[0],
      o = e[1] - t[1],
      a = n[0] - t[0],
      u = n[1] - t[1],
      c = Math.atan2(o, i),
      l = Math.atan2(i * u - o * a, i * a + o * u),
      p = 2 * Math.PI;
    return r === "clockwise"
      ? l -= l < 0 ? 0 : p
      : r === "counterclockwise" && (l += l < 0 ? p : 0),
      directedAngleMarker(t, c, l, s);
  }
  function scaleTangentTransformation(e, t) {
    let [[n, r], [s, i], o] = e;
    return [[n * t, r * t], [s * t, i * t], o];
  }
  function scaleTangentPolygon(e, t) {
    let n = new Array(e.length);
    for (let r = 0; r < n.length; r++) {
      let s = e[r];
      n[r] = [s[0] * t, s[1] * t];
    }
    return n;
  }
  function scaleTangentSegment(e, t) {
    let [[n, r], [s, i]] = e;
    return [[t * n, t * r], [t * s, t * i]];
  }
  var scaleTangentLine = scaleTangentSegment,
    scaleTangentRay = scaleTangentSegment;
  function scaleTangentCircle(e, t) {
    let [[n, r], s] = e;
    return [[t * n, t * r], t * s];
  }
  function scaleTangentArc(e, t) {
    let [[n, r], [s, i], [o, a]] = e;
    return [[t * n, t * r], [t * s, t * i], [t * o, t * a]];
  }
  function scaleTangentAngle(e, t) {
    let [[n, r], s, i, o] = e;
    return [[t * n, t * r], t * s, t * i, o];
  }
  function addTangentPolygon(e, t) {
    if (e.length !== t.length) {
      throw new Error(
        "Polygon tangent must be added to polygon of same length.",
      );
    }
    let n = new Array(e.length);
    for (let r = 0; r < n.length; r++) {
      let s = e[r], i = t[r];
      n[r] = [s[0] + i[0], s[1] + i[1]];
    }
    return n;
  }
  function addTangentSegment(e, t) {
    let [[n, r], [s, i]] = e, [[o, a], [u, c]] = t;
    return [[n + o, r + a], [s + u, i + c]];
  }
  function addTangentSegmentThreeD(e, t) {
    let [[n, r, s], [i, o, a]] = e, [[u, c, l], [p, f, d]] = t;
    return [[n + u, r + c, s + l], [i + p, o + f, a + d]];
  }
  var addTangentLine = addTangentSegment,
    addTangentRay = addTangentSegment,
    addTangentVector = addTangentSegment;
  function addTangentCircle(e, t) {
    let [[n, r], s] = e, [[i, o], a] = t;
    return [[n + i, r + o], s + a];
  }
  function addTangentArc(e, t) {
    let [[n, r], [s, i], [o, a]] = e, [[u, c], [l, p], [f, d]] = t;
    return [[n + u, r + c], [s + l, i + p], [o + f, a + d]];
  }
  function addTangentAngle(e, t) {
    let [[n, r], s, i, o] = e, [[a, u], c, l] = t;
    return [[n + a, r + u], s + c, i + l, o];
  }
  function addTangentTransformation(e, t) {
    let [[n, r], [s, i], o] = e, [[a, u], [c, l]] = t;
    return [[n + a, r + u], [s + c, i + l], o];
  }
  function lineGlider(e, t) {
    let [[n, r], [s, i]] = e;
    return [(1 - t) * n + t * s, (1 - t) * r + t * i];
  }
  function segmentGlider(e, t) {
    return lineGlider(e, clamp(t, 0, 1));
  }
  function segmentThreeDGlider(e, t) {
    t = clamp(t, 0, 1);
    let [[n, r, s], [i, o, a]] = e;
    return [(1 - t) * n + t * i, (1 - t) * r + t * o, (1 - t) * s + t * a];
  }
  function rayGlider(e, t) {
    return lineGlider(e, clamp(t, 0, 1 / 0));
  }
  function circleGlider(e, t) {
    let [[n, r], s] = e, i = Math.min(1, Math.max(0, t));
    return [
      n + s * Math.cos(2 * Math.PI * i),
      r + s * Math.sin(2 * Math.PI * i),
    ];
  }
  function arcGlider(e, t) {
    let n = getArcDetails(e);
    if (!n) return [NaN, NaN];
    if (n.type === "segment") return segmentGlider([e[0], e[2]], t);
    if (n.type === "rays") {
      return t <= 0
        ? rayGlider([n.start1, n.end1], -t)
        : t >= 1
        ? rayGlider([n.start2, n.end2], t - 1)
        : [NaN, NaN];
    }
    t = Math.min(1, Math.max(0, t));
    let r = arcCenter(e),
      s = arcOmega(e),
      i = Math.atan2(e[0][1] - r[1], e[0][0] - r[0]),
      o = distance(r, e[0]),
      a = i + t * s;
    return [r[0] + o * Math.cos(a), r[1] + o * Math.sin(a)];
  }
  function polygonEdgeByParameter(e, t) {
    if (isNaN(t) || e.length === 0) return [[NaN, NaN], [NaN, NaN]];
    if (t < 0 || t >= e.length) return [e[0], e[0]];
    let n = Math.floor(t);
    return [e[n], e[(n + 1) % e.length]];
  }
  function polygonGlider(e, t) {
    if (isNaN(t) || e.length === 0) return [NaN, NaN];
    if (t < 0 || t >= e.length) return e[0];
    let n = Math.floor(t);
    return segmentGlider([e[n], e[(n + 1) % e.length]], t - n);
  }
  function getArcDetails(e) {
    let [t, n, r] = e, [[s, i], [o, a], [u, c]] = [t, n, r];
    if (isNaN(s) || isNaN(i) || isNaN(o) || isNaN(a) || isNaN(u) || isNaN(c)) {
      return;
    }
    let l = arcCenter([t, n, r]), p = distance(l, t);
    if (isFinite(p) && !isDegenerateArc([t, n, r])) {
      let f = Math.atan2(t[1] - l[1], t[0] - l[0]), d = f + arcOmega([t, n, r]);
      return { type: "arc", center: l, radius: p, startAngle: f, endAngle: d };
    } else {
      let f = to(o, a, 0, s, i, 0, u, c, 0);
      return f < 0 || f > 1
        ? {
          type: "rays",
          start1: [s, i],
          end1: [s + (s - u), i + (i - c)],
          start2: [u, c],
          end2: [u + (u - s), c + (c - i)],
        }
        : { type: "segment", start: [s, i], end: [u, c] };
    }
  }
  function chooseNonIncidentPoint(e, t, n) {
    let s = distance(e, t);
    if (s > 1e-9) return t;
    let i = distance(e, n);
    return i > 1e-9 ? n : isNaN(s) && isNaN(i) ? [NaN, NaN] : e;
  }
  function circleCircleIntersection(e, t) {
    let [[n, r], s] = e,
      [[i, o], a] = t,
      u = hypot(i - n, o - r),
      c = u * u,
      l = s * s,
      p = a * a,
      [f, d, y] = [u, s, a].sort((M, P) => P - M),
      g = f + d + y,
      m = y - (f - d),
      h = y + (f - d),
      x = f + (d - y),
      T = .01,
      b;
    return m < 0 && f + T * m === f || h < 0 && f + T * h === f ||
        x < 0 && f + T * x === f
      ? b = 0
      : b = Math.sqrt(g * m * h * x) / 4,
      [
        (i + n) / 2 + (i - n) * (l - p) / (2 * c) + -2 * (o - r) * b / c,
        (o + r) / 2 + (o - r) * (l - p) / (2 * c) + 2 * (i - n) * b / c,
      ];
  }
  function mg(e, t, n) {
    let [[r, s], i] = e,
      [[o, a], [u, c]] = t,
      l = o - r,
      p = u - r,
      f = a - s,
      d = c - s,
      y = u - o,
      g = c - a,
      m = y * y + g * g,
      h = hypot(y, g),
      x = l * d - p * f,
      T = i * h,
      b = T + x,
      M = T - x,
      P = .01,
      D;
    if (
      b < 0 && T + P * b === T || M < 0 && T + P * M === T ? D = 0 : D = b * M,
        D < 0
    ) return [NaN, NaN];
    let S = Math.sqrt(D);
    return [r + (x * g + n * y * S) / m, s + (-x * y + n * g * S) / m];
  }
  function Q2(e, t) {
    let [[n, r], [s, i]] = e,
      [[o, a], [u, c]] = t,
      l = i - r,
      p = n - s,
      f = c - a,
      d = o - u,
      y = l * n + p * r,
      g = f * o + d * a,
      m = l * d - f * p,
      h = m / (hypot(l, p) * hypot(f, d));
    return m === 0 || 1 + .1 * h === 1
      ? [NaN, NaN]
      : [(d * y - p * g) / m, (l * g - f * y) / m];
  }
  function lineCircleIntersection(e, t, n = 0) {
    let r = mg(t, e, -1);
    if (Cu(r, e, n, true)) return r;
    {
      let s = mg(t, e, 1);
      return Cu(s, e, n, true) ? s : [NaN, NaN];
    }
  }
  function circleLineIntersection(e, t, n = 0) {
    let r = mg(e, t, 1);
    if (Cu(r, t, n, false)) return r;
    {
      let s = mg(e, t, -1);
      return Cu(s, t, n, false) ? s : [NaN, NaN];
    }
  }
  function lineLineIntersection(e, t, n = 0) {
    let r = Q2(e, t);
    return !Cu(r, e, n, true) || !Cu(r, t, n, false) ? [NaN, NaN] : r;
  }
  function circleArcIntersection(e, t, n = 0) {
    let r = Nv(t, e, n, -1);
    return dp(r, t, n, false) ? r : [NaN, NaN];
  }
  function lineArcIntersection(e, t, n = 0) {
    let r = Rv(t, e, n, -1);
    return !Cu(r, e, n, true) || !dp(r, t, n, false) ? [NaN, NaN] : r;
  }
  function arcCircleIntersection(e, t, n = 0) {
    let r = Nv(e, t, n, 1);
    return dp(r, e, n, true) ? r : [NaN, NaN];
  }
  function arcLineIntersection(e, t, n = 0) {
    let r = Rv(e, t, n, 1);
    return !dp(r, e, n, true) || !Cu(r, t, n, false) ? [NaN, NaN] : r;
  }
  function arcArcIntersection(e, t, n = 0) {
    let r = nG(e, t, n);
    return !dp(r, e, n, true) || !dp(r, t, n, false) ? [NaN, NaN] : r;
  }
  function nG(e, t, n) {
    let r = gg(e);
    if (hg(r)) return lineArcIntersection(r, t, n);
    let s = gg(t);
    return hg(s)
      ? arcLineIntersection(e, s, n)
      : QE(() => circleCircleIntersection(r, s), () =>
        circleCircleIntersection(s, r), (i) =>
        KE(-1, yg(e, i), yg(t, i)));
  }
  function Nv(e, t, n, r) {
    let s = gg(e);
    return hg(s)
      ? r > 0
        ? circleLineIntersection(t, s, n)
        : lineCircleIntersection(s, t, n)
      : QE(
        () => circleCircleIntersection(s, t),
        () => circleCircleIntersection(t, s),
        (i) => KE(r, yg(e, i), rG(t, i)),
      );
  }
  function Rv(e, t, n, r) {
    let s = gg(e);
    return hg(s)
      ? lineLineIntersection(s, t, n)
      : QE(() => circleLineIntersection(s, t, n), () =>
        lineCircleIntersection(t, s, n), (i) =>
        KE(r, yg(e, i), sG(t)));
  }
  function QE(e, t, n) {
    let r = e();
    if (n(r)) return r;
    let s = t();
    return n(s) ? s : [NaN, NaN];
  }
  function KE(e, t, n) {
    return e * pointDet(t, n) > 0;
  }
  function yg(e, [t, n]) {
    let [r, s] = arcCenter(e);
    return arcOmega(e) > 0 ? [s - n, t - r] : [n - s, r - t];
  }
  function rG([[e, t]], [n, r]) {
    return [t - r, n - e];
  }
  function sG([[e, t], [n, r]]) {
    return [n - e, r - t];
  }
  function gg(e) {
    let t = arcCenter(e), n = distance(t, arcGlider(e, 0));
    return isFinite(n) && !isDegenerateArc(e) ? [t, n] : [e[0], e[2]];
  }
  function hg(e) {
    return Array.isArray(e[1]);
  }
  function dp([e, t], n, r, s) {
    let [i, o] = arcCenter(n);
    return (s ? (r & 3) === 0 : (r & 12) === 0) ||
      Bm(
        Math.atan2(t - o, e - i),
        Math.atan2(n[0][1] - o, n[0][0] - i),
        arcOmega(n),
      );
  }
  function Cu([e, t], [[n, r], [s, i]], o, a) {
    let u = to(e, t, 0, n, r, 0, s, i, 0),
      [c, l] = a
        ? [(o & 1) === 0, (o & 2) === 0]
        : [(o & 4) === 0, (o & 8) === 0];
    return !isNaN(u) && (u >= 0 || c) && (u <= 1 || l);
  }
  function parallel(e, t) {
    let [[n, r], [s, i]] = e, [o, a] = t;
    return [[o, a], [o + (s - n), a + (i - r)]];
  }
  function perpendicular(e, t) {
    let [[n, r], [s, i]] = e, [o, a] = t;
    return [[o, a], [o + (i - r), a - (s - n)]];
  }
  function anglebisector(e) {
    let [t, n, r] = e, [s, i] = t, o = cos(n + r / 2), a = sin(n + r / 2);
    return [[s, i], [s + o, i + a]];
  }
  function complexMultiplyPoints(e, t) {
    let [n, r] = e, [s, i] = t;
    return [n * s - r * i, n * i + s * r];
  }
  function e0(e, t) {
    let [n, r, s] = e, [i, o] = n, [a, u] = t;
    return s && (u = -u),
      o === 0 ? [i * a, i * u] : [i * a - o * u, i * u + a * o];
  }
  function pointDet(e, t) {
    let [n, r] = e, [s, i] = t;
    return n * i - s * r;
  }
  function pointDot(e, t) {
    let [n, r] = e, [s, i] = t;
    return n * s + r * i;
  }
  function pointPerp(e) {
    let [t, n] = e;
    return [-n, t];
  }
  function rawTransform(e, t) {
    return [e, t, false];
  }
  function rawTransformConj(e, t) {
    return [e, t, true];
  }
  function transformWithoutTranslation(e) {
    return [e[0], [0, 0], e[2]];
  }
  function transformScaleFactor(e) {
    return e[0];
  }
  function translation(e) {
    return [[1, 0], e, false];
  }
  function dilation(e, t) {
    let [n, r] = e;
    return [[t, 0], [(1 - t) * n, (1 - t) * r], false];
  }
  function rotation(e, t) {
    let [n, r] = e, s = Math.cos(t), i = Math.sin(t);
    return [[s, i], [n * (1 - s) + r * i, r * (1 - s) - n * i], false];
  }
  function reflection(e) {
    let [[t, n], [r, s]] = e,
      i = r - t,
      o = s - n,
      a = i * i + o * o,
      u = (i * i - o * o) / a,
      c = 2 * i * o / a;
    return [[u, c], [(1 - u) * t - c * n, (1 + u) * n - c * t], true];
  }
  function composeTransformation(e, t) {
    let n = e[2], [r, s, i] = t;
    return [e0(e, r), transformPoint(e, s), i !== n];
  }
  function invertTransformation(e) {
    let [[t, n], [r, s], i] = e,
      o = t * t + n * n,
      a = t / o,
      u = -n / o,
      c = -(t / o * r + n / o * s),
      l = -(t / o * s - n / o * r);
    return i && (u = -u, l = -l), [[a, u], [c, l], i];
  }
  function transformPoint(e, t) {
    let [n, r] = e0(e, t), [s, i] = e[1];
    return [n + s, r + i];
  }
  function TG(e, t) {
    let [n, r, s] = e;
    return s ? -t : t;
  }
  function transformSegment(e, t) {
    let [n, r] = t;
    return [transformPoint(e, n), transformPoint(e, r)];
  }
  var transformLine = transformSegment, transformRay = transformSegment;
  function transformVector(e, t) {
    let [n, r] = t;
    return [e0(e, n), transformPoint(e, r)];
  }
  function transformCircle(e, t) {
    let [n, r] = t, [[s, i]] = e;
    return [transformPoint(e, n), hypot(s, i) * r];
  }
  function transformArc(e, t) {
    let [n, r, s] = t;
    return [transformPoint(e, n), transformPoint(e, r), transformPoint(e, s)];
  }
  function transformPolygon(e, t) {
    let n = [];
    for (let r of t) n.push(transformPoint(e, r));
    return n;
  }
  function transformAngleMarker(e, t) {
    let [n, r, s] = t,
      i = transformPoint(e, n),
      [o, a, u] = e,
      [c, l] = transformPoint([o, [0, 0], u], [Math.cos(r), Math.sin(r)]),
      p = Math.atan2(l, c),
      f = TG(e, s);
    return [i, p, f, t[3]];
  }
  function select(e, t) {
    let n = [];
    for (let r = 0; r < Math.min(e.length, t.length); r++) t[r] && n.push(e[r]);
    return n;
  }
  function elementsAt(e, t) {
    let n = [];
    for (let r of t) n.push(e[r]);
    return n;
  }
  function uniquePerm(e) {
    let t = [], n = {};
    for (let r = 0; r < e.length; r++) {
      let s = e[r], i = bg(s);
      n.hasOwnProperty(i) || (n[i] = true, t.push(r));
    }
    return t;
  }
  function tone(e, t) {
    return [e, t];
  }
  function frequency(e) {
    return e[0];
  }
  function volume(e) {
    return e[1];
  }
  function bg(e) {
    if (Array.isArray(e)) return `[${e.map(bg).join(",")}]`;
    switch (typeof e) {
      case "string":
        return e;
      case "boolean":
      case "number":
        return e.toString();
      case "object":
        if (LG(e)) {
          let n = [];
          for (let r of We(e.updateRules)) {
            n.push(`"${r}": ${bg(e.updateRules[r].value)}`);
          }
          return `{${n.join(",")}}`;
        } else return V(e).toString();
      default:
        return e;
    }
  }
  function LG(e) {
    return typeof e != "object" || !e ? false : e.type === "Action";
  }
  function restriction(e) {
    return e;
  }
  function restrictionToBoolean(e) {
    return e;
  }
  function complex(e, t) {
    return isNaN(e) || isNaN(t) ? [NaN, NaN] : [e, t];
  }
  function complexFromPolarRounded(e, t) {
    return isNaN(e) || isNaN(t)
      ? complex(NaN, NaN)
      : e === 0
      ? complex(0, 0)
      : complex(e * cos(t), e * sin(t));
  }
  function real([e, t]) {
    return e;
  }
  function imag([e, t]) {
    return t;
  }
  function arg([e, t]) {
    return vf(t, e);
  }
  function conj([e, t]) {
    return [e, -t];
  }
  function complexDivide(e, t) {
    let [n, r] = t;
    return Math.abs(r) <= Math.abs(n) ? HS(e, t) : conj(HS(kS(e), kS(t)));
  }
  function kS([e, t]) {
    return [t, e];
  }
  function HS([e, t], [n, r]) {
    let s = r / n, i = 1 / (n + r * s);
    return s === 0
      ? complex((e + r * (t / n)) * i, (t - r * (e / n)) * i)
      : complex((e + t * s) * i, (t - e * s) * i);
  }
  function complexSqrt([e, t]) {
    return Wc(e, t);
  }
  function Wc(e, t) {
    let n = Math.sqrt(.5 * (Math.abs(e) + hypot(e, t)));
    return n === 1 / 0 &&
      (n = 2 * Math.sqrt(.5 * (Math.abs(.25 * e) + hypot(.25 * e, .25 * t)))),
      n === 0 || !isFinite(t)
        ? complex(n, t)
        : e > 0
        ? complex(n, .5 * (t / n))
        : (t < 0 && (n = -n), complex(.5 * (t / n), n));
  }
  function complexReciprocal(e) {
    return complexDivide(complex(1, 0), e);
  }
  function Cf(e) {
    return 0 + e;
  }
  function vf(e, t) {
    return Math.atan2(Cf(e), Cf(t));
  }
  function kG(e, t) {
    let n = e * e + t * t;
    if (n === 1 / 0) return Math.log(Math.hypot(.5 * e, .5 * t)) + Math.LN2;
    if (n === 0) return Math.log(Math.hypot(e, t));
    if (.5 < n && n < 3) {
      let r = Math.max(e, t), s = Math.min(e, t);
      return .5 * Math.log1p((r + 1) * (r - 1) + s * s);
    } else return .5 * Math.log(n);
  }
  function complexLog([e, t]) {
    return complex(kG(e, t), vf(t, e));
  }
  function complexExp([e, t]) {
    let n = Math.exp(e);
    return t === 0 ? complex(n, 0) : complexFromPolarRounded(n, t);
  }
  function zG([e, t]) {
    return complex((e + t) * (e - t), 2 * e * t);
  }
  function zS(e, t) {
    t = t >>> 0;
    let [n, r] = e, s = 1, i = 0;
    for (; t;) {
      for (; !(t & 1);) {
        let u = (n + r) * (n - r), c = 2 * n * r;
        n = u, r = c, t = t >>> 1;
      }
      let o = n * s - r * i, a = n * i + s * r;
      s = o, i = a, t = t - 1 >>> 0;
    }
    return complex(s, i);
  }
  function complexPow(e, t) {
    let [n, r] = t;
    if (r === 0) return complexPowReal(e, n);
    let [s, i] = e;
    if (isNaN(s) || isNaN(i) || isNaN(n) || isNaN(r)) return complex(NaN, NaN);
    let o = hypot(s, i),
      a = vf(i, s),
      u = Math.pow(o, n) * Math.exp(-a * r),
      c = Math.log(o) * r + a * n;
    return isFinite(u)
      ? complexFromPolarRounded(u, c)
      : complexFromPolarRounded(Math.exp(n * Math.log(o) - a * r), c);
  }
  function complexPowReal(e, t) {
    let [n, r] = e;
    if (isNaN(n) || isNaN(r) || isNaN(t)) return complex(NaN, NaN);
    switch (t) {
      case -1:
        return complexReciprocal(e);
      case 0:
        return complex(1, 0);
      case .5:
        return complexSqrt(e);
      case 1:
        return e;
    }
    return r === 0
      ? Number.isInteger(t) || n >= 0
        ? complex(Math.pow(n, t), 0)
        : complexFromPolarRounded(Math.pow(-n, t), Math.PI * t)
      : n === 0
      ? r >= 0
        ? complexFromPolarRounded(Math.pow(r, t), .5 * Math.PI * t)
        : complexFromPolarRounded(Math.pow(-r, t), -.5 * Math.PI * t)
      : t === 2
      ? zG(e)
      : t === (t | 0)
      ? t < 0 ? complexReciprocal(zS(e, -t)) : zS(e, t)
      : complexFromPolarRounded(Math.pow(Math.hypot(n, r), t), t * vf(r, n));
  }
  function complexSin([e, t]) {
    return complex(sin(e) * cosh(t), cos(e) * sinh(t));
  }
  function complexCos([e, t]) {
    return complex(cos(e) * cosh(t), -sin(e) * sinh(t));
  }
  function complexTan([e, t]) {
    let [n, r] = complexTanh([-t, e]);
    return [r, -n];
  }
  function complexSinh([e, t]) {
    return complex(sinh(e) * cos(t), cosh(e) * sin(t));
  }
  function complexCosh([e, t]) {
    return complex(cosh(e) * cos(t), sinh(e) * sin(t));
  }
  function complexTanh([e, t]) {
    let n = tan(t), r = tanh(e);
    if (!isFinite(n)) return complex(1 / r, 1 / n);
    let s = n * n, i = 1 + s, o = sinh(e), a = o * o, u = r * r;
    return complex(i * r / (1 + s * u), n / (1 + i * a));
  }
  function complexSec(e) {
    return complexReciprocal(complexCos(e));
  }
  function complexCsc(e) {
    return complexReciprocal(complexSin(e));
  }
  function complexCot(e) {
    return complexReciprocal(complexTan(e));
  }
  function complexSech(e) {
    return complexReciprocal(complexCosh(e));
  }
  function complexCsch(e) {
    return complexReciprocal(complexSinh(e));
  }
  function complexCoth(e) {
    return complexReciprocal(complexTanh(e));
  }
  function complexAsin([e, t]) {
    let n = Wc(1 - e, -t), r = Wc(1 + e, t);
    return complex(
      Math.atan(e / Cf($c(n, r)[0])),
      Math.asinh($c(conj(n), r)[1]),
    );
  }
  function complexAcos([e, t]) {
    let n = Wc(1 - e, -t), r = Wc(1 + e, t);
    return complex(
      2 * Math.atan(n[0] / Cf(r[0])),
      Math.asinh($c(conj(r), n)[1]),
    );
  }
  function complexAtan([e, t]) {
    let [n, r] = complexAtanh([-t, e]);
    return [r, -n];
  }
  function complexAsinh([e, t]) {
    let [n, r] = complexAsin([-t, e]);
    return [r, -n];
  }
  function complexAcosh([e, t]) {
    let n = Wc(e - 1, t), r = Wc(e + 1, t);
    return complex(
      Math.asinh($c(conj(n), r)[0]),
      2 * Math.atan(n[1] / Cf(r[0])),
    );
  }
  function complexAtanh([e, t]) {
    if (e < 0) {
      let [n, r] = qS(-e, -t);
      return [-n, -r];
    } else return qS(e, t);
  }
  var US = Math.sqrt(Number.MAX_VALUE) / 4;
  function qS(e, t) {
    if (e > US || Math.abs(t) > US) {
      return complex(
        complexReciprocal([e, t])[0],
        t <= 0 ? -Math.PI / 2 : Math.PI / 2,
      );
    }
    if (e === 1) {
      if (t === 0) return complex(1 / 0, 0);
      let n = Math.abs(t),
        r = Math.log(Math.sqrt(Math.sqrt(4 + t * t)) / Math.sqrt(n)),
        s = (Math.PI / 2 + Math.atan(n / 2)) / 2;
      return t < 0 != s < 0 && (s = -s), complex(r, s);
    } else {return complex(
        log1p(4 * e / ((1 - e) ** 2 + t ** 2)) / 4,
        -vf(-2 * t, (1 - e) * (1 + e) - t ** 2) / 2,
      );}
  }
  function complexAsec(e) {
    return complexAcos(complexReciprocal(e));
  }
  function complexAcsc(e) {
    return complexAsin(complexReciprocal(e));
  }
  function complexAcot(e) {
    if (e[0] > 0) return complexAtan(complexReciprocal(e));
    let [t, n] = complexAtan(e);
    return complex(Math.PI / 2 - t, -n);
  }
  function complexAsech(e) {
    let [t, n] = e;
    return t === 0 && n === 0
      ? complex(1 / 0, 0)
      : complexAcosh(complexReciprocal(e));
  }
  function complexAcsch(e) {
    let [t, n] = e;
    return t === 0 && n === 0
      ? complex(1 / 0, 0)
      : complexAsinh(complexReciprocal(e));
  }
  function complexAcoth(e) {
    return e[0] > 0
      ? conj(complexAtanh(conj(complexReciprocal(e))))
      : complexAtanh(complexReciprocal(e));
  }
  function coerceComplexToReal([e, t]) {
    return t === 0 ? e : NaN;
  }
  function peelableCoerceComplexToReal([e, t], n) {
    var r, s;
    return t === 0
      ? ((r = n.goodCoercionCount) != null || (n.goodCoercionCount = 0),
        n.goodCoercionCount++,
        e)
      : (isNaN(t) ||
        ((s = n.badCoercionCount) != null || (n.badCoercionCount = 0),
          n.badCoercionCount++),
        NaN);
  }
  function coerceRealToComplex(e) {
    return isNaN(e) ? [NaN, NaN] : [e, 0];
  }
  function complexFloor([e, t]) {
    let n = Math.floor(e), r = Math.floor(t);
    if (!isFinite(n) || !isFinite(r)) return [n, r];
    let s = e - n, i = t - r;
    return s + i < 1 ? [n, r] : s >= i ? [n + 1, r] : [n, r + 1];
  }
  function complexCeil([e, t]) {
    let n = complexFloor([-e, -t]);
    return [-n[0], -n[1]];
  }
  function complexRound(e) {
    return [Math.round(e[0]), Math.round(e[1])];
  }
  function complexMod(e, t) {
    let [n, r] = e, [s, i] = t;
    if (!isFinite(n) || !isFinite(r) || isNaN(s) || isNaN(i)) return [NaN, NaN];
    if (!isFinite(s) && !isFinite(i)) return e;
    if (s === 1 / 0) return og(n, r, i);
    if (s === -1 / 0) {
      let [f, d] = og(-n, -r, -i);
      return [-f, -d];
    } else if (i === 1 / 0) {
      let [f, d] = og(r, -n, -s);
      return [-d, f];
    } else if (i === -1 / 0) {
      let [f, d] = og(-r, n, s);
      return [d, -f];
    }
    let o = DE(t),
      a = n * s + r * i,
      u = r * s - n * i,
      c = mod(a, o),
      l = mod(u, o);
    c + l < o || (c >= l ? c -= o : l -= o);
    let p = complexDivide([c, l], [s, -i]);
    return Number.isInteger(n) && Number.isInteger(r) && Number.isInteger(s) &&
        Number.isInteger(i)
      ? [Math.round(p[0]), Math.round(p[1])]
      : p;
  }
  function og(e, t, n) {
    return e + t < 0
      ? e >= t ? complex(e - n, 1 / 0) : complex(1 / 0, t + n)
      : [e, t];
  }
  function DE([e, t]) {
    return e * e + t * t;
  }
  function complexGCD(e, t) {
    if (
      !isFinite(e[0]) || !isFinite(e[1]) || !isFinite(t[0]) || !isFinite(t[1])
    ) return [NaN, NaN];
    e = complexRound(e), t = complexRound(t);
    let n = _complexGCD(e, t);
    return $v(n);
  }
  function _complexGCD(e, t) {
    let n = [1, 0];
    for (e = [e[0], e[1]], t = [t[0], t[1]];;) {
      let r = DE(e), s = DE(t);
      if (r === 1 || s === 1) return n;
      if (r === 0) return $c(t, n);
      if (s === 0) return $c(e, n);
      if (r === s && ak(e, t)) return $c(e, n);
      switch (ag(e[0]) << 3 | ag(e[1]) << 2 | ag(t[0]) << 1 | ag(t[1])) {
        case 0:
          sp(e), sp(t), ok(n);
          break;
        case 1:
        case 2:
          sp(e);
          break;
        case 4:
        case 8:
          sp(t);
          break;
        case 3:
          sp(e), ip(t), hE(n);
          break;
        case 12:
          ip(e), sp(t), hE(n);
          break;
        case 14:
        case 13:
          ip(e);
          break;
        case 7:
        case 11:
          ip(t);
          break;
        case 15:
          ip(e), ip(t), hE(n);
          break;
        case 5:
        case 10:
          e = [.5 * (e[0] - t[0]), .5 * (e[1] - t[1])],
            t = [e[0] + t[0], e[1] + t[1]];
          break;
        case 6:
        case 9:
          e = [.5 * (e[0] + t[1]), .5 * (e[1] - t[0])],
            t = [e[0] - t[1], e[1] + t[0]];
          break;
      }
    }
  }
  function ok(e) {
    e[0] *= 2, e[1] *= 2;
  }
  function sp(e) {
    e[0] *= .5, e[1] *= .5;
  }
  function hE(e) {
    let t = e[0] - e[1];
    e[1] = e[1] + e[0], e[0] = t;
  }
  function ip(e) {
    let t = .5 * (e[0] + e[1]);
    e[1] = .5 * (e[1] - e[0]), e[0] = t;
  }
  function ag(e) {
    return e % 2 == 0 ? 0 : 1;
  }
  function $c(e, t) {
    let [n, r] = e, [s, i] = t;
    return complex(n * s - r * i, n * i + s * r);
  }
  function ak(e, t) {
    return e[0] == t[0] && e[1] == t[1] || e[0] == -t[0] && e[1] == -t[1] ||
      e[0] == -t[1] && e[1] == t[0] || e[0] == t[1] && e[1] == -t[0];
  }
  function $v(e) {
    let [t, n] = e;
    return t >= 0 && n < 0
      ? [-n, t]
      : t < 0 && n <= 0
      ? [-t, -n]
      : t <= 0 && n > 0
      ? [n, -t]
      : e;
  }
  function complexLCM(e, t) {
    if (
      !isFinite(e[0]) || !isFinite(e[1]) || !isFinite(t[0]) || !isFinite(t[1])
    ) return [NaN, NaN];
    if (e[0] === 0 && e[1] === 0 || t[0] === 0 && t[1] === 0) return [0, 0];
    if (
      !isFinite(e[0]) || !isFinite(e[1]) || !isFinite(t[0]) || !isFinite(t[1])
    ) return [NaN, NaN];
    e = complexRound(e), t = complexRound(t);
    let n = _complexGCD(e, t),
      r = complexRound(complexDivide(e, n)),
      s = complexMultiplyPoints(r, t);
    return $v(s);
  }
  function hp(e, t) {
    return { n: e, d: t };
  }
  function an(e) {
    return typeof e == "object" && typeof e.n == "number" &&
      typeof e.d == "number";
  }
  var Of = Math.pow(2, 53) - 1;
  function Qc(e) {
    let t = e.match(/^(-)?(\d*)?(?:\.(\d*))?$/);
    if (!t) return NaN;
    let n = t[1], r = t[2], s = t[3];
    if (!r && !s) return NaN;
    let i = !!n;
    if (s) {
      let o = s.replace(/0+$/, ""),
        a = o.length,
        u = Math.pow(10, a),
        c = parseInt(r || "0", 10) * u + parseInt(o || "0", 10);
      return c > Of || u > Of ? parseFloat(e) : Se(i ? -c : c, u);
    } else {
      let o = parseInt(r, 10);
      return o > Of ? parseFloat(e) : Se(i ? -o : o, 1);
    }
  }
  function V(e) {
    return an(e) ? e.n / e.d : +e;
  }
  function Ii(e) {
    return an(e) ? false : isNaN(e);
  }
  function Se(e, t) {
    if (
      !isFinite(e) || !isFinite(t) || t === 0 || Math.floor(e) !== e ||
      Math.floor(t) !== t || Math.abs(e) > Of || Math.abs(t) > Of
    ) return e / t;
    t < 0 && (e = -e, t = -t);
    let n = gcd1(e, t);
    return hp(e / n, t / n);
  }
  function Us(e) {
    return an(e) ? hp(-e.n, e.d) : -e;
  }
  function Yv(e) {
    return an(e) ? hp(Math.abs(e.n), Math.abs(e.d)) : Math.abs(e);
  }
  function Xv(e) {
    return an(e)
      ? e.n === 0 ? e.d / e.n : hp(e.n < 0 ? -e.d : e.d, Math.abs(e.n))
      : 1 / e;
  }
  function qs(e, t) {
    if (!an(e) || !an(t)) return V(e) + V(t);
    let n = gcd1(e.d, t.d);
    return Se(e.n * (t.d / n) + t.n * (e.d / n), e.d / n * t.d);
  }
  function wr(e, t) {
    if (!an(e) || !an(t)) return V(e) * V(t);
    let n = gcd1(e.n, t.d), r = gcd1(t.n, e.d);
    return Se(e.n / n * (t.n / r), e.d / r * (t.d / n));
  }
  function ai(e, t) {
    return qs(e, Us(t));
  }
  function Ps(e, t) {
    return !an(e) || !an(t) ? V(e) / V(t) : wr(e, Xv(t));
  }
  function uk(e, t) {
    let n = e, r = t;
    if (t.n < 0 && (r = Us(t), n = Xv(e)), !an(n) || !an(r)) {
      return pow1(V(e), V(t));
    }
    if (e = n, t = r, t.d === 1) {
      return Se(Math.pow(e.n, t.n), Math.pow(e.d, t.n));
    }
    let s = e.n < 0;
    if (s && t.d % 2 !== 1) return NaN;
    let o = (s ? -1 : 1) * Math.round(Math.pow(Math.abs(e.n), 1 / t.d)),
      a = Math.round(Math.pow(Math.abs(e.d), 1 / t.d));
    return Math.pow(o, t.d) !== e.n || Math.pow(a, t.d) !== e.d
      ? pow1(V(e), V(t))
      : Se(Math.pow(o, t.n), Math.pow(a, t.n));
  }
  function Zv(e, t) {
    if (!an(e) || !an(t)) return pow1(V(e), V(t));
    let n = uk(e, t);
    return an(n) ? n : pow1(V(e), V(t));
  }
  function Wv(e) {
    if (!an(e)) return Math.sqrt(e);
    let t = Math.round(Math.sqrt(e.n)), n = Math.round(Math.sqrt(e.d));
    return t * t !== e.n || n * n !== e.d ? Math.sqrt(V(e)) : Se(t, n);
  }
  function jv(e, t) {
    if (!an(e) || !an(t)) {
      let r = V(e), s = V(t);
      mod(r, s);
    }
    let n = ai(e, wr(t, hp(Math.floor(V(Ps(e, t))), 1)));
    return an(n) ? n : mod(V(e), V(t));
  }
  function Jv(e) {
    let t = hp(0, 1);
    for (let n of e) t = qs(t, n);
    return t;
  }
  var Q = class extends Yt {
    constructor(t, n) {
      if (!Array.isArray(t)) {
        throw new TypeError(
          "Argument to expression constructor must be an Array.",
        );
      }
      super(),
        this.args = t,
        (!n || !n.skipRegisterDependencies) && this.registerDependencies();
    }
    shouldExportAns() {
      return true;
    }
    registerDependencies() {
      for (let t = 0; t < this.args.length; t++) {
        this.mergeDependencies(this.args[t]);
      }
    }
    copyWithArgs(t) {
      throw new Error(
        `Programming Error: copyWithArgs not implemented for ${this.constructor.name}`,
      );
    }
  };
  var Et = class extends Q {
    constructor(n) {
      super([]);
      this.isConstant = true;
      typeof n == "number" && (n = Se(n, 1)), this._constantValue = n;
    }
    asValue() {
      let n = this._constantValue;
      return typeof n == "boolean" ? n : V(n);
    }
    asCompilerValue() {
      return this._constantValue;
    }
    scalarExprString() {
      return this.asValue() > 0
        ? String(this.asValue())
        : "(" + String(this.asValue()) + ")";
    }
    getEvaluationInfo() {
      return [{ val: this.asValue() }];
    }
    isNaN() {
      let n = this.asValue();
      return typeof n == "number" && isNaN(n);
    }
  };
  function c0(e) {
    if (!an(e)) {
      throw new Error(
        "Programming Error: numeric constants should be rational",
      );
    }
    return { type: 1, valueType: Number, value: e };
  }
  var vu = c0(Se(0, 1)), Kc = c0(Se(1, 1)), Nf = c0(Se(1, 2));
  function pt(e) {
    return e.map((t) => Ae(t));
  }
  function Su(e) {
    return e.map((t) => kt(t));
  }
  function ee(e, t) {
    var d, y, g, m, h;
    let n = t == null ? void 0 : t.defaultArguments,
      r = 1 / 0,
      s = 0,
      i = (d = n == null ? void 0 : n.length) != null ? d : 0;
    for (let x of e) {
      let T = x.minArity - i;
      T < r && (r = T);
      let b = (y = x.maxArity) != null ? y : 1 / 0;
      b > s && (s = b);
    }
    let o = (g = t == null ? void 0 : t.fallthroughUnlessDistribution) != null
        ? g
        : false,
      a = (m = t == null ? void 0 : t.allowDotCall) != null ? m : false,
      u = (h = t == null ? void 0 : t.isSeeded) != null ? h : false,
      c = t == null ? void 0 : t.minArityExampleArgs,
      l = t == null ? void 0 : t.maxArityExampleArgs,
      p = t == null ? void 0 : t.dotMinArityExampleArgs,
      f = t == null ? void 0 : t.dotMaxArityExampleArgs;
    return {
      minArity: r,
      getSignatures: (x) => e.filter((T) => T.satisfiesPolicy(x)),
      maxArity: s,
      defaultArguments: n,
      fallthroughUnlessDistribution: o,
      minArityExampleArgs: c,
      maxArityExampleArgs: l,
      dotMinArityExampleArgs: p,
      dotMaxArityExampleArgs: f,
      allowDotCall: a,
      isSeeded: u,
    };
  }
  function wo() {
    return ee(pt([{ type: "variadic", initial: [], rest: Any }]), {});
  }
  var Ag = Qn.of([Segment, Circle, Line, Ray, Arc]),
    o0 = Qn.of([Segment, Line, Ray, Vector]),
    bp = Qn.of([
      Point,
      Segment,
      Circle,
      Line,
      Ray,
      Vector,
      Arc,
      Polygon,
      AngleMarker,
      DirectedAngleMarker,
      Transformation,
    ]),
    a0 = Qn.of([
      ...ii.types.filter((e) => e !== ListOfDistribution),
      Distribution,
    ]),
    u0 = Qn.of([Any, ListOfAny], { coerceComplexToReal: false });
  function el(e) {
    return !!Fo[e];
  }
  function An(e) {
    return [
      kt([Rd(e)]),
      kt([e]),
      Ae({ type: "variadic", initial: [e, e], rest: e }),
    ];
  }
  function xp(e) {
    return [kt([Rd(e), Rd(e)])];
  }
  var Fo = {
    midpoint: ee([
      ...pt([[Point, Point], [Segment]]),
      ...pt([[Point3D, Point3D], [Segment3D]]),
    ], {
      allowDotCall: true,
    }),
    segment: ee([Ae([Point, Point]), Ae([Point3D, Point3D])]),
    vector: ee([Ae([Point, Point]), Ae([Point3D, Point3D])]),
    sphere: ee([Ae([Point, Number]), Ae([Point3D, Number])]),
    distance: ee(pt([[Point, Point], [Point3D, Point3D]])),
    glider: ee(
      pt([[Qn.of([Segment, Circle, Line, Ray, Arc, Polygon]), Number]]),
    ),
    circle: ee(pt([[Point, Segment], [Point, Point], [Point, Number]]), {}),
    center: ee(pt([[Circle], [Arc]]), { allowDotCall: true }),
    radius: ee(pt([[Circle], [Arc]]), { allowDotCall: true }),
    intersection: ee(pt([[Ag, Ag]])),
    strictintersection: ee(pt([[Ag, Ag]])),
    parallel: ee(pt([[o0, Point]])),
    perpendicular: ee(pt([[o0, Point]])),
    anglebisector: ee(pt([[Tx]])),
    start: ee([Ae([Vector]), Ae([Vector3D])], { allowDotCall: true }),
    end: ee([Ae([Vector]), Ae([Vector3D])], { allowDotCall: true }),
    length: ee([
      kt([ii], { geometry: false, "3d": false }),
      Ae([Segment3D]),
      Ae([Vector3D]),
      Ae([Segment]),
      Ae([Vector]),
      Ae([Arc]),
      kt({ type: "variadic", initial: [Any], rest: Any }, {
        geometry: false,
        "3d": false,
      }),
    ], { allowDotCall: true }),
    translate: ee(pt([[bp, Vector], [bp, Point, Point]])),
    dilate: ee(pt([[bp, Point, Number]])),
    rotate: ee(pt([[bp, Point, Number]])),
    reflect: ee(pt([[bp, o0]])),
    apply: ee(pt([[Transformation, bp]])),
    points: ee([]),
    lines: ee([]),
    circles: ee([]),
    arcs: ee([]),
    polygons: ee([]),
    rays: ee([]),
    vectors: ee([]),
    angle: ee(pt([[Point, Point, Point]])),
    directedangle: ee(pt([[Point, Point, Point]])),
    angles: ee(Su([[Polygon]]), { allowDotCall: true }),
    directedangles: ee(Su([[Polygon]]), { allowDotCall: true }),
    coterminal: ee(pt([[AngleMarker], [DirectedAngleMarker]])),
    round: ee([
      ...pt([[Te], [Te, Number]]),
      ...pt([[Complex], [Complex, Number]]),
    ]),
    mod: ee([...pt([[Te, Te]]), ...pt([[Complex, Complex]])]),
    floor: ee([...pt([[Te]]), ...pt([[Complex]])]),
    ceil: ee([...pt([[Te]]), ...pt([[Complex]])]),
    abs: ee([...pt([[Te]]), ...pt([[Complex]])]),
    sign: ee([Ae([Te]), Ae([Complex])]),
    real: ee([Ae([Complex])], { allowDotCall: true }),
    imag: ee([Ae([Complex])], { allowDotCall: true }),
    conj: ee([...pt([[Te]]), ...pt([[Complex]])]),
    exp: ee([Ae([Te]), Ae([Complex])]),
    sin: ee([Ae([Te]), Ae([Complex])]),
    cos: ee([Ae([Te]), Ae([Complex])]),
    tan: ee([Ae([Te]), Ae([Complex])]),
    sinh: ee([Ae([Te]), Ae([Complex])]),
    cosh: ee([Ae([Te]), Ae([Complex])]),
    tanh: ee([Ae([Te]), Ae([Complex])]),
    sec: ee([Ae([Te]), Ae([Complex])]),
    csc: ee([Ae([Te]), Ae([Complex])]),
    cot: ee([Ae([Te]), Ae([Complex])]),
    sech: ee([Ae([Te]), Ae([Complex])]),
    csch: ee([Ae([Te]), Ae([Complex])]),
    coth: ee([Ae([Te]), Ae([Complex])]),
    arctan: ee([Ae([Te]), Ae([Complex]), ...pt([[Number, Number]])]),
    arcsinh: ee([Ae([Te]), Ae([Complex])]),
    arccot: ee([Ae([Te]), Ae([Complex])]),
    arccsch: ee([Ae([Te]), Ae([Complex])]),
    nthroot: ee([...pt([[Number, Number]])]),
    complexNthRoot: ee([...pt([[Complex, Complex]])]),
    sort: ee(Su([[ro], [ListOfComplex], [ii, ro], [ii, ListOfComplex]]), {
      minArityExampleArgs: "([3,2,1])",
      maxArityExampleArgs: "([1,2,3],[3,2,1])",
      dotMaxArityExampleArgs: "([3,4])",
      allowDotCall: true,
    }),
    shuffle: ee(Su([[SeedType, ii], [SeedType, ii, Number]]), {
      minArityExampleArgs: "([1,2,3])",
      maxArityExampleArgs: "([1,2,3],2)",
      dotMaxArityExampleArgs: "(2)",
      allowDotCall: true,
      isSeeded: true,
    }),
    join: ee(Su([{ type: "variadic", initial: [u0, u0], rest: u0 }]), {
      minArityExampleArgs: "([1,2],[3,4])",
      dotMinArityExampleArgs: "([3,4])",
      allowDotCall: true,
    }),
    unique: ee(
      Su([[Qn.of(
        ii.types.filter((e) => e !== ListOfDistribution && e !== ListOfAny),
        { coerceComplexToReal: false },
      )]]),
      {
        minArityExampleArgs: "([1,2,3])",
        maxArityExampleArgs: "([1,2,3])",
        allowDotCall: true,
      },
    ),
    normaldist: ee(pt([[Number, Number]]), { defaultArguments: [vu, Kc] }),
    tdist: ee(pt([[Number]])),
    binomialdist: ee(pt([[Number, Number]]), { defaultArguments: [Nf] }),
    poissondist: ee(pt([[Number]])),
    uniformdist: ee(pt([[Number, Number]]), { defaultArguments: [vu, Kc] }),
    pdf: ee(pt([[Distribution, Number]]), { allowDotCall: true }),
    cdf: ee(pt([[Distribution, Number], [Distribution, Number, Number]]), {
      allowDotCall: true,
    }),
    median: ee([...pt([[Distribution]]), ...An(Number)], {
      fallthroughUnlessDistribution: true,
      allowDotCall: true,
    }),
    stdev: ee([...pt([[Distribution]]), ...An(Te), ...An(Complex)], {
      fallthroughUnlessDistribution: true,
      allowDotCall: true,
    }),
    stdevp: ee([...An(Te), ...An(Complex)], { allowDotCall: true }),
    var: ee([...pt([[Distribution]]), ...An(Te), ...An(Complex)], {
      fallthroughUnlessDistribution: true,
      allowDotCall: true,
    }),
    cov: ee([...xp(Te), ...xp(Complex)]),
    covp: ee([...xp(Te), ...xp(Complex)]),
    corr: ee([...xp(Te), ...xp(Complex)]),
    quantile: ee([
      ...pt([[Distribution, Number]]),
      kt([ListOfNumber, oi(Number)]),
    ], {
      fallthroughUnlessDistribution: true,
      allowDotCall: true,
      minArityExampleArgs: "([1,2,3], 1)",
      maxArityExampleArgs: "([1,2,3], 1)",
      dotMinArityExampleArgs: "(x)",
      dotMaxArityExampleArgs: "(x)",
    }),
    random: ee([
      kt([SeedType]),
      ...Su([[SeedType, Number], [SeedType, Number, Number], [SeedType, a0], [
        SeedType,
        a0,
        Number,
      ], [SeedType, a0, Number, Number]]),
    ], { allowDotCall: true, isSeeded: true }),
    polygon: ee([
      kt([]),
      ...An(Point),
      ...Su([[ListOfNumber, ListOfNumber], [Number, ListOfNumber], [
        ListOfNumber,
        Number,
      ]]),
    ]),
    total: ee([...An(Te), ...An(Complex), ...An(Point), ...An(Point3D)], {
      allowDotCall: true,
    }),
    mean: ee([
      Ae([Distribution]),
      ...An(Te),
      ...An(Complex),
      ...An(Point),
      ...An(Point3D),
    ], {
      fallthroughUnlessDistribution: true,
      allowDotCall: true,
    }),
    varp: ee([Ae([Distribution]), ...An(Te), ...An(Complex)], {
      fallthroughUnlessDistribution: true,
      allowDotCall: true,
    }),
    mad: ee([...An(Te), ...An(Complex)]),
    lcm: ee([...An(Te), ...An(Complex)], { allowDotCall: true }),
    gcd: ee([...An(Te), ...An(Complex)], { allowDotCall: true }),
    min: ee([...An(Number)], { allowDotCall: true }),
    max: ee([...An(Number)], { allowDotCall: true }),
    histogram: wo(),
    dotplot: wo(),
    boxplot: wo(),
    ttest: wo(),
    ittest: wo(),
    stats: wo(),
    det: wo(),
    inv: wo(),
    transpose: wo(),
    rref: wo(),
    trace: wo(),
  };
  function ck(e) {
    switch (e) {
      case "default":
      case "trig":
      case "inverseTrig":
      case "trig2":
      case "never-broadcast":
        return [Number];
      case "reducer":
        return [ListOfNumber];
      case "doubleReducer":
        return [ListOfNumber, ListOfNumber];
      case "parameterizedReducer":
        return [ListOfNumber, Number];
      case "color":
        return [Number, Number, Number];
    }
  }
  function lk(e) {
    switch (e) {
      case "default":
      case "trig":
      case "inverseTrig":
      case "trig2":
      case "doubleReducer":
      case "color":
      case "never-broadcast":
        return false;
      case "reducer":
      case "parameterizedReducer":
        return true;
    }
  }
  function pk(e, t, n) {
    return e === "reducer" ? 1 / 0 : t + n;
  }
  function A(e, t, n) {
    var d, y, g, m, h;
    n === void 0 && (n = {});
    let r = (d = n.tag) != null ? d : "default",
      s = (y = n.argumentTypes) != null ? y : ck(r),
      i = n.defaultArguments ? n.defaultArguments.length : 0,
      o = s.length - i,
      a = pk(r, o, i),
      u = (g = n.allowDotCall) != null ? g : lk(r),
      c = (m = n.noPeel) != null ? m : false,
      { defaultArguments: l, minArityExampleArgs: p, maxArityExampleArgs: f } =
        n;
    return {
      module: e,
      symbol: t,
      argumentTypes: s,
      defaultArguments: l,
      returnType: (h = n.returnType) != null ? h : Number,
      tag: r,
      minArity: o,
      maxArity: a,
      allowDotCall: u,
      noPeel: c,
      minArityExampleArgs: p,
      maxArityExampleArgs: f,
    };
  }
  function Ou(e) {
    let t;
    return e in Bn && (t = Bn[e].tag),
      t === "trig" || t === "trig2" || t === "inverseTrig"
        ? true
        : e === "angle" || e === "angles" || e === "directedangle" ||
          e === "directedangles" || e === "rotate";
  }
  var Bn = {
      sin: A("BuiltIn", "sin", { tag: "trig" }),
      cos: A("BuiltIn", "cos", { tag: "trig" }),
      tan: A("BuiltIn", "tan", { tag: "trig" }),
      cot: A("BuiltIn", "cot", { tag: "trig" }),
      sec: A("BuiltIn", "sec", { tag: "trig" }),
      csc: A("BuiltIn", "csc", { tag: "trig" }),
      arcsin: A("Math", "asin", { tag: "inverseTrig" }),
      arccos: A("Math", "acos", { tag: "inverseTrig" }),
      arctan: A("Math", "atan2", {
        argumentTypes: [Number, Number],
        tag: "inverseTrig",
      }),
      arccot: A("BuiltIn", "acot", { tag: "inverseTrig" }),
      arcsec: A("BuiltIn", "asec", { tag: "inverseTrig" }),
      arccsc: A("BuiltIn", "acsc", { tag: "inverseTrig" }),
      sinh: A("BuiltIn", "sinh"),
      cosh: A("BuiltIn", "cosh"),
      tanh: A("BuiltIn", "tanh"),
      coth: A("BuiltIn", "coth"),
      sech: A("BuiltIn", "sech"),
      csch: A("BuiltIn", "csch"),
      arcsinh: A("BuiltIn", "asinh"),
      arccosh: A("BuiltIn", "acosh"),
      arctanh: A("BuiltIn", "atanh"),
      arccoth: A("BuiltIn", "acoth"),
      arcsech: A("BuiltIn", "asech"),
      arccsch: A("BuiltIn", "acsch"),
      sqrt: A("Math", "sqrt"),
      rtxsqpone: A("BuiltIn", "sqrtxsqp1"),
      rtxsqmone: A("BuiltIn", "sqrtxsqm1"),
      hypot: A("BuiltIn", "hypot", { argumentTypes: [Number, Number] }),
      log: A("BuiltIn", "common_log"),
      logbase: A("BuiltIn", "log_base", { argumentTypes: [Number, Number] }),
      ln: A("BuiltIn", "log"),
      exp: A("Math", "exp"),
      floor: A("Math", "floor"),
      complexFloor: A("BuiltIn", "complexFloor", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      ceil: A("Math", "ceil"),
      complexCeil: A("BuiltIn", "complexCeil", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      round: A("Math", "round"),
      complexRound: A("BuiltIn", "complexRound", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      abs: A("Math", "abs"),
      sign: A("BuiltIn", "sign"),
      mod: A("BuiltIn", "mod", { argumentTypes: [Number, Number] }),
      complexMod: A("BuiltIn", "complexMod", {
        argumentTypes: [Complex, Complex],
        returnType: Complex,
      }),
      nCr: A("BuiltIn", "nCr", { argumentTypes: [Number, Number] }),
      nPr: A("BuiltIn", "nPr", { argumentTypes: [Number, Number] }),
      factorial: A("BuiltIn", "factorial"),
      polyGamma: A("BuiltIn", "polyGamma", { argumentTypes: [Number, Number] }),
      lcm: A("BuiltIn", "listLCM", { tag: "reducer" }),
      complexLCM: A("BuiltIn", "complexListLCM", {
        argumentTypes: [ListOfComplex],
        returnType: Complex,
        tag: "reducer",
      }),
      gcd: A("BuiltIn", "listGCD", { tag: "reducer" }),
      complexGCD: A("BuiltIn", "complexListGCD", {
        argumentTypes: [ListOfComplex],
        returnType: Complex,
        tag: "reducer",
      }),
      distance: A("BuiltIn", "distance", { argumentTypes: [Point, Point] }),
      polygon: A("BuiltIn", "polygon", {
        tag: "reducer",
        argumentTypes: [ListOfPoint],
        returnType: Polygon,
      }),
      area: A("BuiltIn", "polygonArea", { argumentTypes: [Polygon] }),
      perimeter: A("BuiltIn", "polygonPerimeter", { argumentTypes: [Polygon] }),
      pointDet: A("BuiltIn", "pointDet", { argumentTypes: [Point, Point] }),
      pointDot: A("BuiltIn", "pointDot", { argumentTypes: [Point, Point] }),
      pointPerp: A("BuiltIn", "pointPerp", {
        argumentTypes: [Point],
        returnType: Point,
      }),
      complexMultiplyPoints: A("BuiltIn", "complexMultiplyPoints", {
        argumentTypes: [Point, Point],
        returnType: Point,
      }),
      segment: A("BuiltIn", "segment", {
        argumentTypes: [Point, Point],
        returnType: Segment,
      }),
      line: A("BuiltIn", "line", {
        argumentTypes: [Point, Point],
        returnType: Line,
      }),
      ray: A("BuiltIn", "ray", {
        argumentTypes: [Point, Point],
        returnType: Ray,
      }),
      vector: A("BuiltIn", "vector", {
        argumentTypes: [Point, Point],
        returnType: Vector,
      }),
      vectorThreeD: A("BuiltIn", "vectorThreeD", {
        argumentTypes: [Point3D, Point3D],
        returnType: Vector3D,
      }),
      mathVector: A("BuiltIn", "mathVector", {
        argumentTypes: [Point, Point],
        returnType: Vector,
      }),
      mathVectorThreeD: A("BuiltIn", "mathVectorThreeD", {
        argumentTypes: [Point3D, Point3D],
        returnType: Vector3D,
      }),
      vectorDisplacementAsPoint: A("BuiltIn", "vectorDisplacementAsPoint", {
        argumentTypes: [Vector],
        returnType: Point,
      }),
      vectorThreeDDisplacementAsPoint: A(
        "BuiltIn",
        "vectorThreeDDisplacementAsPoint",
        { argumentTypes: [Vector3D], returnType: Point3D },
      ),
      basePointFromVector: A("BuiltIn", "basePointFromVector", {
        argumentTypes: [Vector],
        returnType: Point,
      }),
      basePointFromVectorThreeD: A("BuiltIn", "basePointFromVectorThreeD", {
        argumentTypes: [Vector3D],
        returnType: Point3D,
      }),
      circle: A("BuiltIn", "circle", {
        argumentTypes: [Point, Number],
        returnType: Circle,
      }),
      center: A("BuiltIn", "center", {
        argumentTypes: [Circle],
        returnType: Point,
        allowDotCall: true,
      }),
      radius: A("BuiltIn", "radius", {
        argumentTypes: [Circle],
        returnType: Number,
        allowDotCall: true,
      }),
      arc: A("BuiltIn", "arc", {
        argumentTypes: [Point, Point, Point],
        returnType: Arc,
      }),
      arcCenter: A("BuiltIn", "arcCenter", {
        argumentTypes: [Arc],
        returnType: Point,
      }),
      arcFirstPoint: A("BuiltIn", "arcFirstPoint", {
        argumentTypes: [Arc],
        returnType: Point,
      }),
      arcMiddlePoint: A("BuiltIn", "arcMiddlePoint", {
        argumentTypes: [Arc],
        returnType: Point,
      }),
      arcThirdPoint: A("BuiltIn", "arcThirdPoint", {
        argumentTypes: [Arc],
        returnType: Point,
      }),
      arcOmega: A("BuiltIn", "arcOmega", {
        argumentTypes: [Arc],
        returnType: Number,
      }),
      undirectedAngleMarker: A("BuiltIn", "undirectedAngleMarker", {
        argumentTypes: [DirectedAngleMarker],
        returnType: AngleMarker,
      }),
      directedAngleMarker: A("BuiltIn", "directedAngleMarker", {
        argumentTypes: [Point, Number, Number, Number],
        returnType: DirectedAngleMarker,
      }),
      directedCoterminalAngle: A("BuiltIn", "directedCoterminalAngle", {
        argumentTypes: [DirectedAngleMarker],
        returnType: DirectedAngleMarker,
      }),
      undirectedCoterminalAngle: A("BuiltIn", "undirectedCoterminalAngle", {
        argumentTypes: [AngleMarker],
        returnType: AngleMarker,
      }),
      supplement: A("BuiltIn", "supplementAngle", {
        argumentTypes: [DirectedAngleMarker],
        returnType: DirectedAngleMarker,
      }),
      directedAngleMarkerRawDelta: A("BuiltIn", "angleMarkerRawDelta", {
        argumentTypes: [DirectedAngleMarker],
        returnType: Number,
      }),
      undirectedAngleMarkerRawDelta: A("BuiltIn", "angleMarkerRawDelta", {
        argumentTypes: [AngleMarker],
        returnType: Number,
      }),
      directedAngleMarkerMultiplier: A("BuiltIn", "angleMarkerMultiplier", {
        argumentTypes: [DirectedAngleMarker],
        returnType: Number,
      }),
      undirectedAngleMarkerMultiplier: A("BuiltIn", "angleMarkerMultiplier", {
        argumentTypes: [AngleMarker],
        returnType: Number,
      }),
      polygonInteriorUndirectedAngles: A(
        "BuiltIn",
        "polygonInteriorUndirectedAngles",
        {
          argumentTypes: [Polygon, Number],
          returnType: ListOfAngleMarker,
          allowDotCall: true,
          tag: "never-broadcast",
        },
      ),
      polygonInteriorDirectedAngles: A(
        "BuiltIn",
        "polygonInteriorDirectedAngles",
        {
          argumentTypes: [Polygon, Number],
          returnType: ListOfDirectedAngleMarker,
          allowDotCall: true,
          tag: "never-broadcast",
        },
      ),
      vertices: A("BuiltIn", "vertices", {
        argumentTypes: [Polygon],
        returnType: ListOfPoint,
        allowDotCall: true,
        tag: "never-broadcast",
      }),
      segments: A("BuiltIn", "polygonEdges", {
        argumentTypes: [Polygon],
        returnType: ListOfSegment,
        allowDotCall: true,
        tag: "never-broadcast",
      }),
      scaleTangentTransformation: A("BuiltIn", "scaleTangentTransformation", {
        argumentTypes: [Transformation, Number],
        returnType: Polygon,
      }),
      scaleTangentPolygon: A("BuiltIn", "scaleTangentPolygon", {
        argumentTypes: [Polygon, Number],
        returnType: Polygon,
      }),
      scaleTangentSegment: A("BuiltIn", "scaleTangentSegment", {
        argumentTypes: [Segment, Number],
        returnType: Segment,
      }),
      scaleTangentLine: A("BuiltIn", "scaleTangentLine", {
        argumentTypes: [Line, Number],
        returnType: Line,
      }),
      scaleTangentRay: A("BuiltIn", "scaleTangentRay", {
        argumentTypes: [Ray, Number],
        returnType: Ray,
      }),
      scaleTangentCircle: A("BuiltIn", "scaleTangentCircle", {
        argumentTypes: [Circle, Number],
        returnType: Circle,
      }),
      scaleTangentArc: A("BuiltIn", "scaleTangentArc", {
        argumentTypes: [Arc, Number],
        returnType: Circle,
      }),
      scaleTangentDirectedAngleMarker: A("BuiltIn", "scaleTangentAngle", {
        argumentTypes: [DirectedAngleMarker, Number],
        returnType: DirectedAngleMarker,
      }),
      scaleTangentUndirectedAngleMarker: A("BuiltIn", "scaleTangentAngle", {
        argumentTypes: [AngleMarker, Number],
        returnType: AngleMarker,
      }),
      addTangentPolygon: A("BuiltIn", "addTangentPolygon", {
        argumentTypes: [Polygon, Polygon],
        returnType: Polygon,
      }),
      addTangentSegment: A("BuiltIn", "addTangentSegment", {
        argumentTypes: [Segment, Segment],
        returnType: Segment,
      }),
      addTangentSegmentThreeD: A("BuiltIn", "addTangentSegmentThreeD", {
        argumentTypes: [Segment3D, Segment3D],
        returnType: Segment3D,
      }),
      addTangentLine: A("BuiltIn", "addTangentLine", {
        argumentTypes: [Line, Line],
        returnType: Line,
      }),
      addTangentRay: A("BuiltIn", "addTangentRay", {
        argumentTypes: [Ray, Ray],
        returnType: Ray,
      }),
      addTangentVector: A("BuiltIn", "addTangentVector", {
        argumentTypes: [Vector, Vector],
        returnType: Vector,
      }),
      addTangentCircle: A("BuiltIn", "addTangentCircle", {
        argumentTypes: [Circle, Circle],
        returnType: Circle,
      }),
      addTangentArc: A("BuiltIn", "addTangentArc", {
        argumentTypes: [Arc, Arc],
        returnType: Arc,
      }),
      addTangentTransformation: A("BuiltIn", "addTangentTransformation", {
        argumentTypes: [Transformation, Transformation],
        returnType: Transformation,
      }),
      addTangentDirectedAngleMarker: A("BuiltIn", "addTangentAngle", {
        argumentTypes: [DirectedAngleMarker, DirectedAngleMarker],
        returnType: DirectedAngleMarker,
      }),
      addTangentUndirectedAngleMarker: A("BuiltIn", "addTangentAngle", {
        argumentTypes: [AngleMarker, AngleMarker],
        returnType: AngleMarker,
      }),
      segmentGlider: A("BuiltIn", "segmentGlider", {
        argumentTypes: [Segment, Number],
        returnType: Point,
      }),
      segmentThreeDGlider: A("BuiltIn", "segmentThreeDGlider", {
        argumentTypes: [Segment3D, Number],
        returnType: Point3D,
      }),
      lineGlider: A("BuiltIn", "lineGlider", {
        argumentTypes: [Line, Number],
        returnType: Point,
      }),
      rayGlider: A("BuiltIn", "rayGlider", {
        argumentTypes: [Ray, Number],
        returnType: Point,
      }),
      circleGlider: A("BuiltIn", "circleGlider", {
        argumentTypes: [Circle, Number],
        returnType: Point,
      }),
      arcGlider: A("BuiltIn", "arcGlider", {
        argumentTypes: [Arc, Number],
        returnType: Point,
      }),
      polygonEdgeByParameter: A("BuiltIn", "polygonEdgeByParameter", {
        argumentTypes: [Polygon, Number],
        returnType: Segment,
      }),
      polygonGlider: A("BuiltIn", "polygonGlider", {
        argumentTypes: [Polygon, Number],
        returnType: Point,
      }),
      chooseNonIncidentPoint: A("BuiltIn", "chooseNonIncidentPoint", {
        argumentTypes: [Point, Point, Point],
        returnType: Point,
      }),
      circleCircleIntersection: A("BuiltIn", "circleCircleIntersection", {
        argumentTypes: [Circle, Circle, Number],
        returnType: Point,
      }),
      circleArcIntersection: A("BuiltIn", "circleArcIntersection", {
        argumentTypes: [Circle, Arc, Number],
        returnType: Point,
      }),
      circleLineIntersection: A("BuiltIn", "circleLineIntersection", {
        argumentTypes: [Circle, Line, Number],
        returnType: Point,
      }),
      arcCircleIntersection: A("BuiltIn", "arcCircleIntersection", {
        argumentTypes: [Arc, Circle, Number],
        returnType: Point,
      }),
      arcArcIntersection: A("BuiltIn", "arcArcIntersection", {
        argumentTypes: [Arc, Arc, Number],
        returnType: Point,
      }),
      arcLineIntersection: A("BuiltIn", "arcLineIntersection", {
        argumentTypes: [Arc, Line, Number],
        returnType: Point,
      }),
      lineCircleIntersection: A("BuiltIn", "lineCircleIntersection", {
        argumentTypes: [Line, Circle, Number],
        returnType: Point,
      }),
      lineArcIntersection: A("BuiltIn", "lineArcIntersection", {
        argumentTypes: [Line, Arc, Number],
        returnType: Point,
      }),
      lineLineIntersection: A("BuiltIn", "lineLineIntersection", {
        argumentTypes: [Line, Line, Number],
        returnType: Point,
      }),
      lineFromSegment: A("BuiltIn", "identity", {
        argumentTypes: [Segment],
        returnType: Line,
      }),
      lineFromRay: A("BuiltIn", "identity", {
        argumentTypes: [Ray],
        returnType: Line,
      }),
      parallel: A("BuiltIn", "parallel", {
        argumentTypes: [Line, Point],
        returnType: Line,
      }),
      perpendicular: A("BuiltIn", "perpendicular", {
        argumentTypes: [Line, Point],
        returnType: Line,
      }),
      anglebisector: A("BuiltIn", "anglebisector", {
        argumentTypes: [AngleMarker],
        returnType: Ray,
      }),
      directedanglebisector: A("BuiltIn", "anglebisector", {
        argumentTypes: [DirectedAngleMarker],
        returnType: Ray,
      }),
      rawTransform: A("BuiltIn", "rawTransform", {
        argumentTypes: [Point, Point],
        returnType: Transformation,
      }),
      rawTransformConj: A("BuiltIn", "rawTransformConj", {
        argumentTypes: [Point, Point],
        returnType: Transformation,
      }),
      transformWithoutTranslation: A("BuiltIn", "transformWithoutTranslation", {
        argumentTypes: [Transformation],
        returnType: Transformation,
      }),
      transformScaleFactor: A("BuiltIn", "transformScaleFactor", {
        argumentTypes: [Transformation],
        returnType: Point,
      }),
      translation: A("BuiltIn", "translation", {
        argumentTypes: [Point],
        returnType: Transformation,
      }),
      dilation: A("BuiltIn", "dilation", {
        argumentTypes: [Point, Number],
        returnType: Transformation,
      }),
      rotation: A("BuiltIn", "rotation", {
        tag: "trig2",
        argumentTypes: [Point, Number],
        returnType: Transformation,
      }),
      reflection: A("BuiltIn", "reflection", {
        argumentTypes: [Line],
        returnType: Transformation,
      }),
      compose: A("BuiltIn", "composeTransformation", {
        argumentTypes: [Transformation, Transformation],
        returnType: Transformation,
      }),
      inverse: A("BuiltIn", "invertTransformation", {
        argumentTypes: [Transformation],
        returnType: Transformation,
      }),
      transformPoint: A("BuiltIn", "transformPoint", {
        argumentTypes: [Transformation, Point],
        returnType: Point,
      }),
      transformSegment: A("BuiltIn", "transformSegment", {
        argumentTypes: [Transformation, Segment],
        returnType: Segment,
      }),
      transformLine: A("BuiltIn", "transformLine", {
        argumentTypes: [Transformation, Line],
        returnType: Line,
      }),
      transformRay: A("BuiltIn", "transformRay", {
        argumentTypes: [Transformation, Ray],
        returnType: Ray,
      }),
      transformVector: A("BuiltIn", "transformVector", {
        argumentTypes: [Transformation, Vector],
        returnType: Vector,
      }),
      transformCircle: A("BuiltIn", "transformCircle", {
        argumentTypes: [Transformation, Circle],
        returnType: Circle,
      }),
      transformArc: A("BuiltIn", "transformArc", {
        argumentTypes: [Transformation, Arc],
        returnType: Arc,
      }),
      transformPolygon: A("BuiltIn", "transformPolygon", {
        argumentTypes: [Transformation, Polygon],
        returnType: Polygon,
      }),
      transformAngleMarker: A("BuiltIn", "transformAngleMarker", {
        argumentTypes: [Transformation, AngleMarker],
        returnType: AngleMarker,
      }),
      transformDirectedAngleMarker: A("BuiltIn", "transformAngleMarker", {
        argumentTypes: [Transformation, DirectedAngleMarker],
        returnType: DirectedAngleMarker,
      }),
      distanceThreeD: A("BuiltIn", "distanceThreeD", {
        argumentTypes: [Point3D, Point3D],
      }),
      segmentThreeD: A("BuiltIn", "segmentThreeD", {
        argumentTypes: [Point3D, Point3D],
        returnType: Segment3D,
      }),
      triangle: A("BuiltIn", "triangle", {
        argumentTypes: [Point3D, Point3D, Point3D],
        returnType: Triangle3D,
      }),
      sphere: A("BuiltIn", "sphere", {
        argumentTypes: [Point3D, Number],
        returnType: Sphere3D,
      }),
      mean: A("BuiltIn", "mean", { tag: "reducer" }),
      total: A("BuiltIn", "total", { tag: "reducer" }),
      stdev: A("BuiltIn", "stdev", { tag: "reducer" }),
      stdevp: A("BuiltIn", "stdevp", { tag: "reducer" }),
      mad: A("BuiltIn", "mad", { tag: "reducer" }),
      count: A("BuiltIn", "listLength", {
        tag: "reducer",
        argumentTypes: [ListOfAny],
        noPeel: true,
      }),
      listMin: A("BuiltIn", "listMin", { tag: "reducer" }),
      listMax: A("BuiltIn", "listMax", { tag: "reducer" }),
      min: A("Math", "min", {
        argumentTypes: [Number, Number],
        returnType: Number,
      }),
      max: A("Math", "max", {
        argumentTypes: [Number, Number],
        returnType: Number,
      }),
      argmin: A("BuiltIn", "argMin", { tag: "reducer", noPeel: true }),
      argmax: A("BuiltIn", "argMax", { tag: "reducer", noPeel: true }),
      median: A("BuiltIn", "median", { tag: "reducer" }),
      var: A("BuiltIn", "variance", { tag: "reducer" }),
      varp: A("BuiltIn", "varp", { tag: "reducer" }),
      cov: A("BuiltIn", "cov", { tag: "doubleReducer" }),
      covp: A("BuiltIn", "covp", { tag: "doubleReducer" }),
      corr: A("BuiltIn", "corr", { tag: "doubleReducer" }),
      spearman: A("BuiltIn", "spearman", { tag: "doubleReducer" }),
      quantile: A("BuiltIn", "quantile", { tag: "parameterizedReducer" }),
      quartile: A("BuiltIn", "quartile", { tag: "parameterizedReducer" }),
      upperQuantileIndex: A("BuiltIn", "upperQuantileIndex", {
        tag: "parameterizedReducer",
      }),
      lowerQuantileIndex: A("BuiltIn", "lowerQuantileIndex", {
        tag: "parameterizedReducer",
      }),
      quartileIndex: A("BuiltIn", "quartileIndex", {
        tag: "parameterizedReducer",
      }),
      upperQuartileIndex: A("BuiltIn", "upperQuartileIndex", {
        tag: "parameterizedReducer",
      }),
      lowerQuartileIndex: A("BuiltIn", "lowerQuartileIndex", {
        tag: "parameterizedReducer",
      }),
      normalcdf: A("BuiltIn", "normalcdf", {
        argumentTypes: [Number, Number, Number, Number],
        defaultArguments: [vu, Kc],
      }),
      normalpdf: A("BuiltIn", "normalpdf", {
        argumentTypes: [Number, Number, Number],
        defaultArguments: [vu, Kc],
      }),
      binomcdf: A("BuiltIn", "binomcdf", {
        argumentTypes: [Number, Number, Number, Number],
        defaultArguments: [Nf],
      }),
      binompdf: A("BuiltIn", "binompdf", {
        argumentTypes: [Number, Number, Number],
        defaultArguments: [Nf],
      }),
      poissoncdf: A("BuiltIn", "poissoncdf", {
        argumentTypes: [Number, Number, Number],
      }),
      poissonpdf: A("BuiltIn", "poissonpdf", {
        argumentTypes: [Number, Number, Number],
      }),
      uniformcdf: A("BuiltIn", "uniformcdf", {
        argumentTypes: [Number, Number, Number, Number],
        defaultArguments: [vu, Kc],
      }),
      uniformpdf: A("BuiltIn", "uniformpdf", {
        argumentTypes: [Number, Number, Number],
        defaultArguments: [vu, Kc],
      }),
      invT: A("BuiltIn", "invT", { argumentTypes: [Number, Number] }),
      invPoisson: A("BuiltIn", "invPoisson", {
        argumentTypes: [Number, Number],
      }),
      invBinom: A("BuiltIn", "invBinom", {
        argumentTypes: [Number, Number, Number],
      }),
      invUniform: A("BuiltIn", "invUniform", {
        argumentTypes: [Number, Number, Number],
      }),
      tpdf: A("BuiltIn", "tpdf", { argumentTypes: [Number, Number] }),
      tcdf: A("BuiltIn", "tcdf", { argumentTypes: [Number, Number, Number] }),
      erf: A("BuiltIn", "erf"),
      invNorm: A("BuiltIn", "invNorm"),
      tscore: A("BuiltIn", "tscore", {
        tag: "parameterizedReducer",
        defaultArguments: [vu],
      }),
      normalSample: A("BuiltIn", "normalSample", {
        argumentTypes: [SeedType, Number, Number],
      }),
      uniformSample: A("BuiltIn", "uniformSample", {
        argumentTypes: [SeedType, Number, Number],
      }),
      tSample: A("BuiltIn", "tSample", { argumentTypes: [SeedType, Number] }),
      poissonSample: A("BuiltIn", "poissonSample", {
        argumentTypes: [SeedType, Number],
      }),
      binomSample: A("BuiltIn", "binomSample", {
        argumentTypes: [SeedType, Number, Number],
      }),
      rgb: A("BuiltIn", "rgb", { returnType: RGBColor, tag: "color" }),
      hsv: A("BuiltIn", "hsv", { returnType: RGBColor, tag: "color" }),
      tone: A("BuiltIn", "tone", {
        argumentTypes: [Number, Number],
        returnType: Tone,
        defaultArguments: [Nf],
        minArityExampleArgs: "(440)",
        maxArityExampleArgs: "(440, 0.5)",
      }),
      validateRangeLength: A("BuiltIn", "validateRangeLength", {
        returnType: Number,
        argumentTypes: [ListOfNumber, ListOfNumber, Number, Number],
        tag: "never-broadcast",
        noPeel: true,
      }),
      validateSampleCount: A("BuiltIn", "validateSampleCount", {
        returnType: Number,
        argumentTypes: [Number],
      }),
      select: A("BuiltIn", "select", {
        argumentTypes: [ListOfAny, ListOfBool],
        returnType: (e) => e[0],
        tag: "never-broadcast",
        noPeel: true,
      }),
      shuffle: A("BuiltIn", "shuffle", {
        argumentTypes: [SeedType, ListOfAny],
        returnType: (e) => e[1],
        tag: "never-broadcast",
      }),
      sortPerm: A("BuiltIn", "sortPerm", {
        argumentTypes: [ListOfNumber],
        returnType: ListOfNumber,
        tag: "never-broadcast",
        noPeel: true,
      }),
      complexSortPerm: A("BuiltIn", "complexSortPerm", {
        argumentTypes: [ListOfComplex],
        returnType: ListOfNumber,
        tag: "never-broadcast",
        noPeel: true,
      }),
      elementsAt: A("BuiltIn", "elementsAt", {
        argumentTypes: [ListOfAny, ListOfNumber],
        returnType: (e) => e[0],
        tag: "never-broadcast",
        noPeel: true,
      }),
      uniquePerm: A("BuiltIn", "uniquePerm", {
        argumentTypes: [ListOfAny],
        returnType: ListOfNumber,
        tag: "never-broadcast",
        noPeel: true,
      }),
      restriction: A("BuiltIn", "restriction", {
        argumentTypes: [Bool],
        returnType: Restriction,
      }),
      restrictionToBoolean: A("BuiltIn", "restrictionToBoolean", {
        argumentTypes: [Restriction],
        returnType: Bool,
      }),
      complex: A("BuiltIn", "complex", {
        argumentTypes: [Number, Number],
        returnType: Complex,
      }),
      arg: A("BuiltIn", "arg", {
        argumentTypes: [Complex],
        returnType: Number,
      }),
      complexDivide: A("BuiltIn", "complexDivide", {
        argumentTypes: [Complex, Complex],
        returnType: Complex,
      }),
      peelableCoerceComplexToReal: A("BuiltIn", "coerceComplexToReal", {
        argumentTypes: [Complex],
        returnType: Number,
      }),
      coerceComplexToReal: A("BuiltIn", "coerceComplexToReal", {
        argumentTypes: [Complex],
        returnType: Number,
      }),
      coerceRealToComplex: A("BuiltIn", "coerceRealToComplex", {
        argumentTypes: [Number],
        returnType: Complex,
      }),
      complexSqrt: A("BuiltIn", "complexSqrt", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexLn: A("BuiltIn", "complexLog", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexLogbase: A("BuiltIn", "complexLogbase", {
        argumentTypes: [Complex, Complex],
        returnType: Complex,
      }),
      complexLog: A("BuiltIn", "complexCommonLog", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexExp: A("BuiltIn", "complexExp", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexPow: A("BuiltIn", "complexPow", {
        argumentTypes: [Complex, Complex],
        returnType: Complex,
      }),
      complexSin: A("BuiltIn", "complexSin", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexCos: A("BuiltIn", "complexCos", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexTan: A("BuiltIn", "complexTan", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexSinh: A("BuiltIn", "complexSinh", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexCosh: A("BuiltIn", "complexCosh", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexTanh: A("BuiltIn", "complexTanh", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexSec: A("BuiltIn", "complexSec", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexCsc: A("BuiltIn", "complexCsc", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexCot: A("BuiltIn", "complexCot", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexSech: A("BuiltIn", "complexSech", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexCsch: A("BuiltIn", "complexCsch", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexCoth: A("BuiltIn", "complexCoth", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArcsin: A("BuiltIn", "complexAsin", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArccos: A("BuiltIn", "complexAcos", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArctan: A("BuiltIn", "complexAtan", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArcsec: A("BuiltIn", "complexAsec", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArccsc: A("BuiltIn", "complexAcsc", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArccot: A("BuiltIn", "complexAcot", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArcsinh: A("BuiltIn", "complexAsinh", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArccosh: A("BuiltIn", "complexAcosh", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArctanh: A("BuiltIn", "complexAtanh", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArcsech: A("BuiltIn", "complexAsech", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArccsch: A("BuiltIn", "complexAcsch", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      complexArccoth: A("BuiltIn", "complexAcoth", {
        argumentTypes: [Complex],
        returnType: Complex,
      }),
      angleVertex: A("BuiltIn", "angleVertex", {
        argumentTypes: [AngleMarker],
        returnType: Point,
      }),
      angleStart: A("BuiltIn", "angleStart", {
        argumentTypes: [AngleMarker],
        returnType: Number,
      }),
      directedAngleVertex: A("BuiltIn", "angleVertex", {
        argumentTypes: [DirectedAngleMarker],
        returnType: Point,
      }),
      directedAngleStart: A("BuiltIn", "angleStart", {
        argumentTypes: [DirectedAngleMarker],
        returnType: Number,
      }),
    },
    Ip = {
      sqrt: "complexSqrt",
      ln: "complexLn",
      log: "complexLog",
      logbase: "complexLogbase",
      exp: "complexExp",
      sin: "complexSin",
      cos: "complexCos",
      tan: "complexTan",
      sinh: "complexSinh",
      cosh: "complexCosh",
      tanh: "complexTanh",
      sec: "complexSec",
      csc: "complexCsc",
      cot: "complexCot",
      sech: "complexSech",
      csch: "complexCsch",
      coth: "complexCoth",
      arcsin: "complexArcsin",
      arccos: "complexArccos",
      arctan: "complexArctan",
      arcsec: "complexArcsec",
      arccsc: "complexArccsc",
      arccot: "complexArccot",
      arcsinh: "complexArcsinh",
      arccosh: "complexArccosh",
      arctanh: "complexArctanh",
      arcsech: "complexArcsech",
      arccsch: "complexArccsch",
      arccoth: "complexArccoth",
      floor: "complexFloor",
      ceil: "complexCeil",
      mod: "complexMod",
      nthroot: "complexNthRoot",
      sortPerm: "complexSortPerm",
    },
    dk = {
      sqrt: true,
      ln: true,
      log: true,
      logbase: true,
      arcsin: true,
      arccos: true,
      arcsec: true,
      arccsc: true,
      arccosh: true,
      arctanh: true,
      arcsech: true,
      arccoth: true,
      nthroot: true,
    };
  function _g(e, t) {
    return e.isComplexEnabled() && t in dk ? Ip[t] : t;
  }
  function Tp(e) {
    return !!Bn[e];
  }
  function Rf(e, t) {
    let n = el(t) ? Fo[t] : void 0;
    if (!n && !Tp(t)) return;
    let r = [];
    return n && (r = [...n.getSignatures(e)]),
      Tp(t) && !n && r.push(...l0(t)),
      r;
  }
  function l0(e) {
    var s;
    let t = [], n = Bn[e], r = (s = n.returnType) != null ? s : Number;
    switch (n.tag) {
      case "reducer": {
        if (
          Array.isArray(n.argumentTypes) &&
          typeof n.argumentTypes[0] == "number" && j(n.argumentTypes[0]) &&
          typeof r == "number" && wn(r)
        ) {
          let i = n.argumentTypes[0], o = Ve(i);
          t.push(...An(o));
        } else {throw new Error(
            `Programming error: declared argumentTypes for built-in function ${e} is not consistent with "reducer"`,
          );}
        break;
      }
      case "parameterizedReducer": {
        if (
          t.push(kt(n.argumentTypes)),
            Array.isArray(n.argumentTypes) && n.argumentTypes.length === 2
        ) {
          let i = n.argumentTypes[1];
          t.push(
            kt([n.argumentTypes[0], typeof i == "number" && wn(i) ? oi(i) : i]),
          );
        }
        break;
      }
      case "doubleReducer":
      case "never-broadcast": {
        t.push(kt(n.argumentTypes));
        break;
      }
      default: {
        t.push(kt(n.argumentTypes.map((i) => ty(i) ? oi(i) : i)));
        break;
      }
    }
    return t;
  }
  var we = class extends Q {
    constructor(t) {
      super([]),
        this._symbol = latexToIdentifier(t),
        this._errorSymbol = this._symbol,
        this.addDependency(this._symbol);
    }
    setInputSpan(t) {
      super.setInputSpan(t),
        this._errorSymbol = latexToIdentifier(this.getInputString());
    }
    getInputSpan() {
      return this._inputSpan === void 0
        ? Vs(this._symbol, 0, this._symbol.length)
        : this._inputSpan;
    }
  };
  var gn = class extends Q {
    constructor(t, n) {
      super(n, { skipRegisterDependencies: true }),
        typeof t == "string" && (t = new we(t)),
        this._identifier = t,
        this._symbol = t._symbol,
        this._errorSymbol = t._errorSymbol === "logbase"
          ? "log"
          : t._errorSymbol,
        this.registerDependencies();
    }
    registerDependencies() {
      this.addDependency(this._symbol),
        super.registerDependencies(),
        Ou(this._symbol) && this.addDependency("trigAngleMultiplier");
    }
  };
  var ao = class extends Q {
    slot(t) {
      return this.args[t];
    }
  };
  var p0 = {
    pi: new Et(Math.PI),
    tau: new Et(2 * Math.PI),
    e: new Et(Math.E),
    trigAngleMultiplier: new Et(Se(1, 1)),
    infty: new Et(1 / 0),
    identityTransformation: new gn("translation", [
      new ao([new Et(0), new Et(0)]),
    ]),
  };
  var Lg = class extends Yt {
      constructor() {
        super(...arguments);
        this.isFunction = true;
      }
    },
    tl,
    tt = {};
  for (tl of We(p0)) tt[tl] = p0[tl];
  for (tl of We(Bn)) tt[tl] = new Lg();
  for (tl of We(Fo)) tt[tl] = new Lg();
  var Jr = {
    "<": { inclusive: false, direction: -1 },
    "!=": { inclusive: false, direction: 0 },
    ">": { inclusive: false, direction: 1 },
    "<=": { inclusive: true, direction: -1 },
    "=": { inclusive: true, direction: 0 },
    ">=": { inclusive: true, direction: 1 },
  };
  function nl(e, t) {
    switch (t) {
      case -1:
        return e ? "<=" : "<";
      case 0:
        return e ? "=" : "!=";
      case 1:
        return e ? ">=" : ">";
      default:
        throw "Programming error.  Comparators must have a direction of -1, 0, or 1";
    }
  }
  var Es = class extends Q {};
  var uo = class e extends Q {
    constructor(n, r) {
      super(r);
      this.operator = n;
      this._difference = Jr[this.operator].direction === -1
        ? new Es([r[1], r[0]])
        : new Es([r[0], r[1]]);
    }
    static create(n) {
      class r extends e {
        constructor(i) {
          super(n, i);
        }
      }
      return r;
    }
    asComparator() {
      return this;
    }
    isInequality() {
      return Jr[this.operator].direction !== 0;
    }
  };
  var ps = {
    "<": uo.create("<"),
    ">": uo.create(">"),
    "<=": uo.create("<="),
    ">=": uo.create(">="),
    "=": uo.create("="),
  };
  var Nu = class extends Yt {
    constructor(t, n) {
      super(),
        this.mergeDependencies(t, n),
        this._lhs = t,
        this._rhs = n,
        this._difference = new Es([this._lhs, this._rhs]);
    }
    asComparator() {
      return new ps["="]([this._lhs, this._rhs]);
    }
  };
  var Cr = class extends Yt {
    constructor(n, r, s, i) {
      super();
      this.recursionInfo = i;
      this.externalBaseCases = [];
      this.isFunction = true;
      this._symbol = n._symbol, this._argSymbols = r.map((o) => o._symbol);
      for (let o of this._argSymbols) if (o === this._symbol) throw PI(o);
      this._exports = [this._symbol],
        this._expression = s,
        this.mergeDependenciesInScope(
          this.type,
          [this._symbol].concat(this._argSymbols),
          this._expression,
          { functionDefinitionSymbol: this._symbol },
        ),
        this.combinedDependencies = super.getDependencies();
    }
    getDependencies() {
      return this.combinedDependencies;
    }
    setExternalBaseCases(n) {
      this.externalBaseCases = [...n],
        this.combinedDependencies = [...super.getDependencies()];
      for (let r of n) {
        let s = r.getRef();
        s && this.combinedDependencies.push(s);
      }
    }
    getExternalBaseCases() {
      return this.externalBaseCases;
    }
    getSliderVariables(n, r) {
      let s = this._argSymbols;
      return super.getSliderVariables(n, r).filter((i) => s.indexOf(i) === -1);
    }
    asEquation() {
      let n = this._argSymbols.map((s) => new we(s)),
        r = new Nu(new gn(new we(this._symbol), n), this._expression);
      return r.userData = this.userData, r.metaData = this.metaData, r;
    }
  };
  var Qr = class e extends Yt {
    constructor(n, r, s, i, o) {
      super();
      this.specifiedArg = s;
      this.rhs = i;
      this.originalNode = o;
      if (
        this._symbol = n,
          this._argSymbols = r.map((a) => a._symbol),
          this._expression = i,
          this.userData = o.userData,
          this.metaData = o.metaData,
          this._inputSpan = o._inputSpan,
          this.mergeDependenciesInScope(
            "FunctionDefinition",
            this._argSymbols,
            this._expression,
            { functionDefinitionSymbol: this._symbol },
          ),
          s.valid
      ) {
        let a = s.functionDefArgSymbols.slice();
        a[s.argIndex] = s.argValue.toString(),
          this.ref = `_base_case:${n}:${a.join(",")}`,
          this._exports = [this.ref];
      } else {
        let a = this._exports.find((u) => u.indexOf("idref") !== -1);
        a && (this.ref = a);
      }
    }
    static fromCallAssignment(n, r) {
      let s = r._lhs;
      if (!(s instanceof gn)) return;
      let i = n[s._symbol];
      if (!i || !(i instanceof Cr)) return;
      if (s.args.length !== i._argSymbols.length) {
        return new e(
          i._symbol,
          [],
          { valid: false, error: _x(i._symbol, i._argSymbols.length) },
          r._rhs,
          r,
        );
      }
      let o, a = [];
      for (let u = 0; u < s.args.length; u++) {
        let c = s.args[u];
        if (c instanceof Et) {
          if (o) {
            o = { valid: false, error: wd() };
            break;
          }
          o = {
            valid: true,
            argIndex: u,
            functionDefArgSymbols: i._argSymbols,
            argValue: c.asValue(),
            argSymbol: i._argSymbols[u],
          };
        } else if (c instanceof we) {
          if (c._symbol !== i._argSymbols[u]) {
            o = { valid: false, error: ay() };
            break;
          } else a.push(c);
        } else {
          o = { valid: false, error: ay() };
          break;
        }
      }
      if (o) return new e(i._symbol, a, o, r._rhs, r);
    }
    getRef() {
      return this.ref;
    }
    getSliderVariables(n, r) {
      let s = this._argSymbols;
      return super.getSliderVariables(n, r).filter((i) => s.indexOf(i) === -1);
    }
  };
  var Wa = class extends Yt {
    constructor(t, n, r, s, i) {
      super(),
        this.parameters = t,
        this.residuals = n,
        this.statistics = r,
        this.model = s,
        this.isModelValid = i.isModelValid,
        this.residualVariable = i.residualVariable,
        this.residualSuggestionId = i.residualSuggestionId,
        this.shouldSuggestLogMode = i.shouldSuggestLogMode,
        this.isLinear = i.isLinear,
        this.parameterWarning = i.parameterWarning,
        this.displayPrecision = i.displayPrecision,
        this._exports = [this.residualVariable];
      for (let o of We(t)) this._exports.push(o);
      this.mergeDependencies(s);
    }
    getCompiledFunction() {
      return this.model.getCompiledFunction.apply(this.model, arguments);
    }
    getCompiledDerivative() {
      return this.model.getCompiledDerivative.apply(this.model, arguments);
    }
  };
  function Af(e) {
    return e.type === "FunctionDefinition";
  }
  function Qv(e) {
    return e.type === "FunctionCall";
  }
  function ki(e) {
    return e.type === "Identifier";
  }
  function Hi(e) {
    return e.type === "Table";
  }
  function _f(e) {
    return e.type === "Image";
  }
  function Kr(e) {
    return e.type === "Error";
  }
  function ui(e) {
    return e.type === "Regression";
  }
  function ga(e) {
    return e.type === "TableColumn";
  }
  function ha(e) {
    return e.type === "TableColumnValue";
  }
  var Pp = class extends Yt {
    constructor(n, r) {
      super();
      this.isRegression = true;
      this.tableRegressionData = void 0;
      this._lhs = n,
        this.isLhsSimple = n instanceof we,
        this._logLhs = new gn("ln", [n]),
        this._rhs = r,
        this._difference = new Es([n, r]),
        this._logDifference = new Es([new gn("ln", [n]), new gn("ln", [r])]),
        this.mergeDependencies(n, r);
    }
    getExportsFromConcrete(n, r) {
      if (Kr(r)) return [];
      let s = [];
      for (let i of We(r.parameters)) n.assignmentForbidden(i) || s.push(i);
      return n.assignmentForbidden(r.residualVariable) ||
        s.push(r.residualVariable),
        s;
    }
    exportTo(n, r, s) {
      if (r.isError) return [];
      if (!(r instanceof Wa)) {
        throw U(`Expected optimized regression but got ${r.type}.`);
      }
      let i = [];
      for (let o of We(r.parameters)) {
        n.assignmentForbidden(o) ||
          (i.push(o), s[o] = s[o] ? Wl(o) : r.parameters[o]);
      }
      return n.assignmentForbidden(r.residualVariable)
        ? []
        : (s[r.residualVariable] = r.residuals, i.push(r.residualVariable), i);
    }
    getSliderVariables() {
      return [];
    }
    analyzeRegression(n, r, s, i, o) {
      throw U(`Node ${this.type} does not define analyzeRegression.`);
    }
  };
  var co = class extends Yt {
    constructor(n, r, s, i) {
      super();
      this.tableID = s;
      this.columnIndex = i;
      this.headerDependencies = new Set();
      this.cellDependencies = new Set();
      this.header = n,
        this.values = r,
        this.registerDependencies(),
        this._exports = this.computeExports(),
        this.localFrameID = s;
    }
    registerDependencies() {
      this.mergeDependencies(this.header),
        this.mergeDependencies.apply(this, this.values);
      for (let n of this.header.getDependencies()) {
        this.headerDependencies.add(n);
      }
      for (let n of this.header.getOptionalDependencies()) {
        this.headerDependencies.add(n);
      }
      for (let n of this.values) {
        for (let r of n.getDependencies()) this.cellDependencies.add(r);
        for (let r of n.getOptionalDependencies()) this.cellDependencies.add(r);
      }
    }
    computeExports() {
      return this.header instanceof we ? [this.header._symbol] : [];
    }
    _exportSymbolsTo(n, r, s) {
      if (n.length === 0) return;
      let i = this.getExportValue(r, s);
      this.header instanceof we && !this.isFreeVariable(s) &&
        (n = n.filter((o) => o !== this.header._symbol));
      for (let o of n) s.hasOwnProperty(o) || (s[o] = i);
    }
    getExportValue(n, r) {
      return this.isFreeVariable(r) || n.blocksExport ? n : this.header;
    }
    isFreeVariable(n) {
      return this.header instanceof we &&
        GD(n).definitionLevel[this.header._symbol] === 1;
    }
    exportTo(n, r, s) {
      let i = this.getLegalExports(n);
      return this._exportSymbolsTo(i, r, s), i;
    }
    exportToLocal(n, r, s) {
      this._exportSymbolsTo(this.getExports(n), r, s);
    }
  };
  function mk(e) {
    return e instanceof Qr ? { type: 2 } : Af(e)
      ? {
        type: 1,
        rhsDependencies: e._expression.getDependencies(),
        fnSymbol: e._symbol,
      }
      : { type: 0 };
  }
  function yk(e, t, n, r) {
    var s;
    if (t instanceof Pp) {
      let i = r == null ? void 0 : r.get(n);
      if (i) {
        return {
          exports: i,
          dependencies: {
            type: "simple",
            localFrameID: void 0,
            dependencies: [],
          },
        };
      }
    }
    if (t instanceof co) {
      let i = t.header instanceof we ? t.header._symbol : void 0;
      return {
        exports: t.getLegalExports(e),
        dependencies: {
          type: "table-column",
          localFrameID: t.localFrameID,
          headerIdent: i,
          headerDependencies: t.headerDependencies,
          cellDependencies: t.cellDependencies,
        },
      };
    }
    return {
      exports: t.getLegalExports(e),
      dependencies: {
        type: "simple",
        localFrameID: ui(t)
          ? (s = t.tableRegressionData) == null ? void 0 : s.tableId
          : t.localFrameID,
        dependencies: t.getDependencies(),
      },
    };
  }
  function gk(e, t) {
    if (t.localFrameID !== void 0) {
      return { frameID: t.localFrameID, exports: t.getExports(e) };
    }
  }
  function Lf(e, t, n, r) {
    let s = hk(e, t, r), i = xk(s);
    return Ik(e, s, i, n);
  }
  function hk(e, t, n) {
    let r = {};
    for (let s of Object.keys(t)) {
      let i = t[s],
        { exports: o, dependencies: a } = yk(e, i, s, n),
        u = gk(e, i);
      r[s] = { meta: mk(i), exports: o, dependencies: a, local: u };
    }
    return r;
  }
  function d0(e, t, n) {
    var r, s, i, o;
    (s = (r = e.assignments)[t]) != null || (r[t] = []),
      e.assignments[t].push(n),
      e.assignments[t].length > 1 && (e.multiplyDefined[t] = true),
      (o = (i = e.exports)[n]) != null || (i[n] = []),
      e.exports[n].push(t);
  }
  function bk(e, t) {
    let n = e.get(t),
      r = n != null ? n : { assignments: {}, multiplyDefined: {}, exports: {} };
    return n || e.set(t, r), r;
  }
  function xk(e) {
    let t = new Map(),
      n = {},
      r = { assignments: {}, exports: {}, multiplyDefined: {} };
    for (let s of We(e)) {
      let i = e[s];
      if (i.local === void 0) {
        for (let o of i.exports) tt[o] || (n[o] = 0, d0(r, o, s));
      }
    }
    for (let s of We(e)) {
      let i = e[s];
      if (i.local === void 0) continue;
      for (let a of i.exports) tt[a] || n[a] !== 0 && (n[a] = 1, d0(r, a, s));
      let o = bk(t, i.local.frameID);
      for (let a of i.local.exports) {
        tt[a] || n[a] !== 0 && (n[a] = 1, d0(o, a, s));
      }
    }
    return {
      exports: r.exports,
      assignments: r.assignments,
      definitionLevel: n,
      multiplyDefined: r.multiplyDefined,
      localAssignments: t,
    };
  }
  function Tk(e, t, n) {
    var r, s;
    if (t !== void 0) {
      let i = (r = e.localAssignments.get(t)) == null
        ? void 0
        : r.assignments[n];
      if (i) return i;
    }
    return (s = e.assignments[n]) != null ? s : [];
  }
  function Kv(e, t) {
    var n;
    return (n = e.multiplyDefined[t]) != null ? n : false;
  }
  function Ik(e, t, n, r) {
    let s = [],
      i = new Set(),
      o = {},
      a = new Set(),
      u = {},
      c = 0,
      l = [],
      p = [];
    for (let g of r) u.hasOwnProperty(g) || f(g);
    function f(g) {
      u[g] = u[g] || {};
      let m = u[g], h;
      m.id = g, m.index = c, m.lowlink = c, l.push(m), m.instack = true, c++;
      let x = t[g], T;
      x.dependencies.type === "simple"
        ? T = x.dependencies.dependencies
        : !x.dependencies.headerIdent ||
            n.definitionLevel[x.dependencies.headerIdent] === 0
        ? T = x.dependencies.headerDependencies
        : T = x.dependencies.cellDependencies;
      for (let b of T) {
        let M = x.dependencies.localFrameID, P = Tk(n, M, b);
        for (let D of P) {
          u.hasOwnProperty(D)
            ? (h = u[D],
              h.instack && (m.lowlink = Math.min(m.lowlink, h.index)))
            : (f(D), h = u[D], m.lowlink = Math.min(m.lowlink, h.lowlink));
        }
      }
      if (m.lowlink === m.index) {
        if (h = l.pop(), h.instack = false, h === m) d(m.id);
        else {
          let b = [h.id];
          for (; h = l.pop(), h.instack = false, b.push(h.id), h !== m;);
          y(b);
        }
      }
    }
    function d(g) {
      p.push(g);
      let m = t[g];
      if (m.meta.type === 1) {
        let h = m.meta.fnSymbol;
        !e.assignmentForbidden(h) && m.meta.rhsDependencies.includes(h) &&
          !Kv(n, h) && (o[g] = [g], a.add(h));
      }
    }
    function y(g) {
      var b;
      let m = [], h = true, x = [], T = new Set();
      for (let M = g.length - 1; M >= 0; M--) {
        let P = g[M], D = t[P];
        for (let S of D.exports) {
          m.push({
            symbol: S,
            localFrameID: (b = D.local) == null ? void 0 : b.frameID,
          });
        }
        T.add(P),
          p.push(P),
          D.meta.type === 1 && !Kv(n, D.meta.fnSymbol) ? x.push(P) : h = false,
          D.meta.type === 2 && i.add(P);
      }
      if (h) {
        for (let M of [...T]) o[M] = x;
        for (let { symbol: M } of m) a.add(M);
      }
      s.push(m);
    }
    return {
      resolved: p,
      exports: n.exports,
      assignments: n.assignments,
      definitionLevel: n.definitionLevel,
      multiplyDefined: n.multiplyDefined,
      cycles: s,
      recursiveFunctionGroups: o,
      recursiveFunctionSymbols: a,
      recursiveFunctionBaseCasesWithCycles: i,
      localDependencyOrder: n.localAssignments,
    };
  }
  function eO(e) {
    let t = function (...r) {
      return new e(...r);
    };
    t.prototype = e.prototype;
    let n = Object.getOwnPropertyNames(e);
    for (let r of n) {
      let s = e[r];
      if (typeof s == "function") {
        try {
          t[r] = s;
        } catch (i) {}
      }
    }
    return t;
  }
  var Ep = class extends Q {};
  var Fg = class extends we {};
  var ja = class extends Yt {
    constructor(t, n) {
      super(),
        t instanceof we ? this._symbol = t._symbol : this._symbol = t,
        this.mergeDependencies(n),
        this._expression = n,
        this._exports = this.computeExports();
    }
    shouldExportAns() {
      return true;
    }
    computeExports() {
      let t = this._symbol, n = this.getDependencies();
      for (let r = 0; r < n.length; r++) if (n[r] === t) return [];
      return [t];
    }
    isEquation(t, n) {
      let r = this._symbol,
        s = r === "x" || r === "y",
        i = r === "r" || r === "z",
        o = r === "rho",
        a = n.getDependencies(),
        u = this.graphmodeDependencies(t, n);
      return o || i || s && a.includes("z") ? u.includes(r) : a.includes(r);
    }
    asEquation() {
      let t = new Nu(new we(this._symbol), this._expression);
      return t.userData = this.userData, t.metaData = this.metaData, t;
    }
    shouldPromoteToSlider(t) {
      if (!this._expression.isConstant || this._expression.is_mixed_number) {
        return false;
      }
      let n = this._expression.asValue();
      return typeof n != "number" || !isFinite(n)
        ? false
        : t.isValidSlider(this._symbol);
    }
  };
  var Mp = class extends Q {
    constructor(t) {
      super(t), this._symbol = t[0]._symbol, this._lhs = t[0], this._rhs = t[1];
    }
  };
  var Ru = class extends Q {};
  var Cp = class extends Q {
    constructor(t) {
      super(t), this._symbol = "boxplot";
    }
  };
  var Fr = class extends Q {};
  function Pk(e, t) {
    let n = Jr[e[0]].direction === -1
      ? new Es([t[1], t[0]])
      : new Es([t[0], t[1]]);
    switch (e.length) {
      case 0:
        throw new Error(
          "Programming Error: ComparatorChain must have at least one comparator",
        );
      case 1:
        return n;
      case 2:
        return new Fr([new ps[e[1]](t.slice(1)), n, new Et(NaN)]);
      default:
        return new Fr([new Au(e.slice(1), t.slice(1)), n, new Et(NaN)]);
    }
  }
  var Au = class extends Q {
    constructor(n, r) {
      super(r);
      this.symbols = n;
      if (n.length < 1) {
        throw "Programming Error: ComparatorChain must have at least one comparator.";
      }
      if (r.length !== n.length + 1) {
        throw "Programming Error: ComparatorChain must have one more arg than symbols";
      }
      if (n.includes("=") && !n.every((s) => s === "=")) throw qx();
      this._difference = Pk(n, r);
    }
    isInequality() {
      return !this.symbols.includes("=");
    }
  };
  var rl = class extends Q {
    constructor(n) {
      let r = n.map((s) => new we("\\idref_{" + s + "}"));
      super(r);
      this.constructedObjectIds = n;
      this._exports.push("construction");
    }
  };
  var Dp = class extends Q {};
  var sl = class extends Q {
    constructor(t, n) {
      super(n),
        t instanceof we
          ? this._symbol = t._symbol
          : this._symbol = new we(t)._symbol,
        this.addDependency(this._symbol);
    }
  };
  var Sp = class extends Q {};
  var Ms = class extends Q {
    registerDependencies() {
      if (super.registerDependencies(), this.args[1].type === "Identifier") {
        let t = this.args[1]._symbol;
        Ou(t) && this.addDependency("trigAngleMultiplier");
      }
    }
  };
  var _u = class extends Q {};
  var vp = class extends Q {
    constructor(t) {
      super(t), this._symbol = "dotplot";
    }
  };
  var Vg = class extends Yt {
    constructor(t) {
      super();
      let [n, r, s, i, o] = t;
      this.args = t,
        this._symbol = s._symbol,
        this._operators = [r, i],
        this._expressions = [n, o];
      let a = nl(Jr[r].inclusive && Jr[t[3]].inclusive, Jr[t[1]].direction);
      this._indicator = new ps[a]([t[0], t[4]]),
        this.addDependency(this._symbol),
        this.mergeDependencies(this._expressions[0], this._expressions[1]);
    }
    isInequality() {
      return true;
    }
    isShadeBetween() {
      return true;
    }
  };
  var Lu = class extends Q {};
  var il = class extends Q {
    constructor(t, n) {
      super(n), this.seed = n[0], this.userSeed = n[1], this.tag = t;
    }
    asValue() {
      return this.seed.asValue() + "::" + this.tag + this.userSeed.asValue();
    }
  };
  var wu = class extends Q {
    registerDependencies() {
      if (super.registerDependencies(), this.args[0].type === "Identifier") {
        let t = this.args[0]._symbol;
        Ou(t) && this.addDependency("trigAngleMultiplier");
      }
    }
  };
  var Fu = class extends Q {
    registerDependencies() {
      if (
        this.addDependency("factorial"),
          super.registerDependencies(),
          this.args[0].type === "Identifier"
      ) {
        let t = this.args[0]._symbol;
        Ou(t) && this.addDependency("trigAngleMultiplier");
      }
    }
  };
  var Op = class extends Q {
    constructor(t) {
      super(t), this._symbol = "histogram";
    }
  };
  var Bg = class extends Yt {
    constructor(n, r) {
      super();
      this.isImage = true;
      this.center = n.center,
        this.radianAngle = n.radianAngle,
        this.width = n.width,
        this.height = n.height,
        this.opacity = n.opacity,
        this.moveStrategy = r,
        this.mergeDependencies(
          this.center,
          this.radianAngle,
          this.width,
          this.height,
          this.opacity,
        );
    }
  };
  var Np = class extends Q {
    constructor(t) {
      super(t), this._symbol = "ittest";
    }
  };
  var Rp = class extends Q {
    constructor(t) {
      super(t, { skipRegisterDependencies: true }),
        this._differential = t[0],
        this.registerDependencies();
    }
    registerDependencies() {
      for (let t = 1; t <= 3; t++) {
        this.mergeDependenciesInScope(
          this.type,
          [this._differential._symbol],
          this.args[t],
        );
      }
    }
  };
  function hn(e, t) {
    let n = e.getInstruction(t);
    switch (n.type) {
      case 1:
        return Vo(n.value);
      default:
        throw new Error(`Unexpected opcode ${n.type}.`);
    }
  }
  function Vo(e) {
    if (Array.isArray(e)) return e.map(Vo);
    switch (typeof e) {
      case "boolean":
      case "number":
      case "string":
        return e;
      case "object":
        if (gu(e)) {
          let t = {};
          for (let n of We(e.updateRules)) {
            let r = e.updateRules[n];
            t[n] = { value: Vo(r.value), valueType: r.valueType };
          }
          return { type: "Action", updateRules: t };
        } else return V(e);
      default:
        throw new Error("Unexpected value: " + e);
    }
  }
  function ge(e) {
    return e.type <= 4;
  }
  function tO(e) {
    return !ge(e);
  }
  function es(e) {
    switch (e.type) {
      case 21:
      case 23:
      case 19:
      case 50:
      case 53:
        return true;
      default:
        return false;
    }
  }
  function ds(e) {
    switch (e.type) {
      case 20:
      case 22:
      case 24:
      case 51:
      case 54:
        return true;
      default:
        return false;
    }
  }
  function Gg(e) {
    switch (e.type) {
      case 20:
      case 22:
      case 24:
      case 51:
        return true;
      default:
        return false;
    }
  }
  function Vr(e, t) {
    let n = new Array(t);
    for (let s = 0; s < t; s++) n[s] = false;
    n[t] = true;
    let r = t;
    for (; r > 0;) {
      r = 0;
      for (let s = t; s >= 0; s--) {
        if (!n[s]) continue;
        let i = e.getInstruction(s);
        if (!ge(i)) {
          for (
            let o of e.getDirectDependencies(i)
          ) o > s && !n[o] && o > r && (r = o), n[o] = true;
        }
      }
    }
    return n;
  }
  function nO(e, t) {
    let n = new Array(t);
    for (let s = 0; s < t; s++) n[s] = false;
    n[t] = true;
    let r = t;
    for (; r > 0;) {
      r = 0;
      for (let s = t; s >= 0; s--) {
        if (!n[s]) continue;
        let i = e.getInstruction(s);
        if (!ge(i)) {
          if (i.type === 33) n[i.args[1]] = true, n[i.args[2]] = true;
          else {for (
              let o of e.getDirectDependencies(i)
            ) o > s && !n[o] && (r = o), n[o] = true;}
        }
      }
    }
    return n;
  }
  function fs(e, t) {
    var s;
    let n = [], r = [];
    for (let i = 0; i < t; i++) r.push(false);
    r.push(true);
    for (let i = t; i >= 0; i--) {
      if (!r[i]) continue;
      let o = e.getInstruction(i);
      if (o.type === 2) n.push({ symbol: e.argNames[i], scope: "free" });
      else if (es(o)) {
        switch (o.type) {
          case 21:
            n.push({ symbol: o.callData.indexSymbol, scope: "integral" });
            break;
          case 19:
            n.push({ symbol: o.callData.indexSymbol, scope: o.callData.type });
            break;
          case 23:
            if (
              ((s = o.context) == null ? void 0 : s.type) ===
                "list-comprehension"
            ) {
              for (let u of o.context.callData.inputListSymbols) {
                n.push({ symbol: u, scope: "comprehension" });
              }
            }
            break;
          case 50:
            for (let u of o.callData.parameterSymbols) {
              n.push({ symbol: u, scope: "map" });
            }
            break;
          case 53: {
            let u = e.getInstruction(o.args[0]);
            for (let c of u.parameterSymbols) {
              n.push({ symbol: c, scope: "recursive-function" });
            }
            break;
          }
          default:
            let a = o;
            throw new Error(
              `Programming Error: unexpected loop instruction ${a.type}`,
            );
        }
      } else {o.type === 3 && o.symbol &&
          n.push({ symbol: o.symbol, scope: "symbolic-var" });}
      if (!ge(o)) { for (let a of e.getDirectDependencies(o)) r[a] = true; }
    }
    return n.reverse();
  }
  function Vu(e, t) {
    return ol(e, [t], 0, e.instructionsLength() - 1);
  }
  function ol(e, t, n, r) {
    let s = [];
    for (let o = n; o <= r; o++) s[o] = false;
    for (let o of t) s[o] = true;
    let i = Math.min(...t);
    for (let o = 0; o <= 1; o++) {
      let a = false;
      for (let u = i + 1; u < e.instructionsLength(); u++) {
        let c = e.getInstruction(u);
        if (ge(c) || s[u]) continue;
        let l = false;
        for (let p of e.getDirectDependencies(c)) {
          if (s[p]) {
            l = true;
            break;
          }
        }
        if (s[u] = l, l && c.type === 20 && !s[c.args[0]]) {
          let p = c.args[0], f = c.args.length - 1;
          for (let d = 0; d < f; d++) {
            let y = c.args[1 + d], g = p + 1 + d;
            s[y] && (s[g] = true, a = true);
          }
        }
      }
      if (!a) break;
    }
    return s;
  }
  function rO(e) {
    if (e.isConstant()) return;
    let t = [];
    for (let i = 0; i < e.getReturnIndex(); i++) {
      e.getInstruction(i).type === 44 && t.push(i);
    }
    if (t.length === 0) return;
    let n = Vr(e, e.getReturnIndex()), r = [];
    for (let i = 0; i < e.argNames.length; i++) n[i] && r.push(i);
    let s = ol(e, r, 0, e.getReturnIndex());
    for (let i of t) if (n[i] && s[i]) throw PP(fs(e, i));
  }
  function ms(e) {
    if (!Bo(e)) {
      throw new Error(
        "Programming error: expected an array but found " + typeof e,
      );
    }
  }
  function Bo(e) {
    return Array.isArray(e);
  }
  function sO(e) {
    if (Bo(e)) { for (let { compiled: t } of e) t && f0(t); }
  }
  function $Z(e) {
    if (Bo(e)) { for (let { compiled: t } of e) t && Mk(t); }
  }
  function f0(e) {
    delete e.fn;
  }
  function Mk(e) {
    e.fn = wf(e.args, e.source, e.constants, e.executionMetadata);
  }
  function wf(e, t, n, r) {
    let i = `var fn = (function(${e.join(",")}){"use strict"; ${t}});
fn.__meta = __meta;
return fn;
`;
    return new Function("BuiltIn", "ErrorMsg", "_C", "__meta", i)(Gi, Ht, n, r);
  }
  function oO(e, t, n) {
    let r = "",
      s = (e.instructionsLength() - 1).toString().length,
      i = 0,
      o = false,
      a = Vr(e, t);
    for (let u = 0; u < e.instructionsLength(); u++) {
      let c = e.getInstruction(u), l = n.comments[u] || "";
      if (
        ds(c) && (i -= 1),
          !a[u] && !n.printUnreferencedInstructions || c.type === 0
      ) {
        o || (r += `${iO(u, s)}: ${g0(2 * i)}...
`), o = true;
      } else {
        o = false;
        let p = `${iO(u, s)}: ${g0(2 * i)}${al(e, u)}`;
        l && (p += " ".repeat(Math.max(0, 36 - p.length)), p += `	# ${l}`),
          r += p + `
`;
      }
      es(c) && (i += 1);
    }
    return r;
  }
  function al(e, t) {
    let n = e.getInstruction(t);
    switch (n.type) {
      case 0:
        return ts(n.type);
      case 2:
        return `${ts(n.type)} ${at(n.valueType)} ${e.argNames[t]}`;
      case 3:
        return `${ts(n.type)} ${at(n.valueType)}`;
      case 1:
        return `${ts(n.type)} ${at(n.valueType)} ${y0(n.value)}`;
      case 37:
      case 42:
        return `${ts(n.type)} ${at(n.valueType)} ${n.symbol} ${
          n.args.join(" ")
        }`;
      case 44:
        return `${ts(n.type)} ${at(n.valueType)} ${n.tag} ${n.args.join(" ")}`;
      case 48:
        return `${ts(n.type)} ${at(n.valueType)} ${n.args.join(" ")}`;
      case 16:
        return `${ts(n.type)} ${at(n.valueType)} (${n.index}) ${
          n.args.join(" ")
        }`;
      case 50:
        return `${ts(n.type)} ${at(n.valueType)} ${n.args.join(" ")} (${
          n.callData.parameterSymbols.join(",")
        })`;
      case 4: {
        let s = n.signature.argTypes.map((i) => at(i)).join(", ");
        return `${ts(n.type)} ${at(n.valueType)} ${n.symbol}(${s}) [group ${
          n.recursionGroup.join(" ")
        }]`;
      }
      case 8:
      case 9:
      case 10:
      case 11:
      case 13:
      case 12:
      case 14:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 32:
      case 31:
      case 33:
      case 38:
      case 39:
      case 40:
      case 41:
      case 47:
      case 49:
      case 51:
      case 53:
      case 54:
      case 55:
      case 15:
        return `${ts(n.type)} ${at(n.valueType)} ${n.args.join(" ")}`;
      default:
        let r = n;
        throw new Error(`Unexpected opcode ${r.type}`);
    }
  }
  function ts(e) {
    switch (e) {
      case 0:
        return "Noop";
      case 1:
        return "Constant";
      case 8:
        return "Add";
      case 9:
        return "Subtract";
      case 10:
        return "Multiply";
      case 11:
        return "Divide";
      case 12:
        return "Exponent";
      case 13:
        return "RawExponent";
      case 14:
        return "Negative";
      case 19:
        return "BeginLoop";
      case 20:
        return "EndLoop";
      case 21:
        return "BeginIntegral";
      case 22:
        return "EndIntegral";
      case 23:
        return "BeginBroadcast";
      case 24:
        return "EndBroadcast";
      case 25:
        return "Equal";
      case 26:
        return "Less";
      case 27:
        return "Greater";
      case 28:
        return "LessEqual";
      case 29:
        return "GreaterEqual";
      case 31:
        return "Or";
      case 32:
        return "And";
      case 33:
        return "Piecewise";
      case 38:
        return "List";
      case 39:
        return "ListAccess";
      case 40:
        return "DeferredListAccess";
      case 41:
        return "InboundsListAccess";
      case 37:
        return "NativeFunction";
      case 42:
        return "Distribution";
      case 2:
        return "LoadArg";
      case 47:
        return "BlockVar";
      case 48:
        return "BroadcastResult";
      case 3:
        return "SymbolicVar";
      case 44:
        return "ExtendSeed";
      case 49:
        return "Action";
      case 50:
        return "BeginMap";
      case 51:
        return "EndMap";
      case 4:
        return "FunctionHeader";
      case 53:
        return "BeginFunction";
      case 54:
        return "EndFunction";
      case 55:
        return "FunctionCall";
      case 15:
        return "Tuple";
      case 16:
        return "Slot";
      default:
        let t = e;
        throw new Error(`Unexpected opcode ${t.type}`);
    }
  }
  function y0(e) {
    if (Array.isArray(e)) return `[${e.map(y0).join(",")}]`;
    switch (typeof e) {
      case "string":
        return e;
      case "boolean":
      case "number":
        return e.toString();
      case "object":
        if (gu(e)) {
          let t = [];
          for (let n of We(e.updateRules)) {
            t.push(`"${n}": ${y0(e.updateRules[n].value)}`);
          }
          return `{${t.join(", ")}}`;
        } else return `${e.n}/${e.d}`;
      default:
        throw new Error("Unexpected value: " + e);
    }
  }
  function iO(e, t) {
    let n = e.toString();
    return g0(t - n.length) + n;
  }
  function g0(e) {
    let t = "";
    for (let n = 0; n < e; n++) t += " ";
    return t;
  }
  function fn(e) {
    return `_${e}`;
  }
  function Ap(e) {
    return `_${e}_thunk_computed`;
  }
  function _p(e) {
    return `_${e}_thunk_function`;
  }
  function kg(e) {
    return `_${e}_next`;
  }
  function aO(e) {
    return `_${e}_next1`;
  }
  function h0(e, t) {
    return `_${e}_${t}`;
  }
  function b0(e) {
    return `_${e}_inner`;
  }
  function uO(e) {
    return `_${e}_cache`;
  }
  function cO(e) {
    return `_${e}_key`;
  }
  function Hg(e) {
    return `_${e}_computationMetrics`;
  }
  function lO(e) {
    return `_${e}_out`;
  }
  function pO(e) {
    return `_${e}_computationMetrics`;
  }
  function dO(e) {
    return `_${e}_cacheEntry`;
  }
  function fO(e) {
    return `_${e}_args`;
  }
  function Ff(e, t) {
    return `_${e}_prev_${t}`;
  }
  function mO(e) {
    return `_${e}_computationDepth`;
  }
  function yO(e) {
    return `_${e}_computationCount`;
  }
  function Je(e) {
    return e.type === 1;
  }
  function gO(e) {
    if (!Je(e)) {
      throw new Error(
        `Programming error: expected constant instruction but found ${
          ts(e.type)
        } instead.`,
      );
    }
  }
  var T0 = class {
    constructor(t, n) {
      this.chunk = t;
      this.recursiveFunctionGroup = n;
      this.referencesFrom = {};
      this.referencesTo = {};
      this.baseCases = {};
      for (let c of Object.values(n)) {
        this.referencesFrom[c] = [],
          this.referencesTo[c] = [],
          this.baseCases[c] = [];
      }
      let {
        dependsOnRecursiveCall: r,
        iterationParameterIndex: s,
        recursiveReferences: i,
      } = vk(this.chunk, this.recursiveFunctionGroup);
      for (let c of i) {
        this.referencesFrom[c.from].push(c), this.referencesTo[c.to].push(c);
      }
      this.iterationParameterIndex = s;
      let {
        baseCases: o,
        isEveryBranchRecursiveOrBaseCase: a,
        isUnconditionallyRecursive: u,
      } = Sk(t, n, r, s);
      this.isEveryBranchRecursiveOrBaseCase = a,
        this.isUnconditionallyRecursive = u;
      for (let c of o) this.baseCases[c.fn].push(c);
    }
    hasRecursiveReferences() {
      for (let t of Object.values(this.referencesFrom)) {
        if (t.length > 0) return true;
      }
      return false;
    }
    getBaseCasesForFunction(t) {
      return this.baseCases[t];
    }
    getReferencesFrom(t) {
      return this.referencesFrom[t];
    }
    getReferencesTo(t) {
      return this.referencesTo[t];
    }
    getAllReferences() {
      let t = [];
      for (let n of Object.values(this.referencesFrom)) t.push(...n);
      return t;
    }
  };
  function Dk(e, t, n) {
    if (t === void 0) return;
    let r = e.getInstruction(n), s = e.getInstruction(r.args[0]);
    if (s.type !== 25) return;
    let [i, o] = s.args, a;
    if (i === t) a = o;
    else if (o === t) a = i;
    else return;
    let u = e.getInstruction(a);
    if (Je(u) && u.valueType === Number) return u.value;
  }
  function Sk(e, t, n, r) {
    let s = [], i = true, o = true;
    for (let a in t) {
      let u = t[a],
        l = e.getInstruction(u).endIndex,
        f = e.getInstruction(l).args[0],
        d = r !== void 0 ? f + r + 1 : void 0,
        y = { [l]: true };
      for (let g = l; g > f; g--) {
        if (!y[g]) continue;
        let m = e.getInstruction(g);
        if (!ge(m)) {
          if (m.type === 33) {
            let h = m.args[1], x = m.args[2];
            if (!n[h] || !n[x]) {
              i = false;
              let b = Dk(e, d, g);
              b !== void 0 && !n[h]
                ? s.push({ fn: u, argValue: b })
                : o = false;
            }
          }
          for (let h of m.args) y[h] = true;
        }
      }
    }
    return s.sort((a, u) => V(a.argValue) - V(u.argValue)), {
      baseCases: s,
      isUnconditionallyRecursive: i,
      isEveryBranchRecursiveOrBaseCase: o,
    };
  }
  var x0 = Symbol("NON_ITERATIVE");
  function vk(e, t) {
    let n = new Set(Object.values(t)), r = {}, s = [], i;
    for (let o in t) {
      let a = t[o],
        c = e.getInstruction(a).endIndex,
        p = e.getInstruction(c).args[0],
        f = Vr(e, c);
      for (let d = p; d < c; d++) {
        let y = e.getInstruction(d);
        if (!ge(y) && f[d]) {
          if (y.type === 55 && n.has(y.args[0])) {
            r[d] = true;
            let g = I0(e, p, y);
            g
              ? (g.iterationParameterIndex !== void 0 &&
                (i !== void 0 && i !== g.iterationParameterIndex
                  ? i = x0
                  : i = g.iterationParameterIndex),
                s.push(g.ref))
              : i = x0;
          }
          for (let g of e.getDirectDependencies(y)) {
            if (r[g]) {
              r[d] = true;
              break;
            }
          }
        }
      }
    }
    return i === void 0 && Object.values(t).every((o) =>
      e.getInstruction(o).signature.argTypes.length === 1
    ) && (i = 0),
      {
        dependsOnRecursiveCall: r,
        iterationParameterIndex: i === x0 ? void 0 : i,
        recursiveReferences: s,
      };
  }
  function I0(e, t, n) {
    let r = e.getInstruction(t), s, i;
    for (let o = 1; o < n.args.length; o++) {
      let a = n.args[o], u = e.getInstruction(a), c, l;
      if (u.type === 9 && s === void 0) {
        let d = e.getInstruction(u.args[1]);
        if (!(d.type === 1 && d.valueType === Number)) return;
        l = V(d.value), c = u.args[0];
      } else l = 0, c = a;
      let p = e.getInstruction(c);
      if (
        !(p.type === 47 && p.args[0] === t && o === c - t) ||
        l !== Math.floor(l) || l < 0
      ) return;
      if (s === void 0) i = l, l !== 0 && (s = o - 1);
      else if (l !== 0) return;
    }
    if (i !== void 0) {
      return {
        ref: { from: r.args[0], to: n.args[0], iterationParameterOffset: i },
        iterationParameterIndex: s,
      };
    }
  }
  function hO(e, t) {
    var c, l;
    let n = new T0(e, t), r = {};
    for (let p in n.recursiveFunctionGroup) {
      let f = n.recursiveFunctionGroup[p], d = n.getBaseCasesForFunction(f);
      if (d.length === 0) continue;
      let y = V(d[0].argValue), g = 1;
      for (; g < d.length && V(d[g].argValue) === V(d[g - 1].argValue) + 1;) {
        g++;
      }
      let m = d.slice(g).map((h) => V(h.argValue));
      r[p] = { min: y, consecutiveCount: g, additional: m };
    }
    let s = {}, i = -1 / 0, o = 1 / 0;
    if (
      n.iterationParameterIndex !== void 0 && n.isEveryBranchRecursiveOrBaseCase
    ) {
      let p = new Map();
      for (let f of Object.values(n.recursiveFunctionGroup)) {
        let d = e.getInstruction(f).symbol, y = -1 / 0;
        for (let g of n.getReferencesTo(f)) {
          y = Math.max(y, g.iterationParameterOffset);
        }
        if (isFinite(y) && (s[d] = y), y > 0) {
          let g = r[e.getInstruction(f).symbol],
            m = (c = g == null ? void 0 : g.min) != null ? c : -1 / 0;
          p.set(f, {
            min: m + y,
            max: m +
              ((l = g == null ? void 0 : g.consecutiveCount) != null ? l : 0),
          });
        }
      }
      for (let { min: f, max: d } of p.values()) {
        i = Math.max(i, f), o = Math.min(o, d);
      }
    }
    let a = {};
    for (let p in n.recursiveFunctionGroup) {
      let f = n.recursiveFunctionGroup[p], d = e.getInstruction(f);
      a[p] = d.parameterSymbols;
    }
    let u = {};
    for (let p in n.recursiveFunctionGroup) {
      let f = n.recursiveFunctionGroup[p], d = e.getInstruction(f);
      u[p] = d.signature.argTypes.map((y, g) =>
        g === n.iterationParameterIndex && n.isEveryBranchRecursiveOrBaseCase &&
          !n.isUnconditionallyRecursive
          ? 1
          : 0
      );
    }
    if (n.iterationParameterIndex !== void 0 && isFinite(i) && i <= o) {
      let p = Ok(n);
      return {
        canIterate: true,
        parameterSymbols: a,
        baseCaseInfo: r,
        maxRecursiveCallOffsets: s,
        iterationParameterIndex: n.iterationParameterIndex,
        domainInfo: u,
        loopStart: i,
        order: p,
      };
    } else {return {
        canIterate: false,
        parameterSymbols: a,
        baseCaseInfo: r,
        maxRecursiveCallOffsets: s,
        iterationParameterIndex: n.iterationParameterIndex,
        domainInfo: u,
      };}
  }
  function Ok(e) {
    if (e.iterationParameterIndex === void 0) {
      throw U("Programming error: no recursive parameter");
    }
    let n = Object.values(e.recursiveFunctionGroup),
      r = new Map(),
      s = new Map(),
      i = (u) => {
        let c = new Set();
        for (let l of e.getReferencesTo(u)) {
          l.iterationParameterOffset === 0 && c.add(l.from);
        }
        return [...c];
      };
    n.forEach((u) => {
      let c = i(u);
      r.set(u, c);
      for (let l of c) s.set(l, (s.get(l) || 0) + 1);
      s.has(u) || s.set(u, 0);
    });
    let o = [];
    s.forEach((u, c) => {
      u === 0 && o.push(c);
    });
    let a = [];
    for (; o.length > 0;) {
      let u = o.shift();
      a.push(u),
        (r.get(u) || []).forEach((l) => {
          let p = l, f = s.get(p) - 1;
          s.set(p, f), f === 0 && o.push(p);
        });
    }
    if (a.length !== n.length) throw Nx();
    return a;
  }
  function zg(e, t) {
    let n;
    for (let o = t, a = 0; o > 0; o--) {
      let u = e.getInstruction(o);
      if (u.type === 53 && a === 0) {
        n = o;
        break;
      }
      u.type === 54 && a++, u.type === 53 && a--;
    }
    if (n === void 0) return false;
    let r = e.getInstruction(t),
      s = e.getInstruction(r.args[0]),
      i = e.getInstruction(n).args[0];
    return s.recursionGroup.includes(i);
  }
  function Ug(e) {
    for (let t = 0; t < e.argCoeffs.length; t++) {
      if (V(e.argCoeffs[t]) !== 0) return false;
    }
    return true;
  }
  var qg = Se(0, 1), bO = Se(1, 1);
  function $g(e) {
    if (e.op === "&&") return { op: "||", values: e.values.map($g) };
    if (e.op === "||") return { op: "&&", values: e.values.map($g) };
    switch (e.condition) {
      case ">0":
        return { op: "comparator", value: Cs._neg(e.value), condition: ">=0" };
      case ">=0":
        return { op: "comparator", value: Cs._neg(e.value), condition: ">0" };
      case "=0":
        return { op: "comparator", value: e.value, condition: "!=0" };
      case "!=0":
        return { op: "comparator", value: e.value, condition: "=0" };
    }
  }
  function P0(e, t) {
    let n = [];
    return e.op === "&&" ? n.push(...e.values) : n.push(e),
      t.op === "&&" ? n.push(...t.values) : n.push(t),
      { op: "&&", values: n };
  }
  var Cs;
  ((c) => {
    function e(l, p) {
      if (!(l === void 0 || p === void 0)) return t(l, p);
    }
    c.add = e;
    function t(l, p) {
      let f = [];
      for (let d = 0; d < l.argCoeffs.length; d++) {
        f.push(qs(l.argCoeffs[d], p.argCoeffs[d]));
      }
      return {
        argCoeffs: f,
        constantCoeff: qs(l.constantCoeff, p.constantCoeff),
      };
    }
    c._add = t;
    function n(l, p) {
      if (!(l === void 0 || p === void 0)) return r(l, p);
    }
    c.sub = n;
    function r(l, p) {
      let f = [];
      for (let d = 0; d < l.argCoeffs.length; d++) {
        f.push(ai(l.argCoeffs[d], p.argCoeffs[d]));
      }
      return {
        argCoeffs: f,
        constantCoeff: ai(l.constantCoeff, p.constantCoeff),
      };
    }
    c._sub = r;
    function s(l) {
      if (l !== void 0) return i(l);
    }
    c.neg = s;
    function i(l) {
      let p = [];
      for (let f = 0; f < l.argCoeffs.length; f++) p.push(Us(l.argCoeffs[f]));
      return { argCoeffs: p, constantCoeff: Us(l.constantCoeff) };
    }
    c._neg = i;
    function o(l, p) {
      if (l === void 0 || p === void 0) return;
      let f = Ug(l), d = Ug(p);
      if (!f && !d) return;
      d || ([l, p] = [p, l]);
      let y = [];
      for (let g = 0; g < l.argCoeffs.length; g++) {
        y.push(wr(l.argCoeffs[g], p.constantCoeff));
      }
      return {
        argCoeffs: y,
        constantCoeff: wr(l.constantCoeff, p.constantCoeff),
      };
    }
    c.mul = o;
    function a(l, p) {
      if (l === void 0 || p === void 0 || !Ug(p)) return;
      let d = [];
      for (let y = 0; y < l.argCoeffs.length; y++) {
        d.push(Ps(l.argCoeffs[y], p.constantCoeff));
      }
      return {
        argCoeffs: d,
        constantCoeff: Ps(l.constantCoeff, p.constantCoeff),
      };
    }
    c.div = a;
    function u(l, p) {
      if (!(l === void 0 || p === void 0 || !Ug(p))) {
        return V(p.constantCoeff) === 0
          ? {
            argCoeffs: new Array(l.argCoeffs.length).fill(qg),
            constantCoeff: bO,
          }
          : V(p.constantCoeff) === 1
          ? l
          : void 0;
      }
    }
    c.pow = u;
  })(Cs || (Cs = {}));
  var Yg = class {
    constructor(t, n, r, s) {
      this.chunk = t;
      this.coefficientTable = [];
      this.conditionTable = [];
      this.ZERO_COEFFS = new Array(n.length).fill(qg),
        this.mask = ol(t, n, r, s);
      for (let i = 0; i < n.length; i++) {
        let o = [];
        for (let a = 0; a < n.length; a++) o.push(i === a ? bO : qg);
        this.coefficientTable[n[i]] = { argCoeffs: o, constantCoeff: qg };
      }
    }
    coeffs(t) {
      let n = this.coefficientTable[t];
      if (n !== void 0) return n;
      let r, s = this.chunk.getInstruction(t);
      return s.type === 1 && s.valueType === Number
        ? r = { argCoeffs: this.ZERO_COEFFS, constantCoeff: s.value }
        : this.mask[t]
        ? r = this._coeffs(t)
        : r = void 0,
        this.coefficientTable[t] = r,
        r;
    }
    _coeffs(t) {
      let n = this.chunk.getInstruction(t);
      switch (n.type) {
        case 8: {
          let [s, i] = n.args;
          return Cs.add(this.coeffs(s), this.coeffs(i));
        }
        case 9: {
          let [s, i] = n.args;
          return Cs.sub(this.coeffs(s), this.coeffs(i));
        }
        case 14: {
          let s = n.args[0];
          return Cs.neg(this.coeffs(s));
        }
        case 10: {
          let [s, i] = n.args;
          return Cs.mul(this.coeffs(s), this.coeffs(i));
        }
        case 11: {
          let [s, i] = n.args;
          return Cs.div(this.coeffs(s), this.coeffs(i));
        }
        case 12:
        case 13: {
          let [s, i] = n.args;
          return Cs.pow(this.coeffs(s), this.coeffs(i));
        }
        case 26:
        case 28:
        case 27:
        case 29:
        case 33:
        case 0:
        case 23:
        case 2:
        case 1:
        case 25:
        case 32:
        case 31:
        case 15:
        case 16:
        case 38:
        case 39:
        case 40:
        case 41:
        case 37:
        case 42:
        case 21:
        case 22:
        case 19:
        case 20:
        case 24:
        case 48:
        case 47:
        case 3:
        case 44:
        case 49:
        case 50:
        case 51:
        case 4:
        case 53:
        case 54:
        case 55:
          return;
        default:
          let r = n;
          throw new Error(`Unexpected opcode ${r.type}`);
      }
    }
    condition(t) {
      let n = this.conditionTable[t];
      if (n !== void 0) return n;
      let r;
      return this.mask[t] ? r = this._condition(t) : r = void 0,
        this.conditionTable[t] = r,
        r;
    }
    _condition(t) {
      let n = this.chunk.getInstruction(t);
      switch (n.type) {
        case 26: {
          let [s, i] = n.args, o = Cs.sub(this.coeffs(i), this.coeffs(s));
          return o === void 0
            ? void 0
            : { op: "comparator", value: o, condition: ">0" };
        }
        case 28: {
          let [s, i] = n.args, o = Cs.sub(this.coeffs(i), this.coeffs(s));
          return o === void 0
            ? void 0
            : { op: "comparator", value: o, condition: ">=0" };
        }
        case 27: {
          let [s, i] = n.args, o = Cs.sub(this.coeffs(s), this.coeffs(i));
          return o === void 0
            ? void 0
            : { op: "comparator", value: o, condition: ">0" };
        }
        case 29: {
          let [s, i] = n.args, o = Cs.sub(this.coeffs(s), this.coeffs(i));
          return o === void 0
            ? void 0
            : { op: "comparator", value: o, condition: ">=0" };
        }
        case 25: {
          let [s, i] = n.args, o = Cs.sub(this.coeffs(s), this.coeffs(i));
          return o === void 0
            ? void 0
            : { op: "comparator", value: o, condition: "=0" };
        }
        case 32: {
          let s = n.args.map((i) => this.condition(i));
          return s.some((i) => i === void 0) ? void 0 : { op: "&&", values: s };
        }
        case 31: {
          let s = n.args.map((i) => this.condition(i));
          return s.some((i) => i === void 0) ? void 0 : { op: "||", values: s };
        }
        case 8:
        case 9:
        case 14:
        case 10:
        case 11:
        case 12:
        case 13:
        case 33:
        case 0:
        case 23:
        case 2:
        case 1:
        case 15:
        case 16:
        case 38:
        case 39:
        case 40:
        case 41:
        case 37:
        case 42:
        case 21:
        case 22:
        case 19:
        case 20:
        case 24:
        case 48:
        case 47:
        case 3:
        case 44:
        case 49:
        case 50:
        case 51:
        case 4:
        case 53:
        case 54:
        case 55:
          return;
        default:
          let r = n;
          throw new Error(`Unexpected opcode ${r.type}`);
      }
    }
  };
  function TO(e, t, n, r) {
    let s = t.reachConditions[n];
    if (s !== void 0) return IO(e, t, r, s);
  }
  function IO(e, t, n, r) {
    let s = t.argBlockvars;
    if (r.op === "||" || r.op === "&&") {
      let i = [];
      for (let o of r.values) {
        let a = IO(e, t, n, o);
        if (a === void 0) return;
        i.push(a);
      }
      return i.length === 0
        ? r.op === "&&" ? "true" : "false"
        : `(${i.join(r.op)})`;
    }
    switch (r.condition) {
      case ">0":
      case ">=0": {
        let o = `(${xO(e, r.value, s)}${r.condition})`,
          a = E0(e, r.value, s, n);
        return `(${o}&&${a})`;
      }
      case "!=0": {
        let i = xO(e, r.value, s),
          o = `(${i}>0)`,
          a = E0(e, r.value, s, n),
          u = `(${i}<0)`,
          c = E0(e, Cs._neg(r.value), s, n);
        return `((${o}&&${a})||(${u}&&${c}))`;
      }
      case "=0":
        return;
    }
  }
  function E0(e, t, n, r) {
    let s = [];
    for (let i = 0; i < n.length; i++) {
      let o = V(t.argCoeffs[i]),
        a = e.referenceArg(n[i]),
        u = e.referenceArg(r[i]);
      o > 0 ? s.push(`${u}>=${a}`) : o < 0 && s.push(`${u}<=${a}`);
    }
    return s.length === 0 ? true : `(${s.join("&&")})`;
  }
  function xO(e, t, n) {
    let r = "";
    for (let s = 0; s < n.length; s++) {
      let i = e.printValue(t.argCoeffs[s], Number), o = e.referenceArg(n[s]);
      r += `${i}*${o}+`;
    }
    return r += e.printValue(t.constantCoeff, Number), `(${r})`;
  }
  var Jt;
  ((r) => (r.Noop = 0, r.Inline = 1, r.Block = 2))(Jt || (Jt = {}));
  function M0(e) {
    switch (e.type) {
      case Jt.Noop:
        return "";
      case Jt.Inline:
        return e.source + `;
`;
      case Jt.Block:
        return e.source;
    }
  }
  function PO(e, t, n) {
    if (e.glsl) throw U("GLSL function not implemented");
    let { chunk: r, referenced: s } = e,
      i = t.args[0],
      o = r.getInstruction(i),
      a = o.signature.argTypes;
    if (e.isTailFunction[i]) return { type: Jt.Noop, nextIdx: o.endIndex + 1 };
    e.enterFunction(t, n, 0);
    let u = "";
    for (let c = 0; c < a.length; c++) {
      let l = n + c + 1;
      s[l] && (u += `${fn(l)}=${h0(i, c)};
`);
    }
    return { type: Jt.Block, source: Nk(e, t, n, u), nextIdx: n + 1 };
  }
  function Nk(e, t, n, r) {
    let { chunk: s } = e,
      i = t.args[0],
      o = s.getInstruction(i),
      a = o.signature.argTypes,
      u = "";
    for (let d = 0; d < a.length; d++) d > 0 && (u += ","), u += h0(i, d);
    let c = b0(i), l = uO(i), p = cO(i), f = Hg(i);
    return `
    const ${p}=${
      a.length === 1 && o.signature.argTypes[0] === Number
        ? "({fn, args}) => `${fn}:${args[0]}`"
        : "({fn, args}) => `${fn}:${JSON.stringify(args)}`"
    };

    const ${c}=((${l}, ${u}) => {
      ${Lp(e, n + 1, o.endIndex - 1)}
      const ${f} = {depth: 0, count: 0};
      const cache = ${l};
      ${r}
    `;
  }
  function EO(e, t, n) {
    let r = n + 1, s = t.args[0], o = e.chunk.getInstruction(s).args[0];
    if (e.isTailFunction[o]) throw U("Unexpected tail recursive function");
    let a = Rk(e, t), { referenced: u } = e;
    return u[n] && (a += `${fn(n)}=${e.referenceArg(t.args[0])};
`),
      e.exitFunction(),
      { type: Jt.Block, source: a, nextIdx: r };
  }
  function Rk(e, t) {
    let n = t.args[0],
      r = e.chunk.getInstruction(n),
      s = r.args[0],
      i = lO(s),
      o = Hg(s),
      a = r.valueType;
    return `
${o}.count++;
${o}.depth++;
let ${i};
if ((${o}.depth > BuiltIn.RECURSIVE_DEPTH_LIMIT) || (${o}.count > BuiltIn.RECURSIVE_COMPUTATION_LIMIT)) {
  ${i}=BuiltIn.handleRecursionLimitExceeded(__meta, ${a});
} else {
  ${i}=${e.referenceArg(t.args[1])};
}
return BuiltIn.recursionSuccess(${i},${o});
});
`;
  }
  function Vf(e, t) {
    return `{ fn: ${e}, args: ${t} }`;
  }
  function MO(e, t, n) {
    let r = n + 1,
      { chunk: s } = e,
      i = t.args[0],
      o = s.getInstruction(i),
      u = s.getInstruction(o.endIndex).args[0],
      c = t.args.slice(1).map((m) => e.referenceArg(m)),
      l = fn(n),
      p = fO(n),
      f = pO(n),
      d = dO(n),
      y = s.getInstruction(u),
      g = s.getInstruction(y.args[0]);
    if (zg(s, n)) {
      if (e.recursiveFunctionInfo.length < 1) {
        throw U("Expected recursive function info");
      }
      let m = e.recursiveFunctionInfo[e.recursiveFunctionInfo.length - 1],
        h = "",
        x = TO(e, m, n, t.args.slice(1));
      if (e.isTailFunction[i]) {
        let P = y.valueType;
        x && (h = `
if (${x}) {
            return BuiltIn.recursionDiverges(__meta, ${P});
          }`);
        let D = g.signature.argTypes,
          S = h + `
`;
        S += "looping=true";
        for (let O = 0; O < D.length; O++) {
          let _ = kg(u + O + 1);
          S += `,
${_}=${c[O]}`;
        }
        return h
          ? {
            type: Jt.Block,
            source: S + `;
`,
            nextIdx: r,
          }
          : { type: Jt.Inline, source: S, nextIdx: r };
      } else if (m.executionMode === 1) {
        let P = s.getInstruction(s.getInstruction(m.fn).endIndex),
          D = I0(s, P.args[0], t);
        if (!D) throw U("Expected valid iteration reference");
        let S = Ff(D.ref.to, D.ref.iterationParameterOffset);
        return { type: Jt.Inline, source: `${l}=${S}`, nextIdx: r };
      }
      x && (h = `
if (${x}) {
          return BuiltIn.SYMBOL_DIVERGES;
        }`);
      let T = Hg(m.fn),
        b = Vf(i, p),
        M = `
      const ${p} = ([${c.join(",")}]);
      ${h}
      const ${d} = cache.get(BuiltIn.recursionCacheKey(${b}));
      if (${d} === undefined) {
        return BuiltIn.recursionMissingCacheEntry(${b});
      }
      ${l} = ${d}[0];
      const ${f} = ${d}[1];
      if (${f}.count > ${T}.count) {
        ${T}.count = ${f}.count;
      }
      if (${f}.depth > ${T}.depth) {
        ${T}.depth = ${f}.depth;
      }
    `;
      return { type: Jt.Block, source: M, nextIdx: r };
    } else {
      let m = `{${g.recursionGroup.map((b) => `${b}: ${b0(b)}`).join(",")}}`,
        h = e.chunk.getRecursionStructure(y.args[0]);
      if (e.isTailFunction[i]) return Ak(e, t, n);
      if (h.canIterate) return _k(e, t, n, h, { innerFunctionsMap: m });
      let x = Vf(i, `[${c.join(",")}]`),
        T = `${l}=BuiltIn.executeRecursiveFunction(
      __meta,
      ${m},
      ${y.valueType},
      ${x}
    )`;
      return { type: Jt.Inline, source: T, nextIdx: r };
    }
  }
  var CO = Symbol("UPDATED_IN_BODY");
  function DO(e) {
    let t = "";
    for (let n of e) {
      let r = "declare" in n ? `let ${n.declare}` : fn(n.reference),
        s = n.initializeRHS;
      t += `${r}=${s};
`;
    }
    return t;
  }
  function SO(e) {
    let t = "", n = "";
    for (let r of e) {
      let s = "declare" in r ? r.declare : fn(r.reference);
      r.updateRHS !== CO &&
        (t && (t += ",", n += ","), t += `${s}`, n += `${r.updateRHS}`);
    }
    return `[${t}]=[${n}]`;
  }
  function Ak(e, t, n) {
    let r = t.args[0],
      s = e.chunk.getInstruction(r),
      i = e.chunk.getInstruction(s.endIndex),
      o = i.args[0],
      a = e.chunk.getInstruction(o),
      u = a.valueType,
      c = fn(n),
      l = [];
    e.enterFunction(a, o, 2);
    let p = Xg(e, o, s.endIndex).source;
    e.exitFunction();
    let f = mO(n), d = yO(n);
    l.push({ declare: f, initializeRHS: "0", updateRHS: `${f}+1` }, {
      declare: d,
      initializeRHS: "0",
      updateRHS: `${d}+1`,
    });
    for (let g = 1; g < t.args.length; g++) {
      let m = o + g;
      if (!e.referenced[m]) continue;
      let h = kg(m);
      l.push({
        reference: m,
        initializeRHS: e.referenceArg(t.args[g]),
        updateRHS: h,
      }, { declare: h, initializeRHS: void 0, updateRHS: CO });
    }
    let y = `${c}=(() => {
    ${Lp(e, o + 1, s.endIndex - 1)}

    let looping = true;
    ${DO(l)}
    while (looping) {
      looping = false;

      ${p}

      if (looping) {
        ${SO(l)}
      }

      if ((${f} > BuiltIn.RECURSIVE_DEPTH_LIMIT) || (${d} > BuiltIn.RECURSIVE_COMPUTATION_LIMIT)) {
        return BuiltIn.handleRecursionLimitExceeded(__meta, ${u});
      };
    }

    return ${e.referenceArg(i.args[1])}
  })()`;
    return { type: Jt.Inline, source: y, nextIdx: n + 1 };
  }
  function _k(e, t, n, r, s) {
    let i = t.args[0],
      o = e.chunk.getInstruction(i),
      a = e.chunk.getInstruction(o.endIndex),
      u = a.args[0],
      c = fn(n),
      l = [],
      p = "",
      f,
      { iterationParameterIndex: d, loopStart: y, order: g } = r,
      m = r.maxRecursiveCallOffsets,
      h = u + d + 1,
      x = fn(h),
      T = t.args[d + 1],
      b = `(${y})`,
      M = e.chunk.getInstruction(T),
      P = (M.type === 39 || M.type === 41) &&
          e.chunk.getInstruction(M.args[1]).type === 23
        ? M.args[0]
        : void 0,
      D = `(${e.referenceArg(T)})-${b}`,
      S,
      O;
    if (P !== void 0) {
      let G = e.referenceArg(P);
      S = `BuiltIn.listMax(
      (${G}).filter(
        x => isFinite(x) &&
        Math.floor(x - ${b}) === (x - ${b})
      )
    )`, O = `BuiltIn.getBroadcastTargetElements(${G}).has(${x})`;
    } else S = `(${e.referenceArg(T)})`, O = "false";
    l.push({ reference: h, initializeRHS: `(${b})`, updateRHS: `${x}+1` }),
      f = "";
    for (let G of g) {
      let k = e.chunk.getInstruction(G),
        Z = k.endIndex,
        F = e.chunk.getInstruction(Z),
        Y = F.args[0],
        re = e.chunk.getInstruction(Y);
      for (let he = 1; he < t.args.length; he++) {
        let K = Y + he;
        if (!e.referenced[K]) continue;
        let Oe = fn(K);
        he === d + 1
          ? f += `${Oe}=${e.referenceArg(h)};
`
          : p += `${Oe}=${e.referenceArg(t.args[he])};
`;
      }
      p += Lp(e, Y + 1, k.endIndex - 1);
      let Ee = m[k.symbol];
      if (Ee !== void 0) {
        for (let he = 1; he <= Ee; he++) {
          let K = Ff(G, he),
            Oe = he === 1 ? e.referenceArg(F.args[1]) : Ff(G, he - 1),
            te = t.args.slice(1).map((J, W) =>
              W === d ? y - he : e.referenceArg(J)
            ),
            Ze = Vf(G, `[${te.join(",")}]`),
            dt = `BuiltIn.executeRecursiveFunction(
            __meta,
            ${s.innerFunctionsMap},
            ${re.valueType},
            ${Ze}
          )`,
            me = `(
          broadcastOutputMap
            ? (broadcastOutputMap[BuiltIn.recursionCacheKey(${Ze})] = ${dt})
            : ${dt}
        )`;
          l.push({ declare: K, initializeRHS: me, updateRHS: Oe });
        }
      }
      e.enterFunction(re, Y, 1),
        f += Xg(e, Y, k.endIndex).source,
        e.exitFunction(),
        f += `const ${Ff(G, 0)}=${e.referenceArg(F.args[1])};
`;
    }
    let _ = t.args.slice(1).map((G) => e.referenceArg(G)),
      L = t.args.slice(1).map((G, k) => k === d ? x : e.referenceArg(G)),
      w = `${c}=(() => {
    ${p}
    const broadcastOutputMap = ${
        P !== void 0 ? "__meta.iterativeRecursionOutputs" : "undefined"
      };

    ${DO(l)}

    const outerStackFrame = ${Vf(i, `[${_.join(",")}]`)};

    if (broadcastOutputMap) {
        const cacheEntry = broadcastOutputMap[BuiltIn.recursionCacheKey(outerStackFrame)];
        if (cacheEntry !== undefined) {
          return cacheEntry;
        }
      }


    const targetLoopSteps = ${D}
    if (targetLoopSteps < 0 || Math.floor(targetLoopSteps) !== targetLoopSteps) {
      return BuiltIn.executeRecursiveFunction(
        __meta,
        ${s.innerFunctionsMap},
        ${o.valueType},
        outerStackFrame
      );
    }

    const loopEnd = ${S};

    let result;
    while (true) {
      ${f}

      result = ${e.referenceArg(a.args[1])};

      if (broadcastOutputMap && ${O}) {
        const key = BuiltIn.recursionCacheKey(${Vf(i, `[${L.join(",")}]`)});
        broadcastOutputMap[key] = result;
      }

      if (${x} < loopEnd) {
        ${SO(l)}
      } else {
        break;
      }
    }

    ${
        P === void 0
          ? "return result;"
          : `const cached = broadcastOutputMap[BuiltIn.recursionCacheKey(outerStackFrame)];
          if (cached === undefined) {
            return BuiltIn.recursionDiverges(__meta, ${o.valueType});
          }
          return cached;
          `
      }
  })()`;
    return { type: Jt.Inline, source: w, nextIdx: n + 1 };
  }
  function Zg(e) {
    let { chunk: t } = e,
      n = Lp(e, t.argNames.length, t.instructionsLength() - 1),
      r = 0;
    for (; r < t.instructionsLength();) {
      let s = t.getInstruction(r), i = C0(e, s, r);
      n += M0(i), r = i.nextIdx;
    }
    return n += `return ${e.referenceArg(t.getReturnIndex())};`, n;
  }
  function Lk(e, t) {
    let { chunk: n } = e,
      r = [],
      s = e.thunkName(t),
      i = e.thunkEnd(s),
      o = Ap(s),
      a = _p(s),
      u = "",
      c = false,
      l = false;
    e.wantToInlineThunk(s) || (l = true);
    let p = t;
    for (; p <= i;) {
      let f = n.getInstruction(p), d = p === t ? vO(e, f, p) : C0(e, f, p);
      switch (d.type) {
        case Jt.Noop:
          break;
        case Jt.Inline:
          c && (u += `,
`),
            u += d.source,
            c = true;
          break;
        case Jt.Block:
          c && (u += `;
`),
            c = false,
            u += d.source,
            l = true;
          break;
      }
      r.push(u), p = d.nextIdx;
    }
    if (u === "" && (u = "0", l = false), l) {
      let f = `${o}=false;${a}=()=>{
${o}=true;

      ${u}${c ? ";" : ""}
    };
`;
      return { type: Jt.Block, source: f, nextIdx: p };
    } else return e.inlineThunk(s, u), { type: Jt.Noop, nextIdx: p };
  }
  function C0(e, t, n) {
    return e.isThunkBegin(n) ? Lk(e, n) : vO(e, t, n);
  }
  function vO(e, t, n) {
    let r = n + 1;
    if (!e.referenced[n]) return { type: Jt.Noop, nextIdx: r };
    switch (t.type) {
      case 0:
      case 47:
      case 48:
      case 22:
      case 49:
      case 4:
        return { type: Jt.Noop, nextIdx: r };
      case 21:
        if (e.glsl) throw FT();
        return Fk(e, t, n);
      case 2:
        return e.inlineSource(n, e.chunk.argNames[n]),
          { type: Jt.Noop, nextIdx: r };
      case 23:
        return { type: Jt.Block, source: Vk(e, t, n), nextIdx: r };
      case 24:
        return { type: Jt.Block, source: Bk(e, t, n), nextIdx: r };
      case 19:
        return { type: Jt.Block, source: Gk(e, t, n), nextIdx: r };
      case 20:
        return { type: Jt.Block, source: kk(e, t, n), nextIdx: r };
      case 50:
        return { type: Jt.Block, source: Hk(e, t, n), nextIdx: r };
      case 51:
        return { type: Jt.Block, source: zk(e, t, n), nextIdx: r };
      case 53:
        return PO(e, t, n);
      case 54:
        return EO(e, t, n);
      case 33: {
        let s = e.referenceArg(t.args[0]),
          i = e.referencePiecewiseBranch(t.args[1]),
          o = e.referencePiecewiseBranch(t.args[2]);
        if (
          !(i.thunkDependencies.some((p) => e.isEarlyReturningThunk(p)) ||
            o.thunkDependencies.some((p) => e.isEarlyReturningThunk(p)))
        ) {
          let p = e.emitTernary(s, i.expression, o.expression, t);
          return e.shouldInline(n)
            ? (e.inlineSource(n, `(${p})`), { type: Jt.Noop, nextIdx: r })
            : { type: Jt.Inline, source: `${fn(n)}=${p}`, nextIdx: r };
        }
        let u = fn(n),
          c = (p) => {
            if (p.length === 0) return "";
            let f = "";
            for (let d of p) {
              let y = e.inlinedThunks[d];
              if (y !== void 0) {
                let g = `(${y},void 0)`;
                f !== "" ? f = `(${f}||${g})` : f = g;
              } else {
                let g = Ap(d), m = _p(d);
                f !== "" && (f += "||"), f += `(${g} ? undefined : ${m}())`;
              }
            }
            return f = "const earlyReturn =" + f,
              f += `;
if (earlyReturn !== undefined) return earlyReturn;
`,
              f;
          },
          l = `if (${s}) {
          ${c(i.thunkDependencies)}${u} = ${i.rawExpression};
        } else {
          ${c(o.thunkDependencies)}${u} = ${o.rawExpression};
        }`;
        return { type: Jt.Block, source: l, nextIdx: r };
      }
      case 55:
        return MO(e, t, n);
      default: {
        let s = Uk(e, t, n);
        return e.shouldInline(n)
          ? (e.inlineSource(n, `(${s})`), { type: Jt.Noop, nextIdx: r })
          : { type: Jt.Inline, source: `${fn(n)}=${s}`, nextIdx: r };
      }
    }
  }
  function Xg(e, t, n) {
    let { chunk: r, referenced: s } = e, i = "", o = t + 1;
    for (; o < n;) {
      if (!s[o]) {
        o = o + 1;
        continue;
      }
      let a = r.getInstruction(o), u = C0(e, a, o);
      i += M0(u), o = u.nextIdx;
    }
    return { type: Jt.Block, source: i, nextIdx: o };
  }
  function wk(e, t, n) {
    let { endIndex: r } = t,
      { chunk: s } = e,
      i = `function(${fn(n)}) {
`,
      o = n + 1,
      a = r - 1;
    i += Lp(e, o, a), i += Xg(e, n, r).source;
    let u = s.getInstruction(r);
    return i += `return ${e.referenceArg(u.args[1])};
}`,
      i;
  }
  function Fk(e, t, n) {
    let r = "BuiltIn.quad(";
    r += wk(e, t, n),
      r += `,${e.referenceArg(t.args[0])},${e.referenceArg(t.args[1])})`;
    let { endIndex: s } = t, i = s + 1;
    return e.shouldInline(i)
      ? (e.inlineSource(i, r), { type: Jt.Noop, nextIdx: t.endIndex })
      : { type: Jt.Inline, source: `${fn(s + 1)}=${r}`, nextIdx: t.endIndex };
  }
  function Lp(e, t, n) {
    let { chunk: r, referenced: s } = e, i = "", o = false;
    for (let a = t; a <= n; a++) {
      if (!e.glsl && e.isThunkBegin(a)) {
        let c = e.thunkName(a);
        i += `${o ? "," : "var "}${Ap(c)}`, i += `,${_p(c)}`, o = true;
      }
      let u = r.getInstruction(a);
      if (!(u.type === 0 || u.type === 24 || u.type === 20 || !s[a])) {
        if (u.type === 21) {
          let { endIndex: c } = u;
          a = c, e.shouldInline(c + 1) && a++;
          continue;
        }
        if (
          !e.shouldInline(a) &&
          (i += e.emitVarDeclaration(a, o), o = true, u.type === 53)
        ) {
          let { endIndex: c } = u;
          a = c - 1;
          continue;
        }
      }
    }
    return o && (i += `;
`),
      i;
  }
  function Vk(e, t, n) {
    let { glsl: r, chunk: s, referenced: i } = e,
      o = fn(n),
      a = s.getInstruction(t.endIndex),
      u = e.referenceArg(t.args[0]),
      c = "";
    for (let p = 1; p < a.args.length; p++) {
      let f = t.endIndex + p;
      if (!i[f] || s.getInstruction(f).type !== 48) continue;
      let y = fn(f);
      r || (c += `${y}=[];
`);
    }
    return r || (c += `if(${u}>${1e4}) throw ErrorMsg.maxListSize();
`),
      c += `for(${o}=1${r ? ".0" : ""};${o}<=${u};${o}++){
`,
      c;
  }
  function Bk(e, t, n) {
    let { glsl: r, chunk: s, referenced: i } = e, o = "";
    for (let a = 1; a < t.args.length; a++) {
      let u = n + a;
      if (
        u >= s.instructionsLength() || !i[u] || s.getInstruction(u).type !== 48
      ) continue;
      let c = fn(n + a), l = e.referenceArg(t.args[a]);
      if (r) {
        let p = e.referenceArg(t.args[0]);
        o += `${c}[int(${p})-1]=${l};
`;
      } else {o += `${c}.push(${l});
`;}
    }
    return o += `}
`,
      o;
  }
  function Gk(e, t, n) {
    let { chunk: r, referenced: s } = e, i = fn(n);
    e.beforeBeginLoop(t);
    let o = `${e.referenceArg(t.args[0])}`,
      a = `${e.referenceArg(t.args[1])}`,
      u = `if(${o}>${a}){
`;
    for (let c = 2; c < t.args.length; c++) {
      let l = t.endIndex + c - 1;
      if (
        l >= r.instructionsLength() || !s[l] || r.getInstruction(l).type !== 47
      ) continue;
      let p = fn(l);
      u += `${p}=${e.referenceArg(t.args[c])};
`;
    }
    u += e.checkFiniteBounds(t, o, a),
      u += `}else{
`;
    for (let c = 2; c < t.args.length; c++) {
      let l = n + c - 1;
      if (!s[l] || r.getInstruction(l).type !== 47) continue;
      let p = fn(l);
      u += `${p}=${e.referenceArg(t.args[c])};
`;
    }
    return u += `${i}=${o};
`,
      u += "while (true) {",
      u;
  }
  function kk(e, t, n) {
    let { chunk: r, referenced: s } = e,
      i = r.getInstruction(t.args[0]),
      o = `${e.referenceArg(i.args[1])}`,
      a = fn(t.args[0]),
      u = `${a}++;`;
    u += `if (${a}<=${o}) {
`;
    let c = new Map(), l = [];
    for (let p = 1; p < t.args.length; p++) {
      let f = t.args[0] + p;
      if (!s[f] || r.getInstruction(f).type !== 47) continue;
      let d = t.args[p];
      c.set(f, e.referenceArg(d)), l[d] = e.isDirectlyReferencedByName(d);
    }
    for (let [p, f] of c.entries()) {
      if (l[p]) {
        let d = aO(p);
        u += e.emitImmediateAssignment(p, d, f), c.set(p, d);
      }
    }
    for (let [p, f] of c.entries()) {
      u += `${fn(p)}=${f};
`;
    }
    u += `} else {
`;
    for (let p = 1; p < t.args.length; p++) {
      let f = n + p;
      if (
        f >= r.instructionsLength() || !s[f] || r.getInstruction(f).type !== 47
      ) continue;
      let d = fn(f);
      u += `${d}=${e.referenceArg(t.args[p])};
`;
    }
    return u += `break;
`,
      u += `}
}
`,
      u += `}
`,
      u;
  }
  function Hk(e, t, n) {
    let { glsl: r } = e;
    if (r) throw U("GLSL map not implemented yet");
    let s = fn(t.endIndex + 1), i = [];
    for (let a = 0; a < t.callData.parameterSymbols.length; a++) {
      let u = fn(n + a + 1);
      i.push(u);
    }
    let o = i.join(",");
    return `${s}=(${o}) => {
`;
  }
  function zk(e, t, n) {
    let r = `return ${e.referenceArg(t.args[1])}`;
    return r += `}
`,
      r;
  }
  function Uk(e, t, n) {
    switch (t.type) {
      case 1:
        return e.emitConstant(t);
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 31:
      case 32:
        return e.emitBinary(
          t,
          e.referenceArg(t.args[0]),
          e.referenceArg(t.args[1]),
        );
      case 14: {
        let s = e.referenceArg(t.args[0]);
        return e.emitNeg(s);
      }
      case 15: {
        let s = t.valueType;
        switch (s) {
          case Point:
          case Complex:
            return e.emitVec2(
              e.referenceArg(t.args[0]),
              e.referenceArg(t.args[1]),
            );
          case Point3D:
            return e.emitVec3(
              e.referenceArg(t.args[0]),
              e.referenceArg(t.args[1]),
              e.referenceArg(t.args[2]),
            );
          default:
            let i = s;
            throw new Error(`Unexpected tuple type ${i}`);
        }
      }
      case 16: {
        let s = e.chunk.getInstruction(t.args[0]).valueType;
        switch (s) {
          case Point:
          case Point3D:
          case Complex:
            return e.emitVecAccess(e.referenceArg(t.args[0]), t.index);
          default:
            let i = s;
            throw new Error(`Unexpected tuple type ${i}`);
        }
      }
      case 38:
        return e.emitList(t.args.map((s) => e.referenceArg(s)), t);
      case 40:
      case 42:
      case 3:
        throw new Error(
          `Programming Error: expect ${
            ts(t.type)
          } to be removed before emitting code.`,
        );
      case 39: {
        let s = t.valueType;
        return e.emitListAccess(
          e.referenceArg(t.args[0]),
          e.referenceArg(t.args[1]),
          e.printValue(ls(s), s),
          t,
        );
      }
      case 41:
        return e.emitInboundsListAccess(
          e.referenceArg(t.args[0]),
          e.referenceArg(t.args[1]),
        );
      case 37: {
        let s = t.args.map((i) => e.referenceArg(i));
        return !e.glsl &&
            (n === e.chunk.getReturnIndex() &&
                t.symbol === "coerceComplexToReal" ||
              t.symbol === "peelableCoerceComplexToReal")
          ? `BuiltIn.peelableCoerceComplexToReal(${s.join(",")},__meta)`
          : e.emitNativeFunction(s, t);
      }
      case 44:
        return e.emitExtendSeed(
          e.referenceArg(t.args[0]),
          e.chunk.getInstruction(t.args[1]).valueType,
          e.referenceArg(t.args[1]),
          t.tag,
        );
      case 2:
      case 0:
      case 21:
      case 22:
      case 19:
      case 20:
      case 23:
      case 24:
      case 47:
      case 48:
      case 49:
      case 50:
      case 51:
      case 53:
      case 54:
      case 33:
      case 55:
      case 4:
        throw new Error(`Unexpected opcode ${t.type}`);
      default:
        let r = t;
        throw new Error(`Unexpected opcode ${r.type}`);
    }
  }
  function OO(e, t, n, r) {
    let s = e.getInstruction(n.args[0]);
    if (s.recursionGroup.length > 1) return [];
    let i = s.endIndex, o = e.getInstruction(i), a = new Yg(e, r, t, i), u = [];
    for (let l = 1; l < o.args.length; l++) {
      u[o.args[l]] = { op: "&&", values: [] };
    }
    for (let l = i - 1; l > t; l--) {
      let p = u[l];
      if (p === void 0) continue;
      let f = e.getInstruction(l);
      if (!ge(f)) {
        if (f.type === 33) {
          u[f.args[0]] = p;
          let d = a.condition(f.args[0]);
          d !== void 0 &&
            (u[f.args[1]] = P0(p, d), u[f.args[2]] = P0(p, $g(d)));
        } else for (let d of f.args) u[d] = p;
      }
    }
    let c = [];
    e: for (let l = i - 1; l >= t; l--) {
      let p = e.getInstruction(l);
      if (p.type !== 55) continue;
      let f = e.getInstruction(p.args[0]);
      if (l > f.endIndex) continue;
      let d = p.args.slice(1);
      if (d.length !== f.signature.argTypes.length) {
        throw new Error("Programming error: Non-matching arg length");
      }
      let y = u[l];
      if (y !== void 0) {
        if (y.op === "&&" && y.values.length === 0) {
          throw new Error(
            "Programming error: Recursive call unconditionally executed",
          );
        }
        for (let g = 0; g < d.length; g++) {
          if (e.getInstruction(d[g]).valueType !== Number) continue e;
          let m = a.coeffs(d[g]);
          if (m === void 0 || !qk(m, g) || V(m.argCoeffs[g]) < -1) continue e;
        }
        c[l] = y;
      }
    }
    return c;
  }
  function qk(e, t) {
    for (let n = 0; n < e.argCoeffs.length; n++) {
      if (n !== t && V(e.argCoeffs[n]) !== 0) return false;
    }
    return true;
  }
  function NO(e, t) {
    let n = e.getReturnIndex(), r = new Array(n), s = new Array(n).fill(false);
    for (let o = 0; o <= n; o++) {
      let a = e.getInstruction(o);
      es(a) || ds(a) || a.type === 48 ||
        a.type === 47 && e.getInstruction(a.args[0]).type !== 22 ||
        a.type === 0 || a.type === 55
        ? r[o] = 2
        : r[o] = 0;
    }
    r[n] === 0 && (r[n] = 1, s[n] = true);
    let i = 0;
    for (let o = n; o >= 0; o--) {
      if (!t[o]) continue;
      let a = e.getInstruction(o);
      if (a.type === 54 ? i++ : a.type === 53 && i--, ge(a)) continue;
      if (
        a.type === 19 || a.type === 20 || a.type === 24 || a.type === 54 ||
        a.type === 39 || a.type === 55
      ) {
        for (let c of a.args) {
          let l = e.getInstruction(c);
          r[c] === 0 && l.type === 1 && l.valueType === Number
            ? (r[c] = 1, s[c] = true)
            : (r[c] = 2, s[c] = false);
        }
      } else {
        for (let c of a.args) {
          switch (r[c]) {
            case 0:
              r[c] = 1, s[c] = true;
              break;
            case 1:
            case 2:
              r[c] = 2, s[c] = false;
              break;
          }
        }
        i > 0 && a.type === 33 && (r[o] = 2, s[o] = false);
      }
    }
    return s;
  }
  function RO(e, t) {
    if (t.recursionGroup.length > 1) return false;
    let n = t.endIndex, r = e.getInstruction(n);
    if (r.type !== 54) {
      throw new Error(
        "Programming Error: end of BeginFunction is not EndFunction",
      );
    }
    let [s, ...i] = r.args;
    if (i.length !== 1) return false;
    let o = e.getInstruction(s);
    if (o.type !== 53) {
      throw new Error(
        "Programming Error: start of EndFunction is not BeginFunction",
      );
    }
    let a = o.args[0], u = {};
    u[i[0]] = true;
    for (let c = n - 1; c >= s; c--) {
      let l = e.getInstruction(c);
      switch (l.type) {
        case 55:
          if (!u[c]) return false;
          if (l.args[0] !== a) {
            throw new Error("recursionGroup.length == 1 contradicted");
          }
          break;
        case 33:
          u[c] && (u[l.args[1]] = true, u[l.args[2]] = true);
          break;
        default:
          break;
      }
    }
    return true;
  }
  function $k(e, t) {
    if (e.size !== t.size) return false;
    for (let n of e) if (!t.has(n)) return false;
    return true;
  }
  var Wg = class {
    constructor(t, n, r) {
      this.chunk = t;
      this.referenced = n;
      this.shouldInline = r;
      this.thunkSets = [];
      this.thunkStarts = [];
      this.thunkEnds = [];
      this._isThunkEnd = [];
      this.piecewiseReferencedCount = [];
      this.dependencyThunkNames = [];
      this.parentFunctionStart = [];
      let s = t.getReturnIndex();
      for (let a = 0; a <= t.instructionsLength(); a++) {
        this.thunkSets[a] = new Set();
      }
      let i = t.argNames.length, o = [];
      for (let a = i; a <= t.getReturnIndex(); a++) {
        let u = t.getInstruction(a);
        this.parentFunctionStart[a] = o[o.length - 1],
          u.type === 53 ? o.push(a) : u.type === 54 && o.pop();
      }
      this.markThunkSets(i, s, [s], "always"), this.markThunks(i, s);
    }
    isThunkBegin(t) {
      return this.thunkStarts[t] === t;
    }
    isThunkEnd(t) {
      return !!this._isThunkEnd[t];
    }
    containingThunkName(t) {
      return this.thunkStarts[t];
    }
    thunkEnd(t) {
      return this.thunkEnds[t];
    }
    isEarlyReturningThunk(t) {
      let n = this.parentFunctionStart[t];
      return this.isThunkBegin(t) && n !== void 0;
    }
    dependencyThunkNamesForPiecewiseBranch(t) {
      return this.dependencyThunkNames[t];
    }
    wantToInlineThunk(t) {
      let n = this.thunkSets[t];
      if (n !== "always" && n.size === 1) {
        for (let r of n) {
          if (this.piecewiseReferencedCount[r] !== 1) return false;
        }
        return true;
      }
      return false;
    }
    printChunkWithThunkInfo() {
      for (let t = 0; t <= this.chunk.getReturnIndex(); t++) {
        let n = this.thunkSets[t],
          r = n === "always" ? "always" : `{${[...n].sort().join(",")}}`;
        if (this.isThunkBegin(t) && (r += " beginThunk"), this.isThunkEnd(t)) {
          r += " endThunk";
        } else {
          let s = this.containingThunkName(t);
          s !== void 0 && (r += ` start:${s}`);
        }
        this.shouldInline[t] && (r += "	[inline]"), this.chunk.comments[t] = r;
      }
      return this.chunk.print(this.chunk.getReturnIndex());
    }
    markThunkSets(t, n, r, s) {
      let {
        chunk: i,
        referenced: o,
        thunkSets: a,
        piecewiseReferencedCount: u,
      } = this;
      for (let l of r) a[l] = "always";
      function c(l, p) {
        let f = a[l];
        if (f !== "always") {
          if (p === "always") {
            a[l] = p;
            return;
          }
          for (let d of p) f.add(d);
        }
      }
      for (let l = n; l >= t; l--) {
        if (!o[l]) continue;
        let p = i.getInstruction(l);
        if (ge(p)) continue;
        let f = a[l];
        if (ds(p)) {
          let d = p.args[0];
          this.markThunkSets(d + 1, l - 1, p.args.slice(1), f), l = d + 1;
          continue;
        }
        for (let d = 0; d < p.args.length; d++) {
          let y = p.args[d];
          if (y < t) c(y, s);
          else if (d > 0 && p.type === 33) {
            let g = a[y];
            g !== "always" && g.add(y);
            let m = u[y];
            u[y] = (m != null ? m : 0) + 1;
          } else c(y, f);
        }
      }
    }
    markThunks(t, n) {
      var a, u;
      let { chunk: r, thunkSets: s } = this, i, o;
      for (let c = t; c <= n; c = o) {
        let l = r.getInstruction(c), p = Yk(this.chunk, l), f, d;
        if (p) {
          let y = c + 1, g = p.innerEndIndex - 1;
          this.markThunks(y, g),
            d = s[p.innerEndIndex],
            o = p.outerEndIndex + 1,
            f = this.thunkDecision(
              i,
              c,
              this.referenced[p.innerEndIndex],
              l.type === 21 && this.shouldInline[p.outerEndIndex],
              d,
            );
        } else {d = s[c],
            o = c + 1,
            f = this.thunkDecision(
              i,
              c,
              this.referenced[c],
              this.shouldInline[c],
              d,
            );}
        if (
          i !== void 0 && f.shouldEndThunk &&
          (this.markEndThunk(c - 1, i), i = void 0),
            f.shouldStartThunk && d !== "always"
        ) {
          for (let y of d) {
            (u = (a = this.dependencyThunkNames)[y]) != null || (a[y] = []),
              this.dependencyThunkNames[y].push(c);
          }
          i = { start: c, set: d };
        }
        if (i !== void 0 && (this.thunkStarts[c] = i.start, p)) {
          for (let y = p.innerEndIndex; y <= p.outerEndIndex; y++) {
            this.thunkStarts[y] = i.start;
          }
        }
      }
      i !== void 0 && this.markEndThunk(n, i);
    }
    thunkDecision(t, n, r, s, i) {
      let o = this.chunk.getInstruction(n);
      if (o.type === 33 && (s = false), s || !r) {
        return { shouldEndThunk: false, shouldStartThunk: false };
      }
      if (i === "always") {
        return { shouldEndThunk: t !== void 0, shouldStartThunk: false };
      }
      let a = o.type === 1 || o.type === 47,
        u = i.size > 0 && !a,
        c = t !== void 0 && !$k(i, t.set);
      return { shouldEndThunk: c, shouldStartThunk: (c || t === void 0) && u };
    }
    markEndThunk(t, n) {
      let { referenced: r } = this;
      for (; t >= 0 && !r[t];) t--;
      this._isThunkEnd[t] = true, this.thunkEnds[n.start] = t;
    }
  };
  function Yk(e, t) {
    if (es(t)) {
      let n = t.endIndex, r = e.getInstruction(n);
      if (r === void 0) return;
      if (Gg(r)) {
        return { outerEndIndex: n + r.args.length - 1, innerEndIndex: n };
      }
      if (r.type === 54) return { outerEndIndex: n, innerEndIndex: n };
    }
  }
  var wp = class {
    constructor(t, n) {
      this.chunk = t;
      this.glsl = n;
      this.inlinedSource = [];
      this.inlinedThunks = [];
      this.recursiveFunctionInfo = [];
      this.isTailFunction = [];
      let r = t.getReturnIndex();
      this.referenced = Vr(t, r),
        this._shouldInline = NO(t, this.referenced),
        !this.glsl && t.computeNeedsThunking() &&
        (this.thunks = new Wg(t, this.referenced, this._shouldInline));
      for (let s = 0; s <= r; s++) {
        let i = t.getInstruction(s);
        if (i.type === 4) {
          if (!this.referenced[s]) continue;
          this.isTailFunction[s] = RO(t, i),
            i.recursionGroup = i.recursionGroup.filter((o) =>
              this.referenced[o]
            );
        }
      }
    }
    isThunkBegin(t) {
      return !!this.thunks && this.thunks.isThunkBegin(t);
    }
    isThunkEnd(t) {
      return !!this.thunks && this.thunks.isThunkEnd(t);
    }
    isEarlyReturningThunk(t) {
      return !!this.thunks && this.thunks.isEarlyReturningThunk(t) &&
        this.inlinedThunks[t] === void 0;
    }
    thunkName(t) {
      var n;
      return (n = this.thunks) == null ? void 0 : n.containingThunkName(t);
    }
    thunkEnd(t) {
      return this.thunks.thunkEnd(t);
    }
    shouldInline(t) {
      return this._shouldInline[t];
    }
    inlineSource(t, n) {
      this.inlinedSource[t] = n;
    }
    wantToInlineThunk(t) {
      return !!this.thunks && this.thunks.wantToInlineThunk(t);
    }
    inlineThunk(t, n) {
      this.inlinedThunks[t] = n;
    }
    referenceArg(t) {
      let n = this.inlinedSource[t];
      return n !== void 0 ? n : fn(t);
    }
    isDirectlyReferencedByName(t) {
      return this.inlinedSource[t] === void 0;
    }
    referencePiecewiseBranch(t) {
      var o;
      let n = this.referenceArg(t),
        r = (o = this.thunks) == null
          ? void 0
          : o.dependencyThunkNamesForPiecewiseBranch(t);
      if (!r || r.length === 0) {
        return { expression: n, rawExpression: n, thunkDependencies: [] };
      }
      let s = [], i = "";
      for (let a of r) {
        let u = this.inlinedThunks[a];
        if (u !== void 0) i && (i += ","), i += u;
        else {
          let c = Ap(a), l = _p(a), p = `${c}||${l}()`;
          i && (i += ","), i += `${p}`;
        }
        s.push(a);
      }
      return {
        expression: "(" + i + "," + n + ")",
        rawExpression: n,
        thunkDependencies: s,
      };
    }
    enterFunction(t, n, r) {
      let s = t.args[0], i = this.chunk.getInstruction(s), o = [];
      for (let u = 0; u < i.signature.argTypes.length; u++) o.push(n + u + 1);
      let a = OO(this.chunk, n, t, o);
      this.recursiveFunctionInfo.push({
        fn: s,
        argBlockvars: o,
        reachConditions: a,
        returnType: t.valueType,
        executionMode: r,
      });
    }
    exitFunction() {
      this.recursiveFunctionInfo.pop();
    }
  };
  function jg(e) {
    let t = new D0(e), n = Zg(t);
    return t.finish(n);
  }
  var D0 = class extends wp {
    constructor(n) {
      super(n, false);
      this.constants = [];
    }
    finish(n) {
      return { source: n, constants: this.constants };
    }
    printValue(n) {
      return AO(n);
    }
    beforeBeginLoop() {}
    checkFiniteBounds(n, r, s) {
      let i = `}else if(!isFinite(${s}-${r})){
`;
      for (let o = 2; o < n.args.length; o++) {
        let a = n.endIndex + o - 1;
        if (a >= this.chunk.instructionsLength() || !this.referenced[a]) {
          continue;
        }
        let u = this.chunk.getInstruction(a);
        if (u.type !== 47) continue;
        let c = fn(a);
        io(u.valueType)
          ? i += `${c}=${this.printValue(ls(u.valueType))};
`
          : i += `throw new Error('Cannot set ${c} of type ${
            at(u.valueType)
          } to NaN value');
`;
      }
      return i;
    }
    emitConstant(n) {
      return n.valueType === Number || n.valueType === Bool ||
          n.valueType === Point ||
          n.valueType === Point3D
        ? this.printValue(n.value)
        : (this.constants.push(Vo(n.value)),
          `_C[${this.constants.length - 1}]`);
    }
    emitNeg(n) {
      return `-${n}`;
    }
    emitTernary(n, r, s) {
      return `${n}?${r}:${s}`;
    }
    emitVec2(n, r) {
      return `[${n},${r}]`;
    }
    emitVec3(n, r, s) {
      return `[${n},${r},${s}]`;
    }
    emitVecAccess(n, r) {
      return `${n}[${r}]`;
    }
    emitBinary(n, r, s) {
      switch (n.type) {
        case 8:
          return `${r}+${s}`;
        case 9:
          return `${r}-${s}`;
        case 10:
          return `${r}*${s}`;
        case 11:
          return `${r}/${s}`;
        case 12:
          return `BuiltIn.pow(${r},${s})`;
        case 13:
          return `Math.pow(${r},${s})`;
        case 25:
          return `${r}===${s}`;
        case 26:
          return `${r}<${s}`;
        case 28:
          return `${r}<=${s}`;
        case 27:
          return `${r}>${s}`;
        case 29:
          return `${r}>=${s}`;
        case 31:
          return `${r}||${s}`;
        case 32:
          return `${r}&&${s}`;
        default:
          throw new Error("Programming Error: invalid binary opcode.");
      }
    }
    emitList(n) {
      return `[${n.join(",")}]`;
    }
    emitListAccess(n, r, s) {
      let i = `${n}.length`, o = `Math.floor(${r})`;
      return `(${o}>=1&&${o}<=${i})?${n}[${o}-1]:${s}`;
    }
    emitInboundsListAccess(n, r) {
      return `${n}[${r}-1]`;
    }
    emitNativeFunction(n, r) {
      let s = Bn[r.symbol];
      return `${s.module}.${s.symbol}(${n.join(",")})`;
    }
    emitExtendSeed(n, r, s, i) {
      let o = r === Number
        ? s
        : `BuiltIn.serializeNonNumericSeedPart(${r},${s})`;
      return `${n}+'::${i}'+${o}`;
    }
    emitVarDeclaration(n, r) {
      let s = r ? "," : "var ";
      return s += fn(n), s;
    }
    emitImmediateAssignment(n, r, s) {
      return `var ${r}=${s};`;
    }
    emitFunctionCall(n, r, s, i) {
      return `${n}(${r}, ${s}, ${i.join(",")})`;
    }
  };
  function AO(e) {
    if (Array.isArray(e)) return `[${e.map(AO).join(",")}]`;
    switch (typeof e) {
      case "boolean":
      case "number":
        return e.toString();
      case "string":
        return `${JSON.stringify(e)}`;
      case "object":
        if (gu(e)) throw new Error("Action values cannot be compiled");
        return V(e).toString();
      default:
        throw new Error("Unexpected value: " + e);
    }
  }
  function Jg(e) {
    let t = e.getInstruction(e.getReturnIndex());
    if (t.type !== 47) throw new Error(`Expected BlockVar, got ${t.type}`);
    let n = e.getInstruction(t.args[0]);
    if (n.type !== 51) throw new Error(`Expected EndMap, got ${n.type}`);
    let r = j(t.valueType) ? Ve(t.valueType) : t.valueType,
      s = e.getInstruction(n.args[0]);
    if (s.type !== 50) throw new Error(`Expected BeginMap, got ${s.type}`);
    let i = [];
    for (let p of s.args) {
      let f = e.getInstruction(p);
      if (!Je(f) || f.valueType !== Number) {
        throw U("Programming error: interval bounds must be constant numbers");
      }
      i.push(V(f.value));
    }
    let o, a;
    r === MapIntervalPoint || r === MapIntervalComplex ||
      r === MapIntervalPoint3D
      ? (o = ["t"], a = { type: "1d", min: i[0], max: i[1] })
      : (o = ["u", "v"],
        a = { type: "2d", uMin: i[0], uMax: i[1], vMin: i[2], vMax: i[3] });
    let u = jg(e),
      c = `
  const mapFn = (function() {
    "use strict";
    ${u.source}
  })();
  return mapFn(${o.join(",")});
`,
      l = {};
    return {
      args: o,
      source: c,
      constants: u.constants,
      executionMetadata: l,
      fn: wf(o, c, u.constants, l),
      domain: a,
    };
  }
  function Xk(e) {
    for (let t = 0; t < this.length; t++) e(this.elementAt(t), t);
  }
  function Zk(e) {
    let t = [];
    for (let n = 0; n < this.length; n++) t.push(e(this.elementAt(n), n));
    return t;
  }
  var on = class e extends Yt {
    constructor(n) {
      super();
      this.isError = false;
      this.eachElement = Xk;
      this.mapElements = Zk;
      if (n.getError()) {
        throw new Error(
          "Programming error: IRExpression should not be constructed with an error chunk",
        );
      }
      if (
        this.warning = n.getWarning(),
          this._chunk = n,
          this.valueType = n.getReturnType(),
          this.addDependencies(n.getLiveArgNames()),
          this.isList = j(this.valueType),
          this.isList &&
          (this.length = this._chunk.getConstantListLength(),
            this.length === void 0)
      ) throw RP(n.getListLengthDependencies());
      rO(n);
      let r = n.isConstant();
      this.isConstant = r &&
        (this.valueType === Number || this.valueType === Bool),
        this.isTypedConstant = r,
        this.isEmptyAction = r && this.valueType === Action &&
          Object.keys(n.asValue().updateRules).length === 0;
    }
    shouldExportAns() {
      return true;
    }
    getCompiledFunction(n) {
      return ua(this.valueType)
        ? Jg(this._chunk)
        : this._chunk.getCompiledFunction(n);
    }
    getRestrictedFunctionForGLSL(n, r) {
      return this._chunk.getRestrictedFunctionForGLSL(n, r);
    }
    polynomialOrder(n) {
      return this._chunk.polynomialOrder(n, {
        allowRestriction: true,
        allowClosedBlockReferences: false,
      });
    }
    getPolynomialCoefficients(n) {
      let r = this._chunk.getPolynomialCoefficients(n),
        s = r.chunk,
        i = r.coefficients,
        o = [];
      for (let a = 0; a < i.length; a++) {
        let u = s.copy();
        u.setReturnIndex(i[a]), u.fuseBroadcast(), o.push(new e(u));
      }
      return o;
    }
    takeDerivative(n) {
      let r = this._chunk.copy().takeDerivative(n).fuseBroadcast();
      return new e(r);
    }
    gradient(n) {
      let r = this._chunk.copy().gradient(n).fuseBroadcast();
      return new e(r);
    }
    toImplicitBool() {
      let n = this._chunk.copy();
      return n.GreaterEqual([n.getReturnIndex(), n.Constant(0)]),
        n.fuseBroadcast(),
        new e(n);
    }
    interpretWithParameters(n) {
      let r, s = this._chunk.argNames;
      if (n.length === s.length) r = n;
      else {
        r = [];
        let i = this.getDependencies();
        for (let o = 0, a = 0; o < s.length; o++) {
          i[a] === s[o] ? (r.push(n[a]), a += 1) : r.push(void 0);
        }
      }
      return this._chunk.interpretWithParameters(r);
    }
    substituteConstantArguments(n) {
      return new e(this._chunk.substituteConstantArguments(n));
    }
    boundDomain(n) {
      return this._chunk.boundDomain(n);
    }
    asValue() {
      if (this._chunk.isConstant()) return this._chunk.asValue();
      if (this.isList) {
        let n = [], r = Vo(ls(Ve(this.valueType)));
        for (let s = 0; s < this.length; s++) n.push(r);
        return n;
      } else return Vo(ls(this.valueType));
    }
    asTypedValue() {
      return { valueType: this.valueType, value: this.asValue() };
    }
    asCompilerValue() {
      return this._chunk.asCompilerValue();
    }
    isNaN() {
      return typeof this.asValue() == "number" && isNaN(this.asValue());
    }
    getEvaluationInfo() {
      return this._chunk.isConstant() && this.getDependencies().length === 0 &&
          (se(this.valueType, Number) || se(this.valueType, Bool) ||
            se(this.valueType, Complex))
        ? [{ val: this.asValue() }]
        : false;
    }
    findLinearSubset(n) {
      return this._chunk.findLinearSubset(n);
    }
    deriveRegressionRestrictions() {
      let n = this._chunk.deriveRegressionRestrictions();
      return n === this._chunk ? this : new e(n);
    }
    getCursorContext() {
      return this._chunk.getCursorContext();
    }
    getRecursiveFunctionMetadata() {
      let n = this._chunk.getInstruction(this._chunk.getReturnIndex());
      if (n.type === 55) {
        return this._chunk.getRecursiveFunctionMetadata(n.args[0]);
      }
    }
    coerceToNumericIfPossible() {
      if (
        se(this.valueType, AngleMarker) ||
        se(this.valueType, DirectedAngleMarker) ||
        se(this.valueType, Complex)
      ) {
        let n = this._chunk.copy(), r = n.getReturnIndex();
        return n.coerceToNumericIfPossible() === r ? this : new e(n);
      } else return this;
    }
    slot(n) {
      let r = this._chunk.copy();
      return r.setReturnIndex(r.Slot(n, [r.getReturnIndex()])), new e(r);
    }
  };
  function Wk(e) {
    let t = 1 / 0;
    for (let n = 0; n < e.length; n++) {
      (e[n].isList || e[n].isBroadcast) && (t = Math.min(t, e[n].length));
    }
    return t;
  }
  var Bf = class Bf extends Q {
    constructor(n) {
      super(n);
      this.isList = true;
      this.length = n.length;
    }
    asValue() {
      let n = [];
      for (let r = 0; r < this.args.length; r++) n.push(this.args[r].asValue());
      return n;
    }
    asCompilerValue() {
      let n = [];
      for (let r = 0; r < this.args.length; r++) {
        n.push(this.args[r].asCompilerValue());
      }
      return n;
    }
    getEvaluationInfo() {
      if (this.args.every((n) => n.isConstant)) {
        return [{ val: this.args.map((n) => n.asValue()) }];
      }
    }
  };
  Bf.eachArgs = function (n, r) {
    let s = Wk(n);
    if (!isFinite(s)) {
      r(n);
      return;
    }
    for (let i = 0; i < s; i++) {
      let o = [];
      for (let a = 0; a < n.length; a++) {
        o.push(n[a].isList || j(n[a].valueType) ? n[a].elementAt(i) : n[a]);
      }
      r(o, i);
    }
  },
    Bf.wrap = function (n) {
      return n.isList || j(n.valueType) ? n : new Bf([n]);
    };
  var lo = Bf;
  var Go = class extends Q {
    constructor(t) {
      super(t), this.list = t[0], this.index = t[1];
    }
  };
  var Ja = class extends Q {
    constructor(n, r, s, i, o = []) {
      super([n, r].concat(s), { skipRegisterDependencies: true });
      this.shouldCoerceToList = i;
      this.parameters = o;
      this._index = n,
        this._body = r,
        this._inputLists = s,
        this.registerDependencies();
    }
    registerDependencies() {
      let n = [];
      for (let i of this._inputLists) {
        let o = i._symbol;
        n.push(o);
      }
      for (let i of this.parameters) {
        let o = i.identifier._symbol;
        n.push(o);
      }
      this.addOptionalDependencies(n);
      let s = [this._index._symbol, ...n];
      for (let i of this._inputLists) {
        this.mergeDependenciesInScope(this.type, s, i.args[1]);
      }
      for (let i of this.parameters) {
        this.mergeDependenciesInScope(this.type, s, i.bounds[0]),
          this.mergeDependenciesInScope(this.type, s, i.bounds[1]);
      }
      this.mergeDependenciesInScope(this.type, s, this._body);
    }
  };
  var Qg = class extends Et {
    constructor() {
      super(...arguments);
      this.is_mixed_number = true;
    }
  };
  var Kg = class extends ao {
    constructor(n, r, s) {
      super(n);
      this.isTypedConstant = true;
      this.isMovablePoint = true;
      this.moveStrategy = r, this.defaultDragMode = s, this.valueType = Point;
    }
    asValue() {
      return [+this.args[0].asValue(), +this.args[1].asValue()];
    }
    asTypedValue() {
      return { valueType: this.valueType, value: this.asValue() };
    }
    asCompilerValue() {
      return [this.args[0].asCompilerValue(), this.args[1].asCompilerValue()];
    }
  };
  var Fp = class extends Q {};
  var Vp = class extends Q {};
  var Bp = class extends Q {};
  var Gp = class extends Q {};
  var kp = class extends Q {};
  var ul = class extends Q {
    constructor(t, n) {
      super(n), this.order = t;
    }
  };
  var Bu = class extends Q {
    constructor(t) {
      super(t, { skipRegisterDependencies: true }),
        this._index = t[0],
        this.registerDependencies();
    }
    registerDependencies() {
      for (let t = 1; t <= 3; t++) {
        this.mergeDependenciesInScope(
          this.type,
          [this._index._symbol],
          this.args[t],
        );
      }
    }
  };
  var Hp = class extends Bu {
    constructor() {
      super(...arguments);
      this.in_place_operator = "*=";
      this.starting_value = 1;
    }
    evaluateConstant(n) {
      let r = 1 + Math.round(n[1]) - Math.round(n[0]);
      return r <= 0 ? this.starting_value : Math.pow(n[2], r);
    }
    update(n, r) {
      return n * r;
    }
  };
  var zp = class extends Q {
    constructor(t) {
      super(t), this.beginning = t[0], this.end = t[1];
    }
    isHalfEmpty() {
      return this.end && this.end.args && this.end.args.length === 0;
    }
  };
  var eh = class extends Lu {};
  var cl = class extends Q {
    constructor(n) {
      let r = new Et(n);
      super([r]);
      this.value = n;
      this._constantNode = r;
    }
    asValue() {
      return this._constantNode.asValue();
    }
    asCompilerValue() {
      return this._constantNode.asCompilerValue();
    }
  };
  var Up = class extends Q {};
  var ll = class extends Q {
    constructor(n) {
      typeof n != "string" && (n = "" + n);
      super([]);
      this.isString = true;
      this._stringValue = n;
    }
    asValue() {
      return this._stringValue;
    }
  };
  var Gu = class extends gn {
    constructor(t, n) {
      super(t, n), this.seed = n[0];
    }
  };
  var th = class extends ja {
    constructor(n, r) {
      super(new we(n._symbol), n._expression);
      this.isSlider = true;
      this.setInputSpan(n._inputSpan),
        this.sliderAssignment = n,
        this.sliderMin = r.sliderMin,
        this.sliderMax = r.sliderMax,
        this.sliderSoftMin = r.sliderSoftMin,
        this.sliderSoftMax = r.sliderSoftMax,
        this.sliderStep = r.sliderStep,
        this.sliderIsPlayingOnce = r.sliderIsPlayingOnce,
        this.sliderMin && this.mergeDependencies(this.sliderMin),
        this.sliderMax && this.mergeDependencies(this.sliderMax),
        this.sliderStep && this.mergeDependencies(this.sliderStep);
    }
    shouldPromoteToSlider(n) {
      return false;
    }
    asAssignment() {
      return new ja(this._symbol, this._expression);
    }
  };
  var nh = class extends Yt {
    constructor(t, n, r, s) {
      super(),
        this._symbol = t,
        this._expression = n,
        this.otherVariableSolutionData = r,
        this.mergeDependencies(n),
        this.branchMultiplier = s;
    }
  };
  var qp = class extends Q {
    constructor(t) {
      super(t), this._symbol = "stats";
    }
  };
  var xa = class extends Q {
    constructor(t, n) {
      super([t].concat(n), { skipRegisterDependencies: true }),
        this._body = t,
        this._assignments = n,
        this.registerDependencies();
    }
    registerDependencies() {
      let t = [];
      for (let n = 0; n < this._assignments.length; n++) {
        let r = this._assignments[n], s = r._lhs, i = r._rhs;
        if (ki(s)) {
          let o = r._symbol;
          t.push(o), this.mergeDependencies(i);
        } else if (Qv(s)) this.mergeDependencies(r);
        else {throw new Error(
            `Unexpected LHS in assignment expression: ${s.type}`,
          );}
        this.addSubstitutionDependencies(i.getDependencies());
      }
      this.addOptionalDependencies(t),
        this.mergeDependenciesInScope(this.type, t, this._body);
    }
  };
  var $p = class extends Bu {
    constructor() {
      super(...arguments);
      this.in_place_operator = "+=";
      this.starting_value = 0;
    }
    evaluateConstant(n) {
      let r = 1 + Math.round(n[1]) - Math.round(n[0]);
      return r <= 0 ? this.starting_value : r * n[2];
    }
    update(n, r) {
      return n + r;
    }
  };
  var Yp = class extends Yt {
    constructor(n, r, s, i) {
      super();
      this.calcColumns = r;
      this.regression = s;
      this.exportPenalty = 1;
      this.isTable = true;
      this.columns = n,
        this.mergeDependencies.apply(this, n),
        this.localFrameID = i;
    }
    getExports() {
      return [];
    }
    getColumnIdsForGraphing() {
      return this.columns.map((n) => n.userData.id);
    }
    getColumnStatementIds() {
      return this.calcColumns.map((n) => n.userData.id);
    }
    getRegressionId() {
      var n;
      return (n = this.regression) == null ? void 0 : n.userData.id;
    }
  };
  var rh = class extends Yt {
    constructor(t) {
      super(),
        this.handler = t.handler,
        this.minStep = t.minStep,
        this.mergeDependencies(this.handler),
        this.mergeDependencies(this.minStep);
    }
  };
  var Xp = class extends Q {
    constructor(t) {
      super(t), this._symbol = "ttest";
    }
  };
  var Zp = class extends Q {
    constructor(t) {
      super(t, { skipRegisterDependencies: true }),
        this._symbol = t[0]._symbol,
        this._expression = t[1],
        this.registerDependencies();
    }
    registerDependencies() {
      this.addUpdateSymbol(this._symbol),
        this.mergeDependencies(this._expression);
    }
  };
  var ku = class extends Yt {
    constructor(t, n) {
      super(),
        this._symbol = t._symbol,
        this.mergeDependencies(t, n),
        this._lhs = t,
        this._rhs = n;
    }
    asComparator() {
      return new ps["="]([this._lhs, this._rhs]);
    }
  };
  var br = "i",
    ko = class extends Q {
      constructor() {
        super([]);
      }
    };
  var pl = class extends Q {
    constructor(n, r, s) {
      super(n);
      this.isTypedConstant = true;
      this.isMovablePoint = true;
      this.moveStrategy = r, this.defaultDragMode = s, this.valueType = Complex;
    }
    asValue() {
      return [+this.args[0].asValue(), +this.args[1].asValue()];
    }
    asTypedValue() {
      return { valueType: this.valueType, value: this.asValue() };
    }
    asCompilerValue() {
      return [this.args[0].asCompilerValue(), this.args[1].asCompilerValue()];
    }
    getEvaluationInfo() {
      return [{ val: this.asValue() }];
    }
  };
  var Ho = class extends Q {
    constructor(t, n) {
      super(n), this.symbol = t;
    }
  };
  function lt(e, t) {
    switch (e) {
      case Number:
      case Bool:
        return new C.Constant(t);
      case SeedType:
        return new C.Seed(t);
      case Complex:
        return new C.Add([
          lt(Number, t[0]),
          new C.Multiply([lt(Number, t[1]), new C.ImaginaryUnit()]),
        ]);
      case Point:
        return new C.ParenSeq([lt(Number, t[0]), lt(Number, t[1])]);
      case Point3D:
        return new C.ParenSeq([
          lt(Number, t[0]),
          lt(Number, t[1]),
          lt(Number, t[2]),
        ]);
      case Segment3D:
        return new C.FunctionCall("segment", [
          lt(Point3D, t[0]),
          lt(Point3D, t[1]),
        ]);
      case Vector3D:
        return new C.FunctionCall("vector", [
          lt(Point3D, t[0]),
          lt(Point3D, t[1]),
        ]);
      case Triangle3D:
        return new C.FunctionCall("triangle", [
          lt(Point3D, t[0]),
          lt(Point3D, t[1]),
          lt(Point3D, t[2]),
        ]);
      case Sphere3D:
        return new C.FunctionCall("sphere", [
          lt(Point3D, t[0]),
          lt(Number, t[1]),
        ]);
      case RGBColor:
        return new C.FunctionCall("rgb", [
          lt(Number, t[0]),
          lt(Number, t[1]),
          lt(Number, t[2]),
        ]);
      case Polygon:
        return new C.FunctionCall("polygon", [lt(ListOfPoint, t)]);
      case Segment:
        return new C.FunctionCall("segment", [
          lt(Point, t[0]),
          lt(Point, t[1]),
        ]);
      case Line:
        return new C.FunctionCall("line", [lt(Point, t[0]), lt(Point, t[1])]);
      case Ray:
        return new C.FunctionCall("ray", [lt(Point, t[0]), lt(Point, t[1])]);
      case Vector:
        return new C.FunctionCall("mathVector", [
          lt(Point, t[0]),
          lt(Point, t[1]),
        ]);
      case Circle:
        return new C.FunctionCall("circle", [
          lt(Point, t[0]),
          lt(Number, t[1]),
        ]);
      case Arc:
        return new C.FunctionCall("arc", [
          lt(Point, t[0]),
          lt(Point, t[1]),
          lt(Point, t[2]),
        ]);
      case AngleMarker:
        return new C.FunctionCall("angle", [
          lt(Point, t[0]),
          lt(Number, t[1]),
          lt(Number, t[2]),
        ]);
      case DirectedAngleMarker:
        return new C.FunctionCall("directedangle", [
          lt(Point, t[0]),
          lt(Number, t[1]),
          lt(Number, t[2]),
        ]);
      case EmptyList:
      case ListOfNumber:
      case ListOfBool:
      case ListOfComplex:
      case ListOfPoint:
      case ListOfColor:
      case ListOfPolygon:
      case ListOfSegment:
      case ListOfLine:
      case ListOfRay:
      case ListOfVector:
      case ListOfAngleMarker:
      case ListOfDirectedAngleMarker:
      case ListOfCircle:
      case ListOfArc:
      case ListOfPoint3D:
      case ListOfSegment3D:
      case ListOfVector3D:
      case ListOfTriangle3D:
      case ListOfSphere3D:
      case ListOfTone: {
        let r = [], s = Ve(e);
        for (let i of t) r.push(lt(s, i));
        return new C.List(r);
      }
      case Any:
      case Distribution:
      case ListOfAny:
      case ListOfDistribution:
      case Action:
      case Transformation:
      case ListOfTransformation:
      case ErrorType:
      case MapIntervalPoint:
      case MapIntervalComplex:
      case MapIntervalPoint3D:
      case MapInterval2ToPoint:
      case MapInterval2ToComplex:
      case MapInterval2DPoint3D:
      case ListOfMapIntervalPoint:
      case ListOfMapIntervalComplex:
      case ListOfMapIntervalPoint3D:
      case ListOfMapInterval2ToPoint:
      case ListOfMapInterval2ToComplex:
      case ListOfMapInterval2DPoint3D:
      case Restriction:
      case ListOfRestriction:
        throw new Error(
          `Programming error: cannot create parse node from valueType: ${
            at(e)
          }`,
        );
      case Tone:
        return new C.FunctionCall("tone", [lt(Number, t[0]), lt(Number, t[1])]);
      default:
        let n = e;
        throw new Error(`Programming error: unexpected valueType: ${at(n)}`);
    }
  }
  function jk(e) {
    if (!e.isTypedConstant) return new Et(NaN);
    let t = e.asTypedValue();
    return t ? lt(t.valueType, t.value) : new Et(NaN);
  }
  function Jk(e) {
    if (!e.isTypedConstant) return NaN;
    let t = e.asTypedValue();
    if (!t) return NaN;
    switch (t.valueType) {
      case Number:
        return t.value;
      case Complex:
        return t.value;
      default:
        throw U(`Unexpected type ${at(t.valueType)} in column.`);
    }
  }
  var dl = class extends lo {
    constructor(n, r) {
      super(n.map(jk));
      this.rawArgs = n;
      this.headerSymbol = r;
      this.isIndependent = r !== void 0;
    }
    asValueMixed() {
      return this.rawArgs.map(Jk);
    }
  };
  function ae(e, t) {
    let n = eO(e);
    return n.prototype.type = t, n;
  }
  var Qk = {
      Base: ae(Yt, "Base"),
      Expression: ae(Q, "Expression"),
      Error: ae(v, "Error"),
      Constant: ae(Et, "Constant"),
      MixedNumber: ae(Qg, "MixedNumber"),
      Identifier: ae(we, "Identifier"),
      Ans: ae(Fg, "Ans"),
      ImaginaryUnit: ae(ko, "ImaginaryUnit"),
      List: ae(lo, "List"),
      TableColumnValue: ae(dl, "TableColumnValue"),
      Range: ae(zp, "Range"),
      ListAccess: ae(Go, "ListAccess"),
      DotAccess: ae(Ms, "DotAccess"),
      Construction: ae(rl, "Construction"),
      ParenSeq: ae(ao, "ParenSeq"),
      MovableComplexNumber: ae(pl, "MovableComplexNumber"),
      MovablePoint: ae(Kg, "MovablePoint"),
      NamedCoordinateAccess: ae(Ho, "NamedCoordinateAccess"),
      BareSeq: ae(Ru, "BareSeq"),
      Norm: ae(Bp, "Norm"),
      BaseComparator: ae(uo, "BaseComparator"),
      ComparatorChain: ae(Au, "ComparatorChain"),
      DoubleInequality: ae(Vg, "DoubleInequality"),
      RepeatedOperator: ae(Bu, "RepeatedOperator"),
      Sum: ae($p, "Sum"),
      Product: ae(Hp, "Product"),
      Integral: ae(Rp, "Integral"),
      AssignmentExpression: ae(Mp, "AssignmentExpression"),
      ListComprehension: ae(Ja, "ListComprehension"),
      FunctionCall: ae(gn, "FunctionCall"),
      RecursiveFunctionBaseCase: ae(Qr, "RecursiveFunctionBaseCase"),
      SeededFunctionCall: ae(Gu, "SeededFunctionCall"),
      FunctionExponent: ae(wu, "FunctionExponent"),
      FunctionFactorial: ae(Fu, "FunctionFactorial"),
      Prime: ae(ul, "Prime"),
      Piecewise: ae(Fr, "Piecewise"),
      Restriction: ae(Up, "Restriction"),
      Derivative: ae(sl, "Derivative"),
      UpdateRule: ae(Zp, "UpdateRule"),
      Substitution: ae(xa, "Substitution"),
      Histogram: ae(Op, "Histogram"),
      DotPlot: ae(vp, "DotPlot"),
      BoxPlot: ae(Cp, "BoxPlot"),
      TTest: ae(Xp, "TTest"),
      IndependentTTest: ae(Np, "IndependentTTest"),
      Stats: ae(qp, "Stats"),
      Assignment: ae(ja, "Assignment"),
      FunctionDefinition: ae(Cr, "FunctionDefinition"),
      CallAssignment: ae(ku, "CallAssignment"),
      Equation: ae(Nu, "Equation"),
      Regression: ae(Pp, "Regression"),
      Image: ae(Bg, "Image"),
      Ticker: ae(rh, "Ticker"),
      Slider: ae(th, "Slider"),
      RegressionParameter: ae(cl, "RegressionParameter"),
      Table: ae(Yp, "Table"),
      TableColumn: ae(co, "TableColumn"),
      SolvedEquation: ae(nh, "SolvedEquation"),
      OptimizedRegression: ae(Wa, "OptimizedRegression"),
      Seed: ae(ll, "Seed"),
      ExtendSeed: ae(il, "ExtendSeed"),
      IRExpression: ae(on, "IRExpression"),
      Add: ae(Ep, "Add"),
      Subtract: ae(Es, "Subtract"),
      Multiply: ae(Fp, "Multiply"),
      DotMultiply: ae(_u, "DotMultiply"),
      CrossMultiply: ae(Dp, "CrossMultiply"),
      Divide: ae(Sp, "Divide"),
      Exponent: ae(Lu, "Exponent"),
      Negative: ae(Vp, "Negative"),
      Or: ae(Gp, "Or"),
      PercentOf: ae(kp, "PercentOf"),
      RawExponent: ae(eh, "RawExponent"),
      Comparator: {
        "<": ae(ps["<"], "Comparator['<']"),
        ">": ae(ps[">"], "Comparator['>']"),
        "<=": ae(ps["<="], "Comparator['<=']"),
        ">=": ae(ps[">="], "Comparator['>=']"),
        "=": ae(ps["="], "Comparator['=']"),
      },
    },
    C = Qk;
  var F1 = {};
  ia(F1, { parse: () => Mi, setInput: () => $A });
  var Dr = { xmin: -5, xmax: 5, ymin: -5, ymax: 5, zmin: -5, zmax: 5 };
  function S0(e, t) {
    let n = Math.round(1e6 * e) / 1e6;
    return Math.abs(n - e) < t ? n : e;
  }
  function $j(e) {
    let t = true, n = true, r = true;
    return e.hardMin !== void 0 && e.target < e.hardMin && (t = false),
      e.hardMax !== void 0 && e.target > e.hardMax && (n = false),
      e.step &&
      sh({
          target: e.target,
          step: e.step,
          hardMin: t ? e.hardMin : void 0,
          hardMax: n ? e.hardMax : void 0,
        }) !== e.target &&
      (r = false),
      { min: t, max: n, step: r };
  }
  function sh(e) {
    let { target: t, hardMin: n, hardMax: r, step: s } = e, i = 1e-10;
    if (
      n !== void 0 && r !== void 0 && (i = Math.min(i, Math.abs(r - n) / 1e3)),
        s && (i = Math.min(i, s / 10)),
        n !== void 0 && (n = S0(n, i)),
        r !== void 0 && (r = S0(r, i)),
        e.forceSliderToMax && r !== void 0 && (t = r),
        n > r || t <= n
    ) return n;
    if (t >= r) return r;
    if (s) {
      let a = n !== void 0 ? n : 0, u = Math.round((t - a) / s);
      t = s * u + a;
    }
    let o = S0(t, i);
    return (s || n === o || r === o) && (t = o), t <= n ? n : t >= r ? r : t;
  }
  function _O(e) {
    let { storedMax: t, sliderValue: n, hardMin: r, step: s } = e,
      i = e.is3d ? Dr.xmax : 10;
    if (t > i && (i = t), n > i && (i = n), r > i && (i = r), s) {
      let o = sh({ target: i, hardMin: r, hardMax: void 0, step: s });
      o >= i ? i = o : i = o + s;
    }
    return i;
  }
  var Qa = { coerceToNumber: "all" };
  C.Base.prototype.tryGetConcreteTree = function (e, t, n = {}) {
    let r;
    try {
      r = this.getConcreteTree(e, t, n);
    } catch (s) {
      s instanceof C.Base ? r = s : r = U(s);
    }
    return r;
  };
  C.Base.prototype.getConcreteTree = function (e, t, n = {}) {
    let r = this.buildIRExpression(e, t, { coerceToNumber: n.coerceToNumber });
    if (r.isError) throw r;
    return r;
  };
  C.DoubleInequality.prototype.getConcreteTree = function (e, t) {
    return new this.constructor([
      new C.Piecewise([this._indicator, this._expressions[0], new Et(NaN)])
        .getConcreteTree(e, t),
      this._operators[0],
      new we(this._symbol),
      this._operators[1],
      new C.Piecewise([this._indicator, this._expressions[1], new Et(NaN)])
        .getConcreteTree(e, t),
    ]);
  };
  C.Error.prototype.getConcreteTree = function (e, t) {
    return this;
  };
  function Gf(e, t) {
    return e.isError ? e : t.indexOf(e.valueType) === -1 ? Fd() : e;
  }
  C.Image.prototype.getConcreteTree = function (e, t) {
    let n = this.center.tryGetConcreteTree(e, t),
      r = this.radianAngle.tryGetConcreteTree(e, t, Qa),
      s = this.width.tryGetConcreteTree(e, t, Qa),
      i = this.height.tryGetConcreteTree(e, t, Qa),
      o = this.opacity.tryGetConcreteTree(e, t, Qa),
      a = [Point, ListOfPoint, EmptyList],
      u = [Number, ListOfNumber, EmptyList];
    return n = Gf(n, a),
      r = Gf(r, u),
      s = Gf(s, u),
      i = Gf(i, u),
      o = Gf(o, u),
      new C.Image({
        center: n,
        radianAngle: r,
        width: s,
        height: i,
        opacity: o,
      }, this.moveStrategy);
  };
  C.Ticker.prototype.getConcreteTree = function (e, t) {
    let n = this.handler.tryGetConcreteTree(e, t);
    !n.isError && n.valueType !== Action && (n = kd(oe(n.valueType)));
    let r = n.getDependencies().filter((s) =>
      !(e.graphingEnabled() && e.validActionVariable(s))
    );
    return r.length && (n = rn(e.sliderVariables(r)).setDependencies(r)),
      new C.Ticker({
        handler: n,
        minStep: this.minStep.tryGetConcreteTree(e, t, Qa),
      });
  };
  function v0(e, t, n) {
    if (!t) {
      n.valids[e] = true;
      return;
    }
    let r = t.getDependencies();
    if (t.isError) n.errors[e] = true;
    else if (r.length > 0) {
      n.errors[e] = true;
      for (let s = 0; s < r.length; s++) {
        r[s] === n.exportedSymbol
          ? n.errors.cycle = true
          : n.missingVars.push(r[s]);
      }
    } else n.values[e] = +t.asValue();
    n.valids[e] = isFinite(n.values[e]), n.valids[e] || (n.values[e] = void 0);
  }
  function ih(e) {
    return e && e.valueType === ListOfNumber && e.length === 1 && e.args
      ? e.args[0]
      : e;
  }
  C.Slider.prototype.getConcreteTree = function (e, t) {
    let n = this._expression.getConcreteTree(e, t),
      r = ih(this.sliderMin && this.sliderMin.tryGetConcreteTree(e, t, Qa)),
      s = ih(this.sliderMax && this.sliderMax.tryGetConcreteTree(e, t, Qa)),
      i = ih(this.sliderStep && this.sliderStep.tryGetConcreteTree(e, t, Qa)),
      o = {
        exportedSymbol: this._symbol,
        errors: {},
        values: {},
        valids: {},
        missingVars: [],
        errMsg: void 0,
      };
    if (
      v0("min", r, o),
        v0("max", s, o),
        v0("step", i, o),
        i && o.valids.step && (o.values.step === 0
          ? delete o.values.step
          : o.values.step = Math.abs(o.values.step)),
        o.errors.cycle
          ? n = SI(o.exportedSymbol)
          : (o.errors.min || !o.valids.min
            ? o.errMsg = vI()
            : o.errors.max || !o.valids.max
            ? o.errMsg = OI()
            : (o.errors.step || !o.valids.step) && (o.errMsg = RI()),
            o.values.min > o.values.max &&
            (o.valids.min = false,
              o.valids.max = false,
              o.errMsg || (o.errMsg = NI()))),
        n.isConstant
    ) {
      let u = t.initialEvaluation && t.initialEvaluation.asValue() &&
          this.sliderIsPlayingOnce,
        c = o.values.max,
        l = +n.asValue(),
        p = o.values.min,
        f = o.values.step;
      if (u && !isFinite(c)) {
        let m = ih(
          this.sliderSoftMax && this.sliderSoftMax.tryGetConcreteTree(e, t, Qa),
        );
        m &&
          (c = _O({
            storedMax: +m.asValue(),
            sliderValue: l,
            step: f,
            hardMin: p,
            is3d: e.is3dProduct(),
          }));
      }
      let d = sh({
          target: l,
          hardMin: p,
          hardMax: c,
          step: f,
          forceSliderToMax: !!u,
        }),
        y = Qc(d.toString()),
        g = isFinite(V(y)) ? y : d;
      n = new Et(g).getConcreteTree(e, t);
    }
    return n.sliderInfo = o, n;
  };
  function LO(e, t) {
    if (!t[this._symbol]) throw Li(this._symbol, e);
    let n = this.args.map((r) => r.getConcreteTree(e, t));
    if (n.length > 0) {
      if (
        n.length === 1 && n.push(new C.Constant(1).getConcreteTree(e, t)),
          n[1].getDependencies().length
      ) throw Qd(this._symbol).setDependencies(n[1].getDependencies());
      if (n[1].valueType !== Number) throw Qd(this._symbol);
      let r = n[1].asValue();
      if (!isFinite(r) || r <= 0) throw Qd(this._symbol);
    }
    return this.typeCheck(e, n), new this.constructor(n);
  }
  C.Histogram.prototype.getConcreteTree = LO;
  C.DotPlot.prototype.getConcreteTree = LO;
  C.BoxPlot.prototype.getConcreteTree = function (e, t) {
    if (!t[this._symbol]) throw Li(this._symbol, e);
    let n = this.args.map((r) => r.getConcreteTree(e, t));
    return this.typeCheck(e, n),
      n.length === 1 &&
        (n[0].valueType === ListOfNumber || n[0].valueType === EmptyList)
        ? new this.constructor(n)
        : U("Failed to copmile BoxPlot");
  };
  function O0(e, t) {
    if (!t[this._symbol]) throw Li(this._symbol, e);
    let n = this.args.map((r) => r.getConcreteTree(e, t));
    return this.typeCheck(e, n), new this.constructor(n);
  }
  C.TTest.prototype.getConcreteTree = O0;
  C.IndependentTTest.prototype.getConcreteTree = O0;
  C.Stats.prototype.getConcreteTree = O0;
  C.Table.prototype.getConcreteTree = function (e, t) {
    let n = [];
    for (let i of this.columns) {
      let o = ga(i) && ki(i.header) ? t[i.header._symbol] : void 0;
      o && ha(o) ? n.push(o) : n.push(i.tryGetConcreteTree(e, t));
    }
    let r = 1;
    for (let i of n) i.isList && (r = Math.max(i.length, r));
    let s = [];
    for (let i of n) s.push(eH(i, r));
    return new C.Table(s, this.calcColumns, this.regression, this.localFrameID);
  };
  function eH(e, t) {
    if (Kr(e)) return e;
    if (ha(e)) return e;
    if (e.isList) {
      let n;
      if (e instanceof lo) n = e.mapElements((r) => r);
      else if (e instanceof on) n = e.mapElements((r) => r);
      else return U(`Unexpected parse node type ${e.type} with isList: true`);
      return new C.TableColumnValue(n, void 0);
    } else if (e.isTypedConstant) {
      let n = [];
      for (let r = 0; r < t; r++) n.push(e);
      return new dl(n, void 0);
    } else {return U(
        `Invalid column: expected an error, constant, or list but got:
 ${e.repr("", 1)}`,
      );}
  }
  C.TableColumn.prototype.getConcreteTree = function (e, t) {
    var r;
    let n = this.header.tableError();
    if (n) return KI(n);
    if (this.header instanceof C.Identifier) {
      let s = t[this.header._symbol];
      if (s && t.hasOwnProperty(this.header._symbol) && Kr(s)) return s;
    }
    if (this.isFreeVariable(t)) {
      if (this.columnIndex === 0) {
        let i = this.header._symbol;
        if (!e.validFirstColumnVariable(i)) return eP();
      }
      let s = [];
      for (let i = 0; i < this.values.length; i++) {
        if (this.values[i].tableError()) {
          s.push(Wd(this.values[i].tableError()));
          continue;
        }
        let o = this.values[i].tryGetConcreteTree(e, t);
        o.isError
          ? s.push(o)
          : o.tableError()
          ? s.push(Wd(o.tableError()))
          : o.valueType === Number || o.valueType === Complex
          ? s.push(o)
          : s.push(bT([oe(o.valueType)]));
      }
      for (let i = 0; i < s.length; i++) {
        if (s[i].isError) continue;
        let o = this.values[i] && this.values[i].tableError();
        if (o) {
          s[i] = Wd(o);
          continue;
        }
        let a = s[i].getDependencies();
        a.length && (s[i] = rn(a).setDependencies(a));
      }
      return new dl(s, this.header._symbol);
    } else {
      let s = this.header.getConcreteTree(e, t, {
        coerceToNumber: "all-except-complex",
      });
      return !s.isError && s.valueType !== Number &&
          s.valueType !== ListOfNumber &&
          s.valueType !== Complex && s.valueType !== ListOfComplex &&
          s.valueType !== EmptyList
        ? hT([oe((r = s.valueType) != null ? r : Any)])
        : s.getDependencies().length > 0
        ? rn(s.getDependencies()).setDependencies(s.getDependencies())
        : s;
    }
  };
  var Ka;
  function wO(e) {
    Ka = e;
  }
  function FO() {
    Ka && (Ka.cacheHits += 1);
  }
  function VO() {
    Ka && (Ka.cacheMisses += 1);
  }
  function BO() {
    Ka && (Ka.cacheWrites += 1);
  }
  function GO() {
    Ka && (Ka.cacheReads += 1);
  }
  var kO = {
    segment: true,
    ray: true,
    vector: true,
    line: true,
    circle: true,
    arc: true,
    polygon: true,
    glider: true,
    midpoint: true,
    intersection: true,
    strictintersection: true,
    perpendicular: true,
    parallel: true,
    translate: true,
    rotate: true,
    dilate: true,
    reflect: true,
    apply: true,
    segments: true,
    vertices: true,
    angle: true,
    angles: true,
    directedangle: true,
    directedangles: true,
    clockwise: true,
    counterclockwise: true,
    reflex: true,
    start: true,
    end: true,
    anglebisector: true,
  };
  function zo(e) {
    switch (e.type) {
      case "simple":
        return;
      case "list-access":
        return e.listIndex;
      case "polygon-edge":
        return zo(e.polygon);
      case "arbitrary-expression":
        return;
      default:
        throw new Error(`Unexpected parent type: ${e.type}`);
    }
  }
  function Ta(e) {
    switch (e.type) {
      case "simple":
      case "list-access":
        return e.identifier;
      case "polygon-edge":
        return Ta(e.polygon);
      default:
        throw new Error(`Unexpected parent type: ${e.type}`);
    }
  }
  var Wp = {
    simple: (e) => ({ type: "simple", identifier: e }),
    listAccess: (e, t) => ({
      type: "list-access",
      identifier: e,
      listIndex: t,
    }),
    polygonEdge: (e, t) => ({
      type: "polygon-edge",
      polygon: { type: "simple", identifier: e },
      edgeIndex: t,
    }),
    polygonListItemEdge: (e, t) => ({
      type: "polygon-edge",
      polygon: { type: "list-access", identifier: e, listIndex: t.listIndex },
      edgeIndex: t.edgeIndex,
    }),
    arbitraryExpression: (e) => ({
      type: "arbitrary-expression",
      latex: e.getInputString(),
    }),
  };
  function tH(e) {
    return e !== void 0 && e in kO;
  }
  function kf(e) {
    return tH(e)
      ? e === "rotate" || e === "dilate" || e === "translate" || e === "reflect"
        ? true
        : false
      : false;
  }
  function oh(e) {
    if (e instanceof Go && e.list instanceof we && e.index instanceof Et) {
      return Wp.listAccess(e.list._symbol, e.index.asValue());
    }
    if (e instanceof Go && e.list instanceof Ms && e.index instanceof Et) {
      let t = e.list.args[0], n = e.list.args[1];
      if (t instanceof we && n instanceof we && n._symbol === "segments") {
        return Wp.polygonEdge(t._symbol, e.index.asValue());
      }
      if (t instanceof Go && t.list instanceof we && t.index instanceof Et) {
        return Wp.polygonListItemEdge(t.list._symbol, {
          listIndex: t.index.asValue(),
          edgeIndex: e.index.asValue(),
        });
      }
    }
    return e.type === "Identifier"
      ? Wp.simple(e._symbol)
      : Wp.arbitraryExpression(e);
  }
  function ah(e) {
    let t = {}, n = e;
    if (
      (n instanceof ja || n instanceof Cr) &&
      (t.identifier = n._symbol, n = n._expression),
        n instanceof Go && n.index instanceof Et &&
        (t.listAccess = n.index.asValue(), n = n.list),
        n instanceof gn
    ) {
      let r = n._symbol,
        s = n.args[0] instanceof we ? n.args[0]._symbol : void 0;
      if (kf(r) && e instanceof Cr && s && e._argSymbols.some((i) => i === s)) {
        t.tree = { symbol: r, parents: n.args.slice(1).map(oh) };
      } else if (kO[r]) t.tree = { symbol: r, parents: n.args.map(oh) };
      else {
        let i = Wp.simple(n._symbol);
        t.tree = { symbol: "apply", parents: [i, ...n.args.map(oh)] };
      }
    } else if (n instanceof Ms) {
      let r = n.args.map(oh);
      r.length === 2 && r[1] && r[1].type === "simple" &&
        r[1].identifier === "segments"
        ? t.tree = { symbol: "segments", parents: [r[0]] }
        : r.length === 2 && r[1] && r[1].type === "simple" &&
            r[1].identifier === "start"
        ? t.tree = { symbol: "start", parents: [r[0]] }
        : r.length === 2 && r[1] && r[1].type === "simple" &&
          r[1].identifier === "end" &&
          (t.tree = { symbol: "end", parents: [r[0]] });
    }
    return t;
  }
  function UO(e, t, n, r, s) {
    let i = se(n, Circle) || se(n, Arc), o = se(s, Circle) || se(s, Arc);
    if (!i && !o) return;
    let a = zO(e, t, n),
      u = zO(e, r, s),
      c = a.filter((l) => {
        let p = Ta(l);
        return p ? u.some((f) => ws(l, f)) && !!e.lookup(p) : false;
      });
    for (let l of a) HO(e, l, r) && c.every((p) => !ws(l, p)) && c.push(l);
    for (let l of u) HO(e, l, t) && c.every((p) => !ws(l, p)) && c.push(l);
    if (c.length === 1) return c[0];
  }
  function HO(e, t, n) {
    let r = Ta(t),
      s = r !== void 0 ? e.lookup(r) : void 0,
      i = s && e.getGeometryTree(s);
    return ((i == null ? void 0 : i.symbol) === "glider" ||
      (i == null ? void 0 : i.symbol) === "intersection" ||
      (i == null ? void 0 : i.symbol) === "strictintersection" ||
      (i == null ? void 0 : i.symbol) === "midpoint") &&
      (i == null ? void 0 : i.parents.some((o) => {
        if (o.type === "arbitrary-expression") return false;
        let a = Ta(o);
        return a && e.resolvesTo(a, n) &&
          (zo(t) === void 0 || zo(o) === void 0 || zo(o) === zo(t));
      }));
  }
  function zO(e, t, n) {
    var i;
    let r = [],
      s = ((i = e.getGeometryTree(t)) == null ? void 0 : i.parents) || [];
    for (let o = 0; o < s.length; o++) {
      let a = s[o];
      if (
        se(n, Circle) && o === 0 || a.type === "arbitrary-expression" ||
        a.type === "polygon-edge"
      ) continue;
      let u = Ta(a);
      if (!u) continue;
      let c = e.lookup(u);
      c && e.isPointOrListOfPoints(c) && r.push(a);
    }
    return r;
  }
  function jp(e) {
    if (e.length === 0) return EmptyList;
    if (e.includes(Complex)) return ListOfComplex;
    let t = e[0];
    if (t !== Number && kn(t, Number)) {
      for (let n of e) {
        let r = fu(t, n);
        r !== void 0 && (t = r);
      }
    }
    return wn(t) ? vn(t) : ListOfAny;
  }
  function qO(e) {
    let t = [];
    for (let n of e) n !== EmptyList && (j(n) ? t.push(Ve(n)) : t.push(n));
    return jp(t);
  }
  function uh(e, t) {
    if (j(e)) {
      let n = Ve(e);
      for (let r = 0; r < t.length; r++) if (Br(n, t[r])) return true;
      return false;
    }
    return Br(e, t);
  }
  function Br(e, t) {
    switch (e) {
      case Number:
        return Ii(t);
      case Restriction:
        return t;
      case Complex:
      case Point: {
        let [n, r] = t;
        return Ii(n) || Ii(r);
      }
      case Point3D: {
        let [n, r, s] = t;
        return Ii(n) || Ii(r) || Ii(s);
      }
      case RGBColor: {
        let [n, r, s] = t;
        return Ii(n) || Ii(r) || Ii(s);
      }
      case Polygon: {
        for (let n of t) if (Br(Point, n)) return true;
        return false;
      }
      case Sphere3D: {
        let [n, r] = t;
        return Br(Point3D, n) || Br(Number, r);
      }
      case Triangle3D: {
        let [n, r, s] = t;
        return Br(Point3D, n) || Br(Point3D, r) || Br(Point3D, s);
      }
      case Segment3D:
      case Vector3D: {
        let [n, r] = t;
        return Br(Point3D, n) || Br(Point3D, r);
      }
      case Segment:
      case Line:
      case Ray:
      case Vector: {
        let [n, r] = t;
        return Br(Point, n) || Br(Point, r);
      }
      case Circle: {
        let [n, r] = t;
        return Br(Point, n) || Br(Number, r);
      }
      case Arc: {
        let [n, r, s] = t;
        return Br(Point, n) || Br(Point, r) || Br(Point, s);
      }
      case AngleMarker:
      case DirectedAngleMarker: {
        let [n, r, s] = t;
        return Br(Point, n) || Br(Number, r) || Br(Number, s);
      }
      case Action:
        return Object.keys(t.updateRules).length === 0;
      case Bool:
      case Distribution:
      case SeedType:
      case Transformation:
      case MapIntervalPoint:
      case MapIntervalComplex:
      case MapIntervalPoint3D:
      case MapInterval2ToPoint:
      case MapInterval2ToComplex:
      case MapInterval2DPoint3D:
        return false;
      case Tone: {
        let [n, r] = t;
        return Ii(n) || Ii(r);
      }
      default:
        throw new Error("Type cannot contain a NaN value: " + oe(e) + ".");
    }
  }
  function po(e, t) {
    return e.pushLeafInstruction(t);
  }
  function _n(e, t, n) {
    switch (t.type) {
      case 8:
        return e.Add(n);
      case 9:
        return e.Subtract(n);
      case 10:
        return e.Multiply(n);
      case 11:
        return e.Divide(n);
      case 12:
        return e.Exponent(n);
      case 13:
        return e.RawExponent(n);
      case 14:
        return e.Negative(n);
      case 25:
        return e.Equal(n);
      case 26:
        return e.Less(n);
      case 27:
        return e.Greater(n);
      case 28:
        return e.LessEqual(n);
      case 29:
        return e.GreaterEqual(n);
      case 31:
        return e.Or(n);
      case 32:
        return e.And(n);
      case 33:
        return e.Piecewise(n);
      case 47:
        return e.BlockVar(t.valueType, n);
      case 48:
        return e.BroadcastResult(t.valueType, n);
      case 15:
        return e.TupleOfType(t.valueType, n);
      case 16:
        return e.Slot(t.index, n);
      case 37:
        return e.NativeFunction(t.symbol, n);
      case 42:
        return e.Distribution(t.symbol, n);
      case 21:
        return e.BeginIntegral(t.callData, n);
      case 22:
        return e.EndIntegral(n);
      case 23:
        return e.BeginBroadcast(n, t.context);
      case 24:
        return e.EndBroadcast(n);
      case 19:
        return e.BeginLoop(t.callData, n);
      case 20:
        return e.EndLoop(n);
      case 38:
        return e.List(n);
      case 39:
        return e.ListAccess(n);
      case 40:
        return e.DeferredListAccess(n);
      case 41:
        return e.InboundsListAccess(n);
      case 44:
        return e.ExtendSeed(t.tag, n);
      case 49:
        return e.Action(t.symbols, n);
      case 50:
        return e.BeginMap(t.callData, n);
      case 51:
        return e.EndMap(n);
      case 53:
        return e.BeginFunction(n);
      case 54:
        return e.EndFunction(n);
      case 55:
        return e.FunctionCall(n);
      default:
        let r = t;
        throw new Error(`Unexpected opcode ${r.type}`);
    }
  }
  function $O(e, t, n) {
    let r = e.argNames.indexOf(t);
    if (r === -1) return 0;
    let s = ns(e, r, n);
    return ln(s, e.getReturnIndex());
  }
  function ns(e, t, { allowRestriction: n, allowClosedBlockReferences: r }) {
    return {
      chunk: e,
      argIndex: t,
      orderTable: [],
      mask: Vu(e, t),
      allowRestriction: n,
      allowClosedBlockReferences: r,
    };
  }
  function ln(e, t) {
    let n = e.orderTable[t];
    if (n !== void 0) return n;
    let r = nH(e, t);
    return e.orderTable[t] = r, r;
  }
  function nH(e, t) {
    let {
      chunk: n,
      mask: r,
      argIndex: s,
      allowRestriction: i,
      allowClosedBlockReferences: o,
    } = e;
    if (!o && n.isInClosedBlock(t)) return 1 / 0;
    if (t === s) return 1;
    if (!r[t]) return 0;
    let a = n.getInstruction(t);
    if (es(a) || ds(a)) return 1 / 0;
    switch (a.type) {
      case 8:
      case 9:
      case 26:
      case 28:
      case 27:
      case 29: {
        let [c, l] = a.args;
        return Math.max(ln(e, c), ln(e, l));
      }
      case 10: {
        let [c, l] = a.args;
        return ln(e, c) + ln(e, l);
      }
      case 14:
        return ln(e, a.args[0]);
      case 11: {
        let [c, l] = a.args;
        return ln(e, l) > 0 ? 1 / 0 : ln(e, c);
      }
      case 12:
      case 13: {
        let [c, l] = a.args, p = n.getInstruction(l);
        if (ln(e, c) === 0 && ln(e, l) === 0) return 0;
        if (p.type === 1) {
          let f = V(p.value);
          return f === Math.round(f) && f > 0 ? ln(e, c) * f : 1 / 0;
        } else return 1 / 0;
      }
      case 33: {
        let c = n.getInstruction(a.args[2]);
        return i && c.type === 1 && isNaN(V(c.value))
          ? ln(e, a.args[1])
          : 1 / 0;
      }
      case 16:
      case 37:
      case 2:
      case 0:
      case 1:
      case 25:
      case 32:
      case 31:
      case 15:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 48:
      case 47:
      case 3:
      case 44:
      case 49:
      case 4:
      case 55:
        return 1 / 0;
      default:
        let u = a;
        throw new Error(`Unexpected opcode ${u.type}`);
    }
  }
  function YO(e, t) {
    let n = e.argNames.indexOf(t),
      r = e.getReturnIndex(),
      s = fo(
        ns(e, n, { allowRestriction: true, allowClosedBlockReferences: false }),
        r,
      );
    if (ln(s.orderCtx, r) > 2) {
      throw new Error(
        "Programming Error: cannot compute polynomial coefficients for polynomials of order greater than 2",
      );
    }
    let i = Kn(s, r), o = false;
    for (let a = 0; a < e.instructionsLength(); a++) {
      e.getInstruction(a).type === 33 && s.mask[a] && (o = true);
    }
    return {
      chunk: s.newChunk,
      coefficients: i,
      mappedArgIndex: s.valueMap[n],
      mappedReturnIndex: s.valueMap[r],
      isRestrictedPolynomial: o,
    };
  }
  function fo(e, t) {
    let { chunk: n, argIndex: r } = e, s = Vr(n, t);
    if (n.isInClosedBlock(r)) {
      throw new Error(
        "Programming Error: cannot find polynomial coefficients of an instruction in a closed block",
      );
    }
    let i, o;
    r >= 0 && r < n.argNames.length
      ? (i = n.argNames.slice(),
        o = n.argTypes.slice(),
        i.splice(r, 1),
        o.splice(r, 1))
      : (i = n.argNames, o = n.argTypes);
    let a = new Ia({ argNames: i, argTypes: o }), u = [];
    for (let d = 0; d < n.instructionsLength(); d++) {
      if (!s[d]) continue;
      let y = n.getInstruction(d);
      if (y.type === 2) {
        d < r || r < 0
          ? u[d] = d
          : d === r
          ? u[d] = a.SymbolicVar(n.argTypes[d])
          : u[d] = d - 1;
      } else if (ge(y)) u[d] = po(a, y);
      else {
        let g = [];
        for (let m of y.args) g.push(u[m]);
        u[d] = _n(a, y, g);
      }
    }
    let c = [], l = a.Constant(0), p = a.Constant(1), f = a.Constant(NaN);
    return {
      chunk: n,
      newChunk: a,
      orderCtx: e,
      coefficientTable: c,
      mask: e.mask,
      valueMap: u,
      argIndex: r,
      zero: l,
      one: p,
      nan: f,
    };
  }
  function Kn(e, t) {
    let {
        newChunk: n,
        orderCtx: r,
        coefficientTable: s,
        mask: i,
        valueMap: o,
        argIndex: a,
        zero: u,
        one: c,
        nan: l,
      } = e,
      p = s[t];
    if (p !== void 0) return p;
    let f;
    for (
      i[t]
        ? t === a ? f = [u, c] : ln(r, t) > 2 ? f = [l] : f = rH(e, t)
        : f = [o[t]];
      f.length > 1;
    ) {
      let d = n.getInstruction(f[f.length - 1]);
      if (d.type === 1 && V(d.value) === 0) f.pop();
      else break;
    }
    if (f.length === 0) {
      throw new Error("Programming Error: coefficients cannot be empty");
    }
    return s[t] = f, f;
  }
  function rH(e, t) {
    let n = e.chunk.getInstruction(t), { newChunk: r } = e;
    switch (n.type) {
      case 8: {
        let [i, o] = n.args,
          a = Kn(e, i),
          u = Kn(e, o),
          c = a.length - 1,
          l = u.length - 1,
          p = [];
        for (let f = 0; f <= Math.max(c, l); f++) {
          c >= f && l >= f
            ? p.push(r.Add([a[f], u[f]]))
            : p.push(c > l ? a[f] : u[f]);
        }
        return p;
      }
      case 9:
      case 26:
      case 28:
      case 27:
      case 29: {
        let [i, o] = n.args;
        (n.type === 26 || n.type == 28) && ([i, o] = [o, i]);
        let a = Kn(e, i),
          u = Kn(e, o),
          c = a.length - 1,
          l = u.length - 1,
          p = [];
        for (let f = 0; f <= Math.max(c, l); f++) {
          c >= f && l >= f
            ? p.push(r.Subtract([a[f], u[f]]))
            : p.push(c > l ? a[f] : r.Negative([u[f]]));
        }
        return p;
      }
      case 14: {
        let i = n.args[0], o = Kn(e, i), a = [];
        for (let u = 0; u < o.length; u++) a.push(r.Negative([o[u]]));
        return a;
      }
      case 10: {
        let [i, o] = n.args,
          a = Kn(e, i),
          u = Kn(e, o),
          c = a.length - 1,
          l = u.length - 1,
          p = [];
        for (let f = 0; f <= c; f++) {
          for (let d = 0; d <= l; d++) {
            if (f + d > 2) continue;
            let y = r.Multiply([a[f], u[d]]), g = p[f + d];
            g === void 0 ? p[f + d] = y : p[f + d] = r.Add([g, y]);
          }
        }
        return p;
      }
      case 11: {
        let [i, o] = n.args, a = Kn(e, i), u = Kn(e, o), c = [];
        for (let l = 0; l < a.length; l++) c.push(r.Divide([a[l], u[0]]));
        return c;
      }
      case 12:
      case 13: {
        let [i, o] = n.args, a = Kn(e, i), u = Kn(e, o);
        if (a.length - 1 === 0) return [r.RawExponent([a[0], u[0]])];
        let l = r.getInstruction(u[0]);
        switch (V(l.value)) {
          case 0:
            return [r.Constant(1)];
          case 1:
            return a;
          case 2:
            return [
              r.Multiply([a[0], a[0]]),
              r.Multiply([r.Constant(2), r.Multiply([a[0], a[1]])]),
              r.Multiply([a[1], a[1]]),
            ];
        }
      }
      case 33:
        return Kn(e, n.args[1]);
      case 37:
      case 16:
      case 0:
      case 23:
      case 2:
      case 1:
      case 25:
      case 32:
      case 31:
      case 15:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 21:
      case 22:
      case 19:
      case 20:
      case 24:
      case 48:
      case 47:
      case 3:
      case 44:
      case 49:
      case 50:
      case 51:
      case 4:
      case 53:
      case 54:
      case 55:
        throw new Error(
          `Cannot find polynomial coefficients of opcode ${n.type} that depends on symbol.`,
        );
      default:
        let s = n;
        throw new Error(`Unexpected opcode ${s.type}`);
    }
  }
  function XO(e, t, n) {
    let r = e.argNames.indexOf(t);
    if (r === -1) {
      let o = e.getInstruction(n);
      return o.type === 1 ? R0(o.valueType, o.value) : dr();
    }
    let s = ns(e, r, {
        allowRestriction: true,
        allowClosedBlockReferences: false,
      }),
      i = sH(s, n);
    return Ds(i, n);
  }
  function sH(e, t) {
    let { chunk: n, mask: r } = e;
    return { chunk: n, mask: r, orderCtx: e, domainTable: [], index: t };
  }
  function Ds(e, t) {
    let { domainTable: n } = e, r = n[t];
    if (r !== void 0) return r;
    let s = iH(e, t);
    return n[t] = s, s;
  }
  function iH(e, t) {
    let { chunk: n, mask: r, orderCtx: s } = e, i = n.getInstruction(t);
    switch (i.type) {
      case 1:
        return R0(i.valueType, i.value);
      case 3:
      case 2:
        return i.valueType === Number ? aa() : dr();
      case 0:
        return dr();
      case 31:
        return Sd(Ds(e, i.args[0]), Ds(e, i.args[1]));
      case 32:
      case 8:
      case 9:
      case 10:
        return Gn(Ds(e, i.args[0]), Ds(e, i.args[1]));
      case 11: {
        let o = Gn(Ds(e, i.args[0]), Ds(e, i.args[1])),
          a = n.getInstruction(i.args[1]);
        return a.type === 1 && a.valueType === Number && V(a.value) !== 0
          ? o
          : Gn(dr(), o);
      }
      case 14:
        return Ds(e, i.args[0]);
      case 15: {
        let o = i.valueType;
        switch (o) {
          case Point:
          case Point3D:
            return oH(e, i.args);
          case Complex:
            return N0(e, i.args);
          default:
            let a = o;
            throw new Error(`Unexpected tuple type ${a}`);
        }
      }
      case 12:
      case 13:
      case 47:
      case 48:
      case 16:
      case 42:
      case 21:
      case 22:
      case 23:
      case 24:
      case 19:
      case 20:
      case 39:
      case 40:
      case 41:
      case 44:
      case 50:
      case 51:
      case 54:
      case 55:
        return N0(e, i.args);
      case 4:
      case 53:
        return dr();
      case 49:
        return dr();
      case 38:
        return i.args.length === 1 ? Ds(e, i.args[0]) : dr();
      case 25:
        return dr();
      case 33:
        return OD(Ds(e, i.args[0]), Ds(e, i.args[1]), Ds(e, i.args[2]));
      case 26:
      case 27:
      case 28:
      case 29: {
        if (!r[t]) return aa();
        let o = Gn(Ds(e, i.args[0]), Ds(e, i.args[1]));
        if (ln(s, t) > 1) return Gn(dr(), o);
        let a = e.coefficientCtx;
        a === void 0 && (a = fo(s, e.index), e.coefficientCtx = a);
        let u = a.newChunk, c = Kn(a, t), [l, p] = c;
        if (!Je(u.getInstruction(l))) return Gn(dr(), o);
        let f = hn(u, l);
        if (isNaN(f)) return ka();
        if (p === void 0) {
          return i.type === 28 || i.type === 29
            ? f >= 0 ? o : ka()
            : f > 0
            ? o
            : ka();
        }
        {
          let d = hn(u, p);
          return Gn(o, Hl(f, d));
        }
      }
      case 37:
        switch (i.symbol) {
          case "restriction":
          case "restrictionToBoolean":
            return Ds(e, i.args[0]);
          case "count":
            return aa();
          default:
            return Bn[i.symbol].noPeel ? dr() : N0(e, i.args);
        }
    }
  }
  function oH(e, t) {
    let n = aa();
    for (let r of t) n = Gn(n, Ds(e, r));
    return n;
  }
  function N0(e, t) {
    let n = dr();
    for (let r of t) n = Gn(n, Ds(e, r));
    return n;
  }
  function R0(e, t) {
    if (j(e)) return t.length === 1 ? R0(Ve(e), t[0]) : dr();
    switch (e) {
      case Number:
      case Point:
      case Point3D:
        return uh(e, t) ? ka() : aa();
      case Bool:
        return t ? aa() : ka();
      default:
        return dr();
    }
  }
  var Hf = [oi(Number), oi(Number)],
    A0 = [
      ...Pi([
        [Te, Te],
        [Complex, Complex],
        [Point, Number],
        [Number, Point],
        [Number, Vector],
        [Number, Vector3D],
        [Vector, Number],
        [Vector3D, Number],
        [Point3D, Number],
        [Number, Point3D],
        [Restriction, Tf],
        [Tf, Restriction],
      ]),
      kt([Restriction, If]),
      kt([If, Restriction]),
    ],
    _0 = {
      Negative: Pi([[Te], [Complex], [Point], [Vector], [Vector3D], [Point3D]]),
      Add: Pi([[Te, Te], [Complex, Complex], [Point, Point], [Vector, Vector], [
        Vector3D,
        Vector3D,
      ], [Point3D, Point3D]]),
      Subtract: Pi([
        [Te, Te],
        [Complex, Complex],
        [Point, Point],
        [Vector, Vector],
        [Vector3D, Vector3D],
        [Point3D, Point3D],
      ]),
      Multiply: A0,
      DotMultiply: [
        ...Pi([[Vector, Vector], [Vector3D, Vector3D], [Point3D, Point3D]]),
        ...A0,
      ],
      CrossMultiply: [
        ...Pi([[Vector3D, Vector3D], [Point3D, Point3D]]),
        ...Pi([
          [Te, Te],
          [Complex, Complex],
          [Point, Number],
          [Number, Point],
          [Vector, Number],
          [Number, Vector],
          [Vector3D, Number],
          [Number, Vector3D],
          [Restriction, Tf],
          [Tf, Restriction],
        ]),
        kt([Restriction, If]),
        kt([If, Restriction]),
      ],
      Divide: Pi([
        [Te, Te],
        [Complex, Complex],
        [Point, Number],
        [Vector, Number],
        [Vector3D, Number],
        [Point3D, Number],
      ]),
      Exponent: Pi([[Te, Te], [Complex, Complex]]),
      "Comparator['=']": [kt(Hf)],
      "Comparator['>']": [kt(Hf)],
      "Comparator['<']": [kt(Hf)],
      "Comparator['>=']": [kt(Hf)],
      "Comparator['<=']": [kt(Hf)],
      ComparatorChain: Pi([{
        type: "variadic",
        initial: [Number, Number],
        rest: Number,
      }]),
      PercentOf: A0,
      Norm: Pi([[Number], [Point], [Point3D], [Vector], [Vector3D]]),
      ListAccess: [kt([ii, oi(Qn.of([Bool, Number]))])],
      Integral: Pi([[
        Number,
        Number,
        Qn.of(ql, { coerceComplexToReal: false }),
      ]]),
    };
  function Pi(e) {
    return e.map((t) => Ae(t));
  }
  function ch(e, t, n) {
    if (t instanceof lo) {
      let r = n.filter((i) => i !== void 0);
      if (r.length === 0) return;
      let s = jp(r);
      return j(s) && s !== ListOfAny
        ? Hu([kt({ type: "variadic", initial: [], rest: Ve(s) })], n)
        : [];
    } else if (t instanceof gn || t instanceof Gu || t instanceof Ms) {
      let r = t instanceof Ms ? t.args[1]._symbol : t._symbol;
      if (!r) return;
      let s = Rf(e, r);
      return s ? Hu(s, n) : void 0;
    } else if (t instanceof Fr) {
      let [r, s, i] = n, o = s !== void 0 && i !== void 0 ? Ha(s, i) : void 0;
      !o && i === Number && t.args[2] instanceof Et && t.args[2].isNaN() &&
        (i = void 0);
      let a;
      if (o !== void 0) a = o;
      else if (s !== void 0) a = s;
      else if (i !== void 0) a = i;
      else return;
      j(a) && (a = Ve(a));
      let u = wn(a) ? oi(a) : a;
      return Hu([kt([oi(Bool), u, u])], [n[0], s, i]);
    } else if (e.is3dProduct() && t instanceof _u) {
      let r = [..._0.DotMultiply, Ae([Point, Point])];
      return Hu(r, n);
    } else if (t instanceof ao) {
      let r = [
        kt({ type: "variadic", initial: [Action], rest: Action }),
        Ae([Number, Number]),
      ];
      return e.is3dProduct() && r.push(Ae([Number, Number, Number])), Hu(r, n);
    } else if (t instanceof Ru) {
      let r = [kt({ type: "variadic", initial: [Action], rest: Action })],
        s = n.filter((i) => i !== void 0 && i !== Number);
      if (s.length > 0) {
        let i = jp(s);
        j(i) && i !== ListOfAny &&
          r.push(kt({ type: "variadic", initial: [], rest: Ve(i) }));
      }
      return Hu(r, n);
    } else if (t instanceof Ho) {
      let r = t.symbol, s;
      switch (r) {
        case "x":
        case "y":
          s = Pi([[Point], [Point3D]]);
          break;
        case "z": {
          s = Pi([[Point3D]]);
          break;
        }
        default: {
          let i = r;
          throw new Error(
            `Programming Error: unexpected named coordinate: '${i}'.`,
          );
        }
      }
      return Hu(s, n);
    } else if (t.type in _0 && n.some((r) => r !== void 0)) {
      let r = _0[t.type];
      return r ? Hu(r, n) : void 0;
    }
  }
  function Hu(e, t) {
    return e.filter((n) => n.matches(t));
  }
  function WO(e, t, n, r) {
    if (!JO(e, n, r)) return;
    let s = t.type;
    switch (s) {
      case "Comparator['>']":
      case "Comparator['<']":
      case "Comparator['>=']":
      case "Comparator['<=']": {
        e.setWarning(
          E("shared-calculator-error-complex-operation-undefined", {
            symbol: formatSymbol(t.operator),
          }),
        );
        break;
      }
      case "ComparatorChain": {
        let [i] = t.symbols;
        if (i === void 0 || i === "=") break;
        e.setWarning(
          E("shared-calculator-error-complex-operation-undefined", {
            symbol: formatSymbol(i),
          }),
        );
        break;
      }
      case "ParenSeq":
        e.setWarning(E("shared-calculator-error-complex-point-coordinate"));
        break;
      case "Integral":
        switch (QO(e, n, r)) {
          case 0:
            e.setWarning(
              E("shared-calculator-error-integral-lower-bound-type-error", {
                symbol: oe(e.getInstruction(n[0]).valueType),
              }),
            );
            break;
          case 1:
            e.setWarning(
              E("shared-calculator-error-integral-upper-bound-type-error", {
                symbol: oe(e.getInstruction(n[1]).valueType),
              }),
            );
            break;
          default:
            break;
        }
        break;
      case "ListAccess":
        e.setWarning(E("shared-calculator-error-complex-list-access"));
        break;
      case "CrossMultiply":
      case "DotMultiply":
      case "Multiply":
      case "PercentOf":
        if (n.length !== 2) break;
        e.setWarning(
          E("shared-calculator-error-multiply-type-error", ZO(e, n)),
        );
        break;
      case "Divide":
        if (n.length !== 2) break;
        e.setWarning(E("shared-calculator-error-divide-type-error", ZO(e, n)));
        break;
      case "Sum":
      case "Product":
      case "Range":
        break;
      case "DotAccess":
      case "FunctionCall":
      case "SeededFunctionCall":
        break;
      case "Comparator['=']":
      case "Add":
      case "Subtract":
      case "Exponent":
      case "Negative":
      case "Or":
      case "Piecewise":
      case "Restriction":
      case "List":
      case "TableColumnValue":
      case "Norm":
      case "BareSeq":
      case "NamedCoordinateAccess":
      case "Ans":
      case "Constant":
      case "ImaginaryUnit":
      case "Assignment":
      case "RecursiveFunctionBaseCase":
      case "MixedNumber":
      case "Identifier":
      case "Construction":
      case "ListComprehension":
      case "FunctionExponent":
      case "FunctionFactorial":
      case "Prime":
      case "Derivative":
      case "UpdateRule":
      case "Substitution":
      case "FunctionDefinition":
      case "Slider":
      case "RegressionParameter":
      case "Seed":
      case "ExtendSeed":
        break;
      default:
    }
  }
  function jO(e, t, n, r, s) {
    if (t === "sort") {
      let i;
      if (r.length === 1) i = r[0];
      else if (r.length === 2) i = r[1];
      else return;
      KO(e.getInstruction(i)) &&
        e.setWarning(
          E("shared-calculator-error-complex-sort", {
            symbol: formatSymbol(n),
          }),
        );
      return;
    }
    if (JO(e, r, s)) {
      switch (t) {
        case "factorial":
        case "erf":
        case "nCr":
        case "nPr":
          e.setWarning(
            E("shared-calculator-error-complex-operation-unimplemented", {
              symbol: formatSymbol(n),
            }),
          );
          break;
        case "round":
          e.setWarning(
            E("shared-calculator-error-complex-round", {
              symbol: formatSymbol(n),
            }),
          );
          break;
        default:
          e.setWarning(
            E("shared-calculator-error-complex-operation-undefined", {
              symbol: formatSymbol(n),
            }),
          );
          break;
      }
    }
  }
  function JO(e, t, n) {
    return QO(e, t, n) !== -1;
  }
  function QO(e, t, n) {
    if (n.length === 0) return -1;
    let r = n[0];
    for (let s = 0; s < t.length; s++) {
      let i = t[s], o = r.argTypeAtIndex(s);
      if (
        !(o === Number || o === ListOfNumber ||
          typeof o == "object" && o.coerceComplexToReal)
      ) continue;
      let u = e.getInstruction(i);
      if (KO(u)) return s;
    }
    return -1;
  }
  function KO(e) {
    if (e.type !== 1) return false;
    switch (e.valueType) {
      case Complex:
        return V(e.value[1]) !== 0;
      case ListOfComplex:
        return e.value.some((t) => V(t[1]) !== 0);
      default:
        return false;
    }
  }
  function ZO(e, t) {
    let n = e.getInstruction(t[0]), r = e.getInstruction(t[1]);
    return { symbol1: oe(n.valueType), symbol2: oe(r.valueType) };
  }
  function tN(e, t, n, r, s, i) {
    var x, T, b, M;
    if (n = _g(t, n), !el(n) && !Tp(n) || kf(n)) return;
    let o,
      a = false,
      u = false,
      c = 0,
      l = [],
      p = [],
      f = s.map((P) => e.getInstruction(P).valueType),
      d = el(n) ? Fo[n] : void 0;
    if (
      d &&
      (a = d.isSeeded,
        o = void 0,
        l.push(...d.getSignatures(t)),
        c = (T = (x = d.defaultArguments) == null ? void 0 : x.length) != null
          ? T
          : 0,
        p = lh(l, f, c),
        u = d.allowDotCall),
        p.length === 0 && (d != null && d.fallthroughUnlessDistribution) &&
        f.length > 0 && se(f[0], Distribution)
    ) {
      l = l.filter((P) => {
        let D = P.argTypeAtIndex(0);
        return D === void 0 ? false : Mc(Distribution, D);
      }), p = [];
    } else if (Tp(n) && p.length === 0) {
      let P = Bn[n];
      o = P.tag,
        l.push(...l0(n)),
        c = (M = (b = P.defaultArguments) == null ? void 0 : b.length) != null
          ? M
          : 0,
        p = lh(l, f, c),
        u = u || P.allowDotCall;
    }
    let y = Math.min(...l.map((P) => P.minArity)),
      g = Math.max(...l.map((P) => {
        var D;
        return (D = P.maxArity) != null ? D : 1 / 0;
      })),
      m = s,
      h = s;
    if (a && (h = m = s.slice(1), y -= 1, g -= 1), i) {
      if (!u) throw Gd(r);
      let P = e.getInstruction(m[0]).valueType;
      if (
        !j(P) && P !== Segment3D && P !== Vector3D && P !== Distribution &&
        P !== Tone &&
        (P === Point || !vd(P)) && n !== "real" && n !== "imag"
      ) throw tT(r, oe(P), { blockExport: e.areAllArgsConstant([m[0]]) });
      r = "." + r, h = m.slice(1), y -= 1, g -= 1;
    }
    if (
      (t.isGeometryEnabled() || t.is3dPolicy()) && n === "length" &&
      h.length === 1 && j(e.getInstruction(h[0]).valueType)
    ) {
      let P = t.is3dPolicy() ? eT : Kx;
      if (p.length === 0) {
        throw P(r, Pa(e, h)[0], { blockExport: e.areAllArgsConstant(h) });
      }
      if (h.length === 1 && e.getInstruction(h[0]).valueType === EmptyList) {
        throw P(r, Pa(e, h)[0], { blockExport: e.areAllArgsConstant(h) });
      }
    }
    if (p.length > 0) {
      jO(e, n, r, s, p);
      return;
    }
    throw L0(e, {
      symbol: n,
      errorSymbol: r,
      providedArgs: h,
      argsWithoutSeed: m,
      isDotCall: i,
      minArity: y,
      maxArity: g,
      defaultArgumentCount: c,
      builtInTag: o,
      signatures: l,
    });
  }
  function L0(
    e,
    {
      symbol: t,
      errorSymbol: n,
      providedArgs: r,
      argsWithoutSeed: s,
      isDotCall: i,
      minArity: o,
      maxArity: a,
      defaultArgumentCount: u,
      builtInTag: c,
      signatures: l,
    },
  ) {
    if (c === "doubleReducer" && r.length === 2) {
      if (
        !j(e.getInstruction(r[0]).valueType) ||
        !j(e.getInstruction(r[1]).valueType)
      ) throw jd(t, { blockExport: e.areAllArgsConstant(r) });
    } else if (
      c === "parameterizedReducer" && !i && r.length === 2 &&
      !j(e.getInstruction(r[0]).valueType)
    ) throw rP(t, { blockExport: e.areAllArgsConstant([r[0]]) });
    if (t === "logbase" && r.length !== 2) {
      return Ao("log", 1, r.length - 1, { includeUsageExample: true });
    }
    if (t === "random") return $T();
    if (r.length < o || r.length > a) {
      let {
          dotMinArityExampleArgs: g,
          dotMaxArityExampleArgs: m,
          minArityExampleArgs: h,
          maxArityExampleArgs: x,
        } = aH(t),
        T,
        b;
      if (
        r.length < o
          ? (b = o - u, i && g ? T = n + g : h && (T = n + h))
          : (b = a, i && m ? T = n + m : x && (T = n + x)),
          i && (c === "parameterizedReducer" || t === "pdf" || t === "cdf")
      ) {
        return Ao(n, b, r.length, {
          includeUsageExample: true,
          usageExample: T,
        });
      }
      if (c === "reducer" && r.length === 0) return jT(n);
      if (c === "doubleReducer") return qd(n);
      if (c === "parameterizedReducer") return WT(n);
      if (c === "color") return XT(n);
      if (el(t)) {
        switch (t) {
          case "pdf":
            return HT();
          case "cdf":
            return r.length < o ? zT() : UT();
          case "tdist":
            return qT();
          case "length":
          case "round":
          case "floor":
          case "ceil":
          case "abs":
          case "sign":
          case "mod":
          case "gcd":
          case "lcm":
          case "min":
          case "max":
          case "midpoint":
          case "segment":
          case "vector":
          case "sphere":
          case "distance":
          case "circle":
          case "center":
          case "radius":
          case "glider":
          case "intersection":
          case "strictintersection":
          case "parallel":
          case "perpendicular":
          case "anglebisector":
          case "start":
          case "end":
          case "angle":
          case "directedangle":
          case "angles":
          case "directedangles":
          case "apply":
          case "translate":
          case "reflect":
          case "dilate":
          case "rotate":
          case "normaldist":
          case "poissondist":
          case "binomialdist":
          case "uniformdist":
          case "total":
          case "mean":
          case "median":
          case "stdev":
          case "stdevp":
          case "var":
          case "varp":
          case "covp":
          case "cov":
          case "corr":
          case "mad":
          case "quantile":
          case "sort":
          case "shuffle":
          case "join":
          case "unique":
          case "polygon":
          case "coterminal":
          case "real":
          case "imag":
          case "conj":
          case "exp":
          case "sin":
          case "cos":
          case "tan":
          case "sinh":
          case "cosh":
          case "tanh":
          case "sec":
          case "csc":
          case "cot":
          case "sech":
          case "csch":
          case "coth":
          case "arccot":
          case "arcsinh":
          case "arccsch":
          case "arctan":
          case "nthroot":
          case "complexNthRoot":
            return eN(n, b, l, r.map((P) => e.getInstruction(P).valueType), T);
          case "points":
          case "lines":
          case "circles":
          case "polygons":
          case "rays":
          case "vectors":
          case "arcs":
            throw ks(n);
          case "histogram":
          case "dotplot":
          case "boxplot":
          case "ttest":
          case "ittest":
          case "stats":
          case "det":
          case "inv":
          case "transpose":
          case "rref":
          case "trace":
            throw U(`Unexpected arity error for ${t}`);
          default:
            let M = t;
            throw new Error(`Unexpected compiler function ${M}`);
        }
      }
      return eN(n, b, l, r.map((M) => e.getInstruction(M).valueType), T);
    }
    if (
      t === "polygon" && r.length === 2 &&
      e.getInstruction(r[0]).valueType === Number &&
      e.getInstruction(r[1]).valueType === Number
    ) return Ud();
    let p = [], f = [];
    for (let g = 0; g < s.length; g++) {
      let m = s[g],
        h = c !== void 0 && c !== "doubleReducer" && c !== "never-broadcast" &&
          !(c === "parameterizedReducer" && g === 0) && t !== "polygon",
        x = e.getInstruction(m).valueType;
      j(x) && h && (x = Ve(x)), p.push(x), f.push(oe(x));
    }
    let d = e.areAllArgsConstant(s), y = nN(t);
    if (y && !rN(t, l, p)) {
      let g = new v(y);
      return d ? g : g.allowExport();
    }
    return Hs(n, f, { blockExport: d });
  }
  function eN(e, t, n, r, s) {
    let i = nN(e);
    return i && !rN(e, n, r)
      ? new v(i)
      : Ao(e, t, r.length, { includeUsageExample: !i, usageExample: s });
  }
  function aH(e) {
    return el(e) ? Fo[e] : Tp(e) ? Bn[e] : {};
  }
  function lh(e, t, n) {
    return e.filter((r) => r.matches(t) && t.length + n >= r.minArity);
  }
  function nN(e) {
    switch (e) {
      case "midpoint":
        return E("shared-calculator-error-required-arguments-midpoint");
      case "intersection":
        return E("shared-calculator-error-required-arguments-intersection");
      case "segment":
      case "line":
      case "ray":
      case "distance":
        return E("shared-calculator-error-required-arguments-points", {
          symbol: e,
          count: 2,
        });
      case "parallel":
      case "perpendicular":
        return E("shared-calculator-error-required-arguments-perpendicular", {
          symbol: e,
        });
      case "circle":
        return E("shared-calculator-error-required-arguments-circle");
      case "arc":
      case "angle":
      case "directedangle":
        return E("shared-calculator-error-required-arguments-points", {
          symbol: e,
          count: 3,
        });
      case "triangle":
        return E("shared-calculator-error-required-arguments-triangle");
      case "polygon":
        return E("shared-calculator-error-required-arguments-polygon");
      case "glider":
        return E("shared-calculator-error-required-arguments-glider");
      case "vector":
        return E("shared-calculator-error-required-arguments-vector");
      case "length":
        return E("shared-calculator-error-required-arguments-length");
      case "area":
      case "perimeter":
      case "vertices":
      case "angles":
      case "directedangles":
      case "segments":
        return E("shared-calculator-error-required-arguments-area", {
          symbol: e,
        });
      case "radius":
      case "center":
        return E("shared-calculator-error-required-arguments-radius", {
          symbol: e,
        });
      case "anglebisector":
      case "coterminal":
        return E("shared-calculator-error-required-arguments-coterminal", {
          symbol: e,
        });
      case "supplement":
        return E("shared-calculator-error-required-arguments-supplement");
      case "start":
      case "end":
        return E("shared-calculator-error-required-arguments-start", {
          symbol: e,
        });
      case "dilate":
      case "rotate":
        return E("shared-calculator-error-required-arguments-dilate", {
          symbol: e,
        });
      case "reflect":
        return E("shared-calculator-error-required-arguments-reflect");
      case "translate":
        return E("shared-calculator-error-required-arguments-translate");
      case "sphere":
        return E("shared-calculator-error-required-arguments-sphere");
    }
  }
  function rN(e, t, n) {
    return e === "polygon" && (t = t.filter((s) => s.maxArity !== 1)),
      t.some((s) =>
        s.maxArity === 0 || n.length < s.minArity ? false : n.every((i, o) => {
          let a = s.argTypeAtIndex(o);
          return a === void 0 ? true : ny(i, a);
        })
      );
  }
  function Pa(e, t) {
    let n = [];
    for (let r of t) n.push(oe(e.getInstruction(r).valueType));
    return n;
  }
  function zu(e, t) {
    let n = [];
    for (let r of t) {
      let s = e.getInstruction(r).valueType, i = j(s) ? Ve(s) : s;
      n.push(oe(i));
    }
    return n;
  }
  function gt(e, t, n) {
    return se(e.getInstruction(t).valueType, n);
  }
  function Uo(e, t, n, r) {
    var l, p;
    let s = n.type;
    if (
      s === "FunctionCall" || s === "SeededFunctionCall" || s === "DotAccess"
    ) {
      let f, d;
      if (
        n instanceof Ms && (n.args[1] instanceof we || n.args[1] instanceof gn)
      ) f = n.args[1]._symbol, d = (l = n.args[1]._errorSymbol) != null ? l : f;
      else if (n instanceof gn || n instanceof Gu) {
        f = n._symbol, d = (p = n._errorSymbol) != null ? p : f;
      } else return;
      if (f === "polygon" && t.polygonUnsupportedPreferTriangle()) throw ky();
      if (
        f === "length" && !t.isGeometryEnabled() && !t.is3dPolicy() &&
        r.length === 0
      ) throw ZT();
      tN(e, t, f, d, r, n instanceof Ms);
      return;
    }
    let i = r.map((f) => e.getInstruction(f).valueType), o = ch(t, n, i);
    if (!o) return;
    let a = Math.min(...o.map((f) => f.minArity));
    if (o.length > 0 && r.length >= a) {
      WO(e, n, r, o);
      return;
    }
    let u = uH(s, i, {
        specifyPointDimensions: n instanceof Ho && n.symbol === "z",
      }),
      c = e.areAllArgsConstant(r);
    switch (s) {
      case "Add":
        throw Fx(u, { blockExport: c });
      case "Subtract":
        throw Vx(u, { blockExport: c });
      case "CrossMultiply":
        throw t.is3dProduct() && i.length === 2 &&
            (se(i[0], Point) && se(i[1], Point) ||
              se(i[0], Number) && se(i[1], Point3D) ||
              se(i[0], Point3D) && se(i[1], Number))
          ? Bx(u, { blockExport: c })
          : Vd(u, { blockExport: c });
      case "DotMultiply":
        throw Vd(u, { blockExport: c });
      case "Multiply": {
        if (t.is3dProduct() && i.length === 2) {
          if (se(i[0], Point3D) && se(i[1], Point3D)) {
            throw kx(u, { blockExport: c });
          }
          if (se(i[0], Point) && se(i[1], Point)) {
            throw Gx(u, { blockExport: c });
          }
        }
        throw Vd(u, { blockExport: c });
      }
      case "Divide":
        throw Hx(u, { blockExport: c });
      case "Exponent":
        throw zx(u, { blockExport: c });
      case "Negative":
        throw Ux(u, { blockExport: c });
      case "Comparator['=']":
      case "Comparator['>']":
      case "Comparator['<']":
      case "Comparator['>=']":
      case "Comparator['<=']":
      case "ComparatorChain":
        throw Yx(u, { blockExport: c });
      case "Or":
        throw Zx(u, { blockExport: c });
      case "Piecewise":
        throw se(i[0], Bool)
          ? gT([
            oe(e.getInstruction(r[1]).valueType),
            oe(e.getInstruction(r[2]).valueType),
          ], { blockExport: e.areAllArgsConstant([r[1], r[2]]) })
          : fy(u, { blockExport: e.areAllArgsConstant([r[0]]) });
      case "Restriction":
        throw fy(u, { blockExport: c });
      case "List":
      case "TableColumnValue": {
        sN(e, r);
        break;
      }
      case "ListAccess":
        throw Bd(u, { blockExport: c });
      case "Norm":
        throw Hs("abs", u, { blockExport: c });
      case "ParenSeq": {
        let f = i.indexOf(Action) !== -1, d = i.some((g) => g !== Action);
        if (f && d) throw yy([oe(i[0]), oe(i[1])], { blockExport: c });
        if (i.length !== 2 && (!t.is3dProduct() || i.length !== 3)) {
          let g = t.is3dPolicy() ? 3 : 2;
          throw KT(g);
        }
        let y = i.find((g) => !se(g, Number));
        throw y !== void 0
          ? Wx(oe(y), { blockExport: c })
          : U("Unexpected error type checking ParenSeq");
      }
      case "BareSeq": {
        if (i.length === 0) throw Yd();
        if (i.length === 1) throw U("Length-1 BareSeq is impossible");
        let f = i[0], d = i.find((y) => y !== f);
        if (d) throw yy([oe(f), oe(d)], { blockExport: c });
        if (f === Number) throw r.length === 2 ? JT() : QT();
        sN(e, r);
        break;
      }
      case "NamedCoordinateAccess":
        throw jx(u, "." + n.symbol, { blockExport: c });
      case "Integral": {
        let [f, d, y] = i, g = j(f) ? Ve(f) : f, m = j(d) ? Ve(d) : d;
        throw kn(g, Number)
          ? kn(m, Number)
            ? pT([oe(y)], { blockExport: c })
            : lT([oe(d)], { blockExport: c })
          : cT([oe(f)], { blockExport: c });
      }
      case "Ans":
      case "Constant":
      case "ImaginaryUnit":
      case "Assignment":
      case "RecursiveFunctionBaseCase":
      case "MixedNumber":
      case "Identifier":
      case "Construction":
      case "Range":
      case "Sum":
      case "Product":
      case "ListComprehension":
      case "FunctionExponent":
      case "FunctionFactorial":
      case "Prime":
      case "Derivative":
      case "UpdateRule":
      case "Substitution":
      case "FunctionDefinition":
      case "Slider":
      case "RegressionParameter":
      case "Seed":
      case "ExtendSeed":
      case "PercentOf":
        return;
      default: {
        let f = s;
        throw new Error(`Unexpected node type: ${f}`);
      }
    }
  }
  function sN(e, t) {
    if (t.length === 0) return;
    let n = e.getInstruction(t[0]).valueType;
    if (!wn(n)) throw vc([oe(n)], { blockExport: Je(e.getInstruction(t[0])) });
    let r = e.areAllArgsConstant(t);
    for (let s of t) {
      let i = e.getInstruction(s).valueType;
      if (!wn(i)) throw vc([oe(i)], { blockExport: r });
      if (i !== n) throw Hd({ blockExport: r });
    }
  }
  function uH(e, t, n) {
    switch (e) {
      case "Add":
      case "Subtract":
      case "Multiply":
      case "Divide":
      case "Exponent":
      case "Negative":
      case "Comparator['<']":
      case "Comparator['>']":
      case "Comparator['=']":
      case "Comparator['<=']":
      case "Comparator['>=']":
      case "NamedCoordinateAccess":
        return t.map((r) => oe(r, n));
      case "ComparatorChain": {
        for (let r = 0; r < t.length; r++) {
          if (!kn(t[r], Number) && !kn(t[r], ListOfNumber)) {
            return r === 0
              ? [oe(t[r]), oe(t[r + 1])]
              : [oe(t[r - 1]), oe(t[r])];
          }
        }
        return t.map((r) => oe(r));
      }
      case "ListAccess":
      case "Constant":
      case "ImaginaryUnit":
      case "MixedNumber":
      case "Identifier":
      case "Ans":
      case "List":
      case "TableColumnValue":
      case "Range":
      case "Construction":
      case "ParenSeq":
      case "BareSeq":
      case "Norm":
      case "Sum":
      case "Product":
      case "Integral":
      case "ListComprehension":
      case "FunctionExponent":
      case "FunctionFactorial":
      case "Prime":
      case "Piecewise":
      case "Restriction":
      case "Derivative":
      case "UpdateRule":
      case "Substitution":
      case "Assignment":
      case "RecursiveFunctionBaseCase":
      case "FunctionDefinition":
      case "Slider":
      case "RegressionParameter":
      case "Seed":
      case "ExtendSeed":
      case "DotMultiply":
      case "CrossMultiply":
      case "Or":
      case "PercentOf":
        return t.map((r) => oe(r));
      default: {
        let r = e;
        throw new Error(`Unexpected node type: ${r}`);
      }
    }
  }
  function iN(e, t) {
    let n = e.getInstruction(t);
    if (ge(n)) return;
    let r = kt(w0(e, n).expectedTypes);
    if (n.type === 49) {
      for (let u of n.args) {
        let c = e.getInstruction(u).valueType;
        if (
          !se(c, Number) && !se(c, Complex) && !se(c, Point) &&
          !se(c, Point3D) && !se(c, RGBColor) &&
          !se(c, Polygon) && !se(c, Segment) && !se(c, Line) && !se(c, Ray) &&
          !se(c, Vector) &&
          !se(c, Circle) && !se(c, Arc) && !se(c, AngleMarker) &&
          !se(c, Tone) && !se(c, DirectedAngleMarker)
        ) throw ET(oe(c));
      }
      let a = {};
      for (let u of n.symbols) {
        if (a[u]) throw CT(u);
        a[u] = true;
      }
      return;
    }
    let s = [];
    for (let a = 0; a < n.args.length; a++) {
      let u = e.getInstruction(n.args[a]).valueType, c = r.argTypeAtIndex(a);
      (c === void 0 || !Mc(u, c)) && s.push(n.args[a]);
    }
    if (s.length === 0) return;
    let i = Pa(e, n.args), o = e.areAllArgsConstant(n.args);
    switch (n.type) {
      case 32:
        throw Xx(i, { blockExport: o });
      case 22:
      case 21:
      case 44:
      case 31:
      case 15:
      case 16:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 38:
      case 39:
      case 40:
      case 41:
      case 37:
      case 42:
      case 33:
      case 48:
      case 47:
      case 23:
      case 24:
      case 19:
      case 20:
      case 50:
      case 51:
      case 53:
      case 54:
      case 55:
        throw U(`Invalid argument types for opcode ${n.type}`);
      default: {
        let a = n;
        throw new Error(`Unexpected opcode: ${a.type}`);
      }
    }
  }
  function w0(e, t, n = false) {
    switch (t.type) {
      case 8:
      case 9:
      case 10:
      case 11:
        return n && t.args.length > 0 &&
            e.getInstruction(t.args[0]).valueType === Point
          ? { expectedTypes: [Point, Point] }
          : { expectedTypes: [Number, Number] };
      case 12:
      case 13:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
        return { expectedTypes: [Number, Number] };
      case 14:
        return { expectedTypes: [Number] };
      case 31:
        return { expectedTypes: [Bool, Bool] };
      case 32:
        return { expectedTypes: [Bool, Bool] };
      case 33:
        return { expectedTypes: [Bool, t.valueType, t.valueType] };
      case 15:
        return { expectedTypes: zl[t.valueType] };
      case 21:
        return { expectedTypes: [Number, Number] };
      case 22: {
        let r = e.getInstruction(t.args[1]).valueType;
        return $l(r)
          ? { expectedTypes: [Number, r] }
          : { expectedTypes: [Number, Number] };
      }
      case 38: {
        let r = t.valueType, s = Ve(r);
        return { expectedTypes: { type: "variadic", initial: [], rest: s } };
      }
      case 39:
      case 40:
      case 41:
        return { expectedTypes: [ListOfAny, Number] };
      case 37: {
        let r = t.symbol, s = Bn[r], i = s.argumentTypes;
        return s.tag === "reducer" && !cH(e, t.args) && Array.isArray(i) &&
            typeof i[0] == "number" && j(i[0])
          ? {
            isReducerWithNoListArgs: true,
            expectedTypes: { type: "variadic", initial: [], rest: Ve(i[0]) },
          }
          : { expectedTypes: i };
      }
      case 44: {
        let r = e.getInstruction(t.args[1]).valueType;
        return { expectedTypes: [SeedType, r] };
      }
      case 47:
        return {
          expectedTypes: t.args.map((r) => e.getInstruction(r).valueType),
        };
      case 23:
        return { expectedTypes: [Number] };
      case 19:
        return {
          expectedTypes: t.args.map((r) => {
            let s = e.getInstruction(r).valueType;
            return s === Bool || (t.callData.type === "sum" ? $l(s) : bx(s))
              ? s
              : Number;
          }),
        };
      case 50: {
        let r = t.callData.parameterSymbols.length, s = [];
        for (let i = 0; i < r; i++) s.push(Number, Number);
        return { expectedTypes: s };
      }
      case 24:
      case 20:
      case 51: {
        let r = [Number];
        for (let s = 1; s < t.args.length; s++) {
          r.push(e.getInstruction(t.args[s]).valueType);
        }
        return { expectedTypes: r };
      }
      case 42:
        return { expectedTypes: t.args.map(() => Number) };
      case 48:
      case 49:
        return {
          expectedTypes: t.args.map((r) => e.getInstruction(r).valueType),
        };
      case 53:
        return { expectedTypes: [t.valueType] };
      case 54:
        return {
          expectedTypes: t.args.map((r) => e.getInstruction(r).valueType),
        };
      case 55:
        return {
          expectedTypes: t.args.map((r) => e.getInstruction(r).valueType),
        };
      case 16:
        return { expectedTypes: [hx] };
      default: {
        let r = t;
        throw new Error(`Unexpected opcode: ${r.type}`);
      }
    }
  }
  function cH(e, t) {
    for (let n of t) if (j(e.getInstruction(n).valueType)) return true;
    return false;
  }
  function oN(e) {
    let t = e.getReturnIndex(), n = e.getInstruction(t);
    if (ge(n)) return t;
    let r = w0(e, n), s = kt(r.expectedTypes), i = F0(e, n.args, [s]);
    if (r.isReducerWithNoListArgs) {
      let o = pH(e, i.didCoerce ? i.args : n.args),
        a = vn(r.expectedTypes.rest);
      if (_i(o, a)) {
        i.didCoerce ? e.replaceInstructionWithNoop(t) : e.popInstruction();
        let u = e.List(n.args);
        return e.copyInstructionWithArgs(n, [u]);
      }
    } else {i.didCoerce &&
        (e.replaceInstructionWithNoop(t),
          e.copyInstructionWithArgs(n, i.args));}
    return e.getReturnIndex();
  }
  function F0(e, t, n) {
    let r = false, s = [];
    for (let i = 0; i < t.length; i++) {
      let o = Ad(n, i), a = t[i], u = e.getInstruction(a).valueType, c = a;
      o.every((l) => !_i(u, l)) &&
      (se(o[0], Number) ? c = zi(e, a) : se(o[0], Complex) && (c = lH(e, a))),
        c !== a && (r = true),
        s.push(c);
    }
    return r ? { didCoerce: r, args: s } : { didCoerce: false };
  }
  function zi(e, t, n = {}) {
    var s;
    let r = e.getInstruction(t);
    return r.valueType === EmptyList
      ? t
      : se(r.valueType, AngleMarker)
      ? uN(e, t)
      : se(r.valueType, DirectedAngleMarker)
      ? aN(e, t)
      : se(r.valueType, Restriction)
      ? e.Piecewise([
        e.NativeFunction("restrictionToBoolean", [t]),
        e.Constant(1),
        e.Constant(NaN),
      ])
      : se(r.valueType, Complex)
      ? (s = n.peelableCoerce) != null && s
        ? e.NativeFunction("peelableCoerceComplexToReal", [t])
        : e.NativeFunction("coerceComplexToReal", [t])
      : t;
  }
  function fl(e, t) {
    let n = e.getInstruction(t);
    return n.valueType === EmptyList || se(n.valueType, Complex) ? t : zi(e, t);
  }
  function lH(e, t) {
    let n = e.getInstruction(t);
    if (n.valueType === EmptyList) return t;
    if (se(n.valueType, Number)) {
      return e.NativeFunction("coerceRealToComplex", [t]);
    }
    if (se(n.valueType, Complex)) return t;
    if (kn(n.valueType, Number) || kn(n.valueType, ListOfNumber)) {
      let r = zi(e, t);
      return e.NativeFunction("coerceRealToComplex", [r]);
    }
    return t;
  }
  function pH(e, t) {
    let n = e.getInstruction(t[0]).valueType;
    if (!wn(n)) return ListOfAny;
    for (let r of t) if (e.getInstruction(r).valueType !== n) return ListOfAny;
    return vn(n);
  }
  function ph(e, t, n) {
    let r = e.getInstruction(n);
    if (!ge(r)) {
      for (let o of r.args) {
        if (!Je(e.getInstruction(o))) return true;
      }
    }
    if (t < n) return !Je(e.getInstruction(t));
    let s = [true];
    for (let o = n + 1; o <= t; o++) s.push(false);
    let i = [t];
    for (; i.length;) {
      let o = i.pop();
      if (s[o - n]) continue;
      s[o - n] = true;
      let a = e.getInstruction(o);
      if (!ge(a)) {
        for (let u of a.args) {
          let c = e.getInstruction(u);
          if (u < n) {
            let l = e.getInstruction(u);
            if (l.type === 4) continue;
            if (!Je(l)) return true;
          } else {
            if (e.getInstruction(u).type === 50) return true;
            if (c.type === 3) return true;
            s[u - n] || i.push(u);
          }
        }
      }
    }
    return false;
  }
  function qo(e, t, n) {
    let r = qn(e, t);
    if (r === void 0) {
      throw new Error(`${n}
Non-constant instruction: "${al(e, ur(e, t))}"`);
    }
    return r;
  }
  function qn(e, t) {
    let n = ml(e, t, void 0, void 0);
    if (!(n < 0)) return n;
  }
  function ml(e, t, n, r) {
    var a;
    let s = n && n[t];
    if (s) return s;
    let i = e.getInstruction(t), o;
    switch (i.type) {
      case 38:
        o = i.args.length;
        break;
      case 1:
        o = i.value.length;
        break;
      case 48: {
        o = (a = i.constantLength) != null ? a : -1;
        break;
      }
    }
    return o === void 0 && (n = n || {}, o = dH(e, i, n, r || new Set())),
      n && (n[t] = o),
      o;
  }
  function dH(e, t, n, r) {
    switch (t.type) {
      case 33: {
        let s = ml(e, t.args[1], n, r), i = ml(e, t.args[2], n, r);
        return s === i ? s : -1;
      }
      case 37:
        switch (t.symbol) {
          case "elementsAt":
            return ml(e, t.args[1], n, r);
          case "sortPerm":
          case "complexSortPerm":
            return ml(e, t.args[0], n, r);
          case "shuffle":
            return ml(e, t.args[1], n, r);
          default:
            return -1;
        }
      case 55: {
        if (r && r.has(t.args[0])) return -1;
        r.add(t.args[0]);
        let s = e.dereferenceFunctionHeader(t.args[0]);
        if (s !== void 0) {
          let i = e.getInstruction(s);
          return ml(e, i.args[1], n, r);
        }
        return -1;
      }
      default: {
        if (j(t.valueType)) return -1;
        throw new Error(
          `Programming Error: cannot find the list length of ${ts(t.type)} ${
            oe(t.valueType)
          }.`,
        );
      }
    }
  }
  function ur(e, t) {
    let n = e.getInstruction(t);
    if (!j(n.valueType)) {
      throw new Error(
        `Programming Error: cannot find the list length of ${
          e.printInstruction(t)
        }`,
      );
    }
    switch (n.type) {
      case 38:
        return e.Constant(n.args.length);
      case 1:
        return e.Constant(n.value.length);
      case 48: {
        let r = e.getInstruction(n.args[0]);
        return e.getInstruction(r.args[0]).args[0];
      }
      case 37:
        switch (n.symbol) {
          case "elementsAt":
            return ur(e, n.args[1]);
          case "sortPerm":
          case "complexSortPerm":
            return ur(e, n.args[0]);
          case "shuffle":
            return ur(e, n.args[1]);
        }
    }
    return e.NativeFunction("count", [t]);
  }
  function Jp(e, t) {
    let n = [];
    for (let o of t) j(e.getInstruction(o).valueType) && n.push(o);
    if (n.length === 0) return;
    if (n.length === 1) return ur(e, n[0]);
    let r = [];
    for (let o of n) r.push(qn(e, o));
    let s, i = 1 / 0;
    for (let o = 0; o < r.length; o++) {
      let a = n[o], u = r[o];
      if (u === void 0) {
        return e.NativeFunction("listMin", [e.List(n.map((c) => ur(e, c)))]);
      }
      u < i && (s = a, i = u);
    }
    return s !== void 0 ? ur(e, s) : e.Constant(i);
  }
  function zf(e, t, n) {
    let r = e.getInstruction(t);
    if (j(r.valueType)) {
      let s = qn(e, t);
      if (n = Math.floor(n), isNaN(n) || n < 0 || s !== void 0 && n >= s) {
        let i = Ve(r.valueType);
        return e.NanOfType(i);
      }
      return r.type === 38
        ? r.args[n]
        : r.type === 1 && j(r.valueType)
        ? e.ConstantOfType(Ve(r.valueType), r.value[n])
        : s !== void 0
        ? e.InboundsListAccess([t, e.Constant(n + 1)])
        : e.ListAccess([t, e.Constant(n + 1)]);
    } else throw new Error(`Cannot access elements of ${oe(r.valueType)}`);
  }
  function dh(e, t, n) {
    let r = e.getInstruction(t);
    if (n.length === 0) return e.ConstantOfType(r.valueType, []);
    if (r.type === 1 && j(r.valueType)) {
      let s = [], i = Ve(r.valueType);
      for (let o of n) {
        let a = Math.floor(o);
        isNaN(a) || a < 0 ||
          a >=
            qo(
              e,
              t,
              "Programming error: expected Constant list instruction to have constant length.",
            )
          ? s.push(ls(i))
          : s.push(r.value[a]);
      }
      return e.ConstantOfType(r.valueType, s);
    } else if (r.type === 38) {
      let s = [];
      for (let i of n) {
        let o = Math.floor(i);
        if (
          isNaN(o) || o < 0 ||
          o >=
            qo(
              e,
              t,
              "Programming error: expected List instruction to have constant length.",
            )
        ) {
          let a = Ve(r.valueType);
          s.push(e.NanOfType(a));
        } else s.push(r.args[o]);
      }
      return e.List(s);
    } else {
      let s = [], i = true, o = qn(e, t);
      for (let u of n) {
        let c = Math.floor(u);
        s.push(e.Constant(c + 1)),
          (isNaN(c) || c < 0 || o === void 0 || c >= o) && (i = false);
      }
      let a = [t, e.List(s)];
      return i ? e.InboundsListAccess(a) : e.ListAccess(a);
    }
  }
  function Gr(e, t) {
    let n = e.getInstruction(t);
    if (n.type !== 48) return t;
    let r = n.args[0], s = e.getInstruction(r), i = s.args[0], o = false;
    for (let u = i + 1; u < r; u++) {
      let c = e.getInstruction(u);
      if (c.type === 40 && c.args[1] === i) {
        o = true;
        break;
      }
    }
    if (!o) return t;
    let a = [];
    for (let u = i; u <= r + s.args.length - 1; u++) {
      let c = e.getInstruction(u);
      if (ge(c)) a.push(e.copyInstruction(c));
      else {
        let l = [];
        for (let p of c.args) l.push(p >= i ? a[p - i] : p);
        c.type === 40
          ? a.push(e.InboundsListAccess(l))
          : a.push(e.copyInstructionWithArgs(c, l));
      }
    }
    return e.getReturnIndex();
  }
  function V0(e, t) {
    return !an(e) && isNaN(e) || !an(t) && isNaN(t) ? [NaN, NaN] : [e, t];
  }
  function fh(e) {
    return complex(V(e[0]), V(e[1]));
  }
  function cN([e, t]) {
    return an(e) && an(t);
  }
  function lN(e, t) {
    if (!cN(e) || !cN(t)) return complexDivide(fh(e), fh(t));
    let [n, r] = e,
      [s, i] = t,
      o = qs(wr(s, s), wr(i, i)),
      a = qs(wr(n, s), wr(r, i)),
      u = ai(wr(r, s), wr(n, i)),
      c = Ps(a, o),
      l = Ps(u, o);
    return !an(c) || !an(l) ? complexDivide(fh(e), fh(t)) : V0(c, l);
  }
  function B0(e, t, n) {
    let r;
    return mh(t) ? r = k0(t, n) : r = dN(t, n), e.ConstantOfType(t, r);
  }
  function G0(e) {
    return mh(e) || pN(e);
  }
  function mh(e) {
    switch (e) {
      case EmptyList:
      case ListOfNumber:
      case ListOfBool:
      case ListOfComplex:
      case ListOfRestriction:
      case ListOfPoint:
      case ListOfSegment:
      case ListOfCircle:
      case ListOfArc:
      case ListOfRay:
      case ListOfVector:
      case ListOfLine:
      case ListOfPolygon:
      case ListOfAngleMarker:
      case ListOfDirectedAngleMarker:
      case ListOfPoint3D:
      case ListOfVector3D:
      case ListOfTriangle3D:
      case ListOfSphere3D:
      case ListOfSegment3D:
      case ListOfColor:
      case ListOfTone:
      case ListOfTransformation:
        return true;
      default:
        return false;
    }
  }
  function pN(e) {
    switch (e) {
      case Number:
      case Bool:
      case Complex:
      case Restriction:
      case Point:
      case Segment:
      case Circle:
      case Arc:
      case Ray:
      case Vector:
      case Line:
      case Polygon:
      case AngleMarker:
      case DirectedAngleMarker:
      case Point3D:
      case Vector3D:
      case Triangle3D:
      case Sphere3D:
      case Segment3D:
      case RGBColor:
      case Tone:
      case Transformation:
      case Action:
      case SeedType:
        return true;
      default:
        return false;
    }
  }
  function k0(e, t) {
    if (e === EmptyList) return [];
    let n = Ve(e);
    if (!pN(n)) {
      throw new Error(
        `Programming error: unexpected element type ${at(n)} for list type ${
          at(e)
        }.`,
      );
    }
    let r = [];
    for (let s = 0; s < t.length; s++) {
      let i = dN(n, t[s]);
      r.push(i);
    }
    return r;
  }
  function dN(e, t) {
    if (e === Number) return Se(t, 1);
    if (e === Point || e === Complex) {
      let [n, r] = t;
      return [Se(n, 1), Se(r, 1)];
    } else if (e === Point3D) {
      let [n, r, s] = t;
      return [Se(n, 1), Se(r, 1), Se(s, 1)];
    } else return t;
  }
  function H0(e, t) {
    return qs(e, t);
  }
  function z0(e, t) {
    return ai(e, t);
  }
  function U0(e, t) {
    return wr(e, t);
  }
  function q0(e, t) {
    return Ps(e, t);
  }
  function Uf(e, t) {
    return V(e) === Math.E ? Math.exp(V(t)) : Zv(e, t);
  }
  var mH = Uf;
  function $0(e) {
    return Us(e);
  }
  function yH(e, t) {
    return t[e];
  }
  function Y0(e, t) {
    return V(e) === V(t);
  }
  function X0(e, t) {
    return V(e) < V(t);
  }
  function Z0(e, t) {
    return V(e) > V(t);
  }
  function W0(e, t) {
    return V(e) <= V(t);
  }
  function j0(e, t) {
    return V(e) >= V(t);
  }
  function mN(e, t) {
    return e || t;
  }
  function yN(e, t) {
    return e && t;
  }
  function gH(e, t, n) {
    let r = Math.floor(V(n)) - 1;
    return !isFinite(r) || r < 0 || r >= t.length ? ls(e) : t[r];
  }
  function J0(e, t, n, r) {
    an(r) && (r = V(r));
    let s = n === Number || n === SeedType
      ? r
      : serializeNonNumericSeedPart(n, r);
    return `${t}::${e}${s}`;
  }
  function Q0(e, t) {
    switch (e) {
      case "mod":
        return jv(t[0], t[1]);
      case "abs":
        return Yv(t[0]);
      case "sqrt":
        return Wv(t[0]);
      case "total":
        return Jv(t[0]);
      case "count":
        return t[0].length;
      case "validateRangeLength": {
        let n = t[0],
          r = t[1],
          s = t[2],
          i = t[3],
          o = validateRangeLength(n, r, s, i);
        if (o === 0) throw Jd();
        return o;
      }
      case "validateSampleCount": {
        let n = Vo(t[0]), r = validateSampleCount(n);
        if (r === 0 && n !== 0) throw IP();
        return r;
      }
      case "select":
      case "elementsAt":
      case "uniquePerm": {
        let n = Bn[e];
        return Gi[n.symbol].apply(null, t);
      }
      case "complex":
        return V0(t[0], t[1]);
      case "complexDivide":
        return lN(t[0], t[1]);
      default: {
        let n = Bn[e];
        return (n.module === "Math" ? Math : Gi)[n.symbol].apply(null, Vo(t));
      }
    }
  }
  function gN(e, t) {
    let n = Array(t + 1);
    return St(e, t, n);
  }
  function hN(e, t, n) {
    let r = Array(t + 1);
    for (let s = 0; s < n.length; s++) r[s] = n[s];
    return St(e, t, r);
  }
  function bN(e, t, n) {
    if (t.constantLength) return t.constantLength;
    let r = t.args[0], i = e.getInstruction(r).args[0], o = e.getInstruction(i);
    return V(St(e, o.args[0], n));
  }
  function xN(e, t, n, r) {
    let s = e.getInstruction(t), i = bN(e, s, r);
    if (!isFinite(n) || n < 0 || n >= i) return ls(Ve(s.valueType));
    let o = s.args[0],
      a = t - o,
      u = e.getInstruction(o),
      c = u.args[0],
      l = u.args[a];
    r[c] = n + 1;
    let p = St(e, l, r);
    for (let f = c; f <= o; f++) r[f] = void 0;
    return p;
  }
  function hH(e, t, n) {
    let r = e.getInstruction(t), s = r.args[0], i = e.getInstruction(s).args[0];
    if (xH(e, i + 1, s - 1) && mh(r.valueType)) {
      let u = e.copy(), c = Qp(u);
      return k0(r.valueType, c);
    }
    let o = bN(e, r, n), a = [];
    for (let u = o - 1; u >= 0; u--) a[u] = xN(e, t, u, n);
    return a;
  }
  function TN(e, t, n) {
    let r = St(e, t.args[1], n), s = t.args[0], i = e.getInstruction(s);
    if (i.type === 48) return xN(e, s, V(r) - 1, n);
    if (i.type === 33) {
      let o = St(e, i.args[0], n);
      return TN(e, { ...t, args: [o ? i.args[1] : i.args[2], t.args[1]] }, n);
    } else {
      let o = St(e, t.args[0], n);
      return gH(t.valueType, o, r);
    }
  }
  function St(e, t, n) {
    let r = n[t];
    if (r !== void 0) return r;
    let s = bH(e, t, n);
    return typeof s == "number" && s === Math.floor(s) && (s = Se(s, 1)),
      n[t] = s,
      s;
  }
  function bH(e, t, n) {
    let r = e.getInstruction(t);
    switch (r.type) {
      case 1:
        return r.value;
      case 8:
        return H0(St(e, r.args[0], n), St(e, r.args[1], n));
      case 9:
        return z0(St(e, r.args[0], n), St(e, r.args[1], n));
      case 10:
        return U0(St(e, r.args[0], n), St(e, r.args[1], n));
      case 11:
        return q0(St(e, r.args[0], n), St(e, r.args[1], n));
      case 12:
        return Uf(St(e, r.args[0], n), St(e, r.args[1], n));
      case 13:
        return mH(St(e, r.args[0], n), St(e, r.args[1], n));
      case 14:
        return $0(St(e, r.args[0], n));
      case 15:
        return r.args.map((i) => St(e, i, n));
      case 16:
        return yH(r.index, St(e, r.args[0], n));
      case 25:
        return Y0(St(e, r.args[0], n), St(e, r.args[1], n));
      case 26:
        return X0(St(e, r.args[0], n), St(e, r.args[1], n));
      case 27:
        return Z0(St(e, r.args[0], n), St(e, r.args[1], n));
      case 28:
        return W0(St(e, r.args[0], n), St(e, r.args[1], n));
      case 29:
        return j0(St(e, r.args[0], n), St(e, r.args[1], n));
      case 31:
        return St(e, r.args[0], n) || St(e, r.args[1], n);
      case 32:
        return St(e, r.args[0], n) && St(e, r.args[1], n);
      case 44:
        return J0(
          r.tag,
          St(e, r.args[0], n),
          e.getInstruction(r.args[1]).valueType,
          St(e, r.args[1], n),
        );
      case 33:
        return St(e, r.args[0], n) ? St(e, r.args[1], n) : St(e, r.args[2], n);
      case 37: {
        let i = [];
        for (let o of r.args) i.push(St(e, o, n));
        return Q0(r.symbol, i);
      }
      case 38: {
        let i = [];
        for (let o of r.args) i.push(St(e, o, n));
        return i;
      }
      case 39:
      case 40:
      case 41:
        return TN(e, r, n);
      case 48:
        return hH(e, t, n);
      case 47: {
        let i = r.args[0],
          o = t - i,
          u = e.getInstruction(i).args[o],
          c = fN(e, { endIndex: i, returnIndex: u, resultIndex: t }, n);
        return Qp(c);
      }
      case 55: {
        let i = r.args[0],
          a = e.getInstruction(i).endIndex,
          c = e.getInstruction(a).args[0],
          l = fN(e, { endIndex: a, returnIndex: c, resultIndex: t }, n);
        return Qp(l);
      }
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 42:
      case 0:
      case 2:
      case 3:
      case 49:
      case 50:
      case 51:
      case 4:
      case 53:
      case 54:
        throw new Error(`Programming Error: cannot interpret opcode ${r.type}`);
      default:
        let s = r;
        throw new Error(`Programming Error: unexpected opcode ${s.type}`);
    }
  }
  function fN(e, t, n) {
    let r = t.endIndex,
      s = t.returnIndex,
      i = t.resultIndex,
      o = e.getInstruction(r).args[0],
      a = [];
    a[s] = true;
    let u = s;
    e.getInstruction(i).type === 55 && (a[i] = true, u = i);
    for (let d = u; d >= o; d--) {
      if (!a[d]) continue;
      let y = e.getInstruction(d);
      if (!ge(y)) {
        for (let g of y.args) {
          g < o || g > r ? St(e, g, n) : a[g] = true;
        }
      }
    }
    let l = e.copy();
    l.unsafelyTruncate(o);
    for (let d = 0; d < o; d++) {
      let y = n[d], g = e.getInstruction(d);
      if (y !== void 0) {
        let m = g.valueType;
        l.replaceInstructionWithConstant(d, {
          type: 1,
          valueType: m,
          value: y,
        });
      }
    }
    l.reopenAllBlocks();
    let p = [];
    for (let d = o; d < i; d++) {
      let y = e.getInstruction(d);
      if (ge(y)) p.push(l.copyInstruction(y));
      else {
        let g = [];
        for (let m of y.args) g.push(m < o ? m : p[m - o]);
        y.type === 40
          ? p.push(l.InboundsListAccess(g))
          : p.push(l.copyInstructionWithArgs(y, g));
      }
    }
    l.Noop();
    let f = e.getInstruction(i);
    if (f.type === 47) {
      l.replaceInstructionWithBlockVarOrFunctionCall(l.getReturnIndex(), {
        type: 47,
        valueType: f.valueType,
        args: [r < o ? r : p[r - o]],
      });
    } else if (f.type === 55) {
      l.replaceInstructionWithBlockVarOrFunctionCall(l.getReturnIndex(), {
        type: 55,
        valueType: f.valueType,
        args: f.args.map((d) => d < o ? d : p[d - o]),
      });
    } else {throw new Error(
        `Programming error: unexpected opcode ${ts(f.type)}`,
      );}
    return l;
  }
  function xH(e, t, n) {
    let r = [];
    for (let i = 0; i <= t; i++) r.push(false);
    let s = [];
    for (let i = t + 1; i <= n; i++) s.push(i);
    for (; s.length;) {
      let i = s.pop();
      if (r[i]) continue;
      r[i] = true;
      let o = e.getInstruction(i);
      if (o.type === 55) return true;
      if (!ge(o)) { for (let a of o.args) r[a] || s.push(a); }
    }
    return false;
  }
  function Qp(e) {
    let t = e.getCompiledFunction();
    return t.executionMetadata.recursiveFunctionCache = new LruCache(),
      t.executionMetadata.iterativeRecursionOutputs = {},
      t.fn();
  }
  function PN(e) {
    if (e.instructionsLength() - 1 !== e.getReturnIndex()) {
      throw new Error(
        "Programming Error: only the final instruction in a chunk can be constant collapsed",
      );
    }
    let t = e.getInstruction(e.getReturnIndex());
    if (ge(t)) return e.getReturnIndex();
    switch (t.type) {
      case 8: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.Constant(H0(r.value, s.value)))
          : r.type === 1 && V(r.value) === 0
          ? (e.popInstruction(), t.args[1])
          : s.type === 1 && V(s.value) === 0
          ? (e.popInstruction(), t.args[0])
          : e.getReturnIndex();
      }
      case 9: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.Constant(z0(r.value, s.value)))
          : r.type === 1 && V(r.value) === 0
          ? (e.popInstruction(), e.Negative([t.args[1]]))
          : s.type === 1 && V(s.value) === 0
          ? (e.popInstruction(), t.args[0])
          : e.getReturnIndex();
      }
      case 10: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.Constant(U0(r.value, s.value)))
          : r.type === 1 && V(r.value) === 1
          ? (e.popInstruction(), t.args[1])
          : s.type === 1 && V(s.value) === 1
          ? (e.popInstruction(), t.args[0])
          : e.getReturnIndex();
      }
      case 11: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.Constant(q0(r.value, s.value)))
          : s.type === 1 && V(s.value) === 1
          ? (e.popInstruction(), t.args[0])
          : e.getReturnIndex();
      }
      case 12: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        if (r.type === 1 && s.type === 1) {
          return e.popInstruction(), e.Constant(Uf(r.value, s.value));
        }
        if (r.type === 1 && r.valueType === Number) {
          let i = V(r.value);
          if (i === Math.E) {
            return e.popInstruction(), e.NativeFunction("exp", [t.args[1]]);
          }
          if (i > 0) return e.popInstruction(), e.RawExponent(t.args);
        }
        if (s.type === 1 && s.valueType === Number) {
          let i = V(s.value);
          if (i === 1) return e.popInstruction(), t.args[0];
          if (i === Math.floor(i)) {
            return e.popInstruction(), e.RawExponent(t.args);
          }
          if (an(s.value)) {
            let { n: o, d: a } = s.value;
            if (a % 2 === 1) {
              e.popInstruction();
              let u = e.RawExponent([
                e.NativeFunction("abs", [t.args[0]]),
                t.args[1],
              ]);
              return o % 2 === 0
                ? u
                : e.Multiply([e.NativeFunction("sign", [t.args[0]]), u]);
            }
          }
        }
        return e.getReturnIndex();
      }
      case 13: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.Constant(Uf(r.value, s.value)))
          : s.type === 1 && V(s.value) === 1
          ? (e.popInstruction(), t.args[0])
          : e.getReturnIndex();
      }
      case 14: {
        let r = e.getInstruction(t.args[0]);
        return r.type === 1
          ? (e.popInstruction(), e.Constant($0(r.value)))
          : e.getReturnIndex();
      }
      case 25: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.ConstantOfType(Bool, Y0(r.value, s.value)))
          : e.getReturnIndex();
      }
      case 26: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.ConstantOfType(Bool, X0(r.value, s.value)))
          : e.getReturnIndex();
      }
      case 27: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.ConstantOfType(Bool, Z0(r.value, s.value)))
          : e.getReturnIndex();
      }
      case 28: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.ConstantOfType(Bool, W0(r.value, s.value)))
          : e.getReturnIndex();
      }
      case 29: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.ConstantOfType(Bool, j0(r.value, s.value)))
          : e.getReturnIndex();
      }
      case 31: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.ConstantOfType(Bool, mN(r.value, s.value)))
          : r.type === 1
          ? (e.popInstruction(), r.value ? t.args[0] : t.args[1])
          : s.type === 1
          ? (e.popInstruction(), s.value ? t.args[1] : t.args[0])
          : e.getReturnIndex();
      }
      case 32: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return r.type === 1 && s.type === 1
          ? (e.popInstruction(), e.ConstantOfType(Bool, yN(r.value, s.value)))
          : r.type === 1
          ? (e.popInstruction(), r.value ? t.args[1] : t.args[0])
          : s.type === 1
          ? (e.popInstruction(), s.value ? t.args[0] : t.args[1])
          : e.getReturnIndex();
      }
      case 33: {
        let r = e.getInstruction(t.args[0]);
        return r.type === 1
          ? (e.popInstruction(), r.value ? t.args[1] : t.args[2])
          : e.getReturnIndex();
      }
      case 16: {
        let r = e.getInstruction(t.args[0]), s = t.index;
        return r.type === 15
          ? (e.popInstruction(), r.args[s])
          : r.type === 1
          ? (e.popInstruction(), e.ConstantOfType(t.valueType, r.value[s]))
          : e.getReturnIndex();
      }
      case 38:
      case 15: {
        if (IN(e, t.args)) {
          e.popInstruction();
          let r = [];
          for (let s of t.args) r.push(e.getInstruction(s).value);
          return e.ConstantOfType(t.valueType, r);
        }
        return e.getReturnIndex();
      }
      case 39:
      case 41: {
        let r = t.args[0],
          s = e.getInstruction(r),
          i = e.getInstruction(t.args[1]),
          o = qn(e, r);
        if (o === 0) return e.popInstruction(), e.NanOfType(t.valueType);
        if (s.type === 33 && i.type === 1) {
          let a = t.type === 39
              ? e.ListAccess([s.args[1], t.args[1]])
              : e.InboundsListAccess([s.args[1], t.args[1]]),
            u = t.type === 39
              ? e.ListAccess([s.args[2], t.args[1]])
              : e.InboundsListAccess([s.args[2], t.args[1]]);
          return e.Piecewise([s.args[0], a, u]);
        }
        if (s.type === 48) {
          e.popInstruction();
          let a = s.args[0],
            u = r - a,
            c = e.getInstruction(a),
            l = c.args[0],
            p,
            f;
          if (t.type === 41) p = t.args[1];
          else if (i.type === 1 && i.valueType === Number && o !== void 0) {
            let y = V(i.value), g = Math.floor(y);
            if (g < 1 || g > o) return e.NanOfType(t.valueType);
            p = y === g ? t.args[1] : e.Constant(g);
          } else {
            let y = e.Constant(1),
              m = e.getInstruction(l).args[0],
              h = e.NativeFunction("floor", [t.args[1]]),
              x = e.GreaterEqual([h, y]),
              T = e.LessEqual([h, m]);
            p = e.Piecewise([x, e.Piecewise([T, h, m]), y]),
              f = {
                one: y,
                lengthIndex: m,
                roundedIndex: h,
                greaterEqualIndex: x,
                lessEqualIndex: T,
              };
          }
          if (c.args[u] < l) return c.args[u];
          let d = [p];
          for (let y = l + 1; y <= c.args[u]; y++) {
            let g = e.getInstruction(y);
            if (ge(g)) d.push(e.copyInstruction(g));
            else {
              let m = [];
              for (let h of g.args) m.push(h >= l ? d[h - l] : h);
              g.type === 40
                ? d.push(e.InboundsListAccess(m))
                : d.push(e.copyInstructionWithArgs(g, m));
            }
          }
          if (f) {
            let {
                greaterEqualIndex: y,
                lessEqualIndex: g,
                lengthIndex: m,
                one: h,
              } = f,
              x = Ve(s.valueType),
              T = e.NanOfType(x),
              b = d[d.length - 1],
              M = e.And([e.And([y, g]), e.GreaterEqual([m, h])]);
            return e.Piecewise([M, b, T]);
          } else return d[d.length - 1];
        } else if (i.type === 1 && i.valueType === Number) {
          if (s.type === 38) {
            e.popInstruction();
            let a = Math.floor(V(i.value)) - 1;
            return isNaN(a) || a < 0 || a >= s.args.length
              ? e.NanOfType(t.valueType)
              : s.args[a];
          } else if (s.type === 1) {
            e.popInstruction();
            let a = Math.floor(V(i.value)) - 1;
            return isNaN(a) || a < 0 || a >= s.value.length
              ? e.NanOfType(t.valueType)
              : e.ConstantOfType(Ve(s.valueType), s.value[a]);
          } else return e.getReturnIndex();
        } else return e.getReturnIndex();
      }
      case 47: {
        let r = e.getInstruction(t.args[0]);
        if (!ds(r) || ph(e, e.getReturnIndex(), r.args[0])) {
          return e.getReturnIndex();
        }
        if (G0(t.valueType)) {
          let s = e.copy(), i = Qp(s);
          return e.popInstruction(), B0(e, t.valueType, i);
        } else {throw new Error(
            `Constant collapsing a block with return type ${
              oe(t.valueType)
            } is not implemented.`,
          );}
      }
      case 55: {
        let r = e.dereferenceFunctionHeader(t.args[0]);
        if (r === void 0 || !IN(e, t.args.slice(1)) || ph(e, r, t.args[0])) {
          return e.getReturnIndex();
        }
        if (G0(t.valueType)) {
          let s = e.copy(), i = Qp(s);
          return e.popInstruction(), B0(e, t.valueType, i);
        } else {throw new Error(
            `Constant collapsing a function call with return type ${
              oe(t.valueType)
            } is not implemented.`,
          );}
      }
      case 37: {
        let r = IH(e, t.args);
        if (r !== void 0) {
          return e.popInstruction(),
            e.ConstantOfType(t.valueType, Q0(t.symbol, r));
        }
        switch (t.symbol) {
          case "complexPow": {
            let s = e.getInstruction(t.args[1]);
            if (s.type === 1 && s.valueType === Complex) {
              let [i, o] = s.value;
              if (V(i) === 1 && V(o) === 0) {
                return e.popInstruction(), t.args[0];
              }
            }
            return e.getReturnIndex();
          }
          case "count": {
            let s = qn(e, t.args[0]);
            return s !== void 0
              ? (e.popInstruction(), e.Constant(s))
              : e.getReturnIndex();
          }
          case "select": {
            let s = qn(e, t.args[0]);
            if (s !== void 0 && Je(e.getInstruction(t.args[1]))) {
              e.popInstruction();
              let i = hn(e, t.args[1]), o = [];
              for (let a = 0; a < Math.min(s, i.length); a++) i[a] && o.push(a);
              return dh(e, t.args[0], o);
            } else return e.getReturnIndex();
          }
          case "shuffle": {
            let s = t.args[0], i = t.args[1], o = qn(e, i);
            if (o !== void 0 && Je(e.getInstruction(s))) {
              e.popInstruction();
              let a = randomPerm(hn(e, s), o);
              return dh(e, i, a);
            } else return e.getReturnIndex();
          }
          case "elementsAt": {
            let s = t.args[0], i = t.args[1];
            if (Je(e.getInstruction(i))) {
              e.popInstruction();
              let o = hn(e, i);
              return dh(e, s, o);
            }
            return e.getReturnIndex();
          }
          case "restrictionToBoolean": {
            let s = e.getInstruction(t.args[0]);
            return Je(s)
              ? (e.popInstruction(), e.ConstantOfType(Bool, s.value))
              : s.type === 37 && s.symbol === "restriction"
              ? (e.popInstruction(), s.args[0])
              : e.getReturnIndex();
          }
          default:
            return e.getReturnIndex();
        }
      }
      case 44: {
        let r = e.getInstruction(t.args[0]), s = e.getInstruction(t.args[1]);
        return Je(r) && Je(s)
          ? e.ConstantOfType(
            SeedType,
            J0(t.tag, hn(e, t.args[0]), s.valueType, hn(e, t.args[1])),
          )
          : e.getReturnIndex();
      }
      case 48: {
        let r = e.getReturnIndex(), s = qn(e, r);
        if (s !== void 0 && s === 0) {
          return e.popInstruction(), e.ConstantOfType(t.valueType, []);
        }
        let i = t.args[0],
          o = e.getInstruction(i),
          a = o.args[0],
          u = r - i,
          c = o.args[u];
        if (!ph(e, c, a)) {
          if (t.valueType === ListOfDistribution) {
            if (s == null) throw sf(fs(e, r));
            let f = [];
            for (let d = 0; d < s; d++) {
              let y = e.InboundsListAccess([r, e.Constant(d + 1)]);
              f.push(y);
            }
            return e.List(f);
          }
          let p = gN(e, r);
          e.popInstruction(), e.ConstantOfType(t.valueType, p);
        }
        return r;
      }
      case 49: {
        for (let s of t.args) {
          if (!Je(e.getInstruction(s))) return e.getReturnIndex();
        }
        e.popInstruction();
        let r = {};
        for (let s = 0; s < t.symbols.length; s++) {
          let i = t.symbols[s], o = e.getInstruction(t.args[s]);
          if (
            o.type === 48 && (o = e.getInstruction(Gr(e, t.args[s]))),
              o.type !== 1
          ) throw new Error("Expected instruction to be constant");
          let { valueType: a, value: u } = o;
          uh(a, u) || (r[i] = { value: u, valueType: a });
        }
        return e.ConstantOfType(Action, { type: "Action", updateRules: r });
      }
      case 20:
      case 22:
      case 23:
      case 24:
      case 40:
      case 42:
      case 21:
      case 19:
      case 50:
      case 51:
      case 53:
      case 54:
        return e.getReturnIndex();
      default:
        let n = t;
        throw new Error(`Unexpected opcode ${n.type}`);
    }
  }
  function IN(e, t) {
    for (let n of t) {
      let r = e.getInstruction(n);
      if (!Je(r)) return false;
    }
    return true;
  }
  function IH(e, t) {
    let n = [];
    for (let r of t) {
      let s = e.getInstruction(r);
      if (Je(s)) n.push(s.value);
      else return;
    }
    return n;
  }
  function EN(e) {
    if (e.instructionsLength() - 1 !== e.getReturnIndex()) {
      throw new Error(
        "Programming Error: only the final instruction in a chunk can be converted to broadcast",
      );
    }
    let t = e.getInstruction(e.getReturnIndex());
    if (ge(t)) return e.getReturnIndex();
    switch (t.type) {
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 31:
      case 32:
      case 15:
      case 14:
      case 33:
      case 16:
        return yl(e, t);
      case 42:
        return Gr(e, yl(e, t));
      case 37: {
        let r = Bn[t.symbol];
        switch (r.tag) {
          case "default":
          case "trig":
          case "trig2":
          case "inverseTrig":
          case "color":
            return yl(e, t);
          case "never-broadcast": {
            let s = [], i = false;
            for (let o of t.args) {
              let a = Gr(e, o);
              a !== o ? (i = true, s.push(a)) : s.push(o);
            }
            return i ? e.copyInstructionWithArgs(t, s) : e.getReturnIndex();
          }
          case "reducer":
            if (PH(e, t.args)) {
              if (t.args.length === 1) {
                let s = t.args[0], i = Gr(e, s);
                return i !== s
                  ? e.copyInstructionWithArgs(t, [i])
                  : e.getReturnIndex();
              } else return yl(e, t);
            } else return e.getReturnIndex();
          case "doubleReducer": {
            if (t.args.length !== 2) {
              throw new Error(
                "Programming error: double reducers must have two arguments",
              );
            }
            let s = Gr(e, t.args[0]), i = Gr(e, t.args[1]);
            return s !== t.args[0] || i !== t.args[1]
              ? e.copyInstructionWithArgs(t, [s, i])
              : e.getReturnIndex();
          }
          case "parameterizedReducer": {
            if (t.args.length !== 2) {
              throw new Error(
                "Programming error: double reducers must have two arguments",
              );
            }
            let s = Gr(e, t.args[0]);
            return s === t.args[0]
              ? yl(e, t, [false, true])
              : e.copyInstructionWithArgs(t, [s, t.args[1]]);
          }
          default: {
            let s = r.tag;
            throw new Error(`Programming Error: unexpected tag ${s}`);
          }
        }
      }
      case 39:
      case 40:
      case 41:
        return yl(e, t, [false, true]);
      case 55: {
        let s = e.getInstruction(t.args[0]).signature.argTypes.map((a) =>
            !j(a)
          ),
          i = [t.args[0]],
          o = false;
        for (let a = 1; a < t.args.length; a++) {
          let u = t.args[a], c = Gr(e, u);
          c !== u ? (o = true, i.push(c)) : i.push(u);
        }
        return o ? e.copyInstructionWithArgs(t, i) : yl(e, t, [false, ...s]);
      }
      case 21:
      case 22:
      case 19:
      case 20:
      case 50:
      case 51:
        return e.getReturnIndex();
      case 38:
      case 47:
      case 23:
      case 24:
      case 48:
      case 44:
      case 49:
      case 53:
      case 54:
        return e.getReturnIndex();
      default:
        let n = t;
        throw new Error(`Unexpected opcode ${n.type}`);
    }
  }
  function PH(e, t) {
    for (let n of t) if (j(e.getInstruction(n).valueType)) return true;
    return false;
  }
  function yl(e, t, n) {
    let r = t.args, s = false, i = [];
    for (let d = 0; d < r.length; d++) {
      if (n && !n[d]) continue;
      let y = r[d], g = e.getInstruction(y).valueType;
      j(g) && i.indexOf(y) === -1 && i.push(y), g === EmptyList && (s = true);
    }
    if (i.length === 0) return e.getReturnIndex();
    if (
      t.type === 33 && i.indexOf(t.args[0]) == -1 &&
      i.indexOf(t.args[1]) >= 0 && i.indexOf(t.args[2]) >= 0
    ) {
      let d = Gr(e, t.args[1]), y = Gr(e, t.args[2]);
      return d !== t.args[1] || y !== t.args[2]
        ? _n(e, t, [t.args[0], d, y])
        : e.getReturnIndex();
    }
    e.popInstruction();
    let o = Jp(e, i);
    if (o === void 0) {
      throw new Error(
        "Programming Error: expected minListLength to be defined for " +
          i.length + " lists",
      );
    }
    let a = o;
    if (Je(e.getInstruction(a)) && hn(e, a) === 0 && s) {
      return e.ConstantOfType(EmptyList, []);
    }
    let u = e.BeginBroadcast([a], { type: "implicit" }), c = [];
    for (let d of i) c.push(Ea(e, d, u));
    let l = [];
    for (let d = 0; d < r.length; d++) {
      let y = r[d];
      if (n && !n[d]) l.push(y);
      else {
        let g = i.indexOf(y);
        l.push(g === -1 ? y : c[g]);
      }
    }
    let p = e.copyInstructionWithArgs(t, l), f = e.EndBroadcast([u, p]);
    return e.BroadcastResult(vn(e.getInstruction(p).valueType), [f]);
  }
  function Ea(e, t, n) {
    return e.getInstruction(t).type == 48
      ? e.DeferredListAccess([t, n])
      : e.InboundsListAccess([t, n]);
  }
  function CN(e) {
    let t = e.getReturnIndex(), n = Vr(e, t), r = e.getInstruction(t);
    if (r.type !== 48) return e;
    let s = r.args[0],
      i = t - s,
      o = e.getInstruction(s),
      a = o.args[0],
      u = o.args[i],
      c = [],
      l = [];
    c.push(a);
    let p = qo(
      e,
      e.getReturnIndex(),
      "Programming error: cannot optimize regression on non-constant-length list",
    );
    l.push({ range: p - 1, length: p });
    let f = false, d = false;
    for (let D = a + 1; D <= u; D++) {
      if (!n[D]) continue;
      let S = e.getInstruction(D);
      if (es(S) || ds(S)) return e;
      if (S.type === 39 || S.type === 41 || S.type === 40) {
        if (S.args[1] !== a) continue;
        let O = S.args[0];
        if (
          e.getInstruction(O).valueType !== ListOfNumber ||
          !Je(e.getInstruction(O))
        ) {
          continue;
        }
        let _ = hn(e, O), L = CH(_);
        if (!isFinite(L.range)) continue;
        c.push(D), l.push(L);
      } else MN(S) ? f = true : (S.type === 12 || S.type === 13) && (d = true);
    }
    if (c.length === 0 || !d && !f) return e;
    let y = [], g = [];
    for (let D = 0; D < e.argNames.length; D++) g.push(D), y.push(aa());
    let m = [], h = [];
    for (let D = 0; D <= u; D++) m.push(K0(e, g, m, D)), h.push(K0(e, c, h, D));
    for (let D = 0; D <= u; D++) {
      if (!n[D]) continue;
      let S = e.getInstruction(D);
      if (S.type === 33) {
        let O = m[D];
        for (let _ = 0; _ < O.length; _++) if (O[_]) return e;
      } else if (S.type === 12 || S.type === 13) {
        let O = false, _ = false;
        for (let K = 0; K < c.length; K++) {
          h[S.args[0]][K] && (O = true), h[S.args[1]][K] && (_ = true);
        }
        if (O || !_) continue;
        let L = m[S.args[0]], w = 0, G;
        for (let K = 0; K < L.length; K++) L[K] && (G = K, w += 1);
        if (w !== 1 || G === void 0) continue;
        let k = g[G],
          Z = ns(e.copy().reopenFinalBlock(), k, {
            allowRestriction: false,
            allowClosedBlockReferences: false,
          });
        if (ln(Z, S.args[0]) !== 1) continue;
        let F = fo(Z, S.args[0]), [Y, re] = Kn(F, S.args[0]);
        if (re === void 0) continue;
        let Ee = hn(F.newChunk, re), he = hn(F.newChunk, Y);
        y[G] = Gn(y[G], Hl(he, Ee));
      }
    }
    if (f) {
      let D = e.copy().reopenFinalBlock();
      for (let S = 0; S < c.length; S++) {
        let O = ns(D, c[S], {
            allowRestriction: false,
            allowClosedBlockReferences: false,
          }),
          _ = fo(O, u);
        for (let L = a + 1; L <= u; L++) {
          if (!n[L]) continue;
          let w = D.getInstruction(L);
          if (MN(w)) {
            let G = w.args[0];
            if (ln(O, G) !== 1) continue;
            let k = Kn(_, G)[1];
            if (k === void 0) continue;
            let Z = MH(_.newChunk, k), F, Y = 0;
            for (let me = 0; me < Z.length; me++) Z[me] && (F = me, Y += 1);
            if (Y !== 1 || F === void 0) continue;
            let re = ns(_.newChunk, F, {
              allowRestriction: false,
              allowClosedBlockReferences: false,
            });
            if (ln(re, k) !== 1) continue;
            let Ee = fo(re, k), [he, K] = Kn(Ee, k);
            if (
              K === void 0 || !Je(Ee.newChunk.getInstruction(he)) ||
              !Je(Ee.newChunk.getInstruction(K))
            ) continue;
            let Oe = hn(Ee.newChunk, he),
              te = hn(Ee.newChunk, K),
              Ze = SH(l[S]),
              dt = DH(l[S]);
            if (
              !isFinite(Ze) || Ze <= 0 || !isFinite(dt) || dt < 0 || Ze <= dt
            ) continue;
            y[F] = Gn(y[F], Gn(Hl(-dt + Oe, te), Hl(Ze - Oe, -te)));
          }
        }
      }
    }
    let x = false;
    for (let D of y) {
      if (Fs(D) || !hi(D)) return e;
      (D.bounds[0] !== -1 / 0 || D.bounds[1] !== 1 / 0) && (x = true);
    }
    if (!x) return e;
    let T = e.copy(), b = T.Constant(1), M = T.Constant(NaN), P = t;
    for (let D = 0; D < T.argNames.length; D++) P = EH(T, y[D], P, D, b, M);
    return T.fuseBroadcast(), T;
  }
  function EH(e, t, n, r, s, i) {
    if (Fs(t) || !hi(t) || t.bounds[0] === -1 / 0 && t.bounds[1] === 1 / 0) {
      return n;
    }
    let o = e.And([
      e.LessEqual([e.Constant(t.bounds[0]), r]),
      e.LessEqual([r, e.Constant(t.bounds[1])]),
    ]);
    return e.Multiply([n, e.Piecewise([o, s, i])]);
  }
  function MH(e, t) {
    let n = [];
    for (let s = 0; s < e.argNames.length; s++) n.push(s);
    let r = [];
    for (let s = 0; s <= t; s++) r.push(K0(e, n, r, s));
    return r[t];
  }
  function MN(e) {
    return e.type === 37 && (e.symbol === "sin" || e.symbol === "cos");
  }
  function CH(e) {
    let t = 1 / 0, n = -1 / 0, r = e.length;
    for (let s of e) t = Math.min(t, s), n = Math.max(n, s);
    return { range: n - t, length: r };
  }
  function DH({ range: e }) {
    return 1e-5 / e;
  }
  function SH({ range: e, length: t }) {
    let n = e / Math.min(t - 1, 31);
    return Math.PI / n;
  }
  function K0(e, t, n, r) {
    let s = e.getInstruction(r), i = vH(t.length);
    for (let o = 0; o < t.length; o++) if (t[o] === r) return i[o] = true, i;
    if (ge(s)) return i;
    for (let o of s.args) {
      let a = n[o];
      for (let u = 0; u < a.length; u++) i[u] = i[u] || a[u];
    }
    return i;
  }
  function vH(e) {
    let t = [];
    for (let n = 0; n < e; n++) t.push(false);
    return t;
  }
  var RN = tM({
    sin: Dn(
      "isinf(x) || isnan(x) ? NaN : dcg_isPiMultiple(abs(x)) ? 0.0 : sin(x)",
    ),
    cos: Dn(
      "isinf(x) || isnan(x) ? NaN : dcg_isOddHalfPiMultiple(abs(x)) ? 0.0 : cos(x)",
    ),
    tan: ci(pe`float a=abs(x);
    return isinf(x) || isnan(x) ? NaN
      : dcg_isPiMultiple(a) ? 0.0
      : dcg_isOddHalfPiMultiple(a) ? Infinity
      : tan(x);`),
    cot: ci(pe`float a=abs(x);
      return isinf(x) || isnan(x) ? NaN
        : a < 0.03 ? 1.0/x - x/3.0
        : dcg_isPiMultiple(a) ? Infinity
        : dcg_isOddHalfPiMultiple(a) ? 0.0
        : 1.0 / tan(x);`),
    sec: Dn(
      "isinf(x) || isnan(x) ? NaN : dcg_isOddHalfPiMultiple(abs(x)) ? Infinity: 1.0 / cos(x)",
    ),
    csc: ci(pe`float a=abs(x);
      return isinf(x) || isnan(x) ? NaN
        : a < 0.03 ? 1.0/x + x/6.0
        : dcg_isPiMultiple(a) ? Infinity
        : 1.0 / sin(x);`),
    arcsin: ci(pe`if (isinf(x) || isnan(x)) { return NaN; }
    if (x == 1.0) { return dcg_PI/2.0; }
    if (x == -1.0) { return -dcg_PI/2.0; }
    if (x > 1.0 || x < -1.0) return NaN;
    float y0 = asin(x);
    return y0 + (x - sin(y0)) / cos(y0);`),
    arccos: ci(pe`if (isinf(x) || isnan(x)) { return NaN; }
    if (x == 1.0) { return 0.0; }
    if (x == -1.0) { return dcg_PI; }
    if (x > 1.0 || x < -1.0) return NaN;
    float y0 = acos(x);
    return y0 + (cos(y0) - x) / sin(y0);`),
    arctan: qf(pe`isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) ?
        (y > 0.0 ? 0.25 : 0.75) * sign(x) * dcg_PI
      : x == 0.0 && y == 0.0 ? y
      : atan(x, y)
    `),
    arccot: Dn("isnan(x) ? NaN : dcg_PI/2.0 - atan(x)"),
    arcsec: Dn("isnan(x) ? NaN : dcg_arccos(1.0/x)"),
    arccsc: Dn("isnan(x) ? NaN : dcg_arcsin(1.0/x)"),
    sinh: Dn("isinf(x) ? x : isnan(x) ? NaN : sinh(x)"),
    cosh: Dn("isinf(x) ? Infinity : isnan(x) ? NaN : cosh(x)"),
    tanh: Dn("abs(x) > 10.0 ? sign(x) : isnan(x) ? NaN : tanh(x)"),
    coth: Dn(
      "abs(x) > 10.0 ? sign(x) : isnan(x) ? NaN : x == 0.0 ? Infinity : abs(x) < 0.03 ? 1.0/x + x/3.0 : 1.0/tanh(x)",
    ),
    sech: Dn("isinf(x) ? 0.0 : isnan(x) ? NaN : 1.0/cosh(x)"),
    csch: Dn(
      "isinf(x) ? 0.0 : isnan(x) ? NaN : x == 0.0 ? Infinity : abs(x) < 0.03 ? 1.0/x - x/6.0 : 1.0/sinh(x)",
    ),
    arcsinh: ci(pe`float a=abs(x);
      return isnan(x) ? NaN : sign(x) * (
        1.0 + x * x == 1.0
          ? dcg_log1p(a)
          : log(a + dcg_rtxsqpone(a))
      );`),
    arccosh: Dn("x < 1.0 || isnan(x) ? NaN : log(x + dcg_rtxsqmone(x))"),
    arctanh: ci(pe`if (isnan(x) || abs(x) > 1.0) { return NaN; }
      if (x == 1.0) { return Infinity; }
      if (x == -1.0) { return -Infinity; }
      float y0 = 0.5*(dcg_log1p(x) - dcg_log1p(-x));
      float c = cosh(y0);
      return y0 + (x - tanh(y0)) * c * c;`),
    arccoth: Dn("isnan(x) ? NaN : abs(x) >= 1.0 ? dcg_arctanh(1.0/x) : NaN"),
    arcsech: Dn(
      "isnan(x) ? NaN : 0.0 < x && x <= 1.0 ? dcg_arccosh(1.0/x) : x == 0.0 ? Infinity : NaN",
    ),
    arccsch: Dn("isinf(x) ? 0.0 : isnan(x) ? NaN : dcg_arcsinh(1.0/x)"),
    sinpiSeries: ci(pe`float xsq = x*x;
    return x*(dcg_PI-xsq*(5.167708-xsq*(2.549761-xsq*0.5890122)));`),
    sinpi: ci(pe`if (isnan(x) || isinf(x)) { return NaN; }
    if (x==0.0) { return x; }
    if (x == floor(x)) { return x > 0.0 ? 0.0 : -0.0; }
    int i = int(dcg_round(2.0*x));
    float t = -0.5 * float(i) + x;
    float s = bool(i & 2) ? -1.0 : 1.0;
    float y = bool(i & 1) ? cos(dcg_PI * t) : dcg_sinpiSeries(t);
    return s*y;`),
    sincpi: Dn(
      "isnan(x) ? NaN : isinf(x) ? 0.0 : x == 0.0 ? 1.0 : dcg_sinpi(x)/(dcg_PI*x);",
    ),
    sqrt: Dn("isnan(x) ? NaN : x >= 0.0 ? sqrt(x) : NaN"),
    rtxsqpone: Dn("dcg_hypot(x, 1.0)"),
    rtxsqmone: ci(
      "float t = x*x; return isnan(x) || t < 1.0 ? NaN : t - 1.0 == t ? abs(x) : sqrt(t - 1.0);",
    ),
    hypot: AN(pe`if (isnan(x) || isnan(y)) return NaN;
      if (isinf(x) || isinf(y)) return Infinity;
      x = abs(x);
      y = abs(y);
      float m = max(x,y);
      x /= m;
      y /= m;
      return m == 0.0 ? 0.0 : sqrt(x*x + y*y) * m;`),
    min: qf(pe`isnan(x) || isnan(y) ? NaN : min(x, y)`),
    max: qf(pe`isnan(x) || isnan(y) ? NaN : max(x, y)`),
    log: Dn(
      "isnan(x) ? NaN : x > 0.0 ? log(x)*0.4342944819 : x == 0.0 ? -Infinity : NaN",
    ),
    logbase: qf(pe`isnan(x) || isnan(y) ? NaN
      : y == 1.0 ?
        (
          x > 1.0 ? Infinity
          : x == 1.0 ? NaN
          : x < 0.0 ? NaN
          : -Infinity
        )
      : y > 0.0 ?
        (
          x > 0.0 ? log(x)/log(y)
          : x == 0.0 && !isinf(y) ? -Infinity
          : NaN
        )
      : NaN`),
    ln: Dn("isnan(x) ? NaN : x > 0.0 ? log(x) : x == 0.0 ? -Infinity : NaN"),
    exp: Dn("isnan(x) ? NaN : exp(x)"),
    floor: Dn("isnan(x) ? NaN : floor(x)"),
    ceil: Dn("isnan(x) ? NaN : ceil(x)"),
    round: Dn("isinf(x) || isnan(x) ? x : floor(0.5 + x)"),
    abs: Dn("isnan(x) ? NaN : abs(x)"),
    sign: Dn("isnan(x) ? NaN : sign(x)"),
    mod: qf(
      "isinf(x) || isinf(y) || isnan(x) || isnan(y) || y == 0.0 ? NaN : mod(x, y)",
    ),
    stirlingPrefactor: kr(
      "float",
      "float x, float y",
      pe`if (isnan(x) || isnan(y)) { return NaN; }
    return pow(x/exp(1.0), y);`,
    ),
    stirlerrSeries: ci(pe`float S0 = 0.083333336;
    float S1 = 0.0027777778;
    float S2 = 0.0007936508;
    float nn = x*x;
    return (S0-(S1-S2/nn)/nn)/x;`),
    factorialAsymptotic: Dn(
      "dcg_stirlingPrefactor(x,x)*sqrt(2.0*dcg_PI*x)*exp(dcg_stirlerrSeries(x))",
    ),
    factorialMinimax: ci(pe`float n1 = 2.1618295;
    float n2 = 1.5849807;
    float n3 = 0.4026814;
    float d1 = 2.2390451;
    float d2 = 1.6824219;
    float d3 = 0.43668285;

    float n = 1.0 + x*(n1 + x*(n2 + x*n3));
    float d = 1.0 + x*(d1 + x*(d2 + x*d3));
    float xp1 = x+1.0;

    return dcg_stirlingPrefactor(xp1,x)*sqrt(xp1)*(n/d);
    `),
    factorialPositive: Dn(
      pe`(x>33.0)?Infinity:(x>8.0)?dcg_factorialAsymptotic(x):dcg_factorialMinimax(x);`,
    ),
    factorial: ci(pe`if (isnan(x) || (isinf(x) && x < 0.0)) { return NaN; }
    bool isInteger = x == floor(x);
    if (x < 0.0) {
      if (isInteger) return Infinity;
      return 1.0 / (dcg_sincpi(x) * dcg_factorialPositive(-x));
    }
    float approx = dcg_factorialPositive(x);
    return isInteger ? dcg_round(approx) : approx;`),
    distance: kr(
      "float",
      "vec2 a, vec2 b",
      pe`
      if (any(isnan(a)) || any(isnan(b))) return NaN;
      vec2 d = a-b;
      return dcg_hypot(d.x, d.y);`,
    ),
    distanceThreeD: kr(
      "float",
      "vec3 a, vec3 b",
      pe`
      if (any(isnan(a)) || any(isnan(b))) return NaN;
      vec3 d = a-b;
      return dcg_hypot(dcg_hypot(d.x, d.y), d.z);`,
    ),
    hsv: kr(
      "vec3",
      "float h, float s, float v",
      pe`if (isnan(h) || isnan(s) || isnan(v)) {discard;}
      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      if (isinf(h)) h = 0.0;
      vec3 p = abs(fract(h / 360.0 + K.xyz) * 6.0 - K.www);
      return vec3(clamp(v, 0.0, 1.0) * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), clamp(s, 0.0, 1.0)));`,
    ),
    rgb: kr(
      "vec3",
      "float r, float g, float b",
      pe`if (isnan(r) || isnan(g) || isnan(b)) {discard;}
    return clamp(vec3(r,g,b),0.0,255.0)/255.0;`,
    ),
    erf: ci(pe`if (isnan(x)) return NaN;
      float t = abs(x);
      float n = x*x;
      float r = -n;
      return sign(x) * (
        r < -750.0
          ? 1.0
          : t >= 0.065
          ? 1.0 - exp(r) * (
            t > 50000000.0
              ? r / t
              : t > 50.0
              ? (r * (n * (n + 4.5) + 2.0)) / (t * (n * (n + 5.0) + 3.75))
              : ((0.9999999999999999+t*(2.224574423459406+t*(2.444115549920689+
                t*(1.7057986861852539+t*(0.8257463703357973+
                  t*(0.28647031042892007+t*(0.07124513844341643+
                    t*(0.012296749268608364+t*(0.001347817214557592+
                      0.00007263959403471071*t))))))))
                )/(1.0+t*(3.352953590554884+t*(5.227518529742423+
                  t*(5.003720878235473+t*(3.266590890998987+
                    t*(1.5255421920765353+t*(0.5185887413188858+
                      t*(0.12747319185915415+t*(0.02185979575963238+
                        t*(0.0023889438122503674+0.00012875032817508128*t
                ))))))))))
              )
          )
          : t*(1.1283791670955126+r*(0.37612638903183754+
              r*(0.11283791670955126+r*(0.026866170645131252+
                0.005223977625442188*r))))
      );`),
    restriction: kr("bool", "bool x", "return x;"),
    restrictionToBoolean: kr("bool", "bool x", "return x;"),
    complex: kr(
      "vec2",
      "float u, float v",
      pe`if (isnan(u) || isnan(v)) { return vec2(NaN, NaN); }
    return vec2(u,v);`,
    ),
    real: kr("float", "vec2 c", "return c.x;"),
    imag: kr("float", "vec2 c", "return c.y;"),
    arg: kr("float", "vec2 c", "return dcg_arctan(c.y,c.x);"),
    peelableCoerceComplexToReal: kr(
      "float",
      "vec2 a",
      "return a.y == 0.0 ? a.x : NaN;",
    ),
    coerceComplexToReal: kr(
      "float",
      "vec2 a",
      "return a.y == 0.0 ? a.x : NaN;",
    ),
    coerceRealToComplex: kr(
      "vec2",
      "float x",
      "return isnan(x) ? vec2(NaN, NaN) : vec2(x, 0);",
    ),
    complexSqrt: $s(pe`float u = z.x; float v = z.y;
    float r = sqrt(0.5 * (abs(u) + dcg_hypot(u, v)));
    if (r == 0.0 || isnan(v) || isinf(v)) return dcg_complex(r, v);
    if (u > 0.0) return dcg_complex(r, 0.5 * (v / r));
    if (v < 0.0) r = -r;
    return dcg_complex(0.5 * (v / r), r);`),
    complexDivide: kr(
      "vec2",
      "vec2 a, vec2 b",
      pe`float u1 = a.x; float v1 = a.y;
      float u2 = b.x; float v2 = b.y;
      if (isnan(u1) || isnan(v1) || isnan(u2) || isnan(v2)) return vec2(NaN, NaN);
      if (isinf(u1) || isinf(v1)) return vec2(NaN, NaN);
      if (u2 == 0.0 && v2 == 0.0) return vec2(NaN, NaN);
      if (isinf(u2) || isinf(v2)) return vec2(0.0, 0.0);
      if (abs(v2) <= abs(u2)) {
        return dcg_subComplexDivide(a, b);
      } else {
        return dcg_conj(dcg_subComplexDivide(a.yx, b.yx));
      }`,
    ),
    complexLn: $s(pe`float u = z.x; float v = z.y;
      return dcg_complex(dcg_ln(dcg_hypot(u,v)), dcg_arctan(v,u));`),
    complexExp: $s(pe`float u = z.x; float v = z.y;
      if (isnan(u)) return vec2(NaN, NaN);
      float r = exp(u);
      return v == 0.0 ? vec2(r, 0.0) : dcg_complexFromPolarRounded(r, v);`),
    complexPow: kr(
      "vec2",
      "vec2 z1, vec2 z2",
      pe`float u2 = z2.x; float v2 = z2.y;
      float u1 = z1.x; float v1 = z1.y;
      if (isnan(u1) || isnan(v1) || isnan(u2) || isnan(v2))
        return vec2(NaN, NaN);
      float r1 = dcg_hypot(u1, v1);
      float theta1 = dcg_arctan(v1, u1);
      float rOut = pow(r1, u2) * exp(-theta1 * v2);
      float thetaOut = log(r1) * v2 + theta1 * u2;
      if (!isinf(rOut)) {
        return dcg_complexFromPolarRounded(rOut, thetaOut);
      } else {
        return dcg_complexFromPolarRounded(
          exp(u2 * log(r1) - theta1 * v2),
          thetaOut
        );
      }
      `,
    ),
    complexSin: $s(pe`float u = z.x; float v = z.y;
      return dcg_complex(dcg_sin(u) * dcg_cosh(v), dcg_cos(u) * dcg_sinh(v));`),
    complexCos: $s(pe`float u = z.x; float v = z.y;
      return dcg_complex(dcg_cos(u) * dcg_cosh(v), -dcg_sin(u) * dcg_sinh(v));`),
    complexSinh: $s(pe`float u = z.x; float v = z.y;
      return dcg_complex(dcg_sinh(u) * dcg_cos(v), dcg_cosh(u) * dcg_sin(v));`),
    complexCosh: $s(pe`float u = z.x; float v = z.y;
      return dcg_complex(dcg_cosh(u) * dcg_cos(v), dcg_sinh(u) * dcg_sin(v));`),
    complexTanh: $s(pe`float u = z.x; float v = z.y;
      float tanv = dcg_tan(v); float tanhu = dcg_tanh(u);
      if (isnan(tanv) || isnan(tanhu)) return vec2(NaN, NaN);
      if (isinf(tanv)) return vec2(1.0 / tanhu, 0.0);

      float tanv2 = tanv * tanv;
      float secv2 = 1.0 + tanv2;
      float sinhu = dcg_sinh(u);
      float sinhu2 = sinhu * sinhu;
      float tanhu2 = tanhu * tanhu;
      return dcg_complex(
        (secv2 * tanhu) / (1.0 + tanv2 * tanhu2),
        tanv / (1.0 + secv2 * sinhu2)
      );`),
    complexTan: $s(pe`float u = z.x; float v = z.y;
      vec2 t = dcg_complexTanh(vec2(-v, u));
      return vec2(t.y, -t.x);`),
    complexSec: $s("return dcg_complexReciprocal(dcg_complexCos(z));"),
    complexCsc: $s("return dcg_complexReciprocal(dcg_complexSin(z));"),
    complexCot: $s("return dcg_complexReciprocal(dcg_complexTan(z));"),
    complexSech: $s("return dcg_complexReciprocal(dcg_complexCosh(z));"),
    complexCsch: $s("return dcg_complexReciprocal(dcg_complexSinh(z));"),
    complexCoth: $s("return dcg_complexReciprocal(dcg_complexTanh(z));"),
    complexLogbase: kr(
      "vec2",
      "vec2 z, vec2 base",
      pe`
      float u = z.x; float v = z.y;
      float bu = base.x; float covp = base.y;
      if (any(isnan(z)) || any(isnan(base))) return vec2(NaN, NaN);
      if (covp == 0.0 && bu == 0.0) return vec2(NaN, NaN);
      if (u == 0.0 && v == 0.0) return vec2(-Infinity, 0);${""}
      return dcg_complexDivide(dcg_complexLn(z), dcg_complexLn(base));`,
    ),
    complexLog: $s("return dcg_complexLogbase(z, vec2(10.0,0.0));"),
  });
  function kr(e, t, n) {
    return { type: "scalar", value: `${e} dcg_[[name_here]](${t}){ ${n} }` };
  }
  function ci(e) {
    return kr("float", "float x", e);
  }
  function Dn(e) {
    return ci(`return ${e};`);
  }
  function AN(e) {
    return kr("float", "float x, float y", e);
  }
  function qf(e) {
    return AN(`return ${e};`);
  }
  function $s(e) {
    return kr("vec2", "vec2 z", e);
  }
  function Ys(e, { inType: t, outType: n, deps: r } = {}) {
    let s = t != null ? t : (o) => `float[${o}]`,
      i = n != null ? n : () => "float";
    return {
      type: "reducer",
      value: (o) => `${i(o)} dcg_[[name_here]](${s(o)} L) { ${e(o)} }`,
      deps: r != null ? r : [],
    };
  }
  function eM(e) {
    return {
      type: "double-reducer",
      value: (t, n) => {
        let r = Math.min(t, n), s = e(r);
        return `float dcg_[[name_here]](float[${t}] X, float[${n}] Y) { ${s} }`;
      },
    };
  }
  var OH = tM({
    lcm: Ys((e) =>
      pe`float g = abs(dcg_round(L[0]));
      if (isnan(g) || isinf(g)) return NaN;
      for (int i=1; i<${e}; i++) {
        float v = abs(dcg_round(L[i]));
        if (isnan(v) || isinf(v)) return NaN;
        if (g != 0.0)
          g *= dcg_round(v / dcg_gcd2(g, v));
      }
      return g;`
    ),
    gcd: Ys((e) =>
      pe`float g = abs(dcg_round(L[0]));
      if (isnan(g) || isinf(g)) return NaN;
      for (int i=1; i<${e}; i++) {
        float x = L[i];
        if (isnan(x) || isinf(x)) return NaN;
        g = dcg_gcd2(g, abs(dcg_round(x)));
      }
      return g;`
    ),
    mean: Ys((e) =>
      pe`float tot = 0.0;
      for (int i=0; i<${e}; i++) {
        float x = L[i];
        if (isnan(x) || (isinf(x) && x == -tot)) return NaN;
        tot += x;
      }
      return tot / ${e}.0;`
    ),
    total: Ys((e) =>
      pe`float tot = 0.0;
      for (int i=0; i<${e}; i++) {
        float x = L[i];
        if (isnan(x) || (isinf(x) && x == -tot)) return NaN;
        tot += x;
      }
      return tot;`
    ),
    stdev: Ys((e) => SN(e, e - 1), { deps: ["mean"] }),
    stdevp: Ys((e) => SN(e, e), { deps: ["mean"] }),
    mad: Ys((e) =>
      pe`float mean = dcg_mean(L);
      if (isnan(mean) || isinf(mean)) return NaN;
      float tot = 0.0;
      for (int i=0; i<${e}; i++) {
        tot += abs(L[i] - mean);
      }
      return tot / ${e}.0;`, { deps: ["mean"] }),
    listMin: Ys((e) => vN(e, "min")),
    listMax: Ys((e) => vN(e, "max")),
    argmin: Ys((e) => ON(e, "<")),
    argmax: Ys((e) => ON(e, ">=")),
    median: Ys(
      (e) =>
        e % 2 === 1
          ? `return L[int(dcg_sortPerm(L)[${(e - 1) / 2}])];`
          : pe`float[${e}] perm = dcg_sortPerm(L);
          return 0.5*(L[int(perm[${e / 2}])]+L[int(perm[${e / 2 - 1}])]);`,
      {
        deps: ["sortPerm"],
      },
    ),
    varp: Ys((e) => DN(e, e), { deps: ["mean"] }),
    var: Ys((e) => DN(e, e - 1), { deps: ["mean"] }),
    sortPerm: Ys((e) => {
      if (e > 100) throw Oc();
      return pe`float[${e}] permFloat;
        float lastMin = -Infinity;
        int lastIndex = -1;
        for (int i=0; i<${e}; i++) {
          float currMin = NaN;
          int currIndex = ${e};
          int j;
          for (j=0; j<${e}; j++) {
            float e = L[j];
            float cmpLast = dcg_compareAscendingNaNLast(e, lastMin);
            float cmpCurr = dcg_compareAscendingNaNLast(currMin, e);
            if (
              (cmpLast > 0.0 || (cmpLast == 0.0 && j > lastIndex))
              && (cmpCurr > 0.0 || (cmpCurr == 0.0 && j < currIndex))
            ) {
              currMin = e;
              currIndex = j;
            }
          }
          permFloat[i] = float(currIndex);
          lastMin = currMin;
          lastIndex = currIndex;
        }
        return permFloat;`;
    }, { outType: (e) => `float[${e}]` }),
    complexSortPerm: Ys((e) => {
      if (e > 100) throw Oc();
      return pe`float[${e}] permFloat;
      vec2 lastMin = vec2(-Infinity,-Infinity);
      int lastIndex = -1;
      for (int i=0; i<${e}; i++) {
        vec2 currMin = vec2(NaN,NaN);
        int currIndex = ${e};
        int j;
        for (j=0; j<${e}; j++) {
          vec2 e = L[j];
          float cmpLast = dcg_compareComplexLexicographic(e, lastMin);
          float cmpCurr = dcg_compareComplexLexicographic(currMin, e);
          if (
            (cmpLast > 0.0 || (cmpLast == 0.0 && j > lastIndex))
            && (cmpCurr > 0.0 || (cmpCurr == 0.0 && j < currIndex))
          ) {
            currMin = e;
            currIndex = j;
          }
        }
        permFloat[i] = float(currIndex);
        lastMin = currMin;
        lastIndex = currIndex;
      }
      return permFloat;`;
    }, { inType: (e) => `vec2[${e}]`, outType: (e) => `float[${e}]` }),
  });
  function DN(e, t) {
    return t === 0 ? "return NaN;" : pe`float mean = dcg_mean(L);
    if (isnan(mean) || isinf(mean)) return NaN;
    float tot = 0.0;
    for (int i=0; i<${e}; i++) {
      float delta = L[i] - mean;
      tot += delta * delta;
    }
    return tot / ${t}.0;`;
  }
  function SN(e, t) {
    return t === 0 ? "return NaN;" : pe`float mean = dcg_mean(L);
    if (isnan(mean) || isinf(mean)) return NaN;
    float tot = 0.0;
    for (int i=0; i<${e}; i++) {
      tot = dcg_hypot(tot, L[i] - mean);
    }
    return tot / ${nM(Math.sqrt(t))};`;
  }
  function vN(e, t) {
    return pe`float m = L[0];
    if (isnan(m)) return NaN;
    for (int i=1; i<${e}; i++) {
      float x = L[i];
      if (isnan(x)) return NaN;
      m = ${t}(m, x);
    }
    return m;`;
  }
  function ON(e, t) {
    return pe`if (isnan(L[0])) return 0.0;
    int arg = 0;
    float best = L[0];
    for (int i=1; i<${e}; i++) {
      float e = L[i];
      if (isnan(e)) return 0.0;
      if (e ${t} best) {
        arg = i;
        best = e;
      }
    }
    return float(arg + 1);`;
  }
  var NH = tM({
      cov: eM((e) => NN(e, e - 1)),
      covp: eM((e) => NN(e, e)),
      corr: eM((e) =>
        pe`${_N(e)}
      float t1 = 0.0;
      float t2 = 0.0;
      float tc = 0.0;
      for (int i=0; i<${e}; i++) {
        float d1 = X[i] - m1;
        float d2 = Y[i] - m2;
        t1 = dcg_hypot(t1, d1);
        t2 = dcg_hypot(t2, d2);
        tc += d1 * d2;
      }
      return tc / (t1 * t2);`
      ),
    }),
    RH = {
      type: "elementsAt",
      value: (e, t) =>
        `${e}[${t}] dcg_elementsAt(${e}[${t}] X, float[${t}] Y) {
      ${e}[${t}] outList;
      for (int i=0; i<${t}; i++) {
        outList[i] = X[int(Y[i])];
      }
      return outList;
    }`,
    },
    AH = { ...RN, ...OH, ...NH, elementsAt: RH },
    yh = AH;
  function _H(e, t) {
    switch (e.type) {
      case "scalar":
        return e.value.replace("[[name_here]]", t);
      case "reducer": {
        let n = e.value;
        return (r) => n(r).replace("[[name_here]]", t);
      }
      case "double-reducer": {
        let n = e.value;
        return (r, s) => n(r, s).replace("[[name_here]]", t);
      }
      default:
        return e.value;
    }
  }
  function tM(e) {
    for (let [t, n] of Object.entries(e)) {
      n.type !== "omitted" && (n.value = _H(n, t));
    }
    return e;
  }
  function NN(e, t) {
    return pe`${_N(e)}
    float tot = 0.0;
    for (int i=0; i<${e}; i++) {
      tot += (X[i] - m1) * (Y[i] - m2);
    }
    return tot / ${t}.0;`;
  }
  function _N(e) {
    return pe`float m1 = 0.0;
    for (int i=0; i<${e}; i++) {
      float x = X[i];
      if (isnan(x) || isinf(x)) return NaN;
      m1 += x;
    }
    m1 /= ${e}.0;
    float m2 = 0.0;
    for (int i=0; i<${e}; i++) {
      float y = Y[i];
      if (isnan(y) || isinf(y)) return NaN;
      m2 += y;
    }
    m2 /= ${e}.0;`;
  }
  var LH = [
      pe`float dcg_rawpow(float x, float y) {
    if (isnan(x) || isnan(y)) return NaN;
    if (y==0.0) return 1.0;
    if (isinf(y)) {${""}
      float a = abs(x);
      if (a == 1.0) return NaN;
      if (y > 0.0) {
        return a > 1.0 ? Infinity : 0.0;
      } else {
        return a < 1.0 ? Infinity : 0.0;
      }
    }
    if (x > 0.0) return pow(x, y);
    else if (x == 0.0) {
      if (y > 0.0) return 0.0;
      else if (y == 0.0) return 1.0;
      else return Infinity;
    } else {
      float m = mod(y, 2.0);
      if (m == 1.0) return -pow(-x, y);
      else return pow(-x, y);
    }
  }`,
      pe`float dcg_pow(float x, float y) {
    if (isnan(x) || isnan(y)) return NaN;
    if (y==0.0) return 1.0;
    if (isinf(y)) {
      float a = abs(x);
      if (a == 1.0) return NaN;
      if (y > 0.0) {
        return a > 1.0 ? Infinity : 0.0;
      } else {
        return a < 1.0 ? Infinity : 0.0;
      }
    }
    if (x > 0.0) return pow(x,y);
    else if (x == 0.0) {
      if (y > 0.0) return 0.0;
      if (y == 0.0) return 1.0;
      if (y < 0.0) return Infinity;
    } else {
      float m = mod(y, 2.0);
      if (m == 0.0) return pow(-x, y);
      else if (m == 1.0) return -pow(-x, y);
      else {${""}
        vec2 a0 = vec2(0.0, 1.0);
        vec2 a1 = vec2(1.0, 0.0);
        float approx = y;
        for (int i=0; i<12; i+=1) {
          float whole = floor(approx);
          vec2 a = whole * a1 + a0;
          if (a.y > 100.0) break;
          a0 = a1; a1 = a;
          if (approx == whole) break;
          approx = 1.0 / (approx - whole);
        }${""}
        float r = a1.x / a1.y;
        float m = max(max(abs(y), abs(r)), 1.0);
        if (abs(mod(a1.y, 2.0) - 1.0) < 0.01 && abs((r - y)/y) < 0.00001) {
          return (mod(a1.x, 2.0) == 0.0 ? 1.0 : -1.0) * pow(-x, y);
        } else {
          return NaN;
        }
      }
    }
  }`,
      pe`float dcg_add(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) && x != y ? NaN
      : x + y;
  }`,
      pe`float dcg_sub(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) && x != -y ? NaN
      : x - y;
  }`,
      pe`float dcg_mul(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && y == 0.0 ? NaN
      : x == 0.0 && isinf(y) ? NaN
      : x * y;
  }`,
      pe`float dcg_div(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) ? NaN
      : x == 0.0 && y == 0.0 ? NaN
      : x / y;
  }`,
      pe`float dcg_neg(float x) {
    return isnan(x) ? NaN : -x;
  }`,
      pe`bool dcg_equal(float x, float y) {
    return isnan(x) || isnan(y) ? false : x == y;
  }`,
      pe`bool dcg_less(float x, float y) {
    return isnan(x) || isnan(y) ? false : x < y;
  }`,
      pe`bool dcg_lessEqual(float x, float y) {
    return isnan(x) || isnan(y) ? false : x <= y;
  }`,
      pe`bool dcg_greater(float x, float y) {
    return isnan(x) || isnan(y) ? false : x > y;
  }`,
      pe`bool dcg_greaterEqual(float x, float y) {
    return isnan(x) || isnan(y) ? false : x >= y;
  }`,
      pe`float dcg_gcd2(float u, float v) {
    for (int i=0; i<95; i++) {
      if (v == 0.0) break;
      u = mod(u, v);
      if (u == 0.0) break;
      v = mod(v, u);
    }
    return u+v;
  }`,
      pe`float dcg_log1p(float x) {
    return x - 0.5 * x * x == x ? x : log(1.0 + x);
  }`,
      pe`bool dcg_isPiMultiple(float absx) {
    if (absx > 1.0e5) return false;
    return floor(0.5 + dcg_PI_INV * absx) * dcg_PI == absx;
  }`,
      pe`bool dcg_isOddHalfPiMultiple(float absx) {
    if (absx > 1.0e5) return false;
    float n = floor(0.5 + 2.0 * dcg_PI_INV * absx);
    return mod(n, 2.0) == 1.0 && n * dcg_PI == 2.0 * absx;
  }`,
      "vec2 dcg_conj(vec2 a) { return vec2(a.x, -a.y); }",
      pe`vec2 dcg_subComplexDivide(vec2 a, vec2 b) {
    float u1 = a.x; float v1 = a.y;
    float u2 = b.x; float v2 = b.y;
    float r = v2 / u2;
    float t = 1.0 / (u2 + v2 * r);
    if (r == 0.0) {
      return dcg_complex((u1 + v2 * (v1 / u2)) * t, (v1 - v2 * (u1 / u2)) * t);
    } else {
      return dcg_complex((u1 + v1 * r) * t, (v1 - u1 * r) * t);
    }
  }`,
      pe`vec2 dcg_complexFromPolarRounded(float r, float theta) {
    if (isnan(r) || isnan(theta)) return vec2(NaN, NaN);
    if (r == 0.0) return vec2(0.0, 0.0);
    return dcg_complex(r * dcg_cos(theta), r * dcg_sin(theta));
  }`,
      pe`vec2 dcg_complexReciprocal(vec2 z) {
    return dcg_complexDivide(vec2(1.0,0.0), z);
  }`,
      pe`float dcg_compareAscendingNaNLast(float x, float y) {
    float diff = dcg_sub(x,y);
    return !isnan(diff) ? diff : float(isnan(x)) - float(isnan(y));
  }`,
      pe`float dcg_compareComplexLexicographic(vec2 x, vec2 y) {
    float realComparison = dcg_compareAscendingNaNLast(x.x, y.x);
    return realComparison != 0.0 ? realComparison : dcg_compareAscendingNaNLast(x.y, y.y);
  }`,
    ].join(`
`),
    wH = `
  float dcg_round(float x);
  float dcg_hypot(float x, float y);
  float dcg_rtxsqpone(float x);
  float dcg_rtxsqmone(float x);
  float dcg_cos(float x);
  float dcg_sin(float x);
  float dcg_tan(float x);
  float dcg_tanh(float x);
  vec2 dcg_complex(float u, float v);
  vec2 dcg_complexDivide(vec2 a, vec2 b);
`,
    FH = Object.values(RN).map((e) => e.value).join(`
`),
    oK = pe`uniform float NaN;
    uniform float Infinity;
    #define dcg_PI 3.141592653589793
    #define dcg_PI_INV 0.3183098861837907
    ${wH}\n
    ${LH}\n
    ${FH}`;
  function pe(e, ...t) {
    let n = e[0];
    for (let r = 0; r < t.length; r++) n += t[r], n += e[r + 1];
    return VH(n);
  }
  function VH(e) {
    let t = e.split(`
`);
    if (/^\s/.test(t[0][0])) {
      throw new Error("Programming error: Expected un-indented first line");
    }
    if (t.length <= 1) return e;
    let n = Math.min(...t.slice(1).map((r) => r.match(/^\s*/)[0].length));
    return t[0] + `
` + t.slice(1).map((r) => r.slice(n)).join(`
`);
  }
  function Ma(e, t) {
    let n = new rM(e, t), r = Zg(n);
    return n.finish(r);
  }
  var rM = class extends wp {
    constructor(n, r) {
      super(n, true);
      this.maxUniforms = r;
      this.glsl = true;
      this.shaderUniforms = [];
      this.definitions = {};
    }
    finish(n) {
      return {
        source: n,
        shaderFunctions: BH(this.chunk, this.definitions),
        shaderUniforms: this.shaderUniforms,
      };
    }
    printValue(n, r) {
      if (Array.isArray(n)) {
        if (n.length > 100) throw Oc();
        let s = j(r),
          i = s ? Ve(r) : r,
          o = n.map((c) => this.printValue(c, i)).join(","),
          a = $f(r),
          u = LN({ type: a, arity: n.length });
        return this.definitions[u] = true,
          (s ? "buildList" : a) + "(" + o + ")";
      }
      switch (typeof n) {
        case "boolean":
          return n.toString();
        case "number":
          return this.printFloatOrUniformGLSL(n);
        case "string":
          throw Xl("random");
        case "object":
          if (gu(n)) throw new Error("Action values cannot be compiled");
          return this.printFloatOrUniformGLSL(V(n));
        default:
          throw new Error("Unexpected value: " + n);
      }
    }
    printFloatOrUniformGLSL(n) {
      if (this.shaderUniforms.length >= this.maxUniforms) return nM(n);
      {
        let s = "_DCG_SC_" + this.shaderUniforms.length;
        return this.shaderUniforms.push(n), s;
      }
    }
    beforeBeginLoop(n) {
      let r = this.chunk.getInstruction(n.args[0]),
        s = this.chunk.getInstruction(n.args[1]),
        i = n.callData.type === "sum";
      if (r.type !== 1) {
        let u = fs(this.chunk, n.args[0]);
        throw i ? gy(u) : hy(u);
      }
      if (s.type !== 1) {
        let u = fs(this.chunk, n.args[1]);
        throw i ? gy(u) : hy(u);
      }
      if (r.valueType !== Number || s.valueType !== Number) {
        throw new Error("Programming error: non-number in summation bounds");
      }
      let o = V(r.value), a = V(s.value);
      if (!isFinite(a - o) || a - o >= 1e3) throw i ? VT() : BT();
    }
    checkFiniteBounds() {
      return "";
    }
    emitConstant(n) {
      return this.printValue(n.value, n.valueType);
    }
    emitNeg(n) {
      return `dcg_neg(${n})`;
    }
    emitTernary(n, r, s, i) {
      return j(i.valueType) ? `dcg_ternary(${n},${r},${s})` : `${n}?${r}:${s}`;
    }
    emitVec2(n, r) {
      return `vec2(${n},${r})`;
    }
    emitVec3(n, r, s) {
      return `vec3(${n},${r},${s})`;
    }
    emitVecAccess(n, r) {
      return `${n}.${r === 0 ? "x" : r === 1 ? "y" : "z"}`;
    }
    emitBinary(n, r, s) {
      switch (n.type) {
        case 8:
          return `dcg_add(${r},${s})`;
        case 9:
          return `dcg_sub(${r},${s})`;
        case 10:
          return `dcg_mul(${r},${s})`;
        case 11:
          return `dcg_div(${r},${s})`;
        case 12:
          return `dcg_pow(${r},${s})`;
        case 13:
          return `dcg_rawpow(${r},${s})`;
        case 25:
          return `dcg_equal(${r},${s})`;
        case 26:
          return `dcg_less(${r},${s})`;
        case 28:
          return `dcg_lessEqual(${r},${s})`;
        case 27:
          return `dcg_greater(${r},${s})`;
        case 29:
          return `dcg_greaterEqual(${r},${s})`;
        case 31:
          return `${r}||${s}`;
        case 32:
          return `${r}&&${s}`;
        default:
          throw new Error("Programming Error: invalid binary opcode.");
      }
    }
    emitList(n, r) {
      let s = LN({ type: $f(r.valueType), arity: r.args.length });
      return this.definitions[s] = true, `buildList(${n.join(",")})`;
    }
    emitListAccess(n, r, s, i) {
      let o = qn(this.chunk, i.args[0]);
      if (o === void 0) throw mu(fs(this.chunk, i.args[0]));
      let a = `int(${r})`;
      return `(${a}>=1&&${a}<=${o})?${n}[${a}-1]:${s}`;
    }
    emitInboundsListAccess(n, r) {
      return `${n}[int(${r})-1]`;
    }
    emitNativeFunction(n, r) {
      if (!yh[r.symbol]) throw Xl(r.symbol);
      return `dcg_${r.symbol}(${n.join(",")})`;
    }
    emitExtendSeed() {
      throw Xl("random");
    }
    emitVarDeclaration(n, r) {
      let s = r ? ";" : "";
      return s += sM(this.chunk, n) + " " + fn(n), s;
    }
    emitImmediateAssignment(n, r, s) {
      return `${sM(this.chunk, n)} ${r}=${s};`;
    }
    emitFunctionCall() {
      throw Xl("recursion");
    }
  };
  function hK(...e) {
    return Object.keys(Object.assign({}, ...e)).join(`
`);
  }
  function LN(e) {
    let { type: t, arity: n } = e, r = t + "[" + n + "]", s = r + " buildList(";
    for (let i = 0; i < n - 1; i++) s += `${t} _${i}, `;
    s += `${t} _${n - 1}) {
`,
      s += r + ` a;
`;
    for (let i = 0; i < n; i++) {
      s += `a[${i}] = _${i};
`;
    }
    return s += `return a;
}
`,
      s;
  }
  function BH(e, t) {
    let n = e.argNames.length, r = e.instructionsLength() - 1;
    for (let s = n; s <= r; s++) {
      let i = e.getInstruction(s);
      if (i.type === 33) {
        if (j(i.valueType)) {
          let o = sM(e, s),
            a =
              `${o} dcg_ternary(bool x, ${o} y, ${o} z) { if (x) return y; return z; }`;
          t[a] = true;
        }
      } else if (i.type === 37) {
        let o = yh[i.symbol];
        if ((o == null ? void 0 : o.type) === "reducer") {
          let a = i.args[0], u = qn(e, a);
          if (u === void 0) throw mu(fs(e, a));
          for (let c of o.deps) t[yh[c].value(u)] = true;
          t[o.value(u)] = true;
        } else if ((o == null ? void 0 : o.type) === "double-reducer") {
          let a = i.args[0], u = i.args[1], c = qn(e, a), l = qn(e, u);
          if (c === void 0) throw mu(fs(e, a));
          if (l === void 0) throw mu(fs(e, u));
          t[o.value(c, l)] = true;
        } else if ((o == null ? void 0 : o.type) === "elementsAt") {
          let a = $f(Ve(i.valueType)), u = i.args[1], c = qn(e, u);
          if (c === void 0) throw mu(fs(e, u));
          t[o.value(a, c)] = true;
        }
      }
    }
    return t;
  }
  function nM(e) {
    let t = e.toString();
    return /^-?\d+$/.test(t) ? t + ".0" : t;
  }
  function $f(e) {
    switch (j(e) ? Ve(e) : e) {
      case Bool:
        return "bool";
      case Number:
        return "float";
      case Point:
      case Complex:
        return "vec2";
      case RGBColor:
      case Point3D:
        return "vec3";
      default:
        throw new Error("Unexpected type: " + at(e));
    }
  }
  function sM(e, t) {
    let n = e.getInstruction(t);
    if (j(n.valueType)) {
      let r = qn(e, t);
      if (r === void 0) throw mu(fs(e, t));
      if (r > 100) throw Oc();
      return `${$f(n.valueType)}[${r}]`;
    } else return $f(n.valueType);
  }
  function bK(e) {
    let t = {}, n = "";
    if (e) {
      for (let r = 0; r < e.length; r++) {
        let s = "_DCG_SC_" + r;
        t[s] = { value: e[r] },
          n += "uniform float " + s + `;
`;
      }
    }
    return { uniforms: t, declarations: n };
  }
  function wN(e) {
    let t = [], n = [];
    for (let r = 0; r < e.argNames.length; r++) {
      let s = [], i = [];
      for (let o = 0; o < e.argNames.length; o++) {
        s.push(e.argTypes[o] === Number), i.push(r === o);
      }
      n.push(i), t.push(s);
    }
    for (let r = e.argNames.length; r <= e.getReturnIndex(); r++) {
      n.push(GH(e, n, r)), t.push(kH(e, n, t, r));
    }
    return t[e.getReturnIndex()];
  }
  function GH(e, t, n) {
    let r = e.getInstruction(n), s = zH(e.argNames.length);
    if (ge(r)) return s;
    for (let i of r.args) {
      let o = t[i];
      for (let a = 0; a < o.length; a++) s[a] = s[a] || o[a];
    }
    return s;
  }
  function kH(e, t, n, r) {
    let s = e.getInstruction(r);
    if (ge(s)) return iM(e.argNames.length);
    switch (s.type) {
      case 8:
      case 9:
      case 14:
      case 15:
      case 16:
      case 38: {
        let o = iM(e.argNames.length);
        for (let a = 0; a < s.args.length; a++) {
          let u = n[s.args[a]];
          for (let c = 0; c < u.length; c++) o[c] = o[c] && u[c];
        }
        return o;
      }
      case 11: {
        let o = [], a = n[s.args[0]], u = t[s.args[1]];
        for (let c = 0; c < a.length; c++) o.push(a[c] && !u[c]);
        return o;
      }
      case 10: {
        let o = n[s.args[0]].slice(),
          a = n[s.args[1]].slice(),
          u = t[s.args[0]],
          c = t[s.args[1]],
          l = 0,
          p = 0;
        for (let f = 0; f < o.length; f++) {
          let d = o[f] && !c[f], y = a[f] && !u[f];
          o[f] = d, a[f] = y, d && (l += 1), y && (p += 1);
        }
        return l >= p ? o : a;
      }
      case 33: {
        let o = t[s.args[0]], a = n[s.args[1]], u = n[s.args[2]], c = [];
        for (let l = 0; l < o.length; l++) c.push(!o[l] && a[l] && u[l]);
        return c;
      }
      case 39:
      case 40:
      case 41: {
        let o = n[s.args[0]], a = t[s.args[1]], u = [];
        for (let c = 0; c < a.length; c++) u.push(o[c] && !a[c]);
        return u;
      }
      case 48: {
        let o = s.args[0], a = e.getInstruction(o), u = r - o;
        return n[a.args[u]];
      }
      case 37:
        return HH(e, s, t, n, r);
      case 12:
      case 13:
      case 26:
      case 28:
      case 27:
      case 29:
      case 25:
      case 32:
      case 31:
      case 42:
      case 21:
      case 22:
      case 19:
      case 20:
      case 23:
      case 24:
      case 47:
      case 44:
      case 49:
      case 50:
      case 51:
      case 53:
      case 54:
      case 55: {
        let o = t[r], a = [];
        for (let u of o) a.push(!u);
        return a;
      }
      default:
        let i = s;
        throw new Error(`Unexpected opcode ${i.type}`);
    }
  }
  function HH(e, t, n, r, s) {
    switch (t.symbol) {
      case "complex": {
        let i = iM(e.argNames.length);
        for (let o = 0; o < t.args.length; o++) {
          let a = r[t.args[o]];
          for (let u = 0; u < a.length; u++) i[u] = i[u] && a[u];
        }
        return i;
      }
      default: {
        let i = n[s], o = [];
        for (let a of i) o.push(!a);
        return o;
      }
    }
  }
  function zH(e) {
    let t = [];
    for (let n = 0; n < e; n++) t.push(false);
    return t;
  }
  function iM(e) {
    let t = [];
    for (let n = 0; n < e; n++) t.push(true);
    return t;
  }
  function Sn(e, t, n) {
    switch (t) {
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 21:
      case 19:
      case 23:
      case 50:
        return Number;
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 31:
      case 32:
        return Bool;
      case 33: {
        let s = e.getInstruction(n[1]).valueType,
          i = e.getInstruction(n[2]).valueType,
          o = Ha(s, i);
        return o === void 0 ? s : o;
      }
      case 38:
        return jp(n.map((s) => e.getInstruction(s).valueType));
      case 39:
      case 40:
      case 41: {
        let s = e.getInstruction(n[0]).valueType;
        return j(s) ? Ve(s) : Any;
      }
      case 44:
        return SeedType;
      case 49:
        return Action;
      case 55:
        return e.getInstruction(n[0]).valueType;
      case 1:
      case 2:
      case 37:
      case 42:
      case 47:
      case 48:
      case 3:
      case 0:
      case 24:
      case 22:
      case 20:
      case 51:
      case 4:
      case 53:
      case 54:
      case 15:
      case 16:
        return Any;
      default:
        let r = t;
        throw new Error(`Unexpected opcode ${r}`);
    }
  }
  function FN(e) {
    if (e.instructionsLength() - 1 !== e.getReturnIndex()) {
      throw new Error(
        "Programming Error: only the final instruction in a chunk can be lifted to numbers",
      );
    }
    let t = e.getInstruction(e.getReturnIndex());
    if (ge(t)) return e.getReturnIndex();
    switch (t.type) {
      case 8:
        let [n, r] = t.args;
        return cr(e, n) && cr(e, r)
          ? (e.popInstruction(),
            e.NativeFunction("complex", [
              e.Add([e.Slot(0, [n]), e.Slot(0, [r])]),
              e.Add([e.Slot(1, [n]), e.Slot(1, [r])]),
            ]))
          : cr(e, n) && rs(e, r)
          ? (e.popInstruction(),
            e.NativeFunction("complex", [
              e.Add([e.Slot(0, [n]), r]),
              e.Slot(1, [n]),
            ]))
          : rs(e, n) && cr(e, r)
          ? (e.popInstruction(),
            e.NativeFunction("complex", [
              e.Add([n, e.Slot(0, [r])]),
              e.Slot(1, [r]),
            ]))
          : Uu(e, n) && Uu(e, r)
          ? (e.popInstruction(),
            e.TupleOfType(Point, [
              e.Add([e.Slot(0, [n]), e.Slot(0, [r])]),
              e.Add([e.Slot(1, [n]), e.Slot(1, [r])]),
            ]))
          : qu(e, n) && qu(e, r)
          ? (e.popInstruction(),
            e.TupleOfType(Point3D, [
              e.Add([e.Slot(0, [n]), e.Slot(0, [r])]),
              e.Add([e.Slot(1, [n]), e.Slot(1, [r])]),
              e.Add([e.Slot(2, [n]), e.Slot(2, [r])]),
            ]))
          : eu(e, t.args)
          ? (e.popInstruction(),
            $u(e, [e.Add([Ss(e, n), Ss(e, r)]), $o(e, t.args[0])]))
          : e.getReturnIndex();
      case 9: {
        let [i, o] = t.args;
        return cr(e, i) && cr(e, o)
          ? (e.popInstruction(),
            e.NativeFunction("complex", [
              e.Subtract([e.Slot(0, [i]), e.Slot(0, [o])]),
              e.Subtract([e.Slot(1, [i]), e.Slot(1, [o])]),
            ]))
          : cr(e, i) && rs(e, o)
          ? (e.popInstruction(),
            e.NativeFunction("complex", [
              e.Subtract([e.Slot(0, [i]), o]),
              e.Slot(1, [i]),
            ]))
          : rs(e, i) && cr(e, o)
          ? (e.popInstruction(),
            e.NativeFunction("complex", [
              e.Subtract([i, e.Slot(0, [o])]),
              e.Negative([e.Slot(1, [o])]),
            ]))
          : Uu(e, i) && Uu(e, o)
          ? (e.popInstruction(),
            e.TupleOfType(Point, [
              e.Subtract([e.Slot(0, [i]), e.Slot(0, [o])]),
              e.Subtract([e.Slot(1, [i]), e.Slot(1, [o])]),
            ]))
          : qu(e, i) && qu(e, o)
          ? (e.popInstruction(),
            e.TupleOfType(Point3D, [
              e.Subtract([e.Slot(0, [i]), e.Slot(0, [o])]),
              e.Subtract([e.Slot(1, [i]), e.Slot(1, [o])]),
              e.Subtract([e.Slot(2, [i]), e.Slot(2, [o])]),
            ]))
          : eu(e, t.args)
          ? (e.popInstruction(),
            $u(e, [e.Subtract([Ss(e, i), Ss(e, o)]), $o(e, i)]))
          : e.getReturnIndex();
      }
      case 14: {
        let [i] = t.args;
        return cr(e, i)
          ? (e.popInstruction(),
            e.NativeFunction("complex", [
              e.Negative([e.Slot(0, [i])]),
              e.Negative([e.Slot(1, [i])]),
            ]))
          : Uu(e, i)
          ? (e.popInstruction(),
            e.TupleOfType(Point, [
              e.Negative([e.Slot(0, [i])]),
              e.Negative([e.Slot(1, [i])]),
            ]))
          : qu(e, i)
          ? (e.popInstruction(),
            e.TupleOfType(Point3D, [
              e.Negative([e.Slot(0, [i])]),
              e.Negative([e.Slot(1, [i])]),
              e.Negative([e.Slot(2, [i])]),
            ]))
          : eu(e, t.args)
          ? (e.popInstruction(), $u(e, [e.Negative([Ss(e, i)]), $o(e, i)]))
          : e.getReturnIndex();
      }
      case 10: {
        let [i, o] = t.args;
        if (cr(e, i) && cr(e, o)) {
          e.popInstruction();
          let a = e.Slot(0, [i]),
            u = e.Slot(1, [i]),
            c = e.Slot(0, [o]),
            l = e.Slot(1, [o]);
          return e.NativeFunction("complex", [
            e.Subtract([e.Multiply([a, c]), e.Multiply([u, l])]),
            e.Add([e.Multiply([a, l]), e.Multiply([c, u])]),
          ]);
        } else {
          if (cr(e, i) && rs(e, o)) {
            return e.popInstruction(),
              e.NativeFunction("complex", [
                e.Multiply([e.Slot(0, [i]), o]),
                e.Multiply([e.Slot(1, [i]), o]),
              ]);
          }
          if (rs(e, i) && cr(e, o)) {
            return e.popInstruction(),
              e.NativeFunction("complex", [
                e.Multiply([i, e.Slot(0, [o])]),
                e.Multiply([i, e.Slot(1, [o])]),
              ]);
          }
          if (Yf(e, i) && Yf(e, o)) {
            return e.popInstruction(),
              e.NativeFunction("restriction", [
                e.And([
                  e.NativeFunction("restrictionToBoolean", [i]),
                  e.NativeFunction("restrictionToBoolean", [o]),
                ]),
              ]);
          }
          if (Yf(e, i) || Yf(e, o)) {
            let a, u;
            Yf(e, i) ? (a = i, u = o) : (a = o, u = i);
            let c = e.getInstruction(u).valueType;
            return io(c)
              ? (e.popInstruction(),
                e.Piecewise([
                  e.NativeFunction("restrictionToBoolean", [a]),
                  u,
                  e.NanOfType(c),
                ]))
              : e.getReturnIndex();
          } else {return Uu(e, i) && rs(e, o)
              ? (e.popInstruction(),
                e.TupleOfType(Point, [
                  e.Multiply([e.Slot(0, [i]), o]),
                  e.Multiply([e.Slot(1, [i]), o]),
                ]))
              : rs(e, i) && Uu(e, o)
              ? (e.popInstruction(),
                e.TupleOfType(Point, [
                  e.Multiply([i, e.Slot(0, [o])]),
                  e.Multiply([i, e.Slot(1, [o])]),
                ]))
              : eu(e, [i]) && rs(e, o)
              ? (e.popInstruction(),
                $u(e, [e.Multiply([Ss(e, i), o]), $o(e, i)]))
              : rs(e, i) && eu(e, [o])
              ? (e.popInstruction(),
                $u(e, [e.Multiply([i, Ss(e, o)]), $o(e, o)]))
              : qu(e, i) && rs(e, o)
              ? (e.popInstruction(),
                e.TupleOfType(Point3D, [
                  e.Multiply([e.Slot(0, [i]), o]),
                  e.Multiply([e.Slot(1, [i]), o]),
                  e.Multiply([e.Slot(2, [i]), o]),
                ]))
              : rs(e, i) && qu(e, o)
              ? (e.popInstruction(),
                e.TupleOfType(Point3D, [
                  e.Multiply([i, e.Slot(0, [o])]),
                  e.Multiply([i, e.Slot(1, [o])]),
                  e.Multiply([i, e.Slot(2, [o])]),
                ]))
              : e.getReturnIndex();}
        }
      }
      case 11: {
        let [i, o] = t.args;
        return cr(e, i) && cr(e, o)
          ? (e.popInstruction(), e.NativeFunction("complexDivide", [i, o]))
          : cr(e, i) && rs(e, o)
          ? (e.popInstruction(),
            e.NativeFunction("complex", [
              e.Divide([e.Slot(0, [i]), o]),
              e.Divide([e.Slot(1, [i]), o]),
            ]))
          : rs(e, i) && cr(e, o)
          ? (e.popInstruction(),
            e.NativeFunction("complexDivide", [
              e.NativeFunction("complex", [i, e.Constant(0)]),
              o,
            ]))
          : Uu(e, i) && rs(e, o)
          ? (e.popInstruction(),
            e.TupleOfType(Point, [
              e.Divide([e.Slot(0, [i]), o]),
              e.Divide([e.Slot(1, [i]), o]),
            ]))
          : eu(e, [i]) && rs(e, o)
          ? (e.popInstruction(), $u(e, [e.Divide([Ss(e, i), o]), $o(e, i)]))
          : qu(e, i) && rs(e, o)
          ? (e.popInstruction(),
            e.TupleOfType(Point3D, [
              e.Divide([e.Slot(0, [i]), o]),
              e.Divide([e.Slot(1, [i]), o]),
              e.Divide([e.Slot(2, [i]), o]),
            ]))
          : e.getReturnIndex();
      }
      case 25: {
        let [i, o] = t.args;
        if (cr(e, i) && cr(e, o)) {
          e.popInstruction();
          let a = e.Slot(0, [i]),
            u = e.Slot(0, [o]),
            c = e.Slot(1, [i]),
            l = e.Slot(1, [o]);
          return e.And([e.Equal([a, u]), e.Equal([c, l])]);
        } else if (rs(e, i) && cr(e, o)) {
          e.popInstruction();
          let a = i, u = e.Slot(0, [o]), c = e.Constant(0), l = e.Slot(1, [o]);
          return e.And([e.Equal([a, u]), e.Equal([c, l])]);
        } else if (cr(e, i) && rs(e, o)) {
          e.popInstruction();
          let a = e.Slot(0, [i]), u = o, c = e.Slot(1, [i]), l = e.Constant(0);
          return e.And([e.Equal([a, u]), e.Equal([c, l])]);
        } else return e.getReturnIndex();
      }
      case 28:
      case 29: {
        let [i, o] = t.args;
        if (cr(e, i) && cr(e, o)) {
          e.popInstruction();
          let a = t.type === 28 ? e.Less(t.args) : e.Greater(t.args);
          return e.Or([a, e.Equal(t.args)]);
        } else return e.getReturnIndex();
      }
      case 12:
      case 13:
      case 26:
      case 27:
      case 32:
      case 31:
      case 15:
      case 33:
      case 16:
      case 37:
      case 42:
      case 39:
      case 40:
      case 41:
      case 21:
      case 22:
      case 19:
      case 20:
      case 38:
      case 47:
      case 23:
      case 24:
      case 48:
      case 44:
      case 49:
      case 50:
      case 51:
      case 53:
      case 54:
      case 55:
        return e.getReturnIndex();
      default:
        let s = t;
        throw new Error(`Unexpected opcode ${s.type}`);
    }
  }
  function Uu(e, t) {
    return e.getInstruction(t).valueType === Point;
  }
  function qu(e, t) {
    return e.getInstruction(t).valueType === Point3D;
  }
  function rs(e, t) {
    return e.getInstruction(t).valueType === Number;
  }
  function cr(e, t) {
    return e.getInstruction(t).valueType === Complex;
  }
  function Yf(e, t) {
    return e.getInstruction(t).valueType === Restriction;
  }
  function eu(e, t) {
    return t.every((n) => gt(e, n, Vector)) ||
      t.every((n) => gt(e, n, Vector3D));
  }
  function $u(e, t) {
    return Ui(e, t, "mathVector", Xf("mathVector", "mathVectorThreeD"));
  }
  function $o(e, t) {
    return Ui(e, [t], "start", [{
      match: [Vector],
      build: () => e.NativeFunction("basePointFromVector", [t]),
    }, {
      match: [Vector3D],
      build: () => e.NativeFunction("basePointFromVectorThreeD", [t]),
    }]);
  }
  function Ss(e, t) {
    return Ui(e, [t], "displacement", [{
      match: [Vector],
      build: () => e.NativeFunction("vectorDisplacementAsPoint", [t]),
    }, {
      match: [Vector3D],
      build: () => e.NativeFunction("vectorThreeDDisplacementAsPoint", [t]),
    }]);
  }
  function Xf(e, t) {
    return [
      { match: [Point, Point], build: (n, r) => n.NativeFunction(e, r) },
      {
        match: [Point3D, Point3D],
        build: (n, r) => n.NativeFunction(t, r),
      },
    ];
  }
  function Yu(e, t) {
    if (t.type !== 33) return false;
    let n = e.getInstruction(t.args[2]);
    return n.type === 1 && io(n.valueType) && _S(n.valueType, n.value) ||
      Yu(e, n) && VN(e, t.args[1]) && VN(e, n.args[1]);
  }
  function oM(e, t) {
    let n = [];
    for (; t.type === 33;) n.push(t.args[0]), t = e.getInstruction(t.args[2]);
    return n;
  }
  function* gh(e, t) {
    let n = e.getInstruction(t);
    n.type !== 32
      ? yield t
      : (yield* gh(e, n.args[0]), yield* gh(e, n.args[1]));
  }
  function BN(e, t) {
    return e.getInstruction(t).type === 25;
  }
  function GN(e, t) {
    let n = e.getInstruction(t);
    if (n.type !== 25) return;
    let r = n.args[0],
      s = n.args[1],
      i = e.getInstruction(r),
      o = e.getInstruction(s),
      a = (o.type === 41 || o.type === 40) && Je(e.getInstruction(o.args[0]));
    return i.type === 2 && (Je(o) || a) && se(o.valueType, Number)
      ? { type: "constant", variable: e.argNames[r], index: s }
      : se(i.valueType, Number) && se(o.valueType, Number)
      ? { type: "implicit", index: e.Subtract([r, s]) }
      : void 0;
  }
  function VN(e, t) {
    let n = e.getInstruction(t);
    return n.type === 1 && n.valueType === Number && V(n.value) === 1;
  }
  var uM = class {
      constructor(t, n, r, s) {
        this.openChunk = t;
        this.returnIndex = n;
        this.restrictionIndex = r;
        this.slices = s;
      }
      getSliceVariablesOrImplicit() {
        return this.slices.map((t) =>
          t.type === "constant" ? t.variable : "_implicit"
        );
      }
      getPeeledSlices() {
        let t = [];
        for (let n of this.slices) {
          if (n.type === "constant") {
            let r = this.openChunk.getInstruction(n.index);
            if (Je(r) && r.valueType === Number) {
              t.push({
                type: "constant",
                variable: n.variable,
                value: V(r.value),
              });
            } else if (!(Je(r) && r.valueType === ListOfNumber)) throw ca();
          } else if (
            this.openChunk.getInstruction(n.index).valueType === Number
          ) {
            let s = this.openChunk.copy();
            s.setReturnIndex(n.index),
              s.fuseBroadcast(),
              t.push({ type: "implicit", sliceChunk: s });
          } else throw ca();
        }
        return t;
      }
      getValueAndRestrictionChunk() {
        let t = this.getPeeledSlices(), n = this.openChunk.copy();
        n.setReturnIndex(this.returnIndex), n.fuseBroadcast();
        let r;
        return this.restrictionIndex !== void 0 &&
          (r = this.openChunk.copy(),
            r.setReturnIndex(this.restrictionIndex),
            r.fuseBroadcast()),
          { valueChunk: n, restrictionChunk: r, slices: t };
      }
      getSlicesAndRestrictionChunk() {
        let t = this.getPeeledSlices(),
          n = this.openChunk.copy(),
          r = n.GreaterEqual([this.returnIndex, n.Constant(0)]);
        return this.restrictionIndex !== void 0 &&
          (r = n.And([r, this.restrictionIndex])),
          n.setReturnIndex(r),
          n.fuseBroadcast(),
          { restrictionChunk: n, slices: t };
      }
    },
    hh = class {
      constructor(t, n, r) {
        this.chunk = t;
        this.slices = [];
        this.oldIPtoNewIP = [];
        this.oldIPToRestriction = [];
        var s, i;
        this.produceNumbers =
          (s = r == null ? void 0 : r.produceNumbers) != null ? s : false,
          this.allowSlices = (i = r == null ? void 0 : r.allowSlices) != null
            ? i
            : false,
          this.newChunk = new Ia({
            argNames: t.argNames,
            argTypes: t.argTypes,
          }),
          this.startTrue = this.produceNumbers
            ? this.newChunk.Constant(1 / 0)
            : this.newChunk.ConstantOfType(Bool, true),
          this.peelable = $H(t),
          XH(t, this.peelable, n);
      }
      selectRestriction() {
        return true;
      }
    },
    cM = class extends hh {
      constructor(n, r, s) {
        super(n, r, s);
        this.currSelectIndex = 0;
        this.selectIndex = s.selectIndex;
      }
      selectRestriction() {
        let n = this.selectIndex === this.currSelectIndex;
        return this.currSelectIndex++, this.produceNumbers ? n : !n;
      }
    };
  function tu(e, t, n) {
    let r = new hh(e, t, n);
    lM(r, 0, e.instructionsLength() - 1);
    let s = r.oldIPToRestriction[e.getReturnIndex()];
    return new uM(
      r.newChunk,
      r.oldIPtoNewIP[e.getReturnIndex()],
      r.startTrue === s ? void 0 : s,
      r.slices,
    );
  }
  function* kN(e, t, n) {
    var s, i;
    let r = aM(e, n, { produceNumbers: false, selectIndex: 0 });
    if (r === void 0 || r.count <= 1) {
      yield { value: t, restriction: void 0 };
      return;
    }
    for (let o = 0; o < r.count; o++) {
      let a = (s = aM(e, n, { produceNumbers: true, selectIndex: o })) == null
          ? void 0
          : s.chunk,
        u = o === 0
          ? r.chunk
          : (i = aM(e, n, { produceNumbers: false, selectIndex: o })) == null
          ? void 0
          : i.chunk;
      if (!a || !u) {
        throw new Error("Programming Error: selectIndex gave invalid chunk.");
      }
      yield { value: a, restriction: u };
    }
  }
  function aM(e, t, n) {
    let r = new cM(e, t, n);
    lM(r, 0, e.instructionsLength() - 1);
    let s = r.oldIPToRestriction[e.getReturnIndex()];
    if (r.currSelectIndex === 0) return;
    let i = r.oldIPtoNewIP[e.getReturnIndex()],
      o = r.newChunk.getInstruction(i);
    if (o.type !== 29) {
      throw new Error("Programming Error: Expected GreaterEqual.");
    }
    let a = r.produceNumbers ? r.newChunk.Subtract([o.args[0], o.args[1]]) : i;
    return r.selectRestriction() && (s = bh(r, [s, a])),
      r.newChunk.setReturnIndex(s),
      { chunk: r.newChunk, count: r.currSelectIndex };
  }
  function lM(e, t, n) {
    let {
      chunk: r,
      newChunk: s,
      peelable: i,
      oldIPtoNewIP: o,
      oldIPToRestriction: a,
    } = e;
    for (let u = t; u <= n; u++) {
      let c = r.getInstruction(u);
      if (i[u] && (c.type === 19 || c.type === 23)) u = qH(e, u);
      else if (c.type === 2) o[u] = u, a[u] = e.startTrue;
      else if (ge(c)) o[u] = s.copyInstruction(c), a[u] = e.startTrue;
      else if (i[u] && Yu(r, c)) {
        o[u] = o[c.args[1]];
        let l = c.args.map((p) => a[p]);
        for (let p of ZH(e, c)) e.selectRestriction() && l.push(p);
        a[u] = bh(e, l);
      } else {o[u] = s.copyInstructionWithArgs(c, c.args.map((l) => o[l])),
          a[u] = bh(e, c.args.map((l) => a[l]));}
    }
  }
  function bh(e, t) {
    let r = [...new Set(t)].filter((s) => !HN(e, s));
    return r.length
      ? xh(e, r).reduce((s, i) =>
        e.produceNumbers
          ? e.newChunk.NativeFunction("listMin", [s, i])
          : e.newChunk.And([s, i])
      )
      : e.startTrue;
  }
  function UH(e, t) {
    let n = [...new Set(t)];
    return n.some((r) => !HN(e, r))
      ? xh(e, n).reduce((r, s) =>
        e.produceNumbers
          ? e.newChunk.NativeFunction("listMax", [r, s])
          : e.newChunk.Or([r, s])
      )
      : e.startTrue;
  }
  function xh(e, t) {
    if (!e.produceNumbers) return t;
    let n = e.newChunk;
    return t.map((r) => {
      let s = n.getInstruction(r);
      if (s.valueType !== Bool) return r;
      switch (s.type) {
        case 27:
        case 29:
          return n.Subtract([s.args[0], s.args[1]]);
        case 26:
        case 28:
          return n.Subtract([s.args[1], s.args[0]]);
        case 25:
          throw U("convertBoolsToNums on an equality.");
        case 32:
          return n.NativeFunction("listMin", xh(e, s.args));
        case 31:
          return n.NativeFunction("listMax", xh(e, s.args));
        case 1:
          return n.Constant(s.value ? 1 / 0 : -1 / 0);
        default:
          throw U("convertBoolsToNums on a non-opcode condition.");
      }
    });
  }
  function HN({ newChunk: e }, t) {
    let n = e.getInstruction(t);
    return n.type === 1 &&
      (n.valueType === Number && n.value === 1 / 0 ||
        n.valueType === Bool && n.value);
  }
  function qH(e, t) {
    let {
        chunk: n,
        newChunk: r,
        oldIPtoNewIP: s,
        oldIPToRestriction: i,
        startTrue: o,
      } = e,
      a = n.getInstruction(t),
      u = a.endIndex,
      c = n.getInstruction(u),
      l,
      p;
    if (a.type === 23) {
      s[t] = r.copyInstructionWithArgs(a, [s[a.args[0]]]), i[t] = o, p = t + 1;
    } else {
      let g = a.args.map((m) => s[m]);
      g.push(o), s[t] = r.copyInstructionWithArgs(a, g), i[t] = o;
      for (let m = 2; m < a.args.length; m++) {
        let h = t + m - 1;
        s[h] = r.copyInstructionWithArgs(n.getInstruction(h), [s[t]]), i[h] = o;
      }
      l = r.BlockVar(e.produceNumbers ? Number : Bool, [s[t]]),
        p = t + a.args.length - 1;
    }
    lM(e, p, u - 1);
    let f = c.args.map((g) => s[g]),
      d = e.slices.filter((g) => p <= g.index && g.index < u),
      y = l;
    if (a.type === 19) {
      if (l === void 0) {
        throw new Error("Expected restrictionAccumVar to be defined");
      }
      y = bh(e, [l, i[c.args[1]]]), f.push(y);
    } else {
      f.push(i[c.args[1]]);
      for (let g of d) f.push(g.index);
    }
    s[u] = r.copyInstructionWithArgs(c, f), i[u] = o;
    for (let g = 1; g < c.args.length; g++) {
      s[u + g] = r.copyInstructionWithArgs(n.getInstruction(u + g), [s[u]]);
    }
    if (a.type === 23) {
      let g = r.BroadcastResult(e.produceNumbers ? ListOfNumber : ListOfBool, [
        s[u],
      ]);
      for (let m of d) m.index = r.BroadcastResult(ListOfNumber, [s[u]]);
      for (let m = 1; m < c.args.length; m++) i[u + m] = g;
    } else {
      let g = r.BlockVar(e.produceNumbers ? Number : Bool, [s[u]]);
      l === y && (g = o);
      for (let m = 1; m < c.args.length; m++) i[u + m] = g;
    }
    return u + c.args.length - 1;
  }
  function $H(e) {
    let t = [];
    for (let r = 0; r < e.instructionsLength(); r++) t.push(false);
    t[e.getReturnIndex()] = true;
    let n = e.instructionsLength() - 1;
    for (let r = n; r >= 0; r--) {
      if (!t[r]) continue;
      let s = e.getInstruction(r);
      if (!ge(s)) { for (let i of YH(e, s)) t[i] = true; }
    }
    return t;
  }
  function YH(e, t) {
    switch (t.type) {
      case 14:
      case 8:
      case 9:
      case 26:
      case 28:
      case 27:
      case 29:
      case 10:
      case 11:
      case 12:
      case 13:
      case 25:
      case 32:
      case 15:
      case 38:
      case 47:
      case 19:
      case 39:
      case 40:
      case 41:
      case 23:
      case 24:
      case 48:
      case 50:
        return t.args;
      case 33:
        return Yu(e, t) ? oM(e, t).concat([t.args[1]]) : [];
      case 37: {
        let r = Bn[t.symbol];
        return r.noPeel
          ? []
          : r.tag === "reducer" || r.tag === "doubleReducer" ||
              r.tag === "never-broadcast" || r.tag === "parameterizedReducer"
          ? t.args.filter((s) => e.getInstruction(s).type !== 48)
          : t.args;
      }
      case 20:
        return t.args.slice(1);
      case 51:
        return [t.args[1]];
      case 31:
        return [];
      case 16:
      case 42:
      case 21:
      case 22:
      case 44:
      case 49:
      case 53:
      case 54:
      case 55:
        return [];
      default:
        let n = t;
        throw new Error(`Unexpected opcode ${n.type}`);
    }
  }
  function XH(e, t, n) {
    let r = [];
    for (let s = 0; s < e.argNames.length; s++) {
      let i = e.argNames[s];
      n.indexOf(i) < 0 && r.push(s);
    }
    for (let s of r) {
      let i = Vu(e, s);
      for (let o = 0; o < e.instructionsLength(); o++) t[s] && (t[s] = !i[o]);
    }
  }
  function ZH(e, t) {
    let n = oM(e.chunk, t).map((r) => e.oldIPtoNewIP[r]);
    if (e.allowSlices && n.length === 1) {
      let r = GN(e.newChunk, n[0]);
      if (r) return e.slices.push(r), [];
    }
    if (n.some((r) => BN(e.newChunk, r))) throw ca();
    if (n.length === 1) {
      let r = n[0];
      return [...gh(e.newChunk, r)];
    }
    return [UH(e, n)];
  }
  function zN(e, t) {
    let n = [], r = [], s = [];
    for (let o = 0; o < e.argNames.length; o++) {
      t.hasOwnProperty(e.argNames[o]) ||
        (n.push(e.argNames[o]), r.push(e.argTypes[o]));
    }
    let i = new Ia({ argNames: n, argTypes: r });
    for (let o = 0, a = 0; o < e.argNames.length; o++) {
      t.hasOwnProperty(e.argNames[o])
        ? s[o] = i.ConstantOfType(e.argTypes[o], t[e.argNames[o]])
        : (s[o] = a, a += 1);
    }
    for (let o = e.argNames.length; o < e.instructionsLength(); o++) {
      let a = e.getInstruction(o);
      if (ge(a)) s.push(po(i, a));
      else {
        let u = [];
        for (let c of a.args) u.push(s[c]);
        s.push(_n(i, a, u));
      }
    }
    return i;
  }
  function li(e) {
    let t = e;
    if (
      t && typeof t.toJSON == "function" && (t = t.toJSON()),
        !t || typeof t != "object"
    ) return t;
    if (Array.isArray(t)) return t.map(li);
    let n = {};
    for (let r in t) t.hasOwnProperty(r) && (n[r] = li(t[r]));
    return n;
  }
  var Th = class e {
    constructor() {
      this.maps = { real: {}, complexOne: {}, complexI: {} };
    }
    clone() {
      let t = new e();
      return t.maps = li(this.maps), t;
    }
    pruneIP(t) {
      for (let n of Object.values(this.maps)) delete n[t];
    }
    truncate(t) {
      for (let n of Object.values(this.maps)) {
        for (let r in n) {
          let s = +r;
          s >= t ? delete n[s] : WH(n[s], t);
        }
      }
    }
    getMapEntry(t, n, r) {
      let s = this.maps[n], i = s[r];
      if (i) return i;
      let o = { maxValidReference: t.instructionsLength() - 1, map: [] };
      return s[r] = o, o;
    }
    _cachedDerivativesForTests() {
      let t = [];
      for (let [n, r] of Object.entries(this.maps)) {
        for (let s in r) t.push(`${s} ${n}`);
      }
      return t.sort(), t;
    }
  };
  function WH(e, t) {
    e.map.length = Math.min(e.map.length, t),
      e.maxValidReference = Math.min(e.maxValidReference, t - 1);
  }
  var jH = {
    "+": true,
    "-": true,
    "*": true,
    "\\cdot": true,
    "\\times": true,
    "/": true,
    "!": true,
    "(": true,
    ")": true,
    "\\{": true,
    "\\}": true,
    "(|": true,
    "|)": true,
    "[": true,
    "]": true,
    ",": true,
    "...": true,
    ":": true,
    "=": true,
    ">": true,
    "<": true,
    ">=": true,
    "<=": true,
    "->": true,
    "~": true,
    "%": true,
    ".": true,
    for: true,
    with: true,
    Letter: true,
    Decimal: true,
    Cmd: true,
    TokenNode: true,
    Differential: true,
    End: true,
    Trig: true,
    Ln: true,
    Log: true,
    Int: true,
    Sum: true,
    Prod: true,
    Err: true,
  };
  function $K(e) {
    let t = nu[e];
    if (!t) return true;
    switch (t) {
      case "Ln":
      case "Log":
      case "for":
      case "with":
      case "Trig":
        return true;
      default:
        return false;
    }
  }
  var nu = {
      "\\lt": "<",
      "\\gt": ">",
      "\\le": "<=",
      "\\ge": ">=",
      "\\leq": "<=",
      "\\geq": ">=",
      "\\ldots": "...",
      "\\sim": "~",
      "\\to": "->",
      "\\cdot": "\\cdot",
      "\\times": "\\times",
      "\\div": "/",
      "\\ln": "Ln",
      "\\log": "Log",
      "\\int": "Int",
      "\\sum": "Sum",
      "\\prod": "Prod",
      "\\backslash": "Err",
      "\\for": "for",
      "\\with": "with",
    },
    JH = ["sin", "cos", "tan", "cot", "sec", "csc"];
  for (let e of JH) {
    nu["\\" + e] = "Trig",
      nu["\\" + e + "h"] = "Trig",
      nu["\\arc" + e] = "Trig",
      nu["\\arc" + e + "h"] = "Trig",
      nu["\\ar" + e + "h"] = "Trig";
  }
  function YK(e) {
    return e === "\\log" || e === "\\prod" || e === "\\sum" || e === "\\int";
  }
  var pM = {
      "+": "+",
      "-": "-",
      "*": "*",
      "/": "/",
      "!": "!",
      "(": "(",
      ")": ")",
      "[": "[",
      "]": "]",
      ",": ",",
      "...": "...",
      ":": ":",
      "=": "=",
      ">=": ">=",
      "<=": "<=",
      ">": ">",
      "<": "<",
      "~": "~",
      ".": ".",
    },
    UN = { "\\{": "\\{", "\\}": "\\}", "\\%": "%" },
    qN = { "|": "(|", "\\{": "\\{", "[": "[", "(": "(" },
    $N = { "|": "|)", "\\}": "\\}", "]": "]", ")": ")" },
    YN = Object.keys(jH);
  function XN(e) {
    return 48 <= e && e <= 57;
  }
  function QH(e) {
    return 97 <= e && e <= 122;
  }
  function KH(e) {
    return 65 <= e && e <= 90;
  }
  function Ih(e) {
    return QH(e) || KH(e);
  }
  function Ph(e) {
    return e === 92;
  }
  function dM(e) {
    return e === 39;
  }
  function ZN(e) {
    if (9 <= e && e <= 13 || 8192 <= e && e <= 8202) return true;
    switch (e) {
      case 32:
      case 160:
      case 5760:
      case 8232:
      case 8233:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return true;
      default:
        return false;
    }
  }
  var ez = {
    mcd: "gcd",
    gcf: "gcd",
    mcm: "lcm",
    signum: "sign",
    sgn: "sign",
    stdDevP: "stdevp",
    stddevp: "stdevp",
    stdDev: "stdev",
    stddev: "stdev",
    variance: "var",
    TTest: "ttest",
    TScore: "tscore",
    IndependentTTest: "ittest",
    iTTest: "ittest",
    inverseCdf: "quantile",
    inversecdf: "quantile",
    arsinh: "arcsinh",
    arcosh: "arccosh",
    artanh: "arctanh",
    arcsch: "arccsch",
    arsech: "arcsech",
    arcoth: "arccoth",
  };
  function WN(e) {
    let t = 0;
    for (; Ph(e.charCodeAt(t));) t += 1;
    return t > 0 && (e = e.slice(t)), ez[e] || e;
  }
  function jN(e, t, n) {
    return { type: "Comparator", span: e, symbol: t, args: n };
  }
  function JN(e, t, n) {
    if (t.length < 1) {
      throw "Programming Error: ComparatorChain must have at least one comparator.";
    }
    if (n.length !== t.length + 1) {
      throw "Programming Error: ComparatorChain must have one more arg than symbols";
    }
    return { type: "ComparatorChain", span: e, args: n, symbols: t };
  }
  function QN(e, t) {
    return { type: "Tilde", span: e, args: t };
  }
  function KN(e, t) {
    return { type: "Pos", span: e, args: t };
  }
  function eR(e, t) {
    return { type: "Neg", span: e, args: t };
  }
  function tR(e, t) {
    return { type: "Add", span: e, args: t };
  }
  function nR(e, t) {
    return { type: "Sub", span: e, args: t };
  }
  function rR(e, t) {
    return { type: "Mul", span: e, args: t };
  }
  function sR(e, t) {
    return { type: "DotMul", span: e, args: t };
  }
  function iR(e, t) {
    return { type: "CrossMul", span: e, args: t };
  }
  function oR(e, t) {
    return { type: "Div", span: e, args: t };
  }
  function aR(e, t) {
    return { type: "Bang", span: e, args: t };
  }
  function Zf(e, t) {
    return { type: "Call", span: e, args: t };
  }
  function fM(e, t) {
    return { type: "ImplicitCall", span: e, args: t };
  }
  function uR(e, t) {
    return { type: "Index", span: e, args: t };
  }
  function mM(e, t) {
    return { type: "Paren", span: e, args: t };
  }
  function yM(e, t) {
    return { type: "List", span: e, args: t };
  }
  function cR(e, t) {
    return { type: "Pipes", span: e, args: t };
  }
  function gM(e, t) {
    return { type: "Subscript", span: e, args: t };
  }
  function Eh(e, t) {
    return { type: "Superscript", span: e, args: t };
  }
  function Wf(e, t, n) {
    return { type: "Prime", span: e, nprimes: t, args: n };
  }
  function Mh(e, t) {
    return { type: "Seq", span: e, args: t };
  }
  function lR(e, t) {
    return { type: "Sqrt", span: e, args: t };
  }
  function pR(e, t) {
    return { type: "Nthroot", span: e, args: t };
  }
  function dR(e, t) {
    return { type: "Frac", span: e, args: t };
  }
  function fR(e, t) {
    return { type: "Derivative", span: e, args: t };
  }
  function mR(e, t) {
    return { type: "Integral", span: e, args: t };
  }
  function yR(e, t) {
    return { type: "EmptyIntegral", span: e, args: t };
  }
  function gR(e, t) {
    return { type: "Sum", span: e, args: t };
  }
  function hR(e, t) {
    return { type: "Product", span: e, args: t };
  }
  function bR(e, t) {
    return { type: "Piecewise", span: e, args: t };
  }
  function xR(e) {
    return { type: "EmptyPiecewise", span: e };
  }
  function TR(e) {
    return { type: "EmptyRangeEnd", span: e };
  }
  function IR(e, t) {
    return { type: "Colon", span: e, args: t };
  }
  function hM(e, t) {
    return { type: "Ellipsis", span: e, args: t };
  }
  function PR(e, t) {
    return { type: "For", span: e, args: t };
  }
  function ER(e, t) {
    return { type: "With", span: e, args: t };
  }
  function MR(e, t) {
    return { type: "Dot", span: e, args: t };
  }
  function CR(e, t) {
    return { type: "PercentOf", span: e, args: t };
  }
  function DR(e, t) {
    return { type: "RightArrow", span: e, args: t };
  }
  function bM(e, t) {
    return { type: "Juxt", span: e, args: t };
  }
  function SR(e, t) {
    return { type: "Letter", span: e, val: t };
  }
  function Ch(e, t) {
    return { type: "Decimal", span: e, val: t };
  }
  function gl(e, t) {
    return { type: "Cmd", span: e, val: WN(t) };
  }
  function vR(e, t) {
    return { type: "Alphanumeric", span: e, val: t };
  }
  function OR(e, t, n, r) {
    return { type: "MixedNumber", span: e, whole: t, num: n, den: r };
  }
  function lr(e) {
    if (e.type === "Subscript") {
      if (e.args[1].type !== "Alphanumeric") return false;
      e = e.args[0];
    }
    switch (e.type) {
      case "Cmd":
        return true;
      case "Letter":
        return true;
      default:
        return false;
    }
  }
  function NR(e) {
    return e.type !== "Superscript" ? false : lr(e.args[0]);
  }
  function RR(e, t) {
    if (e.type !== "Letter" || e.val !== "d" || t.type !== "Juxt") return false;
    let [n, r] = t.args;
    return n.type !== "Letter" || n.val !== "d" ? false : lr(r);
  }
  function Sr(e) {
    return e.type === "Seq" ? e.args : [e];
  }
  function AR(e, t, n, r, s, i, o, a) {
    return {
      opts: e,
      input: t,
      prevSpan: n,
      startIndex: r,
      endIndex: s,
      token: i,
      mode: o,
      parent: a,
    };
  }
  function Pe(e, t) {
    return Bs(e.token.span, t.prevSpan);
  }
  function er(e, t) {
    return Bs(e, t.prevSpan);
  }
  function TM(e) {
    return No(e.token.span.input, e.token.span.start);
  }
  function nz(e, t) {
    return { type: "Differential", span: e, val: t };
  }
  function vs(e, t, n) {
    return { type: e, span: t, val: n };
  }
  function ru(e, t) {
    let n = No(e.span.input, e.span.start);
    return IM(t, e, 0, n, void 0, void 0);
  }
  function IM(e, t, n, r, s, i) {
    let o = t.args;
    if (n > o.length && i) return _R(i, r);
    n = jf(o, n);
    let { token: a, endIndex: u } = LR(t, n, s);
    if (a.type === "End" && i) {
      let c = i.input.args[i.startIndex];
      if (c.type === "LeftRight") {
        let l = c.right, p = $N[l.val] || "Err", f = vs(p, l.span, l.val);
        return AR(e, t, r, n, u, f, s, i);
      }
    } else {a.type === "Int"
        ? s = rz(s)
        : a.type === "Differential" && (s = sz(s));}
    return AR(e, t, r, n, u, a, s, i);
  }
  function Xe(e) {
    let t = e.input.args[e.startIndex], n = e.token.span;
    return t && t.type === "LeftRight"
      ? IM(e.opts, t.arg, 0, n, e.mode, e)
      : _R(e, n);
  }
  function _R(e, t) {
    let { input: n, endIndex: r, mode: s, parent: i } = e;
    return IM(e.opts, n, r + 1, t, s, i);
  }
  function ss(e) {
    return e.token;
  }
  function rz(e) {
    return { type: "integral", parent: e };
  }
  function sz(e) {
    if (!e || e.type !== "integral") {
      throw new Error(
        "Programming Error: expected lexer to be in integral mode.",
      );
    }
    return e.parent;
  }
  function Hr(e, t) {
    return ss(e).type === t;
  }
  function vh(e) {
    return e.startIndex >= e.input.args.length;
  }
  function PM(e, t) {
    return t.token.span.start > e.token.span.start;
  }
  function xr(e, t) {
    return { token: t, endIndex: e };
  }
  function LR(e, t, n) {
    let r = e.args;
    if (t >= r.length) {
      let i = No(e.span.input, e.span.end);
      return xr(t, vs("End", i, ""));
    }
    let s = e.args[t];
    switch (s.type) {
      case "Sqrt":
      case "Frac":
      case "SupSub":
        return xr(t, s);
      case "Letter": {
        if (!n || n.type !== "integral" || s.val != "d") return xr(t, s);
        let { endIndex: c, token: l } = LR(e, t + 1, n);
        if (l.type === "Letter" || l.type === "Cmd") {
          let p = nz(Bs(s.span, l.span), l.val);
          return xr(c, p);
        } else return xr(t, s);
      }
      case "LeftRight": {
        let c = s.left, l = qN[c.val] || "Err", p = Bs(s.span, c.span);
        return xr(t, vs(l, p, c.val));
      }
      case "OperatorName":
        let i = [];
        for (let c of s.arg.args) {
          if (c.type !== "Letter") {
            return xr(t, vs("Err", s.span, Yn(s.arg.span)));
          }
          i.push(c.val);
        }
        let o = "\\" + i.join(""), a = nu[o] || "Cmd";
        return xr(t, vs(a, s.span, o));
      case "TokenNode": {
        let c = "$";
        if (s.arg.args.length === 0) {
          return xr(t, vs("Err", s.span, Yn(s.arg.span)));
        }
        for (let l of s.arg.args) {
          if (l.type !== "Digit") {
            return xr(t, vs("Err", s.span, Yn(s.arg.span)));
          }
          c += l.val;
        }
        return xr(t, vs("TokenNode", s.span, c));
      }
      case "Cmd": {
        let c = nu[s.val] || "Cmd";
        return xr(t, vs(c, s.span, s.val));
      }
      case "EscapedSymbol": {
        let c = UN[s.val] || "Err";
        return xr(t, vs(c, s.span, s.val));
      }
      case "Symbol":
        return iz(e, t, s);
      case "Digit":
        return wR(e, t);
      default:
        throw `Unexpected atom ${s.type}.`;
    }
  }
  function iz(e, t, n) {
    switch (n.val) {
      case ".":
        return oz(e, t);
      case "-": {
        let s = e.args[t + 1];
        if (s && Dh(s, ">")) {
          let i = vs("->", Bs(n.span, s.span), "->");
          return xr(t + 1, i);
        }
        break;
      }
      case "<": {
        let s = e.args[t + 1];
        if (s && Dh(s, "=")) {
          let i = vs("<=", Bs(n.span, s.span), "<=");
          return xr(t + 1, i);
        }
        break;
      }
      case ">": {
        let s = e.args[t + 1];
        if (s && Dh(s, "=")) {
          let i = vs(">=", Bs(n.span, s.span), ">=");
          return xr(t + 1, i);
        }
        break;
      }
    }
    let r = pM[n.val] || "Err";
    return xr(t, vs(r, n.span, n.val));
  }
  function oz(e, t) {
    let n = e.args[t];
    if (n.type !== "Symbol" || n.val !== ".") {
      throw new Error("Programming Error: expected '.'");
    }
    if (t + 2 < e.args.length && Sh(e.args[t + 1]) && Sh(e.args[t + 2])) {
      let i = Bs(n.span, e.args[t + 2].span);
      return xr(t + 2, vs("...", i, Yn(i)));
    }
    let r = jf(e.args, t + 1);
    if (r < e.args.length && e.args[r].type === "Digit") return wR(e, t);
    let s = pM[n.val] || "Err";
    return xr(t, vs(s, n.span, n.val));
  }
  function wR(e, t) {
    let n = az(e, t);
    if (n) return n;
    let r = e.args, s = e.args[t].span, i = [], o = false, a = false;
    for (; t < r.length; t++) {
      let c = jf(r, t);
      if (c >= r.length) break;
      let l = r[c];
      if (l.type === "Digit") t = c, o = true, i.push(l.val);
      else if (!a && Sh(l)) {
        if (c + 1 < r.length && Sh(e.args[c + 1])) break;
        t = c, a = true, i.push(".");
      } else break;
    }
    if (!o) {
      throw new Error(
        "Programming Error: decimals must have at least one digit.",
      );
    }
    let u = Bs(s, e.args[t - 1].span);
    return xr(t - 1, vs("Decimal", u, i.join("")));
  }
  function az(e, t) {
    let n = e.args, r = n[t].span, s = [];
    for (; t < n.length; t++) {
      let c = jf(n, t);
      if (c >= n.length) break;
      let l = n[c];
      if (l.type !== "Digit") break;
      t = c, s.push(l.val);
    }
    if (t = jf(n, t), t >= n.length) return;
    let i = n[t];
    if (i.type !== "Frac") return;
    let o = [], a = [];
    for (let c of i.num.args) {
      if (!xM(c)) {
        if (c.type !== "Digit") return;
        o.push(c.val);
      }
    }
    for (let c of i.den.args) {
      if (!xM(c)) {
        if (c.type !== "Digit") return;
        a.push(c.val);
      }
    }
    let u = Bs(r, i.span);
    return xr(t, OR(u, s.join(""), o.join(""), a.join("")));
  }
  function xM(e) {
    switch (e.type) {
      case "Sqrt":
      case "Frac":
      case "SupSub":
      case "LeftRight":
      case "OperatorName":
      case "TokenNode":
      case "Symbol":
      case "Letter":
      case "Digit":
        return false;
      case "Cmd":
        return e.val === "\\space";
      case "EscapedSymbol":
        return e.val === "\\ " || e.val === "\\:" || e.val === "\\," ||
          e.val === "\\;";
      default:
        throw `Unexpected atom ${e.type}.`;
    }
  }
  function jf(e, t) {
    for (; t < e.length && xM(e[t]);) t += 1;
    return t;
  }
  function Sh(e) {
    return Dh(e, ".");
  }
  function Dh(e, t) {
    return e.type === "Symbol" && e.val === t;
  }
  var Kp = {},
    uz = [
      "sin",
      "cos",
      "tan",
      "cot",
      "sec",
      "csc",
      "sinh",
      "cosh",
      "tanh",
      "coth",
      "sech",
      "csch",
    ];
  uz.forEach((e) => {
    Kp[e] = "arc" + e, Kp["arc" + e] = e;
  });
  var cz = 0;
  function zR(e, t) {
    return lz(e, t);
  }
  function It(e, t) {
    let n = [];
    for (let r = 0; r < t.length; r++) n.push(mn(e, t[r]));
    return n;
  }
  function FR(e, t, n) {
    let r = e.nodes, [s, i] = It(e, t);
    if (Rh(n)) {
      let o = No(n.span.input, n.span.end), a = e.setInput(XR(e), o);
      i = e.setInput(r.SeededFunctionCall(i, [a]), n.span);
    }
    return [s, i];
  }
  function lz(e, t) {
    return e.setInput(pz(e, t), t.span);
  }
  function UR(e) {
    if (e.type !== "Call") return;
    let [t, n] = e.args, r = Sr(n);
    if (lr(t) && r.every(lr)) return { base: t, args: r };
  }
  function qR(e) {
    return UR(e) !== void 0;
  }
  function CM(e) {
    return lr(e);
  }
  function pz(e, t) {
    let n = e.nodes;
    switch (t.type) {
      case "Comparator":
        if (t.symbol === "=") {
          let [r, s] = t.args, i = UR(r);
          if (i) {
            let { base: o, args: a } = i, u = It(e, a), c = e;
            if (e.includeFunctionParametersInRandomSeed) {
              for (let p of u) c = Kf(c, { prefix: "fc", expr: p });
            }
            let l = mn(c, s);
            return n.FunctionDefinition(mn(e, o), u, l);
          } else {
            if (r.type === "Call" && lr(r.args[0])) {
              return n.CallAssignment(mn(e, r), mn(e, s));
            }
            if (CM(r)) {
              let o;
              return s.type === "For"
                ? o = e.setInput(Oh(e, s, { parentIsList: false }), s.span)
                : o = mn(e, s),
                n.Assignment(mn(e, r), o);
            }
          }
          return n.Equation(mn(e, r), mn(e, s));
        } else return Ca(e, t);
      case "Tilde": {
        let [r, s] = It(e, t.args);
        return n.Regression(r, s);
      }
      case "ComparatorChain": {
        if (!e.specializeDoubleInequalities || t.symbols.length !== 2) {
          return Ca(e, t);
        }
        let [r, s, i] = t.args, [o, a] = t.symbols;
        return !lr(s) || t.symbols.includes("=")
          ? Ca(e, t)
          : n.DoubleInequality([mn(e, r), o, mn(e, s), a, mn(e, i)]);
      }
      case "Call": {
        let [r, s] = t.args;
        if (r.type === "Cmd") {
          switch (r.val) {
            case "histogram":
              return n.Histogram(It(e, Sr(s)));
            case "dotplot":
              return n.DotPlot(It(e, Sr(s)));
            case "boxplot":
              return n.BoxPlot(It(e, Sr(s)));
            case "ttest":
              return n.TTest(It(e, Sr(s)));
            case "ittest":
              return n.IndependentTTest(It(e, Sr(s)));
            case "stats":
              return n.Stats(It(e, Sr(s)));
            default:
              return Jf(e, t);
          }
        }
        return Jf(e, t);
      }
      case "For":
        return Oh(e, t, { parentIsList: false });
      default:
        return Jf(e, t);
    }
  }
  function $R(e) {
    if (e.type !== "Paren") return false;
    let [t] = e.args;
    return t.type !== "Seq"
      ? false
      : t.args.length === 2 || t.args.length === 3;
  }
  function VR(e, t, n, r) {
    let s = dz(e, n, r);
    if (s !== void 0) return e.setInput(s, Bs(t.args[0].span, r.span));
  }
  function dz(e, t, n) {
    let r = e.nodes;
    if (n.type === "Letter") {
      switch (n.val) {
        case "x":
        case "y":
        case "z":
          return r.NamedCoordinateAccess(n.val, [t]);
      }
    } else if (n.type === "Cmd") {
      switch (n.val) {
        case "real":
        case "imag":
          throw nT(n.val);
      }
    }
  }
  function mn(e, t) {
    return e.setInput(Jf(e, t), t.span);
  }
  function Jf(e, t) {
    let n = e.nodes;
    switch (t.type) {
      case "Pos":
        return mn(e, t.args[0]);
      case "Neg":
        let r = -1, s = t.args[0];
        for (;;) {
          if (s.type === "Pos" || s.type === "Paren" && !$R(s)) s = s.args[0];
          else if (s.type === "Neg") s = s.args[0], r *= -1;
          else break;
        }
        switch (s.type) {
          case "Decimal": {
            let o = kR(s);
            return n.Constant(r === -1 ? Us(o) : o);
          }
          case "MixedNumber": {
            let o = HR(s);
            return n.MixedNumber(r === -1 ? Us(o) : o);
          }
          default:
            return r === -1 ? n.Negative([mn(e, s)]) : mn(e, s);
        }
      case "Add":
        return n.Add(It(e, t.args));
      case "Sub":
        return n.Subtract(It(e, t.args));
      case "Mul":
        return n.Multiply(It(e, t.args));
      case "DotMul":
        return n.DotMultiply(It(e, t.args));
      case "CrossMul":
        return n.CrossMultiply(It(e, t.args));
      case "Div":
        return n.Divide(It(e, t.args));
      case "Bang": {
        let [o] = t.args;
        return o.type === "Call" && lr(o.args[0]) && !Rh(o.args[0]) &&
            Sr(o.args[1]).length === 1
          ? n.FunctionFactorial(It(e, o.args))
          : n.FunctionCall("\\factorial", It(e, t.args));
      }
      case "PercentOf":
        return n.PercentOf(It(e, t.args));
      case "Call":
        return BR(e, t);
      case "ImplicitCall":
        return bz(t), BR(e, t);
      case "Dot": {
        let o = t.args[1], [a, u] = FR(e, t.args, o);
        if (o.type === "Letter") {
          switch (o.val) {
            case "x":
            case "y":
            case "z":
              return n.NamedCoordinateAccess(o.val, [a]);
            default:
              break;
          }
        } else if (o.type === "Call") {
          let c = o.args[0], l = VR(e, t, a, c);
          if (l !== void 0) return n.Multiply([l, mn(e, o.args[1])]);
        }
        return n.DotAccess([a, u]);
      }
      case "Prime": {
        let [o] = t.args;
        if (o.type === "Call") {
          let [a, u] = o.args, c = Sr(u).length;
          if (a.type === "Cmd" && a.val === "logbase") {
            if (c !== 2) throw Nc();
          } else if (c !== 1) throw Nc();
          return n.Prime(t.nprimes, It(e, t.args));
        } else throw o.type === "ImplicitCall" ? Cy() : My();
      }
      case "Index": {
        let [o, a] = t.args;
        if (a.type === "Seq") {
          return n.ListAccess([
            mn(e, o),
            e.setInput(n.List(It(e, a.args)), void 0),
          ]);
        }
        if (a.type === "Ellipsis") {
          let [u, c] = a.args;
          return n.ListAccess([
            mn(e, o),
            e.setInput(
              n.Range([
                e.setInput(n.List(It(e, Sr(u))), void 0),
                e.setInput(
                  n.List(c.type === "EmptyRangeEnd" ? [] : It(e, Sr(c))),
                  void 0,
                ),
              ]),
              void 0,
            ),
          ]);
        }
        return Qf(a)
          ? n.ListAccess([mn(e, o), e.setInput(Ca(e, a), void 0)])
          : n.ListAccess(It(e, t.args));
      }
      case "Paren": {
        let [o] = t.args;
        if (o.type === "Seq") {
          if (o.args.length === 0) throw Yd();
          return n.ParenSeq(It(e, o.args));
        } else return mn(e, o);
      }
      case "List": {
        if (t.args.length === 0) return n.List([]);
        let o = t.args[0];
        if (o.type === "Ellipsis") {
          let [a, u] = o.args;
          return n.Range([
            e.setInput(n.List(It(e, Sr(a))), void 0),
            e.setInput(n.List(It(e, Sr(u))), void 0),
          ]);
        } else if (o.type === "For") return Oh(e, o, { parentIsList: true });
        return n.List(It(e, Sr(o)));
      }
      case "Pipes": {
        let [o] = t.args;
        return n.Norm([mn(e, o)]);
      }
      case "Subscript": {
        let [o, a] = t.args;
        if (a.val.length === 0) throw Ey();
        let u;
        switch (o.type) {
          case "Letter":
            u = o.val;
            break;
          case "Cmd":
            u = o.val;
            break;
          default:
            throw lI();
        }
        if (u === "ans") throw ks("ans");
        return n.Identifier(`${u}_${a.val}`);
      }
      case "Superscript": {
        let [o, a] = t.args;
        if (
          o.type === "Call" && o.args[1].type !== "Seq" && !Rh(o.args[0]) &&
          !xz(o)
        ) return n.FunctionExponent(It(e, [o.args[0], o.args[1], a]));
        if (o.type === "Dot") {
          let u = o.args[1], [c, l] = FR(e, o.args, u), p = mn(e, a);
          if (u.type === "Letter") {
            switch (u.val) {
              case "x":
              case "y":
              case "z":
                return n.Exponent([
                  e.setInput(n.NamedCoordinateAccess(u.val, [c]), o.span),
                  p,
                ]);
              default:
                break;
            }
          } else if (u.type === "Call") {
            let f = u.args[0], d = VR(e, o, c, f);
            if (d !== void 0) {
              return n.Multiply([
                d,
                e.setInput(
                  n.Exponent([mn(e, u.args[1]), p]),
                  Vs(t.span.input, u.args[0].span.end, a.span.end),
                ),
              ]);
            }
          }
          return n.Exponent([e.setInput(n.DotAccess([c, l]), o.span), p]);
        } else return n.Exponent(It(e, t.args));
      }
      case "Sqrt":
        return n.FunctionCall("sqrt", It(e, t.args));
      case "Nthroot":
        return n.FunctionCall("nthroot", It(e, [t.args[1], t.args[0]]));
      case "Frac":
        return n.Divide(It(e, t.args));
      case "Derivative": {
        let o = It(e, t.args);
        if (!lr(t.args[0])) {
          throw U(
            `Expected identifier in derivative, but found ${t.args[0].type}`,
          );
        }
        return n.Derivative(o[0], [o[1]]);
      }
      case "Integral": {
        let [o, a, u, c] = t.args, l = It(e, [o, a, u, c]);
        return n.Integral(l);
      }
      case "EmptyIntegral": {
        let [o, a, u] = It(e, t.args),
          c = e.setInput(n.Constant(Se(1, 1)), void 0);
        return n.Integral([o, a, u, c]);
      }
      case "Sum": {
        let [o, a, u] = t.args;
        if (a.type !== "Comparator" || !ed(a)) throw aP();
        let c = It(e, [a.args[0], a.args[1], u]),
          l = mn(Kf(e, { prefix: "ro", expr: c[0] }), o);
        return n.Sum(c.concat(l));
      }
      case "Product": {
        let [o, a, u] = t.args;
        if (a.type !== "Comparator" || !ed(a)) throw uP();
        let c = It(e, [a.args[0], a.args[1], u]),
          l = mn(Kf(e, { prefix: "ro", expr: c[0] }), o);
        return n.Product(c.concat(l));
      }
      case "Juxt": {
        if (e.writeIntegral) {
          let [u, c] = t.args;
          if (
            c.type === "Letter" && c.val === "t" && u.type === "Juxt" &&
            ([u, c] = u.args, c.type === "Letter" && c.val === "n")
          ) {
            if (u.type === "Juxt") {
              if (
                [u, c] = u.args, c.type === "Letter" && c.val === "i"
              ) throw Gy();
            } else if (u.type === "Letter" && u.val === "i") throw Gy();
          }
        }
        let [o, a] = t.args;
        if (
          o.type === "MixedNumber" &&
          !(lr(a) || a.type === "Piecewise" || a.type === "Call" ||
            a.type === "Paren")
        ) throw Ty(Nh(o));
        if (a.type === "MixedNumber") throw Ty(Nh(a));
        return n.Multiply(It(e, t.args));
      }
      case "Letter":
        return n.Identifier(t.val);
      case "Cmd": {
        let o = t.val;
        switch (o) {
          case "ans": {
            if (e.currentIndex === void 0) throw Kd("ans");
            return n.Ans(`ans_{${e.currentIndex - 1}}`);
          }
          case "approx":
            throw uy(o);
          case "dt": {
            if (!e.allowDt) throw Kd(o);
            return n.Identifier(o);
          }
          case "index": {
            if (!e.allowIndex) throw Kd(o);
            return n.Identifier(o);
          }
          default:
            return n.Identifier(o);
        }
      }
      case "With": {
        if (e.isSubstitutionRHS) throw $y();
        let [o, a] = t.args, u = { ...e, isSubstitutionRHS: true };
        return n.Substitution(mn(u, o), yz(u, a));
      }
      case "Decimal":
        return n.Constant(kR(t));
      case "MixedNumber":
        return n.MixedNumber(HR(t));
      case "Piecewise":
        return hz(e, t);
      case "RightArrow":
        return gz(e, t);
      case "Seq":
        return n.BareSeq(It(e, t.args));
      case "EmptyPiecewise":
        return n.Restriction([
          e.setInput(n.Constant(true), No(t.span.input, t.span.start)),
        ]);
      case "Comparator":
        throw t.symbol === "=" ? ks("=") : cy();
      case "ComparatorChain":
        throw t.symbols.includes("=") ? wx() : cy();
      case "Tilde":
        throw ks("~");
      case "Colon":
        throw ks(":");
      case "Ellipsis":
        throw ks("...");
      case "For":
        return Oh(e, t, { parentIsList: false });
      case "EmptyRangeEnd":
        throw sP();
      case "Err":
        throw Tz(t.error);
      default:
        throw `Unexpected surface node ${t.type}.`;
    }
  }
  function EM(e) {
    return Kp.hasOwnProperty(e);
  }
  function YR(e) {
    return e === "ln" || e === "log" || e === "logbase";
  }
  function fz(e) {
    return e.type === "Decimal" && e.val === "2";
  }
  function mz(e) {
    return e.type !== "Neg"
      ? false
      : (e = e.args[0], e.type === "Decimal" && e.val === "1");
  }
  function BR(e, t) {
    let n = e.nodes, [r, s] = t.args, i = mn(e, r), o = Sr(s), a = It(e, o);
    if (Rh(r)) {
      let u = No(s.span.input, s.span.start), c = e.setInput(XR(e), u);
      return n.SeededFunctionCall(i, [c].concat(a));
    }
    if (lr(r)) return n.FunctionCall(i, a);
    if (r.type === "Superscript") {
      let [u, c] = r.args;
      if (u.type === "Cmd") {
        let l = u.val;
        if (EM(l) || YR(l)) {
          if (fz(c)) {
            return n.Exponent([
              e.setInput(n.FunctionCall(l, a), void 0),
              mn(e, c),
            ]);
          }
          if (mz(c) && Kp[l] !== void 0) return n.FunctionCall(Kp[l], a);
          throw EM(l) ? gI(l) : hI(l === "logbase" ? "log" : l);
        }
      }
    }
    return n.Multiply([i, mn(e, s)]);
  }
  function Oh(e, t, { parentIsList: n }) {
    let r = e.nodes,
      [s, i] = t.args,
      o = e.setInput(r.Identifier(`_comprehensionIndex_${cz++}`), void 0);
    if (s.type === "For") throw yu("for");
    let a = mn(Kf(e, { prefix: "li", expr: o }), s), u = [];
    if (i.type === "Seq") {
      let p = false, f = false, d = false;
      for (let y = 0; y < i.args.length; y++) {
        let g = i.args[y];
        ed(g) || e.allowIntervalComprehensions && g.type === "ComparatorChain"
          ? p = true
          : f = true, g.type === "Cmd" && g.val === "cursor" && (d = true);
      }
      if (p && f) {
        let y = yu("for");
        throw d &&
          y.setCursorContext({
            type: "for-assignment-lhs",
            allowedTypes: [Point],
          }),
          y;
      }
    }
    let c = [];
    for (let p of Sr(i)) {
      if (e.allowIntervalComprehensions && p.type === "ComparatorChain") {
        let f = MM(p), { min: d, identifier: y, max: g, open: m } = f;
        c.push({ identifier: mn(e, y), bounds: [mn(e, d), mn(e, g)], open: m });
      } else if (p.type === "Comparator" && ed(p)) {
        let f = e.setInput(r.AssignmentExpression(It(e, p.args)), p.span);
        u.push(f);
      } else {
        if (p.type === "Comparator") throw Jl("a");
        {
          let f = vP();
          throw p.type === "Cmd" && p.val === "cursor" &&
            f.setCursorContext({
              type: "for-assignment-lhs",
              allowedTypes: [Point],
            }),
            f;
        }
      }
    }
    let l = n;
    return r.ListComprehension(o, a, u, l, c);
  }
  function yz(e, t) {
    let n = e.nodes;
    if (t.type === "Seq") {
      let i = false, o = false, a = false;
      for (let u = 0; u < t.args.length; u++) {
        let c = t.args[u];
        if (c.type === "With") throw yu("with");
        if (ed(c) || GR(c)) i = true;
        else if (
          e.allowIntervalComprehensions && c.type === "ComparatorChain"
        ) {
          try {
            MM(c), o = true;
          } catch (l) {
            a = true;
          }
        } else a = true;
      }
      if ((i || o) && a) throw yu("with");
      if (o) throw Yy();
    }
    if (e.allowIntervalComprehensions && t.type === "ComparatorChain") {
      let i;
      try {
        MM(t), i = true;
      } catch (o) {
        i = false;
      }
      if (i) throw Yy();
    }
    if (t.type === "With") throw $y();
    let r = Sr(t), s = [];
    for (let i of r) {
      if (i.type != "Comparator" || !ed(i) && !GR(i)) throw of();
      let o = e.setInput(n.AssignmentExpression(It(e, i.args)), i.span);
      s.push(o);
    }
    return s;
  }
  function GR(e) {
    if (e.type !== "Comparator" || e.symbol !== "=") return false;
    let t = e.args[0];
    if (t.type !== "Call") return false;
    let [n] = t.args;
    return !!lr(n);
  }
  function MM(e) {
    if (e.symbols.length !== 2) throw Jl("a");
    let [t, n, r] = e.args, [s, i] = e.symbols;
    if (!lr(n)) throw Jl("a");
    if (
      s !== "<" && s !== "<=" || i !== "<" && i !== "<=" ||
      e.symbols.includes("=")
    ) throw Jl(Yn(n.span));
    return { min: t, identifier: n, max: r, open: [s === "<", i === "<"] };
  }
  function gz(e, t) {
    let n = e.nodes;
    if (!lr(t.args[0])) throw MT();
    return e = Kf(e, {
      prefix: "ec",
      expr: e.setInput(n.Identifier("globalEventCount"), void 0),
    }),
      n.UpdateRule(It(e, t.args));
  }
  function hz(e, t) {
    let n = e.nodes, [r] = t.args, s = Sr(r);
    if (s.length === 1 && Qf(s[0])) {
      let f = s[0];
      return n.Restriction([e.setInput(Ca(e, f), f.span)]);
    }
    if (s.length > 1 && s.every(Qf)) {
      let f = e.setInput(Ca(e, s[0]), s[0].span);
      for (let d = 1; d < s.length; d++) {
        let y = e.setInput(Ca(e, s[d]), s[d].span);
        f = e.setInput(n.Or([f, y]), Bs(s[0].span, s[d].span));
      }
      return n.Restriction([f]);
    }
    let i, o = [];
    e: for (i = 0; i < s.length; i++) {
      let f = s[i];
      switch (f.type) {
        case "Colon": {
          let [d, y] = f.args;
          if (!Qf(d)) throw TI();
          if (y.type === "With" && y.args[1].type === "Seq") throw yu("with");
          o.push({
            condition: e.setInput(Ca(e, d), d.span),
            if_expr: mn(e, y),
          });
          break;
        }
        case "Comparator":
        case "ComparatorChain":
          o.push({
            condition: e.setInput(Ca(e, f), f.span),
            if_expr: e.setInput(n.Constant(Se(1, 1)), Vs("1", 0, 1)),
          });
          break;
        case "For":
          throw yu("for");
        default:
          break e;
      }
    }
    if (i === 0) throw bI();
    if (i < s.length - 1) throw xI();
    let a, u;
    i === s.length - 1 ? (a = Jf(e, s[i]), u = s[i]) : a = n.Constant(NaN);
    let c = a, l = u == null ? void 0 : u.span, p;
    for (; o.length;) {
      p = o.pop(),
        c = n.Piecewise([p.condition, p.if_expr, e.setInput(c, l)]),
        l = void 0;
    }
    return c;
  }
  function Qf(e) {
    return e.type === "Comparator" || e.type === "ComparatorChain";
  }
  function Ca(e, t) {
    let n = e.nodes;
    switch (t.type) {
      case "Comparator":
        return n.Comparator[t.symbol](It(e, t.args));
      case "ComparatorChain":
        return n.ComparatorChain(t.symbols, It(e, t.args));
      default:
        throw U(`Unexpected type for condition: ${t.type}`);
    }
  }
  function bz(e) {
    let [t, n] = e.args;
    if (
      t.type === "Superscript" && (t = t.args[0]),
        t.type === "Cmd" && t.val === "logbase" && n.type === "Seq" &&
        n.args.length === 2
    ) { if (!Yo(n.args[0])) throw xy("log"); } else if (!Yo(n)) {
      throw t.type === "Cmd"
        ? xy(t.val)
        : U(`Unexpected type for args of implicit call: ${n.type}`);
    }
  }
  function kR(e) {
    return Qc(e.val);
  }
  function HR(e) {
    let t = Qc(e.whole), n = Qc(e.num), r = Qc(e.den);
    return qs(t, Ps(n, r));
  }
  function xz(e) {
    if (e.type !== "Call") return false;
    let t = e.args[0];
    for (
      ;
      t.type === "Superscript" || t.type === "Subscript" || t.type === "Prime";
    ) t = t.args[0];
    return t.type !== "Cmd" ? false : EM(t.val) || YR(t.val);
  }
  function ed(e) {
    return e.type === "Comparator" && e.symbol === "=" && lr(e.args[0]);
  }
  function Tz(e) {
    switch (e.type) {
      case "UnexpectedParseError":
      case "MissingBound":
      case "EmptyGroup":
      case "UnexpectedDifferential":
      case "UnexpectedEnd":
        return U(`Unexpected error type: ${e.type}`);
      case "InvalidOperatorName":
        return cI();
      case "UnexpectedCloseDelimiter":
      case "MissingCloseDelimiter":
        return bP(e.open, e.close);
      case "UnrecognizedSymbol":
        return e.val === "." ? ks(e.val) : uy(e.val);
      case "EmptyInput":
        return Xd();
      case "BinaryOperatorMissingRight":
      case "BinaryOperatorMissingLeft":
        return $d(e.val === "%" ? "% of" : e.val);
      case "UnaryOperatorMissingLeft":
        return nI(e.val);
      case "UnaryOperatorMissingRight":
        return rI(e.val);
      case "UnexpectedSubscript":
        return EI(e.base);
      case "PercentMissingOf":
        return TP();
      case "SumMissingBound":
        return iP();
      case "ProductMissingBound":
        return oP();
      case "IntegralMissingBound":
        return pP();
      case "SumMissingBody":
        return mP();
      case "ProductMissingBody":
        return yP();
      case "IntegralMissingBody":
        return gP();
      case "DerivativeMissingBody":
        return hP();
      case "IntegralMissingDifferential":
        return dP();
      case "DifferentialWithSuperscript":
        return fP();
      case "FractionMissingNumerator":
        return sI();
      case "FractionMissingDenominator":
        return iI();
      case "FractionEmpty":
        return oI();
      case "EmptySuperscript":
        return aI();
      case "EmptySubscript":
        return Ey();
      case "InvalidSubscript":
        return uI(e.val);
      case "SuperscriptWithPrime":
        return pI();
      case "PrimeWithoutParen":
        return Cy();
      case "UnexpectedPrime":
        return My();
      case "EmptyRadical":
        return dI();
      case "EmptyRadicalIndex":
        return fI();
      case "EmptySquareBracket":
        return mI();
      case "EmptyPipe":
        return yI();
      case "FunctionMissingArgument":
        return Ao(e.val, 1, 0, { includeUsageExample: true });
      case "AdjacentNumbers":
        return eI(Nh(e.args[0]), Nh(e.args[1]));
      case "TokenWithSubscript":
        return tI();
      case "UnexpectedFor":
        return ks("for");
      default:
        throw `Unexpected surface node ${e.type}.`;
    }
  }
  function Nh(e) {
    switch (e.type) {
      case "Decimal":
        return e.val;
      case "MixedNumber":
        return `${e.whole} ${e.num}/${e.den}`;
      default:
        let t = e;
        throw new Error(`Unexpected node type ${t.type}`);
    }
  }
  function Yo(e) {
    switch (e.type) {
      case "Letter":
      case "Decimal":
      case "MixedNumber":
      case "Cmd":
      case "EmptyPiecewise":
        return true;
      case "Neg": {
        let n = e.args[0];
        for (;;) {
          if (n.type === "Pos" || n.type === "Paren" && !$R(n)) n = n.args[0];
          else if (n.type === "Neg") n = n.args[0];
          else break;
        }
        return n.type === "Decimal" || n.type === "MixedNumber";
      }
      case "Pos":
        return Yo(e.args[0]);
      case "Paren":
        return Yo(e.args[0]);
      case "Juxt":
      case "Mul":
      case "DotMul":
      case "CrossMul":
      case "Div":
        return Yo(e.args[0]) && Yo(e.args[1]);
      case "Subscript":
        return Yo(e.args[0]);
      case "Superscript":
      case "Frac":
      case "Add":
      case "Sub":
        return Yo(e.args[0]) && Yo(e.args[1]);
      case "Piecewise": {
        let [n] = e.args;
        return Qf(n);
      }
      case "Call": {
        let [n, r] = e.args;
        return lr(n) || NR(n) ? false : Yo(n) && Yo(r);
      }
      case "Derivative":
      case "Sqrt":
      case "Nthroot":
      case "Pipes":
      case "Bang":
        return false;
      case "Comparator":
      case "ComparatorChain":
      case "Tilde":
      case "ImplicitCall":
      case "Index":
      case "List":
      case "Seq":
      case "Integral":
      case "EmptyIntegral":
      case "Sum":
      case "Product":
      case "Colon":
      case "Ellipsis":
      case "For":
      case "With":
      case "Dot":
      case "PercentOf":
      case "Prime":
      case "EmptyRangeEnd":
      case "RightArrow":
        return false;
      default:
        throw `Unexpected surface node ${e.type}.`;
    }
  }
  function Rh(e) {
    return e.type !== "Cmd" ? false : e.val === "random" || e.val === "shuffle";
  }
  function XR(e) {
    let t = e.nodes.ExtendSeed("", [
      e.setInput(e.nodes.Identifier("globalRandomSeed"), void 0),
      e.setInput(e.nodes.Seed(e.nextSeed()), void 0),
    ]);
    if (!e.seedExtensions) return t;
    for (let { prefix: n, expr: r } of e.seedExtensions) {
      t = e.nodes.ExtendSeed(n, [e.setInput(t, void 0), r]);
    }
    return t;
  }
  function Kf(e, t) {
    let n = e.seedExtensions || [];
    return { ...e, seedExtensions: n.concat(t) };
  }
  function td(e) {
    return { type: "initial", tokenType: e };
  }
  function em(e) {
    return { type: "l", tokenType: e };
  }
  function tm(e) {
    return { type: "r", tokenType: e };
  }
  function nn(e) {
    return { type: "la", tokenType: e };
  }
  function nd(e) {
    return { type: "ra", tokenType: e };
  }
  function ZR(e, t) {
    for (let n of YN) {
      if (t[n] === void 0) {
        throw new Error(
          `Programming Error: token ${n} must be a assigned a ${e} precedence`,
        );
      }
    }
  }
  function hl(e, t, n, r) {
    if (t[n] !== void 0) {
      throw new Error(
        `Programming Error: duplicate ${e} entry for token ${n}.`,
      );
    }
    t[n] = r;
  }
  function WR(e) {
    let t = {}, n = {}, r = {};
    for (let a = 0; a < e.length; a++) {
      let u = e[a];
      for (let { type: c, tokenType: l } of u) {
        switch (c) {
          case "initial":
            hl("initial", t, l, a);
            break;
          case "l":
            hl("left", n, l, a);
            break;
          case "r":
            hl("right", r, l, a);
            break;
          case "la":
            hl("left", n, l, a), hl("right", r, l, a);
            break;
          case "ra":
            hl("left", n, l, a), hl("right", r, l, a - 1);
            break;
        }
      }
    }
    ZR("left", n), ZR("right", r);
    function s(a) {
      return r[a];
    }
    function i(a) {
      return n[a];
    }
    function o(a) {
      let u = t[a];
      return u === void 0 ? s(a) : u;
    }
    return { rightPrec: s, leftPrec: i, initialPrec: o };
  }
  function Be(e, t) {
    return { type: "Err", span: e, error: t };
  }
  function DM() {
    return { type: "UnexpectedParseError" };
  }
  function jR() {
    return { type: "EmptyInput" };
  }
  function JR() {
    return { type: "EmptyGroup" };
  }
  function SM() {
    return { type: "EmptySubscript" };
  }
  function QR() {
    return { type: "EmptySuperscript" };
  }
  function vM() {
    return { type: "EmptyRadical" };
  }
  function KR() {
    return { type: "EmptySquareBracket" };
  }
  function eA() {
    return { type: "EmptyPipe" };
  }
  function tA() {
    return { type: "EmptyRadicalIndex" };
  }
  function OM() {
    return { type: "UnexpectedEnd" };
  }
  function bl(e) {
    return { type: "BinaryOperatorMissingRight", val: e };
  }
  function nA(e) {
    return { type: "BinaryOperatorMissingLeft", val: e };
  }
  function NM(e) {
    return { type: "UnaryOperatorMissingRight", val: e };
  }
  function RM(e) {
    return { type: "UnaryOperatorMissingLeft", val: e };
  }
  function rA(e, t) {
    return { type: "MissingCloseDelimiter", open: e, close: t };
  }
  function nm(e, t) {
    return { type: "UnexpectedCloseDelimiter", open: e, close: t };
  }
  function sA() {
    return { type: "UnexpectedDifferential" };
  }
  function iA(e) {
    return { type: "UnrecognizedSymbol", val: e };
  }
  function oA(e) {
    return { type: "InvalidSubscript", val: e };
  }
  function aA(e) {
    return { type: "UnexpectedSubscript", base: e };
  }
  function AM(e) {
    return { type: "FunctionMissingArgument", val: e };
  }
  function uA() {
    return { type: "PercentMissingOf" };
  }
  function _M() {
    return { type: "PrimeWithoutParen" };
  }
  function cA() {
    return { type: "SuperscriptWithPrime" };
  }
  function Ah() {
    return { type: "UnexpectedPrime" };
  }
  function lA() {
    return { type: "SumMissingBound" };
  }
  function pA() {
    return { type: "ProductMissingBound" };
  }
  function LM() {
    return { type: "MissingBound" };
  }
  function dA() {
    return { type: "IntegralMissingBound" };
  }
  function fA() {
    return { type: "SumMissingBody" };
  }
  function mA() {
    return { type: "ProductMissingBody" };
  }
  function yA() {
    return { type: "IntegralMissingBody" };
  }
  function gA() {
    return { type: "DerivativeMissingBody" };
  }
  function hA() {
    return { type: "IntegralMissingDifferential" };
  }
  function bA() {
    return { type: "DifferentialWithSuperscript" };
  }
  function xA() {
    return { type: "FractionMissingNumerator" };
  }
  function TA() {
    return { type: "FractionMissingDenominator" };
  }
  function IA() {
    return { type: "FractionEmpty" };
  }
  function wM(e) {
    return { type: "AdjacentNumbers", args: e };
  }
  function PA() {
    return { type: "UnexpectedFor" };
  }
  function EA() {
    return { type: "TokenWithSubscript" };
  }
  var Pz = [
      [
        td("("),
        nn(")"),
        td("\\{"),
        nn("\\}"),
        tm("["),
        nn("]"),
        td("(|"),
        nn("|)"),
        nn("Differential"),
        nn("End"),
      ],
      [nn("for")],
      [tm("with")],
      [nd("...")],
      [nn(",")],
      [nd(":")],
      [tm("->")],
      [em("with")],
      [nn("="), nn(">"), nn("<"), nn(">="), nn("<="), nn("~")],
      [em("->")],
      [nn("+"), nn("-")],
      [
        nn("*"),
        nn("\\cdot"),
        nn("\\times"),
        nn("/"),
        nn("Decimal"),
        nn("MixedNumber"),
        nn("Letter"),
        nn("Cmd"),
        nn("TokenNode"),
        nn("%"),
        tm("("),
        nn("\\{"),
        nn("(|"),
        nn("Frac"),
        nn("Sqrt"),
        nn("Trig"),
        nn("Ln"),
        nn("Log"),
        nd("Int"),
        nd("Sum"),
        nd("Prod"),
      ],
      [td("+"), td("-")],
      [nn("!")],
      [nn("SupSub")],
      [em("["), nn(".")],
      [em("(")],
      [nn("Err")],
    ],
    { leftPrec: _h, rightPrec: MA, initialPrec: vA } = WR(Pz),
    CA = { trailingComma: false };
  function OA(e, t) {
    let n = t ? { ...CA, ...t } : CA, r = ru(e, n), s = Ez(r);
    return s.type === "Err" && s.error.type === "EmptyGroup"
      ? Be(s.span, jR())
      : s;
  }
  function Ez(e) {
    return Xu(e, { isToplevel: true });
  }
  function Xu(e, { isToplevel: t } = { isToplevel: false }) {
    if (vh(e)) return Be(Pe(e, e), JR());
    let { state: n, tree: r } = pr(e, 0, { isToplevel: t });
    return r.type !== "Err" && !vh(n) ? VM(n).tree : r;
  }
  function H(e, t) {
    return { state: e, tree: t };
  }
  function pr(e, t, { isToplevel: n } = { isToplevel: false }) {
    let r = e, s;
    if ({ state: r, tree: s } = Mz(r), s.type === "Err") return H(r, s);
    if (!PM(e, r)) {
      throw new Error("Programming Error: parseInitial did not advance state.");
    }
    for (; !vh(r);) {
      let i;
      if (Hr(r, "(") && !Sz(s) ? i = MA("(") : i = _h(ss(r).type), t >= i) {
        break;
      }
      let o = r, a = Cz(r, s, n) ? _h("for") - 1 : MA(ss(r).type);
      if ({ state: r, tree: s } = Dz(r, s, a), s.type === "Err") return H(r, s);
      if (!PM(o, r)) {
        throw new Error(
          "Programming Error: parseSuccessor did not advance state.",
        );
      }
    }
    return H(r, s);
  }
  function Ei(e) {
    return e.type === "UnexpectedDifferential" ||
      e.type === "UnexpectedCloseDelimiter" || e.type === "UnexpectedEnd" ||
      e.type === "BinaryOperatorMissingLeft";
  }
  function Mz(e) {
    let t = e, n = ss(e), r = vA(n.type), s;
    switch (n.type) {
      case "+": {
        if (e = Xe(e), { state: e, tree: s } = pr(e, r), s.type === "Err") {
          if (!Ei(s.error)) return H(e, s);
          let o = Pe(t, e), a = Be(o, NM(n.val));
          return H(e, a);
        }
        return H(e, KN(Pe(t, e), [s]));
      }
      case "-":
        if (e = Xe(e), { state: e, tree: s } = pr(e, r), s.type === "Err") {
          if (!Ei(s.error)) return H(e, s);
          let o = Pe(t, e), a = Be(o, NM(n.val));
          return H(e, a);
        } else return H(e, eR(Pe(t, e), [s]));
      case "(":
        return rm(e);
      case "\\{":
        return e = Xe(e),
          Hr(e, "\\}")
            ? (e = Xe(e), H(e, xR(Pe(t, e))))
            : ({ state: e, tree: s } = pr(e, r),
              { state: e, tree: s } = sm(t, e, s, "\\{", "\\}"),
              s.type === "Err" ? H(e, s) : H(e, bR(Pe(t, e), [s])));
      case "[":
        return e = Xe(e),
          Hr(e, "]")
            ? (e = Xe(e), H(e, yM(Pe(t, e), [])))
            : ({ state: e, tree: s } = pr(e, r),
              { state: e, tree: s } = sm(t, e, s, "[", "]"),
              s.type === "Err" ? H(e, s) : H(e, yM(Pe(t, e), [s])));
      case "(|": {
        if (e = Xe(e), Hr(e, "|)")) {
          e = Xe(e);
          let o = Pe(t, e);
          return H(e, Be(o, eA()));
        }
        return { state: e, tree: s } = pr(e, r),
          { state: e, tree: s } = sm(t, e, s, "(|", "|)"),
          s.type === "Err" ? H(e, s) : H(e, cR(Pe(t, e), [s]));
      }
      case "Frac": {
        if (e.opts.disallowFrac) throw Uy();
        e = Xe(e);
        let o = Xu(ru(n.num, e.opts)), a = Xu(ru(n.den, e.opts));
        if (
          o.type === "Err" && o.error.type === "EmptyGroup" &&
          a.type === "Err" && a.error.type === "EmptyGroup"
        ) {
          let u = Pe(t, e), c = Be(u, IA());
          return H(e, c);
        }
        if (o.type === "Err" && o.error.type === "EmptyGroup") {
          let u = Pe(t, e), c = Be(u, xA());
          return H(e, c);
        }
        if (a.type === "Err" && a.error.type === "EmptyGroup") {
          let u = Pe(t, e), c = Be(u, TA());
          return H(e, c);
        }
        if (o.type === "Err") return H(e, o);
        if (a.type === "Err") return H(e, a);
        if (RR(o, a) && a.type === "Juxt") {
          let u = a.args[1], c;
          if ({ state: e, tree: c } = pr(e, _h("*") - 1), c.type === "Err") {
            if (Ei(c.error)) {
              let l = Pe(t, e);
              return H(e, Be(l, gA()));
            }
            return H(e, c);
          }
          return H(e, fR(Pe(t, e), [u, c]));
        }
        return H(e, dR(Pe(t, e), [o, a]));
      }
      case "Sqrt":
        if (e = Xe(e), n.optArg) {
          let o = Xu(ru(n.optArg, e.opts));
          if (o.type === "Err") {
            return o.error.type === "EmptyGroup"
              ? H(e, Be(o.span, tA()))
              : H(e, o);
          }
          let a = Xu(ru(n.arg, e.opts));
          return a.type === "Err"
            ? a.error.type === "EmptyGroup" ? H(e, Be(a.span, vM())) : H(e, a)
            : H(e, pR(Pe(t, e), [o, a]));
        } else {
          let o = Xu(ru(n.arg, e.opts));
          return o.type === "Err"
            ? o.error.type === "EmptyGroup" ? H(e, Be(o.span, vM())) : H(e, o)
            : H(e, lR(Pe(t, e), [o]));
        }
      case "Trig":
      case "Ln": {
        e = Xe(e);
        let o = gl(Pe(t, e), n.val), a = 0, u = ss(e);
        if (u.type === "SupSub") {
          if (e = Xe(e), u.sub) {
            let p = Pe(t, e), f = Be(p, aA(o.val));
            return H(e, f);
          }
          let l = Lh(u, e.opts);
          if (l) {
            if (l.type === "Err") return H(e, l);
            o = Eh(Pe(t, e), [o, l]);
          }
          a = u.nprimes;
        }
        let c = Hr(e, "(");
        if (c) {
          if ({ state: e, tree: s } = rm(e), s.type === "Err") return H(e, s);
          s = Zf(Pe(t, e), [o, s.args[0]]);
        } else {
          if ({ state: e, tree: s } = pr(e, r - 1), s.type === "Err") {
            return Ei(s.error) ? H(e, Be(Pe(t, e), AM(n.val))) : H(e, s);
          }
          s = fM(Pe(t, e), [o, s]);
        }
        if (a > 0) {
          let l = Pe(t, e);
          if (!c) {
            let p = Be(l, _M());
            return H(e, p);
          }
          s = Wf(l, a, [s]);
        }
        return H(e, s);
      }
      case "Log": {
        e = Xe(e);
        let o = Pe(t, e), a = gl(o, n.val), u = 0, c, l, p = ss(e);
        if (
          p.type === "SupSub" &&
          (e = Xe(e), c = NA(p, e.opts), l = Lh(p, e.opts), u = p.nprimes),
            c && c.type === "Err"
        ) return H(e, c);
        if (l && l.type === "Err") return H(e, l);
        let f = Hr(e, "(");
        if (f) {
          if ({ state: e, tree: s } = rm(e), s.type === "Err") return H(e, s);
          s = s.args[0];
        } else if ({ state: e, tree: s } = pr(e, r - 1), s.type === "Err") {
          return Ei(s.error) ? H(e, Be(Pe(t, e), AM(n.val))) : H(e, s);
        }
        let d = c ? gl(o, "\\logbase") : a,
          y = c ? Mh(Pe(t, e), Sr(s).concat(c)) : s;
        if (
          l && (d = Eh(Pe(t, e), [d, l])),
            f ? s = Zf(Pe(t, e), [d, y]) : s = fM(Pe(t, e), [d, y]),
            u > 0
        ) {
          let g = Pe(t, e);
          if (!f) {
            let m = Be(g, _M());
            return H(e, m);
          }
          s = Wf(g, u, [s]);
        }
        return H(e, s);
      }
      case "Int": {
        e = Xe(e);
        let o = ss(e);
        e = Xe(e);
        let a = FM(o, t, e);
        if (a.type === "Err") {
          return a.error.type === "MissingBound"
            ? H(e, Be(a.span, dA()))
            : H(e, a);
        }
        let { sup: u, sub: c } = a, l;
        if (Hr(e, "Differential")) {
          return { state: e, tree: l } = SA(e),
            l.type === "Err" ? H(e, l) : H(e, yR(Pe(t, e), [l, c, u]));
        }
        if ({ state: e, tree: s } = pr(e, r), s.type === "Err") {
          return Ei(s.error) ? H(e, Be(s.span, yA())) : H(e, s);
        }
        let p = s;
        return Hr(e, "Differential")
          ? ({ state: e, tree: l } = SA(e),
            l.type === "Err" ? H(e, l) : H(e, mR(Pe(t, e), [l, c, u, p])))
          : H(e, Be(Pe(t, e), hA()));
      }
      case "Sum": {
        e = Xe(e);
        let o = ss(e);
        e = Xe(e);
        let a = FM(o, t, e);
        if (a.type === "Err") {
          return a.error.type === "MissingBound"
            ? H(e, Be(a.span, lA()))
            : H(e, a);
        }
        let { sup: u, sub: c } = a;
        return { state: e, tree: s } = pr(e, r),
          s.type === "Err"
            ? Ei(s.error) ? H(e, Be(s.span, fA())) : H(e, s)
            : H(e, gR(Pe(t, e), [s, c, u]));
      }
      case "Prod": {
        e = Xe(e);
        let o = ss(e);
        e = Xe(e);
        let a = FM(o, t, e);
        if (a.type === "Err") {
          return a.error.type === "MissingBound"
            ? H(e, Be(a.span, pA()))
            : H(e, a);
        }
        let { sup: u, sub: c } = a;
        return { state: e, tree: s } = pr(e, r),
          s.type === "Err"
            ? Ei(s.error) ? H(e, Be(s.span, mA())) : H(e, s)
            : H(e, hR(Pe(t, e), [s, c, u]));
      }
      case "Cmd":
        return e = Xe(e), s = gl(Pe(t, e), n.val), H(e, s);
      case "TokenNode": {
        e = Xe(e);
        let o = ss(e);
        return o.type === "SupSub" && o.sub
          ? (e = Xe(e), H(e, Be(Pe(t, e), EA())))
          : (s = gl(Pe(t, e), n.val), H(e, s));
      }
      case "Letter":
        return e = Xe(e), s = SR(Pe(t, e), n.val), H(e, s);
      case "Decimal": {
        e = Xe(e);
        let o = Ch(Pe(t, e), n.val), a = e.token;
        if (a.type === "Decimal" || a.type === "MixedNumber") {
          let u = e;
          e = Xe(e);
          let c = Pe(t, e),
            l = a.type === "MixedNumber" ? a : Ch(Pe(u, e), a.val);
          return H(e, Be(c, wM([o, l])));
        }
        if (
          n.val.endsWith(".") && a.type === "Cmd" &&
          (a.val === "\\real" || a.val === "\\imag")
        ) throw ly();
        return H(e, o);
      }
      case "MixedNumber": {
        if (e.opts.disallowFrac) throw Uy();
        e = Xe(e);
        let o = e.token;
        if (o.type === "Decimal" || o.type === "MixedNumber") {
          let a = e;
          e = Xe(e);
          let u = Pe(t, e),
            c = o.type === "MixedNumber" ? o : Ch(Pe(a, e), o.val);
          return H(e, Be(u, wM([n, c])));
        }
        return H(e, n);
      }
      case "*":
      case "\\cdot":
      case "\\times":
      case "/":
      case ",":
      case "=":
      case ">":
      case "<":
      case ">=":
      case "<=":
      case "->":
      case "~":
      case ":":
      case "...":
      case "%":
      case ".": {
        e = Xe(e);
        let o = Pe(t, e), a = Be(o, nA(n.val));
        return H(e, a);
      }
      case "for": {
        e = Xe(e);
        let o = Pe(t, e), a = Be(o, PA());
        return H(e, a);
      }
      case "with": {
        e = Xe(e);
        let o = Pe(t, e), a = Be(o, DM());
        return H(e, a);
      }
      case "!": {
        e = Xe(e);
        let o = Pe(t, e), a = Be(o, RM(n.val));
        return H(e, a);
      }
      case "SupSub": {
        e = Xe(e);
        let o = "supsub";
        n.sub
          ? o = "subscript"
          : n.sup
          ? o = "superscript"
          : n.nprimes > 0 && (o = "prime");
        let a = Pe(t, e), u = Be(a, RM(o));
        return H(e, u);
      }
      case ")":
      case "\\}":
      case "]":
      case "|)":
      case "Differential":
        return VM(e);
      case "Err": {
        e = Xe(e);
        let o = Pe(t, e), a = Be(o, iA(n.val));
        return H(e, a);
      }
      case "End": {
        let o = Pe(t, e), a = Be(o, OM());
        return H(e, a);
      }
      default:
        throw `Unexpected token type ${n.type}.`;
    }
  }
  function Cz(e, t, n) {
    return Hr(e, "=") && n && (qR(t) || CM(t));
  }
  function Dz(e, t, n) {
    let r = ss(e), s;
    switch (r.type) {
      case "+":
      case "-":
      case "*":
      case "\\cdot":
      case "\\times":
      case "/":
      case "~":
      case ":":
      case ".":
      case "->":
      case "for": {
        if (e = Xe(e), { state: e, tree: s } = pr(e, n), s.type === "Err") {
          if (Ei(s.error)) {
            let o = er(t.span, e), a = Be(o, bl(r.val));
            return H(e, a);
          } else return H(e, s);
        }
        return H(e, DA(r.type, er(t.span, e), [t, s]));
      }
      case "with": {
        if (e = Xe(e), { state: e, tree: s } = pr(e, n), s.type === "Err") {
          if (Ei(s.error)) {
            let o = er(t.span, e), a = Be(o, bl(r.val));
            return H(e, a);
          } else return H(e, s);
        }
        return H(e, DA(r.type, er(t.span, e), [t, s]));
      }
      case "%": {
        e = Xe(e);
        let o = ss(e);
        if (o.type !== "Cmd" || o.val !== "of" && o.val !== "\\of") {
          let a = Be(r.span, uA());
          return H(e, a);
        }
        if (e = Xe(e), { state: e, tree: s } = pr(e, n), s.type === "Err") {
          if (Ei(s.error)) {
            let a = er(t.span, e), u = Be(a, bl(r.val));
            return H(e, u);
          } else return H(e, s);
        }
        return H(e, CR(er(t.span, e), [t, s]));
      }
      case "=":
      case ">=":
      case "<=":
      case ">":
      case "<": {
        let o = [t], a = [];
        for (;;) {
          let c = ss(e).type;
          if (c !== "=" && c !== ">=" && c !== "<=" && c !== ">" && c !== "<") {
            break;
          }
          if (
            a.push(c),
              e = Xe(e),
              { state: e, tree: s } = pr(e, n),
              s.type === "Err"
          ) {
            if (Ei(s.error)) {
              let l = er(t.span, e), p = Be(l, bl(r.val));
              return H(e, p);
            } else return H(e, s);
          }
          o.push(s);
        }
        let u = o[o.length - 1];
        return u.type === "Comparator"
          ? (o.pop(), Array.prototype.push.apply(o, u.args), a.push(u.symbol))
          : u.type === "ComparatorChain" &&
            (o.pop(),
              Array.prototype.push.apply(o, u.args),
              Array.prototype.push.apply(a, u.symbols)),
          o.length === 2
            ? H(e, jN(er(t.span, e), a[0], o))
            : H(e, JN(er(t.span, e), a, o));
      }
      case "!":
        return e = Xe(e), H(e, aR(er(t.span, e), [t]));
      case "[": {
        let o = e;
        if (e = Xe(e), Hr(e, "]")) {
          e = Xe(e);
          let a = Pe(o, e);
          return H(e, Be(a, KR()));
        }
        return { state: e, tree: s } = pr(e, n),
          { state: e, tree: s } = sm(o, e, s, "[", "]"),
          s.type === "Err" ? H(e, s) : H(e, uR(er(t.span, e), [t, s]));
      }
      case "Sqrt":
      case "Frac":
      case "Letter":
      case "Cmd":
      case "TokenNode":
      case "Trig":
      case "Ln":
      case "Log":
      case "Sum":
      case "Int":
      case "Prod":
      case "Decimal":
      case "MixedNumber":
      case "\\{":
      case "(|":
        return { state: e, tree: s } = pr(e, n),
          s.type === "Err" ? H(e, s) : H(e, bM(er(t.span, e), [t, s]));
      case "(":
        if (lr(t)) {
          if ({ state: e, tree: s } = rm(e), s.type === "Err") return H(e, s);
          let o = er(t.span, e);
          return H(e, Zf(o, [t, s.args[0]]));
        } else if (t.type === "Prime" && lr(t.args[0])) {
          if ({ state: e, tree: s } = rm(e), s.type === "Err") return H(e, s);
          let o = er(t.span, e);
          return H(e, Wf(o, t.nprimes, [Zf(o, [t.args[0], s.args[0]])]));
        } else {return { state: e, tree: s } = pr(e, n),
            s.type === "Err" ? H(e, s) : H(e, bM(er(t.span, e), [t, s]));}
      case "SupSub": {
        e = Xe(e);
        let o = RA(r), a = Lh(r, e.opts);
        if (o && o.type === "Err") return H(e, o);
        if (a && a.type === "Err") return H(e, a);
        if (
          o && (t = gM(er(t.span, e), [t, o])),
            a && (t = Eh(er(t.span, e), [t, a])),
            r.nprimes > 0
        ) {
          let u = er(t.span, e);
          if (!lr(t)) {
            let c = Be(u, Ah());
            return H(e, c);
          }
          t = Wf(u, r.nprimes, [t]);
        }
        return H(e, t);
      }
      case ",": {
        let o = [t];
        for (
          ;
          Hr(e, ",") &&
          (e = Xe(e), !(Hr(e, "...") || e.opts.trailingComma && vz(e)));
        ) {
          if ({ state: e, tree: s } = pr(e, n), s.type === "Err") {
            if (Ei(s.error)) {
              let a = er(t.span, e), u = Be(a, bl(r.val));
              return H(e, u);
            } else return H(e, s);
          }
          o.push(s);
        }
        return H(e, Mh(er(t.span, e), o));
      }
      case "...": {
        if (e = Xe(e), Hr(e, ",") && (e = Xe(e)), n >= _h(ss(e).type)) {
          return H(e, hM(er(t.span, e), [t, TR(TM(e))]));
        }
        if ({ state: e, tree: s } = pr(e, n), s.type === "Err") {
          if (Ei(s.error)) {
            let o = er(t.span, e), a = Be(o, bl(r.val));
            return H(e, a);
          } else return H(e, s);
        }
        return H(e, hM(er(t.span, e), [t, s]));
      }
      case "]":
      case ")":
      case "\\}":
      case "|)":
      case "Differential":
        return VM(e);
      case "Err":
        return pr(e, n);
      case "End": {
        let o = Pe(e, e), a = Be(o, OM());
        return H(e, a);
      }
      default:
        throw `Unexpected token type ${r.type}.`;
    }
  }
  function Sz(e) {
    return !!(lr(e) || e.type === "Prime" && lr(e.args[0]));
  }
  function DA(e, t, n) {
    switch (e) {
      case "+":
        return tR(t, n);
      case "-":
        return nR(t, n);
      case "*":
        return rR(t, n);
      case "\\cdot":
        return sR(t, n);
      case "\\times":
        return iR(t, n);
      case "/":
        return oR(t, n);
      case "~":
        return QN(t, n);
      case ":":
        return IR(t, n);
      case ".":
        switch (n[0].type) {
          case "Decimal":
          case "MixedNumber":
            throw ly();
          default:
            return MR(t, n);
        }
      case "->":
        return DR(t, n);
      case "for":
        return PR(t, n);
      case "with":
        return ER(t, n);
      default:
        throw `Unexpected token type ${e}.`;
    }
  }
  function NA(e, t) {
    if (!e.sub) return;
    let n = e.sub, r = Xu(ru(n, t));
    return r.type === "Err" && r.error.type === "EmptyGroup"
      ? Be(r.span, SM())
      : r;
  }
  function RA(e) {
    if (!e.sub) return;
    let t = e.sub;
    if (t.args.length === 0) return Be(t.span, SM());
    let n = [];
    for (let r of t.args) {
      if (r.type === "Digit" || r.type === "Letter") n.push(r.val);
      else {
        let s = r.span;
        return Be(s, oA(Yn(s)));
      }
    }
    return vR(t.span, n.join(""));
  }
  function Lh(e, t) {
    if (!e.sup) return;
    let n = Xu(ru(e.sup, t));
    return n.type === "Err"
      ? n.error.type === "EmptyGroup" ? Be(n.span, QR()) : n
      : e.nprimes > 0
      ? Be(e.span, cA())
      : n;
  }
  function FM(e, t, n) {
    if (e.type !== "SupSub") {
      let i = Pe(t, n);
      return Be(i, LM());
    }
    if (e.nprimes > 0) {
      let i = Pe(t, n);
      return Be(i, Ah());
    }
    let r = NA(e, n.opts), s = Lh(e, n.opts);
    if (
      !r || r.type === "Err" && r.error.type === "EmptySubscript" || !s ||
      s.type === "Err" && s.error.type === "EmptySuperscript"
    ) {
      let i = Pe(t, n);
      return Be(i, LM());
    }
    return r.type === "Err"
      ? r
      : s.type === "Err"
      ? s
      : { type: "Bounds", sup: s, sub: r };
  }
  function rm(e) {
    if (e.opts.disableParentheses) throw DP();
    let t = e, n = ss(e), r = vA(n.type);
    if (Hr(e, "(")) e = Xe(e);
    else {throw new Error(
        "Programming Error: expected '(' at start of parseParen.",
      );}
    if (Hr(e, ")")) {
      let i = Mh(TM(e), []);
      e = Xe(e);
      let o = Pe(t, e);
      return H(e, mM(o, [i]));
    }
    let s;
    return { state: e, tree: s } = pr(e, r),
      { state: e, tree: s } = sm(t, e, s, "(", ")"),
      s.type === "Err" ? H(e, s) : H(e, mM(Pe(t, e), [s]));
  }
  function SA(e) {
    let t = e, n = ss(e);
    if (n.type !== "Differential") {
      throw new Error("Programming Error: expected differential");
    }
    e = Xe(e);
    let r = gl(n.span, n.val), s = ss(e);
    if (s.type === "SupSub") {
      e = Xe(e);
      let i = Pe(t, e), o = RA(s);
      if (o) {
        if (o.type === "Err") return H(e, o);
        r = gM(i, [r, o]);
      }
      if (s.sup) return H(e, Be(i, bA()));
      if (s.nprimes > 0) return H(e, Be(i, Ah()));
    }
    return H(e, r);
  }
  function sm(e, t, n, r, s) {
    if (n.type === "Err" && n.error.type !== "UnexpectedEnd") return H(t, n);
    if (n.type === "Err" || !Hr(t, s)) {
      let i = Pe(e, t), o = Be(i, rA(r, s));
      return H(t, o);
    }
    return t = Xe(t), H(t, n);
  }
  function VM(e) {
    let t = e;
    switch (ss(e).type) {
      case ")": {
        e = Xe(e);
        let r = Pe(t, e);
        return H(e, Be(r, nm("(", ")")));
      }
      case "]": {
        e = Xe(e);
        let r = Pe(t, e);
        return H(e, Be(r, nm("[", "]")));
      }
      case "\\}": {
        e = Xe(e);
        let r = Pe(t, e);
        return H(e, Be(r, nm("\\{", "\\}")));
      }
      case "|)": {
        e = Xe(e);
        let r = Pe(t, e);
        return H(e, Be(r, nm("|", "|")));
      }
      case "Differential": {
        e = Xe(e);
        let r = Pe(t, e);
        return H(e, Be(r, sA()));
      }
      default: {
        e = Xe(e);
        let r = Pe(t, e);
        return H(e, Be(r, DM()));
      }
    }
  }
  function vz(e) {
    return Hr(e, ")") || Hr(e, "]") || Hr(e, "\\}");
  }
  function Zu(e, t) {
    return Bs(e.token.span, t.prevSpan);
  }
  function Da(e, t, n) {
    return { type: e, span: t, val: n };
  }
  function Oz(e, t, n, r) {
    return { input: e, prevSpan: t, pos: n, token: r };
  }
  function AA(e) {
    return _A(e, 0, No(e, 0));
  }
  function _A(e, t, n) {
    for (; ZN(e.charCodeAt(t));) t += 1;
    let r = Rz(e, t);
    return Oz(e, n, t, r);
  }
  function mo(e) {
    return _A(e.input, e.token.span.end, e.token.span);
  }
  function Xo(e) {
    return e.token;
  }
  function Zo(e, t) {
    if (Xo(e).type !== t) throw `Parse Error: expected ${t}.`;
    return mo(e);
  }
  function BM(e, t) {
    return Xo(e).type === t;
  }
  function wh(e) {
    return e.pos >= e.input.length;
  }
  var Nz = { "[": "[", "]": "]", "{": "{", "}": "}", "^": "^", _: "_" };
  function Rz(e, t) {
    let n = t;
    if (t >= e.length) return Da("End", No(e, t), "");
    let r = e.charCodeAt(t);
    if (XN(r)) {
      let s = Vs(e, n, t + 1);
      return Da("Digit", s, e.charAt(n));
    } else if (Ih(r)) {
      let s = Vs(e, n, t + 1);
      return Da("Letter", s, e.charAt(n));
    } else if (Ph(r)) {
      if (t += 1, Ih(e.charCodeAt(t))) {
        for (; Ih(e.charCodeAt(t));) t += 1;
        let s = Vs(e, n, t), i = Yn(s);
        return Da(
          i === "\\left" ? "Left" : i === "\\right" ? "Right" : "Cmd",
          s,
          i,
        );
      } else {
        t += 1;
        let s = Vs(e, n, t), i = Yn(s);
        return Da("EscapedSymbol", s, i);
      }
    } else if (dM(r)) {
      for (t += 1; dM(e.charCodeAt(t));) t += 1;
      if (e.charAt(t) === "^") {
        t += 1;
        let s = Vs(e, n, t), i = Yn(s);
        return Da("Primes^", s, i);
      } else {
        let s = Vs(e, n, t), i = Yn(s);
        return Da("Primes", s, i);
      }
    } else {
      let s = Vs(e, n, t + 1), i = e.charAt(n), o = Nz[i] || "Symbol";
      return Da(o, s, i);
    }
  }
  function GM(e, t) {
    return { type: "Group", span: e, args: t };
  }
  function LA(e, t, n) {
    return { type: "Sqrt", span: e, optArg: t, arg: n };
  }
  function wA(e, t, n) {
    return { type: "Frac", span: e, num: t, den: n };
  }
  function FA(e, t, n, r) {
    return { type: "SupSub", span: e, sup: t, sub: n, nprimes: r };
  }
  function VA(e, t, n, r) {
    return { type: "LeftRight", span: e, left: t, right: n, arg: r };
  }
  function BA(e, t) {
    return { type: "OperatorName", span: e, arg: t };
  }
  function GA(e, t) {
    return { type: "TokenNode", span: e, arg: t };
  }
  function kA(e, t) {
    return { type: "Symbol", span: e, val: t };
  }
  var kM = { type: "primitive", errorName: "^" },
    HA = { type: "primitive", errorName: "_" },
    _z = {
      "\\frac": {
        type: "macro",
        errorName: "\\frac",
        expandsToSingleAtom: true,
      },
      "\\operatorname": {
        type: "macro",
        errorName: "\\operatorname",
        expandsToSingleAtom: false,
      },
      "\\token": {
        type: "macro",
        errorName: "\\token",
        expandsToSingleAtom: false,
      },
    };
  function zA(e) {
    let t = Xo(e);
    if (t.type === "Cmd") {
      return t.val === "\\sqrt"
        ? BM(mo(e), "[")
          ? {
            type: "macro",
            errorName: "\\sqrt[*]",
            expandsToSingleAtom: false,
          }
          : { type: "primitive", errorName: "\\sqrt" }
        : _z[t.val];
    }
    if (t.type === "^" || t.type === "Primes^") return kM;
    if (t.type === "_") return HA;
  }
  function UA(e) {
    let { state: t, tree: n } = Fh(AA(e), false);
    if (!wh(t)) throw `Parse error: unexpected ${Yn(Xo(t).span)}.`;
    return n;
  }
  function qi(e, t) {
    return { state: e, tree: t };
  }
  function Fh(e, t) {
    let n = e, r = [];
    e: for (; !wh(e);) {
      let i = Xo(e);
      switch (i.type) {
        case "Cmd":
        case "EscapedSymbol":
        case "Letter":
        case "Digit":
        case "Symbol":
        case "[":
        case "{":
        case "^":
        case "_":
        case "Primes":
        case "Primes^":
        case "Left":
        case "]": {
          if (i.type === "]" && t) break e;
          let a;
          if ({ state: e, tree: a } = qA(e), a.type === "Group") {
            for (let u of a.args) {
              r.push(u);
            }
          } else r.push(a);
          break;
        }
        case "}":
        case "Right":
        case "End":
          break e;
        default:
          throw `Unexpected token type ${i.type}.`;
      }
    }
    let s = Zu(n, e);
    return qi(e, GM(s, r));
  }
  function qA(e) {
    let t = Xo(e);
    switch (t.type) {
      case "EscapedSymbol":
      case "Letter":
      case "Digit":
      case "Symbol":
        return e = mo(e), qi(e, t);
      case "[":
      case "]":
        return e = mo(e), qi(e, kA(t.span, t.val));
      case "{": {
        e = mo(e);
        let r;
        return { state: e, tree: r } = Fh(e, false), e = Zo(e, "}"), qi(e, r);
      }
      case "^":
      case "_":
      case "Primes":
      case "Primes^":
        return kz(e);
      case "Left":
        return Gz(e);
      case "Cmd":
        return Lz(e);
      case "}":
      case "Right":
        throw `Parse Error: unexpected ${t.val}.`;
      case "End":
        throw "Parse Error: unexpected end.";
      default:
        throw `Unexpected token type ${t.type}.`;
    }
  }
  function Lz(e) {
    let t = zA(e), n = Xo(e);
    if (!t) return e = Zo(e, "Cmd"), qi(e, n);
    switch (n.val) {
      case "\\operatorname":
        return wz(e, t);
      case "\\token":
        return Fz(e, t);
      case "\\sqrt":
        return Vz(e, t);
      case "\\frac":
        return Bz(e, t);
      default:
        throw new Error(`Unexpected command ${n.val}.`);
    }
  }
  function wz(e, t) {
    let n = e;
    e = Zo(e, "Cmd");
    let r;
    ({ state: e, tree: r } = Wu(e, t));
    let s = Zu(n, e);
    return qi(e, BA(s, r));
  }
  function Fz(e, t) {
    let n = e;
    e = Zo(e, "Cmd");
    let r;
    ({ state: e, tree: r } = Wu(e, t));
    let s = Zu(n, e);
    return qi(e, GA(s, r));
  }
  function Vz(e, t) {
    let n = e;
    e = Zo(e, "Cmd");
    let r;
    BM(e, "[") && ({ state: e, tree: r } = Hz(e));
    let s;
    ({ state: e, tree: s } = Wu(e, t));
    let i = Zu(n, e);
    return qi(e, LA(i, r, s));
  }
  function Bz(e, t) {
    let n = e;
    e = Zo(e, "Cmd");
    let r;
    ({ state: e, tree: r } = Wu(e, t));
    let s;
    ({ state: e, tree: s } = Wu(e, t));
    let i = Zu(n, e);
    return qi(e, wA(i, r, s));
  }
  function Gz(e) {
    let t = e;
    e = Zo(e, "Left");
    let n = Xo(e);
    e = mo(e);
    let r;
    ({ state: e, tree: r } = Fh(e, false)), e = Zo(e, "Right");
    let s = Xo(e);
    e = mo(e);
    let i = Zu(t, e);
    return qi(e, VA(i, n, s, r));
  }
  function kz(e) {
    let t = e, n, r, s = 0;
    e: for (; !wh(e);) {
      let o = Xo(e);
      switch (o.type) {
        case "^":
          if (e = mo(e), n) throw "Parse Error: double superscript.";
          ({ state: e, tree: n } = Wu(e, kM));
          break;
        case "_":
          if (e = mo(e), r) throw "Parse Error: double subscript.";
          ({ state: e, tree: r } = Wu(e, HA));
          break;
        case "Primes":
          if (e = mo(e), s > 0) throw "Parse Error: double primes.";
          s = o.val.length;
          break;
        case "Primes^":
          if (e = mo(e), s > 0) throw "Parse Error: double primes.";
          if (n) throw "Parse Error: double superscript";
          s = o.val.length - 1, { state: e, tree: n } = Wu(e, kM);
          break;
        default:
          break e;
      }
    }
    let i = Zu(t, e);
    return qi(e, FA(i, n, r, s));
  }
  function Wu(e, t) {
    let n, r = zA(e);
    if (
      r &&
      (t.type !== "primitive" || !(r.type === "macro" && r.expandsToSingleAtom))
    ) {
      throw `Parse Error: can't use ${r.errorName} as argument of ${t.errorName}. Use {}.`;
    }
    return { state: e, tree: n } = qA(e),
      n.type !== "Group" && (n = GM(n.span, [n])),
      qi(e, n);
  }
  function Hz(e) {
    e = Zo(e, "[");
    let t;
    return { state: e, tree: t } = Fh(e, true), e = Zo(e, "]"), qi(e, t);
  }
  function zz() {
    throw rf();
  }
  function $A(e, t) {
    return t && !e._inputSpan && e.setInputSpan(t), e;
  }
  function Mi(e, t = {}) {
    var l;
    let n = typeof e;
    if (n !== "string") {
      throw new Error(
        `Type Error: parse can only be called with strings, got ${
          JSON.stringify(e)
        } of type ${n}`,
      );
    }
    let r = C;
    if (t.disabledFeatures) {
      r = Object.create(r);
      for (let p of t.disabledFeatures) {
        if (!r[p]) {
          throw new Error(
            `Programming Error: ${p} cannot be disabled because it is not a parsenode.`,
          );
        }
        r[p] = zz;
      }
    }
    let s = t.seedPrefix === void 0 ? "" : t.seedPrefix,
      i = 0,
      o = () => {
        let p = `${s}::vc${i}`;
        return i += 1, p;
      },
      a = {
        nodes: r,
        currentIndex: t.index,
        setInput: $A,
        nextSeed: o,
        allowDt: !!t.allowDt,
        allowIndex: !!t.allowIndex,
        writeIntegral: !!t.writeIntegral,
        allowIntervalComprehensions: !!t.allowIntervalComprehensions,
        specializeDoubleInequalities: !!t.specializeDoubleInequalities,
        includeFunctionParametersInRandomSeed:
          (l = t.includeFunctionParametersInRandomSeed) != null ? l : true,
      },
      u = {};
    t.trailingComma !== void 0 && (u.trailingComma = t.trailingComma),
      t.disallowFrac && (u.disallowFrac = true),
      t.disableParentheses && (u.disableParentheses = true);
    function c(p) {
      return p.parseOptions = t, p;
    }
    if (e === "") return c(Xd());
    try {
      let p = UA(e), f = OA(p, u), d = zR(a, f);
      return d.parseOptions = t, d;
    } catch (p) {
      let f;
      return p instanceof C.Error
        ? f = p
        : typeof p == "string"
        ? f = new C.Error(p)
        : f = U(p),
        c(f);
    }
  }
  var qz = [
      "Sum",
      "Product",
      "Integral",
      "List",
      "Derivative",
      "Piecewise",
      "Restriction",
      "Norm",
      "Exponent",
      "PercentOf",
      "FunctionDefinition",
      "UpdateRule",
      "Substitution",
      "ListComprehension",
    ],
    $z = {
      isGeometryEnabled() {
        return false;
      },
      is3dProduct() {
        return false;
      },
      is3dPolicy() {
        return false;
      },
      polygonUnsupportedPreferTriangle() {
        return false;
      },
      areAllScalesLinear() {
        return true;
      },
      assignmentForbidden(e) {
        return true;
      },
      graphingEnabled() {
        return false;
      },
      isValidSlider(e) {
        return false;
      },
      sliderVariables(e) {
        return [];
      },
      ansEnabled() {
        return false;
      },
      disabledFeatures() {
        return qz;
      },
      dimensionVarsEnabled() {
        return false;
      },
      shouldIncludeFunctionParametersInRandomSeed() {
        return true;
      },
      isComplexEnabled() {
        return false;
      },
      isRecursionEnabled() {
        return false;
      },
    },
    YA = {
      ...$z,
      isGeometryEnabled() {
        return true;
      },
      is3dProduct() {
        return true;
      },
      is3dPolicy() {
        return true;
      },
      isComplexEnabled() {
        return false;
      },
    };
  var rd = class e {
    constructor(t, n, r, s, i) {
      this.frame = t;
      this.dynamic = n;
      this.lexical = r;
      this.maxBindingIndex = s;
      this.compiledGlobalCache = i;
    }
    static empty(t) {
      return new e(t, {}, {}, -1, { maxIndex: -1, entries: {} });
    }
    resolve(t) {
      if (this.lexical[t]) return this.lexical[t];
      if (this.dynamic[t]) return this.dynamic[t];
      if (this.compiledGlobalCache.entries[t]) {
        return this.compiledGlobalCache.entries[t];
      }
    }
    getSymbol(t) {
      let n = this.resolve(t);
      if (n) {
        switch (n.type) {
          case "lexical":
          case "dynamic":
          case "free":
            return n.value;
          case "global":
            return n.value;
          case "error":
            throw n.error;
          default:
            throw new Error("Unexpected symbolMap entry type: " + n.type);
        }
      }
    }
    getMaxIndex() {
      return Math.max(this.maxBindingIndex, this.compiledGlobalCache.maxIndex);
    }
    getParseNode(t) {
      let n = this.resolve(t);
      if (n) {
        switch (n.type) {
          case "global":
          case "lexical":
          case "dynamic":
            return n.node;
          case "error":
          case "free":
            return;
          default:
            throw new Error("Unexpected symbolMap entry type: " + n.type);
        }
      }
    }
    addLexicalBinding(t, n, r) {
      this.addScopeEntry(t, { type: "lexical", value: n, node: r });
    }
    addDynamicBinding(t, n, r) {
      this.addScopeEntry(t, { type: "dynamic", value: n, node: r });
    }
    cacheGlobal(t, n, r) {
      this.compiledGlobalCache.entries[t] = {
        type: "global",
        value: n,
        node: r,
      },
        this.compiledGlobalCache.maxIndex = Math.max(
          this.compiledGlobalCache.maxIndex,
          n,
        );
    }
    setFreeVariable(t, n) {
      this.addScopeEntry(t, { type: "free", value: n });
    }
    setErrorIfAccessed(t, n) {
      this.addScopeEntry(t, { type: "error", error: n });
    }
    addScopeEntry(t, n) {
      var o;
      let r = this.lexical, s = this.dynamic, i;
      switch (n.type) {
        case "lexical": {
          r[t] = n,
            this.frame[t] === void 0 &&
              ((o = this.dynamic[t]) == null ? void 0 : o.type) !== "dynamic"
              ? (s[t] = n, i = true)
              : i = false;
          break;
        }
        case "dynamic": {
          s[t] = n,
            r[t] = { type: "lexical", value: n.value, node: n.node },
            i = true;
          break;
        }
        case "error": {
          s[t] = n, i = true;
          break;
        }
        case "free": {
          s[t] = n, i = true;
          break;
        }
        default:
          throw new Error("Unexpected symbolMap entry type: " + n.type);
      }
      n.type !== "error" &&
      (this.maxBindingIndex = Math.max(this.maxBindingIndex, n.value)),
        i && (this.compiledGlobalCache = { maxIndex: -1, entries: {} });
    }
    isLocal(t) {
      let n = this.resolve(t);
      return (n == null ? void 0 : n.type) === "lexical" ||
        (n == null ? void 0 : n.type) === "dynamic";
    }
    isGlobal(t) {
      return this.frame[t] !== void 0 && !this.isLocal(t);
    }
    isError(t) {
      var r;
      let n = this.resolve(t);
      return n
        ? n.type === "error"
        : (r = this.frame[t]) == null
        ? void 0
        : r.isError;
    }
    isDefined(t) {
      return this.isLocal(t) || this.isGlobal(t);
    }
    getVisibleGlobalDefinition(t) {
      let n = this.resolve(t);
      if (!n) return XA(this.frame[t]);
      switch (n.type) {
        case "lexical":
        case "dynamic":
        case "free":
          return;
        case "global":
          return XA(this.frame[t]);
        case "error":
          throw n.error;
        default:
          throw new Error("Unexpected symbolMap entry type: " + n.type);
      }
    }
    childScope() {
      return new e(
        this.frame,
        Tn(this.dynamic),
        Tn(this.lexical),
        this.maxBindingIndex,
        this.compiledGlobalCache,
      );
    }
    childScopeWithChildGlobalCache() {
      return new e(
        this.frame,
        Tn(this.dynamic),
        Tn(this.lexical),
        this.maxBindingIndex,
        {
          maxIndex: this.compiledGlobalCache.maxIndex,
          entries: Tn(this.compiledGlobalCache.entries),
        },
      );
    }
    newLexicalScope() {
      return new e(
        this.frame,
        Tn(this.dynamic),
        {},
        this.maxBindingIndex,
        this.compiledGlobalCache,
      );
    }
  };
  function XA(e) {
    if (e != null && e.isError) throw e;
    return e;
  }
  function su(e, t, n, r) {
    return ju({
      chunk: e,
      argMap: [t],
      start: n,
      unpatchedHeaderMap: new Map(),
      processedHeaders: new Set(),
    }, r);
  }
  function Yz(e, t) {
    let { chunk: n } = e, r = n.getInstruction(t), s = [];
    for (let i of r.recursionGroup) {
      let o = e.unpatchedHeaderMap.get(i);
      if (o === void 0) {
        throw new Error(
          "Programming Error: `substitute` did not include all headers in a recursion group.",
        );
      }
      s.push(o);
    }
    for (let i of r.recursionGroup) e.unpatchedHeaderMap.delete(i);
    for (let i of s) n.getInstruction(i).recursionGroup = s;
  }
  function ju(e, t) {
    let { chunk: n, argMap: r, start: s } = e;
    if (t < s) return t;
    let i = r[t - s];
    if (i !== void 0) return i;
    let o = Xz(e, t);
    e.argMap[t - s] = o;
    let a = n.getInstruction(t);
    if (a.type === 4) {
      let u = o;
      e.unpatchedHeaderMap.set(t, u), e.processedHeaders.add(t);
      for (let c of a.recursionGroup) e.processedHeaders.has(c) || ju(e, c);
      return ju(e, a.endIndex), u;
    }
    if (es(a)) {
      switch (a.type) {
        case 23:
        case 21:
        case 50:
          break;
        case 19: {
          let c = a.args.length - 2;
          for (let l = 0; l < c; l++) ju(e, t + 1 + l);
          break;
        }
        case 53: {
          let l = n.getInstruction(a.args[0]).signature.argTypes.length;
          for (let p = 0; p < l; p++) ju(e, t + 1 + p);
          break;
        }
        default:
          let u = a;
          throw new Error(`Programming Error. Unexpected OpCode: ${u.type}`);
      }
    } else if (Gg(a)) {
      let u = a.args.length - 1;
      for (let c = 0; c < u; c++) ju(e, t + 1 + c);
    }
    return o;
  }
  function Xz(e, t) {
    let { chunk: n, start: r } = e, s = n.getInstruction(t);
    if (ds(s)) {
      let a = s.args[0];
      for (let u = a; u <= t; u++) {
        let c = n.getInstruction(u);
        if (!ge(c)) { for (let l of c.args) l < a && ju(e, l); }
      }
    }
    if (s.type === 4) {
      return n.FunctionHeader(
        s.symbol,
        s.valueType,
        s.signature,
        s.parameterSymbols,
      );
    }
    if (ge(s)) return po(n, s);
    let i = [];
    for (let a of s.args) i.push(ju(e, a));
    let o = e.argMap[t - r];
    if (o !== void 0) return o;
    if (s.type === 55 && !zg(n, t)) {
      let a = s.args[0];
      e.unpatchedHeaderMap.has(a) && Yz(e, a);
    }
    return _n(n, s, i);
  }
  function Bh(e, t, n, r) {
    let s = fl(e, t), i = e.Constant(0);
    if (t < n) return i;
    let o = e.Constant(1),
      a = e.Constant(NaN),
      u = Vu(e, n),
      c = nO(e, s),
      l = e.derivativeMaps.getMapEntry(e, r, n),
      { map: p, maxValidReference: f } = l;
    for (let h = 0; h < p.length; h++) {
      let x = p[h];
      x !== void 0 && x > f && (p[h] = void 0);
    }
    let d = [], y = false;
    for (let h = 0; h < n; h++) d[h] = h, p[h] = i;
    let g = Vr(e, s);
    return Gh(
      {
        chunk: e,
        derivativeVarIndex: n,
        forwardSeed: r,
        forwardMask: u,
        backwardMask: c,
        referenced: g,
        valueMap: d,
        derivativeMap: p,
        mustCopy: y,
        ZERO: i,
        ONE: o,
        NAN: a,
      },
      n,
      s,
    ),
      l.maxValidReference = e.instructionsLength() - 1,
      p[s];
  }
  function Gh(e, t, n) {
    let { chunk: r, valueMap: s, derivativeMap: i, backwardMask: o } = e;
    for (let a = t; a <= n; a++) {
      let u = i[a];
      if (u !== void 0) {
        if (r.getInstruction(u).type === 0) i[a] = void 0;
        else {
          s[a] = Vh(e, a);
          continue;
        }
      }
      if (!o[a]) {
        s[a] = Vh(e, a);
        continue;
      }
      let c = r.getInstruction(a);
      if (es(c) && c.endIndex !== -1) {
        switch (c.type) {
          case 21: {
            a = Zz(e, a);
            continue;
          }
          case 19:
          case 23: {
            a = Jz(e, a);
            continue;
          }
          case 53: {
            a = Kz(e, a);
            continue;
          }
        }
      }
      s[a] = Vh(e, a), i[a] = eU(e, a);
    }
    return n;
  }
  function Zz(e, t) {
    let { chunk: n, forwardMask: r, valueMap: s, derivativeMap: i, ZERO: o } =
        e,
      a = n.getInstruction(t),
      u = a.endIndex,
      c = n.getInstruction(u),
      l = o;
    if (r[a.args[1]]) {
      let p = s[a.args[1]];
      l = n.Add([l, n.Multiply([i[a.args[1]], su(n, p, t, c.args[1])])]);
    }
    if (r[a.args[0]]) {
      let p = s[a.args[0]];
      l = n.Subtract([l, n.Multiply([i[a.args[0]], su(n, p, t, c.args[1])])]);
    }
    if (Wz(n, t, r)) {
      let p = s.slice();
      p[t] = _n(n, a, [p[a.args[0]], p[a.args[1]]]),
        i[t] = o,
        Gh({ ...e, valueMap: p, mustCopy: true }, t + 1, u - 1);
      let f = _n(n, c, [p[c.args[0]], i[c.args[1]]]);
      i[u] = f, l = n.Add([l, _n(n, n.getInstruction(u + 1), [f])]);
    } else for (let p = t; p <= u; p++) i[p] = o;
    if (jz(n, t, s)) {
      let p = { ...e, mustCopy: true };
      for (let f = t; f <= u + 1; f++) s[f] = Vh(p, f);
    } else for (let p = t; p <= u + 1; p++) s[p] = p;
    return i[u + 1] = l, u + c.args.length - 1;
  }
  function Wz(e, t, n) {
    let r = e.getInstruction(t), s = e.getInstruction(r.endIndex);
    if (s.args[1] < t + 1) return n[s.args[1]];
    for (let i = t + 1; i <= s.args[1]; i++) {
      let o = e.getInstruction(i);
      if (!ge(o)) { for (let a of o.args) if (a < t && n[a]) return true; }
    }
    return false;
  }
  function jz(e, t, n) {
    let r = e.getInstruction(t);
    for (let s = t; s <= r.endIndex; s++) {
      let i = e.getInstruction(s);
      if (!ge(i)) { for (let o of i.args) if (n[o] !== o) return true; }
    }
    return false;
  }
  function Jz(e, t) {
    let { chunk: n, derivativeMap: r, valueMap: s, ZERO: i } = e,
      o = n.getInstruction(t),
      a = o.endIndex,
      u = n.getInstruction(a),
      c;
    if (o.type === 23) s[t] = _n(n, o, [s[o.args[0]]]), r[t] = i, c = t + 1;
    else {
      let p = [];
      p.push(s[o.args[0]], s[o.args[1]]);
      for (let f = 2; f < o.args.length; f++) {
        p.push(s[o.args[f]], r[o.args[f]]);
      }
      s[t] = _n(n, o, p), r[t] = i;
      for (let f = 2; f < o.args.length; f++) {
        s[t + f - 1] = _n(n, n.getInstruction(t + f - 1), [s[t]]),
          r[t + f - 1] = _n(n, n.getInstruction(t + f - 1), [s[t]]);
      }
      c = t + o.args.length - 1;
    }
    Gh({ ...e, mustCopy: true }, c, a - 1);
    let l = [];
    l.push(s[u.args[0]]);
    for (let p = 1; p < u.args.length; p++) l.push(s[u.args[p]], r[u.args[p]]);
    s[a] = _n(n, u, l), r[a] = i;
    for (let p = 1; p < u.args.length; p++) {
      s[a + p] = _n(n, n.getInstruction(a + p), [s[a]]),
        r[a + p] = _n(n, n.getInstruction(a + p), [s[a]]);
    }
    return a + u.args.length - 1;
  }
  function Vh(e, t) {
    let { chunk: n, valueMap: r, mustCopy: s, referenced: i } = e;
    if (!i[t]) return t;
    let o = n.getInstruction(t);
    if (ge(o)) return s ? po(n, o) : t;
    {
      let a = [], u = false;
      for (let c of o.args) a.push(r[c]), r[c] !== c && (u = true);
      return u || s ? _n(n, o, a) : t;
    }
  }
  function Qz(e, t) {
    let { chunk: n, derivativeMap: r } = e,
      s = n.getInstruction(t),
      i = [],
      o = s.recursionGroup;
    for (let a of o) {
      let u = n.getInstruction(a), c = { argTypes: [] };
      for (let p of u.signature.argTypes) c.argTypes.push(p, p);
      let l = r[a];
      l ||
      (l = n.FunctionHeader(
        u.symbol + `_\u2202${e.derivativeVarIndex}`,
        u.valueType,
        c,
        u.parameterSymbols,
      ),
        i.push(l)), e.derivativeMap[a] = l;
    }
    for (let a of i) {
      let u = n.getInstruction(a);
      u.recursionGroup = i;
    }
    return e.derivativeMap[t];
  }
  function Kz(e, t) {
    let { chunk: n, valueMap: r, derivativeMap: s } = e,
      o = n.getInstruction(t).args[0],
      a = n.getInstruction(o),
      u = a.endIndex,
      l = n.getInstruction(u).args[1],
      p = s[o],
      f = n.BeginFunction([p]);
    s[t] = f;
    let d = a.signature.argTypes, y = [];
    for (let T = 0; T < d.length; T++) {
      let b = d[T], M = t + T + 1;
      y.push(M);
      let P = n.BlockVar(b, [f]), D = n.BlockVar(b, [f]);
      r[M] = P, s[M] = D;
    }
    let g = t + d.length + 1, m = u - 1, h = ol(n, y, g, m), x = r.slice();
    return x[o] = o,
      Gh({ ...e, valueMap: x, mustCopy: true, forwardMask: h }, g, m),
      n.EndFunction([f, s[l]]),
      u;
  }
  function eU(e, t) {
    let {
        chunk: n,
        derivativeVarIndex: r,
        forwardSeed: s,
        forwardMask: i,
        valueMap: o,
        derivativeMap: a,
        ZERO: u,
        ONE: c,
        NAN: l,
      } = e,
      p = n.getInstruction(t);
    if (t === r) {
      let d;
      switch (s) {
        case "real":
          d = c;
          break;
        case "complexOne":
          d = n.NativeFunction("complex", [c, u]);
          break;
        case "complexI":
          d = n.NativeFunction("complex", [u, c]);
          break;
      }
      if (j(p.valueType)) {
        let y = ur(n, t), g = n.BeginBroadcast([y]), m = n.EndBroadcast([g, d]);
        return n.BroadcastResult(p.valueType, [m]);
      } else return d;
    }
    if (
      es(p) || ds(p) || p.type === 47 || p.type === 48 || p.type === 25 ||
      p.type === 27 || p.type === 26 || p.type === 29 || p.type === 28 ||
      p.type === 32 || p.type === 31 || p.type === 42 || p.type === 44 ||
      p.type === 49 || p.valueType === SeedType
    ) return u;
    if (p.type === 4) return Qz(e, t);
    if (!i[t] || ge(p)) {
      return p.valueType !== Number
        ? nU(n, [o[t], u])
        : p.type !== 1 || isFinite(V(p.value))
        ? u
        : l;
    }
    if (p.type === 38 || p.type === 15) {
      let d = [];
      for (let y of p.args) d.push(a[y]);
      return _n(n, p, d);
    }
    if (p.type === 33) {
      return _n(n, p, [o[p.args[0]], a[p.args[1]], a[p.args[2]]]);
    }
    if (p.type === 55) {
      let y = [a[p.args[0]]];
      for (let g of p.args.slice(1)) {
        y.push(o[g]);
        let m = a[g];
        if (m === u) {
          let h = n.getInstruction(g).valueType;
          NS(h) && (m = n.ZeroOfType(h));
        }
        y.push(m);
      }
      return n.FunctionCall(y);
    }
    let f = u;
    for (let d = 0; d < p.args.length; d++) {
      if (!i[p.args[d]]) continue;
      let y = a[p.args[d]];
      if (y === u) continue;
      let g = tU(e, o[t], d, y);
      g !== u && (f = f === u ? g : rU(n, [g, f]));
    }
    return f;
  }
  function tU(e, t, n, r) {
    let { chunk: s, ZERO: i, ONE: o, NAN: a } = e, u = s.getInstruction(t);
    switch (u.type) {
      case 8:
        return r;
      case 9:
        switch (n) {
          case 0:
            return r;
          default:
            return s.Negative([r]);
        }
      case 10:
        switch (n) {
          case 0:
            return s.Multiply([r, u.args[1]]);
          default:
            return s.Multiply([u.args[0], r]);
        }
      case 11:
        switch (n) {
          case 0:
            return s.Divide([r, u.args[1]]);
          default:
            return s.Multiply([
              u.args[0],
              s.Divide([s.Negative([r]), s.Multiply([u.args[1], u.args[1]])]),
            ]);
        }
      case 14:
        return s.Negative([r]);
      case 12:
      case 13:
        switch (n) {
          case 0:
            return s.Multiply([
              s.Multiply([
                u.args[1],
                s.Exponent([u.args[0], s.Subtract([u.args[1], o])]),
              ]),
              r,
            ]);
          default:
            return s.Multiply([
              s.Piecewise([
                s.Equal([u.args[0], i]),
                s.Piecewise([s.GreaterEqual([u.args[1], i]), i, a]),
                s.Multiply([s.NativeFunction("ln", [u.args[0]]), t]),
              ]),
              r,
            ]);
        }
      case 37:
        return sU(s, t, WA[u.symbol][n], r);
      case 39:
      case 40:
      case 41:
        switch (n) {
          case 0:
            return _n(s, u, [r, u.args[1]]);
          default:
            return i;
        }
      case 16:
        return _n(s, u, [r]);
      default: {
        let c = u;
        throw new Error(`Unimplemented derivative for opcode ${c.type}`);
      }
    }
  }
  function nU(e, t) {
    switch (e.getInstruction(t[0]).valueType) {
      case Segment:
        return e.NativeFunction("scaleTangentSegment", t);
      case Line:
        return e.NativeFunction("scaleTangentLine", t);
      case Ray:
        return e.NativeFunction("scaleTangentRay", t);
      case Circle:
        return e.NativeFunction("scaleTangentCircle", t);
      case Arc:
        return e.NativeFunction("scaleTangentArc", t);
      case AngleMarker:
        return e.NativeFunction("scaleTangentUndirectedAngleMarker", t);
      case DirectedAngleMarker:
        return e.NativeFunction("scaleTangentDirectedAngleMarker", t);
      case Polygon:
        return e.NativeFunction("scaleTangentPolygon", t);
      case Transformation:
        return e.NativeFunction("scaleTangentTransformation", t);
      default:
        return e.Multiply(t);
    }
  }
  function rU(e, t) {
    switch (e.getInstruction(t[0]).valueType) {
      case Segment:
        return e.NativeFunction("addTangentSegment", t);
      case Segment3D:
        return e.NativeFunction("addTangentSegmentThreeD", t);
      case Line:
        return e.NativeFunction("addTangentLine", t);
      case Ray:
        return e.NativeFunction("addTangentRay", t);
      case Vector:
        return e.NativeFunction("addTangentVector", t);
      case Circle:
        return e.NativeFunction("addTangentCircle", t);
      case Arc:
        return e.NativeFunction("addTangentArc", t);
      case AngleMarker:
        return e.NativeFunction("addTangentUndirectedAngleMarker", t);
      case DirectedAngleMarker:
        return e.NativeFunction("addTangentDirectedAngleMarker", t);
      case Polygon:
        return e.NativeFunction("addTangentPolygon", t);
      case Transformation:
        return e.NativeFunction("addTangentTransformation", t);
      default:
        return e.Add(t);
    }
  }
  function sU(e, t, n, r) {
    let s = rd.empty(tt), o = e.getInstruction(t).args;
    for (let a = 0; a < o.length; a++) {
      let u = iU[a];
      s.addLexicalBinding(u, o[a]);
    }
    return s.addLexicalBinding("x_1", r),
      s.addLexicalBinding("q", t),
      Fe(HM(YA, e, s, im.root, void 0, void 0), n);
  }
  var iU = ["x", "y", "z", "u"],
    ZA = {
      exp: ["q*x_1"],
      complexExp: ["q*x_1"],
      ln: ["\\{x >= 0: x_1/x \\}"],
      complexLn: ["x_1/x"],
      log: ["\\{x >= 0: x_1/(x*\\ln(10)) \\}"],
      complexLog: ["x_1/(x*\\ln(10))"],
      sqrt: ["x_1/(2*q)"],
      complexSqrt: ["x_1/(2*q)"],
      complexPow: ["y*\\complexPow(x,y-1)*x_1", "q*\\complexLn(x)*x_1"],
      rtxsqpone: ["x*x_1/q"],
      rtxsqmone: ["x*x_1/q"],
      sin: ["\\cos(x)*x_1"],
      complexSin: ["\\cos(x)*x_1"],
      cos: ["-\\sin(x)*x_1"],
      complexCos: ["-\\sin(x)*x_1"],
      tan: ["(1+q^2)*x_1"],
      complexTan: ["(s*s)*x_1 \\with s=\\sec(x)"],
      arcsin: ["x_1/\\sqrt{1 - x^2}"],
      complexArcsin: ["x_1/(\\complexSqrt(1+x)\\complexSqrt(1-x))"],
      arccos: ["-x_1/\\sqrt{1 - x^2}"],
      complexArccos: ["-x_1/(\\complexSqrt(1+x)\\complexSqrt(1-x))"],
      sinh: ["\\cosh(x)*x_1"],
      complexSinh: ["\\cosh(x)*x_1"],
      cosh: ["\\sinh(x)*x_1"],
      complexCosh: ["\\sinh(x)*x_1"],
      tanh: ["(\\sech(x))^2*x_1"],
      complexTanh: ["(s*s)*x_1 \\with s=\\sech(x)"],
      arcsinh: ["x_1/\\rtxsqpone(x)"],
      complexArcsinh: [
        "x_1/(\\complexSqrt(1+\\complex(0,1)x)\\complexSqrt(1-\\complex(0,1)x))",
      ],
      arccosh: ["\\{ x > 0: x_1/\\rtxsqmone(x) \\}"],
      complexArccosh: ["x_1/(\\complexSqrt(x+1)\\complexSqrt(x-1))"],
      arctanh: ["\\{ \\abs(x) < 1: x_1/(1 - x^2) \\}"],
      complexArctanh: ["x_1/((1+x)(1-x))"],
      csc: ["-\\cot(x)*q*x_1"],
      complexCsc: ["-\\cot(x)*q*x_1"],
      sec: ["\\tan(x)*q*x_1"],
      complexSec: ["\\tan(x)*q*x_1"],
      cot: ["-(1+q^2)*x_1"],
      complexCot: ["-(c*c)*x_1 \\with c=\\csc(x)"],
      arccsc: ["-x_1/(\\abs(x)*\\rtxsqmone(x))"],
      complexArccsc: ["-x_1/((x\\complexSqrt(1-1/x))(x\\complexSqrt(1+1/x)))"],
      arcsec: ["x_1/(\\abs(x)*\\rtxsqmone(x))"],
      complexArcsec: ["x_1/((x\\complexSqrt(1-1/x))(x\\complexSqrt(1+1/x)))"],
      arccot: ["-x_1/(1+x^2)"],
      complexArccot: ["-x_1/((x+\\complex(0,1))(x-\\complex(0,1)))"],
      csch: ["-\\coth(x)*q*x_1"],
      complexCsch: ["-\\coth(x)*q*x_1"],
      sech: ["-\\tanh(x)*q*x_1"],
      complexSech: ["-\\tanh(x)*q*x_1"],
      coth: ["-(\\csch(x))^2*x_1"],
      complexCoth: ["-(c*c)*x_1 \\with c=\\csch(x)"],
      arccsch: ["-x_1/(\\abs(x)*\\rtxsqpone(x))"],
      complexArccsch: [
        "-x_1/((x\\complexSqrt(1+\\complex(0,1)/x))(x\\complexSqrt(1-\\complex(0,1)/x)))",
      ],
      arcsech: ["\\{ x >= 0: -x_1/(x*\\sqrt{1 - x^2}) \\}"],
      complexArcsech: ["-x_1/((x\\complexSqrt((1-x)/(1+x)))(1+x))"],
      arccoth: ["\\{ \\abs(x) > 1 : x_1/(1 - x^2) \\}"],
      complexArccoth: ["x_1/((1+x)(1-x))"],
      factorial: ["q*\\polyGamma(0, x + 1)*x_1"],
      floor: ["\\{ q=x: 0/0, 0*x_1 \\}"],
      complexFloor: [
        "\\{ \\real(d) + \\imag(d) = 0: 0/0, \\imag(d) - \\real(d) = 1: 0/0, 0*x_1 \\} \\with d = x - q",
      ],
      ceil: ["\\{ q=x: 0/0, 0*x_1 \\}"],
      complexCeil: [
        "\\{ \\real(d) + \\imag(d) = 0: 0/0, \\imag(d) - \\real(d) = -1: 0/0, 0*x_1 \\} \\with d = x - q",
      ],
      round: ["\\{ \\abs(\\mod(x, 1) - 0.5) > 0: 0*x_1 \\}"],
      complexRound: [
        "\\{ \\real(q) - \\real(x) = 0.5: 0/0, \\imag(q) - \\imag(x) = 0.5: 0/0, 0*x_1 \\}",
      ],
      abs: ["\\{ x=0: 0/0, \\sign(x)*x_1 \\}"],
      sign: ["\\{ x=0: 0/0, 0*x_1 \\}"],
      distance: [
        "-((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y)/q",
        "((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y)/q",
      ],
      distanceThreeD: [
        "-((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y+(y.z-x.z)*x_1.z)/q",
        "((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y+(y.z-x.z)*x_1.z)/q",
      ],
      segmentThreeD: [
        "\\segmentThreeD(x_1,(0,0,0))",
        "\\segmentThreeD((0,0,0),x_1)",
      ],
      vectorThreeD: [
        "\\vectorThreeD(x_1,(0,0,0))",
        "\\vectorThreeD((0,0,0),x_1)",
      ],
      triangle: [
        "\\triangle(x_1,(0,0,0),(0,0,0))",
        "\\triangle((0,0,0),x_1,(0,0,0))",
        "\\triangle((0,0,0),(0,0,0),x_1)",
      ],
      sphere: ["\\sphere(x_1,0)", "\\sphere((0,0,0),x_1)"],
      pointDet: ["\\pointDet(x_1,y)", "\\pointDet(x,x_1)"],
      pointDot: ["\\pointDot(x_1,y)", "\\pointDot(x,x_1)"],
      pointPerp: ["\\pointPerp(x_1)"],
      complexMultiplyPoints: [
        "\\complexMultiplyPoints(x_1,y)",
        "\\complexMultiplyPoints(x,x_1)",
      ],
      segment: ["\\segment(x_1,(0,0))", "\\segment((0,0),x_1)"],
      line: ["\\line(x_1,(0,0))", "\\line((0,0),x_1)"],
      ray: ["\\ray(x_1,(0,0))", "\\ray((0,0),x_1)"],
      vector: ["\\vector(x_1, (0,0))", "\\vector((0,0), x_1)"],
      mathVector: ["\\mathVector(x_1,(0,0))", "\\mathVector((0,0),x_1)"],
      mathVectorThreeD: [
        "\\mathVectorThreeD(x_1,(0,0,0))",
        "\\mathVectorThreeD((0,0,0),x_1)",
      ],
      rawTransform: ["\\rawTransform(x_1,(0,0))", "\\rawTransform((0,0),x_1)"],
      rawTransformConj: [
        "\\rawTransformConj(x_1,(0,0))",
        "\\rawTransformConj((0,0),x_1)",
      ],
      transformWithoutTranslation: ["\\transformWithoutTranslation(x_1)"],
      transformScaleFactor: ["\\transformScaleFactor(x_1)"],
      vectorDisplacementAsPoint: ["\\vectorDisplacementAsPoint(x_1)"],
      vectorThreeDDisplacementAsPoint: [
        "\\vectorThreeDDisplacementAsPoint(x_1)",
      ],
      basePointFromVector: ["\\basePointFromVector(x_1)"],
      basePointFromVectorThreeD: ["\\basePointFromVectorThreeD(x_1)"],
      circle: ["\\circle(x_1,0)", "\\circle((0,0),x_1)"],
      arc: [
        "\\arc(x_1,(0,0),(0,0))",
        "\\arc((0,0),x_1,(0,0))",
        "\\arc((0,0),(0,0),x_1)",
      ],
      arcCenter: [
        "(\\pointDot(q-p1,p1_1)\\pointPerp(v_2)+\\pointDot(q-p2,p2_1)\\pointPerp(v_3)+\\pointDot(q-p3,p3_1)\\pointPerp(v_1))/\\pointDet(v_2,v_1) \\with v_1=p2-p1,v_2=p3-p2,v_3=p1-p3"
          .replace(/p1_1/g, "\\arcFirstPoint(x_1)").replace(
            /p2_1/g,
            "\\arcMiddlePoint(x_1)",
          ).replace(/p3_1/g, "\\arcThirdPoint(x_1)").replace(
            /p1/g,
            "\\arcFirstPoint(x)",
          ).replace(/p2/g, "\\arcMiddlePoint(x)").replace(
            /p3/g,
            "\\arcThirdPoint(x)",
          ),
      ],
      arcFirstPoint: ["\\arcFirstPoint(x_1)"],
      arcMiddlePoint: ["\\arcMiddlePoint(x_1)"],
      arcThirdPoint: ["\\arcThirdPoint(x_1)"],
      arcOmega: [
        "2 * (X_1*Y/(Y*Y+X*X) - Y_1*X/(Y*Y+X*X))".replace(
          /X_1/g,
          "((v1x * v2y_1 + v1x_1 * v2y) - (v2x_1 * v1y + v2x * v1y_1))",
        ).replace(
          /Y_1/g,
          "((v1x * v2x_1 + v1x_1 * v2x) + (v1y_1 * v2y + v1y * v2y_1))",
        ).replace(/X/g, "(v1x * v2y - v2x * v1y)").replace(
          /Y/g,
          "(v1x * v2x + v1y * v2y)",
        ).replace(/v1x_1/g, "(\\arcMiddlePoint(x_1) - \\arcFirstPoint(x_1)).x")
          .replace(/v2x_1/g, "(\\arcThirdPoint(x_1) - \\arcMiddlePoint(x_1)).x")
          .replace(/v1y_1/g, "(\\arcMiddlePoint(x_1) - \\arcFirstPoint(x_1)).y")
          .replace(/v2y_1/g, "(\\arcThirdPoint(x_1) - \\arcMiddlePoint(x_1)).y")
          .replace(/v1x/g, "(\\arcMiddlePoint(x) - \\arcFirstPoint(x)).x")
          .replace(/v2x/g, "(\\arcThirdPoint(x) - \\arcMiddlePoint(x)).x")
          .replace(/v1y/g, "(\\arcMiddlePoint(x) - \\arcFirstPoint(x)).y")
          .replace(/v2y/g, "(\\arcThirdPoint(x) - \\arcMiddlePoint(x)).y"),
      ],
      center: ["\\center(x_1)"],
      radius: ["\\radius(x_1)"],
      undirectedAngleMarker: ["\\undirectedAngleMarker(x_1)"],
      directedAngleMarker: [
        "\\directedAngleMarker(x_1,0,0,0)",
        "\\directedAngleMarker((0,0),x_1,0,0)",
        "\\directedAngleMarker((0,0),0,x_1,0)",
        "\\directedAngleMarker((0,0),0,0,x_1)",
      ],
      directedCoterminalAngle: [
        "\\directedAngleMarker((0,0),0,\\directedAngleMarkerRawDelta(x_1),0)",
      ],
      undirectedCoterminalAngle: [
        "\\undirectedAngleMarker(\\directedAngleMarker((0,0),0,\\undirectedAngleMarkerRawDelta(x_1),0))",
      ],
      supplement: [
        "\\directedAngleMarker((0,0),0,-\\directedAngleMarkerRawDelta(x_1),0)",
      ],
      directedAngleMarkerMultiplier: ["\\directedAngleMarkerMultiplier(x_1)"],
      undirectedAngleMarkerMultiplier: [
        "\\undirectedAngleMarkerMultiplier(x_1)",
      ],
      directedAngleMarkerRawDelta: ["\\directedAngleMarkerRawDelta(x_1)"],
      undirectedAngleMarkerRawDelta: ["\\undirectedAngleMarkerRawDelta(x_1)"],
      polygonInteriorUndirectedAngles: [
        "\\polygonInteriorUndirectedAngles(x_1)",
      ],
      polygonInteriorDirectedAngles: ["\\polygonInteriorDirectedAngles(x_1)"],
      lineFromSegment: ["\\lineFromSegment(x_1)"],
      lineFromRay: ["\\lineFromRay(x_1)"],
      segmentGlider: [
        "\\segmentGlider(x_1,y)",
        "\\{0<y<1:(\\segmentGlider(x,1)-\\segmentGlider(x,0))*x_1,(0,0)\\}",
      ],
      segmentThreeDGlider: [
        "\\segmentThreeDGlider(x_1,y)",
        "\\{0<y<1:(\\segmentThreeDGlider(x,1)-\\segmentThreeDGlider(x,0))*x_1,(0,0,0)\\}",
      ],
      rayGlider: [
        "\\rayGlider(x_1,y)",
        "\\{0<y:(\\rayGlider(x,1)-\\rayGlider(x,0))*x_1,(0,0)\\}",
      ],
      lineGlider: [
        "\\lineGlider(x_1,y)",
        "(\\lineGlider(x,1)-\\lineGlider(x,0))*x_1",
      ],
      circleGlider: [
        "\\circleGlider(x_1,y)",
        "\\{0<y<1:2*\\pi*\\pointPerp(q-\\center(x))*x_1,(0,0)\\}",
      ],
      arcGlider: ["(0/0,0/0)", "(0/0,0/0)"],
      polygonEdgeByParameter: [
        "\\polygonEdgeByParameter(x_1,y)",
        "\\{\\floor(y)=y:\\segment((0/0,0/0),(0/0,0/0)),\\segment((0,0),(0,0))\\}",
      ],
      polygonGlider: [
        "\\polygonGlider(x_1,y)",
        "\\{y<0:(0,0),y>x.\\vertices.\\count:(0,0),\\floor(y)=y:(0/0,0/0),(x_1*(\\segmentGlider(s,1)-\\segmentGlider(s,0))\\with s=\\polygonEdgeByParameter(x,y))\\}",
      ],
      chooseNonIncidentPoint: ["(0/0,0/0)"],
      circleCircleIntersection: [
        "(\\radius(x)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(x))))/\\pointDot(\\pointPerp(q-\\center(y)),q-\\center(x))*\\pointPerp(q-\\center(y))",
        "(\\radius(y)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(y))))/\\pointDot(\\pointPerp(q-\\center(x)),q-\\center(y))*\\pointPerp(q-\\center(x))",
      ],
      circleArcIntersection: ["(0/0,0/0)"],
      circleLineIntersection: [
        "(\\radius(x)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(x))))/\\pointDot((\\lineGlider(y,1)-\\lineGlider(y,0)),q-\\center(x))*(\\lineGlider(y,1)-\\lineGlider(y,0))",
        "(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(y,1))+\\pointDet(\\lineGlider(y,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\pointPerp(q-\\center(x)),\\lineGlider(y,1)-\\lineGlider(y,0)))*(\\pointPerp(q-\\center(x)))",
      ],
      arcCircleIntersection: ["(0/0,0/0)"],
      arcArcIntersection: ["(0/0,0/0)"],
      arcLineIntersection: ["(0/0,0/0)"],
      lineCircleIntersection: [
        "(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(x,1))+\\pointDet(\\lineGlider(x,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\pointPerp(q-\\center(y)),\\lineGlider(x,1)-\\lineGlider(x,0)))*(\\pointPerp(q-\\center(y)))",
        "(\\radius(y)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(y))))/\\pointDot((\\lineGlider(x,1)-\\lineGlider(x,0)),q-\\center(y))*(\\lineGlider(x,1)-\\lineGlider(x,0))",
      ],
      lineArcIntersection: ["(0/0,0/0)"],
      lineLineIntersection: [
        "(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(x,1))+\\pointDet(\\lineGlider(x,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\lineGlider(y,1)-\\lineGlider(y,0),\\lineGlider(x,1)-\\lineGlider(x,0)))*(\\lineGlider(y,1)-\\lineGlider(y,0))",
        "(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(y,1))+\\pointDet(\\lineGlider(y,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\lineGlider(x,1)-\\lineGlider(x,0),\\lineGlider(y,1)-\\lineGlider(y,0)))*(\\lineGlider(x,1)-\\lineGlider(x,0))",
      ],
      parallel: [
        "\\parallel(x_1,(0,0))",
        "\\parallel(\\line((0,0),(0,0)),x_1)",
      ],
      perpendicular: [
        "\\perpendicular(x_1,(0,0))",
        "\\perpendicular(\\line((0,0),(0,0)),x_1)",
      ],
      angleVertex: ["\\angleVertex(x_1)"],
      angleStart: ["\\angleStart(x_1)"],
      directedAngleVertex: ["\\directedAngleVertex(x_1)"],
      directedAngleStart: ["\\directedAngleStart(x_1)"],
      anglebisector: [
        "\\ray(\\angleVertex(x_1),\\angleVertex(x_1) + \\pointPerp( \\rayGlider(q,1) - \\angleVertex(x) ) * (s_1 + d_1 / 2)) \\with s_1 = \\angleStart(x_1), d_1 = \\undirectedAngleMarkerRawDelta(x_1)",
      ],
      directedanglebisector: [
        "\\ray(\\directedAngleVertex(x_1),\\directedAngleVertex(x_1) + \\pointPerp( \\rayGlider(q,1) - \\directedAngleVertex(x) ) * (s_1 + d_1 / 2)) \\with s_1 = \\directedAngleStart(x_1), d_1 = \\directedAngleMarkerRawDelta(x_1)",
      ],
      scaleTangentTransformation: [
        "\\scaleTangentTransformation(x_1, y)",
        "\\scaleTangentTransformation(x, x_1)",
      ],
      scaleTangentPolygon: [
        "\\scaleTangentPolygon(x_1, y)",
        "\\scaleTangentPolygon(x, x_1)",
      ],
      scaleTangentSegment: [
        "\\scaleTangentSegment(x_1, y)",
        "\\scaleTangentSegment(x, x_1)",
      ],
      scaleTangentLine: [
        "\\scaleTangentLine(x_1, y)",
        "\\scaleTangentLine(x, x_1)",
      ],
      scaleTangentRay: [
        "\\scaleTangentRay(x_1, y)",
        "\\scaleTangentRay(x, x_1)",
      ],
      scaleTangentCircle: [
        "\\scaleTangentCircle(x_1, y)",
        "\\scaleTangentCircle(x, x_1)",
      ],
      scaleTangentArc: [
        "\\scaleTangentArc(x_1, y)",
        "\\scaleTangentArc(x, x_1)",
      ],
      scaleTangentDirectedAngleMarker: [
        "\\scaleTangentDirectedAngleMarker(x_1, y)",
        "\\scaleTangentDirectedAngleMarker(x, x_1)",
      ],
      scaleTangentUndirectedAngleMarker: [
        "\\scaleTangentUndirectedAngleMarker(x_1, y)",
        "\\scaleTangentUndirectedAngleMarker(x, x_1)",
      ],
      addTangentPolygon: ["x_1", "x_1"],
      addTangentSegment: ["x_1", "x_1"],
      addTangentSegmentThreeD: ["x_1", "x_1"],
      addTangentLine: ["x_1", "x_1"],
      addTangentRay: ["x_1", "x_1"],
      addTangentVector: ["x_1", "x_1"],
      addTangentCircle: ["x_1", "x_1"],
      addTangentArc: ["x_1", "x_1"],
      addTangentDirectedAngleMarker: ["x_1", "x_1"],
      addTangentUndirectedAngleMarker: ["x_1", "x_1"],
      addTangentTransformation: ["x_1", "x_1"],
      translation: ["\\rawTransform((0,0),x_1)"],
      dilation: [
        "\\rawTransform((0,0),(1-y)x_1)",
        "\\rawTransform((x_1,0),-x*x_1)",
      ],
      reflection: [
        "\\rawTransformConj(a_1,p1_1-\\complexMultiplyPoints(a_1,(p1.x,-p1.y))-\\complexMultiplyPoints(qa,(p1_1.x,-p1_1.y)))\\with a_1=\\pointPerp(qa)*(\\pointDet(v,v_1)*2/(v.x^2+v.y^2))"
          .replace(/p1_1/g, "\\glider(x_1,0)").replace(/p1/g, "\\glider(x,0)")
          .replace(/v_1/g, "(\\glider(x_1,1)-\\glider(x_1,0))").replace(
            /v/g,
            "(\\glider(x,1)-\\glider(x,0))",
          ).replace(/qa/g, "\\transformScaleFactor(q)"),
      ],
      rotation: [
        "\\rawTransform((0,0),\\complexMultiplyPoints(p,x_1))\\with p=(1,0)-(\\cos(y),\\sin(y))",
        "\\rawTransform(p,\\complexMultiplyPoints(-p,x))\\with p=(-x_1*\\sin(y),x_1*\\cos(y))",
      ],
      compose: [
        "\\reflection(\\line((0/0,0/0),(0/0,0/0)))",
        "\\reflection(\\line((0/0,0/0),(0/0,0/0)))",
      ],
      inverse: ["\\reflection(\\line((0/0,0/0),(0/0,0/0)))"],
      transformPoint: [
        "\\transformPoint(x_1,y)",
        "\\transformPoint(\\transformWithoutTranslation(x),x_1)",
      ],
      transformSegment: [
        "\\transformSegment(x_1,y)",
        "\\transformSegment(\\transformWithoutTranslation(x),x_1)",
      ],
      transformVector: [
        "\\transformVector(x_1,y)",
        "\\transformVector(\\transformWithoutTranslation(x),x_1)",
      ],
      transformLine: [
        "\\transformLine(x_1,y)",
        "\\transformLine(\\transformWithoutTranslation(x),x_1)",
      ],
      transformRay: [
        "\\transformRay(x_1,y)",
        "\\transformRay(\\transformWithoutTranslation(x),x_1)",
      ],
      transformCircle: [
        "\\circle(\\transformPoint(x_1,y.\\center), y.\\radius * \\pointDot(a_1,a) / \\hypot(a.x,a.y))\\with a=\\transformScaleFactor(x),a_1=\\transformScaleFactor(x_1)",
        "\\transformCircle(\\transformWithoutTranslation(x),x_1)",
      ],
      transformArc: [
        "\\transformArc(x_1,y)",
        "\\transformArc(\\transformWithoutTranslation(x),x_1)",
      ],
      transformPolygon: [
        "\\transformPolygon(x_1,y)",
        "\\transformPolygon(\\transformWithoutTranslation(x),x_1)",
      ],
      transformAngleMarker: [
        "\\angle((1,0),(0,0),(1,0))",
        "\\transformAngleMarker(\\transformWithoutTranslation(x),x_1)",
      ],
      transformDirectedAngleMarker: [
        "\\directedangle((1,0),(0,0),(1,0))",
        "\\transformDirectedAngleMarker(\\transformWithoutTranslation(x),x_1)",
      ],
      mean: ["\\mean(x_1)"],
      total: ["\\total(x_1)"],
      count: ["0"],
      var: ["2*\\cov(x, x_1)"],
      varp: ["2*\\cov(x, x_1)*(\\count(x)-1)/\\count(x)"],
      stdev: ["\\cov(x, x_1)/q"],
      stdevp: ["\\covp(x, x_1)/q"],
      mad: ["\\mean(\\sign(x-\\mean(x))*(x_1 - \\mean(x_1)))"],
      listMin: ["x_1[\\argmin(x)]"],
      listMax: ["x_1[\\argmax(x)]"],
      min: ["\\{x>y:0,x_1\\}", "\\{x<=y:0,x_1\\}"],
      max: ["\\{x<y:0,x_1\\}", "\\{x>=y:0,x_1\\}"],
      median: [
        "0.5*(x_1[\\lowerQuantileIndex(x, 0.5)] + x_1[\\upperQuantileIndex(x, 0.5)])",
      ],
      argmin: ["0/0"],
      argmax: ["0/0"],
      gcd: ["0/0"],
      complexGCD: ["0/0"],
      lcm: ["0/0"],
      complexLCM: ["0/0"],
      erf: ["\\frac{2x_1}{\\sqrt{\\pi }}\\exp(-x^2)"],
      invNorm: ["\\frac{x_1}{\\pdf(\\normaldist(0,1),q)}"],
      logbase: [
        "\\{x > 0: \\frac{x_1}{x*\\ln(y)} \\}",
        "\\frac{-q*x_1}{y*\\ln(y)}",
      ],
      complexLogbase: [
        "\\frac{x_1}{x*\\complexLn(y)}",
        "\\frac{-q*x_1}{y*\\complexLn(y)}",
      ],
      hypot: ["x_1*x/q", "x_1*y/q"],
      polyGamma: ["0/0", "\\polyGamma(1 + x, y)*x_1"],
      mod: [
        "\\{ q=0: 0/0, x_1 \\}",
        "\\{ \\mod(x/y, 1) > 0: -\\floor(x/y)*x_1 \\}",
      ],
      complexMod: [
        "\\{ q=0: 0/0, x_1 \\}",
        "\\{ \\round(r)=r: 0/0, -\\floor(x/y)*x_1 \\} \\with r=\\round(x/y)",
      ],
      cov: ["\\cov(x_1, y)", "\\cov(x, x_1)"],
      covp: ["\\covp(x_1, y)", "\\covp(x, x_1)"],
      corr: [
        "(\\cov(x_1, y) - (\\cov(x, y)*\\cov(x, x_1)/\\var(x)))/(\\stdevp(x)\\stdevp(y))",
        "(\\cov(x, x_1) - (\\cov(x, y)*\\cov(y, x_1)/\\var(y)))/(\\stdevp(x)\\stdevp(y))",
      ],
      spearman: ["0/0", "0/0"],
      quantile: [
        "\\{ \\floor(y*(\\count(x)-1)) = y*(\\count(x)-1) :   x_1[\\upperQuantileIndex(x, y)],  (\\ceil(y*(\\count(x)-1)) - y*(\\count(x)-1))*x_1[\\lowerQuantileIndex(x, y)] +   (y*(\\count(x)-1) - \\floor(y*(\\count(x)-1)))*x_1[\\upperQuantileIndex(x, y)]\\}",
        "\\{ \\floor(y*(\\count(x)-1)) < y*(\\count(x)-1) :   (\\count(x)-1)*(x[\\upperQuantileIndex(x, y)] - x[\\lowerQuantileIndex(x, y)])*x_1\\}",
      ],
      quartile: [
        "0.5*(x_1[\\lowerQuartileIndex(x, y)] + x_1[\\upperQuartileIndex(x, y)])",
        "0/0",
      ],
      tscore: [
        "\\frac{\\sqrt{\\count(x)}(\\stdev(x)*\\mean(x_1)-(\\mean(x)-y)*\\frac{\\cov(x,x_1)}{\\stdev(x)})}{\\stdev(x)^2}",
        "-x_1*\\sqrt{\\count(x)}/\\stdev(x)",
      ],
      quartileIndex: ["0/0", "0/0"],
      upperQuartileIndex: ["0/0", "0/0"],
      lowerQuartileIndex: ["0/0", "0/0"],
      upperQuantileIndex: ["0/0", "0/0"],
      lowerQuantileIndex: ["0/0", "0/0"],
      nCr: [
        "q*(\\polyGamma(0, 1 + x) - \\polyGamma(0, 1 + x - y))",
        "q*(\\polyGamma(0, 1 + x - y) - \\polyGamma(0, 1 + y))",
      ],
      nPr: [
        "q*(\\polyGamma(0, 1 + x) - \\polyGamma(0, 1 + x - y))",
        "q*\\polyGamma(0, 1 + x - y)",
      ],
      arctan: ["x_1*y/(y^2+x^2)", "-x_1*x/(y^2+x^2)"],
      complexArctan: ["x_1/((x+\\complex(0,1))(x-\\complex(0,1)))"],
      poissonpdf: [
        "0/0",
        "x_1\\frac{\\exp(-y)(\\floor(x)-y)y^{(\\floor(x)-1)}}{(\\floor(x))!}",
      ],
      invPoisson: ["0/0", "0/0"],
      tpdf: [
        "x_1*q*\\frac{-(y+1)*x}{y+x^2}",
        "x_1*\\frac{1}{2}q*(  \\frac{x^2-1}{y + x^2} + \\ln(\\frac{y}{y + x^2}) +   \\polyGamma(0, \\frac{1+y}{2}) - \\polyGamma(0, y/2))",
      ],
      invT: ["x_1/\\pdf(\\tdist(y),q)", "0/0"],
      tcdf: ["-x_1*\\pdf(\\tdist(z),x)", "x_1*\\pdf(\\tdist(z),y)", "0/0"],
      poissoncdf: [
        "0/0",
        "0/0",
        "x_1\\sum _{n=\\max(0,\\floor(\\min(x,y)))}^{\\floor(\\max(x,y))}\\frac{\\exp(-z)(n-z)z^{(n-1)}}{n!}",
      ],
      normalpdf: [
        "-x_1*\\frac{x-y}{z^2} q",
        "x_1*\\frac{x-y}{z^2} q",
        "x_1*(\\frac{(x-y-z)*(x-y+z)}{z^3}) q",
      ],
      binompdf: [
        "0/0",
        "0/0",
        "\\{0<=z<=1: x_1*q*(\\frac{\\round(x)}{z}-\\frac{\\round(y)-\\round(x)}{1-z}), 0 \\}",
      ],
      invBinom: ["0/0", "0/0", "0/0"],
      uniformpdf: [
        "0",
        "\\{y<=x: \\frac{x_1}{(z-y)^2}, 0\\}",
        "\\{z>=x: -\\frac{x_1}{(z-y)^2}, 0\\}",
      ],
      invUniform: [
        "\\{y<=x<=z: x_1*(z-y), 0\\}",
        "\\{y<=x<=z: x_1*(1-x), 0\\}",
        "\\{y<=x<=z: x_1*x, 0\\}",
      ],
      normalcdf: [
        "-x_1\\pdf(\\normaldist(z,u), x)",
        "x_1\\pdf(\\normaldist(z,u), y)",
        "-x_1*(\\pdf(\\normaldist(z,u), y) - \\pdf(\\normaldist(z,u), x))",
        "x_1*(  \\{\\abs(y)=1/0:0,\\frac{z-y}{u}\\pdf(\\normaldist(z,u),y)\\} -   \\{\\abs(x)=1/0:0,\\frac{z-x}{u}\\pdf(\\normaldist(z,u),x)\\})",
      ],
      binomcdf: [
        "0/0",
        "0/0",
        "0/0",
        "\\{0<=u<=1: x_1*\\sum _{n=\\max(0,\\round(\\min(x,y)))}^{\\round(\\max(x,y))}(  \\pdf(\\binomialdist(z,u),n)*(\\frac{n}{u}-\\frac{\\round(z)-n}{1-u})), 0 \\}",
      ],
      uniformcdf: [
        "\\{z>u: 0/0, -x_1\\pdf(\\uniformdist(z,u), x)\\}",
        "\\{z>u: 0/0, x_1\\pdf(\\uniformdist(z,u), y)\\}",
        "\\{z>u: 0/0, x_1*(\\frac{\\{z<x<u:u-x,0\\} + \\{z<y<u:y-u,0\\}}{(u-z)^2})\\}",
        "\\{z>u: 0/0, x_1*(\\frac{\\{z<x<u:x-z,0\\} + \\{z<y<u:z-y,0\\}}{(u-z)^2})\\}",
      ],
      normalSample: ["0/0", "0/0", "0/0"],
      uniformSample: ["0/0", "0/0", "0/0"],
      tSample: ["0/0", "0/0"],
      poissonSample: ["0/0", "0/0"],
      binomSample: ["0/0", "0/0", "0/0"],
      rgb: ["0/0", "0/0", "0/0"],
      hsv: ["0/0", "0/0", "0/0"],
      polygon: ["\\polygon(x_1)"],
      area: ["0/0"],
      perimeter: ["0/0"],
      vertices: ["\\vertices(x_1)"],
      segments: ["\\segments(x_1)"],
      validateRangeLength: ["0", "0", "0", "\\{q \\ge 1: x_1, 0\\}"],
      validateSampleCount: ["\\{x<0:0,1\\}*x_1"],
      select: ["\\select(x_1, y)", "0*q"],
      shuffle: ["0*y", "\\shuffle(x, x_1)"],
      sortPerm: ["0*x"],
      complexSortPerm: ["0*x"],
      elementsAt: ["\\elementsAt(x_1, y)", "0*q"],
      uniquePerm: ["0*q"],
      tone: ["\\tone(x_1,0)", "\\tone(0,x_1)"],
      restriction: ["0"],
      restrictionToBoolean: ["0"],
      complex: ["\\complex(x_1,0)", "\\complex(0,x_1)"],
      arg: ["\\imag(x_1/x)"],
      complexDivide: ["x_1/y", "-(q/y)x_1"],
      coerceComplexToReal: ["\\coerceComplexToReal(x_1)"],
      peelableCoerceComplexToReal: ["\\peelableCoerceComplexToReal(x_1)"],
      coerceRealToComplex: ["\\coerceRealToComplex(x_1)"],
    },
    WA = {};
  for (let e in ZA) {
    let t = e, n = ZA[t], r = [];
    for (let s = 0; s < n.length; s++) {
      let i = n[s];
      r.push(Mi(i, {}));
    }
    WA[t] = r;
  }
  function om(e) {
    return se(e, Number) ? "number" : se(e, Complex) ? "complex" : void 0;
  }
  function kh(e, t, n, r) {
    let s = e.getInstruction(n).valueType;
    if (om(s) !== r) {
      throw U(`Incorrect derivative strategy '${r}' for type ${s}.`);
    }
    let i = e.getInstruction(t).valueType;
    if (!oU(i, r)) {
      let o = e.areAllArgsConstant([t]);
      throw r === "number"
        ? dT([oe(i)], { blockExport: o })
        : fT([oe(i), oe(s)], { blockExport: o });
    }
    switch (r) {
      case "number":
        return Bh(e, t, n, "real");
      case "complex":
        let o = Bh(e, t, n, "complexOne"), a = Bh(e, t, n, "complexI");
        return e.Multiply([
          e.Constant(Se(1, 2)),
          e.Subtract([o, e.Multiply([e.ImaginaryUnit(), a])]),
        ]);
      default:
        throw U(`Invalid derivative strategy '${r}'.`);
    }
  }
  function oU(e, t) {
    switch (t) {
      case "number":
        return kn(e, Complex) || kn(e, ListOfComplex) || se(e, Point) ||
          se(e, Point3D);
      case "complex":
        return kn(e, Complex) || kn(e, ListOfComplex);
      default:
        throw U(`Invalid derivative strategy '${t}'.`);
    }
  }
  function zM(e, t, n) {
    let r = e.getInstruction(n).valueType, s = om(r);
    if (!s) throw U(`chunk.derivative called on non-number ${at(r)}.`);
    return kh(e, t, n, s);
  }
  function jA(e) {
    let t = [];
    t.push("digraph {");
    for (let n = 0; n < e.instructionsLength(); n++) {
      e.getInstruction(n).type !== 0 &&
        t.push(`${n} [label="${n}: ${al(e, n)}"];`);
    }
    for (let n = 0; n < e.instructionsLength(); n++) {
      let r = e.getInstruction(n);
      if (tO(r)) { for (let s of r.args) t.push(`${n} -> ${s};`); }
    }
    return t.push("}"),
      t.join(`
`);
  }
  var Ia = class e {
    constructor(t) {
      this.derivativeMaps = new Th();
      if (
        this.instructions = [],
          this.blockMask = [],
          this.comments = [],
          t.argNames.length !== t.argTypes.length
      ) {
        throw new Error(
          "Programming Error: length of argNames must match length of argTypes",
        );
      }
      this.argNames = t.argNames, this.argTypes = t.argTypes;
      for (let n = 0; n < this.argTypes.length; n++) {
        let r = this.argTypes[n];
        this.LoadArg(r);
      }
      this.returnIndex = this.Constant(NaN);
    }
    computeNeedsThunking() {
      for (let t = this.returnIndex; t >= 0; t--) {
        if (this.instructions[t].type === 55) return true;
      }
      return false;
    }
    setError(t) {
      this.error = t;
    }
    getError() {
      return this.error;
    }
    setWarning(t) {
      this.warning === void 0 && (this.warning = t);
    }
    restoreWarning(t) {
      this.warning = t;
    }
    getWarning() {
      return this.warning;
    }
    getReturnIndex() {
      return this.returnIndex;
    }
    setReturnIndex(t) {
      if (!(0 <= t && t < this.instructions.length)) {
        throw new Error(`Programming Error: out of bounds return index ${t}`);
      }
      this.returnIndex = t;
    }
    addComments(t) {
      for (let n in t) {
        let r = this.comments[n] || "";
        this.comments[n] = r + t[n];
      }
      return this;
    }
    instructionsLength() {
      return this.instructions.length;
    }
    getInstruction(t) {
      return this.instructions[t];
    }
    popInstruction() {
      this.unsafelyTruncate(this.instructions.length - 1);
    }
    unsafelyTruncate(t) {
      this.instructions.length = Math.min(t, this.instructions.length),
        this.blockMask.length = Math.min(t, this.blockMask.length),
        this.comments.length = Math.min(t, this.comments.length),
        this.derivativeMaps.truncate(t),
        this.setReturnIndex(this.instructions.length - 1);
    }
    dereferenceFunctionHeader(t) {
      let n = this.getInstruction(t);
      return n.endIndex === -1 ? void 0 : n.endIndex;
    }
    getDirectDependencies(t) {
      if (t.type === 55) {
        let n = t.args, r = this.dereferenceFunctionHeader(n[0]);
        if (r !== void 0) return n.concat(r);
      }
      return t.args;
    }
    getRecursionStructure(t) {
      let n = this.getInstruction(t);
      if (n.endIndex === -1) {
        throw U(
          "Programming error: cannot get recursion structure before function is closed",
        );
      }
      if (!n.__cachedRecursionStructure) {
        let r = {};
        for (let s of n.recursionGroup) {
          let i = this.getInstruction(s);
          r[i.symbol] = s;
        }
        n.__cachedRecursionStructure = hO(this, r);
      }
      return n.__cachedRecursionStructure;
    }
    getRecursiveFunctionMetadata(t) {
      let n = this.getRecursionStructure(t), r = this.getInstruction(t);
      return {
        type: n.canIterate ? "iterative" : "general",
        recursionGroup: r.recursionGroup.map((s) =>
          this.getInstruction(s).symbol
        ),
        returnType: r.valueType,
        signature: r.signature,
        recursiveStructure: n,
      };
    }
    pushInstructionChecked(t) {
      if (this.instructions.length >= 32768) throw _T();
      this.instructions.push(t),
        this.setReturnIndex(this.instructions.length - 1);
    }
    pushLeafInstruction(t) {
      return this.pushInstructionChecked(t), this.getReturnIndex();
    }
    pushInstruction(t) {
      return this.checkInstructionArguments(t),
        this.pushInstructionChecked(t),
        this.setReturnIndex(EN(this)),
        this.setReturnIndex(FN(this)),
        this.setReturnIndex(oN(this)),
        iN(this, this.getReturnIndex()),
        this.returnIndex === this.instructions.length - 1 &&
        this.setReturnIndex(PN(this)),
        this.getReturnIndex();
    }
    checkInstructionArguments(t) {
      for (let n of t.args) {
        if (this.blockMask[n]) {
          throw new Error(
            "Programming Error: cannot reference an instruction in a closed block",
          );
        }
      }
    }
    markClosedBlock(t, n) {
      for (let r = t; r < n; r++) this.blockMask[r] = true;
    }
    LoadArg(t) {
      return this.pushLeafInstruction({ type: 2, valueType: t });
    }
    BlockVar(t, n) {
      return this.pushInstruction({ type: 47, valueType: t, args: n });
    }
    SymbolicVar(t, n) {
      return this.pushLeafInstruction({ type: 3, valueType: t, symbol: n });
    }
    BroadcastResult(t, n) {
      let r = n[0],
        i = this.instructions[r].args[0],
        a = this.getInstruction(i).args[0],
        u = this.getInstruction(a);
      return this.pushInstruction({
        type: 48,
        valueType: t,
        args: n,
        constantLength: Je(u) ? hn(this, a) : void 0,
      });
    }
    Constant(t) {
      return this.ConstantOfType(Number, t);
    }
    ConstantOfType(t, n) {
      if (typeof n == "number" && (n = Se(n, 1)), j(t) && n.length > 1e4) {
        throw zd();
      }
      return this.pushLeafInstruction({ type: 1, valueType: t, value: n });
    }
    TupleOfType(t, n) {
      return this.pushInstruction({ type: 15, valueType: t, args: n });
    }
    Slot(t, n) {
      let r = 16,
        s = this.getInstruction(n[0]).valueType,
        i = zl[s],
        o = i ? i[t] : Any;
      if (o === void 0) throw U(`Invalid slot index: ${t} for ${at(s)}.`);
      return this.pushInstruction({ type: r, valueType: o, args: n, index: t });
    }
    ImaginaryUnit() {
      return this.ConstantOfType(Complex, [Se(0, 1), Se(1, 1)]);
    }
    NanOfType(t) {
      if (t === Distribution) {
        let n = this.Constant(NaN);
        return this.Distribution("uniformdist", [n, n]);
      } else return this.ConstantOfType(t, ls(t));
    }
    ZeroOfType(t) {
      return this.ConstantOfType(t, RS(t));
    }
    Add(t) {
      let n = 8, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    Subtract(t) {
      let n = 9, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    Multiply(t) {
      let n = 10, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    Divide(t) {
      let n = 11, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    Exponent(t) {
      let n = 12, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    RawExponent(t) {
      let n = 13, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    Negative(t) {
      let n = 14, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    Equal(t) {
      let n = 25, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    Less(t) {
      let n = 26, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    Greater(t) {
      let n = 27, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    LessEqual(t) {
      let n = 28, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    GreaterEqual(t) {
      let n = 29, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    Comparator(t, n) {
      switch (t) {
        case "=":
          return this.Equal(n);
        case ">":
          return this.Greater(n);
        case "<":
          return this.Less(n);
        case "<=":
          return this.LessEqual(n);
        case ">=":
          return this.GreaterEqual(n);
        default: {
          let r = t;
          throw new Error(`Unexpected comparator symbol: ${r}`);
        }
      }
    }
    Or(t) {
      let n = 31, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    And(t) {
      let n = 32, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    Piecewise(t) {
      let n = 33, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    List(t) {
      let n = 38, r = Sn(this, n, t);
      if (t.length > 1e4) throw zd();
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    ListAccess(t) {
      let n = 39, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    DeferredListAccess(t) {
      let n = 40, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    InboundsListAccess(t) {
      let n = 41, r = Sn(this, n, t);
      return this.pushInstruction({ type: n, valueType: r, args: t });
    }
    NativeFunction(t, n) {
      let r = 37,
        s = Bn[t].returnType,
        i = typeof s == "function"
          ? s(n.map((o) => this.getInstruction(o).valueType))
          : s;
      return this.pushInstruction({
        type: r,
        valueType: i,
        args: n,
        symbol: t,
      });
    }
    Distribution(t, n) {
      let r = 42, s = Distribution;
      return this.pushInstruction({
        type: r,
        valueType: s,
        args: n,
        symbol: t,
      });
    }
    BeginIntegral(t, n) {
      let r = 21, s = Sn(this, r, []);
      return this.pushInstruction({
        type: r,
        valueType: s,
        args: n,
        endIndex: -1,
        callData: t,
      });
    }
    EndIntegral(t) {
      let n = 22, r = Sn(this, n, t), s = t[0], i = this.getInstruction(s);
      this.instructions[s] = {
        type: i.type,
        valueType: i.valueType,
        args: i.args,
        endIndex: this.instructionsLength(),
        callData: i.callData,
      };
      let o = this.pushInstruction({ type: n, valueType: r, args: t });
      return this.markClosedBlock(s, o), o;
    }
    BeginBroadcast(t, n) {
      let r = 23, s = Sn(this, r, []), i = this.getInstruction(t[0]);
      if (Je(i) && hn(this, t[0]) > 1e4) throw zd();
      return this.pushInstruction({
        type: r,
        valueType: s,
        endIndex: -1,
        args: t,
        context: n,
      });
    }
    EndBroadcast(t) {
      let n = 24,
        r = Sn(this, n, t),
        s = t[0],
        i = this.getInstruction(s),
        o = {
          type: i.type,
          valueType: i.valueType,
          args: i.args,
          endIndex: this.instructionsLength(),
          context: i.context,
        };
      this.instructions[s] = o;
      let a = this.pushInstruction({ type: n, valueType: r, args: t });
      return this.markClosedBlock(s, a), a;
    }
    BeginLoop(t, n) {
      let r = 19, s = Sn(this, r, n);
      return this.pushInstruction({
        type: r,
        valueType: s,
        args: n,
        endIndex: -1,
        callData: t,
      });
    }
    EndLoop(t) {
      let n = 20, r = Sn(this, n, t), s = t[0], i = this.getInstruction(s);
      this.instructions[s] = {
        type: i.type,
        valueType: i.valueType,
        args: i.args,
        endIndex: this.instructionsLength(),
        callData: i.callData,
      };
      let o = this.pushInstruction({ type: n, valueType: r, args: t });
      return this.markClosedBlock(s, o), o;
    }
    BeginMap(t, n) {
      let r = 50, s = Sn(this, r, n);
      return this.pushInstruction({
        type: r,
        valueType: s,
        args: n,
        endIndex: -1,
        callData: t,
      });
    }
    EndMap(t) {
      let n = 51, r = Sn(this, n, t), s = t[0], i = this.getInstruction(s);
      this.instructions[s] = {
        type: i.type,
        valueType: i.valueType,
        args: i.args,
        endIndex: this.instructionsLength(),
        callData: i.callData,
      };
      let o = this.pushInstruction({ type: n, valueType: r, args: t });
      return this.markClosedBlock(s, o), o;
    }
    FunctionHeader(t, n, r, s) {
      let i = 4;
      return this.pushLeafInstruction({
        type: i,
        valueType: n,
        endIndex: -1,
        symbol: t,
        signature: r,
        parameterSymbols: s,
        recursionGroup: [],
      });
    }
    BeginFunction(t) {
      let n = 53, r = this.getInstruction(t[0]);
      return this.pushInstruction({
        type: n,
        valueType: r.valueType,
        endIndex: -1,
        args: t,
      });
    }
    EndFunction(t) {
      let n = 54, r = t[0], s = this.getInstruction(r);
      this.instructions[r] = {
        type: s.type,
        valueType: s.valueType,
        args: s.args,
        endIndex: this.instructionsLength(),
      };
      let i = s.args[0], o = this.getInstruction(s.args[0]);
      this.instructions[i] = {
        type: o.type,
        valueType: o.valueType,
        endIndex: this.instructionsLength(),
        symbol: o.symbol,
        signature: o.signature,
        parameterSymbols: o.parameterSymbols,
        recursionGroup: o.recursionGroup,
      };
      let a = this.pushInstruction({ type: n, valueType: Any, args: t });
      return this.markClosedBlock(r, a), a;
    }
    FunctionCall(t) {
      let n = 55;
      return this.pushInstruction({
        type: n,
        valueType: Sn(this, n, t),
        args: t,
      });
    }
    ExtendSeed(t, n) {
      let r = 44, s = SeedType;
      return this.pushInstruction({ type: r, valueType: s, args: n, tag: t });
    }
    Noop() {
      let t = 0, n = Any;
      return this.pushLeafInstruction({ type: t, valueType: n });
    }
    Action(t, n) {
      return this.pushInstruction({
        type: 49,
        valueType: Action,
        args: n,
        symbols: t,
      });
    }
    replaceInstructionWithConstant(t, n) {
      this.instructions[t] = n, this.blockMask[t] = void 0;
    }
    replaceInstructionWithBlockVarOrFunctionCall(t, n) {
      this.instructions[t] = n;
    }
    reopenFinalBlock() {
      let t = this.getInstruction(this.getReturnIndex());
      if (t.type !== 48) return this;
      let n = t.args[0], s = this.getInstruction(n).args[0];
      for (let i = s; i < n; i++) this.blockMask[i] = void 0;
      return this.unsafelyTruncate(n), this;
    }
    reopenAllBlocks() {
      this.blockMask = [];
    }
    isInClosedBlock(t) {
      return !!this.blockMask[t];
    }
    copy() {
      let t = new e({ argNames: this.argNames, argTypes: this.argTypes });
      return t.instructions = this.instructions.slice(),
        t.blockMask = this.blockMask.slice(),
        t.comments = this.comments.slice(),
        t.derivativeMaps = this.derivativeMaps.clone(),
        t.warning = this.warning,
        t.setReturnIndex(this.getReturnIndex()),
        t;
    }
    fuseBroadcast() {
      return this.setReturnIndex(Gr(this, this.getReturnIndex())), this;
    }
    copyInstruction(t) {
      return po(this, t);
    }
    copyInstructionWithArgs(t, n) {
      return _n(this, t, n);
    }
    replaceInstructionWithNoop(t) {
      this.instructions[t] = { type: 0, valueType: Any };
    }
    getReturnType() {
      return this.instructions[this.getReturnIndex()].valueType;
    }
    isConstant() {
      return Je(this.instructions[this.getReturnIndex()]);
    }
    areAllArgsConstant(t) {
      for (let n of t) if (!Je(this.instructions[n])) return false;
      return true;
    }
    asValue() {
      return hn(this, this.getReturnIndex());
    }
    asCompilerValue() {
      let t = this.instructions[this.getReturnIndex()];
      switch (t.type) {
        case 1:
          return t.value;
        default:
          throw new Error(`Unexpected opcode ${t.type}.`);
      }
    }
    getConstantListLength() {
      return qn(this, this.getReturnIndex());
    }
    getListLengthDependencies() {
      let t = this.copy(), n = ur(t, t.getReturnIndex());
      return fs(t, n);
    }
    elementAt(t) {
      let n = this.copy(), r = n.getReturnIndex();
      return n.setReturnIndex(zf(n, r, t)), n;
    }
    substituteConstantArguments(t) {
      return zN(this, t);
    }
    interpretWithParameters(t) {
      return hN(this, this.getReturnIndex(), t);
    }
    getCompiledFunction(t) {
      let n;
      if (t) {
        n = t.slice();
        for (let o of this.argNames) n.indexOf(o) === -1 && n.push(o);
      } else n = this.argNames;
      let { source: r, constants: s } = jg(this), i = {};
      return {
        args: n,
        source: r,
        constants: s,
        executionMetadata: i,
        fn: wf(n, r, s, i),
      };
    }
    getRestrictedFunctionForGLSL(t, n) {
      let r = tu(this, t, { allowSlices: true }),
        { restrictionChunk: s, valueChunk: i } = r
          .getValueAndRestrictionChunk(),
        o;
      if (s !== void 0) {
        try {
          o = Ma(s, n);
        } catch (a) {
          s = void 0;
        }
      }
      return o === void 0 && r.getSliceVariablesOrImplicit().length == 0
        ? {
          concrete: new on(this),
          restriction: void 0,
          restrictionExpr: void 0,
        }
        : {
          concrete: new on(i),
          restriction: o,
          restrictionExpr: s && new on(s),
        };
    }
    polynomialOrder(t, n) {
      return $O(this, t, n);
    }
    getPolynomialCoefficients(t) {
      return YO(this, t);
    }
    takeDerivative(t) {
      let n = this.argNames.indexOf(t);
      return n === -1
        ? this.setReturnIndex(this.ZeroOfType(this.getReturnType()))
        : this.setReturnIndex(zM(this, this.getReturnIndex(), n)),
        this;
    }
    gradient(t) {
      let n = [], r = this.getReturnIndex();
      for (let s of t) {
        let i = this.argNames.indexOf(s);
        i === -1 ? n.push(this.Constant(0)) : n.push(zM(this, r, i));
      }
      return this.List(n), this;
    }
    deriveRegressionRestrictions() {
      return CN(this);
    }
    boundDomain(t) {
      return XO(this, t, this.getReturnIndex());
    }
    findLinearSubset(t) {
      let n = wN(this), r = [];
      for (let s of t) {
        let i = this.argNames.indexOf(s);
        if (i === -1) {
          throw new Error(
            "Programming Error: findLinearSubset called with a non-dependency",
          );
        }
        r.push(n[i]);
      }
      return r;
    }
    isLinearIn(t) {
      let n = this.argNames.filter((r) => t.includes(r));
      return n.length === 0 ? false : this.findLinearSubset(n).every(Boolean);
    }
    isImplicitPlane() {
      let t = (n) => n === "x" || n === "y" || n === "z";
      return this.isLinearIn(["x", "y", "z"]) && this.argNames.every(t);
    }
    print(t, n = this.comments) {
      let r;
      return t === void 0
        ? (t = this.instructionsLength() - 1,
          r = { printUnreferencedInstructions: true, comments: n })
        : r = { printUnreferencedInstructions: false, comments: n },
        oO(this, t, r);
    }
    printInstruction(t) {
      return al(this, t);
    }
    toDot() {
      return jA(this);
    }
    getLiveArgNames() {
      let t = Vr(this, this.getReturnIndex()), n = [];
      for (let r = 0; r < this.argNames.length; r++) {
        t[r] && n.push(this.argNames[r]);
      }
      return n;
    }
    getCursorContext() {
      return this.cursorContext;
    }
    setCursorContext(t) {
      this.cursorContext = t;
    }
    coerceToNumericIfPossible() {
      return zi(this, this.getReturnIndex());
    }
    coerceNonComplexToNumberIfPossible() {
      return fl(this, this.getReturnIndex());
    }
  };
  function xl(e, t) {
    return UM(e, t).freeDependencies;
  }
  function UM(e, t) {
    let n = {};
    if (
      t.type === "FunctionDefinition" || t.type === "RecursiveFunctionBaseCase"
    ) {
      let { freeDependencies: r, updateSymbols: s } = Hh(e, t._expression, n),
        i = r.filter((o) => o !== t._symbol);
      if (t instanceof Cr || t instanceof Qr) {
        for (let o of t._argSymbols) i.includes(o) || i.push(o);
      }
      return { freeDependencies: i, updateSymbols: s };
    }
    return Hh(e, t, n);
  }
  function JA(e, t, n) {
    let r = [], s = [], i = [];
    for (let o of t.scopes) {
      let a = JA(e, o, n);
      for (let u of a.freeDependencies) {
        r.indexOf(u) === -1 && t.definitions.indexOf(u) === -1 && r.push(u);
      }
      for (let u of a.updateSymbols) s.indexOf(u) === -1 && s.push(u);
    }
    for (let o of t.dependencies) {
      if (t.definitions.indexOf(o) !== -1) continue;
      let a = aU(e, o, n), u = t.substitutionDependencies.indexOf(o) !== -1;
      for (let c of a.freeDependencies) {
        r.indexOf(c) === -1 && t.definitions.indexOf(c) === -1 && r.push(c),
          u && i.indexOf(c) === -1 && t.definitions.indexOf(c) === -1 &&
          i.push(c);
      }
      for (let c of a.updateSymbols) s.indexOf(c) === -1 && s.push(c);
    }
    return { freeDependencies: r, updateSymbols: s };
  }
  function Hh(e, t, n) {
    if (t.type === "Slider" || t.type === "Assignment") {
      return Hh(e, t._expression, n);
    }
    {
      let { freeDependencies: r, updateSymbols: s } = JA(e, t.getScope(), n),
        i = t.getUpdateSymbols();
      if (i.length > 0) {
        s = s.slice();
        for (let o of i) s.indexOf(o) === -1 && s.push(o);
      }
      return { freeDependencies: r, updateSymbols: s };
    }
  }
  function aU(e, t, n) {
    if (n[t]) return n[t];
    let r = uU(e, t, n);
    return n[t] = r, r;
  }
  function uU(e, t, n) {
    if (tt[t]) return { freeDependencies: [], updateSymbols: [] };
    let r = e[t];
    return r
      ? (n[t] = { freeDependencies: [], updateSymbols: [] }, Hh(e, r, n))
      : { freeDependencies: [t], updateSymbols: [] };
  }
  function QA(e, t) {
    let n = {}, r = t.getDependencies().slice();
    for (; r.length;) {
      let s = r.pop();
      if (n.hasOwnProperty(s)) continue;
      if (e.isLocal(s) || e.isError(s)) return;
      let i = e.getVisibleGlobalDefinition(s);
      n[s] = i,
        i && i.getDependencies &&
        Array.prototype.push.apply(r, i.getDependencies());
    }
    return Object.entries(n);
  }
  function KA(e, t, n) {
    e_(e, t, n, {});
  }
  function e_(e, t, n, r) {
    let s = {};
    for (let i of n.definitions) {
      if (s[i]) {
        switch (n.kind) {
          case "Sum":
          case "Product":
          case "Integral":
            throw U(
              new Error(
                `${n.kind} scope is not expected to define multiple symbols`,
              ),
            );
          case "FunctionDefinition":
            throw II(i);
          case "ListComprehension":
            throw qy(i);
          case "Substitution":
            throw VP(i);
          default:
            let o = n.kind;
            throw U(new Error(`Unexpected scope kind ${o}`));
        }
      }
      s[i] = true;
    }
    for (let i of n.definitions) {
      let o = t[i];
      if (o) {
        if (e.assignmentForbidden(i)) {
          switch (n.kind) {
            case "Sum":
            case "Product":
              throw vy(i);
            case "Integral":
              throw By(i);
            case "FunctionDefinition":
              throw Sy(i);
            case "Substitution":
            case "ListComprehension":
              throw af(i);
            default:
              let a = n.kind;
              throw U(new Error(`Unexpected scope kind ${a}`));
          }
        }
        if (
          (n.kind === "ListComprehension" || n.kind === "Substitution") &&
          o.type === "FunctionDefinition"
        ) throw uf(i);
      }
      if (r[i]) {
        switch (n.kind) {
          case "Sum":
          case "Product":
            throw vy(i);
          case "Integral":
            throw By(i);
          case "FunctionDefinition":
            throw Sy(i);
          case "ListComprehension":
            throw qy(i);
          case "Substitution":
            throw wP(i);
          default:
            let a = n.kind;
            throw U(new Error(`Unexpected scope kind ${a}`));
        }
      }
    }
    r = Tn(r);
    for (let i of n.definitions) r[i] = true;
    for (let i of n.scopes) e_(e, t, i, r);
  }
  var Sa = {
    normaldist: {
      pdf: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("normalpdf", n.concat(r.args));
      },
      cdf: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("normalcdf", n.concat(r.args));
      },
      mean: function (e, t, n) {
        return e.getInstruction(t).args[0];
      },
      median: function (e, t, n) {
        return Sa.normaldist.mean(e, t, n);
      },
      stdev: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("abs", [r.args[1]]);
      },
      var: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.Multiply([r.args[1], r.args[1]]);
      },
      quantile: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.Add([
          e.Multiply([
            e.NativeFunction("invNorm", n),
            e.NativeFunction("abs", [r.args[1]]),
          ]),
          r.args[0],
        ]);
      },
      random: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("normalSample", [n[0], r.args[0], r.args[1]]);
      },
    },
    tdist: {
      pdf: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("tpdf", n.concat(r.args));
      },
      cdf: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("tcdf", n.concat(r.args));
      },
      mean: function (e, t, n) {
        return e.Constant(0);
      },
      median: function (e, t, n) {
        return e.Constant(0);
      },
      stdev: function (e, t, n) {
        return e.NativeFunction("sqrt", [Sa.tdist.var(e, t, n)]);
      },
      var: function (e, t, n) {
        let r = e.getInstruction(t), s = e.Constant(2), i = r.args[0];
        return e.Piecewise([
          e.GreaterEqual([i, s]),
          e.Divide([i, e.Subtract([i, s])]),
          e.Constant(NaN),
        ]);
      },
      quantile: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("invT", [n[0], r.args[0]]);
      },
      random: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("tSample", [n[0], r.args[0]]);
      },
    },
    poissondist: {
      pdf: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("poissonpdf", n.concat(r.args));
      },
      cdf: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("poissoncdf", n.concat(r.args));
      },
      mean: function (e, t, n) {
        return e.getInstruction(t).args[0];
      },
      median: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("invPoisson", [e.Constant(.5), r.args[0]]);
      },
      stdev: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("sqrt", [r.args[0]]);
      },
      var: function (e, t, n) {
        return Sa.poissondist.mean(e, t, n);
      },
      quantile: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("invPoisson", [n[0], r.args[0]]);
      },
      random: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("poissonSample", [n[0], r.args[0]]);
      },
    },
    binomialdist: {
      pdf: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("binompdf", n.concat(r.args));
      },
      cdf: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("binomcdf", n.concat(r.args));
      },
      mean: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.Multiply([r.args[0], r.args[1]]);
      },
      median: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("invBinom", [
          e.Constant(.5),
          r.args[0],
          r.args[1],
        ]);
      },
      stdev: function (e, t, n) {
        return e.NativeFunction("sqrt", [Sa.binomialdist.var(e, t, n)]);
      },
      var: function (e, t, n) {
        let r = e.getInstruction(t), [s, i] = r.args;
        return e.Multiply([s, e.Multiply([i, e.Subtract([e.Constant(1), i])])]);
      },
      quantile: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("invBinom", [n[0], r.args[0], r.args[1]]);
      },
      random: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("binomSample", [n[0], r.args[0], r.args[1]]);
      },
    },
    uniformdist: {
      pdf: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("uniformpdf", n.concat(r.args));
      },
      cdf: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("uniformcdf", n.concat(r.args));
      },
      mean: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.Divide([e.Add([r.args[0], r.args[1]]), e.Constant(2)]);
      },
      median: function (e, t, n) {
        return Sa.uniformdist.mean(e, t, n);
      },
      stdev: function (e, t, n) {
        return e.NativeFunction("sqrt", [Sa.uniformdist.var(e, t, n)]);
      },
      var: function (e, t, n) {
        let r = e.getInstruction(t), s = e.Subtract([r.args[1], r.args[0]]);
        return e.Divide([e.Multiply([s, s]), e.Constant(12)]);
      },
      quantile: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("invUniform", [n[0], r.args[0], r.args[1]]);
      },
      random: function (e, t, n) {
        let r = e.getInstruction(t);
        return e.NativeFunction("uniformSample", [n[0], r.args[0], r.args[1]]);
      },
    },
  };
  function t_(e, t, n) {
    let r = n[0], s = e.Constant(0), i = e.Constant(1);
    if (qn(e, t) === 0) return e.Constant(NaN);
    let a = ur(e, t);
    return e.InboundsListAccess([
      t,
      e.Add([
        e.NativeFunction("floor", [
          e.Multiply([e.NativeFunction("uniformSample", [r, s, i]), a]),
        ]),
        i,
      ]),
    ]);
  }
  function n_(e, t, n) {
    switch (t) {
      case Complex:
        return e.NativeFunction("complex", n);
      case Point:
      case Point3D:
        return e.TupleOfType(t, n);
      default:
        throw U(
          `Type ${at(t)} is not a supported aggregate type for building.`,
        );
    }
  }
  function am(e) {
    if (!e) return;
    let { latex: t, latexSelection: n } = e;
    if (t === void 0 || n === void 0) return;
    let { start: r, end: s } = n;
    return { input: t, start: r, end: s };
  }
  function qM(e, t, n) {
    if (!t) return;
    let r = $M(t, n._expression);
    r === "start-to-end"
      ? e.setCursorContext({
        type: n.type === "Assignment"
          ? "assignment-rhs"
          : "function-definition-body",
        allowedTypes: [Any],
      })
      : r === "empty-list" &&
        e.setCursorContext({
          type: "expression-arguments",
          expressionType: "List",
          argIndex: 0,
          argCount: 0,
          isLastValidArg: false,
          positionWithinArg: "start-to-end",
          allowedTypesForInsertedArg: [Any],
        });
  }
  function r_(e, t, n) {
    if (t) {
      let r = $M(t, n.args[1]);
      r === "start-to-end"
        ? e.setCursorContext({
          type: "for-assignment-rhs",
          allowedTypes: [Segment, Circle, Arc, Line, Ray, Polygon, ...ii.types],
        })
        : r === "empty-list" &&
          e.setCursorContext({
            type: "for-assignment-rhs",
            allowedTypes: [Any],
          });
    }
  }
  function sd(e, t, n, r, s) {
    let i = cU(e, t, n, r, s);
    i && e.setCursorContext(i);
  }
  function $M(e, t) {
    let n = t.getInputSpan();
    return n
      ? e.start === n.start && e.end === n.end
        ? "start-to-end"
        : e.start === e.end && e.start === n.end
        ? "end"
        : e.start === e.end && e.start === n.start
        ? "start"
        : e.start === e.end && t.type === "List" && t.args.length === 0
        ? "empty-list"
        : "not-aligned"
      : "not-aligned";
  }
  function YM(e, t) {
    if (!e) return;
    let n = false;
    t instanceof Ms && t.args[1] instanceof gn && (n = true, t = t.args[1]);
    let r = t.args;
    if (r) {
      if (r.length === 0) {
        let s = t.getInputSpan();
        if (!s) return;
        let i = Yn(s), o = -1;
        return t.type === "List"
          ? o = i.indexOf("[")
          : (t.type === "FunctionCall" || t.type === "SeededFunctionCall") &&
            (o = i.indexOf("(")),
          o < 0
            ? void 0
            : e.start === s.start + o + 1
            ? { argIndex: 0, positionWithinArg: "start-to-end", isDotCall: n }
            : void 0;
      }
      for (let s = 0; s < r.length; s++) {
        let i = r[s], o = i.getInputSpan();
        if ((o == null ? void 0 : o.input) !== e.input) continue;
        if (e.start < o.start) break;
        let a = $M(e, i);
        if (a !== "not-aligned") {
          return { argIndex: s, positionWithinArg: a, isDotCall: n };
        }
      }
    }
  }
  function cU(e, t, n, r, s) {
    if (!n || !r.args) return;
    let i = YM(n, r);
    if (i === void 0) return;
    i.isDotCall && (r = r.args[1]);
    let o = i.positionWithinArg === "end" ? i.argIndex + 1 : i.argIndex;
    i.isDotCall && (o += 1);
    let a;
    i.positionWithinArg === "empty-list" ||
      i.positionWithinArg === "start-to-end"
      ? a = [...s.slice(0, o), void 0, ...s.slice(o + 1)]
      : r instanceof Fr
      ? a = o === 1 ? [s[0], void 0, s[1]] : [s[0], s[1], void 0]
      : a = [...s.slice(0, o), void 0, ...s.slice(o)],
      a = a.map((p) => {
        if (!(p === void 0 || e.getInstruction(p).type === 2)) return p;
      });
    let u = [];
    for (let p of a) {
      u.push(p === void 0 ? void 0 : e.getInstruction(p).valueType);
    }
    let c = ch(t, r, u), l = c && Ad(c, o);
    if (i.positionWithinArg === "empty-list") {
      let p = l == null ? void 0 : l.filter(j).map(Ve);
      return (p == null ? void 0 : p.length) === 0 ? void 0 : {
        type: "expression-arguments",
        expressionType: "List",
        argIndex: 0,
        argCount: 0,
        isLastValidArg: false,
        positionWithinArg: "start-to-end",
        allowedTypesForInsertedArg: p != null ? p : [Any],
      };
    } else {
      if ((l == null ? void 0 : l.length) === 0) return;
      let p = false;
      if (c) {
        let y = 0;
        for (let g of c) {
          let m = g.maxArity !== void 0 ? g.maxArity - 1 : 1 / 0;
          y = Math.max(y, m);
        }
        p = i.positionWithinArg === "end" && i.argIndex === y - 1 ||
          i.positionWithinArg === "start-to-end" && i.argIndex === y;
      }
      let f = r.args.length;
      if (r instanceof Fr && r.args.length === 3) {
        let y = r.args[2];
        y instanceof Et && y.isNaN() && (f = 2);
      }
      let d = {
        type: "expression-arguments",
        expressionType: r.type,
        argIndex: i.argIndex,
        argCount: f,
        isLastValidArg: p,
        positionWithinArg: i.positionWithinArg,
        allowedTypesForInsertedArg: l != null ? l : [Any],
      };
      if (
        r instanceof gn &&
        (d.functionSymbol = r._symbol,
          d.isDotCall = i.isDotCall,
          r instanceof gn && r._symbol === "polygon")
      ) {
        let y = r.args.filter((g) =>
          !(g instanceof we && g._symbol === "cursor")
        );
        if (y.length > 0) {
          let g = y[0].getInputSpan(), m = y[y.length - 1].getInputSpan();
          d.polygonVertices = g && m
            ? { firstLatex: Yn(g), lastLatex: Yn(m) }
            : void 0;
        }
      }
      return d;
    }
  }
  function um(e, t, n) {
    if (t === n) return true;
    if (t < n) return false;
    let r = [true];
    for (let i = n + 1; i <= t; i++) r.push(false);
    let s = [t];
    for (; s.length;) {
      let i = s.pop();
      if (r[i - n]) continue;
      r[i - n] = true;
      let o = e.getInstruction(i);
      if (!ge(o)) {
        for (let a of e.getDirectDependencies(o)) {
          if (a === n) return true;
          a < n || r[a - n] || s.push(a);
        }
      }
    }
    return false;
  }
  function s_(e, t, n) {
    return zh(e, (r) => {
      var p, f;
      let { chunk: s } = r, i = [], o = [];
      for (let d = 0; d < n.length; d++) {
        let y = s.getInstruction(n[d]).valueType;
        j(y)
          ? (i.push(2), o.push(s.SymbolicVar(y, t._argSymbols[d])))
          : (i.push(0), o.push(n[d]));
      }
      if (i.every((d) => d === 0)) return i;
      let a = Uh(r, t, o), u = Math.min(...o), c = Vr(s, a), l = [];
      for (let d = 0; d < o.length; d++) l[o[d]] = new Set([d]);
      for (let d = u; d <= a; d++) {
        if (!c[d]) continue;
        let y = s.getInstruction(d);
        if (!ge(y)) {
          if (y.type === 39 || y.type === 40 || y.type === 41) {
            let g = y.args[0], m = y.args[1], h = s.getInstruction(m);
            if (h.type === 23) {
              let x = h.endIndex, T = (p = l[x]) != null ? p : new Set();
              for (let b of l[g] || []) T.add(b);
              l[x] = T;
              continue;
            }
          }
          if (y.type === 48) l[d] = l[y.args[0]];
          else if (
            y.type === 37 && y.symbol === "count" && y.args.length === 1
          ) l[d] = l[y.args[0]];
          else if (
            !(y.type === 23 &&
              ((f = y.context) == null ? void 0 : f.type) === "implicit")
          ) {
            if (!(y.type === 44 && y.tag === "fc")) {
              for (let g of y.args) {
                let m = l[g] || [];
                for (let h of m) i[h] = 1;
              }
            }
          }
        }
      }
      return i;
    });
  }
  function lU(e, t, n) {
    let r = rd.empty(t);
    for (let s = 0; s < e.argNames.length; s++) {
      let i = e.argNames[s];
      n.includes(i) ? r.addLexicalBinding(i, s) : r.setFreeVariable(i, s);
    }
    return r;
  }
  var id = class id {
    constructor(t, n, r, s, i) {
      if (
        this.kind = t,
          this.substitutedGlobals = {
            ...n == null ? void 0 : n.substitutedGlobals,
          },
          this.functionBodySubstitutions = {
            ...n == null ? void 0 : n.functionBodySubstitutions,
          },
          t && r && i
      ) {
        let o = i.filter((a) => r.isGlobal(a));
        for (let a of o) {
          this.substitutedGlobals[a] || (this.substitutedGlobals[a] = t);
        }
        if (s && o.length > 0) {
          let a = this.recursionGroupKey(s.fnSymbols);
          this.functionBodySubstitutions[a] ||
            (this.functionBodySubstitutions[a] = {
              operator: t,
              substitutedGlobals: o,
            });
        }
      }
    }
    recursionGroupKey(t) {
      return [...t].sort().join(",");
    }
    getFunctionBodySubstitution(t) {
      let n = this.recursionGroupKey(t);
      return this.functionBodySubstitutions[n];
    }
    allowsRegressionParameterDependency() {
      if (!this.kind) return true;
      for (let t in this.substitutedGlobals) return false;
      return true;
    }
    getRegressionDependencyError(t) {
      if (this.allowsRegressionParameterDependency()) return;
      let [n, r] = Object.entries(this.substitutedGlobals)[0];
      return FP(n, t, r);
    }
    getKind() {
      return this.kind;
    }
    getSubstitutedGlobals() {
      return this.substitutedGlobals;
    }
    with(t, n, r) {
      return new id("with", this, t, n, r);
    }
    for(t, n, r) {
      return new id("for", this, t, n, r);
    }
  };
  id.root = new id();
  var im = id,
    WM = class {
      constructor(t, n) {
        this.definitions = t;
        this.baseCases = n;
        this.type = "type-inference";
        this.argTypes = {};
        this.returnTypes = {};
        this.baseCaseTypes = {};
        this.firstValidBaseCaseIdentifiers = {};
        this.stack = [];
        this.isUnconditionallyRecursive = false;
        this.fnSymbols = Object.keys(t);
      }
      registerFunctionCall(t, n) {
        this.argTypes[t] || (this.argTypes[t] = n);
      }
    };
  function HM(e, t, n, r, s, i) {
    return {
      policy: e,
      chunk: t,
      scope: n,
      substitutionContext: r,
      recursiveFunctionContext: s,
      selection: i,
    };
  }
  function Ci(e, t) {
    return { ...e, scope: t };
  }
  function zh(e, t) {
    let { chunk: n, scope: r } = e,
      s = n.instructionsLength(),
      i = r.childScopeWithChildGlobalCache(),
      o = Ci(e, i),
      a = t(o);
    return n.unsafelyTruncate(s), a;
  }
  function jh(e) {
    let {
        policy: t,
        frame: n,
        argNames: r,
        argTypes: s,
        selection: i,
        locals: o,
      } = e,
      a = new Ia({ argNames: r, argTypes: s }),
      u = lU(a, n, o);
    return HM(t, a, u, im.root, void 0, i);
  }
  function od(e, t) {
    let { policy: n, frame: r, argNames: s, argTypes: i } = e,
      o = am(t.userData),
      a = UM(r, t),
      { freeDependencies: u, updateSymbols: c } = a;
    if (s || (s = u), !i) {
      i = [];
      for (let f = 0; f < s.length; f++) i.push(Number);
    }
    let l;
    t.type === "FunctionDefinition" || t.type === "RecursiveFunctionBaseCase"
      ? l = t._argSymbols
      : l = [];
    let p = jh({
      policy: n,
      frame: r,
      argNames: s,
      argTypes: i,
      selection: o,
      locals: l,
    });
    try {
      KA(n, r, t.getScope()),
        Fe(p, t),
        e.coerceToNumber === "all" || se(p.chunk.getReturnType(), Restriction)
          ? p.chunk.coerceToNumericIfPossible()
          : e.coerceToNumber === "all-except-complex" &&
            p.chunk.coerceNonComplexToNumberIfPossible(),
        e.wrapInList && !j(p.chunk.getReturnType()) &&
        p.chunk.List([p.chunk.getReturnIndex()]),
        p.chunk.fuseBroadcast(),
        pU(p, t, c);
    } catch (f) {
      let d = f instanceof v ? f : U(f);
      d.setCursorContext(p.chunk.getCursorContext()), p.chunk.setError(d);
    }
    return p.chunk;
  }
  function pU(e, t, n) {
    let { chunk: r, scope: s } = e;
    if (t.type === "FunctionDefinition") {
      for (
        let o of n
      ) if (t._argSymbols.indexOf(o) !== -1 || t._symbol === o) throw my(o);
    }
    let i = [];
    for (let o of n) s.isDefined(o) || i.push(o);
    if (i.length) {
      let o = JM(e, i[0]).setDependencies(r.argNames.concat(i));
      throw r.isConstant() && r.getReturnType() === Action &&
        o.setActionValue(r.asValue()),
        o;
    }
  }
  function Fe(e, t) {
    let n;
    if (GO(), mU(e, t)) {
      FO(), n = e.chunk.copyInstruction(t.__IRCache.instruction);
    } else {
      VO();
      let r = e.chunk.instructionsLength();
      n = yU(e, t), n = dU(e, r, n), fU(e, t, n);
    }
    return e.chunk.setReturnIndex(n), n;
  }
  function dU(e, t, n) {
    let { chunk: r, scope: s } = e;
    if (n <= t) return n;
    let i = r.getInstruction(n);
    return Je(i)
      ? (r.unsafelyTruncate(Math.max(t, s.getMaxIndex() + 1)), po(r, i))
      : n;
  }
  function fU(e, t, n) {
    let { chunk: r, scope: s } = e, i = r.getInstruction(n);
    if (!Je(i)) return;
    let o = QA(s, t);
    o && (BO(), t.__IRCache = { keys: o, instruction: i });
  }
  function mU(e, t) {
    let { scope: n, substitutionContext: r } = e;
    if (!t.__IRCache) return false;
    let s = t.__IRCache.keys;
    for (let [i, o] of s) {
      if (n.isLocal(i) || n.isError(i)) return false;
      let a = n.getVisibleGlobalDefinition(i);
      if (
        a !== o ||
        a && a.type === "RegressionParameter" &&
          !r.allowsRegressionParameterDependency()
      ) return false;
    }
    return true;
  }
  function yU(e, t) {
    var u, c, l, p;
    let {
        policy: n,
        chunk: r,
        scope: s,
        substitutionContext: i,
        selection: o,
      } = e,
      a = t.type;
    switch (a) {
      case "Constant": {
        let d = t._constantValue, y = typeof d == "boolean" ? Bool : Number;
        return r.ConstantOfType(y, d);
      }
      case "RegressionParameter":
        return r.Constant(t._constantNode._constantValue);
      case "MixedNumber":
        return r.Constant(t._constantValue);
      case "ImaginaryUnit":
        return r.ImaginaryUnit();
      case "Negative":
        return r.Negative(qh(e, t, t.args));
      case "Add":
        return r.Add(yo(e, t, t.args));
      case "Subtract":
        return r.Subtract(yo(e, t, t.args));
      case "Multiply":
        return r.Multiply(yo(e, t, t.args));
      case "DotMultiply": {
        let [d, y] = yo(e, t, t.args);
        return (c = (u = a_(e, d, y)) != null
            ? u
            : eu(r, [d, y])
            ? a_(e, Ss(r, d), Ss(r, y), { forcePermitted: true })
            : void 0) != null
          ? c
          : r.Multiply([d, y]);
      }
      case "CrossMultiply": {
        let [d, y] = yo(e, t, t.args);
        return e.policy.is3dPolicy()
          ? gt(r, d, Vector3D) && gt(r, y, Vector3D)
            ? $u(r, [u_(e, Ss(r, d), Ss(r, y)), $o(r, d)])
            : gt(r, d, Point3D) && gt(r, y, Point3D)
            ? u_(e, d, y)
            : r.Multiply([d, y])
          : r.Multiply([d, y]);
      }
      case "Divide":
        return r.Divide(yo(e, t, t.args));
      case "Exponent": {
        let d = yo(e, t, t.args);
        if (n.isComplexEnabled()) {
          let y = t.args[1];
          if (RU(y)) {
            let g = r.getInstruction(d[0]).valueType;
            if (Ec(g, Number) || Ec(g, ListOfNumber)) return r.Exponent(d);
          }
          return r.NativeFunction("complexPow", d);
        } else return r.Exponent(d);
      }
      case "Comparator['=']":
      case "Comparator['>']":
      case "Comparator['<']":
      case "Comparator['>=']":
      case "Comparator['<=']":
        return r.Comparator(t.operator, yo(e, t, t.args));
      case "ComparatorChain": {
        let d = Ju(e, t, t.args), y = r.Comparator(t.symbols[0], [d[0], d[1]]);
        for (let g = 1; g < t.symbols.length; g++) {
          y = r.And([y, r.Comparator(t.symbols[g], [d[g], d[g + 1]])]);
        }
        return y;
      }
      case "Or":
        return r.Or(yo(e, t, t.args));
      case "PercentOf":
        return r.Divide([r.Multiply(yo(e, t, t.args)), r.Constant(100)]);
      case "ParenSeq":
        return IU(e, t);
      case "BareSeq":
        return PU(e, t);
      case "NamedCoordinateAccess": {
        let [d] = qh(e, t, t.args), y = t.symbol;
        switch (y) {
          case "x":
            return r.Slot(0, [d]);
          case "y":
            return r.Slot(1, [d]);
          case "z":
            return r.Slot(2, [d]);
          default: {
            let g = y;
            throw new Error(
              `Programming Error: unexpected named coordinate: '${g}'.`,
            );
          }
        }
      }
      case "Norm": {
        let d = qh(e, t, t.args)[0];
        return gt(r, d, Complex)
          ? Yh(r, d)
          : (p = (l = jM(e, d)) != null
              ? l
              : eu(r, [d])
              ? jM(e, Ss(r, d))
              : void 0) != null
          ? p
          : r.NativeFunction("abs", [d]);
      }
      case "UpdateRule": {
        let d = t._symbol;
        if (s.isLocal(d)) throw JM(e, d);
        let y = s.getVisibleGlobalDefinition(d);
        if (y !== void 0 && y.type !== "Assignment" && y.type !== "Slider") {
          throw JM(e, d);
        }
        let g = Fe(e, t.args[1]);
        return r.Action([d], [g]);
      }
      case "List":
      case "TableColumnValue": {
        if (t.getDependencies().length > 0) {
          return ms(t.args), r.List(Ju(e, t, t.args));
        }
        if (t.args.length === 0) {
          return sd(r, n, o, t, []), r.ConstantOfType(EmptyList, []);
        }
        {
          let d = r.instructionsLength(), y = [], g, m;
          ms(t.args);
          let h = true;
          for (let T of t.args) {
            let b = Fe(e, T), M = r.getInstruction(b);
            if (g === void 0) {
              if (g = M.valueType, !wn(g)) {
                throw vc([oe(g)], { blockExport: h });
              }
              m = vn(g);
            } else if (M.valueType !== g) {
              if (fu(g, M.valueType) !== void 0) {
                return r.unsafelyTruncate(d), r.List(Ju(e, t, t.args));
              }
              throw Hd({ blockExport: h });
            }
            if (M.type !== 1) {
              throw new Error(
                "Programming error: expected list with no dependencies to constant collapse.",
              );
            }
            y.push(M.value), r.unsafelyTruncate(d);
          }
          let x = YM(e.selection, t);
          if (
            e.selection && x !== void 0 && m !== void 0 &&
            x.positionWithinArg !== "empty-list"
          ) {
            let T = Ve(m);
            r.setCursorContext({
              type: "expression-arguments",
              expressionType: "List",
              argIndex: x.argIndex,
              argCount: t.args.length,
              isLastValidArg: false,
              positionWithinArg: x.positionWithinArg,
              allowedTypesForInsertedArg: [T],
            });
          }
          return r.ConstantOfType(m, y);
        }
      }
      case "ListAccess": {
        let d = Fe(e, t.args[0]), y = r.getInstruction(d);
        if (t.args[1].type === "Range" && t.args[1].args[1].length === 0) {
          if (!j(y.valueType)) {
            throw Bd([oe(y.valueType), oe(Number)], { blockExport: Je(y) });
          }
          let g = ur(r, d),
            m = QM(e, Fe(e, t.args[1].args[0]), r.List([g]), {
              stepMustBePositive: true,
            });
          return r.ListAccess([d, m]);
        } else {
          let g = Fe(e, t.args[1]), m = r.getInstruction(g);
          if (Uo(r, n, t, [d, g]), m.valueType === ListOfBool) {
            return r.NativeFunction("select", [d, g]);
          }
          if (m.valueType === Bool && j(y.valueType)) {
            let h = r.ConstantOfType(y.valueType, []);
            return r.Piecewise([g, d, h]);
          }
          return r.ListAccess([d, g]);
        }
      }
      case "Range": {
        let [d, y] = yo(e, t, t.args);
        return QM(e, d, y, { stepMustBePositive: false });
      }
      case "ListComprehension":
        return MU(e, t);
      case "Piecewise": {
        let d = Fe(e, t.args[0]),
          y = r.getInstruction(d),
          g = y.type === 1 && y.value === false,
          m = y.type === 1 && y.value === true,
          h;
        h = r.getWarning();
        let x = Fe(e, t.args[1]);
        g && r.restoreWarning(h), h = r.getWarning();
        let T = Fe(e, t.args[2]);
        m && r.restoreWarning(h);
        let b = [d, x, T];
        sd(e.chunk, e.policy, e.selection, t, b), Uo(e.chunk, e.policy, t, b);
        let M = r.getInstruction(b[1]),
          P = r.getInstruction(b[2]),
          D = _i(M.valueType, P.valueType) || _i(P.valueType, M.valueType);
        if (y.type === 1 && y.valueType === Bool && D) {
          let _ = b[y.value ? 1 : 2],
            L = r.getInstruction(_),
            w = M.valueType !== EmptyList ? M.valueType : P.valueType;
          return L.valueType === EmptyList && w !== EmptyList
            ? r.ConstantOfType(w, [])
            : _;
        }
        let S = M.valueType, O = j(S) ? Ve(S) : S;
        if (!D && Je(P) && P.valueType === Number && Ii(P.value) && io(O)) {
          if (se(M.valueType, Restriction)) {
            return r.NativeFunction("restriction", [
              r.And([b[0], r.NativeFunction("restrictionToBoolean", [b[1]])]),
            ]);
          }
          let _ = r.NanOfType(O);
          b = [b[0], b[1], _];
        }
        return r.Piecewise(b);
      }
      case "Restriction":
        return r.NativeFunction("restriction", qh(e, t, t.args));
      case "Ans":
      case "Identifier": {
        let d = t._symbol, y = t._errorSymbol;
        if (t.type === "Ans" && r.argNames.indexOf(d) !== -1) throw EP();
        let g = s.getSymbol(d);
        if (g !== void 0) return g;
        let m = s.getVisibleGlobalDefinition(d);
        if (m === void 0) {
          throw tt[d]
            ? tt[d].isFunction ? Li(y, e.policy) : _c(y)
            : e.recursiveFunctionContext &&
                e.recursiveFunctionContext.fnSymbols.includes(d)
            ? Iy(d)
            : new Error(`Programming Error: reached undefined symbol ${d}`);
        }
        if (s.isLocal(d) || m.isFunction) throw Iy(y);
        if (m.type === "RegressionParameter") {
          let x = i.getRegressionDependencyError(y);
          if (x) throw x;
        }
        let h;
        if (m instanceof Qr) h = Fe(e, m);
        else {
          let x = s.newLexicalScope(), T = Ci(e, x);
          h = Fe(T, m);
        }
        return s.cacheGlobal(d, h, m), h;
      }
      case "FunctionCall":
      case "SeededFunctionCall": {
        ms(t.args);
        let d = Ju(e, t, t.args);
        return ms(d), $h(e, t._symbol, t._errorSymbol, d, t.args);
      }
      case "Substitution":
        return vU(e, t);
      case "FunctionExponent": {
        let d = t.args[0]._symbol,
          y = s.getVisibleGlobalDefinition(d),
          g = s.getSymbol(d),
          m = g !== void 0 ? r.getInstruction(g) : void 0;
        return s.isLocal(d) && (m == null ? void 0 : m.type) === 4 ||
            y != null && y.isFunction
          ? Fe(
            e,
            new C.Exponent([new C.FunctionCall(d, [t.args[1]]), t.args[2]]),
          )
          : Fe(
            e,
            new C.Multiply([t.args[0], new C.Exponent([t.args[1], t.args[2]])]),
          );
      }
      case "FunctionFactorial": {
        let d = t.args[0]._symbol,
          y = s.getVisibleGlobalDefinition(d),
          g = s.getSymbol(d),
          m = g !== void 0 ? r.getInstruction(g) : void 0;
        return s.isLocal(d) && (m == null ? void 0 : m.type) === 4 ||
            y != null && y.isFunction
          ? Fe(
            e,
            new C.FunctionCall("\\factorial", [
              new C.FunctionCall(d, [t.args[1]]),
            ]),
          )
          : Fe(
            e,
            new C.Multiply([
              t.args[0],
              new C.FunctionCall("\\factorial", [t.args[1]]),
            ]),
          );
      }
      case "DotAccess": {
        let d = t.args[0],
          y = t.args[1],
          g = s.getVisibleGlobalDefinition(y._symbol);
        if (d.type === "Identifier" && d._symbol === "construction") {
          return OU(e, y);
        }
        if (
          (y.type === "Identifier" || y.type === "FunctionCall") &&
          (g != null && g.isFunction)
        ) {
          let m = y._symbol, h = y._errorSymbol;
          if (Af(g)) throw Gd(h);
          let x = y.type === "Identifier" ? [d] : [d].concat(y.args),
            T = Ju(e, t, x);
          return $h(e, m, h, T, x);
        } else if (y.type === "SeededFunctionCall") {
          let m = y._symbol,
            h = y._errorSymbol,
            x = [y.seed, d].concat(y.args.slice(1)),
            T = Ju(e, t, x);
          return $h(e, m, h, T, x);
        } else throw ks(".");
      }
      case "Seed":
        return r.ConstantOfType(SeedType, t._stringValue);
      case "ExtendSeed":
        return r.ExtendSeed(t.tag, yo(e, t, t.args));
      case "Integral": {
        let d = t._differential._symbol, y = s.childScope();
        y.setErrorIfAccessed(d, xP(d));
        let g = Ci(e, y),
          m = Fe(g, t.args[1]),
          h = Fe(g, t.args[2]),
          x = r.getInstruction(m),
          T = r.getInstruction(h),
          b = r.SymbolicVar(Number, d),
          M = s.childScope();
        M.addLexicalBinding(d, b);
        let P = Fe(Ci(e, M), t.args[3]);
        if (Uo(r, n, t, [m, h, P]), !um(r, P, b)) {
          return r.Multiply([P, r.Subtract([h, m])]);
        }
        let D = Jp(r, [m, h, P]);
        if (D !== void 0 && um(r, D, b)) throw LP(d);
        let S = D !== void 0 ? r.BeginBroadcast([D]) : void 0, O = m;
        S !== void 0 && j(x.valueType) && (O = Ea(r, m, S));
        let _ = h;
        S !== void 0 && j(T.valueType) && (_ = Ea(r, h, S));
        let L = r.getInstruction(P).valueType, w = j(L) ? Ve(L) : L, G;
        if ($l(w) && w !== Number) {
          let k = [], Z = w === Complex || w === Point ? 2 : 3;
          for (let F = 0; F < Z; F++) {
            let Y = r.BeginIntegral({ indexSymbol: d }, [O, _]),
              re = su(r, Y, b, P),
              Ee = r.getInstruction(re);
            S !== void 0 && j(Ee.valueType) && (re = Ea(r, re, S)),
              re = r.Slot(F, [re]);
            let he = r.EndIntegral([Y, re]);
            k.push(r.BlockVar(Number, [he]));
          }
          G = n_(r, w, k);
        } else {
          let k = r.BeginIntegral({ indexSymbol: d }, [O, _]),
            Z = su(r, k, b, P),
            F = r.getInstruction(Z);
          S !== void 0 && j(F.valueType) && (Z = Ea(r, Z, S));
          let Y = r.EndIntegral([k, Z]);
          G = r.BlockVar(Number, [Y]);
        }
        if (S !== void 0) {
          let k = r.EndBroadcast([S, G]);
          return r.BroadcastResult(vn(w), [k]);
        } else return G;
      }
      case "Sum":
      case "Product": {
        let d = t._index._symbol, y = t.type === "Sum", g = s.childScope();
        g.setErrorIfAccessed(d, y ? cP(d) : lP(d));
        let m = Ci(e, g), h = Fe(m, t.args[1]);
        h = zi(m.chunk, h);
        let x = Fe(m, t.args[2]);
        if (x = zi(m.chunk, x), !gt(r, h, Number)) {
          let me = zu(r, [h]), J = r.areAllArgsConstant([h]);
          throw y ? rT(me, { blockExport: J }) : oT(me, { blockExport: J });
        }
        if (!gt(r, x, Number)) {
          let me = zu(r, [x]), J = r.areAllArgsConstant([x]);
          throw y ? sT(me, { blockExport: J }) : aT(me, { blockExport: J });
        }
        let T = r.NativeFunction("round", [h]),
          b = r.NativeFunction("round", [x]),
          M = r.getInstruction(T),
          P = r.getInstruction(b);
        if (M.type === 1 && M.valueType === Number && !isFinite(V(M.value))) {
          throw y ? py() : dy();
        }
        if (P.type === 1 && P.valueType === Number && !isFinite(V(P.value))) {
          throw y ? py() : dy();
        }
        let D = r.SymbolicVar(Number, d), S = s.childScope();
        S.addLexicalBinding(d, D);
        let O = Fe(Ci(e, S), t.args[3]),
          _ = r.getInstruction(O).valueType,
          L = j(_) ? Ve(_) : _,
          G = (t.type === "Sum" ? ql : Jm).find((me) => Ec(L, me));
        if (G === void 0) {
          let me = zu(r, [O]), J = r.areAllArgsConstant([O]);
          throw y ? iT(me, { blockExport: J }) : uT(me, { blockExport: J });
        }
        if (!um(r, O, D)) {
          let me = r.Add([r.Subtract([b, T]), r.Constant(1)]);
          me = r.NativeFunction("listMax", [me, r.Constant(0)]);
          let J = y
            ? r.Multiply([O, me])
            : G === Complex
            ? r.NativeFunction("complexPow", [O, me])
            : r.RawExponent([O, me]);
          return r.Piecewise([
            r.Less([me, r.Constant(1 / 0)]),
            J,
            r.NanOfType(G),
          ]);
        }
        let k = Jp(r, [T, b, O]);
        if (k !== void 0 && um(r, k, D)) throw y ? AP(d) : _P(d);
        let Z = k !== void 0 ? r.BeginBroadcast([k]) : void 0, F = T;
        Z !== void 0 && j(M.valueType) && (F = Ea(r, T, Z));
        let Y = b;
        Z != null && j(P.valueType) && (Y = Ea(r, b, Z));
        let re = y
            ? r.ZeroOfType(G)
            : G === Complex
            ? r.NativeFunction("complex", [r.Constant(1), r.Constant(0)])
            : r.Constant(1),
          Ee = r.BeginLoop({ type: y ? "sum" : "product", indexSymbol: d }, [
            F,
            Y,
            re,
          ]),
          he = r.BlockVar(G, [Ee]),
          K = su(r, Ee, D, O),
          Oe = r.getInstruction(K);
        Z !== void 0 && j(Oe.valueType) && (K = Ea(r, K, Z));
        let te = y ? r.Add([he, K]) : r.Multiply([he, K]),
          Ze = r.EndLoop([Ee, te]),
          dt = r.BlockVar(G, [Ze]);
        if (Z !== void 0) {
          let me = r.EndBroadcast([Z, dt]);
          return r.BroadcastResult(vn(G), [me]);
        } else return dt;
      }
      case "Derivative": {
        let d = t._symbol,
          y = Fe(e, new C.Identifier(d)),
          g = fl(r, y),
          m = r.getInstruction(g),
          h = om(m.valueType);
        if (!h) throw mT(d, zu(r, [g]), { blockExport: Je(m) });
        let x, T, b = false;
        if ((m.type === 2 || m.type === 3) && m.valueType === Number) {
          x = e, T = g;
        } else {
          let S = s.childScope();
          T = r.SymbolicVar(m.valueType),
            S.addDynamicBinding(d, T),
            b = true,
            x = Ci(e, S);
        }
        let M = 1;
        for (
          ;
          t.args[0].type === "Derivative" && t.args[0]._symbol === t._symbol;
        ) M += 1, t = t.args[0];
        let D = Gr(r, Fe(x, t.args[0]));
        for (let S = 0; S < M; S++) D = kh(r, D, T, h);
        return T === g ? D : (b && r.derivativeMaps.pruneIP(T), su(r, g, T, D));
      }
      case "Prime": {
        let d = t.args[0];
        if (s.isLocal(d._symbol)) throw Py(d._symbol);
        let y = s.getVisibleGlobalDefinition(d._symbol);
        if (!y) throw Dy(d._symbol);
        if (!y.isFunction) throw Py(d._symbol);
        let g = Fe(e, d.args[0]),
          m = fl(r, g),
          h = r.getInstruction(m),
          x = om(h.valueType);
        if (!x) throw yT(d._symbol, zu(r, [m]), { blockExport: Je(h) });
        let T = false, b;
        (h.type === 2 || h.type === 3) && h.valueType === Number
          ? b = m
          : (b = r.SymbolicVar(h.valueType), T = true);
        let M, P;
        if (d._symbol === "logbase") {
          if (d.args.length !== 2) throw Nc();
          M = [b, Fe(e, d.args[1])], P = [d.args[0], d.args[1]];
        } else {
          if (d.args.length !== 1) throw Nc();
          M = [b], P = [d.args[0]];
        }
        let S = Gr(r, $h(e, d._symbol, d._errorSymbol, M, P));
        for (let O = 0; O < t.order; O++) S = kh(r, S, b, x);
        return b === m ? S : (T && r.derivativeMaps.pruneIP(b), su(r, m, b, S));
      }
      case "Slider":
        return e.chunk.Constant(
          t.getConcreteTree(n, s.frame).asCompilerValue(),
        );
      case "Assignment":
        return qM(r, e.selection, t), Fe(e, t._expression);
      case "FunctionDefinition": {
        let d = t;
        if (qM(r, e.selection, d), d.recursionInfo) {
          return P_(e, d, d.recursionInfo);
        }
        {
          let y = e.policy.isRecursionEnabled() &&
              e.policy.assignmentForbidden(d._symbol),
            g = s.childScope();
          return g.setErrorIfAccessed(
            d._symbol,
            Rc([d._symbol], { suggestAlternativeFunctionName: y }),
          ),
            Fe(Ci(e, g), t._expression);
        }
      }
      case "RecursiveFunctionBaseCase": {
        let d = s.childScope(), y = t;
        return d.setErrorIfAccessed(y._symbol, CI(y._symbol)),
          Fe(Ci(e, d), t._expression);
      }
      case "Construction":
        throw ks("construction");
      default:
        let f = a;
        throw new Error(`Programming error, unimplemented node type ${f}`);
    }
  }
  function qh(e, t, n) {
    let r = [Fe(e, n[0])];
    return sd(e.chunk, e.policy, e.selection, t, r),
      Uo(e.chunk, e.policy, t, r),
      r;
  }
  function yo(e, t, n) {
    let r = [Fe(e, n[0]), Fe(e, n[1])];
    return sd(e.chunk, e.policy, e.selection, t, r),
      Uo(e.chunk, e.policy, t, r),
      r;
  }
  function Yh(e, t) {
    return e.NativeFunction("hypot", [e.Slot(0, [t]), e.Slot(1, [t])]);
  }
  function m_(e, t) {
    return gt(e, t, Number) ? t : e.Slot(0, [t]);
  }
  function y_(e, t) {
    return gt(e, t, Number) ? e.Constant(0) : e.Slot(1, [t]);
  }
  function g_(e, t) {
    return gt(e, t, Number) ? t : e.NativeFunction("complex", [
      e.Slot(0, [t]),
      e.Negative([e.Slot(1, [t])]),
    ]);
  }
  function Tl(e, t) {
    return h_(e, t, "mean");
  }
  function h_(e, t, n) {
    return Ui(e, t, n, [{
      match: _r(Te, 0),
      build: () => e.NativeFunction(n, t),
    }, {
      match: _r(Complex, 1),
      build: () =>
        e.NativeFunction("complex", [
          e.NativeFunction(n, t.map((r) => m_(e, r))),
          e.NativeFunction(n, t.map((r) => y_(e, r))),
        ]),
    }, {
      match: _r(Point, 1),
      build: () => {
        let r = (s) => e.NativeFunction(n, t.map((i) => e.Slot(s, [i])));
        return e.TupleOfType(Point, [r(0), r(1)]);
      },
    }, {
      match: _r(Point3D, 1),
      build: () => {
        let r = (s) => e.NativeFunction(n, t.map((i) => e.Slot(s, [i])));
        return e.TupleOfType(Point3D, [r(0), r(1), r(2)]);
      },
    }]);
  }
  function cm(e, t) {
    return Ui(e, t, "varp", [{
      match: _r(Te, 0),
      build: () => e.NativeFunction("varp", t),
    }, {
      match: _r(Complex, 1),
      build: () => {
        let n = Tl(e, t);
        return Tl(e, t.map((r) => gU(e, e.Subtract([r, n]))));
      },
    }]);
  }
  function i_(e, t) {
    return Xh(e, t) ? lm(e, t, "var") : Ui(e, t, "var", [{
      match: _r(Te, 1),
      build: () => e.NativeFunction("var", t),
    }, {
      match: _r(Complex, 1),
      build: () => {
        let n = e.NativeFunction("count", t);
        return e.Divide([
          e.Multiply([cm(e, t), n]),
          e.Subtract([n, e.Constant(1)]),
        ]);
      },
    }]);
  }
  function o_(e, t, n) {
    let r = e.BeginBroadcast([n]),
      s = e.InboundsListAccess([t, r]),
      i = e.EndBroadcast([r, s]);
    return e.BroadcastResult(vn(e.getInstruction(s).valueType), [i]);
  }
  function XM(e, t) {
    return Ui(e, t, "covp", [{
      match: [ro, ro],
      noBroadcast: true,
      build: () => e.NativeFunction("covp", t),
    }, {
      match: [ListOfComplex, ListOfComplex],
      noBroadcast: true,
      build: () => {
        let n = e.NativeFunction("listMin", [ur(e, t[0]), ur(e, t[1])]),
          r = o_(e, t[0], n),
          s = o_(e, t[1], n),
          i = Tl(e, [r]),
          o = Tl(e, [s]);
        return Tl(e, [
          e.Multiply([e.Subtract([r, i]), g_(e, e.Subtract([s, o]))]),
        ]);
      },
    }]);
  }
  function gU(e, t) {
    return e.Add([
      e.Multiply([e.Slot(0, [t]), e.Slot(0, [t])]),
      e.Multiply([e.Slot(1, [t]), e.Slot(1, [t])]),
    ]);
  }
  function jM(e, t) {
    let n = e.chunk;
    return gt(n, t, Point3D)
      ? n.NativeFunction("hypot", [
        n.Slot(0, [t]),
        n.NativeFunction("hypot", [n.Slot(1, [t]), n.Slot(2, [t])]),
      ])
      : gt(n, t, Point)
      ? n.NativeFunction("hypot", [n.Slot(0, [t]), n.Slot(1, [t])])
      : void 0;
  }
  function a_(e, t, n, { forcePermitted: r } = { forcePermitted: false }) {
    let s = e.chunk;
    return (r || e.policy.is3dProduct()) && gt(s, t, Point) && gt(s, n, Point)
      ? s.Add([
        s.Multiply([s.Slot(0, [t]), s.Slot(0, [n])]),
        s.Multiply([s.Slot(1, [t]), s.Slot(1, [n])]),
      ])
      : (r || e.policy.is3dProduct()) && gt(s, t, Point3D) && gt(s, n, Point3D)
      ? s.Add([
        s.Add([
          s.Multiply([s.Slot(0, [t]), s.Slot(0, [n])]),
          s.Multiply([s.Slot(1, [t]), s.Slot(1, [n])]),
        ]),
        s.Multiply([s.Slot(2, [t]), s.Slot(2, [n])]),
      ])
      : void 0;
  }
  function u_(e, t, n) {
    let r = e.chunk,
      s = r.Slot(0, [t]),
      i = r.Slot(1, [t]),
      o = r.Slot(2, [t]),
      a = r.Slot(0, [n]),
      u = r.Slot(1, [n]),
      c = r.Slot(2, [n]);
    return r.TupleOfType(Point3D, [
      r.Subtract([r.Multiply([i, c]), r.Multiply([o, u])]),
      r.Subtract([r.Multiply([o, a]), r.Multiply([s, c])]),
      r.Subtract([r.Multiply([s, u]), r.Multiply([i, a])]),
    ]);
  }
  function Ju(e, t, n) {
    let r = [];
    for (let s of n) r.push(Fe(e, s));
    return sd(e.chunk, e.policy, e.selection, t, r),
      Uo(e.chunk, e.policy, t, r),
      r;
  }
  function $h(e, t, n, r, s) {
    var f;
    let {
      chunk: i,
      scope: o,
      recursiveFunctionContext: a,
      substitutionContext: u,
      policy: c,
    } = e;
    if (t = _g(c, t), a && a.type === "type-inference" && a.definitions[t]) {
      let d = u.getFunctionBodySubstitution(a.fnSymbols);
      if (d && d.substitutedGlobals.length > 0) {
        throw BP(d.operator, d.substitutedGlobals[0], t);
      }
      a.registerFunctionCall(t, r.map((m) => i.getInstruction(m).valueType));
      let y = a.definitions[t];
      if (y instanceof v) throw y;
      let g = M_(e, a, y, r);
      return i.SymbolicVar(g.returnType);
    }
    let l = o.getSymbol(t);
    if (l !== void 0) {
      let d = i.getInstruction(l);
      if (d.type === 4) {
        if (d.signature.argTypes.length !== r.length) {
          throw Ao(t, d.signature.argTypes.length, r.length, {
            includeUsageExample: true,
          });
        }
        for (let y = 0; y < r.length; y++) {
          let g = i.getInstruction(r[y]).valueType, m = d.signature.argTypes[y];
          if (!se(g, m)) {
            throw Lx(y, at(m), at(g), {
              blockExport: Je(i.getInstruction(r[y])),
            });
          }
        }
        return i.FunctionCall([l, ...r]);
      } else if (se(d.valueType, Transformation)) {
        return Wh(e.chunk, [l, ...r], n, true);
      }
      if (r.length >= 1) return f_(e, t, s, r);
      throw d.type === 2 ? Dy(n) : d.valueType === Distribution ? Vy(n) : Fy(n);
    }
    let p = o.getVisibleGlobalDefinition(t);
    if (p === void 0 || !p.isFunction) {
      if ((f = tt[t]) != null && f.isFunction) {
        throw t === "logbase" && o.isGlobal("ln") && o.isGlobal("log")
          ? MP()
          : Li(n, e.policy);
      }
      if (p) {
        let d = Fe(e, p);
        if (i.getInstruction(d).valueType === Distribution) throw Vy(n);
        if (se(i.getInstruction(d).valueType, Transformation)) {
          return Wh(e.chunk, [d, ...r], n, true);
        }
      }
      if (r.length >= 1) return f_(e, t, s, r);
      throw p
        ? Fy(n)
        : new Error(`Programming Error: reached undefined symbol ${t}`);
    }
    if (Af(p)) {
      if (r.length !== p._argSymbols.length) {
        throw Ao(n, p._argSymbols.length, r.length, {
          includeUsageExample: true,
        });
      }
      if (
        p.getDependencies().includes("globalRandomSeed") &&
        c.shouldIncludeFunctionParametersInRandomSeed()
      ) {
        let d = s_(e, p, r), y = r.filter((g, m) => d[m] === 2);
        if (y.length > 0) {
          let g = Jp(i, y);
          if (g === void 0) {
            throw U("Programming error: expected list length to be defined");
          }
          let m = i.BeginBroadcast([g]), h = [];
          for (let M = 0; M < r.length; M++) {
            d[M] === 2 ? h.push(Ea(i, r[M], m)) : h.push(r[M]);
          }
          let x = Uh(e, p, h, s),
            T = i.EndBroadcast([m, x]),
            b = i.getInstruction(x).valueType;
          if (wn(b)) return i.BroadcastResult(vn(b), [T]);
        }
      }
      return Uh(e, p, r, s);
    } else {
      if (Fo.hasOwnProperty(t)) return xU(e, t, n, r, s);
      if (Bn.hasOwnProperty(t)) return pi(e, t, r);
      throw Li(n, e.policy);
    }
  }
  function Uh(e, t, n, r) {
    let { scope: s } = e, i = s.newLexicalScope().childScope();
    for (let a = 0; a < t._argSymbols.length; a++) {
      i.addLexicalBinding(t._argSymbols[a], n[a], r && r[a]);
    }
    let o = Ci(e, i);
    return t.recursionInfo ? P_(o, t, t.recursionInfo) : Fe(o, t._expression);
  }
  function hU(e, t) {
    let n = $o(e, t), r = e.Add([n, Ss(e, t)]);
    return e.NativeFunction("segment", [n, r]);
  }
  function pi(e, t, n) {
    let { chunk: r } = e,
      s = Bn[t],
      i = n.length,
      { minArity: o, maxArity: a } = s;
    if (i > a || i < o) throw U("Unexpected arity mismatch");
    let u = b_(r, n, s);
    switch (s.tag) {
      case "default":
      case "reducer":
      case "doubleReducer":
      case "parameterizedReducer":
      case "color":
      case "never-broadcast":
        return r.NativeFunction(t, u);
      case "trig": {
        let c = Fe(e, new C.Identifier("trigAngleMultiplier")),
          l = r.Multiply([u[0], c]);
        return r.NativeFunction(t, [l]);
      }
      case "trig2": {
        let c = Fe(e, new C.Identifier("trigAngleMultiplier")),
          l = r.Multiply([u[1], c]);
        return r.NativeFunction(t, [u[0], l]);
      }
      case "inverseTrig": {
        let c = Fe(e, new C.Identifier("trigAngleMultiplier")),
          l = r.NativeFunction(t, u);
        return r.Divide([l, c]);
      }
      default: {
        let c = s.tag;
        throw new Error(`Programming Error: unexpected tag ${c}`);
      }
    }
  }
  function b_(e, t, { minArity: n, defaultArguments: r }) {
    if (!r || !(t.length - n < r.length)) return t;
    let s = t.slice();
    for (; s.length - n < r.length;) s.push(e.copyInstruction(r[s.length - n]));
    return s;
  }
  function bU(e, t, n) {
    let r = [n.noBroadcast ? kt(n.match) : Ae(n.match)];
    return lh(r, t.map((s) => e.getInstruction(s).valueType), 0).length > 0;
  }
  function Ui(e, t, n, r) {
    let s = r.find((i) => bU(e, t, i));
    if (!s) {
      if (typeof n == "string") {
        throw Hs(n, Pa(e, t), { blockExport: e.areAllArgsConstant(t) });
      }
      return n(e, t);
    }
    return s.build(e, t);
  }
  function c_(e, t) {
    if (t.length !== 2) throw U("Can only take the midpoint of two points");
    let n = e.Constant(Se(1, 2));
    return e.Multiply([n, e.Add(t)]);
  }
  function xU(e, t, n, r, s) {
    var y, g;
    let { chunk: i, policy: o } = e,
      a = Fo[t],
      { minArity: u, maxArity: c } = a,
      l = r.length;
    if (l < u || l > c) {
      throw kf(t)
        ? L0(i, {
          symbol: t,
          errorSymbol: n,
          argsWithoutSeed: r,
          signatures: a.getSignatures(o),
          minArity: u,
          providedArgs: r,
          builtInTag: void 0,
          defaultArgumentCount:
            (g = (y = a.defaultArguments) == null ? void 0 : y.length) != null
              ? g
              : 0,
          isDotCall: false,
          maxArity: c,
        })
        : new Error("Programming Error: unexpected arity mismatch");
    }
    let p;
    if (t === "cdf") l === 2 ? p = [r[0], i.Constant(-1 / 0), r[1]] : p = r;
    else if (t === "random") {
      if (
        l === 1 ||
        l < 4 && !j(i.getInstruction(r[1]).valueType) &&
          i.getInstruction(r[1]).valueType !== Distribution
      ) {
        let m = i.Distribution("uniformdist", [i.Constant(0), i.Constant(1)]);
        p = [r[0], m].concat(r.slice(1));
      } else p = r;
    } else p = b_(i, r, a);
    let f = Rf(o, t);
    if (t === "join") {
      let m = [];
      for (let x of p) m.push(i.getInstruction(x).valueType);
      let h = qO(m);
      f = [kt({ type: "variadic", initial: [h, h], rest: h })];
    }
    if (f) {
      let m = F0(i, p, f);
      m.didCoerce && (p = m.args);
    }
    function d(m, h = n) {
      return Ui(i, p, h, m);
    }
    switch (t) {
      case "length":
        if (o.isGeometryEnabled() || o.is3dPolicy()) {
          let m = p[0];
          return d([{
            match: [Segment3D],
            build: () => {
              let h = i.Constant(0), x = i.Constant(1);
              return i.NativeFunction("distanceThreeD", [
                i.NativeFunction("segmentThreeDGlider", [m, h]),
                i.NativeFunction("segmentThreeDGlider", [m, x]),
              ]);
            },
          }, {
            match: [Segment],
            build: () => {
              let h = i.Constant(0), x = i.Constant(1);
              return i.NativeFunction("distance", [
                i.NativeFunction("segmentGlider", [m, h]),
                i.NativeFunction("segmentGlider", [m, x]),
              ]);
            },
          }, {
            match: [Arc],
            build: () => {
              let h = i.NativeFunction("abs", [
                  i.NativeFunction("arcOmega", [p[0]]),
                ]),
                { radius: x, startPoint: T } = CU(i, p[0]),
                b = i.NativeFunction("arcThirdPoint", [p[0]]);
              return i.Piecewise([
                i.Equal([h, i.Constant(0)]),
                i.NativeFunction("distance", [T, b]),
                i.Multiply([x, h]),
              ]);
            },
          }, { match: [xx], build: () => jM(e, Ss(i, m)) }]);
        } else return i.NativeFunction("count", p);
      case "round":
        return d([
          { match: [Te], build: () => i.NativeFunction("round", p) },
          {
            match: [Te, Number],
            build: () => {
              let m = i.NativeFunction("round", [p[1]]),
                h = i.RawExponent([i.Constant(10), m]);
              return i.Divide([
                i.NativeFunction("round", [i.Multiply([p[0], h])]),
                h,
              ]);
            },
          },
          {
            match: [Complex],
            build: () => i.NativeFunction("complexRound", p),
          },
          {
            match: [Complex, Number],
            build: () => {
              let m = i.NativeFunction("round", [p[1]]),
                h = i.RawExponent([i.Constant(10), m]);
              return i.Divide([
                i.NativeFunction("complexRound", [i.Multiply([p[0], h])]),
                h,
              ]);
            },
          },
        ]);
      case "abs":
        return d([{ match: [Te], build: () => i.NativeFunction(t, p) }, {
          match: [Complex],
          build: () => Yh(i, p[0]),
        }]);
      case "real":
        return m_(i, p[0]);
      case "imag":
        return y_(i, p[0]);
      case "conj":
        return g_(i, p[0]);
      case "exp":
      case "sin":
      case "cos":
      case "tan":
      case "sinh":
      case "cosh":
      case "tanh":
      case "sec":
      case "csc":
      case "cot":
      case "sech":
      case "csch":
      case "coth":
      case "arccot":
      case "arcsinh":
      case "arccsch":
      case "floor":
      case "ceil":
        return d([{ match: [Te], build: () => pi(e, t, p) }, {
          match: [Complex],
          build: () => pi(e, Ip[t], p),
        }]);
      case "arctan":
        return d([
          {
            match: [Te],
            build: () => pi(e, t, p.concat(i.Constant(1))),
          },
          { match: [Number, Number], build: () => pi(e, t, p) },
          { match: [Complex], build: () => pi(e, Ip[t], p) },
        ]);
      case "mod":
        return d([{ match: [Te, Te], build: () => pi(e, t, p) }, {
          match: [Complex, Complex],
          build: () => pi(e, Ip[t], p),
        }]);
      case "nthroot":
        return i.Exponent([p[0], i.Divide([i.Constant(1), p[1]])]);
      case "complexNthRoot":
        return i.NativeFunction("complexPow", [
          p[0],
          i.Divide([i.Constant(1), p[1]]),
        ]);
      case "sign":
        return d([{ match: [Te], build: () => pi(e, t, p) }, {
          match: [Complex],
          build: () => {
            let m = p[0];
            return i.Piecewise([
              i.Equal([m, i.ZeroOfType(Complex)]),
              m,
              i.Divide([m, Yh(i, m)]),
            ]);
          },
        }]);
      case "midpoint":
        return d([
          {
            match: [Segment],
            build: () => {
              let m = i.Constant(Se(1, 2));
              return i.NativeFunction("segmentGlider", [p[0], m]);
            },
          },
          {
            match: [Segment3D],
            build: () => {
              let m = i.Constant(Se(1, 2));
              return i.NativeFunction("segmentThreeDGlider", [p[0], m]);
            },
          },
          { match: [Point, Point], build: c_ },
          { match: [Point3D, Point3D], build: c_ },
        ]);
      case "circle":
        return d([{
          match: [Point, Segment],
          build: () => {
            let m = i.Constant(0), h = i.Constant(1);
            return i.NativeFunction("circle", [
              p[0],
              i.NativeFunction("distance", [
                i.NativeFunction("segmentGlider", [p[1], m]),
                i.NativeFunction("segmentGlider", [p[1], h]),
              ]),
            ]);
          },
        }, {
          match: [Point, Point],
          build: () =>
            i.NativeFunction("circle", [p[0], i.NativeFunction("distance", p)]),
        }, {
          match: [Point, Number],
          build: () => i.NativeFunction("circle", p),
        }]);
      case "segment":
        return d(Xf("segment", "segmentThreeD"));
      case "vector":
        return d(Xf("vector", "vectorThreeD"));
      case "sphere":
        return d([{
          match: [Point3D, Number],
          build: (m, h) => m.NativeFunction("sphere", h),
        }, {
          match: [Point, Number],
          build: (m, h) =>
            m.NativeFunction("sphere", [
              m.TupleOfType(Point3D, [
                m.Slot(0, [h[0]]),
                m.Slot(1, [h[0]]),
                m.Constant(0),
              ]),
              h[1],
            ]),
        }]);
      case "distance":
        return d(Xf("distance", "distanceThreeD"));
      case "center":
        return d([{
          match: [Circle],
          build: () => i.NativeFunction("center", [p[0]]),
        }, {
          match: [Arc],
          build: () => i.NativeFunction("arcCenter", [p[0]]),
        }]);
      case "radius":
        return d([{
          match: [Circle],
          build: () => i.NativeFunction("radius", [p[0]]),
        }, {
          match: [Arc],
          build: () =>
            i.NativeFunction("distance", [
              i.NativeFunction("arcFirstPoint", [p[0]]),
              i.NativeFunction("arcCenter", [p[0]]),
            ]),
        }]);
      case "glider":
        return x_(e.chunk, p);
      case "intersection":
      case "strictintersection": {
        let m = 0;
        t === "strictintersection" &&
          ((gt(i, p[0], Segment) || gt(i, p[0], Arc)) && (m += 3),
            (gt(i, p[1], Segment) || gt(i, p[1], Arc)) && (m += 12),
            gt(i, p[0], Ray) && (m += 1),
            gt(i, p[1], Ray) && (m += 4));
        let h = SU(e, s, p), x = h && Ta(h);
        if (!h || !x) return ZM(i, p, m);
        let T = Fe(e, new C.Identifier(x)), b = zo(h);
        return b !== void 0 && (T = i.ListAccess([T, i.Constant(b)])),
          i.NativeFunction("chooseNonIncidentPoint", [
            T,
            ZM(i, [p[0], p[1]], m),
            ZM(i, [p[1], p[0]], m << 2 & 12 | m >> 2 & 3),
          ]);
      }
      case "parallel":
      case "perpendicular":
        return d([{
          match: [Qm, Point],
          build: () => {
            let h = [Zh(i, p[0]), p[1]];
            return i.NativeFunction(t, h);
          },
        }]);
      case "anglebisector":
        return d([{
          match: [AngleMarker],
          build: () => i.NativeFunction("anglebisector", p),
        }, {
          match: [DirectedAngleMarker],
          build: () => i.NativeFunction("directedanglebisector", p),
        }]);
      case "start":
        return $o(i, p[0]);
      case "end":
        return i.Add([$o(i, p[0]), Ss(i, p[0])]);
      case "translate":
      case "reflect":
      case "rotate":
      case "dilate":
        return DU(e, t, p);
      case "apply":
        return Wh(i, p, n, false);
      case "normaldist":
      case "tdist":
      case "poissondist":
      case "binomialdist":
      case "uniformdist":
        return i.Distribution(t, p);
      case "median":
      case "quantile":
        return Xh(i, r) ? lm(i, p, t) : pi(e, t, r);
      case "stdev":
        return Xh(i, r)
          ? lm(i, p, t)
          : d([{ match: _r(Te, 1), build: () => pi(e, t, r) }, {
            match: _r(Complex, 1),
            build: () => i.NativeFunction("sqrt", [i_(i, p)]),
          }]);
      case "stdevp":
        return d([{ match: _r(Te, 1), build: () => pi(e, t, r) }, {
          match: _r(Complex, 1),
          build: () => i.NativeFunction("sqrt", [cm(i, p)]),
        }]);
      case "var":
        return i_(i, p);
      case "cov":
        return d([{
          match: [ro, ro],
          noBroadcast: true,
          build: () => pi(e, t, r),
        }, {
          match: [ListOfComplex, ListOfComplex],
          noBroadcast: true,
          build: () => {
            let m = i.NativeFunction("listMin", [ur(i, p[0]), ur(i, p[1])]);
            return i.Divide([
              i.Multiply([XM(i, p), m]),
              i.Subtract([m, i.Constant(1)]),
            ]);
          },
        }]);
      case "corr":
        return d([{
          match: [ro, ro],
          noBroadcast: true,
          build: () => pi(e, t, r),
        }, {
          match: [ListOfComplex, ListOfComplex],
          noBroadcast: true,
          build: () =>
            i.Divide([
              XM(i, p),
              i.NativeFunction("sqrt", [
                i.Multiply([cm(i, [p[0]]), cm(i, [p[1]])]),
              ]),
            ]),
        }]);
      case "mad":
        return d([{ match: _r(Te, 1), build: () => pi(e, t, r) }, {
          match: _r(Complex, 1),
          build: () => {
            let m = Tl(i, p);
            return Tl(i, p.map((h) => Yh(i, i.Subtract([h, m]))));
          },
        }]);
      case "pdf":
      case "cdf":
        return lm(i, p, t);
      case "varp":
        return cm(i, p);
      case "covp":
        return XM(i, p);
      case "total":
      case "mean":
        return t === "mean" && Xh(i, r) ? lm(i, p, t) : h_(i, p, t);
      case "lcm":
      case "gcd":
        return d([{ match: _r(Te, 1), build: () => i.NativeFunction(t, p) }, {
          match: _r(Complex, 1),
          build: () => {
            let m;
            switch (t) {
              case "lcm":
                m = "complexLCM";
                break;
              case "gcd":
                m = "complexGCD";
                break;
            }
            return i.NativeFunction(m, p);
          },
        }]);
      case "min":
        return d([{
          match: [Number, Number],
          build: () => i.NativeFunction("min", p),
        }, {
          match: _r(Number, 0),
          build: () => i.NativeFunction("listMin", p),
        }]);
      case "max":
        return d([{
          match: [Number, Number],
          build: () => i.NativeFunction("max", p),
        }, {
          match: _r(Number, 0),
          build: () => i.NativeFunction("listMax", p),
        }]);
      case "random": {
        let m = p[0],
          h = p[1],
          x = i.getInstruction(p[0]),
          T = i.getInstruction(h);
        if (x.valueType !== SeedType) {
          throw U(`Unexpected value type for seed arg: ${x.valueType}`);
        }
        if (T.valueType === ListOfDistribution) throw YT();
        let b;
        if (j(T.valueType)) b = t_;
        else {
          if (T.type !== 42 || T.valueType !== Distribution) {
            throw U('Expected distribution argument to "random"');
          }
          b = Sa[T.symbol][t];
        }
        if (p.length > 2) {
          let M = p[2], P = i.getInstruction(M);
          if (P.valueType !== Number) {
            throw U(
              `Expected numSamples argument to random() to be a number but got ${P.valueType}`,
            );
          }
          if (p.length === 4) {
            if (i.getInstruction(p[3]).valueType !== Number) {
              throw U(
                `Expected userSeed argument to random() to be a number but got ${P.valueType}`,
              );
            }
            m = i.ExtendSeed("us", [m, p[3]]);
          }
          let D = i.Constant(1),
            S = i.NativeFunction("round", [
              i.NativeFunction("validateSampleCount", [M]),
            ]),
            O = i.BeginBroadcast([S]);
          m = i.ExtendSeed("lc", [m, i.Subtract([O, D])]);
          let _ = b(i, h, [m]), L = i.EndBroadcast([O, _]);
          return i.BroadcastResult(vn(i.getInstruction(_).valueType), [L]);
        }
        return b(i, h, [m]);
      }
      case "shuffle": {
        let m = p[0], h = p[1], x = p[2];
        if (
          !j(i.getInstruction(h).valueType) ||
          x !== void 0 && i.getInstruction(x).valueType !== Number
        ) throw U(`Unexpected args for "${t}"`);
        return x !== void 0 && (m = i.ExtendSeed("us", [m, x])),
          i.NativeFunction("shuffle", [m, h]);
      }
      case "sort":
        return d([{
          match: [ListOfNumber],
          noBroadcast: true,
          build: () => l_(e, p[0], p[0]),
        }, {
          match: [ii, ListOfNumber],
          noBroadcast: true,
          build: () => l_(e, p[0], p[1]),
        }]);
      case "join": {
        let m = [], h = true;
        for (let w of p) {
          let G = i.getInstruction(w);
          Je(G) || (h = false);
          let k = G.valueType;
          if (k !== EmptyList) {
            if (j(k)) m.push({ isList: true, index: w, elementType: Ve(k) });
            else if (wn(k)) m.push({ isList: false, index: w, elementType: k });
            else {throw Hs(n, Pa(i, r), {
                blockExport: i.areAllArgsConstant(p),
              });}
          }
        }
        if (m.length === 0) return i.ConstantOfType(EmptyList, []);
        for (let w of m) {
          if (w.elementType !== m[0].elementType) {
            throw Hs(n, Pa(i, r), { blockExport: i.areAllArgsConstant(p) });
          }
        }
        if (h) {
          let w = [];
          for (let G of m) {
            let k = i.getInstruction(Gr(i, G.index));
            gO(k), G.isList ? w.push(...k.value) : w.push(k.value);
          }
          return i.ConstantOfType(vn(m[0].elementType), w);
        }
        let x = i.Constant(0), T = i.Constant(1), b = {};
        for (let w of m) {
          w.isList && b[w.index] === void 0 && (b[w.index] = ur(i, w.index));
        }
        let M = i.NativeFunction(
            "total",
            m.map((w) => w.isList ? b[w.index] : T),
          ),
          P = i.BeginBroadcast([M]),
          D = x,
          S = [],
          O = [];
        for (let w of m) {
          let G = w.isList
            ? i.ListAccess([w.index, i.Subtract([P, D])])
            : w.index;
          if (O.push(G), w !== m[m.length - 1]) {
            let k = w.isList ? b[w.index] : T;
            D = i.Add([D, k]), S.push(i.LessEqual([P, D]));
          }
        }
        let _ = O[O.length - 1];
        for (let w = O.length - 2; w >= 0; w--) {
          _ = i.Piecewise([S[w], O[w], _]);
        }
        let L = i.EndBroadcast([P, _]);
        return i.BroadcastResult(vn(m[0].elementType), [L]);
      }
      case "unique": {
        let m = p[0], h = i.getInstruction(m);
        if (!j(h.valueType) || h.valueType === ListOfDistribution) {
          throw U(`Unexpected types for ${t}`);
        }
        return i.NativeFunction("elementsAt", [
          m,
          i.NativeFunction("uniquePerm", [m]),
        ]);
      }
      case "polygon":
        return d([{
          match: [],
          build: () => {
            let m = i.ConstantOfType(ListOfPoint, []);
            return i.NativeFunction("polygon", [m]);
          },
        }, {
          match: [Number, Number],
          noBroadcast: true,
          build: () => {
            throw Ud();
          },
        }, {
          match: [Number, Number],
          build: () => {
            let m = i.TupleOfType(Point, p);
            return i.NativeFunction("polygon", [m]);
          },
        }, {
          match: { type: "variadic", initial: [], rest: Point },
          build: () => i.NativeFunction("polygon", p),
        }]);
      case "directedangle":
        return p_(e, p, n);
      case "angle":
        return i.NativeFunction("undirectedAngleMarker", [p_(e, p, n)]);
      case "angles":
        return i.NativeFunction("polygonInteriorUndirectedAngles", [
          p[0],
          Fe(e, new C.Identifier("trigAngleMultiplier")),
        ]);
      case "directedangles":
        return i.NativeFunction("polygonInteriorDirectedAngles", [
          p[0],
          Fe(e, new C.Identifier("trigAngleMultiplier")),
        ]);
      case "coterminal": {
        if (gt(i, p[0], DirectedAngleMarker)) {
          return i.NativeFunction("directedCoterminalAngle", p);
        }
        if (gt(i, p[0], AngleMarker)) {
          return i.NativeFunction("undirectedCoterminalAngle", p);
        }
        throw U(`Unexpected types for ${t}`);
      }
      case "histogram":
      case "dotplot":
      case "boxplot":
      case "ttest":
      case "ittest":
      case "stats":
      case "det":
      case "inv":
      case "transpose":
      case "rref":
      case "trace":
      case "points":
      case "lines":
      case "circles":
      case "polygons":
      case "rays":
      case "arcs":
      case "vectors":
        throw ks(n);
      default: {
        let m = t;
        throw new Error(`Programming Error: unexpected compiler function ${m}`);
      }
    }
  }
  function x_(e, t) {
    return Ui(e, t, "glider", [
      {
        match: [Segment, Number],
        build: () => e.NativeFunction("segmentGlider", t),
      },
      { match: [Line, Number], build: () => e.NativeFunction("lineGlider", t) },
      { match: [Ray, Number], build: () => e.NativeFunction("rayGlider", t) },
      {
        match: [Circle, Number],
        build: () => e.NativeFunction("circleGlider", t),
      },
      { match: [Arc, Number], build: () => e.NativeFunction("arcGlider", t) },
      {
        match: [Polygon, Number],
        build: () => e.NativeFunction("polygonGlider", t),
      },
    ]);
  }
  function l_(e, t, n) {
    let { chunk: r } = e;
    if (qn(r, n) === 0) return n;
    let i = r.NativeFunction("listMin", [ur(r, t), ur(r, n)]);
    return n = r.ListAccess([
      n,
      QM(e, r.List([r.Constant(1)]), r.List([i]), { stepMustBePositive: true }),
    ]),
      r.NativeFunction("elementsAt", [t, TU(e, [n])]);
  }
  function TU(e, t) {
    let { chunk: n } = e, r = "sortPerm";
    return Ui(n, t, "sort", [{
      match: [ro],
      build: () => n.NativeFunction(r, t),
      noBroadcast: true,
    }, {
      match: [ListOfComplex],
      build: () => n.NativeFunction(Ip[r], t),
      noBroadcast: true,
    }]);
  }
  function lm(e, t, n) {
    let r = t[0], s = e.getInstruction(r);
    if (!se(s.valueType, Distribution)) throw U(`Unexpected args for "${n}"`);
    let i = t.slice(1);
    for (let o of i) {
      if (!se(e.getInstruction(o).valueType, Number)) {
        throw U(`Unexpected args for "${n}"`);
      }
    }
    if (j(s.valueType)) {
      let o = [], a = 1 / 0;
      for (let c of t) {
        let l = Gr(e, c);
        o.push(l);
        let p = e.getInstruction(l);
        if (j(p.valueType)) {
          let f = qn(e, l);
          if (f === void 0) throw sf(fs(e, l));
          a = Math.min(a, f);
        }
      }
      let u = [];
      for (let c = 0; c < a; c++) {
        let l = zf(e, o[0], c), p = e.getInstruction(l);
        if (p.type !== 42) {
          throw U(`Unexpected opcode for distribution arg: ${p.type}`);
        }
        let f = [];
        for (let d of o.slice(1)) {
          j(e.getInstruction(d).valueType) ? f.push(zf(e, d, c)) : f.push(d);
        }
        u.push(Sa[p.symbol][n](e, l, f));
      }
      return e.List(u);
    } else {
      if (s.type !== 42) {
        throw U(`Unexpected opcode for distribution arg: ${s.type}`);
      }
      return Sa[s.symbol][n](e, r, i);
    }
  }
  function Xh(e, t) {
    return t.length !== 0 && e.getInstruction(t[0]).valueType !== EmptyList &&
      se(e.getInstruction(t[0]).valueType, Distribution);
  }
  function IU(e, t) {
    ms(t.args);
    let n = Ju(e, t, t.args);
    return T_(e, n);
  }
  function T_(e, t) {
    let { chunk: n } = e, r = false, s = false;
    for (let i = 0; i < t.length; i++) {
      let a = n.getInstruction(t[i]).valueType;
      r = r || a === Action, s = s || a !== Action;
    }
    if (r && s) throw U("Unexpected mix of actions and non-actions");
    if (r) return I_(e, t);
    if (t.length === 2) return n.TupleOfType(Point, t);
    if (t.length == 3) return n.TupleOfType(Point3D, t);
    throw U(`Unexpected tuple dimensions: ${t.length}`);
  }
  function PU(e, t) {
    let { chunk: n } = e;
    ms(t.args);
    let r = Ju(e, t, t.args);
    if (r.length < 1) throw U("Empty bare sequence");
    let s = n.getInstruction(r[0]).valueType;
    if (s === Number) throw U("Ambiguous bare sequence");
    return s === Action ? I_(e, r) : n.List(r);
  }
  function I_(e, t) {
    let { chunk: n } = e, r = [], s = [];
    for (let i of t) {
      let o = n.getInstruction(i);
      switch (o.type) {
        case 49: {
          Array.prototype.push.apply(r, o.symbols),
            Array.prototype.push.apply(s, o.args);
          break;
        }
        case 1: {
          let u = o.value.updateRules;
          for (let c of We(u)) {
            let l = u[c];
            r.push(c), s.push(n.ConstantOfType(l.valueType, l.value));
          }
          break;
        }
        default: {
          let a = fs(n, i);
          throw a.length > 0
            ? OT(a)
            : U(`Unexpected opcode for action: ${o.type}`);
        }
      }
    }
    return n.Action(r, s);
  }
  function JM(e, t) {
    let { scope: n, policy: r } = e;
    if (n.isLocal(t)) return my(t);
    let s = n.getVisibleGlobalDefinition(t);
    return r.assignmentForbidden(t)
      ? ST(t)
      : s && s.type === "FunctionDefinition"
      ? vT(t)
      : DT(t).allowExport();
  }
  function EU(e, t) {
    switch (e.getInstruction(t).valueType) {
      case Segment:
      case Circle:
      case Arc:
        return [e.Constant(0), e.Constant(1)];
      case Line:
        return [e.Constant(-1 / 0), e.Constant(1 / 0)];
      case Ray:
        return [e.Constant(0), e.Constant(1 / 0)];
      case Polygon:
        return [
          e.Constant(0),
          e.NativeFunction("count", [e.NativeFunction("vertices", [t])]),
        ];
      default:
        return;
    }
  }
  function MU(e, t) {
    let { policy: n, chunk: r, scope: s, selection: i } = e;
    if (!(t instanceof Ja)) {
      throw new Error(
        "Programming error: expected a ListComprehension node but got " +
          t.type,
      );
    }
    let o = t._body, a = [], u = [], c = r.Constant(1), l = s.childScope();
    ms(t._inputLists);
    for (let { _symbol: x } of t._inputLists) {
      let T = x;
      l.setErrorIfAccessed(T, OP(T));
    }
    for (let x of t.parameters) {
      let T = x.identifier._symbol;
      l.setErrorIfAccessed(T, NP(T));
    }
    let p = Ci(e, l);
    for (let x = t._inputLists.length - 1; x >= 0; x--) {
      let T = t._inputLists[x], b = T._symbol, M = Fe(p, T.args[1]);
      r_(r, i, T);
      let P = r.getInstruction(M);
      if (!j(P.valueType)) {
        let S = EU(r, M);
        if (S) {
          a.push({ symbol: b, object: M, gliderBounds: S });
          continue;
        }
        let O;
        if (wn(P.valueType)) {
          let _ = T.args[1].getInputSpan();
          _ && (O = Yn(_));
        }
        throw SP(b, oe(P.valueType), O, { blockExport: Je(P) });
      }
      let D = ur(r, M);
      u.push({ symbol: b, assignedList: M, lengthIndex: D }),
        c = r.Multiply([c, D]);
    }
    let f = s.childScope(), d = [], y;
    if (u.length > 0) {
      let x = r.Constant(1);
      y = r.BeginBroadcast([c], {
        type: "list-comprehension",
        callData: { inputListSymbols: u.map((b) => b.symbol) },
      }), f.addLexicalBinding(t._index._symbol, y);
      let T = x;
      for (let b = u.length - 1; b >= 0; b--) {
        let { symbol: M, assignedList: P, lengthIndex: D } = u[b], S;
        if (u.length === 1) S = y;
        else {
          let O = r.NativeFunction("floor", [
            r.Divide([r.Subtract([y, x]), T]),
          ]);
          S = r.Add([r.NativeFunction("mod", [O, D]), x]),
            b > 0 && (T = r.Multiply([T, D]));
        }
        f.addDynamicBinding(M, r.ListAccess([P, S])), d.push(M);
      }
    }
    let g;
    if (t.parameters.length > 0 || a.length > 0) {
      let x = [], T = [];
      for (let b of t.parameters) {
        x.push(b.identifier._symbol),
          T.push(Fe(p, b.bounds[0]), Fe(p, b.bounds[1]));
      }
      for (let b of a) {
        x.push(b.symbol), T.push(b.gliderBounds[0], b.gliderBounds[1]);
      }
      g = r.BeginMap({ parameterSymbols: x }, T);
      for (let b = 0; b < t.parameters.length + a.length; b++) {
        r.BlockVar(Number, [g]);
      }
      for (let b = 0; b < t.parameters.length; b++) {
        let M = t.parameters[b].identifier._symbol, D = g + b + 1;
        f.addDynamicBinding(M, D), d.push(M);
      }
      for (let b = 0; b < a.length; b++) {
        let M = a[b].symbol, P = g + t.parameters.length + b + 1;
        f.addDynamicBinding(M, x_(r, [a[b].object, P])), d.push(M);
      }
    }
    let h = Fe({
      ...Ci(e, f),
      substitutionContext: e.substitutionContext.for(
        s,
        e.recursiveFunctionContext,
        d,
      ),
    }, o);
    if (g !== void 0) {
      let x = r.EndMap([g, h]), T = r.getInstruction(h).valueType;
      if (ua(T)) throw zP();
      if (!Ix(T)) throw kP(T);
      let b = n.is3dPolicy() ? 2 : 1;
      if (t.parameters.length + a.length > b) throw HP(T, t.parameters.length);
      let M = Px(T, t.parameters.length + a.length);
      h = r.BlockVar(M, [x]);
    }
    if (y !== void 0) {
      let x = r.getInstruction(h);
      if (!wn(x.valueType)) throw vc([oe(x.valueType)], { blockExport: Je(x) });
      let T = r.EndBroadcast([y, h]);
      h = r.BroadcastResult(vn(x.valueType), [T]);
    } else t.shouldCoerceToList && (h = r.List([h]));
    return h;
  }
  function QM(e, t, n, r) {
    let { stepMustBePositive: s } = r, { chunk: i } = e;
    t = zi(i, t), n = zi(i, n);
    let o = i.getInstruction(t),
      a = i.getInstruction(n),
      u = qo(
        i,
        t,
        "Programming error: expected range start list to have constant length.",
      ),
      c = qo(
        i,
        n,
        "Programming error: expected range start list to have constant length.",
      );
    if (o.valueType !== ListOfNumber || a.valueType !== ListOfNumber) {
      throw Jd();
    }
    let l = i.Constant(1),
      p = i.Constant(0),
      f = i.ListAccess([t, l]),
      d = i.ListAccess([t, i.Constant(2)]),
      y = i.ListAccess([n, i.Constant(c)]),
      g = i.Subtract([y, f]),
      m = u > 1
        ? i.Subtract([d, f])
        : i.Piecewise([i.GreaterEqual([g, p]), l, i.Constant(-1)]),
      h = i.Add([l, i.NativeFunction("round", [i.Divide([g, m])])]),
      x = i.NativeFunction("validateRangeLength", [t, n, m, h]);
    s && (x = i.Piecewise([i.GreaterEqual([m, p]), x, p]));
    let T = i.BeginBroadcast([x]),
      b = i.Add([f, i.Multiply([m, i.Subtract([T, l])])]),
      M = i.EndBroadcast([T, b]);
    return i.addComments({
      [f]: "start",
      [d]: "second",
      [y]: "last",
      [h]: "proposedLength",
      [m]: "step",
      [b]: "body",
    }),
      i.BroadcastResult(vn(i.getInstruction(b).valueType), [M]);
  }
  function Zh(e, t) {
    return gt(e, t, Segment)
      ? e.NativeFunction("lineFromSegment", [t])
      : gt(e, t, Vector)
      ? e.NativeFunction("lineFromSegment", [hU(e, t)])
      : gt(e, t, Ray)
      ? e.NativeFunction("lineFromRay", [t])
      : t;
  }
  function CU(e, t) {
    let n = e.NativeFunction("arcCenter", [t]),
      r = e.NativeFunction("arcFirstPoint", [t]),
      s = e.NativeFunction("distance", [n, r]);
    return { center: n, radius: s, startPoint: r };
  }
  function p_(e, t, n) {
    let { chunk: r } = e;
    if (
      t.length === 3 && gt(r, t[0], Point) && gt(r, t[1], Point) &&
      gt(r, t[2], Point)
    ) {
      let s = t[0],
        i = t[1],
        o = t[2],
        a = r.Subtract([s, i]),
        u = r.Subtract([o, i]),
        c = r.Slot(0, [a]),
        l = r.Slot(1, [a]),
        p = r.Slot(0, [u]),
        f = r.Slot(1, [u]),
        d = r.NativeFunction("arctan", [l, c]),
        y = r.Subtract([r.Multiply([c, f]), r.Multiply([l, p])]),
        g = r.Add([r.Multiply([c, p]), r.Multiply([l, f])]),
        m = r.NativeFunction("arctan", [y, g]),
        h = r.NativeFunction("abs", [m]),
        x = r.Constant(Math.PI),
        T = r.Constant(Math.PI * 2);
      m = r.Piecewise([
        r.Equal([h, x]),
        x,
        r.Piecewise([
          r.Less([h, x]),
          m,
          r.Multiply([
            r.Multiply([r.NativeFunction("sign", [m]), r.Constant(-1)]),
            r.Subtract([T, h]),
          ]),
        ]),
      ]);
      let b = r.NativeFunction("directedAngleMarker", [
          i,
          d,
          m,
          Fe(e, new C.Identifier("trigAngleMultiplier")),
        ]),
        M = r.Constant(0),
        P = r.And([r.Equal([y, M]), r.Equal([g, M])]);
      return r.Piecewise([P, r.NanOfType(DirectedAngleMarker), b]);
    } else throw U(`Unexpected types for ${n}`);
  }
  function aN(e, t) {
    return e.Divide([
      e.NativeFunction("directedAngleMarkerRawDelta", [t]),
      e.NativeFunction("directedAngleMarkerMultiplier", [t]),
    ]);
  }
  function uN(e, t) {
    return e.NativeFunction("abs", [
      e.Divide([
        e.NativeFunction("undirectedAngleMarkerRawDelta", [t]),
        e.NativeFunction("undirectedAngleMarkerMultiplier", [t]),
      ]),
    ]);
  }
  function DU(e, t, n) {
    let { chunk: r, policy: s } = e, i = n.slice(1), o = Rf(s, t);
    if (!o) throw new Error(`Unexpected transformation type: ${t}`);
    let a = o.map((p) => {
        let f = 0;
        for (let d = 1; d < n.length; d++) {
          let y = r.getInstruction(n[d]).valueType, g = p.argTypeAtIndex(d);
          g && Mc(y, g) && f++;
        }
        return {
          signature: p,
          matchedArgsCount: f,
          signatureArgsCount: p.maxArity === void 0
            ? p.initial.length + 1
            : p.argTypes.length - 1,
          providedArgsCount: n.length - 1,
        };
      }).sort((p, f) =>
        f.matchedArgsCount !== p.matchedArgsCount
          ? f.matchedArgsCount - p.matchedArgsCount
          : p.signatureArgsCount - f.signatureArgsCount
      ),
      u;
    switch (t) {
      case "translate": {
        u = [{
          match: [Vector],
          build: () =>
            r.NativeFunction("translation", [
              r.NativeFunction("vectorDisplacementAsPoint", i),
            ]),
        }, {
          match: [Point, Point],
          build: () =>
            r.NativeFunction("translation", [r.Subtract([i[1], i[0]])]),
        }];
        break;
      }
      case "reflect": {
        u = [{
          match: [Qm],
          build: () => {
            let p = Zh(r, i[0]);
            return r.NativeFunction("reflection", [p]);
          },
        }];
        break;
      }
      case "rotate": {
        u = [{
          match: [Point, Number],
          build: () => {
            let p = Fe(e, new C.Identifier("trigAngleMultiplier"));
            return r.NativeFunction("rotation", [i[0], r.Multiply([i[1], p])]);
          },
        }];
        break;
      }
      case "dilate": {
        u = [{
          match: [Point, Number],
          build: () => r.NativeFunction("dilation", i),
        }];
        break;
      }
      default: {
        let p = t;
        throw new Error(`Programming error: exhaustive check failed: ${p}`);
      }
    }
    let c = r.areAllArgsConstant(i),
      l = Ui(r, i, () => {
        throw Jx(t, Pa(r, i), a[0].signature, { blockExport: c });
      }, u);
    return Wh(r, [l, n[0]], t, true);
  }
  function Wh(e, t, n, r) {
    let s = [
      [Transformation, "compose"],
      [Point, "transformPoint"],
      [Segment, "transformSegment"],
      [Line, "transformLine"],
      [Ray, "transformRay"],
      [Vector, "transformVector"],
      [Circle, "transformCircle"],
      [Arc, "transformArc"],
      [Polygon, "transformPolygon"],
      [AngleMarker, "transformAngleMarker"],
      [DirectedAngleMarker, "transformDirectedAngleMarker"],
    ].map(([o, a]) => ({
      match: [Transformation, o],
      build: (u, c) => u.NativeFunction(a, c),
    }));
    function i() {
      if (r) {
        let o = t.slice(1);
        throw Qx(n, zu(e, o), { blockExport: e.areAllArgsConstant(o) });
      } else throw Hs(n, zu(e, t), { blockExport: e.areAllArgsConstant(t) });
    }
    return Ui(e, t, i, s);
  }
  function ZM(e, t, n) {
    let r = Zh(e, t[0]),
      s = Zh(e, t[1]),
      i = [r, s, e.ConstantOfType(Number, n)];
    if (gt(e, r, Circle)) {
      if (gt(e, s, Circle)) {
        return e.NativeFunction("circleCircleIntersection", i);
      }
      if (gt(e, s, Arc)) return e.NativeFunction("circleArcIntersection", i);
      if (gt(e, s, Line)) return e.NativeFunction("circleLineIntersection", i);
    }
    if (gt(e, r, Arc)) {
      if (gt(e, s, Circle)) return e.NativeFunction("arcCircleIntersection", i);
      if (gt(e, s, Arc)) return e.NativeFunction("arcArcIntersection", i);
      if (gt(e, s, Line)) return e.NativeFunction("arcLineIntersection", i);
    }
    if (gt(e, r, Line)) {
      if (gt(e, s, Circle)) {
        return e.NativeFunction("lineCircleIntersection", i);
      }
      if (gt(e, s, Arc)) return e.NativeFunction("lineArcIntersection", i);
      if (gt(e, s, Line)) return e.NativeFunction("lineLineIntersection", i);
    }
    throw U("Invalid intersection types");
  }
  function SU(e, [t, n], [r, s]) {
    let { chunk: i, scope: o } = e,
      a = i.getInstruction(r).valueType,
      u = i.getInstruction(s).valueType,
      c = (f) => {
        var d;
        return (d = o.getParseNode(f)) != null
          ? d
          : o.getVisibleGlobalDefinition(f);
      },
      l = ki(t) ? c(t._symbol) : t,
      p = ki(n) ? c(n._symbol) : n;
    if (!(!l || !p)) {
      return UO(
        {
          getGeometryTree: (f) => ah(f).tree,
          lookup: c,
          isPointOrListOfPoints: (f) => {
            if (f.isFunction) return false;
            let d = Fe(e, f);
            return se(i.getInstruction(d).valueType, Point);
          },
          resolvesTo: (f, d) => o.getVisibleGlobalDefinition(f) === d,
        },
        l,
        a,
        p,
        u,
      );
    }
  }
  function vU(e, t) {
    let { policy: n, scope: r } = e, s = t._body, i = r.childScope(), o = [];
    for (let u = 0; u < t._assignments.length; u++) {
      let c = t._assignments[u]._lhs, l;
      if (c instanceof we) l = c._symbol;
      else throw of();
      let p = t._assignments[u].args[1], f = r.getVisibleGlobalDefinition(l);
      if (f) {
        if (f.type === "FunctionDefinition") throw uf(l);
        if (n.assignmentForbidden(l)) throw af(l);
      }
      let d = Fe(e, p);
      i.addDynamicBinding(l, d, p), o.push(l);
    }
    return Fe({
      ...Ci(e, i),
      substitutionContext: e.substitutionContext.with(
        r,
        e.recursiveFunctionContext,
        o,
      ),
    }, s);
  }
  var d_ = {
    points: ListOfPoint,
    lines: ListOfLine,
    segments: ListOfSegment,
    polygons: ListOfPolygon,
    circles: ListOfCircle,
    arcs: ListOfArc,
    angles: ListOfAngleMarker,
    directedangles: ListOfDirectedAngleMarker,
    rays: ListOfRay,
    vectors: ListOfVector,
  };
  function OU(e, t) {
    let { chunk: n, scope: r } = e,
      s = r.getVisibleGlobalDefinition("construction");
    if (!s) throw U("Expected 'construction' to be defined in the frame");
    if (s.type !== "Construction" || !(s instanceof Q)) {
      throw U(`Expected construction node but found ${s.type}}`);
    }
    if (!ki(t)) throw U(`Expected identifier but found ${t.type}`);
    let i = t._symbol;
    if (!(i in d_)) throw ks("construction");
    let o = d_[i];
    if (s.args.length === 0) return n.ConstantOfType(o, []);
    let a = Ve(o), u = [];
    for (let c of s.args) {
      try {
        let l = Fe(e, c);
        n.getInstruction(l).valueType === a && u.push(l);
      } catch (l) {
        if (l instanceof C.Base) continue;
        throw l;
      }
    }
    return n.List(u);
  }
  function pm(e, t) {
    let n = e.args,
      r = e instanceof gn
        ? e._symbol
        : e instanceof Fu || e instanceof wu
        ? e.args[0]._symbol
        : void 0;
    if (r && t.definitions[r]) return false;
    if (e instanceof Fr) {
      let a = [pm(e.args[0], t) || new Et(true)],
        u = pm(e.args[1], t),
        c = pm(e.args[2], t);
      return u && a.push(u),
        c && a.push(c),
        a.length === 1 ? false : (a.length === 2 && a.push(a[1]), new Fr(a));
    }
    let s = [], i = false;
    for (let o of n) {
      let a = pm(o, t);
      if (a === false) {
        i = true;
        continue;
      }
      s.push(a);
    }
    return i ? false : e.copyWithArgs(s);
  }
  function P_(e, t, n) {
    let { chunk: r, scope: s } = e, i = {}, o = We(n.definitions);
    for (let y of o) {
      let g = n.definitions[y];
      if (g instanceof v) throw g;
      i[y] = g;
    }
    let a = t._argSymbols.map((y) => Fe(e, new we(y))),
      u = new WM(i, n.baseCases);
    try {
      M_(e, u, t, a);
    } catch (y) {
      throw u.isUnconditionallyRecursive && y instanceof v && !y.blocksExport
        ? o.length > 1 || E_(t, t._expression)
          ? Rc(o, { suggestAlternativeFunctionName: false })
          : oy(o)
        : y;
    }
    let c = {}, l = {}, p = {}, f = s.childScope();
    for (let y of o) {
      let g = u.returnTypes[y];
      if (g === void 0) {
        throw U(`Could not infer the return type for recursive function ${y}.`);
      }
      let m = u.argTypes[y];
      if (m === void 0) {
        throw U(
          `Could not infer the argument types for recursive function ${y}.`,
        );
      }
      l[y] = { argTypes: m },
        c[y] = g,
        p[y] = r.FunctionHeader(y, g, l[y], i[y]._argSymbols),
        f.addLexicalBinding(y, p[y]);
    }
    let d = [];
    for (let y of o) d.push(p[y]);
    for (let y of d) r.getInstruction(y).recursionGroup = d;
    for (let y of o) {
      let g = f.childScope(), m = i[y], h = p[y], x = r.BeginFunction([h]);
      for (let M = 0; M < m._argSymbols.length; M++) {
        let P = m._argSymbols[M], D = r.BlockVar(l[y].argTypes[M], [x]);
        g.addLexicalBinding(P, D);
      }
      let T = {
          ...Ci(e, g),
          recursiveFunctionContext: { type: "compile-general", fnSymbols: o },
        },
        b = C_(T, m, n.baseCases, Fe(T, m._expression));
      if (r.getInstruction(b).valueType !== c[y]) {
        throw Hs(y, Pa(r, a), { blockExport: r.areAllArgsConstant(a) });
      }
      b = Gr(r, b), r.EndFunction([x, b]);
    }
    if (u.isUnconditionallyRecursive) {
      let y = r.getRecursiveFunctionMetadata(p[t._symbol]),
        g = y == null ? void 0 : y.recursiveStructure;
      throw g != null && g.canIterate
        ? new Error(
          "Programming error: expected canIterate==false for unconditionally recursive function.",
        )
        : g != null && g.maxRecursiveCallOffsets &&
            o.every((m) => g.maxRecursiveCallOffsets[m] === 0)
        ? Rc(o, { suggestAlternativeFunctionName: false })
        : Sx(o, {
          type: "missing-non-recursive-branch",
          recursionGroup: o,
          recursiveStructure: g,
        });
    }
    return r.FunctionCall([p[t._symbol], ...a]);
  }
  function E_(e, t) {
    return t instanceof gn && t._symbol === e._symbol
      ? t.args.every((n, r) =>
        n instanceof we && n._symbol === e._argSymbols[r]
      )
      : t.args.every((n) => E_(e, n));
  }
  function M_(e, t, n, r) {
    let { chunk: s } = e,
      i = t.returnTypes[n._symbol],
      o = t.argTypes[n._symbol];
    if (i !== void 0 && o !== void 0) return { returnType: i, argTypes: o };
    let a = n._argSymbols.length, u = r.length;
    if (a !== u) throw Ao(n._symbol, a, u, { includeUsageExample: true });
    let c = r.map((d) => s.getInstruction(d).valueType),
      l = `${n._symbol}:${c.join(",")}:${Object.keys(t.returnTypes).join(",")}`;
    if (t.stack.includes(l)) {
      return t.isUnconditionallyRecursive = true,
        { returnType: Number, argTypes: c };
    }
    t.stack.push(l);
    let p = s.getReturnIndex(), f;
    return zh(e, (d) => {
      var M;
      let y = pm(n._expression, t),
        g = n._symbol,
        m = (M = t.baseCases[g]) != null ? M : [],
        h = { ...d, recursiveFunctionContext: t },
        x = h.scope,
        T = [];
      for (let P = 0; P < n._argSymbols.length; P++) {
        let D = n._argSymbols[P], S = s.SymbolicVar(c[P]);
        T.push(S), x.addLexicalBinding(D, S);
      }
      if (!t.baseCaseTypes.hasOwnProperty(g)) {
        let P, D, S, O = true;
        for (let _ of m) {
          let L = _.getRef();
          if (!_.specifiedArg.valid || !L) continue;
          let w = new we(L), G = Fe(h, w);
          S || (S = w);
          let k = s.getInstruction(G), Z = k.valueType;
          if (Je(k) || (O = false), P === void 0) P = _.specifiedArg.argIndex;
          else if (P !== _.specifiedArg.argIndex) throw wd();
          let F = D;
          if (F === void 0) D = Z;
          else {
            let Y = Ha(F, Z);
            if (Y === void 0) throw Ld({ blockExport: O });
            D = Y;
          }
        }
        t.baseCaseTypes[g] = D, t.firstValidBaseCaseIdentifiers[g] = S;
      }
      let b = t.firstValidBaseCaseIdentifiers[g];
      if (y || b) {
        let P = C_(h, n, t.baseCases, Fe(h, y || b)),
          { someArgBroadcasts: D, inferredArgTypes: S } = NU(s, T, p, P);
        if (c = S, f = s.getInstruction(P).valueType, D) {
          if (!j(f)) throw U(`TODO: expected a list type but found ${at(f)}`);
          f = Ve(f);
        }
        let O = t.returnTypes[n._symbol];
        if (O !== void 0 && f !== O) throw Ld({ blockExport: false });
        t.argTypes[n._symbol] = S, t.returnTypes[n._symbol] = f;
      }
    }),
      zh(e, (d) => {
        let y = { ...d, recursiveFunctionContext: t }, g = y.scope;
        for (let T = 0; T < n._argSymbols.length; T++) {
          let b = n._argSymbols[T], M = s.SymbolicVar(c[T]);
          g.addLexicalBinding(b, M);
        }
        let m = Fe(y, n._expression);
        t.stack.pop();
        let h = s.getInstruction(m).valueType, x = f === void 0 ? h : Ha(f, h);
        if (x === void 0) {
          throw U(`Mismatched return types: ${f && at(f)} vs ${at(h)}`);
        }
        return t.returnTypes[n._symbol] = x, { returnType: x, argTypes: c };
      });
  }
  function NU(e, t, n, r) {
    let s = [], u = [];
    for (let p = 0; p < r - n; p++) u.push(0);
    if (e.getInstruction(r).type === 48) {
      u.push(1);
      for (let p = r; p >= 0; p--) {
        let f = u[p - n];
        if (f === 0) continue;
        let d = e.getInstruction(p);
        if (!ge(d)) {
          if (
            d.type === 24 ? s.push(p) : d.type === 23 && s.pop(),
              (d.type === 48 || d.type === 24) && (u[d.args[0] - n] |= f),
              d.type === 39 || d.type === 41 || d.type === 40
          ) {
            for (let y of s) {
              let m = e.getInstruction(y).args[0];
              if (d.args[1] === m) {
                u[d.args[0] - n] |= f;
                break;
              }
            }
          }
          if (s.length > 0) {
            let y = s[s.length - 1], m = e.getInstruction(y).args[0];
            for (let h of d.args) h >= m && (u[h - n] |= f);
            d.type === 33 && d.args[0] >= m && (u[d.args[0] - n] |= 2);
          }
        }
      }
    }
    let c = [], l = false;
    for (let p = 0; p < t.length; p++) {
      let f = t[p], d = e.getInstruction(f).valueType;
      if (u[f - n] & 2) {
        if (!j(d)) throw U(`Expected list type but found ${at(d)}`);
        l = true, c.push(Ve(d));
      } else c.push(d);
    }
    return { inferredArgTypes: c, someArgBroadcasts: l };
  }
  function C_(e, t, n, r) {
    let { chunk: s } = e, i = true, o = n[t._symbol];
    for (let a of o) {
      let u = a.specifiedArg;
      if (!u.valid) continue;
      let c = t._argSymbols[u.argIndex],
        l = Fe(e, new we(c)),
        p = s.Equal([l, s.Constant(u.argValue)]),
        f = Fe(e, a),
        d = s.getInstruction(f);
      Je(d) || (i = false);
      let y = s.getInstruction(f).valueType, g = s.getInstruction(r).valueType;
      if (Ha(y, g) === void 0) throw Ld({ blockExport: i });
      r = s.Piecewise([p, f, r]);
    }
    return r;
  }
  function RU(e) {
    return e.type === "Constant" && Number.isInteger(e.asValue());
  }
  function f_(e, t, n, r) {
    var f;
    let { policy: s, chunk: i, scope: o } = e, a = new C.Identifier(t), u, c;
    r.length === 1
      ? (u = n[0], c = r[0])
      : (u = new C.ParenSeq(n), Uo(i, s, u, r), c = T_(e, r));
    let p = [(f = o.getSymbol(t)) != null ? f : Fe(e, a), c];
    return Uo(i, s, new C.Multiply([a, u]), p), i.Multiply(p);
  }
  Yt.prototype.buildIRExpression = function (e, t, n) {
    var s;
    let r = od({
      policy: e,
      frame: t,
      wrapInList: n && n.wrapInList,
      coerceToNumber: n && n.coerceToNumber,
    }, this);
    return e.isGeometryEnabled() && r.argNames.some((i) => i[0] === "$")
      ? GP()
      : (s = r.getError()) != null
      ? s
      : new on(r);
  };
  v.prototype.buildIRExpression = function (e, t, n) {
    return this;
  };
  var D_ = Od;
  function KM(e) {
    let t = [];
    for (let n = 0; n < e.length; n++) t.push(oe(e[n].valueType));
    return t;
  }
  var Di = true;
  function S_(e, t) {
    let n = t.length, r = t[0];
    if (n < 2) throw so(this._symbol, { blockExport: Di });
    if (!D_(r.valueType, [ListOfNumber, EmptyList])) {
      throw so(this._symbol, { blockExport: Di });
    }
    if (n > 2) throw by(this._symbol, 2);
  }
  C.Histogram.prototype.typeCheck = S_;
  C.DotPlot.prototype.typeCheck = S_;
  C.BoxPlot.prototype.typeCheck = function (e, t) {
    let n = t.length, r = t[0];
    if (n === 0) throw so(this._symbol, { blockExport: Di });
    if (!D_(r.valueType, [ListOfNumber, EmptyList])) {
      throw so(this._symbol, { blockExport: Di });
    }
    if (n > 1) throw so(this._symbol, { blockExport: Di });
  };
  C.TTest.prototype.typeCheck = function (e, t) {
    let n = this._symbol;
    if (t.length === 0) throw so(n, { blockExport: Di });
    if (t[0].valueType === EmptyList) throw jl(n);
    if (t[0].valueType !== ListOfNumber) throw so(n, { blockExport: Di });
    if (t.length > 2) throw by(n, 2);
    if (t[0].length < 2) throw jl(n);
    if (t[1] && t[1].valueType !== Number) {
      throw Hs(n, KM(t), { blockExport: Di });
    }
  };
  C.IndependentTTest.prototype.typeCheck = function (e, t) {
    let n = this._symbol;
    if (t.length !== 2) throw qd(n);
    if (!j(t[0].valueType) || !j(t[1].valueType)) {
      throw jd(n, { blockExport: Di });
    }
    if (t[0].valueType === EmptyList || t[1].valueType === EmptyList) {
      throw jl("ittest");
    }
    if (t[0].valueType !== ListOfNumber || t[1].valueType !== ListOfNumber) {
      throw Hs(n, KM(t), { blockExport: Di });
    }
    if (t[0].length < 2 || t[1].length < 2) throw jl("ittest");
  },
    C.Stats.prototype.typeCheck = function (e, t) {
      let n = t.length, r = t[0];
      if (n === 0) throw so(this._symbol, { blockExport: Di });
      if (r.valueType === EmptyList) {
        throw Hs(this._symbol, KM(t), { blockExport: Di });
      }
      if (r.valueType !== ListOfNumber) {
        throw so(this._symbol, {
          blockExport: Di,
        });
      }
      if (n > 1) throw so(this._symbol, { blockExport: Di });
    };
  var iu = function (e, t, n) {
      n = n || 0;
      let r = Array(n + 1).join("  "), s = r + "  ";
      return `[
` + s + e.map((i) => i.repr(t, n + 1)).join(
        `,
` + s,
      ) + `
` + r + "]";
    },
    Tr = function (e, t) {
      return t = t || "", "" + t + e;
    };
  C.Expression.prototype.repr = function (e, t) {
    return Tr(this.type, e) + "(" + iu(this.args, e, t) + ")";
  };
  C.IRExpression.prototype.repr = function (e, t) {
    t = t || 0;
    let n = Array(t + 1).join("  "),
      r = n + "  ",
      s = this._chunk.print().split(`
`);
    return s.pop(),
      Tr(this.type, e) + "(`\n" + r + s.join(
        `
` + r,
      ) + `
` + n + "`)";
  };
  C.DoubleInequality.prototype.repr = function (e, t) {
    t = t || 0;
    let n = Array(t + 1).join("  "), r = n + "  ";
    return Tr(this.type, e) + `([
` + r + this.args[0].repr(e, t + 1) + `,
` + r + "'" + this.args[1] + `',
` + r + this.args[2].repr(e, t + 1) + `,
` + r + "'" + this.args[3] + `',
` + r + this.args[4].repr(e, t + 1) + `
` + n + "])";
  };
  C.ComparatorChain.prototype.repr = function (e, t) {
    return t = t || 0,
      Tr(this.type, e) + "([" + this.symbols.map((n) => `'${n}'`).join(",") +
      `],
` + iu(this.args, e, t) + ")";
  };
  C.Identifier.prototype.repr = function (e) {
    return Tr(this.type, e) + "('" + this._symbol + "')";
  };
  C.Constant.prototype.repr = function (e) {
    return Tr(this.type, e) + "(" + this.asValue() + ")";
  };
  C.ExtendSeed.prototype.repr = function (e, t) {
    return Tr(this.type, e) + "('" + this.tag + "', " + iu(this.args, e, t) +
      ")";
  };
  C.Seed.prototype.repr = function (e) {
    return Tr(this.type, e) + "(" + this.asValue() + ")";
  };
  C.FunctionCall.prototype.repr = function (e, t) {
    return Tr(this.type, e) + "('" + this._symbol + "', " +
      iu(this.args, e, t) + ")";
  };
  C.RecursiveFunctionBaseCase.prototype.repr = function (e, t) {
    return this.originalNode.repr(e, t);
  };
  C.Assignment.prototype.repr = function (e, t) {
    return Tr(this.type, e) + "(" + new C.Identifier(this._symbol).repr(e, t) +
      ", " + this._expression.repr(e, t) + ")";
  };
  C.Regression.prototype.repr =
    C.Equation.prototype.repr =
    C.CallAssignment
      .prototype.repr =
      function (e, t) {
        return Tr(this.type, e) + "(" + this._lhs.repr(e, t) + ", " +
          this._rhs.repr(e, t) + ")";
      };
  C.FunctionDefinition.prototype.repr = function (e, t) {
    return Tr(this.type, e) + "(" + new C.Identifier(this._symbol).repr(e, t) +
      ", " + iu(this._argSymbols.map((n) => new C.Identifier(n)), e, t) + ", " +
      this._expression.repr(e, t) + ")";
  };
  C.Error.prototype.repr = function (e, t) {
    return Tr(this.type, e) + "('" + this._msg + "')";
  };
  C.Derivative.prototype.repr = function (e, t) {
    return Tr(this.type, e) + "('" + this._symbol + "', " +
      iu(this.args, e, t) + ")";
  };
  C.SolvedEquation.prototype.repr = function (e, t) {
    return Tr(this.type, e) + "('" + this._symbol + "', " +
      this._expression.repr(e, t) + ")";
  };
  C.OptimizedRegression.prototype.repr = function (e, t) {
    return Tr(this.type, e) + "(" + JSON.stringify(this.parameters) + ", " +
      JSON.stringify(this.residuals) + ", " + JSON.stringify(this.statistics) +
      ", " + this.model.repr(e, t + 1) + ", " + JSON.stringify({
        isModelValid: this.isModelValid,
        residualVariable: this.residualVariable,
        residualSuggestionId: this.residualSuggestionId,
        shouldSuggestLogMode: this.shouldSuggestLogMode,
        isLinear: this.isLinear,
        parameterWarning: this.parameterWarning,
      }) + ")";
  };
  C.Table.prototype.repr = function (e, t) {
    return Tr(this.type, e) + "(" + iu(this.columns, e, t) + ", " +
      this.localFrameID + ")";
  };
  C.TableColumn.prototype.repr = function (e, t) {
    return Tr(this.type, e) + "(" + this.header.repr(e, t) + ", " +
      this.length + ", " + iu(this.values, e, t) + ", " + this.localFrameID +
      ", " + this.columnIndex + ")";
  };
  C.TableColumnValue.prototype.repr = function (e, t) {
    return "TableColumnValue(" + iu(this.rawArgs, e, t) + ", " +
      this.headerSymbol + ")";
  };
  C.Image.prototype.repr = function (e, t) {
    let n = Array(t + 1).join("  "), r = n + "  ";
    return Tr(this.type, e) + `({
` + r + "center: " + this.center.repr(e, t + 1) + `,
` + r + "radianAngle: " + this.radianAngle.repr(e, t + 1) + `,
` + r + "width: " + this.width.repr(e, t + 1) + `,
` + r + "height: " + this.height.repr(e, t + 1) + `},
` + r + "opacity: " + this.opacity.repr(e, t + 1) + `,
` + r + JSON.stringify(this.moveStrategy) + `
` + n + "})";
  };
  C.Ticker.prototype.repr = function (e, t) {
    let n = Array(t + 1).join("  "), r = n + "  ";
    return Tr(this.type, e) + `({
` + r + "handler: " + this.handler.repr(e, t + 1) + `,
` + r + "minStep: " + this.minStep.repr(e, t + 1) + `
` + n + "})";
  };
  C.Slider.prototype.repr = function (e, t) {
    let n = Array(t + 1).join("  "), r = n + "  ";
    return Tr(this.type, e) + `({
` + r + "sliderAssignment: " + this.sliderAssignment.repr(e, t + 1) + `,
` + r + "sliderMin: " + (this.sliderMin && this.sliderMin.repr(e, t + 1)) + `,
` + r + "sliderMax: " + (this.sliderMax && this.sliderMax.repr(e, t + 1)) + `,
` + r + "sliderStep: " + (this.sliderStep && this.sliderStep.repr(e, t + 1)) +
      `},
` + n + ")";
  };
  C.ImaginaryUnit.prototype.repr = function (e) {
    return Tr(this.type, e) + "()";
  };
  var Jh = function (e, t) {
    return e.map((n) => n.substitute(t));
  };
  C.Identifier.prototype.substitute = function (e) {
    return e[this._symbol] ? e[this._symbol] : this;
  };
  C.FunctionCall.prototype.substitute = function (e) {
    let t = e[this._symbol];
    if (t) {
      if (t.type === "Identifier") {
        return new C.FunctionCall(t, Jh(this.args, e));
      }
      if (t.type === "Constant") {
        return new C.Multiply([
          t,
          this.args.length === 1
            ? this.args[0].substitute(e)
            : new C.Constant(NaN),
        ]);
      }
    }
    return C.Expression.prototype.substitute.call(this, e);
  };
  C.Constant.prototype.substitute = function (e) {
    return this;
  };
  C.Expression.prototype.substitute = function (e) {
    return this.copyWithArgs(Jh(this.args, e));
  };
  C.Derivative.prototype.substitute = function (e) {
    let t = e[this._symbol];
    if (t) {
      if (t.type === "Identifier") return new C.Derivative(t, Jh(this.args, e));
      throw new Error(
        "Cannot substitute for a derivative variable with a non-Identifier",
      );
    }
    return new C.Derivative(this._symbol, Jh(this.args, e));
  };
  C.Expression.prototype.simpleFunctionExpression = function () {
    return this;
  };
  C.Assignment.prototype.simpleFunctionExpression = function () {
    return this._expression;
  };
  C.FunctionDefinition.prototype.simpleFunctionExpression = function () {
    return this._expression;
  };
  C.RecursiveFunctionBaseCase.prototype.simpleFunctionExpression = function () {
    return this._expression;
  };
  C.Equation.prototype.simpleFunctionExpression =
    C.CallAssignment.prototype
      .simpleFunctionExpression =
      function () {
        return this.asComparator().simpleFunctionExpression();
      };
  var Qh = {
      normaldist: {
        type: "distribution",
        symbol: "normaldist",
        params: ["mean", "stdev"],
        defaults: ["0", "1"],
        discrete: false,
      },
      tdist: {
        type: "distribution",
        symbol: "tdist",
        params: ["dof"],
        defaults: [void 0],
        discrete: false,
      },
      binomialdist: {
        type: "distribution",
        symbol: "binomialdist",
        params: ["trials", "probsuccess"],
        defaults: [void 0, "0.5"],
        discrete: true,
      },
      poissondist: {
        type: "distribution",
        symbol: "poissondist",
        params: ["mean"],
        defaults: [void 0],
        discrete: true,
      },
      uniformdist: {
        type: "distribution",
        symbol: "uniformdist",
        params: ["min", "max"],
        defaults: ["0", "1"],
        discrete: false,
      },
    },
    AU = {
      Histogram: {
        type: "visualization",
        symbol: "histogram",
        params: ["data", "binwidth"],
        defaults: [void 0, "1"],
      },
      DotPlot: {
        type: "visualization",
        symbol: "dotplot",
        params: ["data", "binwidth"],
        defaults: [void 0, "1"],
      },
      BoxPlot: {
        type: "visualization",
        symbol: "boxplot",
        params: ["data"],
        defaults: [void 0],
      },
    };
  function v_(e) {
    let t = Mi(e, { trailingComma: true });
    return ou(t);
  }
  function ou(e) {
    let t = e, n = AU[t.type];
    if (!n) {
      switch (t.type === "Assignment" && (t = t._expression), t.type) {
        case "FunctionCall": {
          n = Qh[t._symbol];
          break;
        }
        default:
          return;
      }
    }
    if (!n) return;
    let r = {}, s = n.params, i = t.args;
    for (let o = 0; o < s.length; o++) {
      let a = i[o];
      r[s[o]] = a && a.getInputString() || "";
    }
    return { ...n, span: t.getInputSpan(), values: r };
  }
  var LU = {
    X_OR_Y: { points: false, lines: true, fill: false },
    SINGLE_POINT: { points: true, lines: false, fill: false },
    POINT_LIST: { points: true, lines: false, fill: false },
    PARAMETRIC: { points: false, lines: true, fill: false },
    POLAR: { points: false, lines: true, fill: false },
    IMPLICIT: { points: false, lines: true, fill: false },
    POLYGON: { points: false, lines: true, fill: true },
    HISTOGRAM: { points: false, lines: true, fill: true },
    DOTPLOT: { points: true, lines: false, fill: false },
    BOXPLOT: { points: false, lines: true, fill: false },
    TTEST: { points: false, lines: false, fill: false },
    STATS: { points: false, lines: false, fill: false },
    VECTOR2D: { points: false, lines: true, fill: false },
    POINT3D: { points: true, lines: false, fill: false },
    POINT3D_LIST: { points: true, lines: false, fill: false },
    CURVE3D_xyz_t: { points: false, lines: true, fill: false },
    SLICE: { points: false, lines: true, fill: false },
    SLICE_rz_at_z: { points: false, lines: true, fill: false },
    SLICE_zr_at_r: { points: false, lines: true, fill: false },
    SLICE_zr_at_: { points: false, lines: true, fill: false },
    SLICE_zr_at_xyz: { points: false, lines: true, fill: false },
    SLICE_r_at_: { points: false, lines: true, fill: false },
    SLICE_r_at_: { points: false, lines: true, fill: false },
    SLICE_r_at_xyz: { points: false, lines: true, fill: false },
    SLICE_xyz_uv: { points: false, lines: true, fill: false },
    SEGMENT3D: { points: false, lines: true, fill: false },
    VECTOR3D: { points: false, lines: true, fill: false },
    SPHERE3D: { points: false, lines: true, fill: false },
    SURFACE_xyz_uv: { points: false, lines: true, fill: false },
    SURFACE_z_r: { points: false, lines: true, fill: false },
    SURFACE_r_z: { points: false, lines: true, fill: false },
    SURFACE_r_: { points: false, lines: true, fill: false },
    SURFACE_r_z_AMBIGUOUS: { points: false, lines: true, fill: false },
    SURFACE: { points: false, lines: true, fill: false },
    TRIANGLE3D: { points: false, lines: true, fill: false },
    SURFACE_AMBIGUOUS: { points: false, lines: true, fill: false },
    SURFACE_CONSTANT_AMBIGUOUS: { points: false, lines: true, fill: false },
    IMPLICIT_SURFACE: { points: false, lines: true, fill: false },
    IMPLICIT_SURFACE_AMBIGUOUS: { points: false, lines: true, fill: false },
  };
  function eC(e, t, n) {
    var s, i, o, a, u, c;
    if (e === void 0) return { points: false, lines: false, fill: false };
    let r = LU[e];
    switch (e) {
      case "SINGLE_POINT":
        return { points: true, lines: false, fill: false };
      case "POINT_LIST":
      case "POINT3D_LIST":
      case "DOTPLOT":
        return {
          points: (s = t.points) != null ? s : r.points,
          lines: (i = t.lines) != null ? i : r.lines,
          fill: false,
        };
      case "POINT3D":
        return {
          points: (o = t.points) != null ? o : r.points,
          lines: false,
          fill: false,
        };
      case "PARAMETRIC":
      case "POLYGON":
      case "X_OR_Y":
      case "VECTOR2D":
      case "POLAR":
      case "IMPLICIT":
      case "HISTOGRAM":
      case "BOXPLOT":
      case "TTEST":
      case "STATS":
      case "CURVE3D_xyz_t":
        return {
          points: false,
          lines: (a = t.lines) != null ? a : r.lines,
          fill: (u = t.fill) != null ? u : r.fill,
        };
      case "TRIANGLE3D":
      case "SPHERE3D":
      case "SURFACE":
      case "SURFACE_r_\u03B8z":
      case "SURFACE_z_r\u03B8":
      case "SURFACE_r_\u03B8\u03C6":
      case "SURFACE_xyz_uv":
      case "IMPLICIT_SURFACE":
      case "SURFACE_AMBIGUOUS":
      case "SURFACE_CONSTANT_AMBIGUOUS":
      case "SURFACE_r_\u03B8z_AMBIGUOUS":
      case "IMPLICIT_SURFACE_AMBIGUOUS":
      case "SEGMENT3D":
      case "VECTOR3D":
      case "SLICE":
      case "SLICE_r\u03B8z_at_z":
      case "SLICE_zr\u03B8_at_r":
      case "SLICE_zr\u03B8_at_\u03B8":
      case "SLICE_zr\u03B8_at_xyz":
      case "SLICE_r\u03B8\u03C6_at_\u03B8":
      case "SLICE_r\u03B8\u03C6_at_\u03C6":
      case "SLICE_r\u03B8\u03C6_at_xyz":
      case "SLICE_xyz_uv":
        return {
          points: false,
          lines: (c = t.lines) != null ? c : r.lines,
          fill: false,
        };
      default:
        n && n(e);
        let l = e;
        return eC(e, t) || l;
    }
  }
  function tC(e) {
    if (e === void 0) return false;
    switch (e) {
      case "SINGLE_POINT":
      case "POINT_LIST":
      case "PARAMETRIC":
      case "POLYGON":
      case "X_OR_Y":
      case "VECTOR2D":
      case "POLAR":
      case "IMPLICIT":
      case "SURFACE":
      case "SURFACE_AMBIGUOUS":
      case "SURFACE_CONSTANT_AMBIGUOUS":
      case "SURFACE_r_\u03B8z":
      case "SURFACE_r_\u03B8z_AMBIGUOUS":
      case "SURFACE_z_r\u03B8":
      case "SURFACE_r_\u03B8\u03C6":
      case "SURFACE_xyz_uv":
      case "IMPLICIT_SURFACE":
      case "IMPLICIT_SURFACE_AMBIGUOUS":
      case "CURVE3D_xyz_t":
      case "SLICE":
      case "SLICE_r\u03B8z_at_z":
      case "SLICE_zr\u03B8_at_r":
      case "SLICE_zr\u03B8_at_\u03B8":
      case "SLICE_zr\u03B8_at_xyz":
      case "SLICE_r\u03B8\u03C6_at_\u03B8":
      case "SLICE_r\u03B8\u03C6_at_\u03C6":
      case "SLICE_r\u03B8\u03C6_at_xyz":
      case "SLICE_xyz_uv":
      case "SEGMENT3D":
      case "VECTOR3D":
      case "SPHERE3D":
      case "POINT3D":
      case "POINT3D_LIST":
      case "TRIANGLE3D":
        return true;
      case "HISTOGRAM":
      case "BOXPLOT":
      case "DOTPLOT":
      case "TTEST":
      case "STATS":
        return false;
      default:
        return e;
    }
  }
  function O_(e) {
    return e === "SURFACE_r_\u03B8\u03C6" ||
      e === "SLICE_r\u03B8\u03C6_at_\u03B8" ||
      e === "SLICE_r\u03B8\u03C6_at_\u03C6" ||
      e === "SLICE_r\u03B8\u03C6_at_xyz";
  }
  function N_(e) {
    return e === "SURFACE_z_r\u03B8" || e === "SLICE_zr\u03B8_at_r" ||
      e === "SLICE_zr\u03B8_at_\u03B8" || e === "SLICE_zr\u03B8_at_xyz";
  }
  function R_(e) {
    return e === "SURFACE_r_\u03B8z" || e === "SURFACE_r_\u03B8z_AMBIGUOUS" ||
      e === "SLICE_r\u03B8z_at_z";
  }
  var B = function () {};
  B.version = "1.2.6";
  B._myIndexOf = function (t) {
    var n = this.length, r;
    for (r = 0; r < n; ++r) if (this[r] === t) return r;
    return -1;
  };
  B.myIndexOf = Array.prototype.indexOf
    ? Array.prototype.indexOf
    : B._myIndexOf;
  B.precision = 4;
  B.largeArray = 50;
  B.compile = function () {
    var e = Array.prototype.slice.call(arguments), t = e.pop();
    return t = "return function (" + e.join(",") + ") {" + t + "}",
      new Function(["numeric"], t)(B);
  };
  B._dim = function (t) {
    for (var n = []; typeof t == "object";) n.push(t.length), t = t[0];
    return n;
  };
  B.dim = function (t) {
    var n, r;
    return typeof t == "object"
      ? (n = t[0],
        typeof n == "object"
          ? (r = n[0], typeof r == "object" ? B._dim(t) : [t.length, n.length])
          : [t.length])
      : [];
  };
  B.mapreduce = function (t, n) {
    return B.compile(
      "x",
      "accum",
      "_s",
      "_k",
      'if(typeof accum === "undefined") accum = ' + n + `;
if(typeof x === "number") { var xi = x; ` + t + `; return accum; }
if(typeof _s === "undefined") _s = numeric.dim(x);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i,xi;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) {
        accum = arguments.callee(x[i],accum,_s,_k+1);
    }    return accum;
}
for(i=_n-1;i>=1;i-=2) { 
    xi = x[i];
    ` + t + `;
    xi = x[i-1];
    ` + t + `;
}
if(i === 0) {
    xi = x[i];
    ` + t + `
}
return accum;`,
    );
  };
  B.mapreduce2 = function (t, n) {
    return B.compile(
      "x",
      `var n = x.length;
var i,xi;
` + n + `
for(i=n-1;i!==-1;--i) { 
    xi = x[i];
    ` + t + `
}
return accum;`,
    );
  };
  B.rep = function (t, n, r) {
    typeof r == "undefined" && (r = 0);
    var s = t[r], i = Array(s), o;
    if (r === t.length - 1) {
      for (o = s - 2; o >= 0; o -= 2) i[o + 1] = n, i[o] = n;
      return o === -1 && (i[0] = n), i;
    }
    for (o = s - 1; o >= 0; o--) i[o] = B.rep(t, n, r + 1);
    return i;
  };
  B.dotMMsmall = function (t, n) {
    var r, s, i, o, a, u, c, l, p, f, d, y, g, m;
    for (
      o = t.length, a = n.length, u = n[0].length, c = Array(o), r = o - 1;
      r >= 0;
      r--
    ) {
      for (l = Array(u), p = t[r], i = u - 1; i >= 0; i--) {
        for (f = p[a - 1] * n[a - 1][i], s = a - 2; s >= 1; s -= 2) {
          d = s - 1, f += p[s] * n[s][i] + p[d] * n[d][i];
        }
        s === 0 && (f += p[0] * n[0][i]), l[i] = f;
      }
      c[r] = l;
    }
    return c;
  };
  B._getCol = function (t, n, r) {
    var s = t.length, i;
    for (i = s - 1; i > 0; --i) r[i] = t[i][n], --i, r[i] = t[i][n];
    i === 0 && (r[0] = t[0][n]);
  };
  B.dotMMbig = function (t, n) {
    var r = B._getCol,
      s = n.length,
      i = Array(s),
      o = t.length,
      a = n[0].length,
      u = new Array(o),
      c,
      l = B.dotVV,
      p,
      f,
      d,
      y;
    for (--s, --o, p = o; p !== -1; --p) u[p] = Array(a);
    for (--a, p = a; p !== -1; --p) {
      for (r(n, p, i), f = o; f !== -1; --f) {
        y = 0, c = t[f], u[f][p] = l(c, i);
      }
    }
    return u;
  };
  B.dotMV = function (t, n) {
    var r = t.length, s = n.length, i, o = Array(r), a = B.dotVV;
    for (i = r - 1; i >= 0; i--) o[i] = a(t[i], n);
    return o;
  };
  B.dotVM = function (t, n) {
    var r, s, i, o, a, u, c, l, p, f, d, y, g, m, h, x, T, b, M;
    for (o = t.length, a = n[0].length, c = Array(a), i = a - 1; i >= 0; i--) {
      for (f = t[o - 1] * n[o - 1][i], s = o - 2; s >= 1; s -= 2) {
        d = s - 1, f += t[s] * n[s][i] + t[d] * n[d][i];
      }
      s === 0 && (f += t[0] * n[0][i]), c[i] = f;
    }
    return c;
  };
  B.dotVV = function (t, n) {
    var r, s = t.length, i, o = t[s - 1] * n[s - 1];
    for (r = s - 2; r >= 1; r -= 2) i = r - 1, o += t[r] * n[r] + t[i] * n[i];
    return r === 0 && (o += t[0] * n[0]), o;
  };
  B.dot = function (t, n) {
    var r = B.dim;
    switch (r(t).length * 1e3 + r(n).length) {
      case 2002:
        return n.length < 10 ? B.dotMMsmall(t, n) : B.dotMMbig(t, n);
      case 2001:
        return B.dotMV(t, n);
      case 1002:
        return B.dotVM(t, n);
      case 1001:
        return B.dotVV(t, n);
      case 1e3:
        return B.mulVS(t, n);
      case 1:
        return B.mulSV(t, n);
      case 0:
        return t * n;
      default:
        throw new Error("numeric.dot only works on vectors and matrices");
    }
  };
  B.diag = function (t) {
    var n, r, s, i = t.length, o = Array(i), a;
    for (n = i - 1; n >= 0; n--) {
      for (a = Array(i), r = n + 2, s = i - 1; s >= r; s -= 2) {
        a[s] = 0, a[s - 1] = 0;
      }
      for (s > n && (a[s] = 0), a[n] = t[n], s = n - 1; s >= 1; s -= 2) {
        a[s] = 0, a[s - 1] = 0;
      }
      s === 0 && (a[0] = 0), o[n] = a;
    }
    return o;
  };
  B.getDiag = function (e) {
    var t = Math.min(e.length, e[0].length), n, r = Array(t);
    for (n = t - 1; n >= 1; --n) r[n] = e[n][n], --n, r[n] = e[n][n];
    return n === 0 && (r[0] = e[0][0]), r;
  };
  B.identity = function (t) {
    return B.diag(B.rep([t], 1));
  };
  B.pointwise = function (t, n, r) {
    typeof r == "undefined" && (r = "");
    var s = [], i, o = /\[i\]$/, a, u = "", c = false;
    for (i = 0; i < t.length; i++) {
      o.test(t[i]) ? (a = t[i].substring(0, t[i].length - 3), u = a) : a = t[i],
        a === "ret" && (c = true),
        s.push(a);
    }
    return s[t.length] = "_s",
      s[t.length + 1] = "_k",
      s[t.length + 2] = 'if(typeof _s === "undefined") _s = numeric.dim(' + u +
        `);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i` + (c ? "" : ", ret = Array(_n)") + `;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee(` + t.join(",") + `,_s,_k+1);
    return ret;
}
` + r + `
for(i=_n-1;i!==-1;--i) {
    ` + n + `
}
return ret;`,
      B.compile.apply(null, s);
  };
  B.pointwise2 = function (t, n, r) {
    typeof r == "undefined" && (r = "");
    var s = [], i, o = /\[i\]$/, a, u = "", c = false;
    for (i = 0; i < t.length; i++) {
      o.test(t[i]) ? (a = t[i].substring(0, t[i].length - 3), u = a) : a = t[i],
        a === "ret" && (c = true),
        s.push(a);
    }
    return s[t.length] = "var _n = " + u + `.length;
var i` + (c ? "" : ", ret = Array(_n)") + `;
` + r + `
for(i=_n-1;i!==-1;--i) {
` + n + `
}
return ret;`,
      B.compile.apply(null, s);
  };
  B._biforeach = function e(t, n, r, s, i) {
    if (s === r.length - 1) {
      i(t, n);
      return;
    }
    var o, a = r[s];
    for (o = a - 1; o >= 0; o--) {
      e(
        typeof t == "object" ? t[o] : t,
        typeof n == "object" ? n[o] : n,
        r,
        s + 1,
        i,
      );
    }
  };
  B._biforeach2 = function e(t, n, r, s, i) {
    if (s === r.length - 1) return i(t, n);
    var o, a = r[s], u = Array(a);
    for (o = a - 1; o >= 0; --o) {
      u[o] = e(
        typeof t == "object" ? t[o] : t,
        typeof n == "object" ? n[o] : n,
        r,
        s + 1,
        i,
      );
    }
    return u;
  };
  B._foreach = function e(t, n, r, s) {
    if (r === n.length - 1) {
      s(t);
      return;
    }
    var i, o = n[r];
    for (i = o - 1; i >= 0; i--) e(t[i], n, r + 1, s);
  };
  B._foreach2 = function e(t, n, r, s) {
    if (r === n.length - 1) return s(t);
    var i, o = n[r], a = Array(o);
    for (i = o - 1; i >= 0; i--) a[i] = e(t[i], n, r + 1, s);
    return a;
  };
  B.ops2 = {
    add: "+",
    sub: "-",
    mul: "*",
    div: "/",
    mod: "%",
    and: "&&",
    or: "||",
    eq: "===",
    neq: "!==",
    lt: "<",
    gt: ">",
    leq: "<=",
    geq: ">=",
    band: "&",
    bor: "|",
    bxor: "^",
    lshift: "<<",
    rshift: ">>",
    rrshift: ">>>",
  };
  B.opseq = {
    addeq: "+=",
    subeq: "-=",
    muleq: "*=",
    diveq: "/=",
    modeq: "%=",
    lshifteq: "<<=",
    rshifteq: ">>=",
    rrshifteq: ">>>=",
    bandeq: "&=",
    boreq: "|=",
    bxoreq: "^=",
  };
  B.mathfuns = [
    "abs",
    "acos",
    "asin",
    "atan",
    "ceil",
    "cos",
    "exp",
    "floor",
    "log",
    "round",
    "sin",
    "sqrt",
    "tan",
    "isNaN",
    "isFinite",
  ];
  B.mathfuns2 = ["atan2", "pow", "max", "min"];
  B.ops1 = { neg: "-", not: "!", bnot: "~", clone: "" };
  B.mapreducers = {
    any: ["if(xi) return true;", "var accum = false;"],
    all: ["if(!xi) return false;", "var accum = true;"],
    sum: ["accum += xi;", "var accum = 0;"],
    prod: ["accum *= xi;", "var accum = 1;"],
    norm2Squared: ["accum += xi*xi;", "var accum = 0;"],
    norminf: [
      "accum = max(accum,abs(xi));",
      "var accum = 0, max = Math.max, abs = Math.abs;",
    ],
    norm1: ["accum += abs(xi);", "var accum = 0, abs = Math.abs;"],
    sup: ["accum = max(accum,xi);", "var accum = -Infinity, max = Math.max;"],
    inf: ["accum = min(accum,xi);", "var accum = Infinity, min = Math.min;"],
  };
  (function () {
    var e, t;
    for (e = 0; e < B.mathfuns2.length; ++e) t = B.mathfuns2[e], B.ops2[t] = t;
    for (e in B.ops2) {
      if (B.ops2.hasOwnProperty(e)) {
        t = B.ops2[e];
        var n, r, s = "";
        B.myIndexOf.call(B.mathfuns2, e) !== -1
          ? (s = "var " + t + " = Math." + t + `;
`,
            n = function (i, o, a) {
              return i + " = " + t + "(" + o + "," + a + ")";
            },
            r = function (i, o) {
              return i + " = " + t + "(" + i + "," + o + ")";
            })
          : (n = function (i, o, a) {
            return i + " = " + o + " " + t + " " + a;
          },
            B.opseq.hasOwnProperty(e + "eq")
              ? r = function (i, o) {
                return i + " " + t + "= " + o;
              }
              : r = function (i, o) {
                return i + " = " + i + " " + t + " " + o;
              }),
          B[e + "VV"] = B.pointwise2(
            ["x[i]", "y[i]"],
            n("ret[i]", "x[i]", "y[i]"),
            s,
          ),
          B[e + "SV"] = B.pointwise2(
            ["x", "y[i]"],
            n("ret[i]", "x", "y[i]"),
            s,
          ),
          B[e + "VS"] = B.pointwise2(
            ["x[i]", "y"],
            n("ret[i]", "x[i]", "y"),
            s,
          ),
          B[e] = B.compile(
            `var n = arguments.length, i, x = arguments[0], y;
var VV = numeric.` + e + "VV, VS = numeric." + e + "VS, SV = numeric." + e +
              `SV;
var dim = numeric.dim;
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof x === "object") {
      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);
      else x = numeric._biforeach2(x,y,dim(x),0,VS);
  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);
  else ` + r("x", "y") + `
}
return x;
`,
          ),
          B[t] = B[e],
          B[e + "eqV"] = B.pointwise2(
            ["ret[i]", "x[i]"],
            r("ret[i]", "x[i]"),
            s,
          ),
          B[e + "eqS"] = B.pointwise2(["ret[i]", "x"], r("ret[i]", "x"), s),
          B[e + "eq"] = B.compile(
            `var n = arguments.length, i, x = arguments[0], y;
var V = numeric.` + e + "eqV, S = numeric." + e + `eqS
var s = numeric.dim(x);
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);
  else numeric._biforeach(x,y,s,0,S);
}
return x;
`,
          );
      }
    }
    for (e = 0; e < B.mathfuns2.length; ++e) {
      t = B.mathfuns2[e], delete B.ops2[t];
    }
    for (e = 0; e < B.mathfuns.length; ++e) t = B.mathfuns[e], B.ops1[t] = t;
    for (e in B.ops1) {
      B.ops1.hasOwnProperty(e) &&
        (s = "",
          t = B.ops1[e],
          B.myIndexOf.call(B.mathfuns, e) !== -1 && Math.hasOwnProperty(t) &&
          (s = "var " + t + " = Math." + t + `;
`),
          B[e + "eqV"] = B.pointwise2(
            ["ret[i]"],
            "ret[i] = " + t + "(ret[i]);",
            s,
          ),
          B[e + "eq"] = B.compile(
            "x",
            'if(typeof x !== "object") return ' + t + `x
var i;
var V = numeric.` + e + `eqV;
var s = numeric.dim(x);
numeric._foreach(x,s,0,V);
return x;
`,
          ),
          B[e + "V"] = B.pointwise2(["x[i]"], "ret[i] = " + t + "(x[i]);", s),
          B[e] = B.compile(
            "x",
            'if(typeof x !== "object") return ' + t + `(x)
var i;
var V = numeric.` + e + `V;
var s = numeric.dim(x);
return numeric._foreach2(x,s,0,V);
`,
          ));
    }
    for (e = 0; e < B.mathfuns.length; ++e) t = B.mathfuns[e], delete B.ops1[t];
    for (e in B.mapreducers) {
      B.mapreducers.hasOwnProperty(e) &&
        (t = B.mapreducers[e],
          B[e + "V"] = B.mapreduce2(t[0], t[1]),
          B[e] = B.compile(
            "x",
            "s",
            "k",
            t[1] + `if(typeof x !== "object") {    xi = x;
` + t[0] + `
    return accum;
}if(typeof s === "undefined") s = numeric.dim(x);
if(typeof k === "undefined") k = 0;
if(k === s.length-1) return numeric.` + e + `V(x);
var xi;
var n = x.length, i;
for(i=n-1;i!==-1;--i) {
   xi = arguments.callee(x[i]);
` + t[0] + `
}
return accum;
`,
          ));
    }
  })();
  B.inv = function (g) {
    var n = B.dim(g),
      r = Math.abs,
      s = n[0],
      i = n[1],
      o = B.clone(g),
      a,
      u,
      c = B.identity(s),
      l,
      p,
      f,
      d,
      y,
      g;
    for (d = 0; d < i; ++d) {
      var m = -1, h = -1;
      for (f = d; f !== s; ++f) y = r(o[f][d]), y > h && (m = f, h = y);
      for (
        u = o[m],
          o[m] = o[d],
          o[d] = u,
          p = c[m],
          c[m] = c[d],
          c[d] = p,
          g = u[d],
          y = d;
        y !== i;
        ++y
      ) u[y] /= g;
      for (y = i - 1; y !== -1; --y) p[y] /= g;
      for (f = s - 1; f !== -1; --f) {
        if (f !== d) {
          for (a = o[f], l = c[f], g = a[d], y = d + 1; y !== i; ++y) {
            a[y] -= u[y] * g;
          }
          for (y = i - 1; y > 0; --y) l[y] -= p[y] * g, --y, l[y] -= p[y] * g;
          y === 0 && (l[0] -= p[0] * g);
        }
      }
    }
    return c;
  };
  B.det = function (t) {
    var n = B.dim(t);
    if (n.length !== 2 || n[0] !== n[1]) {
      throw new Error("numeric: det() only works on square matrices");
    }
    var r = n[0], s = 1, i, o, a, u = B.clone(t), c, l, p, f, d, y, g;
    for (o = 0; o < r - 1; o++) {
      for (a = o, i = o + 1; i < r; i++) {
        Math.abs(u[i][o]) > Math.abs(u[a][o]) && (a = i);
      }
      for (
        a !== o && (f = u[a], u[a] = u[o], u[o] = f, s *= -1),
          c = u[o],
          i = o + 1;
        i < r;
        i++
      ) {
        for (l = u[i], p = l[o] / c[o], a = o + 1; a < r - 1; a += 2) {
          d = a + 1, l[a] -= c[a] * p, l[d] -= c[d] * p;
        }
        a !== r && (l[a] -= c[a] * p);
      }
      if (c[o] === 0) return 0;
      s *= c[o];
    }
    return s * u[o][o];
  };
  B.transpose = function (t) {
    var n, r, s = t.length, i = t[0].length, o = Array(i), a, u, c;
    for (r = 0; r < i; r++) o[r] = Array(s);
    for (n = s - 1; n >= 1; n -= 2) {
      for (u = t[n], a = t[n - 1], r = i - 1; r >= 1; --r) {
        c = o[r],
          c[n] = u[r],
          c[n - 1] = a[r],
          --r,
          c = o[r],
          c[n] = u[r],
          c[n - 1] = a[r];
      }
      r === 0 && (c = o[0], c[n] = u[0], c[n - 1] = a[0]);
    }
    if (n === 0) {
      for (a = t[0], r = i - 1; r >= 1; --r) {
        o[r][0] = a[r], --r, o[r][0] = a[r];
      }
      r === 0 && (o[0][0] = a[0]);
    }
    return o;
  };
  B.negtranspose = function (t) {
    var n, r, s = t.length, i = t[0].length, o = Array(i), a, u, c;
    for (r = 0; r < i; r++) o[r] = Array(s);
    for (n = s - 1; n >= 1; n -= 2) {
      for (u = t[n], a = t[n - 1], r = i - 1; r >= 1; --r) {
        c = o[r],
          c[n] = -u[r],
          c[n - 1] = -a[r],
          --r,
          c = o[r],
          c[n] = -u[r],
          c[n - 1] = -a[r];
      }
      r === 0 && (c = o[0], c[n] = -u[0], c[n - 1] = -a[0]);
    }
    if (n === 0) {
      for (a = t[0], r = i - 1; r >= 1; --r) {
        o[r][0] = -a[r], --r, o[r][0] = -a[r];
      }
      r === 0 && (o[0][0] = -a[0]);
    }
    return o;
  };
  B.norm2 = function (t) {
    return Math.sqrt(B.norm2Squared(t));
  };
  B.linspace = function (t, n, r) {
    if (
      typeof r == "undefined" && (r = Math.max(Math.round(n - t) + 1, 1)), r < 2
    ) return r === 1 ? [t] : [];
    var s, i = Array(r);
    for (r--, s = r; s >= 0; s--) i[s] = (s * n + (r - s) * t) / r;
    return i;
  };
  B.getBlock = function (t, n, r) {
    var s = B.dim(t);
    function i(o, a) {
      var u, c = n[a], l = r[a] - c, p = Array(l);
      if (a === s.length - 1) {
        for (u = l; u >= 0; u--) p[u] = o[u + c];
        return p;
      }
      for (u = l; u >= 0; u--) p[u] = i(o[u + c], a + 1);
      return p;
    }
    return i(t, 0);
  };
  B.setBlock = function (t, n, r, s) {
    var i = B.dim(t);
    function o(a, u, c) {
      var l, p = n[c], f = r[c] - p;
      if (c === i.length - 1) { for (l = f; l >= 0; l--) a[l + p] = u[l]; }
      for (l = f; l >= 0; l--) o(a[l + p], u[l], c + 1);
    }
    return o(t, s, 0), t;
  };
  B.getRange = function (t, n, r) {
    var s = n.length, i = r.length, o, a, u = Array(s), c, l;
    for (o = s - 1; o !== -1; --o) {
      for (u[o] = Array(i), c = u[o], l = t[n[o]], a = i - 1; a !== -1; --a) {
        c[a] = l[r[a]];
      }
    }
    return u;
  };
  B.blockMatrix = function (t) {
    var n = B.dim(t);
    if (n.length < 4) return B.blockMatrix([t]);
    var r = n[0], s = n[1], i, o, a, u, c;
    for (i = 0, o = 0, a = 0; a < r; ++a) i += t[a][0].length;
    for (u = 0; u < s; ++u) o += t[0][u][0].length;
    var l = Array(i);
    for (a = 0; a < i; ++a) l[a] = Array(o);
    var p = 0, f, d, y, g, m;
    for (a = 0; a < r; ++a) {
      for (f = o, u = s - 1; u !== -1; --u) {
        for (c = t[a][u], f -= c[0].length, y = c.length - 1; y !== -1; --y) {
          for (
            m = c[y], d = l[p + y], g = m.length - 1;
            g !== -1;
            --g
          ) {
            d[f + g] = m[g];
          }
        }
      }
      p += t[a][0].length;
    }
    return l;
  };
  B.tensor = function (t, n) {
    if (typeof t == "number" || typeof n == "number") return B.mul(t, n);
    var r = B.dim(t), s = B.dim(n);
    if (r.length !== 1 || s.length !== 1) {
      throw new Error("numeric: tensor product is only defined for vectors");
    }
    var i = r[0], o = s[0], a = Array(i), u, c, l, p;
    for (c = i - 1; c >= 0; c--) {
      for (u = Array(o), p = t[c], l = o - 1; l >= 3; --l) {
        u[l] = p * n[l],
          --l,
          u[l] = p * n[l],
          --l,
          u[l] = p * n[l],
          --l,
          u[l] = p * n[l];
      }
      for (; l >= 0;) u[l] = p * n[l], --l;
      a[c] = u;
    }
    return a;
  };
  B.epsilon = 2220446049250313e-31;
  B.LU = function (e, t) {
    t = t || false;
    var n = Math.abs,
      r,
      s,
      i,
      o,
      a,
      u,
      c,
      l,
      p,
      f = e.length,
      d = f - 1,
      y = new Array(f);
    for (t || (e = B.clone(e)), i = 0; i < f; ++i) {
      for (c = i, u = e[i], p = n(u[i]), s = i + 1; s < f; ++s) {
        o = n(e[s][i]), p < o && (p = o, c = s);
      }
      for (
        y[i] = c,
          c != i && (e[i] = e[c], e[c] = u, u = e[i]),
          a = u[i],
          r = i + 1;
        r < f;
        ++r
      ) e[r][i] /= a;
      for (r = i + 1; r < f; ++r) {
        for (l = e[r], s = i + 1; s < d; ++s) {
          l[s] -= l[i] * u[s], ++s, l[s] -= l[i] * u[s];
        }
        s === d && (l[s] -= l[i] * u[s]);
      }
    }
    return { LU: e, P: y };
  };
  B.LUsolve = function (t, n) {
    var r, s, i = t.LU, o = i.length, a = B.clone(n), u = t.P, c, l, p, f;
    for (r = o - 1; r !== -1; --r) a[r] = n[r];
    for (r = 0; r < o; ++r) {
      for (
        c = u[r],
          u[r] !== r && (f = a[r], a[r] = a[c], a[c] = f),
          l = i[r],
          s = 0;
        s < r;
        ++s
      ) a[r] -= a[s] * l[s];
    }
    for (r = o - 1; r >= 0; --r) {
      for (l = i[r], s = r + 1; s < o; ++s) a[r] -= a[s] * l[s];
      a[r] /= l[r];
    }
    return a;
  };
  B.solve = function (t, n, r) {
    return B.LUsolve(B.LU(t, r), n);
  };
  var Un = B;
  var wU = Math.pow(2, -52);
  function eb(e) {
    for (let t of e) for (let n of t) if (!an(n)) return false;
    return true;
  }
  function FU(e) {
    let t = [];
    for (let n of e) t.push(n.slice());
    return t;
  }
  function __(e) {
    let { numRows: t, numCols: n } = Kh(e), r = [];
    for (let s = 0; s < n; s++) r.push([]);
    for (let s = 0; s < t; s++) for (let i = 0; i < n; i++) r[i].push(e[s][i]);
    return r;
  }
  function Kh(e) {
    let t = e.length, n = t > 0 ? e[0].length : 0;
    return { numRows: t, numCols: n };
  }
  function VU() {
    throw new Error("Matrix dimension mismatch");
  }
  function nC(e, t) {
    let n = Kh(e), r = Kh(t);
    n.numCols !== r.numRows && VU();
    let s = [];
    for (let i = 0; i < n.numRows; i++) {
      let o = [];
      for (let a = 0; a < r.numCols; a++) {
        let u = Se(0, 1);
        for (let c = 0; c < e[i].length; c++) u = qs(u, wr(e[i][c], t[c][a]));
        o.push(u);
      }
      s.push(o);
    }
    return s;
  }
  function L_(e) {
    let t = FU(e);
    return GU(t), t;
  }
  function BU(e) {
    let t = 0;
    for (let n of e) {
      for (let r of n) {
        let s = Math.abs(V(r));
        if (!isFinite(s)) return NaN;
        s > t && (t = s);
      }
    }
    return t;
  }
  function A_(e) {
    for (let t = 0; t < e.length; t++) {
      for (let n = 0; n < e[t].length; n++) e[t][n] = NaN;
    }
  }
  function GU(e) {
    let { numRows: t, numCols: n } = Kh(e), r = BU(e);
    if (!isFinite(r)) return A_(e), { determinant: NaN, rank: 0 };
    let s = Math.max(t, n) * r * wU, i = Se(1, 1), o = 0, a = 0;
    for (; o < t && a < n;) {
      let u = o, c = Math.abs(V(e[o][a]));
      for (let p = o + 1; p < t; p++) {
        let f = Math.abs(V(e[p][a]));
        (!isFinite(f) || f > c) && (c = f, u = p);
      }
      if (!isFinite(c)) return A_(e), { determinant: NaN, rank: 0 };
      if (c === 0) {
        i = Se(0, 1), a += 1;
        continue;
      }
      if (!an(e[u][a]) && c < s) {
        for (let p = o; p < t; p++) e[o][p] = 0;
        i = 0, a += 1;
        continue;
      }
      if (u !== o) {
        i = Us(i);
        let p = e[o];
        e[o] = e[u], e[u] = p;
      }
      for (let p = 0; p < t; p++) {
        if (p === o) continue;
        let f = Ps(e[p][a], e[o][a]);
        e[p][a] = Se(0, 1);
        for (let d = a + 1; d < n; d++) e[p][d] = ai(e[p][d], wr(f, e[o][d]));
      }
      let l = e[o][a];
      i = wr(i, l), e[o][a] = Se(1, 1);
      for (let p = a + 1; p < n; p++) e[o][p] = Ps(e[o][p], l);
      o += 1, a += 1;
    }
    return { rank: o, determinant: o === t && o === n ? i : Se(0, 1) };
  }
  function HU(e, t) {
    let n = e.length, r = t.length, s = 0, i = 0;
    for (let a = r - n; a < r; a++) {
      s += e[a + n - r] * t[a], i += e[a + n - r] * e[a + n - r];
    }
    let o = s / i;
    for (let a = r - n; a < r; a++) t[a] = 2 * o * e[a + n - r] - t[a];
  }
  function zU(e, t, n) {
    let r = e.length, s = t.length, i = 0, o = 0;
    for (let u = s - r; u < s; u++) {
      i += e[u + r - s] * t[u][n], o += e[u + r - s] * e[u + r - s];
    }
    let a = i / o;
    for (let u = s - r; u < s; u++) t[u][n] = 2 * a * e[u + r - s] - t[u][n];
  }
  function UU(e, t, n, r) {
    let s = Array(e.length - t);
    if (s.length === 1) return s[0] = 1, s;
    if (r === 0) {
      s[0] = 1;
      for (let o = 1; o < s.length; o++) s[o] = 0;
      return s;
    }
    let i = e[t][n] < 0 ? -1 : 1;
    s[0] = e[t][n] + i * Math.sqrt(r);
    for (let o = t + 1; o < e.length; o++) s[o - t] = e[o][n];
    return s;
  }
  function qU(e, t, n) {
    let r = 0;
    for (; t < e.length; t++) r += e[t][n] * e[t][n];
    return r;
  }
  function tb(e, t) {
    if (!t || !t.mutateInput) {
      let i = e;
      e = Array(e.length);
      for (let o = 0; o < i.length; o++) e[o] = i[o].slice();
    }
    let n = Math.min(e.length, e[0].length), r = Array(n), s = [];
    for (let i = 0; i < n; i++) {
      let o = -1 / 0, a = i;
      for (let c = i; c < e[i].length; c++) {
        let l = qU(e, i, c);
        l > o && (o = l, a = c);
      }
      if (r[i] = a, a !== i) {
        for (let c = 0; c < e.length; c++) {
          let l = e[c][a];
          e[c][a] = e[c][i], e[c][i] = l;
        }
      }
      let u = UU(e, i, i, o);
      for (let c = i; c < e[i].length; c++) zU(u, e, c);
      s.push(u);
    }
    return { reflectors: s, r: e, p: r };
  }
  function w_(e, t, n) {
    let { reflectors: r, r: s, p: i } = e, o = t.slice();
    for (let c = 0; c < r.length; c++) HU(r[c], o);
    for (let c = r.length; c < s[0].length; c++) o[c] = 0;
    o.length = s[0].length;
    let a = Math.pow(2, -52),
      u = n.regularize
        ? a * Math.abs(s[0][0]) * Math.max(s.length, s[0].length)
        : 0;
    for (let c = r.length - 1; c >= 0; c--) {
      let l = s[c];
      if (Math.abs(l[c]) <= u) o[c] = 0;
      else {
        for (let p = c + 1; p < r.length; p++) o[c] -= o[p] * l[p];
        o[c] /= l[c];
      }
    }
    for (let c = i.length - 1; c >= 0; c--) {
      if (i[c] !== c) {
        let l = o[c];
        o[c] = o[i[c]], o[i[c]] = l;
      }
    }
    return o;
  }
  function $U(e, t, n) {
    let r = Array(e.r[0].length);
    for (let i = 0; i < r.length; i++) r[i] = Array(t[0].length);
    let s = Array(t.length);
    for (let i = 0; i < t[0].length; i++) {
      for (let a = 0; a < t.length; a++) s[a] = t[a][i];
      let o = w_(e, s, n);
      for (let a = 0; a < o.length; a++) r[a][i] = o[a];
    }
    return r;
  }
  function Il(e, t, n) {
    return Array.isArray(t[0]) ? $U(e, t, n) : w_(e, t, n);
  }
  function YU(e) {
    let t = e.r,
      n = Math.min(t.length, t[0].length),
      r = t[0][0],
      s = t[n - 1][n - 1];
    return r === 0 ? 1 / 0 : Math.abs(r / s);
  }
  function F_(e) {
    let t = Math.pow(2, -52);
    return Math.max(e.r.length, e.r[0].length) * t * YU(e) < 1;
  }
  function rb(e, t) {
    let n = [];
    for (let r = 0; r < t; r++) n.push(e);
    return n;
  }
  function dm(e, t) {
    let n = Qu(e, t), r = 0;
    for (let s of n) {
      let i = s;
      r += i * i;
    }
    return r / n.length;
  }
  function Qu(e, t) {
    return e.apply(void 0, t);
  }
  function nb(e, t) {
    let n = [];
    for (let r of e) {
      let s = r.apply(void 0, t);
      n.push(s);
    }
    return n;
  }
  function V_(e, t) {
    let n = [];
    for (let r = 0; r < e.length; r++) t[r] && n.push(e[r]);
    return n;
  }
  function rC(e, t, n) {
    let r = [];
    for (let s = 0, i = 0; s < e.length; s++) {
      let o = 0;
      n[s] && (o = t[i], i += 1), r.push(e[s] + o);
    }
    return r;
  }
  function oC(e, t) {
    let n = t.solution.map((u) => Math.abs(u) < 1e-6 ? 0 : u),
      r = t.solution.map(() => 0),
      s = dm(e, n),
      i = Qu(e, n),
      o = Qu(e, r),
      a = 0;
    for (let u = 0; u < i.length; u++) {
      let c = o[u] * 1e-15;
      a += Math.abs(i[u] * c) + c * c;
    }
    return a /= i.length,
      isFinite(a) || (a = 0),
      isFinite(t.MSE) && !isFinite(s)
        ? t
        : s <= t.MSE + a
        ? { solution: n, MSE: s }
        : t;
  }
  function aC(e, t) {
    if (!eb(t) || !eb([e])) return;
    let n = __(t), r = nC([e], n)[0], s = nC(t, n);
    for (let c = 0; c < r.length; c++) s[c].push(Us(r[c]));
    let i = L_(s);
    if (!eb(i)) return;
    let o = [], a = r.length, u = 0;
    for (let c of i) {
      for (; u < a;) {
        if (V(c[u]) === 1) {
          o.push(c[c.length - 1]), u++;
          break;
        } else o.push(Se(0, 1)), u++;
      }
    }
    for (; u < a;) o.push(Se(0, 1)), u++;
    return o;
  }
  function uC(e, t) {
    let n = rb(0, t.length),
      r = nb(t, n),
      s = tb(Un.transpose(r), { mutateInput: true });
    for (let u = 0; u < 2; u++) {
      let c = Qu(e, n), l = Un.neg(Il(s, c, { regularize: false }));
      n = Un.add(n, l);
    }
    let i = dm(e, n);
    if (F_(s)) return { solution: n, MSE: i };
    let o = rb(0, t.length);
    for (let u = 0; u < 2; u++) {
      let c = Qu(e, o), l = Un.neg(Il(s, c, { regularize: true }));
      o = Un.add(o, l);
    }
    let a = dm(e, o);
    return .999 * a <= i ? { solution: o, MSE: a } : { solution: n, MSE: i };
  }
  function sC(e, t, n, r) {
    let s = r.maxIterations,
      i = r.linearSubset || rb(false, n.length),
      o = Un.not(i),
      a = V_(t, i),
      u = V_(t, o),
      c = 2,
      l = .1,
      p = n,
      f = 0,
      d = .001,
      y;
    if (a.length > 0) {
      let h = Un.transpose(nb(a, p)), x = tb(h);
      y = { Jv: h, F: x };
      let T = Qu(e, p), b = Un.neg(Il(x, T, { regularize: true }));
      p = rC(p, b, i);
    }
    let g = false, m = dm(e, p);
    for (; f < s && !g && isFinite(m);) {
      let h = Qu(e, p), x = nb(u, p), T = Un.transpose(x), b, M;
      if (y) {
        let { F: S, Jv: O } = y;
        b = Un.dot(x, Un.sub(h, Un.dot(O, Il(S, h, { regularize: true })))),
          M = Un.dot(x, Un.sub(T, Un.dot(O, Il(S, T, { regularize: true }))));
      } else b = Un.dot(x, h), M = Un.dot(x, T);
      let P = p, D = false;
      for (; f < s && !g && !D;) {
        f += 1;
        let S = Un.add(M, Un.diag(rb(d, u.length))),
          O = Un.neg(Un.solve(S, b, true));
        P = rC(p, O, o), g = Un.all(Un.eq(P, p));
        let _;
        if (y) {
          let w = Un.transpose(nb(a, P)), G = tb(w);
          _ = { Jv: w, F: G };
          let k = Qu(e, P), Z = Un.neg(Il(G, k, { regularize: true }));
          P = rC(P, Z, i);
        }
        let L = dm(e, P);
        D = L < m,
          D ? (p = P, m = L, y = _, d *= l) : (d = Math.max(d, 1e-64), d *= c);
      }
    }
    return { solution: p, MSE: m };
  }
  var iC = [
    18.9,
    .105,
    .0113,
    .089,
    4.414,
    .373,
    .06,
    .149,
    1.84,
    9.26,
    5,
    .7,
    .2,
    1.13,
    2.61,
    1,
    .007,
    30,
    120,
    1500,
    4e-4,
    7.23,
    -1,
    -.0081,
    -.03,
    -28.6,
    -1.71,
    -.4,
    -6.94,
    -.777,
    -500,
  ];
  function XU(e) {
    let t = e * 503 % iC.length;
    return iC[t];
  }
  function ZU(e) {
    let t = [];
    for (let n = 0; n < iC.length; n++) {
      let r = [];
      for (let s = 0; s < e; s++) {
        n === 0 && e !== 1
          ? r[s] = 0
          : n === 1 && e !== 1
          ? r[s] = 1
          : r[s] = XU(n * e + s);
      }
      t.push(r);
    }
    return t;
  }
  function B_(e, t, n, r, s) {
    let i = [];
    for (let a of n) i.push({ soln: sC(e, t, a, s), initialGuess: a });
    i.sort((a, u) =>
      isNaN(a.soln.MSE) ? 1 : isNaN(u.soln.MSE) ? -1 : a.soln.MSE - u.soln.MSE
    );
    let o = [];
    for (let a = 0; a < r; a++) o.push(i[a].initialGuess);
    return o;
  }
  function WU(e, t, n, r) {
    if (!t || Fs(t)) return e;
    let s = t.bounds;
    return s[0] === -1 / 0 && s[1] === 1 / 0
      ? e
      : s[0] === -1 / 0
      ? s[1] - Math.exp(-e)
      : s[1] === 1 / 0
      ? s[0] + Math.exp(e)
      : n / (r - 1) * s[1] + (r - 1 - n) / (r - 1) * s[0];
  }
  var G_ = [3, 5, 7, 11, 13, 17, 19];
  function jU(e, t) {
    let n = [];
    for (let r = 0; r < e.length; r++) {
      let s = e[r], i = [];
      for (let o = 0; o < s.length; o++) {
        let a = G_[o % G_.length] * r % e.length;
        i.push(WU(s[o], t[o], a, e.length));
      }
      n.push(i);
    }
    return n;
  }
  function k_(e, t, n) {
    n || (n = {});
    let { linearSubset: r, bounds: s, preferredInitialGuess: i } = n,
      o = ZU(t.length);
    s && (o = jU(o, s));
    let a = B_(e, t, o, 5, { maxIterations: 3, linearSubset: r }),
      u = B_(e, t, a, 1, { maxIterations: 60, linearSubset: r }),
      c = sC(e, t, u[0], { maxIterations: 250, linearSubset: r });
    if (!i) return c;
    let l = sC(e, t, i, { maxIterations: 100, linearSubset: r });
    return isFinite(l.MSE) && (l.MSE < c.MSE || si(l.MSE, c.MSE, 8)) ? l : c;
  }
  function cC(e) {
    return { chunk: e, isLazy: true };
  }
  function H_(e) {
    return e.slice();
  }
  function ib(e) {
    if (!e.isLazy) return e;
    let t = e.chunk.copy();
    return t.reopenFinalBlock(), {
      chunk: t,
      forwardParameterMap: H_,
      reverseParameterMap: H_,
      isLazy: false,
      valueMap: nq(e.chunk.instructionsLength()),
      replacementMask: ad(e.chunk.argNames.length),
    };
  }
  function z_(e) {
    let {
      chunk: t,
      forwardParameterMap: n,
      reverseParameterMap: r,
      isLazy: s,
      valueMap: i,
      replacementMask: o,
      didShiftScale: a,
    } = e;
    return {
      chunk: t.copy(),
      forwardParameterMap: n,
      reverseParameterMap: r,
      isLazy: s,
      valueMap: i.slice(),
      replacementMask: o.slice(),
      didShiftScale: a,
    };
  }
  function JU(e) {
    let t = 1 / 0, n = -1 / 0, r = e.length;
    for (let s of e) t = Math.min(t, s), n = Math.max(n, s);
    return { min: t, max: n, length: r };
  }
  function $_(e) {
    let t = e.getInstruction(e.getReturnIndex());
    if (t.type !== 48) return;
    let n = t.args[0], r = e.getReturnIndex() - n, s = e.getInstruction(n);
    if (s.args.length !== 2) return;
    let i = s.args[0], o = s.args[r], a = [], u = [];
    a.push(i),
      u.push({
        min: 1,
        max: qo(
          e,
          e.getReturnIndex(),
          "Programming error: cannot optimize regression on non-constant-length list",
        ),
        length: qo(
          e,
          e.getReturnIndex(),
          "Programming error: cannot optimize regression on non-constant-length list",
        ),
      });
    let c = false, l = false;
    for (let m = i + 1; m <= o; m++) {
      let h = e.getInstruction(m);
      if (h.type === 39 || h.type === 41 || h.type === 40) {
        if (h.args[1] !== i) continue;
        let x = h.args[0];
        if (
          e.getInstruction(x).valueType !== ListOfNumber ||
          !Je(e.getInstruction(x))
        ) {
          continue;
        }
        let T = hn(e, x), b = JU(T);
        if (!isFinite(b.min) || !isFinite(b.max)) continue;
        a.push(m), u.push(b);
      } else if (h.type === 37) {
        h.symbol === "exp" ? l = true : q_(h) && (c = true);
      } else if (h.type === 12 || h.type === 13) l = true;
      else if (es(h) || ds(h)) return;
    }
    if (a.length === 0 || !l && !c) return;
    let p = [];
    for (let m = 0; m <= o; m++) {
      let h = a.indexOf(m);
      if (h !== -1) {
        let x = ad(a.length);
        x[h] = true, p.push(x);
      } else p.push(sb(e, p, a.length, m));
    }
    let f = [];
    for (let m = 0; m <= e.getReturnIndex(); m++) {
      if (e.getInstruction(m).type === 2) {
        let x = ad(e.argNames.length);
        x[m] = true, f.push(x);
      } else f.push(sb(e, f, e.argNames.length, m));
    }
    let d = {
        listAccessDependencyTable: p,
        listAccesses: a,
        listStatisticsTable: u,
      },
      y;
    for (let m = i + 1; m <= e.getReturnIndex(); m++) {
      let h = e.getInstruction(m);
      switch (h.type) {
        case 37: {
          if (h.symbol === "exp") {
            let Z = h.args[0], F = lC(d, Z);
            if (F === void 0) {
              au(e, f, y, m);
              break;
            }
            let { listStatistics: Y, listAccessIndex: re } = F,
              Ee = fm(cC(e), m, Z, re, Y);
            Ee ? y = [Ee] : au(e, f, y, m);
          }
          break;
        }
        case 12:
        case 13: {
          let [Z, F] = h.args, Y = lC(d, F);
          if (Y === void 0 || U_(d, Z)) {
            au(e, f, y, m);
            break;
          }
          let { listStatistics: re, listAccessIndex: Ee } = Y,
            he = KU(cC(e), m, Ee, re);
          he ? y = [he] : au(e, f, y, m);
          break;
        }
        case 10:
          if (y && y.length > 1) {
            au(e, f, y, m);
            break;
          }
          let x = y && y.length > 0 ? y[0] : cC(e),
            [T, b] = h.args,
            M = x.isLazy ? T : x.valueMap[T],
            P = x.isLazy ? b : x.valueMap[b],
            D = x.chunk.getInstruction(M),
            S = x.chunk.getInstruction(P),
            O,
            _,
            L;
          if (D.type === 37) O = T, L = D, _ = b;
          else if (S.type === 37) O = b, L = S, _ = T;
          else {
            au(e, f, y, m);
            break;
          }
          let w = lC(d, O);
          if (w === void 0 || U_(d, _)) {
            au(e, f, y, m);
            break;
          }
          let { listAccessIndex: G, listStatistics: k } = w;
          if (L.symbol === "exp") {
            let Z = eq(x, m, _, O, G, k);
            if (Z) {
              y = Z;
              break;
            }
          } else if (q_(L)) {
            let Z = QU(x, m, _, O, G);
            if (Z) {
              y = [Z];
              break;
            }
          }
          au(e, f, y, m);
          break;
        default: {
          au(e, f, y, m);
          break;
        }
      }
    }
    if (y === void 0 || y.length === 0) return;
    let g = [];
    for (let m of y) {
      g.push({
        chunk: m.chunk,
        forwardParameterMap: m.forwardParameterMap,
        reverseParameterMap: m.reverseParameterMap,
      });
    }
    return g;
  }
  function au(e, t, n, r) {
    if (n === void 0) return;
    let s = e.getInstruction(r);
    if (ge(s)) { for (let i of n) i.valueMap[r] = r; }
    else {for (let i of n) {
        let { chunk: o, valueMap: a } = i, u = [], c = 0;
        for (let l of s.args) {
          if (a[l] !== l) {
            if (c += 1, c > 1) {
              n.length = 0;
              return;
            }
          } else {
            let p = t[l];
            for (let f = 0; f < p.length; f++) {
              if (p[f] && i.replacementMask[f]) {
                n.length = 0;
                return;
              }
            }
          }
          u.push(a[l]);
        }
        a[r] = c > 0 ? _n(o, s, u) : r;
      }}
  }
  function lC(e, t) {
    let {
        listAccessDependencyTable: n,
        listAccesses: r,
        listStatisticsTable: s,
      } = e,
      i,
      o = n[t];
    for (let a = 0; a < o.length; a++) {
      if (o[a]) {
        if (i) return;
        i = { listAccessIndex: r[a], listStatistics: s[a] };
      }
    }
    return i;
  }
  function U_(e, t) {
    let { listAccessDependencyTable: n } = e, r = n[t];
    for (let s of r) if (s) return true;
    return false;
  }
  function pC(e, t) {
    let n = [];
    for (let i = 0; i <= t; i++) {
      if (e.getInstruction(i).type === 2) {
        let a = ad(e.argNames.length);
        a[i] = true, n.push(a);
      } else n.push(sb(e, n, e.argNames.length, i));
    }
    let r, s = n[t];
    for (let i = 0; i < s.length; i++) {
      if (s[i]) {
        if (r !== void 0) return;
        r = i;
      }
    }
    return r;
  }
  function QU(e, t, n, r, s) {
    let i = e.chunk, o = pC(i, n);
    if (o === void 0) return;
    let a = dC(e, n, o);
    if (a === void 0) return;
    let u = i.getInstruction(r), c = u.args[0];
    if (a = Y_(a, c, s), a === void 0) return;
    let { chunk: l, valueMap: p } = a, f = l.getInstruction(p[c]);
    if (f.type !== 8) return;
    let d = f.args[1], y = l.getInstruction(f.args[0]);
    if (y.type !== 10) return;
    let [g, m] = y.args,
      h = o,
      x = d,
      T = g,
      b = m,
      M = l.Multiply([T, b]),
      P = l.NativeFunction("cos", [M]),
      D = l.NativeFunction("sin", [M]),
      S = u.symbol === "sin"
        ? l.Add([l.Multiply([h, D]), l.Multiply([x, P])])
        : l.Subtract([l.Multiply([h, P]), l.Multiply([x, D])]);
    p[t] = S;
    function O(w) {
      let G = a.forwardParameterMap(w),
        k = G[o],
        Z = G[d],
        F = k * Math.cos(Z),
        Y = k * Math.sin(Z);
      return G[o] = F, G[d] = Y, G;
    }
    function _(w) {
      let G = w.slice(),
        k = w[o],
        Z = w[d],
        F = hypot(k, Z),
        Y = Math.atan2(Z, k);
      return G[o] = F, G[d] = Y, a.reverseParameterMap(G);
    }
    let L = a.replacementMask.slice();
    return L[o] = true, L[g] = true, L[d] = true, {
      chunk: l,
      forwardParameterMap: O,
      reverseParameterMap: _,
      valueMap: p,
      replacementMask: L,
      isLazy: false,
    };
  }
  function KU(e, t, n, r) {
    let s = e.chunk,
      i = s.getInstruction(t),
      [o, a] = i.args,
      u = s.getInstruction(o);
    if (u.type === 1 && u.valueType === Number && V(u.value) > 0) {
      let x = ib(e),
        { chunk: T, valueMap: b } = x,
        M = T.Multiply([T.NativeFunction("ln", [b[o]]), b[a]]);
      return b[a] = M,
        b[t] = T.NativeFunction("exp", [M]),
        fm(x, t, a, n, r) || x;
    }
    let c = pC(s, o);
    if (c === void 0) return;
    let l = dC(e, o, c);
    if (l === void 0) return;
    let { chunk: p, valueMap: f } = l, d = p.Multiply([f[o], f[a]]);
    f[a] = d, f[t] = p.NativeFunction("exp", [d]);
    function y(x) {
      let T = l.forwardParameterMap(x), b = T[c], M = Math.log(b);
      return T[c] = M, T;
    }
    function g(x) {
      let T = x.slice(), b = T[c], M = Math.exp(b);
      return T[c] = M, l.reverseParameterMap(T);
    }
    let m = l.replacementMask.slice();
    m[c] = true;
    let h = {
      chunk: p,
      forwardParameterMap: y,
      reverseParameterMap: g,
      isLazy: false,
      valueMap: f,
      replacementMask: m,
    };
    return fm(h, t, a, n, r) || h;
  }
  function eq(e, t, n, r, s, i) {
    if (!e.isLazy && e.didShiftScale) return;
    let o = e.isLazy ? e : z_(e), a = e.chunk, u = pC(a, n);
    if (u === void 0) return;
    let c = dC(e, n, u);
    if (c === void 0) return;
    let { chunk: l, valueMap: p } = c,
      f = l.getInstruction(p[r]).args[0],
      d = l.Add([f, p[n]]);
    p[n] = d, p[t] = l.NativeFunction("exp", [d]);
    function y(P) {
      let D = c.forwardParameterMap(P), S = D[u], O = Math.log(S);
      return D[u] = O, D;
    }
    function g(P) {
      let D = P.slice(), S = D[u], O = Math.exp(S);
      return D[u] = O, c.reverseParameterMap(D);
    }
    function m(P) {
      let D = c.forwardParameterMap(P), S = D[u], O = Math.log(-S);
      return D[u] = O, D;
    }
    function h(P) {
      let D = P.slice(), S = D[u], O = -Math.exp(S);
      return D[u] = O, c.reverseParameterMap(D);
    }
    let x = c.replacementMask.slice();
    x[u] = true;
    let T = ib(o);
    T.valueMap[t] = T.chunk.Multiply([T.valueMap[n], T.valueMap[r]]);
    let b = {
        chunk: l,
        forwardParameterMap: y,
        reverseParameterMap: g,
        isLazy: false,
        valueMap: p,
        replacementMask: x,
      },
      M = z_(b);
    return M.forwardParameterMap = m,
      M.reverseParameterMap = h,
      b = fm(b, t, n, s, i) || b,
      M = fm(M, t, n, s, i) || M,
      M.valueMap[t] = M.chunk.Negative([M.valueMap[t]]),
      [T, b, M];
  }
  function fm(e, t, n, r, s) {
    let i = tq(e, n, r, s);
    if (i !== void 0) {
      return i.valueMap[t] = i.chunk.NativeFunction("exp", [i.valueMap[n]]), i;
    }
  }
  function tq(e, t, n, r) {
    let s = Y_(e, t, n);
    if (s === void 0) return;
    let { chunk: i, valueMap: o } = s, a = i.getInstruction(o[t]);
    if (a.type !== 8) return;
    let u = a.args[1], c = i.getInstruction(a.args[0]);
    if (c.type !== 10) return;
    let [l, p] = c.args,
      { min: f, max: d } = r,
      y = d - f,
      g = .5 * (d + f),
      m = i.Divide([i.Subtract([p, i.Constant(g)]), i.Constant(y)]),
      h = i.Add([i.Multiply([l, m]), u]);
    o[t] = h;
    function x(b) {
      let M = s.forwardParameterMap(b),
        P = M[l],
        D = M[u],
        S = P * y,
        O = D + g * P;
      return M[l] = S, M[u] = O, M;
    }
    function T(b) {
      let M = b.slice(), P = b[l], D = b[u], S = P / y, O = D - S * g;
      return M[l] = S, M[u] = O, s.reverseParameterMap(M);
    }
    return {
      chunk: i,
      forwardParameterMap: x,
      reverseParameterMap: T,
      isLazy: false,
      valueMap: o,
      replacementMask: s.replacementMask,
      didShiftScale: true,
    };
  }
  function dC(e, t, n) {
    let r = e.chunk,
      s = ns(r, n, {
        allowRestriction: false,
        allowClosedBlockReferences: false,
      });
    if (ln(s, t) !== 1) return;
    let i = fo(s, t), [o, a] = Kn(i, t);
    if (a === void 0) return;
    let u = i.newChunk.getInstruction(o);
    if (u.type !== 1 || u.valueType !== Number) return;
    let c = i.newChunk.getInstruction(a);
    if (c.type !== 1 || c.valueType !== Number) return;
    let l = ib(e),
      { chunk: p, valueMap: f } = l,
      d = V(u.value),
      y = V(c.value);
    f[t] = n;
    function g(x) {
      let T = l.forwardParameterMap(x), b = T[n], M = d + y * b;
      return T[n] = M, T;
    }
    function m(x) {
      let T = x.slice(), M = (T[n] - d) / y;
      return T[n] = M, l.reverseParameterMap(T);
    }
    let h = l.replacementMask.slice();
    return h[n] = true, {
      chunk: p,
      forwardParameterMap: g,
      reverseParameterMap: m,
      isLazy: false,
      valueMap: f,
      replacementMask: h,
    };
  }
  function Y_(e, t, n) {
    let r = e.chunk,
      s = e.isLazy ? t : e.valueMap[t],
      i = ns(r, n, {
        allowRestriction: false,
        allowClosedBlockReferences: true,
      });
    if (ln(i, s) !== 1) return;
    e.isLazy &&
      (i = ns(r.copy().reopenFinalBlock(), n, {
        allowRestriction: false,
        allowClosedBlockReferences: false,
      }));
    let o = fo(i, s), [a, u] = Kn(o, s);
    if (u === void 0) return;
    let c = o.newChunk, l = Math.max(u, a), p = [];
    for (let K = 0; K <= l; K++) {
      if (c.getInstruction(K).type === 2) {
        let te = ad(c.argNames.length);
        te[K] = true, p.push(te);
      } else p.push(sb(c, p, c.argNames.length, K));
    }
    let f, d;
    for (let K = 0; K < r.argNames.length; K++) {
      if (p[u][K]) {
        if (f === void 0) f = K;
        else return;
      } else if (p[a][K]) {
        if (d === void 0) d = K;
        else return;
      }
    }
    if (f === void 0 || d === void 0) return;
    let y = ns(c, f, {
      allowRestriction: false,
      allowClosedBlockReferences: false,
    });
    if (ln(y, u) !== 1) return;
    let g = ns(c, d, {
      allowRestriction: false,
      allowClosedBlockReferences: false,
    });
    if (ln(g, a) !== 1) return;
    let m = fo(y, u),
      h = fo(g, a),
      [x, T] = Kn(m, u),
      b = m.newChunk.getInstruction(x);
    if (b.type !== 1 || b.valueType !== Number) return;
    let M = m.newChunk.getInstruction(T);
    if (M.type !== 1 || M.valueType !== Number) return;
    let P = ib(e),
      { chunk: D, valueMap: S } = P,
      O = D.Add([D.Multiply([f, n]), d]);
    S[t] = O;
    let _ = c.copy();
    _.List([u, a]);
    let L = _.getCompiledFunction().fn;
    function w(K) {
      let Oe = P.forwardParameterMap(K), [te, Ze] = L.apply(null, Oe);
      return Oe[f] = te, Oe[d] = Ze, Oe;
    }
    let G = V(b.value),
      k = V(M.value),
      [Z, F] = Kn(h, a),
      Y = h.newChunk.copy();
    Y.List([Z, F]);
    let re = Y.getCompiledFunction().fn;
    function Ee(K) {
      let Oe = K.slice(),
        te = K[f],
        Ze = K[d],
        dt = (te - G) / k,
        me = K.slice();
      me[f] = dt, me.splice(d, 1);
      let [J, W] = re.apply(null, me), Ge = (Ze - J) / W;
      return Oe[f] = dt, Oe[d] = Ge, P.reverseParameterMap(Oe);
    }
    let he = P.replacementMask.slice();
    return he[f] = true, he[d] = true, {
      chunk: D,
      forwardParameterMap: w,
      reverseParameterMap: Ee,
      isLazy: false,
      valueMap: S,
      replacementMask: he,
    };
  }
  function sb(e, t, n, r) {
    let s = e.getInstruction(r), i = ad(n);
    if (ge(s)) return i;
    for (let o of s.args) {
      let a = t[o];
      for (let u = 0; u < a.length; u++) i[u] = i[u] || a[u];
    }
    return i;
  }
  function ad(e) {
    let t = [];
    for (let n = 0; n < e; n++) t.push(false);
    return t;
  }
  function nq(e) {
    let t = [];
    for (let n = 0; n < e; n++) t.push(n);
    return t;
  }
  function q_(e) {
    return e.type === 37 && (e.symbol === "sin" || e.symbol === "cos");
  }
  function iL(e, t) {
    try {
      return iq(e, t);
    } catch (n) {
      return n instanceof C.Error ? n : U(n);
    }
  }
  var ud = { coerceToNumber: "all-except-complex" },
    fC = { ...ud, wrapInList: true };
  function X_(e) {
    return e === Number || e === ListOfNumber || e === Complex ||
      e === ListOfComplex;
  }
  function rq(e) {
    return !!e.tableRegressionData;
  }
  function sq(e, t) {
    return e === EmptyList || t === EmptyList ? false : X_(e) && X_(t);
  }
  function iq(e, t) {
    let {
        policy: n,
        frame: r,
        exportFrame: s,
        lastExportFrame: i,
        tableStatements: o,
      } = e,
      a = t._lhs.buildIRExpression(n, r, ud),
      u = t._rhs.buildIRExpression(n, r, ud);
    if (a.isError) throw a;
    if (u.isError) throw u;
    if (!sq(a.valueType, u.valueType)) {
      throw PT([oe(a.valueType), oe(u.valueType)]);
    }
    let c = t._difference.buildIRExpression(n, r, fC);
    if (c.isError) throw c;
    let l = c.valueType;
    for (let S of c.getDependencies()) {
      if (!n.validRegressionParameter(S)) throw tP(S);
    }
    let f = !rq(t)
        ? W_(c.getDependencies(), t.userData.regressionParameters, i)
        : W_(c.getDependencies(), {}, {}),
      {
        parameters: d,
        residuals: y,
        isLinear: g,
        parameterWarning: m,
        displayPrecision: h,
      } = sL(f, c, a),
      x = { policy: n, frame: r },
      T = Z_(x, t, d),
      b = is.NONE;
    l === ListOfNumber && (b = dq(t, a, T));
    let M;
    if (
      t.userData.isLogModeRegression && (b === is.LOGLIN || b === is.LOGLOG)
    ) {
      let S = t._logDifference.buildIRExpression(n, r, fC);
      if (S.isError) throw S;
      let O = t._logLhs.buildIRExpression(n, r, fC);
      if (O.isError) throw O;
      ({
        parameters: d,
        isLinear: g,
        parameterWarning: m,
        displayPrecision: h,
      } = sL(f, S, a)),
        T = Z_(x, t, d),
        y = tL(x, t._difference, d);
      let _ = tL(x, t._logDifference, d);
      M = K_(t, O, T, _, t.userData.isLogModeRegression, b, l);
    } else M = K_(t, a, T, y, t.userData.isLogModeRegression, b, l);
    let P = oq(t, s), D = pq(t, P, o, y);
    return t.userData.residualVariable = identifierToLatex(P),
      new C.OptimizedRegression(d, lt(l, y), M, T.substituted, {
        isModelValid: !!T.uniqueRHSNumberList,
        residualVariable: P,
        residualSuggestionId: D,
        shouldSuggestLogMode: b !== is.NONE,
        isLinear: g,
        displayPrecision: h,
        parameterWarning: m,
      });
  }
  function oq(e, t) {
    if (e.userData && e.userData.residualVariable) {
      let i = latexToIdentifier(e.userData.residualVariable);
      if (!t[i]) return i;
    }
    let n = e.getDependencies().filter((i) =>
        i[0] !== "_" && !i.startsWith("regressionparameter_") &&
        !i.startsWith("idref_")
      ),
      r;
    for (let i of n) {
      let o = i.match(/_(.*)/);
      if (o && (r = "e_" + o[1], !t[r])) return r;
    }
    let s = 1;
    for (;;) {
      if (r = "e_" + s, !t[r]) return r;
      s++;
    }
  }
  function Z_({ policy: e, frame: t }, n, r) {
    let s = n._rhs.getDependencies(), i, o;
    for (let p of s) {
      if (r.hasOwnProperty(p)) continue;
      let f = t[p];
      if (
        !f || f.isFunction ||
        (f.type === "Assignment" && (f = f._expression), !f.buildIRExpression)
      ) continue;
      let d = f.buildIRExpression(e, t, ud);
      if (!d.isError && kn(d.valueType, ListOfNumber)) {
        if (i !== void 0) {
          i = void 0, o = void 0;
          break;
        }
        d.getDependencies().length === 0 && (i = p, o = d);
      }
    }
    let a = Tn(t);
    i !== void 0 && (a[i] = void 0);
    let u = n._rhs.buildIRExpression(e, a, ud), c = Tn(a);
    for (let p of We(r)) c[p] = r[p];
    let l = n._rhs.buildIRExpression(e, c, ud);
    return { node: u, substituted: l, uniqueRHSNumberList: o };
  }
  function W_(e, t, n) {
    let r = [];
    if (t || (t = {}), n || (n = {}), !e.every((s) => s in n || s in t)) {
      return e.map((s) => 1);
    }
    for (let s of e) {
      let i = identifierToLatex(s), o = n[s];
      o && isFinite(o.asValue())
        ? r.push(+o.asValue())
        : t.hasOwnProperty(i) && isFinite(+t[i])
        ? r.push(+t[i])
        : r.push(1);
    }
    return r;
  }
  function yC(e, t) {
    switch (t) {
      case ListOfNumber:
        return e;
      case ListOfComplex:
        return function (...r) {
          let s = e.apply(void 0, r);
          return aq(s);
        };
      default:
        throw U("Regression with invalid value type.");
    }
  }
  function j_(e, t) {
    switch (t) {
      case ListOfNumber:
        return e;
      case ListOfComplex:
        return uq(e);
      default:
        throw U("Regression with invalid value type.");
    }
  }
  function aq(e) {
    let t = [];
    for (let [n, r] of e) t.push(n, r);
    return t;
  }
  function uq(e) {
    let t = [];
    for (let [n, r] of e) t.push(n, r);
    return t;
  }
  function J_(e, t) {
    let n = t.getDependencies(),
      r = t.getCompiledFunction(n).fn,
      s = t.valueType,
      i = yC(r, s);
    if (n.length) {
      let o = t.findLinearSubset(n), a = o.every((c) => c), u = [];
      for (let c of n) {
        let l = t.takeDerivative(c).getCompiledFunction(n).fn;
        u.push(yC(l, s));
      }
      if (a) {
        let c = n.map(() => Se(0, 1)),
          l = t.interpretWithParameters(c),
          p = j_(l, s),
          f = [];
        for (let m of n) {
          let h = t.takeDerivative(m).interpretWithParameters(c);
          f.push(j_(h, s));
        }
        let d = aC(p, f);
        if (d) {
          let m = t.interpretWithParameters(d);
          return { solution: d, residuals: m, MSE: ob(m, s), isLinear: a };
        }
        let { solution: y, MSE: g } = oC(i, uC(i, u));
        return {
          solution: y,
          residuals: r.apply(void 0, y),
          MSE: nL(g, s),
          isLinear: a,
        };
      } else {
        let c = [];
        for (let d of n) c.push(t.boundDomain(d));
        let l = { linearSubset: o, bounds: c, preferredInitialGuess: e },
          { solution: p, MSE: f } = oC(i, k_(i, u, l));
        return {
          solution: p,
          residuals: r.apply(void 0, p),
          MSE: nL(f, s),
          isLinear: a,
        };
      }
    } else {return {
        solution: [],
        residuals: t.interpretWithParameters([]),
        MSE: oL(r, [], s),
        isLinear: true,
      };}
  }
  function Q_(e, t) {
    let n = {}, r = t.getDependencies();
    for (let s = 0; s < r.length; s++) {
      let i = new C.RegressionParameter(e[s]);
      n[r[s]] = i;
    }
    return n;
  }
  function K_(e, t, n, r, s, i, o) {
    let a = ob(r, o);
    if (!isFinite(a)) throw nP();
    if (t.getDependencies().length > 0) return { RMSE: Math.sqrt(a) };
    let u = fq(t.asValue(), t.valueType);
    if (
      t.getDependencies().length || !isFinite(u) || u <= 0 || !e.isLhsSimple
    ) return { RMSE: Math.sqrt(a) };
    {
      let c = 1 - a / u, l = cq(t, n, s, i, a);
      return l !== void 0 ? { r: l, rsquared: l * l } : { Rsquared: c };
    }
  }
  function eL(e) {
    if (!e.isTypedConstant) return NaN;
    let t = { valueType: e.valueType, value: e.asCompilerValue() },
      { value: n, valueType: r } = t;
    switch (r) {
      case Number:
        return n;
      case Complex:
        return V(n[1]) === 0 ? n[0] : NaN;
      default:
        return NaN;
    }
  }
  function cq(e, t, n, r, s) {
    if (!t.uniqueRHSNumberList) return;
    let i = [], o = [], a = n && (r === is.LINLOG || r === is.LOGLOG);
    C.List.eachArgs([t.uniqueRHSNumberList, e], (l) => {
      let p = eL(l[0]), f = eL(l[1]);
      i.push(a ? Math.log(V(p)) : p), o.push(f);
    });
    let u = corr(i.map(V), o.map(V));
    if (!isFinite(u)) return;
    let c = lq(i, o);
    if (si(c.MSE, s, 8)) return u;
  }
  function lq(e, t) {
    let n = t, r = [e.map((a) => Us(a)), e.map(() => Se(-1, 1))], s = aC(n, r);
    if (s) {
      let [a, u] = s, c = [];
      for (let l = 0; l < t.length; l++) c.push(ai(t[l], qs(wr(a, e[l]), u)));
      return { solution: s, MSE: ob(c, ListOfNumber) };
    }
    function i(a, u) {
      let c = [];
      for (let l = 0; l < e.length; l++) c.push(V(t[l]) - (a * V(e[l]) + u));
      return c;
    }
    return uC(i, [function () {
      return e.map((a) => -V(a));
    }, function () {
      return e.map(() => -1);
    }]);
  }
  function pq(e, t, n, r) {
    var a, u;
    let s = e._rhs.getDependencies(), i;
    (a = e.tableRegressionData) != null && a.tableId &&
      (i = (u = e.tableRegressionData) == null ? void 0 : u.tableId);
    for (let c in n) {
      let l = n[c];
      if (l.columns.length === 0) continue;
      let p = l.columns[0];
      i === void 0 && ga(p) && ki(p.header) && s.includes(p.header._symbol) &&
        (i = c);
      for (let f = 1; f < l.columns.length; f++) {
        if (l.columns[f].getDependencies().includes(t)) return;
      }
    }
    if (!r.some((c) => Array.isArray(c) && V(c[1]) !== 0)) return i;
  }
  function mC(e, t) {
    let n = e.length, r = e[0], s = t[0], i = e[n - 1], o = t[n - 1];
    if (
      !isFinite(r) || !isFinite(i) || !isFinite(s) || !isFinite(o) ||
      o - s === 0
    ) return false;
    let a = i - r;
    if (a === 0) return false;
    for (let u = 1; u < n - 1; u++) {
      let c = e[u], l = t[u], p = (o * (c - r) + s * (i - c)) / a;
      if (!si(l, p, 5)) return false;
    }
    return true;
  }
  var is = { NONE: 0, LOGLIN: 1, LOGLOG: 2, LINLOG: 3 };
  function dq(e, t, n) {
    if (!e.isLhsSimple || !n.uniqueRHSNumberList || se(t.valueType, Complex)) {
      return is.NONE;
    }
    let r = n.substituted;
    if (r.isError || r.valueType !== Number) return is.NONE;
    let s = r.getDependencies();
    if (s.length !== 1 || isFinite(n.node.polynomialOrder(s[0]))) {
      return is.NONE;
    }
    let i = r.getCompiledFunction(s).fn, o = n.uniqueRHSNumberList;
    if (r.valueType !== Number) return is.NONE;
    let a = o.mapElements((f) => +f.asValue());
    if (a.length < 3) return is.NONE;
    a.sort((f, d) => f - d);
    let u = a.map(i), c = u.map(Math.log), l = a.map(Math.log), p = true;
    return C.List.wrap(t).eachElement((f) => {
      isFinite(Math.log(+f.asValue())) || (p = false);
    }),
      mC(a, c) && p
        ? is.LOGLIN
        : mC(l, c) && p
        ? is.LOGLOG
        : mC(l, u)
        ? is.LINLOG
        : is.NONE;
  }
  function tL({ policy: e, frame: t }, n, r) {
    let s = Tn(t);
    for (let a of We(r)) s[a] = r[a];
    let i = od({ policy: e, frame: s, wrapInList: true }, n), o = i.getError();
    if (o) throw o;
    return i.asCompilerValue();
  }
  function ob(e, t) {
    switch (t) {
      case ListOfNumber: {
        let n = 0;
        for (let r of e) {
          let s = V(r);
          n += s * s;
        }
        return n / e.length;
      }
      case ListOfComplex: {
        let n = 0;
        for (let [r, s] of e) {
          let i = V(r);
          n += i * i;
          let o = V(s);
          n += o * o;
        }
        return n / e.length;
      }
      default:
        throw U("Regression with invalid value type.");
    }
  }
  function fq(e, t) {
    switch (t) {
      case Number:
      case Complex:
        return 0;
      case ListOfNumber:
        return varp(e);
      case ListOfComplex: {
        let n = e, r = 0, s = 0;
        for (let [u, c] of n) r += u, s += c;
        let i = r / n.length, o = s / n.length, a = 0;
        for (let [u, c] of n) {
          let l = V(u) - i;
          a += l * l;
          let p = V(c) - o;
          a += p * p;
        }
        return a / n.length;
      }
      default:
        throw U("Regression with invalid value type.");
    }
  }
  function oL(e, t, n) {
    let r = e.apply(void 0, t);
    return ob(r, n);
  }
  function nL(e, t) {
    switch (t) {
      case ListOfNumber:
        return e;
      case ListOfComplex:
        return e * Math.SQRT2;
      default:
        throw U("Regression with invalid value type.");
    }
  }
  function rL(e, t, n, r) {
    let s = 5;
    if (!r) return s;
    let i = t.apply(void 0, e);
    for (let o = 4; o < 15; o++) {
      let a = e.map((l) => parseFloat(l.toPrecision(o))),
        u = t.apply(void 0, a),
        c = 0;
      for (let l = 0; l < i.length; l++) {
        let p = Math.abs(i[l] - u[l]);
        p > c && (c = p);
      }
      if (c < n) {
        s = o;
        break;
      }
    }
    return s;
  }
  function mq(e) {
    let t = 0;
    if (j(e == null ? void 0 : e.valueType)) {
      let n = e.asValue(), r = listMax(n), s = listMin(n);
      t = (s < 0 && 0 < r ? r - s : Math.max(Math.abs(s), Math.abs(r))) / 500;
    }
    return t;
  }
  function sL(e, t, n) {
    let r, s, i = t._chunk;
    i && (s = $_(i));
    let o = j(n == null ? void 0 : n.valueType), a = mq(n);
    if (!s || s.length === 0) {
      t = t.deriveRegressionRestrictions(), r = J_(e, t);
      let b = t.getCompiledFunction(t.getDependencies()).fn,
        M = rL(r.solution.map((P) => V(P)), b, a, o);
      return {
        parameters: Q_(r.solution, t),
        displayPrecision: M,
        residuals: r.residuals,
        isLinear: r.isLinear,
        parameterWarning: false,
      };
    }
    let u = t.getDependencies(),
      c = t.valueType,
      l = t.getCompiledFunction(u).fn,
      p = yC(l, c),
      f = 1 / 0,
      d = {},
      y,
      g = false,
      m = 1 / 0,
      h = 5;
    for (let b of s) {
      let M = new on(b.chunk);
      if (
        M = M.deriveRegressionRestrictions(),
          r = J_(b.forwardParameterMap(e), M),
          r.MSE < f
      ) {
        let P = b.reverseParameterMap(r.solution.map((S) => V(S))),
          D = oL(l, P, c);
        if (d && (!isFinite(D) || D >= f)) {
          isFinite(D) || (g = true, r.MSE < m && (m = r.MSE));
          continue;
        }
        f = r.MSE, d = Q_(P, t), y = p.apply(void 0, P), h = rL(P, p, a, o);
      }
    }
    let x = Object.keys(d).length, T = o ? n.asValue().length : 1;
    return {
      parameters: d,
      displayPrecision: h,
      residuals: y,
      isLinear: false,
      parameterWarning: g && m < f && T > x,
    };
  }
  var Si = {
    pointsOfInterest: true,
    plotSingleVariableImplicitEquations: true,
    plotImplicits: true,
    plotInequalities: true,
    sliders: true,
  };
  function aL(e, t) {
    let { mappedArgIndex: n, mappedReturnIndex: r, solutionIndex: s } = t,
      i = [],
      o = Vu(e, n),
      a = gq(e, o, r),
      u = s,
      c = e.NanOfType(e.getReturnType());
    for (let l = 0; l <= r; l++) {
      let p = e.getInstruction(l);
      if (l === n) {
        i.push(s);
        continue;
      }
      if (!o[l] && !e.isInClosedBlock(l)) {
        i.push(l);
        continue;
      }
      if (ge(p)) i.push(e.copyInstruction(p));
      else {
        let f = yq(i, p.args);
        i.push(e.copyInstructionWithArgs(p, f)),
          p.type === 33 && a[l] && (u = e.Piecewise([f[0], u, c]));
      }
    }
    return u;
  }
  function yq(e, t) {
    let n = [];
    for (let r of t) n.push(e[r]);
    return n;
  }
  function gq(e, t, n) {
    let r = [];
    for (let s = 0; s < n; s++) r.push(false);
    r[n] = t[n];
    for (let s = n; s >= 0; s--) {
      if (!r[s] || !t[s]) continue;
      let i = e.getInstruction(s);
      if (i.type === 33) r[i.args[1]] = true;
      else if (!ge(i)) { for (let o of i.args) r[o] = true; }
    }
    return r;
  }
  function uL(e, t) {
    try {
      return hq(e, t);
    } catch (n) {
      return n instanceof C.Base ? n : U(n);
    }
  }
  function gC(e, t) {
    try {
      let n = new on(t), r = xl({}, n), s = [];
      for (let o = 0; o < r.length; o++) s.push(Number);
      let i = jh({
        policy: e,
        frame: {},
        argNames: r,
        argTypes: s,
        selection: void 0,
        locals: [],
      });
      return i.chunk = t,
        t.fuseBroadcast(),
        cL(
          { policy: e, ctx: i, isInequality: false, allowSolvingIn3D: true },
          t,
        );
    } catch (n) {
      return n instanceof C.Base ? n : U(n);
    }
  }
  function ab(e, t) {
    let n = e.getInstruction(t);
    if (n.type !== 1) return false;
    switch (n.valueType) {
      case Complex:
        return Number.isNaN(n.value[0]);
      case Number:
        return Number.isNaN(n.value);
      default:
        throw U("Unexpected type in isConstantNaN: " + at(n.valueType));
    }
  }
  function hq({ policy: e, frame: t }, n) {
    let r = false, s = [];
    if (n instanceof ku) {
      let x = n._lhs, T = x._symbol;
      if (
        !t[T] && !e.assignmentForbidden(T) &&
        (r = true, s = x._dependencies, x.args.length > 1)
      ) {
        let M = n._dependencies.filter((D) => !s.includes(D)),
          P = rn([T]).setDependencies(M);
        throw P.silent = true, P;
      }
    }
    let i = n.asComparator(), o = xl(t, i), a = [];
    for (let x = 0; x < o.length; x++) a.push(Number);
    let u = jh({
        policy: e,
        frame: t,
        argNames: o,
        argTypes: a,
        selection: void 0,
        locals: [],
      }),
      { chunk: c } = u,
      l = i.getOperator(),
      p = l !== "=",
      f = Fe(u, i.args[0]),
      d = zi(c, f, { peelableCoerce: true });
    if (d !== f && !ab(c, f) && ab(c, d)) throw Ny(l);
    let y = Fe(u, i.args[1]), g = zi(c, y, { peelableCoerce: true });
    if (g !== y && !ab(c, y) && ab(c, g)) throw Ny(l);
    try {
      Uo(c, e, i, [d, g]);
    } catch (x) {
      throw x instanceof v && r && (x.silent = true), x;
    }
    switch (l) {
      case "<":
        c.Less([d, g]);
        break;
      case ">":
        c.Greater([d, g]);
        break;
      case "<=":
        c.LessEqual([d, g]);
        break;
      case ">=":
        c.GreaterEqual([d, g]);
        break;
      case "=":
        c.Equal([d, g]);
        break;
    }
    if (c.fuseBroadcast(), c.isConstant()) return new on(c);
    let h = c.getInstruction(d).type !== 2 ||
      xl(t, i.args[1]).indexOf(c.argNames[d]) !== -1;
    if (!Si.plotImplicits && h) throw ZI();
    return Jr[l].direction === -1 ? c.Subtract([g, d]) : c.Subtract([d, g]),
      c.fuseBroadcast(),
      cL({
        policy: e,
        ctx: u,
        isInequality: p,
        allowSolvingIn3D: false,
        maybeBaseCase: r,
        callParameters: s,
      }, c);
  }
  function cL(
    {
      policy: e,
      ctx: t,
      isInequality: n,
      allowSolvingIn3D: r,
      maybeBaseCase: s,
      callParameters: i,
    },
    o,
  ) {
    let a = o.getLiveArgNames();
    if (a.length === 0) {
      throw U(`Unexpected: non-constant node with dependencies: ${a}`);
    }
    if (a.length === 1 && !n && !Si.plotSingleVariableImplicitEquations) {
      return XI();
    }
    let u = (g) => g === "x" || g === "y" || g === "z";
    if (e.is3dPolicy() ? !a.every(u) : a.length > 2) {
      let g = e.sliderVariables(a);
      if (s) {
        let m = i ? a.filter((x) => !i.includes(x)) : a,
          h = rn(g).setDependencies(m);
        return h.silent = true, h;
      } else return rn(g).setDependencies(a);
    }
    if (n && !e.validInequalityVariables(a)) return $I().setDependencies(a);
    let { localFrames: c, effectiveOrder: l, variableOfInterest: p } = bq(t, n);
    if (e.complicatedPolarImplicit(p, l)) return WI().setDependencies(a);
    if (!e.validImplicitVariables(a)) {
      let g = Ac();
      return s && (g.silent = true), g;
    }
    if (e.is3dPolicy() && r && l !== 1) return ca();
    if (l > 2 || e.is3dPolicy() && !r) return new on(o);
    let f = [], d = [], y = 1;
    for (let g = 0; g < c.length; g++) {
      let m = c[g], h = xq(m, n);
      y = h.length;
      for (let T of h) {
        let b = m.chunk.copy();
        if (b.setReturnIndex(T), m.isRestrictedPolynomial) {
          let { mappedArgIndex: M, mappedReturnIndex: P } = m;
          b.setReturnIndex(
            aL(b, {
              mappedArgIndex: M,
              mappedReturnIndex: P,
              solutionIndex: b.getReturnIndex(),
            }),
          );
        }
        b.fuseBroadcast(), f.push(new on(b));
      }
      let x = false;
      for (let T of m.coefficients) {
        let b = m.chunk.getInstruction(T);
        b.type === 1 && b.value !== 0 && (x = true);
      }
      if (o.argNames.length !== 2 || x) d.push(void 0);
      else {
        let T = m.chunk.copy(), b = m.coefficients.slice();
        T.List(b);
        let M = j(o.getReturnType()) ? o.elementAt(g) : o.copy(),
          D = M.argNames.indexOf(p) === 0 ? 1 : 0,
          S = M.getReturnIndex();
        M.Add([D, M.Multiply([M.Constant(0), S])]),
          d.push({ coefficients: T, restriction: M });
      }
    }
    return new C.SolvedEquation(p, new C.List(f), d, y);
  }
  function bq(e, t) {
    let n = e.chunk,
      r = e.policy,
      s = n.argNames,
      i = j(n.getReturnType()),
      o = [];
    e: for (let a = 0; a < s.length; a++) {
      let u = s[a], c = s.length > 1 && !r.validSolvedVariable(u);
      o[a] = { localFrames: [], effectiveOrder: 0, variableOfInterest: u };
      let l = !t;
      if (c) {
        o[a].effectiveOrder = 1 / 0;
        continue;
      }
      let p = i ? n.getConstantListLength() : 1;
      if (p == null) {
        throw new Error(
          "Programming error: cannot solve a variable-length list expression",
        );
      }
      for (let f = 0; f < p; f++) {
        let d = i ? n.elementAt(f) : n;
        if (
          d.polynomialOrder(u, {
            allowRestriction: l,
            allowClosedBlockReferences: false,
          }) > 2
        ) {
          o[a].effectiveOrder = 1 / 0;
          continue e;
        }
        let g = d.getPolynomialCoefficients(u);
        o[a].localFrames.push(g),
          o[a].effectiveOrder = Math.max(
            o[a].effectiveOrder,
            g.coefficients.length - 1,
          );
      }
    }
    if (s.length === 1) return o[0];
    if (s.length === 2 && !s.includes("z")) {
      return s[0] === "y" && (o = [o[1], o[0]]),
        o[0].effectiveOrder === 0
          ? o[1]
          : o[1].effectiveOrder === 0
          ? o[0]
          : o[o[0].effectiveOrder < o[1].effectiveOrder ? 0 : 1];
    }
    {
      let a = o.filter((c) => c.effectiveOrder === 1);
      if (a.length > 0) return a[0];
      let u = o.filter((c) => c.effectiveOrder === 2);
      return u.length > 0 ? u[0] : o[0];
    }
  }
  function xq(e, t) {
    return t ? Iq(e) : Tq(e);
  }
  function Tq({ chunk: e, coefficients: t }) {
    let [n, r, s] = t, i = e.Constant(Se(0, 1)), o = e.Constant(NaN);
    if (s === void 0) {
      r === void 0 && (r = i);
      let a = e.Negative([e.Divide([n, r])]), u = e.Equal([r, i]);
      return [e.Piecewise([u, o, a])];
    } else {
      let a = e.Constant(Se(2, 1)),
        u = e.Multiply([a, s]),
        c = e.Negative([e.Divide([r, u])]),
        l = e.Divide([n, s]),
        p = e.Subtract([e.Multiply([c, c]), l]),
        f = e.Equal([s, i]),
        d = e.Equal([p, i]),
        y = e.getInstruction(p);
      if (y.type === 1 && V(y.value) === 0) return [e.Piecewise([f, o, c])];
      {
        let g = e.NativeFunction("sqrt", [p]),
          m = e.Greater([r, i]),
          h = e.Less([r, i]),
          x = e.Greater([c, i]),
          T = e.Piecewise([x, e.Add([c, g]), e.Subtract([c, g])]),
          b = e.Piecewise([d, T, e.Divide([l, T])]),
          M = e.Negative([e.Divide([n, r])]);
        return [
          e.Piecewise([f, e.Piecewise([h, M, o]), T]),
          e.Piecewise([f, e.Piecewise([m, M, o]), b]),
        ];
      }
    }
  }
  function Iq({ chunk: e, coefficients: t }) {
    let [n, r, s] = t, i = e.Constant(Se(0, 1));
    s === void 0 && (s = i), r === void 0 && (r = i), n === void 0 && (n = i);
    let o = e.Constant(Se(2, 1)),
      a = e.Constant(NaN),
      u = e.Constant(Se(1e305, 1)),
      c = e.Negative([u]),
      l = e.Multiply([o, s]),
      p = e.Negative([e.Divide([r, l])]),
      f = e.Divide([n, s]),
      d = e.Subtract([e.Multiply([p, p]), f]),
      y = e.NativeFunction("sqrt", [d]),
      g = e.Negative([e.Divide([n, r])]),
      m = e.Equal([s, i]),
      h = e.Equal([d, i]),
      x = e.Greater([s, i]),
      T = e.Equal([r, i]),
      b = e.Greater([r, i]),
      M = e.Less([r, i]),
      P = e.Greater([p, i]),
      D = e.Greater([n, i]),
      S = e.Less([d, i]),
      O = e.Piecewise([P, e.Add([p, y]), e.Subtract([p, y])]),
      _ = e.Piecewise([h, O, e.Divide([f, O])]),
      L = e.Piecewise([P, _, O]),
      w = e.Piecewise([P, O, _]);
    return [
      e.Piecewise([m, e.Piecewise([M, g, a]), e.Piecewise([x, L, a])]),
      e.Piecewise([
        m,
        e.Piecewise([T, e.Piecewise([D, c, a]), a]),
        e.Piecewise([x, e.Piecewise([S, c, a]), L]),
      ]),
      e.Piecewise([
        m,
        e.Piecewise([T, e.Piecewise([D, u, a]), a]),
        e.Piecewise([x, e.Piecewise([S, u, a]), w]),
      ]),
      e.Piecewise([m, e.Piecewise([b, g, a]), e.Piecewise([x, w, a])]),
    ];
  }
  function va(e) {
    return e >= 100;
  }
  function lL(e, t) {
    switch (e) {
      case 106:
        return 200;
      case 107:
        return 201;
      case 108:
        return 202;
      case 103:
        return 214;
      case 130:
        return 215;
      case 112:
        return 209;
      case 113:
        return 210;
      case 110:
        switch (t) {
          case "z":
            return 206;
          case "theta":
            return 205;
          case "x":
          case "y":
          case "r":
          case "_implicit":
            return 211;
          default:
            return 10;
        }
      case 109:
        switch (t) {
          case "r":
            return 203;
          case "theta":
            return 204;
          case "x":
          case "y":
          case "z":
          case "_implicit":
            return 213;
          default:
            return 10;
        }
      case 111:
        switch (t) {
          case "theta":
            return 207;
          case "phi":
            return 208;
          case "x":
          case "y":
          case "z":
          case "rho":
          case "_implicit":
            return 212;
          default:
            return 10;
        }
      default:
        return 10;
    }
  }
  function hC(e) {
    switch (e) {
      case 123:
      case 122:
      case 121:
      case 120:
      case 124:
      case 126:
      case 127:
        return true;
      default:
        return false;
    }
  }
  function uu(e) {
    return e === 26 || e === 4;
  }
  function Hre(e) {
    return uu(e) || e === 3 || e === 25;
  }
  function pL(e) {
    let t = [];
    for (let r = 0; r < e.instructionsLength(); r++) t.push(false);
    let n = [];
    t[e.getReturnIndex()] = true;
    for (let r = e.instructionsLength() - 1; r >= 0; r--) {
      if (!t[r]) continue;
      let s = e.getInstruction(r);
      if (s.type === 2 && n.push(e.argNames[r]), ge(s)) continue;
      let i = Yu(e, s) ? [s.args[1]] : s.args;
      for (let o of i) t[o] = true;
    }
    return n;
  }
  var Pq = (e) => {
      let t = [], n = [], r = e.length;
      for (let s = 0; s < r; s++) t.push(e[s][0]), n.push(e[s][1]);
      return { defined: { x: t, y: n } };
    },
    go = Pq;
  var { sin: Eq, cos: Mq } = Math,
    st = class e {
      constructor(t = 0, n = 0, r = 0) {
        this.x = t;
        this.y = n;
        this.z = r;
      }
      copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this;
      }
      set(t, n, r) {
        return this.x = t, this.y = n, this.z = r, this;
      }
      clone() {
        return new e(this.x, this.y, this.z);
      }
      equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
      }
      isZero() {
        return this.x === 0 && this.y === 0 && this.z === 0;
      }
      isFinite() {
        return isFinite(this.x) && isFinite(this.y) && isFinite(this.z);
      }
      subVectors(t, n) {
        return this.x = t.x - n.x, this.y = t.y - n.y, this.z = t.z - n.z, this;
      }
      addVectors(t, n) {
        return this.x = t.x + n.x, this.y = t.y + n.y, this.z = t.z + n.z, this;
      }
      multiply(t) {
        return this.x *= t, this.y *= t, this.z *= t, this;
      }
      magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      normalize() {
        return this.multiply(1 / this.magnitude()), this;
      }
      cross(t) {
        return this.crossVectors(this, t);
      }
      crossVectors(t, n) {
        let r = t.x, s = t.y, i = t.z, o = n.x, a = n.y, u = n.z;
        return this.x = s * u - i * a,
          this.y = i * o - r * u,
          this.z = r * a - s * o,
          this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      }
      rotateAroundAxis(t, n) {
        let r = Cq(t, n);
        return new e(
          r[0] * this.x + r[1] * this.y + r[2] * this.z,
          r[3] * this.x + r[4] * this.y + r[5] * this.z,
          r[6] * this.x + r[7] * this.y + r[8] * this.z,
        );
      }
    };
  function Cq(e, t) {
    let n = e.x, r = e.y, s = e.z, i = Eq(t), o = Mq(t), a = 1 - o;
    return [
      a * n * n + o,
      a * n * r + i * s,
      a * n * s - i * r,
      a * r * n - i * s,
      a * r * r + o,
      a * r * s + i * n,
      a * s * n + i * r,
      a * s * r - i * n,
      a * s * s + o,
    ];
  }
  function cd(e, t, n, r, s, i, o) {
    let [a, u, c] = [new st(), new st(), new st()],
      [l, p, f] = [new st(), new st(), new st()],
      [d, y] = [new st(), new st()];
    for (let g = 0; g < e.length / 3; g++) {
      let m = e[3 * g], h = e[3 * g + 1], x = e[3 * g + 2];
      a.set(t[3 * m], t[3 * m + 1], t[3 * m + 2]),
        u.set(t[3 * h], t[3 * h + 1], t[3 * h + 2]),
        c.set(t[3 * x], t[3 * x + 1], t[3 * x + 2]),
        l.set(n[3 * m], n[3 * m + 1], n[3 * m + 2]),
        p.set(n[3 * h], n[3 * h + 1], n[3 * h + 2]),
        f.set(n[3 * x], n[3 * x + 1], n[3 * x + 2]),
        d.subVectors(c, a),
        y.subVectors(a, u);
      let T = d.cross(y).normalize();
      if (
        !(l.dot(T) > o && p.dot(T) > o && f.dot(T) > o) || l.dot(p) < 0 ||
        l.dot(f) < 0 || p.dot(f) < 0
      ) {
        let M = t.length / 3;
        e[3 * g] = M,
          e[3 * g + 1] = M + 1,
          e[3 * g + 2] = M + 2,
          t.push(a.x, a.y, a.z),
          t.push(u.x, u.y, u.z),
          t.push(c.x, c.y, c.z),
          n.push(T.x, T.y, T.z),
          n.push(T.x, T.y, T.z),
          n.push(T.x, T.y, T.z),
          r.push(r[2 * m], r[2 * m + 1]),
          r.push(r[2 * h], r[2 * h + 1]),
          r.push(r[2 * x], r[2 * x + 1]);
        let P = s;
        if (s > 0) {
          for (let D = 0; D < P; D++) i.push(i[P * m + D]);
          for (let D = 0; D < P; D++) i.push(i[P * h + D]);
          for (let D = 0; D < P; D++) i.push(i[P * x + D]);
        }
      }
    }
  }
  function cb(e) {
    let { triangles: t, normalDirHints: n } = e.triangulate(),
      { extraAttrCount: r } = e,
      s = e.getVertexCount(),
      i = new Array(s),
      o = new Array(s * 3),
      a = [],
      u = false,
      c = new Array(s * 3),
      l = new Array(s * 2),
      p = new Array(s * r),
      f = [],
      d = 0;
    function y(m) {
      let h = e.getVertex(m);
      if (!h) return null;
      let x = n[m], T = x ? e.hintedNormal(m, x) : e.getNormal(m);
      T
        ? (c[3 * d] = T[0], c[3 * d + 1] = T[1], c[3 * d + 2] = T[2])
        : (a[d] = true,
          u = true,
          c[3 * d] = 0,
          c[3 * d + 1] = 0,
          c[3 * d + 2] = 0),
        o[3 * d] = h[0],
        o[3 * d + 1] = h[1],
        o[3 * d + 2] = h[2];
      let b = e.getUV(m);
      if (l[2 * d] = b[0], l[2 * d + 1] = b[1], r > 0) {
        for (let M = 0; M < r; M++) {
          p[r * d + M] = e.getExtraAttr(m, M);
        }
      }
      return d++;
    }
    function g(m) {
      let h = i[m];
      return h === void 0 ? i[m] = y(m) : h;
    }
    for (let m = 0; m < t.length; m += 3) {
      let h = t[m], x = t[m + 1], T = t[m + 2], b = g(h), M = g(x), P = g(T);
      if (b === null || M === null || P === null) continue;
      f.push(b, M, P);
      let D = a[b], S = a[M], O = a[P];
      if (D || S || O) {
        let _ = o,
          L = c,
          w = new st(_[3 * b], _[3 * b + 1], _[3 * b + 2]),
          G = new st(_[3 * M], _[3 * M + 1], _[3 * M + 2]),
          k = new st(_[3 * P], _[3 * P + 1], _[3 * P + 2]),
          Z = new st().subVectors(k, w),
          F = new st().subVectors(w, G),
          Y = Z.cross(F);
        if (!Y.isFinite()) continue;
        D && (L[3 * b + 0] += Y.x, L[3 * b + 1] += Y.y, L[3 * b + 2] += Y.z),
          S && (L[3 * M + 0] += Y.x, L[3 * M + 1] += Y.y, L[3 * M + 2] += Y.z),
          O && (L[3 * P + 0] += Y.x, L[3 * P + 1] += Y.y, L[3 * P + 2] += Y.z);
      }
    }
    if (o.length = d * 3, c.length = d * 3, l.length = d * 2, u) {
      for (let m = 0; m < d; m++) {
        if (!a[m]) {
          continue;
        }
        let h = c[3 * m],
          x = c[3 * m + 1],
          T = c[3 * m + 2],
          b = Math.sqrt(h * h + x * x + T * T);
        c[3 * m] = h / b, c[3 * m + 1] = x / b, c[3 * m + 2] = T / b;
      }
    }
    return cd(f, o, c, l, r, p, 0), {
      positions: o,
      normals: c,
      faces: f,
      uvs: l,
      resolved: true,
      extraAttrs: p,
    };
  }
  var TC = class {
      constructor(
        {
          resolution: t,
          uRange: n,
          vRange: r,
          du: s,
          dv: i,
          extraAttrCount: o,
        },
      ) {
        this.normalDirHints = [];
        this.isVertexAtCreaseCache = [];
        this.triangles = [];
        this.edgeVertices = new Map();
        this.edgeNormalVertices = new Map();
        this.finiteVertices = new Map();
        this.resolution = t,
          this.uRange = n,
          this.vRange = r,
          this.du = s,
          this.dv = i,
          this.extraAttrCount = o,
          this.duSquared = s * s,
          this.dvSquared = i * i;
      }
      addVertex(t) {
        return this.normalDirHints.push(void 0),
          this.isVertexAtCreaseCache.push(void 0),
          this._addVertex(t);
      }
      jumpAlongEdge(t, n) {
        let r = 0;
        if (t > n) {
          let u = t;
          t = n, n = u, r = 1;
        }
        let s = n * n + t, i = this.edgeVertices.get(s);
        if (i === null) return;
        if (i !== void 0) return [i[r], i[1 - r]];
        let o = this.findJumpBetweenTwoSamples(t, n);
        if (o === void 0) {
          this.edgeVertices.set(s, null);
          return;
        }
        let a = [this.addVertex(o[0]), this.addVertex(o[1])];
        return this.edgeVertices.set(s, a), [a[r], a[1 - r]];
      }
      edgeNormalFeature(t, n) {
        let r = 0;
        if (t > n) {
          let u = t;
          t = n, n = u, r = 1;
        }
        let s = n * n + t, i = this.edgeNormalVertices.get(s);
        if (i !== void 0) return this.flipEdgeNormalFeature(i, r);
        let o = this.findCreaseBetweenTwoSamples(t, n),
          a = o === null
            ? null
            : o.type === "high-curvature"
            ? { type: "high-curvature", pos: this.addVertex(o.pos) }
            : {
              type: "crease",
              left: this.addVertex(o.left),
              right: this.addVertex(o.right),
            };
        return this.edgeNormalVertices.set(s, a),
          this.flipEdgeNormalFeature(a, r);
      }
      flipEdgeNormalFeature(t, n) {
        return (t == null ? void 0 : t.type) === "crease"
          ? {
            type: "crease",
            left: n === 0 ? t.left : t.right,
            right: n === 0 ? t.right : t.left,
          }
          : t;
      }
      findCreaseBetweenTwoSamples(t, n) {
        let i = this.getUV(t),
          o = this.getUV(n),
          a = this.getNormal(t),
          u = this.getNormal(n),
          c = (x) => {
            var b;
            let T = ar(i, o, x);
            return (b = this.fn(T).normal) != null ? b : [NaN, NaN, NaN];
          };
        if (!a || !u) return null;
        let l = o[0] - i[0],
          p = o[1] - i[1],
          f = this.du,
          d = this.dv,
          y = (Math.abs(f * l) + Math.abs(d * p)) / (l * l + p * p),
          g = Wy(0, a, 1, u, c, .01, 2 * y, .9);
        if (g === void 0) return null;
        if (typeof g == "number") {
          return g < y || g > 1 - y
            ? null
            : { type: "high-curvature", pos: this.fn(ar(i, o, g)) };
        }
        let m = g[0], h = g[1];
        return m < y || h > 1 - y
          ? null
          : (m -= y,
            h += y,
            m <= 1e-8 && (m = 1e-8),
            h >= 1 - 1e-8 && (h = 1 - 1e-8),
            {
              type: "crease",
              left: this.fn(ar(i, o, m)),
              right: this.fn(ar(i, o, h)),
            });
      }
      isVertexAtCrease(t) {
        let n = this.isVertexAtCreaseCache[t];
        if (n !== void 0) return n;
        let r = this._isVertexAtCrease(t);
        return this.isVertexAtCreaseCache[t] = r, r;
      }
      finiteAlongEdge(t, n) {
        if (t > n) {
          let a = t;
          t = n, n = a;
        }
        let r = n * n + t, s = this.finiteVertices.get(r);
        if (s !== void 0) return s;
        let i = this.findFiniteBetweenTwoSamples(t, n);
        if (i === void 0) return;
        let o = this.addVertex(i);
        return this.finiteVertices.set(r, o), o;
      }
      pushTriangle(t, n, r) {
        this.isDegenerate(t, n, r) || this.triangles.push(t, n, r);
      }
      getTriangles() {
        return this.triangles;
      }
    },
    Dq = 1e-4,
    Sq = .99,
    pd = .9999;
  function bC(e, t) {
    return !e || !t ? true : e[0] * t[0] + e[1] * t[1] + e[2] * t[2] < Sq;
  }
  var IC = class extends TC {
      hintVec(t, n) {
        let r = this.getUV(t), s = this.getUV(n);
        return zD(HD(s, r), Dq);
      }
      hintNormal1(t, n, r) {
        let s = this.hintVec(t, n), i = this.hintVec(t, r);
        this.normalDirHints[t] = [s, i];
      }
      hintNormals2(t, n) {
        let r = this.hintVec(t, n), s = xC(r);
        this.normalDirHints[t] = [ub(r), s],
          this.normalDirHints[n] = [s, ub(s)];
      }
      hintNormals2Finite(t, n) {
        let r = this.hintVec(t, n), s = ub(r);
        this.normalDirHints[t] = this.normalDirHints[n] = [s, xC(s)];
      }
      hintNormalFirstBad(t, n) {
        let r = this.hintVec(t, n);
        this.normalDirHints[t] = [ub(r), xC(r)];
      }
      hintNormalSecondBad(t, n) {
        let r = this.hintVec(n, t);
        this.normalDirHints[n] = [Oq(r), vq(r)];
      }
    },
    PC = class extends IC {
      oneJump(t, n, r, s) {
        let i = s[0], o = s[1];
        this.pushTriangle(i, r, t),
          this.pushTriangle(o, n, r),
          this.hintNormalFirstBad(i, r),
          this.hintNormalSecondBad(r, o);
      }
      oneJumpOneExtra(t, n, r, s, i) {
        let o = s[0], a = s[1];
        this.pushTriangle(o, r, t),
          this.pushTriangle(o, i, r),
          this.pushTriangle(a, n, i),
          this.hintNormalFirstBad(o, r),
          this.hintNormalSecondBad(r, a);
      }
      oneJumpOneExtra2(t, n, r, s, i) {
        let o = s[0], a = s[1];
        this.pushTriangle(a, n, r),
          this.pushTriangle(a, r, i),
          this.pushTriangle(o, i, t),
          this.hintNormalFirstBad(o, r),
          this.hintNormalSecondBad(r, a);
      }
      oneJumpTwoExtra(t, n, r, s, i, o) {
        let a = s[0], u = s[1];
        this.pushTriangle(a, o, t),
          this.pushTriangle(a, i, o),
          this.pushTriangle(i, r, o),
          this.pushTriangle(u, n, i);
      }
      twoJumps(t, n, r, s, i) {
        let o = s[0], a = s[1], u = i[0], c = i[1];
        this.pushTriangle(o, r, t),
          this.pushTriangle(o, c, r),
          this.pushTriangle(a, n, u),
          this.hintNormals2(o, c),
          this.hintNormals2(u, a);
      }
      twoJumpsOneExtraPoint(t, n, r, s, i, o) {
        let a = s[0], u = s[1], c = i[0], l = i[1];
        this.pushTriangle(a, o, t),
          this.pushTriangle(a, l, o),
          this.pushTriangle(l, r, o),
          this.pushTriangle(u, n, c),
          this.hintNormals2(a, l),
          this.hintNormals2(c, u);
      }
      oneExtraPoint(t, n, r, s) {
        this.pushTriangle(s, r, t), this.pushTriangle(s, n, r);
      }
      oneExtraPointOneVertexCrease(t, n, r, s) {
        let i = this.copyVertex(r);
        this.pushTriangle(s, i, t),
          this.pushTriangle(s, n, i),
          this.hintNormal1(i, t, n);
      }
      twoExtraPoints(t, n, r, s, i) {
        this.pushTriangle(s, r, t),
          this.pushTriangle(s, i, r),
          this.pushTriangle(s, n, i);
      }
      threeExtraPoints(t, n, r, s, i, o) {
        this.pushTriangle(s, o, t),
          this.pushTriangle(s, i, o),
          this.pushTriangle(s, n, i),
          this.pushTriangle(i, r, o);
      }
      oneEdgeJumpOneVertexCrease(t, n, r, s) {
        let i = s[0], o = s[1], a = this.copyVertex(r), u = this.copyVertex(r);
        this.pushTriangle(i, a, t),
          this.pushTriangle(o, n, u),
          this.hintNormals2(u, o),
          this.hintNormals2(i, a);
      }
      threeVertexCrease(t, n, r) {
        let s = this.copyVertex(t),
          i = this.copyVertex(n),
          o = this.copyVertex(r);
        this.pushTriangle(s, i, o),
          this.hintNormals2(s, i),
          this.hintNormalFirstBad(o, s);
      }
      twoVertexCrease(t, n, r) {
        let s = this.copyVertex(t), i = this.copyVertex(n);
        this.pushTriangle(s, i, r), this.hintNormals2(s, i);
      }
      oneVertexCrease(t, n, r) {
        let s = this.copyVertex(t);
        this.pushTriangle(s, n, r), this.hintNormal1(s, n, r);
      }
      pushTrianglesBasedOnJumps(t, n, r) {
        let s = this.jumpAlongEdge(t, n),
          i = this.jumpAlongEdge(n, r),
          o = this.jumpAlongEdge(r, t);
        if (s && i && o) {
          let m = this.getUV(t),
            h = this.getUV(n),
            x = this.getUV(r),
            T = this.addVertex(this.fn(ar(m, ar(h, x, .5), 1e-4))),
            b = this.addVertex(this.fn(ar(h, ar(x, m, .5), 1e-4))),
            M = this.addVertex(this.fn(ar(x, ar(m, h, .5), 1e-4))),
            P = this.jumpAlongEdge(T, b),
            D = this.jumpAlongEdge(b, M),
            S = this.jumpAlongEdge(M, T);
          if (P && D && S) return;
          t = T, n = b, r = M, s = P, i = D, o = S;
        }
        let a = this.getNormal(t),
          u = this.getNormal(n),
          c = this.getNormal(r),
          l = this.isVertexAtCrease(t),
          p = this.isVertexAtCrease(n),
          f = this.isVertexAtCrease(r),
          d,
          y,
          g;
        if (!l && !p && !s && bC(a, u)) {
          let m = this.edgeNormalFeature(t, n);
          m !== null &&
            (m.type === "high-curvature" ? d = m.pos : s = [m.left, m.right]);
        }
        if (!p && !f && !i && bC(u, c)) {
          let m = this.edgeNormalFeature(n, r);
          m !== null &&
            (m.type === "high-curvature" ? y = m.pos : i = [m.left, m.right]);
        }
        if (!f && !l && !o && bC(c, a)) {
          let m = this.edgeNormalFeature(r, t);
          m !== null &&
            (m.type === "high-curvature" ? g = m.pos : o = [m.left, m.right]);
        }
        s && i
          ? g
            ? this.twoJumpsOneExtraPoint(t, n, r, s, i, g)
            : this.twoJumps(t, n, r, s, i)
          : i && o
          ? d
            ? this.twoJumpsOneExtraPoint(n, r, t, i, o, d)
            : this.twoJumps(n, r, t, i, o)
          : o && s
          ? y
            ? this.twoJumpsOneExtraPoint(r, t, n, o, s, y)
            : this.twoJumps(r, t, n, o, s)
          : s
          ? f
            ? this.oneEdgeJumpOneVertexCrease(t, n, r, s)
            : y && g
            ? this.oneJumpTwoExtra(t, n, r, s, y, g)
            : y
            ? this.oneJumpOneExtra(t, n, r, s, y)
            : g
            ? this.oneJumpOneExtra2(t, n, r, s, g)
            : this.oneJump(t, n, r, s)
          : i
          ? l
            ? this.oneEdgeJumpOneVertexCrease(n, r, t, i)
            : g && d
            ? this.oneJumpTwoExtra(n, r, t, i, g, d)
            : g
            ? this.oneJumpOneExtra(n, r, t, i, g)
            : d
            ? this.oneJumpOneExtra2(n, r, t, i, d)
            : this.oneJump(n, r, t, i)
          : o
          ? p
            ? this.oneEdgeJumpOneVertexCrease(r, t, n, o)
            : d && y
            ? this.oneJumpTwoExtra(r, t, n, o, d, y)
            : d
            ? this.oneJumpOneExtra(r, t, n, o, d)
            : y
            ? this.oneJumpOneExtra2(r, t, n, o, y)
            : this.oneJump(r, t, n, o)
          : l && p && f
          ? this.threeVertexCrease(t, n, r)
          : l && p
          ? this.twoVertexCrease(t, n, r)
          : p && f
          ? this.twoVertexCrease(n, r, t)
          : f && l
          ? this.twoVertexCrease(r, t, n)
          : l
          ? y
            ? this.oneExtraPointOneVertexCrease(n, r, t, y)
            : this.oneVertexCrease(t, n, r)
          : p
          ? g
            ? this.oneExtraPointOneVertexCrease(r, t, n, g)
            : this.oneVertexCrease(n, r, t)
          : f
          ? d
            ? this.oneExtraPointOneVertexCrease(t, n, r, d)
            : this.oneVertexCrease(r, t, n)
          : d && y && g
          ? this.threeExtraPoints(t, n, r, d, y, g)
          : d && y
          ? this.twoExtraPoints(t, n, r, d, y)
          : y && g
          ? this.twoExtraPoints(n, r, t, y, g)
          : g && d
          ? this.twoExtraPoints(r, t, n, g, d)
          : d
          ? this.oneExtraPoint(t, n, r, d)
          : y
          ? this.oneExtraPoint(n, r, t, y)
          : g
          ? this.oneExtraPoint(r, t, n, g)
          : this.pushTriangle(t, n, r);
      }
      oneNonFinite(t, n, r) {
        let s = this.finiteAlongEdge(n, r), i = this.finiteAlongEdge(t, r);
        i !== void 0 && s !== void 0 &&
          (this.pushTrianglesBasedOnJumps(s, t, n),
            this.pushTrianglesBasedOnJumps(s, i, t),
            this.hintNormals2Finite(s, i));
      }
      twoNonFinite(t, n, r) {
        let s = this.finiteAlongEdge(t, n), i = this.finiteAlongEdge(t, r);
        s !== void 0 && i !== void 0 &&
          (this.pushTrianglesBasedOnJumps(t, s, i),
            this.hintNormals2Finite(s, i));
      }
      pushTriangles(t, n, r) {
        let s = this.allowVertex(t),
          i = this.allowVertex(n),
          o = this.allowVertex(r);
        s && i && o
          ? this.pushTrianglesBasedOnJumps(t, n, r)
          : s && i
          ? this.oneNonFinite(t, n, r)
          : i && o
          ? this.oneNonFinite(n, r, t)
          : o && s
          ? this.oneNonFinite(r, t, n)
          : s
          ? this.twoNonFinite(t, n, r)
          : i
          ? this.twoNonFinite(n, r, t)
          : o && this.twoNonFinite(r, t, n);
      }
    },
    ld = class extends PC {
      triangulate() {
        let t = this.resolution,
          { uRange: n, vRange: r, fn: s } = this,
          i = [n.min, r.min],
          o = [n.max, r.max],
          a = t - 1,
          u = new Array(t * t);
        u[0] = this.addVertex(s(i));
        for (let c = 1; c <= a; c++) {
          u[c] = this.addVertex(s(Xy(i, o, [c / a, 0]))),
            u[t * c] = this.addVertex(s(Xy(i, o, [0, c / a])));
        }
        for (let c = 1; c <= a; c++) {
          for (let l = 1; l <= a; l++) {
            let p = u[(l - 1) * t + (c - 1)],
              f = u[l * t + (c - 1)],
              d = u[(l - 1) * t + c],
              y = this.addVertex(s(Xy(i, o, [c / a, l / a])));
            u[l * t + c] = y,
              (c + l) % 2 === 0
                ? (this.pushTriangles(p, y, f), this.pushTriangles(p, d, y))
                : (this.pushTriangles(p, d, f), this.pushTriangles(d, y, f));
          }
        }
        return {
          triangles: this.getTriangles(),
          normalDirHints: this.normalDirHints,
        };
      }
    };
  function vq(e) {
    let t = e[0] * Math.SQRT1_2, n = e[1] * Math.SQRT1_2;
    return [t + n, n - t];
  }
  function ub(e) {
    let t = e[0] * Math.SQRT1_2, n = e[1] * Math.SQRT1_2;
    return [t - n, t + n];
  }
  function Oq(e) {
    return [e[1], -e[0]];
  }
  function xC(e) {
    return [-e[1], e[0]];
  }
  var qe = class {
    constructor(t, n) {
      this.min = t;
      this.max = n;
    }
    get width() {
      return this.max - this.min;
    }
  };
  var EC = class extends ld {
    constructor(n, r, s, i, o, a = [0, 1, 2]) {
      let u = r.width / 1e8, c = s.width / 1e8;
      super({
        resolution: o,
        uRange: r,
        vRange: s,
        du: u,
        dv: c,
        extraAttrCount: 0,
      });
      this.vertices = [];
      this.fn = (n) => {
        let r = this._fn(n),
          s = this.tangentInForcedDf(n, [this.du, 0], r),
          i = this.tangentInForcedDf(n, [0, this.dv], r),
          o = Kl([this.du, 0, s], [0, this.dv, i]);
        return {
          uv: n,
          f: r,
          normal: [o[this.perm0], o[this.perm1], o[this.perm2]],
          dfEast: s,
          dfNorth: i,
        };
      };
      this._fn = (l) => n(l[0], l[1]),
        this.paddedOutputDomain = new qe(
          i.min - 5 * i.width,
          i.max + 5 * i.width,
        ),
        this.jumpTolerance = i.width / 1e3,
        this.perm0 = a[0],
        this.perm1 = a[1],
        this.perm2 = a[2];
    }
    getVertexCount() {
      return this.vertices.length;
    }
    getUV(n) {
      return this.vertices[n].uv;
    }
    getNormal(n) {
      return this.vertices[n].normal;
    }
    _addVertex(n) {
      return this.vertices.push(n) - 1;
    }
    copyVertex(n) {
      return this.addVertex(this.vertices[n]);
    }
    getF(n) {
      return this.vertices[n].f;
    }
    getDfNorth(n) {
      return this.vertices[n].dfNorth;
    }
    getDfEast(n) {
      return this.vertices[n].dfEast;
    }
    tangentInForcedDf(n, r, s) {
      let i = cf(n, r);
      return this._fn(i) - s;
    }
    tangentInForced(n, r, s) {
      let i = cf(n, r);
      return [r[0], r[1], this._fn(i) - s];
    }
    getExtraAttr() {
      throw new Error("Unexpected getExtraAttr call in explicit-surface.ts");
    }
    _isVertexAtCrease(n) {
      let r = this.getUV(n),
        s = this.getDfEast(n),
        i = this.getDfNorth(n),
        o = this.getF(n),
        a = this.tangentInForcedDf(r, [-this.du, 0], o);
      if (
        (-this.duSquared + a * s) /
            Math.sqrt((this.duSquared + a * a) * (this.duSquared + s * s)) > -pd
      ) return true;
      let l = this.tangentInForcedDf(r, [0, -this.dv], o);
      return (-this.dvSquared + i * l) /
          Math.sqrt((this.dvSquared + i * i) * (this.dvSquared + l * l)) > -pd;
    }
    hintedNormal(n, r) {
      let s = this.getUV(n),
        i = this.getF(n),
        o = Kl(
          this.tangentInForced(s, r[0], i),
          this.tangentInForced(s, r[1], i),
        );
      return ep(...o)
        ? [o[this.perm0], o[this.perm1], o[this.perm2]]
        : this.getNormal(n);
    }
    getVertex(n) {
      if (!this.allowVertex(n)) return;
      let r = this.getF(n), s = this.getUV(n);
      return [
        this.perm0 === 2 ? r : s[this.perm0],
        this.perm1 === 2 ? r : s[this.perm1],
        this.perm2 === 2 ? r : s[this.perm2],
      ];
    }
    findJumpBetweenTwoSamples(n, r) {
      let s = this.getUV(n),
        i = this.getF(n),
        o = 0,
        a = this.getUV(r),
        u = this.getF(r),
        c = 1,
        l = (f) => this._fn(ar(s, a, f));
      if (!isFinite(i) || !isFinite(u)) return;
      let p = eS(o, i, c, u, l, this.jumpTolerance);
      if (p) {
        return [
          this.fn(ar(s, a, wi(p[0], 0, 1e-5))),
          this.fn(ar(s, a, wi(p[1], 1, 1e-5))),
        ];
      }
    }
    findFiniteBetweenTwoSamples(n, r) {
      let s = this.getUV(n),
        i = this.getF(n),
        o = this.getUV(r),
        a = this.getF(r),
        u = (p) => {
          let f = this._fn(p);
          return f < this.paddedOutputDomain.min ||
              f > this.paddedOutputDomain.max
            ? NaN
            : f;
        },
        c = (p) => u(ar(s, o, p)),
        l = xs(
          0,
          this.paddedOutputDomain.min < i && i < this.paddedOutputDomain.max
            ? i
            : NaN,
          1,
          this.paddedOutputDomain.min < a && a < this.paddedOutputDomain.max
            ? a
            : NaN,
          c,
        );
      if (l !== void 0) return this.fn(ar(s, o, l));
    }
    allowVertex(n) {
      let r = this.getF(n);
      return this.paddedOutputDomain.min < r && r < this.paddedOutputDomain.max;
    }
    isDegenerate(n, r, s) {
      let i = this.getUV(n),
        o = this.getUV(r),
        a = this.getUV(s),
        u = this.uRange.width * 1e-6,
        c = this.vRange.width * 1e-6;
      return Math.abs(i[0] - o[0]) < u && Math.abs(i[1] - o[1]) < c ||
        Math.abs(o[0] - a[0]) < u && Math.abs(o[1] - a[1]) < c ||
        Math.abs(a[0] - i[0]) < u && Math.abs(a[1] - i[1]) < c;
    }
  };
  function lb(e, t, n, r, s, i = [0, 1, 2]) {
    let o = new EC(e, t, n, r, s, i);
    return cb(o);
  }
  var $i = class {
    constructor(t) {
      this.xtolerance = t.xtolerance || t.tolerance || 0,
        this.ytolerance = t.ytolerance || t.tolerance || 0,
        this.ztolerance = t.ztolerance || t.tolerance || 0,
        this.map = t.map,
        this.segments = [],
        this.segment = [],
        this.pivotPoint = void 0,
        this.pendingPoint = void 0;
    }
    colinear(t, n, r) {
      let s = this.map(t),
        i = this.map(n),
        o = this.map(r),
        a = to(
          o[0],
          o[1],
          o[2] || 0,
          s[0],
          s[1],
          s[2] || 0,
          i[0],
          i[1],
          i[2] || 0,
        );
      if (a < 1) return false;
      let u = [
        s[0] + a * (i[0] - s[0]),
        s[1] + a * (i[1] - s[1]),
        s.length === 3 ? s[2] + a * (i[2] - s[2]) : 0,
      ];
      return Math.abs(o[0] - u[0]) <= this.xtolerance &&
        Math.abs(o[1] - u[1]) <= this.ytolerance &&
        (s.length === 2 || Math.abs(o[2] - u[2]) <= this.ztolerance);
    }
    addPoint(t) {
      if (
        this.dimensions = t.length,
          this.xtolerance < 0 && this.ytolerance < 0 &&
          (this.dimensions === 2 || this.ztolerance < 0)
      ) {
        this.segment.push.apply(this.segment, t);
        return;
      }
      if (!this.segment.length) {
        this.segment.push.apply(this.segment, t);
        return;
      }
      let n = this.dimensions === 2
        ? [
          this.segment[this.segment.length - 2],
          this.segment[this.segment.length - 1],
        ]
        : [
          this.segment[this.segment.length - 3],
          this.segment[this.segment.length - 2],
          this.segment[this.segment.length - 1],
        ];
      if (!(t[0] === n[0] && t[1] === n[1] && t[2] === n[2])) {
        if (!this.pivotPoint || !this.pendingPoint) {
          this.pivotPoint = t, this.pendingPoint = t;
          return;
        }
        (!this.colinear(n, this.pivotPoint, t) ||
          MathHypot(n[0] - t[0], n[1] - t[1], (n[2] || 0) - (t[2] || 0)) <
            MathHypot(
              n[0] - this.pendingPoint[0],
              n[1] - this.pendingPoint[1],
              (n[2] || 0) - (this.pendingPoint[2] || 0),
            )) && (this.flushPending(), this.pivotPoint = t),
          this.pendingPoint = t;
      }
    }
    flushPending() {
      this.pendingPoint &&
        (this.segment.push.apply(this.segment, this.pendingPoint),
          this.pivotPoint = void 0,
          this.pendingPoint = void 0);
    }
    breakSegment() {
      this.flushPending(),
        this.segment.length > (this.dimensions || 2) &&
        this.segments.push(this.segment),
        this.segment = [];
    }
    getSegments() {
      return this.breakSegment(), this.segments;
    }
    finish() {
      return { segments: this.getSegments(), resolved: true };
    }
  };
  var fL = 5, Nq = Math.pow(2, 14), { abs: ho } = Math;
  function hm(e, t) {
    let n = Rq(e, t);
    return {
      segments: n.contours.strokeSegments,
      fillSegments: n.contours.fillSegments,
      resolved: n.quadTree.resolved,
    };
  }
  function Rq(e, t) {
    let n = Math.pow(2, -fL),
      r = dL(t, n),
      s = dL(t, 2 * n),
      i = Aq(e, r, s),
      o = Gq(i.root, e, r),
      a = qq(o, e, r);
    return {
      paddedDomain: r,
      rootDomain: s,
      quadTree: i,
      triangles: o,
      contours: a,
    };
  }
  function fd(e, t, n) {
    return { x: e, y: t, z: n };
  }
  function Ku(e, t, n) {
    return { x: e, y: t, isZero: n };
  }
  function pb(e, t, n) {
    return { vertices: [e, t, n], visited: false, next: void 0 };
  }
  function dL(e, t) {
    let { mathToPixels: n } = e,
      r = n.interpolateX(e.xmin, e.xmax, -t),
      s = n.interpolateX(e.xmax, e.xmin, -t),
      i = n.interpolateY(e.ymin, e.ymax, -t),
      o = n.interpolateY(e.ymax, e.ymin, -t);
    return { ...e, xmin: r, ymin: i, xmax: s, ymax: o };
  }
  function mm(e, t) {
    return { depth: e, vertices: t, children: void 0, center: void 0 };
  }
  function MC(e, t, n) {
    e.center = mL(
      e.vertices[0],
      e.vertices[1],
      e.vertices[2],
      e.vertices[3],
      t,
      n,
    );
  }
  function Aq(e, t, n) {
    let r = _q(e, n), s = [], i = [];
    i.push(r);
    let o = 1, a = true;
    e: for (; i.length;) {
      let u = s;
      s = i, i = u;
      let c;
      for (; c = s.pop();) {
        if (wq(c, e, t)) {
          if (Lq(c, e, t), !c.children) {
            a = false;
            break e;
          }
          if (
            i.push(c.children[0]),
              i.push(c.children[1]),
              i.push(c.children[2]),
              i.push(c.children[3]),
              o += 3,
              o >= Nq
          ) {
            a = false;
            break e;
          }
        } else MC(c, e, t);
      }
    }
    for (let u = 0; u < s.length; u++) MC(s[u], e, t);
    for (let u = 0; u < i.length; u++) MC(i[u], e, t);
    return { root: r, resolved: a };
  }
  function _q(e, t) {
    let n = t.xmin, r = t.xmax, s = t.ymin, i = t.ymax;
    return mm(0, [dd(n, i, e), dd(r, i, e), dd(r, s, e), dd(n, s, e)]);
  }
  function Lq(e, t, n) {
    let r = e.depth + 1,
      s = e.vertices[0],
      i = e.vertices[1],
      o = e.vertices[2],
      a = e.vertices[3],
      u = Os(s, i, t, n),
      c = Os(i, o, t, n),
      l = Os(o, a, t, n),
      p = Os(a, s, t, n),
      f = Os(s, o, t, n);
    e.children = [
      mm(r, [s, u, f, p]),
      mm(r, [u, i, c, f]),
      mm(r, [f, c, o, l]),
      mm(r, [p, f, l, a]),
    ];
  }
  function wq(e, t, n) {
    if (e.depth < fL) return true;
    if (Vq(e, n) || Fq(e, n)) return false;
    let r = e.vertices[0],
      s = e.vertices[1],
      i = e.vertices[2],
      o = e.vertices[3];
    if (isNaN(r.z) && isNaN(s.z) && isNaN(i.z) && isNaN(o.z)) return false;
    if (isNaN(r.z) || isNaN(s.z) || isNaN(i.z) || isNaN(o.z)) return true;
    let a = mL(r, s, i, o, t, n),
      u = Na(r, s, t, n),
      c = Na(s, i, t, n),
      l = Na(i, o, t, n),
      p = Na(o, r, t, n);
    return tc(r, u, t, n) || tc(s, u, t, n) || tc(s, c, t, n) ||
      tc(i, c, t, n) || tc(i, l, t, n) || tc(o, l, t, n) || tc(o, p, t, n) ||
      tc(r, p, t, n) || ec(r, u, a, t, n) || ec(u, s, a, t, n) ||
      ec(s, c, a, t, n) || ec(c, i, a, t, n) || ec(i, l, a, t, n) ||
      ec(l, o, a, t, n) || ec(o, p, a, t, n) || ec(p, r, a, t, n);
  }
  function ec(e, t, n, r, s) {
    if (e.z > 0 == t.z > 0 && t.z > 0 == n.z > 0) return false;
    let i = 0;
    isFinite(e.z) && (i = Math.max(i, Math.abs(e.z))),
      isFinite(t.z) && (i = Math.max(i, Math.abs(t.z))),
      isFinite(n.z) && (i = Math.max(i, Math.abs(n.z)));
    let o = 32 * Number.EPSILON * i, a, u, c, l;
    if (e.z > 0 == t.z > 0) {
      if (a = Os(e, t, r, s), a.z > 0 != e.z > 0) return true;
      u = Oa(e, n, r, s, o), c = Oa(t, n, r, s, o), l = Oa(a, n, r, s, o);
    } else if (t.z > 0 == n.z > 0) {
      if (a = Os(t, n, r, s), a.z > 0 != t.z > 0) return true;
      u = Oa(t, e, r, s, o), c = Oa(n, e, r, s, o), l = Oa(a, e, r, s, o);
    } else {
      if (a = Os(n, e, r, s), a.z > 0 != n.z > 0) return true;
      u = Oa(n, t, r, s, o), c = Oa(e, t, r, s, o), l = Oa(a, t, r, s, o);
    }
    let { mathToPixels: p, map3d: f } = s;
    if (f) {
      let d = f(l.x, l.y), y = f(u.x, u.y), g = f(c.x, c.y);
      return J1(d[0], d[1], d[2], y[0], y[1], y[2], g[0], g[1], g[2]) >
        s.tolerance;
    } else {
      let [d, y] = p.mapCoordinatePair([l.x, l.y]),
        [g, m] = p.mapCoordinatePair([u.x, u.y]),
        [h, x] = p.mapCoordinatePair([c.x, c.y]);
      return j1(d, y, g, m, h, x) > s.tolerance;
    }
  }
  function tc(e, t, n, r) {
    if (isNaN(e.z) && isNaN(t.z)) return false;
    if (isNaN(e.z) || isNaN(t.z)) return e.z > 0 || t.z > 0;
    let i = 4 * Os(e, t, n, r).z - t.z - 3 * e.z,
      o = 1e-4,
      a = (n((1 - o) * e.x + o * t.x, (1 - o) * e.y + o * t.y) - e.z) / o,
      u = Math.max(Math.abs(e.z), Math.abs(t.z));
    return Math.abs(i - a) > .125 * u;
  }
  function Fq(e, t) {
    let { mathToPixels: n, map3d: r, tolerance: s } = t;
    if (r) return false;
    {
      let [i, o] = n.mapCoordinatePair([e.vertices[1].x, e.vertices[1].y]),
        [a, u] = n.mapCoordinatePair([e.vertices[0].x, e.vertices[0].y]),
        [c, l] = n.mapCoordinatePair([e.vertices[3].x, e.vertices[3].y]);
      if (ho(i - a) < 10 * s || ho(u - l) < 10 * s) return true;
    }
    return false;
  }
  function Vq(e, t) {
    return e.vertices[0].x < t.xmin || e.vertices[0].y > t.ymax ||
      e.vertices[2].x > t.xmax || e.vertices[2].y < t.ymin;
  }
  function md(e, t) {
    return e.x < t.xmin || e.x > t.xmax || e.y < t.ymin || e.y > t.ymax;
  }
  function dd(e, t, n) {
    return fd(e, t, n(e, t));
  }
  function Os(e, t, n, r) {
    let { mathToPixels: s } = r;
    return dd(s.interpolateX(e.x, t.x, .5), s.interpolateY(e.y, t.y, .5), n);
  }
  function Na(e, t, n, r) {
    if (md(e, r) || md(t, r)) return Os(e, t, n, r);
    if (isNaN(e.z) || isNaN(t.z)) return Bq(e, t, n, r);
    if (e.z > 0 != t.z > 0) return Os(e, t, n, r);
    let s = .01,
      i = n((1 - s) * e.x + s * t.x, (1 - s) * e.y + s * t.y) - e.z,
      o = t.z - n(s * e.x + (1 - s) * t.x, s * e.y + (1 - s) * t.y);
    return isNaN(i) || isNaN(o) || i > 0 == o > 0
      ? Os(e, t, n, r)
      : yL(fd(e.x, e.y, i), fd(t.x, t.y, o), n, r);
  }
  function mL(e, t, n, r, s, i) {
    let o = Na(e, n, s, i);
    return e.z > 0 == n.z > 0 && o.z > 0 != e.z > 0 ||
        (o = Na(t, r, s, i), t.z > 0 == r.z > 0 && o.z > 0 != t.z > 0)
      ? o
      : Os(e, n, s, i);
  }
  function yL(e, t, n, r) {
    if (isNaN(e.z)) return t;
    if (isNaN(t.z)) return e;
    if (!isFinite(e.z) && !isFinite(t.z)) return Os(e, t, n, r);
    if (isFinite(e.z)) {
      if (isFinite(t.z)) {
        let s = 1 - e.z / t.z, i = 1 - t.z / e.z;
        return dd(e.x / s + t.x / i, e.y / s + t.y / i, n);
      } else return e;
    } else return t;
  }
  function Oa(e, t, n, r, s) {
    let { mathToPixels: i, map3d: o } = r,
      a = e.x,
      u = t.x,
      c = e.y,
      l = t.y,
      p = e.z,
      f = t.z;
    if (md(e, r) || md(t, r)) {
      let d = Os(e, t, n, r);
      return Ku(d.x, d.y, false);
    }
    if (o) {
      let [d, y, g] = o(a, c), [m, h, x] = o(u, l);
      for (
        ;
        ho(d - m) > r.tolerance || ho(y - h) > r.tolerance ||
        ho(g - x) > r.tolerance;
      ) {
        let T = .5 * (a + u), b = .5 * (c + l), M = n(T, b);
        if (
          M > 0 == p > 0 ? (a = T, c = b, p = M) : (u = T, l = b, f = M),
            (T === a || T === u) && (b === c || b === l)
        ) break;
        [d, y, g] = o(a, c), [m, h, x] = o(u, l);
      }
    } else {
      let [d, y] = i.mapCoordinatePair([a, c]),
        [g, m] = i.mapCoordinatePair([u, l]);
      for (; ho(d - g) > r.tolerance || ho(y - m) > r.tolerance;) {
        let h = .5 * (a + u), x = .5 * (c + l), T = n(h, x);
        T > 0 == p > 0 ? (a = h, c = x, p = T) : (u = h, l = x, f = T),
          [d, y] = i.mapCoordinatePair([a, c]),
          [g, m] = i.mapCoordinatePair([u, l]);
      }
    }
    if (isNaN(p)) return Ku(u, l, false);
    if (isNaN(f)) return Ku(a, c, false);
    {
      let d = Math.abs(p), y = Math.abs(f);
      if (d < s && y > 100 * s) {
        return 1 / d >= y ? Ku(a, c, true) : Ku(u, l, false);
      }
      if (y < s && d > 100 * s) {
        return 1 / y >= d ? Ku(u, l, true) : Ku(a, c, false);
      }
      let g = yL(fd(a, c, p), fd(u, l, f), n, r),
        m = p === 0 || f === 0 || g.z === 0 ||
          g.z >= p == f >= g.z && Math.abs(g.z) < 1e250;
      return Ku(g.x, g.y, m);
    }
  }
  function Bq(e, t, n, r) {
    let { mathToPixels: s, map3d: i } = r;
    if (isNaN(e.z) === isNaN(t.z)) return Os(e, t, n, r);
    if (isNaN(e.z)) {
      let p = e;
      e = t, t = p;
    }
    let o = e.x, a = t.x, u = e.y, c = t.y, l = e.z;
    if (i) {
      let [p, f, d] = i(o, u), [y, g, m] = i(a, c);
      for (
        ;
        ho(p - y) > r.tolerance || ho(f - g) > r.tolerance ||
        ho(d - m) > r.tolerance || isNaN(p) || isNaN(y);
      ) {
        let h = .5 * (o + a), x = .5 * (u + c), T = n(h, x);
        if (
          isNaN(T) === isNaN(l) ? (o = h, u = x, l = T) : (a = h, c = x),
            (h === o || h === a) && (x === u || x === c)
        ) break;
        [p, f, d] = i(o, u), [y, g, m] = i(a, c);
      }
    } else {
      let [p, f] = s.mapCoordinatePair([o, u]),
        [d, y] = s.mapCoordinatePair([a, c]);
      for (; ho(p - d) > r.tolerance || ho(f - y) > r.tolerance;) {
        let g = .5 * (o + a), m = .5 * (u + c), h = n(g, m);
        isNaN(h) === isNaN(l) ? (o = g, u = m, l = h) : (a = g, c = m),
          [p, f] = s.mapCoordinatePair([o, u]),
          [d, y] = s.mapCoordinatePair([a, c]);
      }
    }
    return fd(o, u, l);
  }
  function Gq(e, t, n) {
    let r = { triangles: [], edgeCache: {}, domain: n, fn: t };
    return ym(e, r), r.triangles;
  }
  function ym(e, t) {
    e.children &&
      (ym(e.children[0], t),
        ym(e.children[1], t),
        ym(e.children[2], t),
        ym(e.children[3], t),
        nc(e.children[0], e.children[1], t),
        nc(e.children[3], e.children[2], t),
        rc(e.children[1], e.children[2], t),
        rc(e.children[0], e.children[3], t));
  }
  function nc(e, t, n) {
    e.children && t.children
      ? (nc(e.children[1], t.children[0], n),
        nc(e.children[2], t.children[3], n))
      : e.children
      ? (nc(e.children[1], t, n), nc(e.children[2], t, n))
      : t.children
      ? (nc(e, t.children[0], n), nc(e, t.children[3], n))
      : kq(e, t, n);
  }
  function rc(e, t, n) {
    e.children && t.children
      ? (rc(e.children[2], t.children[1], n),
        rc(e.children[3], t.children[0], n))
      : e.children
      ? (rc(e.children[2], t, n), rc(e.children[3], t, n))
      : t.children
      ? (rc(e, t.children[1], n), rc(e, t.children[0], n))
      : Hq(e, t, n);
  }
  function kq(e, t, n) {
    if (!e.center || !t.center) return;
    let r, s;
    e.depth >= t.depth
      ? (r = Na(e.vertices[1], e.vertices[2], n.fn, n.domain),
        s = mb(e.vertices[1], t.center, e.vertices[2], e.center, r))
      : (r = Na(t.vertices[0], t.vertices[3], n.fn, n.domain),
        s = mb(t.vertices[0], t.center, t.vertices[3], e.center, r)),
      gL(s, n.edgeCache, n.domain);
    for (let i = 0; i < 4; i++) n.triangles.push(s[i]);
  }
  function Hq(e, t, n) {
    if (!e.center || !t.center) return;
    let r, s;
    e.depth >= t.depth
      ? (r = Na(e.vertices[3], e.vertices[2], n.fn, n.domain),
        s = mb(e.vertices[2], t.center, e.vertices[3], e.center, r))
      : (r = Na(t.vertices[1], t.vertices[0], n.fn, n.domain),
        s = mb(t.vertices[1], t.center, t.vertices[0], e.center, r)),
      gL(s, n.edgeCache, n.domain);
    for (let i = 0; i < 4; i++) n.triangles.push(s[i]);
  }
  function mb(e, t, n, r, s) {
    return [pb(e, s, t), pb(t, s, n), pb(n, s, r), pb(r, s, e)];
  }
  function gm(e, t, n) {
    return e.z > 0 && !md(e, n) && (!(t.z > 0) || md(t, n));
  }
  function db(e, t) {
    return "" + e.x + "," + e.y + "," + t.x + "," + t.y;
  }
  function gL(e, t, n) {
    fb(e[0], e[1], e[2], db(e[1].vertices[2], e[1].vertices[0]), t, n),
      fb(e[1], e[2], e[3], db(e[2].vertices[0], e[2].vertices[2]), t, n),
      fb(e[2], e[3], e[0], db(e[3].vertices[2], e[3].vertices[0]), t, n),
      fb(e[3], e[0], e[1], db(e[0].vertices[0], e[0].vertices[2]), t, n);
  }
  function fb(e, t, n, r, s, i) {
    let o = t.vertices[0], a = t.vertices[1], u = t.vertices[2];
    gm(a, u, i) && (t.next = n),
      gm(o, a, i) && (t.next = e),
      gm(u, o, i) && Uq(t, r, s),
      gm(o, u, i) && zq(t, r, s);
  }
  function zq(e, t, n) {
    n[t] ? n[t].next = e : n[t] = e;
  }
  function Uq(e, t, n) {
    n[t] ? e.next = n[t] : n[t] = e;
  }
  function qq(e, t, n) {
    let { tolerance: r, mathToPixels: s, map3d: i } = n, o;
    if (i) {
      let a = { tolerance: r, map: (u) => i(u[0], u[1]) };
      o = {
        fillAccumulator: new $i(a),
        strokeAccumulator: new $i(a),
        fn: t,
        domain: n,
      };
    } else {
      let a = { tolerance: r, map: (u) => s.mapCoordinatePair(u) };
      o = {
        fillAccumulator: new $i(a),
        strokeAccumulator: new $i(a),
        fn: t,
        domain: n,
      };
    }
    for (let a = 0; a < e.length; a++) {
      let u = e[a];
      u.next && !u.visited && $q(u, o);
    }
    return {
      strokeSegments: o.strokeAccumulator.finish().segments,
      fillSegments: o.fillAccumulator.finish().segments,
    };
  }
  function $q(e, t) {
    for (;;) {
      let n = e.vertices[0], r = e.vertices[1], s = e.vertices[2], i = 0;
      isFinite(n.z) && (i = Math.max(i, Math.abs(n.z))),
        isFinite(r.z) && (i = Math.max(i, Math.abs(r.z))),
        isFinite(s.z) && (i = Math.max(i, Math.abs(s.z)));
      let o = 32 * Number.EPSILON * i;
      if (
        CC(n, r, t, o), CC(r, s, t, o), CC(s, n, t, o), e.visited || !e.next
      ) break;
      e.visited = true, e = e.next;
    }
    t.strokeAccumulator.breakSegment(), t.fillAccumulator.breakSegment();
  }
  function CC(e, t, n, r) {
    if (gm(e, t, n.domain)) {
      let s = Oa(e, t, n.fn, n.domain, r);
      n.fillAccumulator.addPoint([s.x, s.y]),
        s.isZero
          ? n.strokeAccumulator.addPoint([s.x, s.y])
          : n.strokeAccumulator.breakSegment();
    }
  }
  function DC(e, t) {
    return { type: "linear", s: e, t };
  }
  function hL(e, t) {
    return { type: "logarithmic", s: e, t };
  }
  function bL(e, t) {
    return { type: "exponential", s: e, t };
  }
  function SC() {
    return DC(1, 0);
  }
  function Yq([e, t], [n, r]) {
    let s = (r - n) / (t - e), i = (n + r) / 2 - s * (t + e) / 2;
    return DC(s, i);
  }
  function Xq([e, t], [n, r]) {
    let s = (r - n) / (Math.log(t) - Math.log(e)),
      i = (Math.log(t) * n - Math.log(e) * r) / (Math.log(t) - Math.log(e));
    return hL(s, i);
  }
  function Zq([e, t], [n, r]) {
    let s = (Math.log(r) - Math.log(n)) / (t - e),
      i = (t * Math.log(n) - e * Math.log(r)) / (t - e);
    return bL(s, i);
  }
  function vC(e, t, n) {
    switch (e) {
      case "linear":
        return Yq(t, n);
      case "logarithmic":
        return Xq(t, n);
      case "exponential":
        return Zq(t, n);
      default: {
        let r = e;
        throw new Error("Unexpected scale type: " + r);
      }
    }
  }
  function OC({ type: e, s: t, t: n }, r) {
    switch (e) {
      case "linear":
        return t * r + n;
      case "logarithmic":
        return t * Math.log(r) + n;
      case "exponential":
        return Math.exp(t * r + n);
      default:
        let s = e;
        throw new Error("Unexpected scale type: " + s);
    }
  }
  function NC(e, t, n, r) {
    switch (e) {
      case "linear":
        return Wq(t, n, r);
      case "logarithmic":
        return Math.pow(t, 1 - r) * Math.pow(n, r);
      case "exponential":
        return r === 0
          ? t
          : r === 1
          ? n
          : Math.log((1 - r) * Math.exp(t) + r * Math.exp(n));
      default:
        let s = e;
        throw new Error("Unexpected scale type: " + s);
    }
  }
  function Wq(e, t, n) {
    return (1 - n) * e + n * t;
  }
  function RC({ type: e, s: t, t: n }) {
    switch (e) {
      case "linear":
        return DC(1 / t, -n / t);
      case "logarithmic":
        return bL(1 / t, -n / t);
      case "exponential":
        return hL(1 / t, -n / t);
      default:
        let r = e;
        throw new Error("Unexpected scale type: " + r);
    }
  }
  function AC(e) {
    switch (e) {
      case "linear":
        return "linear";
      case "logarithmic":
        return "exponential";
      case "exponential":
        return "logarithmic";
      default:
        let t = e;
        throw new Error("Unexpected scale type: " + t);
    }
  }
  function yb({ width: e, height: t }) {
    return { left: 0, right: e, top: 0, bottom: t };
  }
  function gb({ xmin: e, xmax: t, ymin: n, ymax: r }) {
    return { left: e, right: t, bottom: n, top: r };
  }
  var sc = class e {
    constructor(t, n) {
      this.xScale = t, this.yScale = n;
    }
    static fromRects(t, n, { xAxisScale: r, yAxisScale: s }) {
      return new e(
        vC(r, [t.left, t.right], [n.left, n.right]),
        vC(s, [t.bottom, t.top], [n.bottom, n.top]),
      );
    }
    static fromRectsInverse(t, n, { xAxisScale: r, yAxisScale: s }) {
      return e.fromRects(n, t, { xAxisScale: AC(r), yAxisScale: AC(s) });
    }
    inverse() {
      return new e(RC(this.xScale), RC(this.yScale));
    }
    mapX(t) {
      return OC(this.xScale, t);
    }
    mapY(t) {
      return OC(this.yScale, t);
    }
    mapPoint({ x: t, y: n }) {
      return { x: this.mapX(t), y: this.mapY(n) };
    }
    mapCoordinatePair([t, n]) {
      return [this.mapX(t), this.mapY(n)];
    }
    mapRect({ top: t, bottom: n, left: r, right: s }) {
      return {
        left: this.mapX(r),
        right: this.mapX(s),
        bottom: this.mapY(n),
        top: this.mapY(t),
      };
    }
    interpolateX(t, n, r) {
      return NC(this.xScale.type, t, n, r);
    }
    interpolateY(t, n, r) {
      return NC(this.yScale.type, t, n, r);
    }
    dangerouslyGetXScaleFactor() {
      if (this.xScale.type !== "linear") {
        throw new Error(
          `Cannot get scale factor a '${this.xScale.type}' scale`,
        );
      }
      return this.xScale.s;
    }
    dangerouslyGetYScaleFactor() {
      if (this.yScale.type !== "linear") {
        throw new Error(
          `Cannot get scale factor a '${this.yScale.type}' scale`,
        );
      }
      return this.yScale.s;
    }
  };
  function hb(e, t, n, r) {
    let s = [],
      i = [],
      o = [],
      a = [],
      { xmin: u, xmax: c, ymin: l, ymax: p, zmin: f, zmax: d } = n,
      y,
      g,
      m;
    switch (r) {
      case "z":
        y = { xmin: u, xmax: c, ymin: l, ymax: p },
          g = (b, M) => [b[M], b[M + 1], f, b[M], b[M + 1], d],
          m = (b, M) => e(b, M, 0);
        break;
      case "y":
        y = { xmin: u, xmax: c, ymin: f, ymax: d },
          g = (b, M) => [b[M], l, b[M + 1], b[M], p, b[M + 1]],
          m = (b, M) => e(b, 0, M);
        break;
      case "x":
        y = { xmin: f, xmax: d, ymin: l, ymax: p },
          g = (b, M) => [u, b[M + 1], b[M], c, b[M + 1], b[M]],
          m = (b, M) => e(0, M, b);
        break;
    }
    let h = yb({ width: 500, height: 500 }),
      x = {
        ...y,
        mathToPixels: sc.fromRects(gb(y), h, {
          xAxisScale: "linear",
          yAxisScale: "linear",
        }),
        tolerance: bo,
      },
      T = hm(m, x);
    for (let b of T.segments) {
      for (let M = 0; M < b.length / 2; M++) {
        let [P, D, S, O, _, L] = g(b, 2 * M);
        if (s.push(P, D, S, O, _, L), o.push(P, D, O, _), t) {
          let w = t(P, D, S), G = t(O, _, L);
          i.push(w[0], w[1], w[2]), i.push(G[0], G[1], G[2]);
        } else i.push(0, 0, 0), i.push(0, 0, 0);
        if (M > 0) {
          let w = s.length / 3 - 4;
          a.push(w, w + 1, w + 2), a.push(w + 2, w + 1, w + 3);
        }
      }
    }
    return cd(a, s, i, o, 0, [], .7), {
      positions: s,
      normals: i,
      faces: a,
      uvs: o,
      resolved: T.resolved,
      extraAttrs: [],
    };
  }
  var bb = [
      [1, 2, 4, 21, 20, 18],
      [0, 1, 3, 20, 19, 18],
      [2, 6, 7, 25, 21, 18],
      [5, 6, 8, 25, 22, 18],
      [5, 9, 11, 23, 22, 18],
      [0, 9, 10, 23, 19, 18],
      [10, 12, 14, 24, 23, 19],
      [3, 12, 13, 24, 20, 19],
      [4, 13, 15, 24, 21, 20],
      [15, 7, 16, 25, 24, 21],
      [11, 17, 14, 24, 23, 22],
      [17, 8, 16, 25, 24, 22],
    ],
    zr = [
      0,
      1,
      0,
      2,
      0,
      3,
      1,
      2,
      2,
      3,
      0,
      4,
      0,
      7,
      3,
      7,
      4,
      7,
      0,
      5,
      1,
      5,
      4,
      5,
      1,
      6,
      2,
      6,
      5,
      6,
      3,
      6,
      6,
      7,
      4,
      6,
      0,
      8,
      1,
      8,
      2,
      8,
      3,
      8,
      4,
      8,
      5,
      8,
      6,
      8,
      7,
      8,
    ],
    TL = [
      [0, 2, 3, 8],
      [0, 1, 2, 8],
      [0, 3, 7, 8],
      [0, 4, 7, 8],
      [0, 4, 5, 8],
      [0, 1, 5, 8],
      [1, 5, 6, 8],
      [1, 2, 6, 8],
      [2, 3, 6, 8],
      [3, 6, 7, 8],
      [4, 5, 6, 8],
      [4, 6, 7, 8],
    ],
    IL = [
      [0, 0, 0],
      [0, 1, 0],
      [1, 1, 0],
      [1, 0, 0],
      [0, 0, 1],
      [0, 1, 1],
      [1, 1, 1],
      [1, 0, 1],
      [.5, .5, .5],
    ],
    _C = [
      [1, 2, 4],
      [4, 20, 21],
      [2, 18, 21],
      [1, 18, 20],
      [0, 1, 3],
      [3, 19, 20],
      [0, 18, 19],
      [2, 6, 7],
      [7, 21, 25],
      [6, 18, 25],
      [5, 6, 8],
      [8, 22, 25],
      [5, 18, 22],
      [5, 9, 11],
      [11, 22, 23],
      [9, 18, 23],
      [0, 9, 10],
      [10, 19, 23],
      [10, 12, 14],
      [14, 23, 24],
      [12, 19, 24],
      [3, 12, 13],
      [13, 20, 24],
      [4, 13, 15],
      [15, 21, 24],
      [15, 7, 16],
      [16, 24, 25],
      [11, 17, 14],
      [17, 22, 24],
      [17, 8, 16],
    ],
    LC = [];
  for (let e = 0; e < 30; e++) {
    let t = _C[e], n = new Set();
    for (let r of t) n.add(zr[r * 2]), n.add(zr[r * 2 + 1]);
    LC[e] = [...n];
  }
  var PL = [
      [0, 3, 2, 1],
      [4, 6, 3, 5],
      [7, 2, 9, 8],
      [10, 12, 9, 11],
      [13, 12, 15, 14],
      [16, 6, 15, 17],
      [18, 17, 20, 19],
      [21, 5, 20, 22],
      [23, 1, 22, 24],
      [25, 24, 8, 26],
      [27, 14, 28, 19],
      [29, 28, 11, 26],
    ],
    Jq = 1 << 31,
    Qq = 1 << 30,
    xL = 1 << 24,
    Pl = 1 << 24,
    Yi = 1 << 24,
    xo = 65536,
    To = 256,
    Io = 1;
  function EL(e, t, n) {
    return n * xo + t * To + e * Io;
  }
  var Kq = {
    0: 0 * xL,
    1: To,
    2: Io + To,
    3: Io,
    4: xo,
    5: To + xo,
    6: Io + To + xo,
    7: Io + xo,
    8: 8 * xL,
  };
  function ML(e, t) {
    return Jq + e + Kq[t];
  }
  var e8 = {
    3: 2 * Yi + To,
    4: 0 * Yi + Io,
    7: 5 * Yi + Io,
    8: 2 * Yi + xo,
    10: 5 * Yi + To,
    11: 0 * Yi + xo,
    12: 6 * Yi + To,
    13: 5 * Yi + Io + To,
    14: 2 * Yi + To + xo,
    15: 9 * Yi + Io,
    16: 0 * Yi + Io + xo,
    17: 1 * Yi + xo,
  };
  function bm(e, t) {
    var n;
    return Qq + e + ((n = e8[t]) != null ? n : Yi * t);
  }
  var t8 = {
    18: 10 * Pl + To,
    21: 7 * Pl + To,
    23: 16 * Pl + Io,
    25: 13 * Pl + Io,
    27: 4 * Pl + xo,
    29: 0 * Pl + xo,
  };
  function wC(e, t) {
    var n;
    return e + ((n = t8[t]) != null ? n : Pl * t);
  }
  var yd = class {
      constructor(t, n, r, s, i) {
        this.PAConstructor = t;
        this.x = n;
        this.y = r;
        this.z = s;
        this.gridsize = i;
        this.i = 0;
        this.j = 0;
        this.k = 0;
        this.cubeVertex = new Array(9);
        this.cubeVertexValue = new this.PAConstructor(9);
        if (i > 250) {
          throw new Error(
            "Programming Error: resolution should be clamped well below 250.",
          );
        }
        this.size = new st(
          this.x.width / i,
          this.y.width / i,
          this.z.width / i,
        );
      }
      loopOverUnitCubes(t) {
        let n = this.gridsize,
          r = n + 1,
          s = new xb(
            this.x.min,
            this.y.min,
            this.z.min,
            this.size.x,
            this.size.y,
            this.size.z,
            n + 1,
            n + 1,
            n + 1,
          ),
          i = new xb(
            this.x.min + this.size.x / 2,
            this.y.min + this.size.y / 2,
            this.z.min + this.size.z / 2,
            this.size.x,
            this.size.y,
            this.size.z,
            n,
            n,
            n,
          ),
          o = s.setupArray(this.PAConstructor),
          a = s.setupArray(this.PAConstructor),
          u = i.setupArray(this.PAConstructor);
        this.evaluateArray(a, s, 0);
        for (let c = 0; c < n; c++) {
          this.k = c,
            [o, a] = [a, o],
            this.evaluateArray(a, s, c + 1),
            this.evaluateArray(u, i, c);
          for (let l = 0; l < n; l++) {
            this.j = l;
            for (let p = 0; p < n; p++) {
              this.i = p;
              let f = l * r + p;
              this.cubeVertexValue.setFrom(0, o, f),
                this.cubeVertexValue.setFrom(1, o, f + r),
                this.cubeVertexValue.setFrom(2, o, f + r + 1),
                this.cubeVertexValue.setFrom(3, o, f + 1),
                this.cubeVertexValue.setFrom(4, a, f),
                this.cubeVertexValue.setFrom(5, a, f + r),
                this.cubeVertexValue.setFrom(6, a, f + r + 1),
                this.cubeVertexValue.setFrom(7, a, f + 1),
                this.cubeVertexValue.setFrom(8, u, l * n + p),
                t();
            }
          }
        }
      }
      evaluateArray(t, n, r) {
        let s = n.z0 + r * n.dz;
        for (let i = 0; i < n.numX; i++) {
          for (let o = 0; o < n.numY; o++) {
            let a = n.x0 + i * n.dx, u = n.y0 + o * n.dy;
            this.setAt(t, o * n.numX + i, a, u, s);
          }
        }
      }
      setVertexPositions() {
        for (let t = 0; t < 9; t++) {
          let n = IL[t];
          this.cubeVertex[t] = [
            this.x.min + (this.i + n[0]) * this.size.x,
            this.y.min + (this.j + n[1]) * this.size.y,
            this.z.min + (this.k + n[2]) * this.size.z,
          ];
        }
      }
    },
    xb = class {
      constructor(t, n, r, s, i, o, a, u, c) {
        this.x0 = t;
        this.y0 = n;
        this.z0 = r;
        this.dx = s;
        this.dy = i;
        this.dz = o;
        this.numX = a;
        this.numY = u;
        this.numZ = c;
      }
      setupArray(t) {
        return new t(this.numX * this.numY);
      }
    };
  var Tb = class {
      constructor(t) {
        this.length = t;
        this.n = 1;
        this.buffer = new Float64Array(t);
      }
      set(t, n) {
        this.buffer[t] = n;
      }
      get(t) {
        return this.buffer[t];
      }
      setFrom(t, n, r) {
        if (n.n !== this.n) {
          throw new Error("Programming Error: Mismatched dimensions");
        }
        this.set(t, n.get(r));
      }
    },
    Ib = class {
      constructor(t) {
        this.length = t;
        this.n = 2;
        this.buffer = new Float64Array(t * 2);
      }
      set(t, n, r) {
        this.buffer[t * 2] = n, this.buffer[t * 2 + 1] = r;
      }
      getX(t) {
        return this.buffer[t * 2];
      }
      getY(t) {
        return this.buffer[t * 2 + 1];
      }
      setFrom(t, n, r) {
        if (n.n !== this.n) {
          throw new Error("Programming Error: Mismatched dimensions");
        }
        this.set(t, n.getX(r), n.getY(r));
      }
    };
  function xm(e, t, n, r, s, i = 100) {
    if (isFinite(r) || ([r, s] = [s, r], [t, n] = [n, t]), isFinite(s)) {
      return FC(e, t, n, r, s, i);
    }
    for (;;) {
      let o = Fi(t, n, .5), a = e(...o);
      if (a === 0) return o;
      if (!isFinite(a)) n = o, s = a;
      else if (r < 0 == a < 0) t = o, r = a;
      else return n = o, s = a, FC(e, t, n, r, s, i);
      if (i *= .5, i < 1) return;
    }
  }
  function CL(e, t, n, r, s, i = 100) {
    if (isFinite(r) || ([r, s] = [s, r], [t, n] = [n, t]), !isFinite(s)) {
      for (;;) {
        let o = Fi(t, n, .5), a = e(...o);
        if (a === 0) {
          return { posNeg: o };
        }
        if (!isFinite(a)) n = o, s = a;
        else if (r < 0 == a < 0) t = o, r = a;
        else if (r > 0) {
          n = o, s = a;
          break;
        } else return { posNeg: VC(e, o, t, a, r, i), posNaN: n8(e, o, n, i) };
        if (i *= .5, i < 1) {
          let u = Fi(t, n, .5);
          return r > 0 ? { posNaN: u } : {};
        }
      }
    }
    return { posNeg: FC(e, t, n, r, s, i) };
  }
  function FC(e, t, n, r, s, i) {
    return r > 0 ? VC(e, t, n, r, s, i) : VC(e, n, t, s, r, i);
  }
  function VC(e, t, n, r, s, i) {
    let o = r - s;
    for (;;) {
      let a = Fi(t, n, .5), u = e(...a);
      if (u < 0) n = a, s = u;
      else if (u > 0) t = a, r = u;
      else return u === 0 ? a : void 0;
      if (i *= .5, i < 1) {
        if (r - s < .1 * o) return Fi(t, n, .5);
        if (i < 1e-6) return;
      }
    }
  }
  function n8(e, t, n, r) {
    for (;;) {
      let s = Fi(t, n, .5), i = e(...s);
      if (!isFinite(i)) n = s;
      else if (i >= 0) t = s;
      else return;
      if (r *= .5, r < 1) return Fi(t, n, .5);
    }
  }
  var Im = 50;
  function El(e) {
    return e !== void 0 && e !== 0;
  }
  function r8(e) {
    return El(e.posNeg) || El(e.posNaN);
  }
  var Tm = {};
  function BC(e = Tm, t = Tm, n = Tm) {
    return { edge0: e, edge1: t, edge2: n };
  }
  function DL(e, t, n, r, { isInequality: s }) {
    return new GC(
      e,
      t,
      new qe(n.xmin, n.xmax),
      new qe(n.ymin, n.ymax),
      new qe(n.zmin, n.zmax),
      r,
      { isInequality: s },
    ).fullLoopOverUnitCubes();
  }
  var GC = class extends yd {
    constructor(n, r, s, i, o, a, { isInequality: u }) {
      super(Tb, s, i, o, a);
      this.f = n;
      this.gradient = r;
      this.cubeEdge = new Array(26);
      this.face = BC();
      this.cubeHasCrossing = false;
      this.allNormalsFromGradient = true;
      this.normalFromGradient = [];
      this.edgesMaybeCross = 0;
      this.positions = [];
      this.uvs = [];
      this.normals = [];
      this.triangles = [];
      this.isInequality = u,
        this.sheet = Array((a + 1) * (a + 1)),
        this.strip = Array(a + 1);
      for (let c = 0; c < (a + 1) * (a + 1); c++) this.sheet[c] = BC();
      for (let c = 0; c < a + 1; c++) this.strip[c] = BC();
    }
    setAt(n, r, s, i, o) {
      let a = this.f(s, i, o);
      n.set(r, a);
    }
    fullLoopOverUnitCubes() {
      this.positions = [],
        this.normals = [],
        this.triangles = [],
        this.loopOverUnitCubes(this.onEachCube.bind(this));
      let { uvs: n, positions: r, normals: s } = this;
      if (!this.allNormalsFromGradient) {
        for (let i = 0; i < s.length / 3; i++) {
          if (this.normalFromGradient[i]) {
            continue;
          }
          let o = s[3 * i],
            a = s[3 * i + 1],
            u = s[3 * i + 2],
            c = Math.sqrt(o * o + a * a + u * u);
          s[3 * i] = o / c, s[3 * i + 1] = a / c, s[3 * i + 2] = u / c;
        }
      }
      return cd(this.triangles, this.positions, s, n, 0, [], .7), {
        positions: r,
        normals: s,
        faces: this.triangles,
        uvs: n,
        resolved: true,
        extraAttrs: [],
      };
    }
    onEachCube() {
      this.edgesMaybeCross = 0, this.cubeHasCrossing = false;
      for (let n = 0; n < 26; n++) {
        let r = this.cubeVertexValue.get(zr[n * 2]),
          s = this.cubeVertexValue.get(zr[n * 2 + 1]);
        (r === 0 || s === 0) && (this.cubeHasCrossing = true),
          !(r > 0 && s > 0 || r < 0 && s < 0) && (isFinite(r) || isFinite(s)) &&
          (this.edgesMaybeCross |= 1 << n);
      }
      this.edgesMaybeCross && (this.setVertexPositions(), this.setEdges()),
        this.saveEdges(),
        this.cubeHasCrossing && this.generateTriangles();
    }
    setEdges() {
      let { i: n, j: r, k: s, gridsize: i } = this,
        o = this.sheet[(n + 0) * (i + 1) + r + 0],
        a = this.sheet[(n + 1) * (i + 1) + r + 0],
        u = this.sheet[(n + 0) * (i + 1) + r + 1],
        c = 0;
      s > 0 &&
      (this.cubeEdge[0] = o.edge0,
        this.cubeEdge[1] = o.edge1,
        this.cubeEdge[2] = o.edge2,
        this.cubeEdge[3] = u.edge2,
        this.cubeEdge[4] = a.edge0,
        c |= 31),
        r > 0 &&
        (this.cubeEdge[5] = this.strip[n].edge0,
          this.cubeEdge[6] = this.strip[n].edge1,
          this.cubeEdge[7] = this.strip[n + 1].edge0,
          this.cubeEdge[8] = this.strip[n].edge2,
          c |= 480,
          s == 0 && (this.cubeEdge[2] = o.edge2, c |= 4)),
        n > 0 &&
        (this.cubeEdge[9] = this.face.edge0,
          this.cubeEdge[10] = this.face.edge1,
          this.cubeEdge[11] = this.face.edge2,
          c |= 3584,
          s == 0 && (this.cubeEdge[0] = o.edge0, c |= 1),
          r == 0 && (this.cubeEdge[5] = this.strip[n].edge0, c |= 32));
      for (let l = 0; l < 26; l++) {
        if (~this.edgesMaybeCross >> l & 1) {
          this.cubeEdge[l] = Tm;
          continue;
        }
        if (c >> l & 1) {
          !this.cubeHasCrossing &&
            (this.cubeEdge[l].posNeg || this.cubeEdge[l].posNaN) &&
            (this.cubeHasCrossing = true);
          continue;
        }
        let p = this.findSurfaceCrossingEDI(zr[l * 2], zr[l * 2 + 1]);
        this.cubeEdge[l] = p, r8(p) && (this.cubeHasCrossing = true);
      }
    }
    saveEdges() {
      let { i: n, j: r, k: s, gridsize: i } = this;
      s < i - 1 &&
      (this.sheet[(n + 0) * (i + 1) + r + 0].edge0 = this.cubeEdge[11],
        this.sheet[(n + 0) * (i + 1) + r + 0].edge1 = this.cubeEdge[17],
        this.sheet[(n + 0) * (i + 1) + r + 0].edge2 = this.cubeEdge[8]),
        r < i - 1 &&
        (this.strip[n].edge0 = this.cubeEdge[10],
          this.strip[n].edge1 = this.cubeEdge[12],
          this.strip[n].edge2 = this.cubeEdge[14]),
        n < i - 1 &&
        (this.face.edge0 = this.cubeEdge[15],
          this.face.edge1 = this.cubeEdge[13],
          this.face.edge2 = this.cubeEdge[16]),
        s == 0 &&
        (this.sheet[(n + 0) * (i + 1) + r + 1].edge2 = this.cubeEdge[3],
          this.sheet[(n + 1) * (i + 1) + r + 0].edge0 = this.cubeEdge[4]),
        r == 0 && (this.strip[n + 1].edge0 = this.cubeEdge[7]),
        r == i - 1 && (this.sheet[n * (i + 1) + i].edge2 = this.cubeEdge[14]),
        n == i - 1 &&
        (this.sheet[(i + 0) * (i + 1) + r].edge0 = this.cubeEdge[16],
          this.strip[i].edge0 = this.cubeEdge[13]);
    }
    findSurfaceCrossingEDI(n, r) {
      let s = this.cubeVertexValue.get(n), i = this.cubeVertexValue.get(r);
      if (s === 0 || i === 0) return Tm;
      let o = this.cubeVertex[n], a = this.cubeVertex[r];
      if (this.isInequality) {
        let { posNeg: u, posNaN: c } = CL(this.f, o, a, s, i);
        return {
          posNeg: u !== void 0 ? this.pushPositionWithGradient(...u) : void 0,
          posNaN: c !== void 0 ? this.pushPositionNoGradient(...c) : void 0,
        };
      } else {
        let u = xm(this.f, o, a, s, i);
        return {
          posNeg: u !== void 0 ? this.pushPositionWithGradient(...u) : void 0,
        };
      }
    }
    pushPositionWithGradient(n, r, s) {
      if (!(isFinite(n) && isFinite(r) && isFinite(s))) return 0;
      let [i, o, a] = this.computeGradient(n, r, s),
        u = Math.sqrt(i * i + o * o + a * a);
      return i /= -u,
        o /= -u,
        a /= -u,
        ep(i, o, a)
          ? (this.normalFromGradient.push(true),
            this._pushPositionAndNormal(n, r, s, i, o, a))
          : this.pushPositionNoGradient(n, r, s);
    }
    pushPositionNoGradient(n, r, s) {
      return isFinite(n) && isFinite(r) && isFinite(s)
        ? (this.allNormalsFromGradient = false,
          this.normalFromGradient.push(false),
          this._pushPositionAndNormal(n, r, s, 0, 0, 0))
        : 0;
    }
    _pushPositionAndNormal(n, r, s, i, o, a) {
      return this.positions.push(n, r, s),
        this.uvs.push(
          (n - this.x.min) / this.x.width,
          (r - this.y.min) / this.y.width,
        ),
        this.normals.push(i, o, a),
        this.positions.length / 3;
    }
    computeGradient(n, r, s) {
      let i = NaN, o = NaN, a = NaN;
      if (
        this.gradient &&
        ([i, o, a] = this.gradient(n, r, s),
          isFinite(i) && isFinite(o) && isFinite(a))
      ) return [i, o, a];
      let u = .001 * Math.min(this.size.x, this.size.y, this.size.z),
        c = this.f(n, r, s);
      if (
        isFinite(i) || (i = (this.f(n + u, r, s) - c) / u),
          isFinite(i) || (i = (c - this.f(n - u, r, s)) / u),
          isFinite(o) || (o = (this.f(n, r + u, s) - c) / u),
          isFinite(o) || (o = (c - this.f(n, r - u, s)) / u),
          isFinite(a) || (a = (this.f(n, r, s + u) - c) / u),
          isFinite(a) || (a = (c - this.f(n, r, s - u)) / u),
          isFinite(i) && isFinite(o) && isFinite(a)
      ) return [i, o, a];
      let l = NaN, p = NaN, f = NaN, d = NaN, y = NaN, g = NaN, m = u / 2;
      return (!isFinite(i) || !isFinite(o)) &&
        (l = (this.f(n + m, r + m, s) - c) / u,
          isFinite(l) || (l = (c - this.f(n - m, r - m, s)) / u),
          p = (this.f(n + m, r - m, s) - c) / u,
          isFinite(p) || (p = (c - this.f(n - m, r + m, s)) / u),
          isFinite(l) && isFinite(p) &&
          (isFinite(i) || (i = l + p), isFinite(o) || (o = l - p))),
        (!isFinite(o) || !isFinite(a)) &&
        (f = (this.f(n, r + m, s + m) - c) / u,
          isFinite(f) || (f = (c - this.f(n, r - m, s - m)) / u),
          d = (this.f(n, r + m, s - m) - c) / u,
          isFinite(d) || (d = (c - this.f(n, r - m, s + m)) / u),
          isFinite(f) && isFinite(d) &&
          (isFinite(o) || (o = f + d), isFinite(a) || (a = f - d))),
        (!isFinite(a) || !isFinite(i)) &&
        (y = (this.f(n + m, r, s + m) - c) / u,
          isFinite(y) || (y = (c - this.f(n - m, r, s - m)) / u),
          g = (this.f(n - m, r, s + m) - c) / u,
          isFinite(g) || (g = (c - this.f(n + m, r, s - m)) / u),
          isFinite(y) && isFinite(g) &&
          (isFinite(i) || (i = y - g), isFinite(a) || (a = y + g))),
        [i, o, a];
    }
    generateTriangles() {
      for (let n = 0; n < 12; n++) {
        let r = bb[n],
          s = [],
          i = 0,
          o = TL[n],
          a = 0,
          u = o[0],
          c = Math.abs(this.cubeVertexValue.get(u));
        c > a && isFinite(c) && (a = c);
        let l = o[1], p = Math.abs(this.cubeVertexValue.get(l));
        p > a && isFinite(p) && (a = p);
        let f = o[2], d = Math.abs(this.cubeVertexValue.get(f));
        d > a && isFinite(d) && (a = d);
        let y = o[3], g = Math.abs(this.cubeVertexValue.get(y));
        g > a && isFinite(g) && (a = g);
        let m = a * Number.EPSILON * 32;
        if (c <= m) {
          i |= 35;
          let x = this.pushPositionWithGradient(...this.cubeVertex[u]);
          x !== void 0 && s.push(x);
        }
        if (p <= m) {
          i |= 21;
          let x = this.pushPositionWithGradient(...this.cubeVertex[l]);
          x !== void 0 && s.push(x);
        }
        if (d <= m) {
          i |= 14;
          let x = this.pushPositionWithGradient(...this.cubeVertex[f]);
          x !== void 0 && s.push(x);
        }
        if (g <= m) {
          i |= 56;
          let x = this.pushPositionWithGradient(...this.cubeVertex[y]);
          x !== void 0 && s.push(x);
        }
        if (s.length === 4) continue;
        let h;
        for (let x = 0; x < 4; x++) {
          let T = o[x];
          if (this.cubeVertexValue.get(T) > m) {
            h = this.cubeVertex[T];
            break;
          }
        }
        if (h === void 0 && this.isInequality) {
          for (let x = 0; x < 6; x++) {
            if (i >> x & 1) continue;
            let { posNeg: T, posNaN: b } = this.cubeEdge[r[x]];
            if (El(T) && El(b)) {
              h = Fi(
                this.positions.slice((T - 1) * 3, T * 3),
                this.positions.slice((b - 1) * 3, b * 3),
                .5,
              );
              break;
            }
          }
        }
        if (h === void 0) {
          for (let x = 0; x < 4; x++) {
            let T = o[x];
            if (!isFinite(this.cubeVertexValue.get(T))) {
              h = this.cubeVertex[T];
              break;
            }
          }
        }
        if (h === void 0 && i && s.length > 0) {
          let x;
          for (let T = 0; T < 4; T++) {
            let b = o[T];
            if (this.cubeVertexValue.get(b) < -m) {
              x = this.cubeVertex[b];
              break;
            }
          }
          if (x) {
            let T = s[0], b = this.positions.slice((T - 1) * 3, T * 3);
            h = Fi(x, b, 2);
          }
        }
        if (h !== void 0) {
          if (this.isInequality) {
            let x = [], T = [], b = false;
            for (let M = 0; M < 6; M++) {
              if (i >> M & 1) continue;
              let { posNeg: P, posNaN: D } = this.cubeEdge[r[M]],
                S = El(P),
                O = El(D);
              S && x.push(P), O && T.push(D), S && O && (b = true);
            }
            if (b) {
              x.push(...s),
                this.pushTriangleFromCorners(T, h),
                this.pushTriangleFromCorners(x, h);
              continue;
            }
          }
          for (let x = 0; x < 6; x++) {
            if (i >> x & 1) continue;
            let { posNeg: T, posNaN: b } = this.cubeEdge[r[x]], M = T || b;
            El(M) && s.push(M);
          }
          this.pushTriangleFromCorners(s, h);
        }
      }
    }
    pushTriangleFromCorners(n, r) {
      if (n.length >= 3) {
        let s = n[0] - 1, i = n[1] - 1, o = n[2] - 1;
        this.pushTriangle(s, i, o, r);
      }
      if (n.length == 4) {
        let s = n[0] - 1, i = n[2] - 1, o = n[3] - 1;
        this.pushTriangle(s, i, o, r);
      }
    }
    pushTriangle(n, r, s, i) {
      this.allNormalsFromGradient || this.fixBadNormals(n, r, s, i),
        this.checkWindingOrder(n, r, s) && ([r, s] = [s, r]),
        this.triangles.push(n, r, s);
    }
    fixBadNormals(n, r, s, i) {
      let o = !this.normalFromGradient[n],
        a = !this.normalFromGradient[r],
        u = !this.normalFromGradient[s];
      if (!(o || a || u)) return;
      let c = this.positions,
        l = this.normals,
        p = new st(c[3 * n], c[3 * n + 1], c[3 * n + 2]),
        f = new st(c[3 * r], c[3 * r + 1], c[3 * r + 2]),
        d = new st(c[3 * s], c[3 * s + 1], c[3 * s + 2]),
        y = new st().subVectors(d, p),
        g = new st().subVectors(p, f),
        m = y.cross(g),
        h = new st().subVectors(p, new st(...i));
      m.dot(h) < 0 && m.multiply(-1),
        m.isFinite() &&
        (o && (l[3 * n + 0] += m.x, l[3 * n + 1] += m.y, l[3 * n + 2] += m.z),
          a && (l[3 * r + 0] += m.x, l[3 * r + 1] += m.y, l[3 * r + 2] += m.z),
          u && (l[3 * s + 0] += m.x, l[3 * s + 1] += m.y, l[3 * s + 2] += m.z));
    }
    checkWindingOrder(n, r, s) {
      let i = this.positions,
        o = this.normals,
        a = i[3 * s] - i[3 * n],
        u = i[3 * s + 1] - i[3 * n + 1],
        c = i[3 * s + 2] - i[3 * n + 2],
        l = i[3 * n] - i[3 * r],
        p = i[3 * n + 1] - i[3 * r + 1],
        f = i[3 * n + 2] - i[3 * r + 2],
        d = u * f - c * p,
        y = c * l - a * f,
        g = a * p - u * l,
        m = o[3 * n],
        h = o[3 * n + 1],
        x = o[3 * n + 2];
      return d * m + y * h + g * x < 0;
    }
  };
  var { floor: s8 } = Math;
  function kC(e) {
    let t = [];
    for (let n of e) t.push(...n), t.push(NaN, NaN, NaN);
    return t;
  }
  function Ml(e, t, n, r) {
    (n === void 0 || isNaN(n)) && (n = zC(t.min, t.max)),
      n = clamp(s8(n), 2, 2e3);
    let { xmin: s, xmax: i, ymin: o, ymax: a, zmin: u, zmax: c } = r.viewport;
    u != null || (u = Dr.zmin), c != null || (c = Dr.zmax);
    let l = Pb(e, {
      min: t.min,
      max: t.max,
      nInitialSamples: n,
      xtolerance: (i - s) / 1e3,
      ytolerance: (a - o) / 1e3,
      ztolerance: (c - u) / 1e3,
      map: (p) => p,
    });
    return kC(l.segments);
  }
  function HC(e, t, n, r) {
    let s = r.degreeMode ? Math.PI / 180 : 1;
    return Ml(
      (i) => {
        let o = e(i), a = o[0], u = o[1], c = o[2];
        return [a * cos(u * s), a * sin(u * s), c];
      },
      t,
      n,
      r,
    );
  }
  function SL(e, t, n, r) {
    let s = r.degreeMode ? Math.PI / 180 : 1;
    return Ml(
      (i) => {
        let o = e(i), a = o[0], u = o[1], c = o[2];
        return [
          a * sin(c * s) * cos(u * s),
          a * sin(c * s) * sin(u * s),
          a * cos(c * s),
        ];
      },
      t,
      n,
      r,
    );
  }
  function AL(e, t, n, r) {
    let s = i8(e, t, n, r);
    return kC(s);
  }
  function i8(e, t, n, r) {
    return new YC(
      e,
      t,
      new qe(n.xmin, n.xmax),
      new qe(n.ymin, n.ymax),
      new qe(n.zmin, n.zmax),
      r,
    ).run();
  }
  var o8 = {},
    YC = class extends yd {
      constructor(n, r, s, i, o, a) {
        super(Ib, s, i, o, a);
        this.f = n;
        this.g = r;
        this.vertexFGZs = {};
        this.vertexZeroF = {};
        this.vertexZeroG = {};
        this.threshF = 0;
        this.threshG = 0;
        this.cubeID = 0;
        this.edgesMaybeCrossF = 0;
        this.edgesMaybeCrossG = 0;
        this.tetEdgeCrossings = new Array(26);
        this.edgeFGZs = new Array(26);
        this.edgeCrossings = new Map();
        this.allFGZs = new Map();
      }
      setAt(n, r, s, i, o) {
        let a = this.f(s, i, o), u = this.g(s, i, o);
        n.set(r, a, u);
      }
      run() {
        return this.loopOverUnitCubes(this.onEachCube.bind(this)),
          this.traceCurves();
      }
      onEachCube() {
        this.cubeID = EL(this.i, this.j, this.k),
          this.pruneEdges(),
          this.edgesMaybeCrossF && this.edgesMaybeCrossG &&
          (this.setVertexPositions(),
            this.setVertexZeros(),
            this.setEdgeCrossings(),
            this.insertCurveSegmentsFromCube());
      }
      pruneEdges() {
        this.edgesMaybeCrossF = 0, this.edgesMaybeCrossG = 0;
        for (let n = 0; n < 26; n++) {
          let r = zr[n * 2],
            s = zr[n * 2 + 1],
            i = this.cubeVertexValue.getX(r),
            o = this.cubeVertexValue.getY(r),
            a = this.cubeVertexValue.getX(s),
            u = this.cubeVertexValue.getY(s);
          !(i > 0 && a > 0 || i < 0 && a < 0) && (isFinite(i) || isFinite(a)) &&
          (this.edgesMaybeCrossF |= 1 << n),
            !(o > 0 && u > 0 || o < 0 && u < 0) &&
            (isFinite(o) || isFinite(u)) && (this.edgesMaybeCrossG |= 1 << n);
        }
      }
      setVertexZeros() {
        let n = 0, r = 0;
        for (let o = 0; o < 9; o++) {
          let a = this.cubeVertexValue.getX(o),
            u = this.cubeVertexValue.getY(o),
            c = Math.abs(a),
            l = Math.abs(u);
          c > n && isFinite(c) && (n = c), l > r && isFinite(c) && (r = l);
        }
        let s = this.threshF = n * Number.EPSILON * 32,
          i = this.threshG = r * Number.EPSILON * 32;
        for (let o = 0; o < 9; o++) {
          let a = this.cubeVertexValue.getX(o),
            u = this.cubeVertexValue.getY(o),
            c = Math.abs(a),
            l = Math.abs(u);
          if (
            this.vertexZeroF[o] = c <= s,
              this.vertexZeroG[o] = l <= i,
              c <= s && l <= i
          ) {
            let p = this.cubeVertex[o],
              f = this.createFGZ(ML(this.cubeID, o), p);
            this.vertexFGZs[o] = f;
          } else this.vertexFGZs[o] = void 0;
        }
      }
      getEdgeCrossings(n) {
        let r = this.edgesMaybeCrossF >> n & 1,
          s = this.edgesMaybeCrossG >> n & 1;
        if (!r && !s) return o8;
        let i = bm(this.cubeID, n), o = this.edgeCrossings.get(i);
        if (o !== void 0) return o;
        let a = this.getEdgeCrossingsUncached(n, r, s);
        return this.edgeCrossings.set(i, a), a;
      }
      getEdgeCrossingsUncached(n, r, s) {
        let i = zr[n * 2],
          o = zr[n * 2 + 1],
          a = this.cubeVertexValue.getX(i),
          u = this.cubeVertexValue.getY(i),
          c = this.cubeVertexValue.getX(o),
          l = this.cubeVertexValue.getY(o),
          p = this.cubeVertex[i],
          f = this.cubeVertex[o],
          d = !r || a === 0 || c === 0 ? void 0 : xm(this.f, p, f, a, c),
          y = !s || u === 0 || l === 0 ? void 0 : xm(this.g, p, f, u, l),
          g = this.threshF;
        !d && y && Math.abs(a) <= g && Math.abs(c) <= g &&
          Math.abs(this.f(y[0], y[1], y[2])) <= g && (d = y);
        let m = this.threshG;
        return !y && d && Math.abs(u) <= m && Math.abs(l) <= m &&
          Math.abs(this.g(d[0], d[1], d[2])) <= m && (y = d),
          { f: d, g: y };
      }
      getTriangleCrossing(n) {
        let r = wC(this.cubeID, n), s = this.allFGZs.get(r);
        if (s !== void 0) return s;
        let i = this.getTriangleCrossingUncached(n);
        return this.allFGZs.set(r, i), i;
      }
      createFGZ(n, r) {
        let s = this.allFGZs.get(n);
        if (s) return s;
        let i = { id: n, pos: r, connections: [], visited: false };
        return this.allFGZs.set(n, i), i;
      }
      getTriangleCrossingUncached(n) {
        let r = [], s = [], i = LC[n];
        for (let a = 0; a < 3; a++) {
          let u = i[a];
          if (this.vertexFGZs[u]) return null;
          this.vertexZeroF[u] && r.push(this.cubeVertex[u]),
            this.vertexZeroG[u] && s.push(this.cubeVertex[u]);
        }
        let o = _C[n];
        for (let a = 0; a < 3; a++) {
          let u = o[a], c = this.tetEdgeCrossings[u];
          if (this.edgeFGZs[u] || !c) continue;
          let l = c.f, p = c.g, f = zr[2 * u], d = zr[2 * u + 1];
          l && !this.vertexZeroF[f] && !this.vertexZeroF[d] && r.push(l),
            p && !this.vertexZeroG[f] && !this.vertexZeroG[d] && s.push(p);
        }
        if (r.length === 2 && s.length === 2) {
          let a = a8(r[0], r[1], s[0], s[1]);
          return a
            ? {
              id: wC(this.cubeID, n),
              pos: a,
              connections: [],
              visited: false,
            }
            : null;
        } else return null;
      }
      setEdgeCrossings() {
        for (let n = 0; n < 26; n++) {
          let r = this.getEdgeCrossings(n),
            s = r.f,
            i = r.g,
            o = zr[n * 2],
            a = zr[n * 2 + 1];
          if (this.vertexFGZs[o] || this.vertexFGZs[a]) {
            this.tetEdgeCrossings[n] = void 0, this.edgeFGZs[n] = void 0;
          } else if (s && this.vertexZeroG[o] && this.vertexZeroG[a]) {
            let u = this.createFGZ(bm(this.cubeID, n), s);
            this.edgeFGZs[n] = u, this.tetEdgeCrossings[n] = void 0;
          } else if (i && this.vertexZeroF[o] && this.vertexZeroF[a]) {
            let u = this.createFGZ(bm(this.cubeID, n), i);
            this.edgeFGZs[n] = u, this.tetEdgeCrossings[n] = void 0;
          } else if (s && i && qa(s, i) < 1e-8) {
            let u = this.createFGZ(bm(this.cubeID, n), s);
            this.edgeFGZs[n] = u, this.tetEdgeCrossings[n] = void 0;
          } else this.edgeFGZs[n] = void 0, this.tetEdgeCrossings[n] = r;
        }
      }
      insertCurveSegmentsFromCube() {
        for (let n = 0; n < 12; n++) this.insertCurveSegmentsFromTetrahedron(n);
      }
      insertCurveSegmentsFromTetrahedron(n) {
        let r = [], s = PL[n];
        for (let l = 0; l < 4; l++) {
          let p = this.getTriangleCrossing(s[l]);
          p && r.push(p);
        }
        let i = [], o = bb[n];
        for (let l = 0; l < 6; l++) {
          let p = this.edgeFGZs[o[l]];
          p && i.push(p);
        }
        let a = [],
          u = [zr[o[0] * 2], zr[o[0] * 2 + 1], zr[o[3] * 2], zr[o[3] * 2 + 1]];
        for (let l of u) {
          let p = this.vertexFGZs[l];
          p && a.push(p);
        }
        let c = [...a, ...i, ...r];
        switch (c.length) {
          case 0:
          case 1:
            break;
          case 2:
            this.connectCrossings(c[0], c[1]);
            break;
          case 3:
            r.length === 2 && this.connectCrossings(r[0], r[1]);
            break;
          case 4:
            r.length === 4 &&
              (this.connectCrossings(r[0], r[1]),
                this.connectCrossings(r[2], r[3]));
            break;
          default:
            throw new Error("Programming error: 5 is impossible.");
        }
      }
      connectCrossings(n, r) {
        n.connections.some((s) => s.id === r.id) ||
          r.connections.some((s) => s.id === n.id) ||
          n.connections.length >= 2 || r.connections.length >= 2 ||
          (n.connections.push(r), r.connections.push(n));
      }
      traceCurves() {
        let n = {
            xtolerance: this.size.x * .1,
            ytolerance: this.size.y * .1,
            ztolerance: this.size.z * .1,
            map: (s) => s,
          },
          r = new $i(n);
        for (let s of this.allFGZs.values()) {
          s && !s.visited && s.connections.length === 1 &&
            this.traceCurve(r, s);
        }
        for (let s of this.allFGZs.values()) {
          s && !s.visited && this.traceCurve(r, s);
        }
        return r.finish().segments;
      }
      traceCurve(n, r) {
        let s = r;
        for (;;) {
          n.addPoint(r.pos), r.visited = true;
          let i;
          for (let o of r.connections) o.visited || (i = o);
          if (!i) break;
          r = i;
        }
        s.connections.length === 2 && n.addPoint(s.pos), n.breakSegment();
      }
    },
    [Eb, vL, UC] = [new st(), new st(), new st()],
    OL = new st(),
    [qC, $C, NL] = [new st(), new st(), new st()],
    [Mb, RL, Cb] = [new st(), new st(), new st()];
  function a8(e, t, n, r) {
    Eb.set(e[0], e[1], e[2]),
      vL.set(t[0], t[1], t[2]),
      UC.set(n[0], n[1], n[2]),
      OL.set(r[0], r[1], r[2]),
      qC.subVectors(vL, Eb),
      $C.subVectors(OL, UC),
      NL.subVectors(UC, Eb),
      Mb.crossVectors(qC, $C),
      RL.crossVectors(NL, $C);
    let s = Mb.dot(RL) / Mb.dot(Mb);
    return 0 <= s && s <= 1
      ? (Cb.addVectors(Eb, qC.multiply(s)), [Cb.x, Cb.y, Cb.z])
      : null;
  }
  var _L = 80;
  var XC = class extends ld {
    constructor(n, r, s, i, o, a) {
      let u = s.width / 1e8, c = i.width / 1e8;
      super({
        resolution: o,
        uRange: s,
        vRange: i,
        du: u,
        dv: c,
        extraAttrCount: a,
      });
      this.vertices = [];
      this.fn = (n) => {
        let r = this._fn(n),
          s = this.tangentInForced(n, [this.du, 0], r),
          i = this.tangentInForced(n, [0, this.dv], r),
          o = Kl(s, i);
        return { uv: n, f: r, normal: o, dfEast: s, dfNorth: i };
      };
      this._fn = (l) => n(l[0], l[1]),
        this.xmin = r.xmin * 6 - r.xmax * 5,
        this.xmax = r.xmax * 6 - r.xmin * 5,
        this.ymin = r.ymin * 6 - r.ymax * 5,
        this.ymax = r.ymax * 6 - r.ymin * 5,
        this.zmin = r.zmin * 6 - r.zmax * 5,
        this.zmax = r.zmax * 6 - r.zmin * 5,
        this.distThresh = ((r.xmax - r.xmin) * 1e-6) ** 2;
    }
    getVertexCount() {
      return this.vertices.length;
    }
    getUV(n) {
      return this.vertices[n].uv;
    }
    getNormal(n) {
      return this.vertices[n].normal;
    }
    _addVertex(n) {
      return this.vertices.push(n) - 1;
    }
    copyVertex(n) {
      return this.addVertex(this.vertices[n]);
    }
    getF(n) {
      return this.vertices[n].f;
    }
    getDfNorth(n) {
      return this.vertices[n].dfNorth;
    }
    getDfEast(n) {
      return this.vertices[n].dfEast;
    }
    insidePaddedDomain(n) {
      return this.zmin <= n[2] && n[2] <= this.zmax && this.ymin <= n[1] &&
        n[1] <= this.ymax && this.xmin <= n[0] && n[0] <= this.xmax;
    }
    tangentInForced(n, r, s) {
      let i = cf(n, r);
      return YP(this._fn(i), s);
    }
    _isVertexAtCrease(n) {
      let r = this.getUV(n),
        s = this.getDfEast(n),
        i = this.getDfNorth(n),
        o = this.getF(n),
        a = this.tangentInForced(r, [-this.du, 0], o);
      if (XP(a, s) / Math.sqrt(Ql(a) * Ql(s)) > -pd) return true;
      let c = this.tangentInForced(r, [0, -this.dv], o);
      return XP(i, c) / Math.sqrt(Ql(i) * Ql(c)) > -pd;
    }
    hintedNormal(n, r) {
      let s = this.getUV(n),
        i = this.getF(n),
        o = Kl(
          this.tangentInForced(s, r[0], i),
          this.tangentInForced(s, r[1], i),
        );
      return ep(...o) ? o : this.getNormal(n);
    }
    getVertex(n) {
      if (this.allowVertex(n)) return this.getF(n);
    }
    getExtraAttr(n, r) {
      return this.vertices[n].f[3 + r];
    }
    findJumpBetweenTwoSamples(n, r) {
      let s = this.getUV(n),
        i = this.getF(n),
        o = 0,
        a = this.getUV(r),
        u = this.getF(r),
        c = 1,
        l = (d) => this._fn(ar(s, a, d));
      if (
        !isFinite(i[0]) || !isFinite(i[1]) || !isFinite(i[2]) ||
        !isFinite(u[0]) || !isFinite(u[1]) || !isFinite(u[2])
      ) return;
      let f = Wy(o, i, c, u, l, (this.xmax - this.xmin) * 1e-6, 0, 0);
      if (f) {
        return [
          this.fn(ar(s, a, wi(f[0], 0, 1e-5))),
          this.fn(ar(s, a, wi(f[1], 1, 1e-5))),
        ];
      }
    }
    clip(n) {
      return this.insidePaddedDomain(n) ? n : [NaN, NaN, NaN];
    }
    findFiniteBetweenTwoSamples(n, r) {
      let s = this.getUV(n),
        i = this.getF(n),
        o = this.getUV(r),
        a = this.getF(r),
        u = (l) => this.clip(this._fn(ar(s, o, l))),
        c = Zy(0, this.clip(i), 1, this.clip(a), u);
      if (c !== void 0) return this.fn(ar(s, o, c));
    }
    allowVertex(n) {
      return this.insidePaddedDomain(this.getF(n));
    }
    isDegenerate(n, r, s) {
      let i = this.getF(n), o = this.getF(r);
      if (qa(i, o) < this.distThresh) return true;
      let a = this.getF(s);
      return qa(o, a) < this.distThresh || qa(i, a) < this.distThresh;
    }
  };
  function Pm(e, t, n, r, s, i) {
    let o = new XC(e, t, n, r, s, i);
    return cb(o);
  }
  function Em(e, t) {
    let n = {};
    for (let r in t) t.hasOwnProperty(r) && (ws(e[r], t[r]) || (n[r] = t[r]));
    return n;
  }
  function Db(e, t) {
    let n, r = {};
    for (let s in t) {
      t.hasOwnProperty(s) && (ws(e[s], t[s]) || (r[s] = t[s], n = r));
    }
    return n;
  }
  function Jse(e, t) {
    t || (t = {});
    let n = {};
    for (let r in e) {
      e.hasOwnProperty(r) && !t.hasOwnProperty(r) && (n[r] = li(e[r]));
    }
    for (let r in t) t.hasOwnProperty(r) && (n[r] = t[r]);
    return n;
  }
  var u8 =
    ((r) => (r.NONE = "NONE", r.POSITIVE = "POSITIVE", r.BOTH = "BOTH", r))(
      u8 || {},
    );
  function eie(e) {
    switch (e) {
      case "LOOP_FORWARD":
        return "dcg-icon-arrow-one-way";
      case "LOOP_FORWARD_REVERSE":
        return "dcg-icon-arrow-two-way";
      case "PLAY_ONCE":
        return "dcg-icon-arrow-once";
      case "PLAY_INDEFINITELY":
        return "dcg-icon-arrow-infinite";
    }
  }
  function sie({ from: e, to: t, props: n }) {
    for (let r in n) n[r] && e.hasOwnProperty(r) && (t[r] = li(e[r]));
  }
  function iie(e, t) {
    for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
  }
  function wL(e, t) {
    let n = {};
    for (let r in t) t.hasOwnProperty(r) && (n[r] = e[r]);
    return n;
  }
  function oie(e) {
    let t = {};
    for (let n in e) e.hasOwnProperty(n) && (t[n] = true);
    return t;
  }
  var FL = {
    collapsed: false,
    hidden: false,
    secret: false,
    inFrontOfEverything: false,
    readonly: false,
    title: "",
  };
  function uie(e) {
    return { ...FL, ...e };
  }
  function cie(e) {
    return Em(FL, e);
  }
  var VL = "**dcg_geo_folder**";
  var ZC = { show: false, min: "", max: "" },
    WC = {
      breadth: "",
      axisOffset: "",
      alignedAxis: "x",
      showBoxplotOutliers: true,
      binAlignment: "center",
      dotplotXMode: "exact",
      histogramMode: "",
    },
    jC = { enabled: false, latex: "" };
  var kL = 4e3,
    Sb = {
      polarDomain: { min: "", max: "" },
      parametricDomain: { min: "", max: "" },
      parametricDomain3Du: { min: "", max: "" },
      parametricDomain3Dv: { min: "", max: "" },
      parametricDomain3Dr: { min: "", max: "" },
      parametricDomain3Dphi: { min: "", max: "" },
      cdf: ZC,
      colorLatex: "",
      description: "",
      fillOpacity: "",
      surfaceOpacity: "",
      lineOpacity: "",
      pointOpacity: "",
      pointSize: "",
      movablePointSize: "",
      lineWidth: "",
      resolution: "",
      labelAngle: "",
      vizProps: WC,
      clickableInfo: jC,
    },
    HL = {
      folderId: "",
      latex: "",
      color: "",
      showLabel: false,
      showAngleLabel: true,
      label: "",
      hidden: false,
      secret: false,
      readonly: false,
      disableGraphInteractions: false,
      dragMode: "AUTO",
      labelSize: "",
      labelOrientation: "default",
      suppressTextOutline: false,
      interactiveLabel: false,
      editableLabelMode: "NONE",
      residualVariable: "",
      isLogModeRegression: false,
      pointStyle: "POINT",
      lineStyle: "SOLID",
      arrowMode: "DEFAULT",
      regressionParameters: {},
      displayEvaluationAsFraction: false,
      slider: {},
      strictIntersection: false,
      extendTo3D: false,
      ...Sb,
      points: void 0,
      lines: void 0,
      fill: void 0,
    },
    zL = {
      hardMin: false,
      hardMax: false,
      animationPeriod: kL,
      loopMode: "LOOP_FORWARD_REVERSE",
      playDirection: 1,
      isPlaying: false,
      min: "-10",
      max: "10",
      step: "",
    },
    UL = {
      hardMin: false,
      hardMax: false,
      animationPeriod: kL,
      loopMode: "LOOP_FORWARD_REVERSE",
      playDirection: 1,
      isPlaying: false,
      min: `${Dr.xmin}`,
      max: `${Dr.xmax}`,
      step: "",
    };
  function Pie(e, t) {
    return {
      ...HL,
      isLogModeRegression: t.defaultLogModeRegressions,
      ...e,
      slider: { ...t.is3d ? UL : zL, ...e.slider },
      cdf: { ...ZC, ...e.cdf },
      vizProps: { ...WC, ...e.vizProps },
      clickableInfo: { ...jC, ...e.clickableInfo },
    };
  }
  function Eie(e, t) {
    let n = Em(HL, { ...e, slider: Em(t.is3d ? UL : zL, e.slider) }),
      r = Db(ZC, e.cdf);
    r === void 0 ? delete n.cdf : n.cdf = r;
    let s = Db(WC, e.vizProps);
    s === void 0 ? delete n.vizProps : n.vizProps = s;
    let i = Db(jC, e.clickableInfo);
    return i === void 0 ? delete n.clickableInfo : n.clickableInfo = i, n;
  }
  function c8(e) {
    return wL(e, Sb);
  }
  function Mie(e, t) {
    for (let n in Sb) if (Sb.hasOwnProperty(n) && e[n] !== t[n]) return false;
    return true;
  }
  function Cie(e) {
    return {
      type: "statement",
      id: e.id,
      latex: e.latex,
      label: e.label,
      color: e.color,
      fill: e.fill,
      points: e.points,
      lines: e.lines,
      extendTo3D: e.extendTo3D,
      pointStyle: e.pointStyle,
      lineStyle: e.lineStyle,
      arrowMode: e.arrowMode,
      dragMode: e.dragMode,
      labelSize: e.labelSize,
      labelOrientation: e.labelOrientation,
      suppressTextOutline: e.suppressTextOutline,
      interactiveLabel: e.interactiveLabel,
      editableLabelMode: e.editableLabelMode,
      residualVariable: e.residualVariable,
      regressionParameters: e.regressionParameters,
      isLogModeRegression: e.isLogModeRegression,
      showLabel: e.showLabel,
      showAngleLabel: e.showAngleLabel,
      shouldGraph: !e.hidden,
      slider: {
        min: e.slider.hardMin ? e.slider.min : "",
        max: e.slider.hardMax ? e.slider.max : "",
        softMin: e.slider.hardMin ? "" : e.slider.min,
        softMax: e.slider.hardMax ? "" : e.slider.max,
        step: e.slider.step,
        isPlayingOnce: e.slider.isPlaying && e.slider.loopMode === "PLAY_ONCE",
      },
      strictIntersection: e.strictIntersection,
      isInConstructionsFolder: e.folderId === VL,
      ...c8(e),
    };
  }
  var y8 = {};
  ia(y8, {
    LinearToSRGB: () => f8,
    SRGBToLinear: () => vb,
    colorString: () => qL,
    colors: () => Cl,
    colors3d: () => m8,
    convertColorStringToLinearRGB: () => QC,
    getDisplayColor: () => Ra,
    invertColor: () => p8,
    isValidHexColor: () => Ob,
    mutateOpacity: () => d8,
    normalizeColor: () => JC,
    parseHex: () => $L,
    shadeColor: () => l8,
  });
  function JC(e) {
    return Ob(e)
      ? (e.match(/^#([A-Fa-f0-9]{3})$/g) &&
        (e = "#" + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]),
        e.toLowerCase())
      : e;
  }
  function Ob(e) {
    return typeof e == "string" &&
      (e.match(/^#([A-Fa-f0-9]{3})$/g) || e.match(/^#([A-Fa-f0-9]{6})$/g));
  }
  function l8(e, t) {
    if (e = JC(e), !Ob(e)) return e;
    t > 1 && (t = 1), t < -1 && (t = -1);
    let n = parseInt(e.slice(1), 16),
      r = t < 0 ? 0 : 255,
      s = t < 0 ? t * -1 : t,
      i = n >> 16,
      o = n >> 8 & 255,
      a = n & 255;
    return qL(
      Math.round((r - i) * s) + i,
      Math.round((r - o) * s) + o,
      Math.round((r - a) * s) + a,
    );
  }
  function qL(e, t, n) {
    return "#" +
      (16777216 + Math.round(e) * 65536 + Math.round(t) * 256 + Math.round(n))
        .toString(16).slice(1);
  }
  function p8(e) {
    if (e = JC(e), !Ob(e)) return e;
    let t = "0123456789abcdef";
    return "#" + e.slice(1).split("").map((n) => t[15 - t.indexOf(n)]).join("");
  }
  function $L(e) {
    e = e.replace(/#/, "");
    let t, n, r;
    return e.length === 3
      ? (t = parseInt(e.slice(0, 1) + e.slice(0, 1), 16),
        n = parseInt(e.slice(1, 2) + e.slice(1, 2), 16),
        r = parseInt(e.slice(2, 3) + e.slice(2, 3), 16))
      : e.length === 6
      ? (t = parseInt(e.slice(0, 2), 16),
        n = parseInt(e.slice(2, 4), 16),
        r = parseInt(e.slice(4, 6), 16))
      : (t = 0, n = 0, r = 0),
      { r: t, g: n, b: r };
  }
  function d8(e, t) {
    let n = /(rgba\([\d]+\,\ ?[\d]+\,\ ?[\d]+\,\ ?)[\d.]+(\))/;
    return e.match(n) ? e.replace(n, `$1${t}$2`) : e;
  }
  function Ra(e, t) {
    if (t && t.colorLatexValue) {
      let n = t.colorLatexValue;
      return Array.isArray(n) ? n[0] : n;
    }
    return e.color;
  }
  function vb(e) {
    return e < .04045
      ? e * .0773993808
      : Math.pow(e * .9478672986 + .0521327014, 2.4);
  }
  function f8(e) {
    return e < .0031308 ? e * 12.92 : 1.055 * Math.pow(e, .41666) - .055;
  }
  function QC(e) {
    let t = $L(e);
    return [vb(t.r / 255), vb(t.g / 255), vb(t.b / 255)];
  }
  var Cl = {
      RED: "#c74440",
      BLUE: "#2d70b3",
      GREEN: "#388c46",
      PURPLE: "#6042a6",
      ORANGE: "#fa7e19",
      BLACK: "#000000",
      GRAY: "#aaaaaa",
      FOCUS_OUTLINE: "#6a93d2",
    },
    m8 = {
      RED: Cl.RED,
      BLUE: Cl.BLUE,
      GREEN: Cl.GREEN,
      ORANGE: Cl.ORANGE,
      PURPLE: Cl.PURPLE,
      GRAY: Cl.GRAY,
    };
  var g8 = (e, t) => {
    let n = e.segments[0], r = t.segments[0], s = [[...n, ...r]];
    return { ...e, segments: s };
  };
  function h8(e) {
    let { viewState: t, graphInfo: n, compiled: r, derivative: s, bounds: i } =
        e,
      o = li(n),
      a = Gn(n.domainBound, bi(i));
    if (!Fs(a)) {
      return o.domainBound = a,
        o.lineStyle = "SOLID",
        cu({ graphInfo: o, viewState: t, compiled: r, derivative: s });
    }
  }
  function ic(e) {
    let {
        viewState: t,
        graphInfo: n,
        compiled: r,
        bounds: s,
        included: i,
        showPoint: o,
      } = e,
      a = li(n),
      u = Gn(n.domainBound, bi(s));
    if (!Fs(u)) {
      return a.domainBound = u,
        a.pointStyle = i ? "POINT" : "OPEN",
        Nb({
          graphInfo: a,
          viewState: t,
          compiled: r,
          showPoint: o,
          maxOverride: void 0,
        });
    }
  }
  function YL(e) {
    let {
        viewState: t,
        graphInfo: n,
        compiled: r,
        bounds: s,
        maxOverride: i,
        showPoint: o,
      } = e,
      [a, u] = s,
      c = [],
      l;
    a = Math.ceil(a), u = Math.floor(u);
    let p = i !== void 0 ? i : 1 / 0;
    if (a === -1 / 0 && u >= p) {
      l = ic({
        bounds: [a, p],
        included: true,
        viewState: t,
        graphInfo: n,
        compiled: r,
        showPoint: o,
      }), c.push(l);
    } else if (a === -1 / 0 && u < 1 / 0) {
      l = ic({
        bounds: [a, u],
        included: true,
        viewState: t,
        graphInfo: n,
        compiled: r,
        showPoint: o,
      }),
        c.push(l),
        c.push(
          ic({
            bounds: [u + 1, p],
            included: false,
            viewState: t,
            graphInfo: n,
            compiled: r,
            showPoint: o,
          }),
        );
    } else if (a > -1 / 0 && u >= p) {
      l = ic({
        bounds: [a, p],
        included: true,
        viewState: t,
        graphInfo: n,
        compiled: r,
        showPoint: o,
      }),
        c.push(
          ic({
            bounds: [-1 / 0, a - 1],
            included: false,
            viewState: t,
            graphInfo: n,
            compiled: r,
            showPoint: o,
          }),
        ),
        c.push(l);
    } else {
      l = ic({
        bounds: [a, u],
        included: true,
        viewState: t,
        graphInfo: n,
        compiled: r,
        showPoint: o,
      });
      let f = ic({
          bounds: [-1 / 0, a - 1],
          included: false,
          viewState: t,
          graphInfo: n,
          compiled: r,
          showPoint: o,
        }),
        d = ic({
          bounds: [u + 1, p],
          included: false,
          viewState: t,
          graphInfo: n,
          compiled: r,
          showPoint: o,
        });
      c.push(l);
      let y;
      f && d && (y = g8(f, d), c.push(y));
    }
    return { cdfTopBranch: l, topBranches: c };
  }
  var XL = (e) => {
    let { viewState: t, graphInfo: n, compiled: r, derivative: s, bounds: i } =
        e,
      [o, a] = i,
      u = h8({
        bounds: [o, a],
        viewState: t,
        graphInfo: n,
        compiled: r,
        derivative: s,
      }),
      c = [cu({ viewState: t, graphInfo: n, compiled: r, derivative: s })];
    return { cdfTopBranch: u, topBranches: c };
  };
  var Mm = class {
      constructor(t) {
        this.parentType = t;
        this.count = 0;
        this.intersections = [];
      }
      addPoint(t) {
        this.intersections.push(t), this.count += 1;
      }
      addPoints(t) {
        this.intersections.push(...t), this.count += t.length;
      }
      addIntersection(t, n) {
        n.valueType === Point
          ? this.addPoint(n.value)
          : this.addPoints(n.value);
      }
      getPoints() {
        return this.intersections;
      }
    },
    gd = class {
      constructor(t) {
        this.parentType = t;
        this.count = 0;
        this.intersectionsByIndex = new Map();
        if (t === ListOfSegment) this.scalarType = Segment;
        else if (t === ListOfRay) this.scalarType = Ray;
        else if (t === ListOfArc) this.scalarType = Arc;
        else {throw new Error(
            `Expected ListOfSegment or ListOfArc but got ${at(t)}`,
          );}
      }
      getListItemIntersections(t) {
        let n = this.intersectionsByIndex.get(t);
        return n ||
          (n = new Mm(this.scalarType), this.intersectionsByIndex.set(t, n)),
          n;
      }
      addIntersection(t, n) {
        let r = zo(t);
        if (r !== void 0) {
          let s = r - 1, i = this.getListItemIntersections(s);
          n.valueType === ListOfPoint
            ? i.addPoints(n.value)
            : i.addPoint(n.value), this.count += 1;
        } else {
          za(n.valueType, [ListOfPoint]);
          for (let s = 0; s < n.value.length; s++) {
            this.getListItemIntersections(s).addPoint(n.value[s]);
          }
          this.count += n.value.length;
        }
      }
    },
    KC = class {
      constructor() {
        this.parentType = Polygon;
        this.count = 0;
        this.intersectionsByEdgeIndex = new Map();
      }
      getEdgeIntersections(t) {
        let n = this.intersectionsByEdgeIndex.get(t);
        return n ||
          (n = new Mm(Segment), this.intersectionsByEdgeIndex.set(t, n)),
          n;
      }
      addPoint(t, n) {
        this.getEdgeIntersections(t).addPoint(n), this.count += 1;
      }
      addIntersection(t, n) {
        if (t.type !== "polygon-edge") {
          throw new Error(
            `Expected a polygon edge parent ref type but got ${t.type}`,
          );
        }
        let r = t.edgeIndex - 1, s = this.getEdgeIntersections(r);
        n.valueType === ListOfPoint
          ? (s.addPoints(n.value), this.count += n.value.length)
          : (s.addPoint(n.value), this.count += 1);
      }
    },
    e1 = class {
      constructor() {
        this.parentType = ListOfPolygon;
        this.count = 0;
        this.intersectionsByEdgeIndex = new Map();
      }
      getEdgeIntersections(t) {
        let n = this.intersectionsByEdgeIndex.get(t);
        return n ||
          (n = new gd(ListOfSegment), this.intersectionsByEdgeIndex.set(t, n)),
          n;
      }
      addIntersection(t, n) {
        if (t.type !== "polygon-edge") {
          throw new Error(
            `Expected a polygon edge parent ref type but got ${t.type}`,
          );
        }
        let r = t.edgeIndex - 1, s = this.getEdgeIntersections(r), i = zo(t);
        if (i !== void 0) {
          let o = i - 1;
          n.valueType === ListOfPoint
            ? s.getListItemIntersections(o).addPoints(n.value)
            : s.getListItemIntersections(o).addPoint(n.value), this.count += 1;
        } else {
          za(n.valueType, [ListOfPoint]);
          for (let o = 0; o < n.value.length; o++) {
            s.getListItemIntersections(o).addPoint(n.value[o]);
          }
          this.count += n.value.length;
        }
      }
    },
    hd = class {
      constructor() {
        this.data = {};
      }
      getChildIntersections(t) {
        return this.data[t];
      }
      addChildIntersection(t, n) {
        za(n == null ? void 0 : n.valueType, [Point, ListOfPoint]);
        let r;
        if (t.valueType == ListOfPolygon) r = this.data[t.id] || new e1();
        else if (
          t.valueType === ListOfSegment || t.valueType === ListOfRay ||
          t.valueType === ListOfArc
        ) r = this.data[t.id] || new gd(t.valueType);
        else if (t.valueType === Polygon) r = this.data[t.id] || new KC();
        else if (
          t.valueType === Segment || t.valueType === Ray || t.valueType === Arc
        ) r = this.data[t.id] || new Mm(t.valueType);
        else return;
        this.data[t.id] = r, r.addIntersection(t.ref, n);
      }
      static compareIntersectionCounts(
        { prevChildIntersections: t, nextChildIntersections: n },
      ) {
        var i, o;
        let r = {},
          s = new Set([...Object.keys(t.data), ...Object.keys(n.data)]);
        for (let a of s) {
          let u = ((i = t.data[a]) == null ? void 0 : i.count) || 0,
            c = ((o = n.data[a]) == null ? void 0 : o.count) || 0;
          r[a] = { prev: u, next: c };
        }
        return r;
      }
    };
  function Aie(e) {
    return 2 * b8(e * .5);
  }
  function b8(e) {
    return e <= 8 ? 3 * e : e >= 16 ? 2 * e : e + 16;
  }
  function JL(e = void 0) {
    let { xmin: t, xmax: n, ymin: r, ymax: s, zmin: i, zmax: o } = e != null
        ? e
        : new Ab(),
      a = [
        t,
        r,
        o,
        t,
        s,
        o,
        n,
        s,
        o,
        n,
        r,
        o,
        t,
        r,
        i,
        t,
        s,
        i,
        n,
        s,
        i,
        n,
        r,
        i,
        t,
        r,
        i,
        t,
        r,
        o,
        t,
        s,
        o,
        t,
        s,
        i,
        n,
        r,
        i,
        n,
        r,
        o,
        n,
        s,
        o,
        n,
        s,
        i,
        n,
        r,
        i,
        n,
        r,
        o,
        t,
        r,
        o,
        t,
        r,
        i,
        n,
        s,
        i,
        n,
        s,
        o,
        t,
        s,
        o,
        t,
        s,
        i,
      ],
      u = [
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
      ],
      c = [
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0,
        1,
        0,
        1,
      ],
      l = [
        0,
        1,
        2,
        0,
        2,
        3,
        4,
        5,
        6,
        4,
        6,
        7,
        8,
        9,
        10,
        8,
        10,
        11,
        12,
        13,
        14,
        12,
        14,
        15,
        16,
        17,
        18,
        16,
        18,
        19,
        20,
        21,
        22,
        20,
        22,
        23,
      ];
    return {
      positions: new Float32Array(a),
      normals: new Float32Array(u),
      faces: new Uint16Array(l),
      uvs: new Float32Array(c),
    };
  }
  var { abs: oc, min: t1, max: n1 } = Math;
  function r1(e, t) {
    let { xmin: n, xmax: r, ymin: s, ymax: i, zmin: o, zmax: a } = t,
      u = [[n, s, a], [n, i, a], [r, i, a], [r, s, a], [n, s, o], [n, i, o], [
        r,
        i,
        o,
      ], [r, s, o]],
      c = [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 0],
        [4, 5],
        [5, 6],
        [6, 7],
        [7, 4],
        [0, 4],
        [1, 5],
        [2, 6],
        [3, 7],
      ],
      l = [];
    for (let [S, O] of c) {
      let _ = u[S], L = u[O], w = e(..._), G = e(...L), k = w / (w - G);
      0 <= k && k <= 1 && l.push(Fi(_, L, k));
    }
    if (l.length < 3) return;
    let p = t1(...l.map((S) => S[0])),
      f = n1(...l.map((S) => S[0])),
      d = t1(...l.map((S) => S[1])),
      y = n1(...l.map((S) => S[1])),
      g = t1(...l.map((S) => S[2])),
      m = n1(...l.map((S) => S[2])),
      h = e(n, s, o),
      x = (e(r, s, o) - h) / (r - n),
      T = (e(n, i, o) - h) / (i - s),
      b = (e(n, s, a) - h) / (a - o),
      M,
      P,
      D;
    return oc(b) >= oc(x) && oc(b) >= oc(T)
      ? (M = (S, O) => [S, O, o - (h + x * (S - n) + T * (O - s)) / b],
        P = new qe(p, f),
        D = new qe(d, y))
      : oc(T) >= oc(b) && oc(T) >= oc(x)
      ? (M = (S, O) => [S, s - (h + x * (S - n) + b * (O - o)) / T, O],
        P = new qe(p, f),
        D = new qe(g, m))
      : (M = (S, O) => [n - (h + T * (S - s) + b * (O - o)) / x, S, O],
        P = new qe(d, y),
        D = new qe(g, m)),
      { explicitPlane: M, u: P, v: D };
  }
  function _b(e, t) {
    let n = [], r = [], s = [], i = [], o = r1(e, t);
    if (o) {
      let { explicitPlane: a, u, v: c } = o;
      n.push(
        ...a(u.min, c.min),
        ...a(u.max, c.min),
        ...a(u.min, c.max),
        ...a(u.max, c.max),
      );
      let l = new st(n[0], n[1], n[2]),
        p = new st(n[3], n[4], n[5]),
        f = new st(n[6], n[7], n[8]),
        d = new st().subVectors(f, l),
        y = new st().subVectors(l, p),
        g = d.cross(y).normalize();
      r.push(g.x, g.y, g.z, g.x, g.y, g.z, g.x, g.y, g.z, g.x, g.y, g.z),
        s.push(0, 0, 0, 1, 1, 0, 1, 1),
        i.push(0, 1, 2, 3, 2, 1);
    }
    return {
      positions: n,
      normals: r,
      faces: i,
      uvs: s,
      resolved: true,
      extraAttrs: [],
    };
  }
  function s1(e, t) {
    let n;
    switch (t) {
      case "solvedEquation":
        n = 2;
        break;
      case "baseComparator":
        n = 4;
        break;
      default:
        n = 1;
        break;
    }
    return Math.floor(e / n);
  }
  var T8 = false, ac = 200, Fb = C.List;
  function Ir() {
    return {};
  }
  function Dl(e, t, n) {
    let r = 1 / 0;
    for (let i of t) {
      let o = e[i];
      Array.isArray(o) && o.length < r && (r = o.length);
    }
    let s = 1;
    return n === "solvedEquation" ? s = 2 : n === "baseComparator" && (s = 4),
      s * r;
  }
  function Aa(e, t, n) {
    return Array.isArray(e) ? e[s1(t, n)] : e;
  }
  function I8(e, t) {
    let n = t.viewport.xmax - t.viewport.xmin,
      r = t.viewport.ymax - t.viewport.ymin,
      s = MathHypot(n, r),
      i = MathHypot(30, 30),
      o = Math.round(2 - Math.log(s / i) / Math.LN10);
    if (o <= 0) return Math.round(e) + "";
    {
      let a = Math.pow(10, o);
      return Math.round(e * a) / a + "";
    }
  }
  function P8(e, t) {
    let n = t.viewport.xmax - t.viewport.xmin,
      r = t.viewport.ymax - t.viewport.ymin,
      s = n * r,
      i = 30 * 30,
      o = Math.round(2 - Math.log(s / i) / Math.LN10);
    if (o <= 0) return Math.round(e) + "";
    {
      let a = Math.pow(10, o);
      return Math.round(e * a) / a + "";
    }
  }
  function E8(e, t) {
    return t.degreeMode
      ? Math.round(e / (Math.PI / 180) * 10) / 10 + "\xB0"
      : Math.round(e * 100) / 100 + "";
  }
  function uc(e, t, n) {
    let r = s1(t, n),
      s = e.userData.lineStyle,
      i = Aa(e.metaData.computedLineWidth, t, n),
      o = Aa(e.metaData.computedLineOpacity, t, n),
      a = Aa(e.metaData.computedFillOpacity, t, n),
      u = Aa(e.metaData.computedSurfaceOpacity, t, n),
      c = e.metaData.colorLatexValue
        ? Aa(e.metaData.colorLatexValue, t, n)
        : e.userData.color,
      l = Aa(e.metaData.computedResolution, t, n);
    return {
      listIndex: r,
      style: s,
      lineWidth: i,
      lineOpacity: o,
      fillOpacity: a,
      surfaceOpacity: u,
      color: c,
      resolution: l,
    };
  }
  C.Base.prototype._graph = M8;
  function M8(e, t, n, r, s, i) {
    var d, y, g;
    if (t instanceof C.SolvedEquation) {
      let m = this._graph(
          e,
          t._expression,
          n,
          r,
          s,
          t.branchMultiplier === 2 ? "solvedEquation" : void 0,
        ),
        h = uw(this, t, n, e);
      return h && (m || (m = []), Array.prototype.push.apply(m, h)), m;
    }
    function o(m) {
      let h = m.editableLabelMode;
      return h === "TEXT" || h === "MATH";
    }
    function a(m, h) {
      return "colorLatex" in m && A8(m.colorLatex) ? m.colorLatex : h;
    }
    let u = t.getExpressionType(r.graphMode, t.valueType),
      c = eC(u, {
        points: this.userData.points,
        lines: this.userData.lines,
        fill: this.userData.fill,
      }),
      l = {
        lineOpacity: "computedLineOpacity",
        lineWidth: "computedLineWidth",
        color: "colorLatexValue",
        fillOpacity: "fillOpacity",
        surfaceOpacity: "surfaceOpacity",
        resolution: "resolution",
      },
      p = (m, h) => {
        let x = Dl(this.metaData, Object.keys(m).map((b) => l[b]), i), T = [];
        return Fb.wrap(t).eachElement((b, M) => {
          if (M >= x) return;
          let P = this.getGraphInfo(e, b);
          P.graphMode = r.graphMode;
          let D = uc(this, M, i);
          P.listIndex = D.listIndex,
            P.style = D.style,
            "lineWidth" in m && (P.lineWidth = D.lineWidth),
            "lineOpacity" in m && (P.lineOpacity = D.lineOpacity),
            "fillOpacity" in m && (P.fillOpacity = D.fillOpacity),
            "surfaceOpacity" in m && (P.surfaceOpacity = D.surfaceOpacity),
            "color" in m && (P.color = a(this.userData, D.color)),
            "resolution" in m && (P.resolution = D.resolution),
            T.push(...h(b, P));
        }),
          T;
      },
      f = r.graphMode;
    switch (f) {
      case 26:
      case 4: {
        let { points: x, droppedIndices: T } = Cm([t.asValue()]),
          b = this.userData.shouldGraph && c.points,
          M = this.userData.showLabel && !b;
        if (b) {
          return [{
            segments: [x],
            graphMode: f,
            droppedIndices: T,
            color: Ra(this.userData, this.metaData),
            style: this.userData.pointStyle,
            showLabel: !!this.userData.showLabel,
            labelSize: this.metaData.computedLabelSize,
            labelAngle: this.metaData.computedLabelAngle,
            labelOrientation: this.userData.labelOrientation,
            pointOpacity: this.metaData.computedPointOpacity,
            pointSize: this.metaData.computedMovablePointSize,
            suppressTextOutline: this.userData.suppressTextOutline,
            editableLabel: o(this.userData),
            labels: this.computedLabels || [],
            poi: go(x),
            movablePointInfo: [],
          }];
        }
        if (M) {
          let P;
          switch (f) {
            case 4:
              P = 3;
              break;
            case 26:
              P = 25;
              break;
            default:
              let D = f;
              throw new Error(`Unexpected graphMode: ${D}`);
          }
          return [{
            segments: [x],
            graphMode: P,
            color: Ra(this.userData, this.metaData),
            style: this.userData.pointStyle,
            showLabel: !!this.userData.showLabel,
            nakedLabel: true,
            labelSize: this.metaData.computedLabelSize,
            labelAngle: this.metaData.computedLabelAngle,
            labelOrientation: this.userData.labelOrientation,
            pointOpacity: this.metaData.computedPointOpacity,
            suppressTextOutline: this.userData.suppressTextOutline,
            editableLabel: o(this.userData),
            labels: this.computedLabels || [],
            poi: go(x),
            showPoint: false,
          }];
        } else return [];
      }
      case 25:
      case 3: {
        let x = [],
          T = this.userData.shouldGraph && c.points,
          b = this.userData.shouldGraph && c.lines,
          M = ["colorLatexValue"];
        T && M.push("computedPointOpacity", "computedPointSize"),
          (this.userData.showLabel || T) &&
          M.push("computedLabelSize", "computedLabelAngle");
        let P = Dl(this.metaData, M, i), D = Fb.wrap(t).asValue();
        ms(D), D.length > P && (D.length = P);
        let S = this.userData.showLabel && !T && !b, O = Cm(D);
        if (this.userData.showLabel || T) {
          let _ = {
            segments: [O.points],
            graphMode: f,
            droppedIndices: O.droppedIndices,
            color: this.metaData.colorLatexValue || this.userData.color,
            style: this.userData.pointStyle,
            showLabel: !!this.userData.showLabel,
            showPoint: T,
            labelSize: this.metaData.computedLabelSize,
            labelAngle: this.metaData.computedLabelAngle,
            labelOrientation: this.userData.labelOrientation,
            pointSize: this.metaData.computedPointSize,
            pointOpacity: this.metaData.computedPointOpacity,
            suppressTextOutline: this.userData.suppressTextOutline,
            interactiveLabel: !!this.userData.interactiveLabel,
            editableLabel: o(this.userData),
            nakedLabel: S,
            labels: this.computedLabels || [],
            poi: go(D),
          };
          e.is3dPolicy() ? x.push(...O8(_)) : x.push(_);
        }
        if (b) {
          let _ = this.metaData.computedLineWidth,
            L = {
              segments: rw(D),
              graphMode: 5,
              color: Ra(this.userData, this.metaData),
              style: this.userData.lineStyle,
              lineWidth: _,
              lineOpacity: this.metaData.computedLineOpacity,
              poi: Ir(),
            };
          x.push(KL(e, L, n, _));
        }
        return x;
      }
      case 114: {
        let x = [],
          T = this.userData.shouldGraph && c.points,
          b = this.userData.shouldGraph && c.lines,
          M = ["colorLatexValue"];
        T && M.push("computedPointOpacity", "computedPointSize");
        let P = Fb.wrap(t).asValue();
        ms(P);
        let D = Dl(this.metaData, M, i), S = Math.min(P.length, D);
        if (T) {
          for (let O = 0; O < S; O++) {
            let { color: _ } = uc(this, O, i),
              L = Aa(this.metaData.computedPointSize, O, i);
            x.push({
              graphMode: 114,
              position: P[O],
              radius: .02 * L,
              guid: Ns(),
              color: _,
            });
          }
        }
        if (b) {
          let O = Aa(this.metaData.computedLineWidth, 0, i),
            { color: _ } = uc(this, 0, i);
          x.push({
            graphMode: 100,
            points: Dm(P, n.viewport, O),
            thickness: O,
            guid: Ns(),
            color: _,
          });
        }
        return x;
      }
      case 117: {
        let x = this.metaData.colorLatexValue
            ? !Array.isArray(this.metaData.colorLatexValue)
            : true,
          T = this.metaData.computedSurfaceOpacity,
          b = [],
          M = [],
          P = [],
          D = [],
          S = [],
          [O, _, L] = [new st(), new st(), new st()],
          [w, G, k] = [new st(), new st(), new st()],
          Z = (Y, re, Ee, he, K, Oe, te, Ze, dt) => {
            if (
              w.set(Y, re, Ee),
                G.set(he, K, Oe),
                k.set(te, Ze, dt),
                !w.isFinite() || !G.isFinite() || !k.isFinite()
            ) return;
            let me = b.length / 3;
            b.push(w.x, w.y, w.z, G.x, G.y, G.z, k.x, k.y, k.z),
              O.subVectors(w, k),
              _.subVectors(G, w),
              L.crossVectors(O, _),
              M.push(L.x, L.y, L.z, L.x, L.y, L.z, L.x, L.y, L.z),
              P.push(me, me + 1, me + 2),
              D.push(0, 0, 0, 1, 1, 0);
          },
          F = () => {
            let Y = {
              guid: Ns(),
              resolved: true,
              positions: new Float32Array(b),
              normals: new Float32Array(M),
              faces: new Uint32Array(P),
              uvs: new Float32Array(D),
              extraAttrs: new Float32Array([]),
            };
            return S.length && (Y.colors = new Float32Array(S)), Y;
          };
        if (t.valueType === ListOfTriangle3D && !Array.isArray(T)) {
          let Y = this.metaData.computedSurfaceOpacity, re = "";
          if (x) {
            let Ee = (d = this.metaData.colorLatexValue) != null
              ? d
              : this.userData.color;
            re = a(this.userData, Ee);
          }
          return p({ color: true }, (Ee, he) => {
            if (Ee.valueType === Triangle3D) {
              let [[K, Oe, te], [Ze, dt, me], [J, W, Ge]] = Ee.asValue();
              if (Z(K, Oe, te, Ze, dt, me, J, W, Ge), !x) {
                let [be, ue, _e] = QC(he.color);
                S.push(be, ue, _e, be, ue, _e, be, ue, _e);
              }
            }
            return [];
          }),
            [{
              meshData: F(),
              color: re,
              surfaceOpacity: Y != null ? Y : 1,
              graphMode: 117,
            }];
        }
        return p({ color: true, surfaceOpacity: true }, (Y, re) => {
          var W;
          let [[Ee, he, K], [Oe, te, Ze], [dt, me, J]] = Y.asValue();
          return b = [],
            M = [],
            P = [],
            D = [],
            Z(Ee, he, K, Oe, te, Ze, dt, me, J),
            [{
              meshData: F(),
              color: a(this.userData, re.color),
              surfaceOpacity: (W = re.surfaceOpacity) != null ? W : 1,
              graphMode: 117,
            }];
        });
      }
      case 119: {
        let x = this.metaData.colorLatexValue
          ? !Array.isArray(this.metaData.colorLatexValue)
          : true;
        if (
          t.valueType === ListOfSegment3D && x &&
          !Array.isArray(this.metaData.computedLineWidth)
        ) {
          let T = (y = this.metaData.colorLatexValue) != null
              ? y
              : this.userData.color,
            b = this.metaData.computedLineWidth,
            M = [];
          return p({ color: true }, (P) => {
            if (P.valueType === Segment3D) {
              let [[D, S, O], [_, L, w]] = P.asValue();
              M.push(D, S, O, _, L, w, NaN, NaN, NaN);
            }
            return [];
          }),
            [{
              graphMode: 119,
              guid: Ns(),
              points: M,
              color: T,
              thickness: b != null ? b : 1,
            }];
        }
        return p({ color: true, lineWidth: true }, (T, b) => {
          let { lineWidth: M, color: P } = b,
            D = T.asValue(),
            [[S, O, _], [L, w, G]] = D;
          return sw(S, O, _, L, w, G) ? [] : [{
            graphMode: 119,
            guid: Ns(),
            points: [S, O, _, L, w, G],
            color: P,
            thickness: M,
          }];
        });
      }
      case 129:
        let m = this.metaData.colorLatexValue
          ? !Array.isArray(this.metaData.colorLatexValue)
          : true;
        if (
          t.valueType === ListOfVector3D && m &&
          !Array.isArray(this.metaData.computedLineWidth)
        ) {
          let x = (g = this.metaData.colorLatexValue) != null
              ? g
              : this.userData.color,
            T = this.metaData.computedLineWidth,
            b = [];
          return p({ color: true }, (M) => {
            if (M.valueType === Vector3D) {
              let [[P, D, S], [O, _, L]] = M.asValue();
              b.push(O, _, L, P + O, D + _, S + L);
            }
            return [];
          }),
            [{
              graphMode: 129,
              guid: Ns(),
              points: b,
              color: x,
              thickness: T != null ? T : 1,
            }];
        }
        return p({ color: true, lineWidth: true }, (x, T) => {
          let { lineWidth: b, color: M } = T,
            P = x.asValue(),
            [[D, S, O], [_, L, w]] = P;
          return sw(D, S, O, _, L, w) ? [] : [{
            graphMode: 129,
            guid: Ns(),
            points: [_, L, w, D + _, S + L, O + w],
            color: M,
            thickness: b,
          }];
        });
      case 118:
        return p(
          { color: true, resolution: true, surfaceOpacity: true },
          (x, T) => {
            let { color: b, surfaceOpacity: M } = T,
              P = x.asValue(),
              [[D, S, O], _] = P,
              L = Math.abs(_);
            return isNaN(D) || isNaN(S) || isNaN(O) || isNaN(_) ? [] : [{
              graphMode: 118,
              position: [D, S, O],
              radius: [L, L, L],
              guid: Ns(),
              color: b,
              surfaceOpacity: M != null ? M : 1,
            }];
          },
        );
      case 5:
      case 100: {
        let x = this.userData,
          T = this.metaData,
          b = [],
          M = p(
            {
              color: true,
              lineOpacity: true,
              lineWidth: true,
              resolution: true,
            },
            (D, S) => {
              var _;
              let O = D.getDependencies();
              if (O.length === 0 && !ua(D.valueType)) {
                let { points: L, droppedIndices: w } = Cm([D.asValue()]);
                return [{
                  segments: [L],
                  graphMode: 3,
                  droppedIndices: w,
                  color: Ra(x, T),
                  style: x.lineStyle,
                  showPoint: false,
                  poi: go(L),
                }];
              } else {
                let L = D.getCompiledFunction(O);
                S.domain = (_ = L.domain) != null ? _ : {
                  type: "1d",
                  min: this.metaData.evaluatedDomainMin,
                  max: this.metaData.evaluatedDomainMax,
                };
                let w = cu({ viewState: n, graphInfo: S, compiled: L });
                return [KL(e, w, n, S.lineWidth)];
              }
            },
          ),
          P = [];
        for (let D of M) D && P.push(D);
        if (c.fill) {
          if (
            P.forEach((D, S) => {
              let { color: O, fillOpacity: _, listIndex: L } = uc(this, S, i);
              b.push({
                segments: D.segments,
                color: O,
                fillOpacity: _,
                listIndex: L,
                graphMode: 7,
                poi: Ir(),
              });
            }), c.lines
          ) P = P.concat(b);
          else return b;
        }
        return P;
      }
      case 20:
        return p(
          { lineOpacity: true, lineWidth: true, color: true },
          (x, T) => {
            let [[b, M], P] = x.asValue();
            return isNaN(b) || isNaN(M) || isNaN(P) ? [] : [{
              segments: [[b, M, P]],
              resolved: true,
              graphMode: T.graphMode,
              color: T.color,
              style: T.lineStyle,
              lineWidth: T.lineWidth,
              lineOpacity: T.lineOpacity,
              listIndex: T.listIndex,
              operator: T.operator,
              poi: Ir(),
            }];
          },
        );
      case 21:
        return p(
          { color: true, lineWidth: true, lineOpacity: true },
          (x, T) => {
            let b = getArcDetails(x.asValue());
            if (!b) return [];
            let M = [];
            return b.type === "arc"
              ? M.push({
                graphMode: f,
                segments: [[
                  b.center[0],
                  b.center[1],
                  b.radius,
                  b.startAngle,
                  b.endAngle,
                ]],
                color: T.color,
                style: T.lineStyle,
                lineWidth: T.lineWidth,
                lineOpacity: T.lineOpacity,
                listIndex: T.listIndex,
                operator: r.operator,
                poi: Ir(),
              })
              : b.type === "rays"
              ? M.push({
                graphMode: 19,
                segments: [[b.start1[0], b.start1[1], b.end1[0], b.end1[1]]],
                color: T.color,
                style: T.lineStyle,
                lineWidth: T.lineWidth,
                lineOpacity: T.lineOpacity,
                listIndex: T.listIndex,
                operator: r.operator,
                poi: Ir(),
              }, {
                graphMode: 19,
                segments: [[b.start2[0], b.start2[1], b.end2[0], b.end2[1]]],
                color: T.color,
                style: T.lineStyle,
                lineWidth: T.lineWidth,
                lineOpacity: T.lineOpacity,
                listIndex: T.listIndex,
                operator: r.operator,
                poi: Ir(),
              })
              : M.push({
                graphMode: 17,
                segments: [[b.start[0], b.start[1], b.end[0], b.end[1]]],
                color: T.color,
                style: T.lineStyle,
                lineWidth: T.lineWidth,
                lineOpacity: T.lineOpacity,
                listIndex: T.listIndex,
                operator: r.operator,
                poi: Ir(),
              }),
              [...M, ...o1(M, s)];
          },
        );
      case 17:
      case 18:
      case 19:
        return p(
          { color: true, lineWidth: true, lineOpacity: true },
          (x, T) => {
            let [[b, M], [P, D]] = x.asValue();
            if (isNaN(b) || isNaN(M) || isNaN(P) || isNaN(D)) return [];
            let S = [],
              O = {
                segments: [[b, M, P, D]],
                resolved: true,
                graphMode: T.graphMode,
                color: T.color,
                style: T.lineStyle,
                arrowMode: T.arrowMode,
                lineWidth: T.lineWidth,
                lineOpacity: T.lineOpacity,
                listIndex: T.listIndex,
                operator: r.operator,
                poi: Ir(),
              };
            if (
              S.push(ew(e, O, n)),
                S.push(...o1([O], s)),
                this.userData.showLabel && r.graphMode === 17
            ) {
              let _ = T.listIndex,
                L = this.computedLabels && this.computedLabels[_ || 0];
              S.push({
                graphMode: 22,
                objectType: 17,
                segments: [[b, M, P, D]],
                color: T.color,
                listIndex: _,
                showLabel: true,
                labelSize: this.metaData.computedLabelSize,
                labelAngle: this.metaData.computedLabelAngle,
                labelOrientation: this.userData.labelOrientation,
                labels: L ? [L] : [I8(MathHypot(P - b, D - M), n)],
              });
            }
            return S;
          },
        );
      case 24:
        return p(
          { lineOpacity: true, lineWidth: true, color: true },
          (x, T) => {
            let [b, M] = x.asValue(),
              [[P, D], [S, O]] = [M, [M[0] + b[0], M[1] + b[1]]];
            if (isNaN(S) || isNaN(O) || isNaN(P) || isNaN(D)) return [];
            let _ = {
              segments: [[P, D, S, O]],
              resolved: true,
              graphMode: T.graphMode,
              color: T.color,
              style: T.lineStyle,
              arrowMode: T.arrowMode,
              lineWidth: T.lineWidth,
              lineOpacity: T.lineOpacity,
              listIndex: T.listIndex,
              operator: r.operator,
              poi: Ir(),
            };
            return [ew(e, _, n)];
          },
        );
      case 23:
        return p(
          { lineOpacity: true, lineWidth: true, color: true },
          (x, T) => {
            let { value: b, valueType: M } = x.asTypedValue(),
              [[P, D], S, O] = b;
            if (isNaN(P) || isNaN(D) || isNaN(S) || isNaN(O)) return [];
            let _ = T.listIndex,
              L = M === DirectedAngleMarker,
              w = L ? O : Math.abs(O),
              G = [];
            if (
              G.push({
                graphMode: 23,
                segments: [[P, D, S, O, L ? 1 : 0]],
                color: T.color,
                style: T.lineStyle,
                lineWidth: T.lineWidth,
                lineOpacity: T.lineOpacity,
                listIndex: _,
                operator: r.operator,
                poi: Ir(),
              }), this.userData.showAngleLabel
            ) {
              let k = this.computedLabels && this.computedLabels[_ || 0];
              G.push({
                graphMode: 22,
                objectType: 23,
                segments: [[P, D, S, O]],
                color: T.color,
                listIndex: _,
                showLabel: true,
                labelSize: this.metaData.computedLabelSize,
                labelAngle: this.metaData.computedLabelAngle,
                labelOrientation: this.userData.labelOrientation,
                labels: k ? [k] : [E8(w, n)],
              });
            }
            return G;
          },
        );
      case 1:
      case 2:
      case 8:
      case 112:
      case 126:
      case 113:
      case 127:
      case 6:
      case 130:
      case 103:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 120:
      case 121:
      case 122:
      case 123:
      case 124: {
        let x = t.valueType === Number;
        return p({
          lineOpacity: true,
          lineWidth: true,
          resolution: true,
          fillOpacity: true,
          surfaceOpacity: true,
          color: true,
        }, (T, b) => {
          var F, Y, re, Ee, he, K, Oe, te, Ze, dt, me;
          (r.graphMode === 6 || r.graphMode === 110 || r.graphMode === 124) &&
            (b.domain = {
              type: "1d",
              min: this.metaData.evaluatedDomainMin,
              max: this.metaData.evaluatedDomainMax,
              isExplicit: this.metaData.isExplicitDomain,
            });
          let M = (F = vi[r.graphMode]) != null ? F : [],
            P = T.getCompiledFunction(M);
          (r.graphMode == 130 || r.graphMode == 103 || r.graphMode == 111 ||
            r.graphMode == 109) && (b.domain = (Y = P.domain) != null ? Y : {
              type: "2d",
              uMin: this.metaData.evaluatedDomain3DMin1,
              uMax: this.metaData.evaluatedDomain3DMax1,
              vMin: this.metaData.evaluatedDomain3DMin2,
              vMax: this.metaData.evaluatedDomain3DMax2,
            });
          let D = [], S;
          try {
            S = T.getCompiledDerivative();
          } catch (J) {}
          let O = S8(this, T, P, n, b, S, x);
          if (O) return O;
          let _ = hC(b.graphMode),
            L = (re = this.userData.extendTo3D) != null ? re : false,
            w = _ && !L,
            G = !e.is3dPolicy() || w,
            k = (Ee = this.userData.lines) != null ? Ee : G,
            Z = (he = this.userData.lines) != null ? he : !w;
          if (
            b.graphMode === 127 && !L &&
            ((K = this.userData.lines) == null || K)
          ) {
            let J = (Oe = vi[b.graphMode]) != null ? Oe : [],
              W = T._chunk.copy();
            W.GreaterEqual([W.getReturnIndex(), W.Constant(0)]);
            let Ge = T.getCompiledFunction(J),
              be = 0,
              ue = n.viewport,
              At = _b((_t, bc, xc) => xc - be, ue);
            return [{
              meshData: Wi(At),
              color: b.color,
              surfaceOpacity: (te = b.surfaceOpacity) != null ? te : 1,
              uvArgs: (Ze = vi[b.graphMode]) != null ? Ze : [],
              extraMeshArgs: (dt = Ol[b.graphMode]) != null ? dt : [],
              graphMode: 106,
              compiled: Ge,
              restrictionShader: Ma(W, ac),
            }];
          }
          if (
            _ &&
            (this.userData.lines === true
              ? (k = w, Z = !w)
              : this.userData.lines === false && (k = false, Z = false)),
              Z && va(b.graphMode)
          ) {
            let J = zb(b.graphMode);
            if (b.graphMode === 113 || b.graphMode === 127) {
              let { positions: W, normals: Ge, faces: be, uvs: ue } = JL(),
                _e = {
                  guid: Ns(),
                  isDomainCube: true,
                  resolved: true,
                  positions: W,
                  normals: Ge,
                  faces: be,
                  uvs: ue,
                  extraAttrs: new Float32Array([]),
                },
                At = T.toImplicitBool();
              D.push({
                meshData: _e,
                graphMode: 113,
                color: b.color,
                surfaceOpacity: 1,
                uvArgs: [],
                extraMeshArgs: [],
                compiled: P,
                restrictionShader: Ma(At._chunk, ac),
              });
              let ze = kN(At._chunk, T._chunk, J);
              for (let Ce of ze) {
                let _t = QL(b, {
                  concrete: new on(Ce.value),
                  restriction: Ce.restriction && Ma(Ce.restriction, ac),
                }, n);
                D.push(_t);
              }
            } else {
              let W = T.getRestrictedFunctionForGLSL(J, ac), Ge = QL(b, W, n);
              D.push(Ge);
            }
          }
          if (k && C8(this, b), !va(b.graphMode)) {
            let J = cu({
                viewState: n,
                graphInfo: b,
                compiled: P,
                derivative: S,
              }),
              W = cw(ou(this), T);
            if (
              W && (J.boundingBox = W), e.is3dPolicy() && k && l1(J.graphMode)
            ) {
              let Ge = (me = b.lineWidth) != null ? me : 1;
              D.push(kb(J, n, Ge));
            } else if (J.fillSegments) {
              let { fillSegments: Ge, ...be } = J;
              k || (be.lineWidth = 0), D.push(be);
            } else k || (J.lineWidth = 0), (k || !va(r.graphMode)) && D.push(J);
            b.graphMode === 8 && b.operator !== "=" &&
              D.push({
                graphMode: 7,
                segments: J.fillSegments,
                poi: Ir(),
                listIndex: b.listIndex,
                color: b.color,
                fillOpacity: b.fillOpacity,
              });
          }
          return D;
        });
      }
      case 200:
      case 201:
      case 202:
      case 206:
      case 205:
      case 211:
      case 203:
      case 204:
      case 213:
      case 207:
      case 208:
      case 212:
      case 214:
      case 215:
      case 209:
        return p(
          { color: true, lineWidth: true, lineOpacity: true, resolution: true },
          (x, T) => {
            var re;
            let b = (re = vi[f]) != null ? re : [],
              M = x.getCompiledFunction(b).domain;
            switch (f) {
              case 206:
              case 211:
                T.domain = {
                  type: "1d",
                  min: this.metaData.evaluatedDomainMin,
                  max: this.metaData.evaluatedDomainMax,
                  isExplicit: this.metaData.isExplicitDomain,
                };
                break;
              case 203:
              case 204:
              case 213:
              case 207:
              case 208:
              case 212:
              case 214:
              case 215:
                T.domain = M != null ? M : {
                  type: "2d",
                  uMin: this.metaData.evaluatedDomain3DMin1,
                  uMax: this.metaData.evaluatedDomain3DMax1,
                  vMin: this.metaData.evaluatedDomain3DMin2,
                  vMax: this.metaData.evaluatedDomain3DMax2,
                };
                break;
            }
            let P = { allowSlices: true },
              D = tu(x._chunk, b, P),
              { valueChunk: S, slices: O } = D.getValueAndRestrictionChunk(),
              _ = S.getInstruction(S.getReturnIndex()).valueType,
              L = ua(_) ? Jg(S) : S.getCompiledFunction(b),
              w = O[0],
              G = w.type === "implicit",
              k = G ? NaN : w.value,
              Z = G ? "_implicit" : w.variable,
              F,
              Y = (Ee) =>
                cu({
                  viewState: n,
                  graphInfo: {
                    ...T,
                    slice_coordinate: Z,
                    slice_value: k,
                    slice_function: Ee,
                  },
                  compiled: L,
                });
            if (G) {
              let Ee = ["x", "y", "z"],
                he = ["x", "y", "z", "r", "theta"],
                K = ["x", "y", "z", "rho", "theta", "phi"],
                Oe = ["x", "y", "z", "u", "v"],
                te = w.sliceChunk;
              switch (f) {
                case 200:
                case 201:
                case 202:
                  F = te.getCompiledFunction(Ee);
                  break;
                case 211:
                case 213:
                  F = te.getCompiledFunction(he);
                  break;
                case 212:
                  F = te.getCompiledFunction(K);
                  break;
                case 215:
                case 214:
                  F = te.getCompiledFunction(Oe);
                  break;
                case 209: {
                  let Ze = (J, W) => {
                      let Ge = W.getCompiledFunction(Ee),
                        be = J._symbol,
                        ue = J._expression.args,
                        _e = [];
                      for (let At of ue) {
                        if (!(At instanceof on)) {
                          throw U(
                            "Programming Error: bad type",
                          );
                        }
                        if (be === "x") {
                          L = At._chunk.getCompiledFunction(["y", "z"]),
                            T.graphMode = 201;
                        } else if (be === "y") {
                          L = At._chunk.getCompiledFunction(["x", "z"]),
                            T.graphMode = 202;
                        } else if (be === "z") {
                          L = At._chunk.getCompiledFunction(["x", "y"]),
                            T.graphMode = 200;
                        } else throw U("Programming Error: bad lhs");
                        _e.push(Y(Ge));
                      }
                      return _e;
                    },
                    dt = (J, W) => {
                      let Ge = n.viewport,
                        be = W.getCompiledFunction(Ee),
                        ue = J.getCompiledFunction(Ee).fn,
                        _e = r1(ue, Ge);
                      if (_e) {
                        let { explicitPlane: At, u: ze, v: Ce } = _e;
                        return T.graphMode = 214,
                          L = {
                            args: ["u", "v"],
                            source: "",
                            constants: [],
                            fn: At,
                            executionMetadata: {},
                          },
                          T.domain = {
                            type: "2d",
                            uMin: ze.min,
                            uMax: ze.max,
                            vMin: Ce.min,
                            vMax: Ce.max,
                          },
                          [Y(be)];
                      } else return [];
                    };
                  if (te.isImplicitPlane()) return dt(te, S);
                  if (S.isImplicitPlane()) return dt(S, te);
                  let me = gC(e, S);
                  return me instanceof C.SolvedEquation && !me.isError
                    ? Ze(me, te)
                    : (me = gC(e, te),
                      me instanceof C.SolvedEquation && !me.isError
                        ? Ze(me, S)
                        : [Y(te.getCompiledFunction(Ee))]);
                }
              }
            }
            return [Y(F)];
          },
        );
      case 210:
        return p(
          { color: true, surfaceOpacity: true, resolution: true },
          (x, T) => {
            var Y, re, Ee, he, K, Oe, te, Ze;
            let b = (Y = vi[f]) != null ? Y : [],
              M = { allowSlices: true },
              P = tu(x._chunk, b, M),
              { restrictionChunk: D, slices: S } = P
                .getSlicesAndRestrictionChunk(),
              O = D.getCompiledFunction(b);
            if (S[0].type === "implicit") {
              let dt = S[0].sliceChunk, me;
              try {
                me = dt.copy().gradient(["x", "y", "z"]).getCompiledFunction([
                  "x",
                  "y",
                  "z",
                ]).fn;
              } catch (be) {}
              let J = (re = T.resolution) != null ? re : NaN;
              return isNaN(J) && (J = Im), J = clamp(J, 0, 100), [{
                meshData: d1(
                  dt.getCompiledFunction(b),
                  void 0,
                  me,
                  n.viewport,
                  J,
                  { isInequality: false },
                ),
                color: T.color,
                surfaceOpacity: (Ee = T.surfaceOpacity) != null ? Ee : 1,
                uvArgs: (he = vi[T.graphMode]) != null ? he : [],
                extraMeshArgs: (K = Ol[T.graphMode]) != null ? K : [],
                graphMode: f,
                compiled: O,
                restrictionShader: Ma(D, ac),
              }];
            }
            let _ = S[0].value, L = S[0].variable, w = n.viewport, G;
            switch (L) {
              case "x":
                G = (dt, me, J) => dt - _;
                break;
              case "y":
                G = (dt, me, J) => me - _;
                break;
              case "z":
                G = (dt, me, J) => J - _;
                break;
              default:
                return [];
            }
            let k = _b(G, w);
            return [{
              meshData: Wi(k),
              color: T.color,
              surfaceOpacity: (Oe = T.surfaceOpacity) != null ? Oe : 1,
              uvArgs: (te = vi[T.graphMode]) != null ? te : [],
              extraMeshArgs: (Ze = Ol[T.graphMode]) != null ? Ze : [],
              graphMode: f,
              compiled: O,
              restrictionShader: Ma(D, ac),
            }];
          },
        );
      case 16: {
        let x = [],
          T = this.userData.lines === void 0 ? true : this.userData.lines,
          b = this.userData.fill === void 0 ? true : this.userData.fill;
        if (!b && !T) return x;
        let M = Dl(this.metaData, [
            "computedLineOpacity",
            "computedLineWidth",
            "colorLatexValue",
            "fillOpacity",
          ], i),
          P = t.asValue();
        j(t.valueType) || (P = [P]);
        for (let D = 0; D < P.length; D++) {
          if (D > M - 1) continue;
          let S = P[D];
          if (!S.length) continue;
          let O = this.getGraphInfo(e, t),
            {
              listIndex: _,
              lineWidth: L,
              lineOpacity: w,
              fillOpacity: G,
              color: k,
            } = uc(this, D, i);
          !this.userData.shouldOmitLastPolygonSegment && S.length > 2 &&
          (S = [...S, S[0]]), ms(S);
          let Z = rw(S);
          if (Z.length) {
            if (
              b && S.length > 2 &&
              x.push({
                segments: Z,
                graphMode: 7,
                poi: Ir(),
                color: k,
                fillOpacity: G,
                style: O.style,
                listIndex: _,
              }),
                T &&
                (x.push({
                  segments: Z,
                  graphMode: 5,
                  poi: Ir(),
                  color: k,
                  style: this.userData.lineStyle,
                  lineWidth: L,
                  lineOpacity: w,
                  listIndex: _,
                }),
                  s)
            ) {
              for (let F = 0; F < S.length - 1; F++) {
                za(s.parentType, [Polygon, ListOfPolygon]);
                let Y = s.getEdgeIntersections(F);
                if (!Y) continue;
                let [re, Ee] = S[F], [he, K] = S[F + 1];
                x.push(
                  ...o1([{
                    segments: [[re, Ee, he, K]],
                    resolved: true,
                    graphMode: 17,
                    color: k,
                    style: this.userData.lineStyle,
                    arrowMode: O.arrowMode,
                    lineWidth: L,
                    lineOpacity: w,
                    listIndex: _,
                    poi: Ir(),
                  }], Y),
                );
              }
            }
            if (T8 && this.userData.showLabel) {
              let F = this.computedLabels && this.computedLabels[_ || 0];
              x.push({
                graphMode: 22,
                objectType: 16,
                segments: Z,
                color: k,
                listIndex: _,
                showLabel: true,
                labelSize: this.metaData.computedLabelSize,
                labelAngle: this.metaData.computedLabelAngle,
                labelOrientation: this.userData.labelOrientation,
                labels: F ? [F] : [P8(polygonArea(S), n)],
              });
            }
          }
        }
        return x;
      }
      case 7:
      case 11:
      case 10:
      case 15:
      case 22:
      case 128:
        return false;
      default:
        let h = f;
        throw new Error(`Unexpected graphMode: ${h}`);
    }
  }
  function QL(e, t, n) {
    var c, l, p;
    let r = (c = vi[e.graphMode]) != null ? c : [],
      s = t.concrete.getCompiledFunction(r),
      i,
      o,
      a = false;
    if (e.graphMode === 112 || e.graphMode === 126 || e.graphMode === 113) {
      e.operator !== "=" && (a = true);
      try {
        i = t.concrete.gradient(["x", "y", "z"])._chunk,
          o = i.getCompiledFunction(["x", "y", "z"]).fn;
      } catch (f) {}
    }
    if (e.graphMode === 112 && o && i) {
      let f = D8(s.fn, o, i, n.viewport);
      if (f) {
        return {
          graphMode: 118,
          position: f.center,
          radius: f.radii,
          guid: Ns(),
          color: e.color,
          restrictionShader: t.restriction,
          surfaceOpacity: (l = e.surfaceOpacity) != null ? l : 1,
        };
      }
    }
    let u = e.graphMode;
    if (
      (u === 112 || u === 113 || u === 127 || u === 106 || u === 107 ||
          u === 108) && t.concrete._chunk.isLinearIn(["x", "y", "z"]) ||
      u === 106 && t.concrete._chunk.isConstant()
    ) {
      let f = n.viewport, d;
      switch (u) {
        case 106:
          d = (m, h, x) => x - s.fn(m, h);
          break;
        case 107:
          d = (m, h, x) => m - s.fn(h, x);
          break;
        case 108:
          d = (m, h, x) => h - s.fn(m, x);
          break;
        case 112:
        case 113:
        case 127:
          d = s.fn;
          break;
      }
      let y = Wi(_b(d, f)), g = u === 113 || u === 127;
      return u === 127 && (u = 113), {
        meshData: y,
        color: e.color,
        surfaceOpacity: g ? 1 : (p = e.surfaceOpacity) != null ? p : 1,
        uvArgs: [],
        extraMeshArgs: [],
        graphMode: u,
        compiled: s,
        restrictionShader: t.restriction,
      };
    }
    return cu({
      viewState: n,
      graphInfo: e,
      compiled: s,
      restrictionShader3d: t.restriction,
      isImplicit3dInequality: a,
      gradient: o,
      dependencies: t.concrete._dependencies,
    });
  }
  function C8(e, t) {
    var r, s, i;
    if (hC(t.graphMode)) {
      switch (t.graphMode) {
        case 121:
        case 123: {
          t.graphMode = 2,
            t.willConvertTo3D = true,
            (r = t.lineWidth) != null || (t.lineWidth = 1);
          break;
        }
        case 120:
        case 122: {
          t.graphMode = 1,
            t.willConvertTo3D = true,
            (s = t.lineWidth) != null || (t.lineWidth = 1);
          break;
        }
        case 124:
          let { min: o, max: a } =
            ((i = t.domain) == null ? void 0 : i.type) === "1d"
              ? t.domain
              : { min: 0, max: 2 * Math.PI };
          t.graphMode = 6,
            t.domain = {
              type: "1d",
              min: o,
              max: a,
              isExplicit: e.metaData.isExplicitDomain,
            };
          break;
        case 126:
          t.graphMode = 8;
          break;
      }
    }
  }
  function D8(e, t, n, r) {
    if (r.zmin === void 0 || r.zmax === void 0) return;
    let s = n.argNames.indexOf("x"),
      i = n.argNames.indexOf("y"),
      o = n.argNames.indexOf("z");
    if (s === -1 || i === -1 || o === -1) return;
    let a = n.getInstruction(n.getReturnIndex());
    if (a.type !== 38 || a.args.length !== 3) return;
    let [u, c, l] = a.args,
      p = ns(n, s, {
        allowRestriction: false,
        allowClosedBlockReferences: false,
      }),
      f = ns(n, i, {
        allowRestriction: false,
        allowClosedBlockReferences: false,
      }),
      d = ns(n, o, {
        allowRestriction: false,
        allowClosedBlockReferences: false,
      });
    if (
      ln(p, u) !== 1 || ln(f, c) !== 1 || ln(d, l) !== 1 || ln(f, u) !== 0 ||
      ln(d, u) !== 0 || ln(p, c) !== 0 || ln(d, c) !== 0 || ln(p, l) !== 0 ||
      ln(f, l) !== 0
    ) return;
    let { xmin: y, ymin: g, zmin: m, xmax: h, ymax: x, zmax: T } = r,
      b = t(y, g, m),
      M = t(h, x, T),
      P = .5 * (M[0] - b[0]) / (h - y),
      D = .5 * (M[1] - b[1]) / (x - g),
      S = .5 * (M[2] - b[2]) / (T - m),
      O = (y * M[0] - h * b[0]) / (M[0] - b[0]),
      _ = (g * M[1] - x * b[1]) / (M[1] - b[1]),
      L = (m * M[2] - T * b[2]) / (M[2] - b[2]),
      w = -e(O, _, L),
      G = Math.sqrt(w / P),
      k = Math.sqrt(w / D),
      Z = Math.sqrt(w / S);
    if (
      !(!isFinite(O) || !isFinite(_) || !isFinite(L) || !isFinite(G) ||
        !isFinite(k) || !isFinite(Z) || G === 0 || k === 0 || Z === 0)
    ) return { center: [O, _, L], radii: [G, k, Z] };
  }
  function S8(e, t, n, r, s, i, o) {
    let a = e.metaData.evaluatedCDFMin,
      u = e.metaData.evaluatedCDFMax,
      c = ou(e),
      l = cw(c, t),
      p = c && c.discrete;
    if (a !== void 0 && u !== void 0 && !isNaN(a) && !isNaN(u) && o) {
      let f = [];
      if (p) {
        let d = {
            viewState: r,
            graphInfo: s,
            compiled: n,
            bounds: [a, u],
            maxOverride: tw(c, t),
            showPoint: e.userData.shouldGraph,
          },
          y = YL(d),
          g = y.cdfTopBranch,
          m = y.topBranches;
        if (
          m.forEach((h) => {
            !h || !l || (h.boundingBox = l);
          }), m.every((h) => h !== void 0) && (f = m, g && g.segments[0].length)
        ) {
          let h = [];
          g.segments[0].forEach((x) => {
            !isNaN(x[0]) && !isNaN(x[1]) && h.push([x[0], 0, x[0], x[1]]);
          }),
            f.push({
              graphMode: 5,
              segments: h,
              boundingBox: l,
              poi: Ir(),
              color: s.color,
            });
        }
      } else {
        let y = XL({
            viewState: r,
            graphInfo: s,
            compiled: n,
            derivative: i,
            bounds: [a, u],
          }),
          g = y.cdfTopBranch,
          m = y.topBranches;
        if (
          m.forEach((h) => {
            !h || !l || (h.boundingBox = l);
          }),
            f = m,
            g && g.segments.length
        ) {
          let h, x;
          for (let T = 0; T < g.segments.length; T++) {
            let b = g.segments[T];
            if (b.length >= 4) {
              h = b[0];
              break;
            }
          }
          for (let T = g.segments.length - 1; T >= 0; T--) {
            let b = g.segments[T];
            if (b.length >= 4) {
              x = b[b.length - 2];
              break;
            }
          }
          if (h !== void 0 && x !== void 0 && isFinite(h) && isFinite(x)) {
            let T = Hb(g.segments, [[h, 0, x, 0]], g.graphMode);
            f.push({ graphMode: 7, segments: T, poi: Ir(), color: s.color });
          }
        }
      }
      return f;
    } else if (p) {
      let f = Nb({
        viewState: r,
        graphInfo: s,
        compiled: n,
        showPoint: e.userData.shouldGraph,
        maxOverride: tw(c, t),
      });
      return l && (f.boundingBox = l), [f];
    } else return;
  }
  function iw(e) {
    return v8(e) || l1(e) || ow(e);
  }
  function v8(e) {
    return e === 3;
  }
  function i1(e, t) {
    let n = t != null ? t : {};
    if (!Array.isArray(e)) return () => e;
    let r = Object.keys(n).length === 0 ? e : e.filter((s, i) => !n[i]);
    return (s) => r[s];
  }
  function O8(e) {
    var i, o;
    let t = e.droppedIndices,
      n = i1((i = e.pointSize) != null ? i : 1, t),
      r = i1(e.color, t),
      s = i1((o = e.pointOpacity) != null ? o : 1, t);
    return e.segments[0].map(([a, u], c) => ({
      graphMode: 114,
      position: [a, u, 0],
      radius: .02 * n(c),
      guid: Ns(),
      color: r(c),
      fillOpacity: s(c),
    }));
  }
  function KL(e, t, n, r) {
    return e.is3dPolicy() && l1(t.graphMode) ? kb(t, n, r != null ? r : 1) : t;
  }
  function l1(e) {
    switch (e) {
      case 1:
      case 2:
      case 6:
      case 8:
      case 5:
        return true;
      default:
        return false;
    }
  }
  function kb(e, t, n, r = 0) {
    var o;
    let s = aw(e, t, r), i = Dm(s, t.viewport, n);
    return {
      graphMode: 128,
      guid: Ns(),
      points: i,
      resolved: e.resolved,
      color: e.color,
      compiled: e.compiled,
      thickness: (o = e.lineWidth) != null ? o : 1,
    };
  }
  function ew(e, t, n) {
    return e.is3dPolicy() && ow(t.graphMode) ? N8(t, n) : t;
  }
  function ow(e) {
    switch (e) {
      case 17:
      case 24:
        return true;
      default:
        return false;
    }
  }
  function N8(e, t) {
    var r;
    let n = aw(e, t);
    return {
      graphMode: e.graphMode === 17 ? 119 : e.graphMode === 24 ? 129 : 128,
      guid: Ns(),
      points: R8(n),
      color: e.color,
      thickness: (r = e.lineWidth) != null ? r : 1,
    };
  }
  function R8(e) {
    let t = [];
    for (let [n, r, s] of e) t.push(n, r, s);
    return t;
  }
  function aw(e, t, n = 0) {
    function r(i, o) {
      if (e.graphMode === 1) return [o, i];
      if (e.graphMode === 6) {
        let a = t.degreeMode ? i * Math.PI / 180 : i;
        return [o * Math.cos(a), o * Math.sin(a)];
      } else return [i, o];
    }
    let s = [];
    for (let i = 0; i < e.segments.length; i++) {
      let o = e.segments[i];
      for (let a = 0; a < o.length / 2; a++) {
        let [u, c] = r(o[2 * a], o[2 * a + 1]);
        s.push([u, c, n]);
      }
      i < e.segments.length - 1 && s.push([NaN, NaN, 0]);
    }
    return s;
  }
  function Dm(e, t, n) {
    if (t.zmin === void 0 || t.zmax === void 0) return [];
    let { xmin: r, xmax: s, ymin: i, ymax: o, zmin: a, zmax: u } = t,
      c = s - r,
      l = o - i,
      p = u - a,
      f = n / 200,
      d = [],
      y = 1e-4;
    for (let h = 0; h < e.length; h++) {
      let x = e[h];
      if (isFinite(x[0]) && isFinite(x[1]) && isFinite(x[2])) {
        let T = d[d.length - 1];
        T !== void 0 && Math.abs(x[0] - T[0]) < y * c &&
            Math.abs(x[1] - T[1]) < y * l && Math.abs(x[2] - T[2]) < y * p ||
          d.push(x);
      } else d.push(void 0);
    }
    let g = [], m = d.length;
    for (let h = 0; h < m; h++) {
      let x = d[h];
      if (!x) {
        g.push(NaN, NaN, NaN);
        continue;
      }
      let [T, b, M] = x, P = d[h - 1], D = d[h + 1];
      if (P && D) {
        let [S, O, _] = P,
          [L, w, G] = D,
          k = (T - S) / c,
          Z = (L - T) / c,
          F = (b - O) / l,
          Y = (w - b) / l,
          re = (M - _) / p,
          Ee = (G - M) / p,
          he = hypot(k, F, re),
          K = hypot(Z, Y, Ee);
        if ((Z * k + Y * F + Ee * re) / (he * K) < .7 && he > f && K > f) {
          let te = .5 * (f / he),
            Ze = .5 * (f / K),
            dt = Po(S, T, 1 - te),
            me = Po(O, b, 1 - te),
            J = Po(_, M, 1 - te),
            W = Po(T, L, Ze),
            Ge = Po(b, w, Ze),
            be = Po(M, G, Ze);
          g.push(dt, me, J),
            g.push(Po(dt, T, .5), Po(me, b, .5), Po(J, M, .5)),
            g.push(T, b, M),
            g.push(Po(T, W, .5), Po(b, Ge, .5), Po(M, be, .5)),
            g.push(W, Ge, be);
        } else g.push(T, b, M);
      } else g.push(T, b, M);
    }
    return g;
  }
  function Po(e, t, n) {
    return (1 - n) * e + n * t;
  }
  function A8(e) {
    return e.startsWith("shader:");
  }
  function wb(e, t, n) {
    return {
      resolved: true,
      graphMode: t,
      segments: n,
      operator: e.operator,
      poi: Ir(),
      color: e.color,
      style: "DASHED",
      lineWidth: 1,
      lineOpacity: .5,
      isIntersectionExtension: true,
    };
  }
  function o1(e, t) {
    if (!t) return [];
    let n = [];
    for (let r of e) {
      let s = t;
      if (
        "listIndex" in r && r.listIndex !== void 0 && t instanceof gd &&
        (s = t.getListItemIntersections(r.listIndex)),
          r.graphMode === 17 || r.graphMode === 19
      ) {
        za(s.parentType, [Segment, Ray]);
        let i = s.getPoints();
        if (!i) continue;
        let o = 0, a, u = 1, c, [l, p, f, d] = r.segments[0];
        for (let y = 0; y < i.length; y++) {
          let [g, m] = i[y], h = to(g, m, 0, l, p, 0, f, d, 0);
          h < o && (o = h, a = y),
            r.graphMode === 17 && h > u && (u = h, c = y);
        }
        a !== void 0 && n.push(wb(r, 17, [[l, p, i[a][0], i[a][1]]])),
          c !== void 0 && n.push(wb(r, 17, [[f, d, i[c][0], i[c][1]]]));
      } else if (r.graphMode === 21) {
        za(s.parentType, [Arc]);
        let i = s.getPoints();
        if (!i) continue;
        let [o, a, u, c, l] = r.segments[0],
          p = l - c + (l < c ? 1 : -1) * 2 * Math.PI,
          f = [];
        for (let d of i) {
          let [y, g] = d, m = Math.atan2(g - a, y - o), h = W1(m, c, p);
          0 < h && h < 1 && f.push(h);
        }
        if (f.length) {
          f.push(0, 1), f.sort();
          let d = 0, y = 0;
          for (let h = 0; h < f.length - 1; h++) {
            let x = f[h + 1] - f[h];
            (d === void 0 || x > d) && (d = x, y = h);
          }
          let g = f[y], m = f[y + 1];
          g > 0 && n.push(wb(r, 21, [[o, a, u, c, c + g * p]])),
            m < 1 && n.push(wb(r, 21, [[o, a, u, l, l - (1 - m) * p]]));
        }
      }
    }
    return n;
  }
  function _8() {
    throw new Error(
      "Programming error: this function is not expected to be called",
    );
  }
  function uw(e, t, n, r) {
    let s = [];
    for (let i = 0; i < t.otherVariableSolutionData.length; i++) {
      let o = t.otherVariableSolutionData[i];
      if (!o) continue;
      let { coefficients: a, restriction: u } = o, c = a.argNames[0];
      if (c !== "x" && c !== "y") continue;
      let l = a.getCompiledFunction().fn, p, f;
      c === "y" ? (p = 1, f = 2) : (p = 2, f = 1);
      let d = void 0,
        { listIndex: y, style: g, lineWidth: m, lineOpacity: h, color: x } = uc(
          e,
          i,
          d,
        ),
        T = Td(n, {
          graphMode: p,
          domainBound: dr(),
          lineWidth: m,
          operator: "=",
        }, _8);
      if (!T) continue;
      let b = dw(l, T);
      for (let M of b) {
        let P = new on(u.substituteConstantArguments({ [c]: M })),
          D = e.getGraphInfo(r, P);
        D = { ...D, graphMode: f, lineWidth: m };
        let O = e._graph(
          r,
          P,
          n,
          D,
          void 0,
          t.branchMultiplier === 2 ? "solvedEquation" : void 0,
        );
        if (Bo(O)) {
          for (let _ of O) {
            s.push({
              ..._,
              listIndex: y,
              style: g,
              lineWidth: m,
              lineOpacity: h,
              color: x,
            });
          }
        }
      }
    }
    return s.length > 0 ? s : false;
  }
  C.Base.prototype.tryGraph = function (e, t, n, r) {
    var s, i, o;
    try {
      let a = this.graph(e, t, n, r);
      if (Array.isArray(a)) {
        for (let u of a) {
          if (!("compiled" in u)) continue;
          let c = (s = u.compiled) == null ? void 0 : s.executionMetadata;
          c &&
            (c.recursionTerminationStatus &&
              (u.recursionTerminationStatus = c.recursionTerminationStatus),
              ((i = c.badCoercionCount) != null ? i : 0) >= 1 &&
              ((o = c.goodCoercionCount) != null ? o : 0) <= 2 &&
              (u.nanBlame = "ComplexCoercion"));
        }
      }
      return a;
    } catch (a) {
      let u = a instanceof C.Error ? a.getError() : U(a).getError();
      return [pw(u)];
    }
  };
  C.Base.prototype.graph = function (e, t, n, r) {
    let s = this.getGraphInfo(e, t);
    return this._graph(e, t, n, s, r);
  };
  C.BaseComparator.prototype.graph = function (e, t, n) {
    let r = this.getGraphInfo(e, t),
      s = r.graphMode,
      i = "baseComparator",
      o = this.userData.lines === void 0 ? true : this.userData.lines;
    if (s === 8 || s === 112 || s === 113 || s === 127 || s === 210) {
      return this._graph(e, t, n, r);
    }
    if (s === 10 || !(t instanceof C.SolvedEquation)) return false;
    let a = this.getOperator(), u = [], c = [], l = true;
    t._expression.eachElement((m) => {
      u.push(m.getCompiledFunction());
      try {
        c.push(m.getCompiledDerivative());
      } catch (h) {
        l = false;
      }
    }), l || (c = void 0);
    let p = [],
      f = [-1, 0, 0, 1],
      d = Dl(this.metaData, [
        "computedLineWidth",
        "computedLineOpacity",
        "computedFillOpacity",
        "colorLatexValue",
      ], i),
      y = Math.min(u.length, d);
    for (let m = 0; m < y; m++) {
      let h = this.getGraphInfo(e, t._expression.args[m]);
      h.graphMode = s;
      let {
        listIndex: x,
        style: T,
        color: b,
        lineWidth: M,
        lineOpacity: P,
        fillOpacity: D,
      } = uc(this, m, i);
      h.listIndex = x,
        h.style = T,
        h.color = b,
        r.graphMode === 6 &&
        (h.domain = {
          type: "1d",
          min: this.metaData.evaluatedDomainMin,
          max: this.metaData.evaluatedDomainMax,
          isExplicit: this.metaData.isExplicitDomain,
        });
      let S = cu({
        viewState: n,
        graphInfo: h,
        compiled: u[m],
        derivative: c ? c[m] : void 0,
      });
      S.lineWidth = M,
        S.lineOpacity = P,
        S.fillOpacity = D,
        S.operator = nl(Jr[a].inclusive, f[m % 4]),
        o || (S.lineWidth = 0),
        p.push(S);
    }
    for (let m = 0; m < y; m += 4) {
      let h = Hb(p[m + 1].segments, p[m + 2].segments, s);
      p.push({
        graphMode: 7,
        listIndex: p[m].listIndex,
        segments: h,
        poi: Ir(),
        fillOpacity: p[m].fillOpacity,
        color: p[m].color,
      });
    }
    let g = uw(this, t, n, e);
    if (g) {
      for (let m of g) m.operator = nl(Jr[a].inclusive, 0);
      Array.prototype.push.apply(p, g);
    }
    return p;
  };
  C.DoubleInequality.prototype.graph = function (e, t, n) {
    let r = this.getGraphInfo(e, t);
    if (r.graphMode === 10) return false;
    let s = [],
      i = nl(Jr[this._operators[0]].inclusive, 0),
      o = nl(Jr[this._operators[1]].inclusive, 0),
      a = this.userData,
      u = this.metaData,
      c = a.lines === void 0 ? true : a.lines,
      l = ["colorLatexValue", "computedFillOpacity"];
    c && l.push("computedLineWidth", "computedLineOpacity");
    let p = Dl(u, l), f = t._expressions;
    return ms(f),
      Fb.eachArgs(f, (d, y) => {
        let g = y;
        if (g >= p) return;
        d[0].userData = d[1].userData = a, d[0].metaData = d[1].metaData = u;
        let m = void 0,
          { color: h, lineWidth: x, lineOpacity: T, fillOpacity: b } = uc(
            this,
            g,
            m,
          ),
          M = this._graph(e, d[0], n, r)[0];
        M.listIndex = g,
          M.operator = i,
          M.color = h,
          M.lineWidth = x,
          M.lineOpacity = T,
          s.push(M);
        let P = this._graph(e, d[1], n, r)[0];
        P.listIndex = g,
          P.operator = o,
          P.color = h,
          P.lineWidth = x,
          P.lineOpacity = T,
          s.push(P);
        let D = M.segments, S = P.segments;
        ms(D), ms(S);
        let O = Hb(D, S, M.graphMode);
        c || (M.lineWidth = 0, P.lineWidth = 0),
          s.push({
            graphMode: 7,
            listIndex: M.listIndex,
            segments: O,
            lineOpacity: T,
            fillOpacity: b,
            poi: Ir(),
            color: h,
          });
      }),
      s;
  };
  C.Regression.prototype.graph = function (e, t, n) {
    var i;
    let r = this.getGraphInfo(e, t), s = this._graph(e, t.model, n, r);
    if (Array.isArray(s)) {
      for (let o of s) {
        (i = this.tableRegressionData) != null && i.tableId &&
          (o.tableId = this.tableRegressionData.tableId);
      }
    }
    return s;
  };
  function p1(e, t) {
    let n = 1 / 0, r = -1 / 0, s = 1 / 0, i = -1 / 0;
    for (let o of t) {
      for (let a = 0; a < o.length; a += 2) {
        let u = o[a], c = o[a + 1];
        u < n && (n = u), u > r && (r = u), c < s && (s = c), c > i && (i = c);
      }
    }
    if (isFinite(n) && isFinite(s)) {
      return { type: e, xmin: n, ymin: s, xmax: r, ymax: i };
    }
  }
  function cw(e, t) {
    if (!e || !(t instanceof on)) return;
    let n = t._chunk, r = n.getInstruction(n.getReturnIndex());
    if (r.type !== 37) return;
    let s = e.discrete ? "discreteDistribution" : "continuousDistribution";
    if (e.symbol === "binomialdist" && r.symbol === "binompdf") {
      let i = hn(n, r.args[1]), o = hn(n, r.args[2]), a = binompdf(o * i, i, o);
      return { type: s, xmin: 0, xmax: i, ymin: 0, ymax: a };
    }
    if (e.symbol === "poissondist" && r.symbol === "poissonpdf") {
      let i = hn(n, r.args[1]),
        o = Math.max(poissonpdf(Math.floor(i), i), poissonpdf(Math.ceil(i), i));
      return { type: s, xmin: 0, xmax: 2.5 * i, ymin: 0, ymax: o };
    }
    if (e.symbol === "normaldist" && r.symbol === "normalpdf") {
      let i = hn(n, r.args[1]), o = hn(n, r.args[2]), a = normalpdf(i, i, o);
      return {
        type: s,
        xmin: i - 2 * Math.abs(o),
        xmax: i + 2 * Math.abs(o),
        ymin: 0,
        ymax: a,
      };
    }
    if (e.symbol === "uniformdist" && r.symbol === "uniformpdf") {
      let i = hn(n, r.args[1]),
        o = hn(n, r.args[2]),
        a = (i + o) / 2,
        u = o - i,
        c = uniformpdf(a, i, o);
      return { type: s, xmin: i - u / 3, xmax: o + u / 3, ymin: 0, ymax: c };
    }
    if (e.symbol === "tdist" && r.symbol === "tpdf") {
      let i = hn(n, r.args[1]), o = tpdf(0, i);
      return { type: s, xmin: -3, xmax: 3, ymin: 0, ymax: o };
    }
  }
  function tw(e, t) {
    if (e === void 0 || e.symbol !== "binomialdist" || !(t instanceof on)) {
      return;
    }
    let n = t._chunk, r = n.getInstruction(n.getReturnIndex());
    if (r.type === 37 && r.symbol === "binompdf") return hn(n, r.args[1]);
  }
  function lw(e, t, n) {
    let r = {};
    n -= .5 * t;
    for (let s = e.length - 1; s >= 0; s--) {
      let i = e[s], o = Math.floor((i - n) / t);
      r[o] ? r[o].data.push(i) : r[o] = {
        id: o,
        data: [i],
        min: o * t + n,
        max: o * t + n + t,
        center: o * t + n + t / 2,
      };
    }
    return r;
  }
  C.Histogram.prototype.graph = function (e, t, n) {
    let r = this.getGraphInfo(e, t),
      s = t.args[0].asValue(),
      i = t.args[1].asValue(),
      o =
        this.userData.vizProps && this.userData.vizProps.binAlignment === "left"
          ? i / 2
          : 0;
    ms(s);
    let a = lw(s, i, o), u = 1;
    this.userData.vizProps && this.userData.vizProps.histogramMode === "density"
      ? u = 1 / (s.length * i)
      : this.userData.vizProps &&
        this.userData.vizProps.histogramMode === "relative" &&
        (u = 1 / s.length);
    let c = [], l = [];
    for (let f in a) {
      let d = a[f], y = d.data.length;
      l.push([d.min, 0 * u, d.min, y * u, d.max, y * u, d.max, 0 * u]);
      let g = 0;
      a[d.id + 1] && (g = a[d.id + 1].data.length);
      let m = [d.min, 0 * u, d.min, y * u, d.max, y * u];
      g < y && m.push(d.max, g * u), c.push(m);
    }
    let p = p1("histogram", l);
    return p && i && (p.binWidth = i), [{
      segments: l,
      graphMode: 7,
      boundingBox: p,
      poi: Ir(),
      color: r.color,
      fillOpacity: .4,
    }, {
      segments: c,
      graphMode: 2,
      poi: {
        zeros: { x: [], y: [] },
        extrema: { x: [], y: [] },
        intercept: { x: [], y: [] },
      },
      color: r.color,
    }];
  };
  C.DotPlot.prototype.graph = function (e, t, n) {
    let r = this.getGraphInfo(e, t),
      s = t.args[1].asValue(),
      i =
        this.userData.vizProps && this.userData.vizProps.binAlignment === "left"
          ? s / 2
          : 0,
      o = t.args[0].asValue();
    ms(o);
    let a = lw(o, s, i), u = false, c, l = [];
    for (let m in a) {
      let h = a[m];
      for (let x = h.data.length - 1; x >= 0; x--) {
        h.center !== h.data[x] && (u = true);
      }
    }
    if (
      this.userData.vizProps && this.userData.vizProps.dotplotXMode === "exact"
    ) {
      for (let m in a) {
        c = a[m].data, c.reverse();
        for (let x = 0; x < c.length; x++) l.push([c[x], x + 1]);
      }
    } else {for (let m in a) {
        let h = a[m];
        c = h.data;
        for (let x = 0; x < c.length; x++) l.push([h.center, x + 1]);
      }}
    let p = p1("dotplot", l);
    p && s && (p.ymin = 0, p.xmin -= .5 * s, p.xmax += .5 * s, p.binWidth = s);
    let { computedPointOpacity: f, computedPointSize: d } = this.metaData,
      y = Aa(f, 0),
      g = this.userData.pointSize ? Aa(d, 0) : 14;
    return [{
      segments: [l],
      graphMode: 3,
      boundingBox: p,
      poi: go(l),
      color: r.color,
      style: this.userData.pointStyle,
      pointSize: g,
      pointOpacity: y,
      showPoint: true,
      needsDotplotXMode: u,
    }];
  };
  C.BoxPlot.prototype.graph = function (e, t, n) {
    let r = this.getGraphInfo(e, t),
      s = this.metaData.evaluatedAxisOffset,
      i = this.metaData.evaluatedBreadth,
      o = t.args[0].asValue();
    if (ms(o), isNaN(i) || isNaN(s)) return false;
    let a = Math.min.apply(null, o),
      u = Math.max.apply(null, o),
      c = quartile(o, 1),
      l = quartile(o, 2),
      p = quartile(o, 3),
      f = s,
      d = f - i / 2,
      y = f + i / 2,
      g = i / 10,
      m = [];
    if (this.userData.vizProps.showBoxplotOutliers) {
      let T = p - c, b = c - 1.5 * T, M = p + 1.5 * T;
      a = 1 / 0,
        u = -1 / 0,
        o.forEach((P) => {
          b <= P && P < a && (a = P),
            u < P && P <= M && (u = P),
            (P < b || P > M) && m.push([P, f]);
        });
    }
    let h = [
      [c, d, p, d, p, y, c, y, c, d],
      [l, d, l, y],
      [c, f, a, f],
      [p, f, u, f],
      [a, f - g, a, f + g],
      [u, f - g, u, f + g],
    ];
    if (this.userData.vizProps && this.userData.vizProps.alignedAxis === "y") {
      for (let T of h) {
        for (let b = 0; b < T.length; b += 2) {
          let M = T[b];
          T[b] = T[b + 1], T[b + 1] = M;
        }
      }
      for (let T of m) {
        let b = T[0];
        T[0] = T[1], T[1] = b;
      }
    }
    let x = [{
      segments: h,
      graphMode: 5,
      boundingBox: p1("boxplot", h.concat(m)),
      poi: Ir(),
      color: r.color,
    }];
    return m.length &&
      x.push({
        segments: [m],
        graphMode: 3,
        color: r.color,
        style: "OPEN",
        showPoint: true,
        poi: go(m),
      }),
      x;
  };
  function L8(e) {
    return Array.prototype.concat.apply([], e);
  }
  C.Table.prototype.isValueDraggable = function (e, t, n) {
    if (!e.columns[t].isIndependent) return false;
    let s = this.calcColumns[t].values, i = s && s[n], o = i && i.asValue();
    return !!(typeof o == "number" && isFinite(o) &&
      i.getDependencies().length === 0);
  };
  function nw(e) {
    let t = [];
    for (let n of e) {
      typeof n == "number" ? t.push(n) : t.push(coerceComplexToReal(n));
    }
    return t;
  }
  C.Table.prototype.graph = function (e, t, n) {
    let r = {}, s = t.columns[0];
    if (s.isError) return r;
    let i = nw(s.asValueMixed());
    for (let o = 1; o < this.columns.length; o++) {
      let a = t.columns[o];
      if (a.isError) continue;
      let u = nw(a.asValueMixed()),
        c = this.columns[o].header.userData,
        l = this.columns[o].header.metaData;
      if (c.hidden) continue;
      let p = Dl(l, [
          "colorLatexValue",
          "computedPointSize",
          "computedPointOpacity",
        ]),
        f = c.dragMode,
        d = f === "X" || f === "XY",
        y = f === "Y" || f === "XY",
        g = !!c.points,
        m = !!c.lines,
        h = [],
        x = [],
        T = [],
        b = [],
        M = [],
        P = [],
        D = 1 / 0,
        S = -1 / 0,
        O = 1 / 0,
        _ = -1 / 0,
        L = {};
      for (let k = 0; k < i.length; k++) {
        let Z = i[k], F = u[k];
        if (!isFinite(Z) || !isFinite(F)) {
          L[k] = true, m && (P.length > 1 && M.push(P), P = []);
          continue;
        }
        if (g) {
          if (k >= p) continue;
          let Y = d && this.isValueDraggable(t, 0, k),
            re = y && this.isValueDraggable(t, o, k);
          Y || re
            ? (T.push([Z, F]), b.push({ index: k, dragX: Y, dragY: re }))
            : x.push([Z, F]);
        }
        m && P.push([Z, F]),
          Z < D && (D = Z),
          Z > S && (S = Z),
          F < O && (O = F),
          F > _ && (_ = F);
      }
      let w = this.columns[o],
        G = {
          type: "table",
          symbol: "header" in w ? w.header._symbol : void 0,
          xmin: D,
          xmax: S,
          ymin: O,
          ymax: _,
        };
      T.length && h.push({
        graphMode: 4,
        segments: [T],
        color: l.colorLatexValue || c.color,
        tableId: c.tableId,
        poi: go(T),
        movablePointInfo: b,
        boundingBox: G,
        pointOpacity: l.computedPointOpacity,
        pointSize: l.computedMovablePointSize,
      }),
        x.length && h.push({
          segments: [x],
          droppedIndices: L,
          graphMode: 3,
          showPoint: true,
          poi: go(x),
          color: l.colorLatexValue || c.color,
          pointSize: l.computedPointSize,
          pointOpacity: l.computedPointOpacity,
          style: c.pointStyle,
          tableId: c.tableId,
          boundingBox: G,
        }),
        (M.length || P.length) && (M.push(P),
          h.push({
            segments: M.map(L8),
            graphMode: 5,
            poi: Ir(),
            color: Ra(c, l),
            style: c.lineStyle,
            lineWidth: Array.isArray(l.computedLineWidth)
              ? l.computedLineWidth[0]
              : l.computedLineWidth,
            lineOpacity: Array.isArray(l.computedLineOpacity)
              ? l.computedLineOpacity[0]
              : l.computedLineOpacity,
            tableId: c.tableId,
            boundingBox: G,
          })),
        h.length && (r[c.id] = h);
    }
    return r;
  };
  function w8(e, t, n) {
    return e
      ? t === 0 && n === 0
        ? e[2].type !== "none" || e[3].type !== "none"
        : t !== 0 && n !== 0
        ? e[0].type !== "none" && e[1].type !== "none"
        : t !== 0
        ? e[0].type !== "none"
        : n !== 0
        ? e[1].type !== "none"
        : false
      : false;
  }
  C.Image.prototype.graph = function (e, t, n) {
    let r = [];
    if (
      t.center.valueType !== Point || t.center.getDependencies().length !== 0 ||
      !t.radianAngle.isConstant || !t.width.isConstant ||
      !t.height.isConstant || !t.opacity.isConstant
    ) return r;
    let s = [],
      i = [],
      o = t.width.asValue() / 2,
      a = t.height.asValue() / 2,
      u = t.radianAngle.asValue();
    for (let c = -1; c <= 1; c++) {
      for (let l = -1; l <= 1; l++) {
        let [p, f] = t.center.asValue(),
          d = [
            p + c * o * Math.cos(u) + l * a * Math.sin(u),
            f - c * o * Math.sin(u) + l * a * Math.cos(u),
          ];
        w8(t.moveStrategy, c, l) && (s.push(d), i.push([c, l]));
      }
    }
    return r.push({
      segments: [s],
      scaleFactors: [i],
      graphMode: 4,
      color: Ra(this.userData, this.metaData),
      style: this.userData.style,
      poi: go(s),
      movablePointInfo: [],
      pointOpacity: 1,
    }),
      r;
  };
  function rw(e) {
    let t = [], n = [];
    for (let [r, s] of e) {
      !isNaN(r) && !isNaN(s)
        ? t.push(r, s)
        : (t.length >= 4 && n.push(t), t = []);
    }
    return t.length >= 4 && n.push(t), n;
  }
  function sw(...e) {
    return e.some((t) => isNaN(t));
  }
  function f1(e) {
    return Math.abs(e) < 5e-8;
  }
  var Sm = class extends $i {
    constructor(t, n, r) {
      let { tolerance: s, mathToPixels: i } = t;
      super({ tolerance: s, map: (o) => i.mapCoordinatePair(o) }),
        this.fn = n,
        this.mappedFn = (o) => i.mapY(n(o)),
        this.derivative = r,
        this.poiData = {
          zeros: { x: [], y: [] },
          intercept: { x: [], y: [] },
          extrema: { x: [], y: [] },
        },
        this.zeroBuffer = [],
        this.extremumBuffer = [];
    }
    getPOI() {
      return Si.pointsOfInterest
        ? (this.poiData.intercept = this.findIntercept(this.fn), this.poiData)
        : {
          zeros: { x: [], y: [] },
          intercept: { x: [], y: [] },
          extrema: { x: [], y: [] },
        };
    }
    addPoint(t) {
      this.segment.length === 0 && f1(t[1]) &&
      (this.poiData.zeros.x.push(t[0]), this.poiData.zeros.y.push(t[1])),
        this.updateZeroBuffer(t),
        this.updateExtremumBuffer(t),
        super.addPoint(t);
    }
    updateZeroBuffer(t) {
      let [n, r] = this.map ? this.map(t) : t;
      if (!isFinite(n) || !isFinite(r)) {
        this.zeroBuffer.length = 0;
        return;
      }
      switch (this.zeroBuffer.length) {
        case 0: {
          if (f1(t[1])) return;
          this.zeroBuffer.push(t);
          return;
        }
        case 1:
          if (t[1] === 0) {
            this.zeroBuffer.push(t);
            return;
          } else if (t[1] > 0 != this.zeroBuffer[0][1] > 0) {
            let s = QP(
              this.zeroBuffer[0][0],
              this.zeroBuffer[0][1],
              t[0],
              t[1],
              this.fn,
            );
            s &&
            (this.poiData.zeros.x.push(s[0]), this.poiData.zeros.y.push(s[1])),
              this.zeroBuffer.length = 0,
              this.zeroBuffer.push(t);
            return;
          } else {
            this.zeroBuffer.length = 0, this.zeroBuffer.push(t);
            return;
          }
        case 2: {
          if (t[1] === 0) return;
          if (t[1] > 0 != this.zeroBuffer[0][1] > 0) {
            let s = pf(
              this.zeroBuffer[0][0],
              this.zeroBuffer[0][1],
              this.zeroBuffer[1][0],
              this.zeroBuffer[1][1],
              t[0],
              t[1],
              this.fn,
            );
            s &&
            (this.poiData.zeros.x.push(s[0]), this.poiData.zeros.y.push(s[1])),
              this.zeroBuffer.length = 0,
              this.zeroBuffer.push(t);
            return;
          } else {
            this.zeroBuffer.length = 0, this.zeroBuffer.push(t);
            return;
          }
        }
      }
    }
    updateExtremumBuffer(t) {
      let [n, r] = this.map ? this.map(t) : t;
      if (!isFinite(n) || !isFinite(r)) {
        this.extremumBuffer.length = 0;
        return;
      }
      switch (this.extremumBuffer.length) {
        case 0: {
          this.extremumBuffer.push(t);
          return;
        }
        case 1: {
          t[1] === this.extremumBuffer[0][1] &&
          (this.extremumBuffer.length = 0), this.extremumBuffer.push(t);
          return;
        }
        case 2:
          if (t[1] === this.extremumBuffer[1][1]) {
            this.extremumBuffer.push(t);
            return;
          } else if (
            t[1] > this.extremumBuffer[1][1] !=
              this.extremumBuffer[1][1] > this.extremumBuffer[0][1]
          ) {
            let s = this.bisectExtremumUsingDerivative(
              this.extremumBuffer[0][0],
              this.extremumBuffer[0][1],
              this.extremumBuffer[1][0],
              this.extremumBuffer[1][1],
              t[0],
              t[1],
            );
            s &&
            (this.poiData.extrema.x.push(s[0]),
              this.poiData.extrema.y.push(s[1]),
              !tp(
                this.extremumBuffer[0][0],
                this.mappedFn(this.extremumBuffer[0][0]),
                s[0],
                this.mappedFn(s[0]),
                t[0],
                this.mappedFn(t[0]),
                this.mappedFn,
                this.ytolerance,
              ) && s[0] > this.segment[this.segment.length - 2] &&
              (this.pendingPoint = s)),
              this.extremumBuffer.shift(),
              this.extremumBuffer.push(t);
            return;
          } else {
            this.extremumBuffer.shift(), this.extremumBuffer.push(t);
            return;
          }
        case 3: {
          if (t[1] === this.extremumBuffer[1][1]) return;
          if (
            t[1] > this.extremumBuffer[1][1] !=
              this.extremumBuffer[1][1] > this.extremumBuffer[0][1]
          ) {
            let s,
              i = .5 * (this.extremumBuffer[1][0] + this.extremumBuffer[2][0]),
              o = this.fn(i);
            o === this.extremumBuffer[1][1]
              ? s = pf(
                this.extremumBuffer[0][0],
                this.extremumBuffer[0][1],
                this.extremumBuffer[1][0],
                this.extremumBuffer[1][1],
                t[0],
                t[1],
                this.fn,
              )
              : s = this.bisectExtremumUsingDerivative(
                this.extremumBuffer[1][0],
                this.extremumBuffer[1][1],
                i,
                o,
                this.extremumBuffer[2][0],
                this.extremumBuffer[2][1],
              ),
              s &&
              (this.poiData.extrema.x.push(s[0]),
                this.poiData.extrema.y.push(s[1])),
              this.extremumBuffer.shift(),
              this.extremumBuffer.shift(),
              this.extremumBuffer.push(t);
            return;
          } else {
            this.extremumBuffer.shift(),
              this.extremumBuffer.shift(),
              this.extremumBuffer.push(t);
            return;
          }
        }
      }
    }
    bisectExtremumUsingDerivative(t, n, r, s, i, o) {
      let a;
      if (this.derivative) {
        let u = this.derivative(t), c = this.derivative(i);
        if (
          !isNaN(u) && !isNaN(c) &&
          (s > n && u > 0 && c < 0 || s < n && u < 0 && c > 0)
        ) {
          let l = QP(t, u, i, c, this.derivative);
          l && (a = [l[0], this.fn(l[0])]);
        }
      }
      return a || (a = KD(t, n, r, s, i, o, this.fn)), a;
    }
    breakSegment() {
      this.zeroBuffer.length = 0,
        this.extremumBuffer.length = 0,
        this.flushPending(),
        this.segment.length > 2 &&
        (this.segments.push(this.segment),
          f1(this.segment[this.segment.length - 1]) &&
          (this.poiData.zeros.x.push(this.segment[this.segment.length - 2]),
            this.poiData.zeros.y.push(this.segment[this.segment.length - 1]))),
        this.segment = [];
    }
    findIntercept(t) {
      if (!t) return { x: [], y: [] };
      let n = t(0);
      return isFinite(n) ? { x: [0], y: [t(0)] } : { x: [], y: [] };
    }
    finish() {
      return {
        segments: this.getSegments(),
        resolved: true,
        poi: this.getPOI(),
      };
    }
  };
  var { floor: fw } = Math,
    mw = 1e4,
    Ub = 5,
    yw = (e, t, n) => ({ x: e, y: t, z: n }),
    gw = (e, t, n) => ({ x: n, y: e, z: t }),
    hw = (e, t, n) => ({ x: e, y: n, z: t }),
    Ab = class {
      constructor() {
        this.xmin = Dr.xmin;
        this.xmax = Dr.xmax;
        this.ymin = Dr.ymin;
        this.ymax = Dr.ymax;
        this.zmin = Dr.zmin;
        this.zmax = Dr.zmax;
      }
    },
    F8 = 0;
  function Ns() {
    return "result_" + F8++;
  }
  var bw;
  ((n) => (n.None = void 0, n.ComplexCoercion = "ComplexCoercion"))(
    bw || (bw = {}),
  );
  function V8() {
    return {
      zeros: { x: [], y: [] },
      extrema: { x: [], y: [] },
      intercept: { x: [], y: [] },
    };
  }
  function pw(e) {
    return { graphMode: 15, error: e, segments: [] };
  }
  function y1(e, t) {
    let n = e[0] + t.min * e[1],
      r = e[0] + t.max * e[1],
      s = {
        zeros: { x: [], y: [] },
        intercept: { x: [], y: [] },
        extrema: { x: [], y: [] },
      };
    if (!isFinite(n) || !isFinite(r)) {
      return { segments: [], poi: s, resolved: true };
    }
    let i = [[t.min, n, t.max, r]], o = -e[0] / e[1];
    return !isNaN(o) && o >= t.min && o <= t.max &&
      (s.zeros.x.push(o), s.zeros.y.push(0)),
      0 >= t.min && 0 <= t.max &&
      (s.intercept.x.push(0), s.intercept.y.push(e[0])),
      { segments: i, poi: s, resolved: true };
  }
  function B8(e, t) {
    let n = y1(e[0], t), r = y1(e[1], t);
    return n.segments.length && r.segments.length &&
        n.segments[0].length === 4 && r.segments[0].length === 4
      ? {
        segments: [[
          n.segments[0][1],
          r.segments[0][1],
          n.segments[0][3],
          r.segments[0][3],
        ]],
        resolved: true,
      }
      : { segments: [], resolved: true };
  }
  function G8(e, t) {
    let n = e(t);
    return { segments: [[...n, ...n]], resolved: true };
  }
  function xw(e, t, n) {
    let { mappedFn: r, jumpTolerance: s, screen: i } = n,
      [o, a] = e,
      [u, c] = t,
      l = Va(o, u),
      p = r(l),
      f = i.height;
    if (
      !(a < 0 && c < 0 && (a >= p || c >= p)) &&
      !(a > f && c > f && (a <= p || c <= p))
    ) return tp(o, a, l, p, u, c, r, s);
  }
  var m1 = (e, t, n) => {
      let { fn: r, mappedFn: s, jumpTolerance: i, accumulator: o } = n;
      if (!isFinite(i) || i <= 0) return;
      let a = xw(e, t, n);
      if (!a) return;
      let u = (t[0] - e[0]) / 10, c = [-u, u], l;
      for (let p = 0; p < c.length; p++) {
        let f = e[0] + c[p], d = s(f);
        isFinite(d) || ([f, d] = e, f = e[0], d = e[1]);
        let y = t[0] + c[p], g = s(y);
        if (isFinite(g) ? l = y : [y, g] = t, xw([f, d], [y, g], n)) {
          let [m, h] = a;
          o.addPoint([m, r(m)]), o.breakSegment(), o.addPoint([h, r(h)]);
          return;
        }
      }
      return l;
    },
    g1 = class {
      constructor(t, n, r) {
        let s = (i) => n.mathToPixels.mapY(t(i));
        this.derivative = r,
          this.accumulator = new Sm(n, t, r),
          this.fn = t,
          this.mathToPixels = n.mathToPixels,
          this.mappedFn = s,
          this.jumpTolerance = n.tolerance || 0,
          this.screen = n.screen;
      }
    };
  function Tw(e, t, n, r) {
    let s = n, i = e(s), o = t.mapY(i);
    return r > 0 && !isFinite(o) && (s = n + r, i = e(s), o = t.mapY(i)),
      r > 0 && !isFinite(o) && (s = n - r, i = e(s), o = t.mapY(i)),
      [s, i, o];
  }
  function h1(e, t, n) {
    let r = new g1(e, t, n),
      { mathToPixels: s, mappedFn: i } = r,
      o = t.nInitialSamples,
      [a, u, c] = Tw(e, s, t.min, 0);
    isFinite(c) && r.accumulator.addPoint([a, u]);
    for (let l = 1; l < o; l++) {
      let p = s.interpolateX(t.min, t.max, l / (o - 1)),
        f = l === o - 1 ? 0 : Math.abs(a - p) / 10,
        [d, y, g] = Tw(e, s, p, f);
      if (isFinite(g) && isFinite(c)) {
        let m = m1([a, c], [d, g], r);
        m !== void 0 && (d = m, y = e(d), g = s.mapY(y)),
          r.accumulator.addPoint([d, y]);
      } else if (isFinite(g) && !isFinite(c)) {
        let m = xs(a, c, d, g, i);
        if (m !== void 0) {
          m !== d && r.accumulator.addPoint([m, e(m)]);
          let h = m1([m, i(m)], [d, g], r);
          h !== void 0 && (d = h, y = e(d), g = s.mapY(y)),
            r.accumulator.addPoint([d, y]);
        }
      } else if (!isFinite(g) && isFinite(c)) {
        let m = xs(a, c, d, g, i);
        if (m !== void 0) {
          let h = m1([a, c], [m, i(m)], r);
          h !== void 0 && (m = h),
            m !== a && r.accumulator.addPoint([m, e(m)]),
            r.accumulator.breakSegment();
        }
      }
      a = d, u = y, c = g;
    }
    return r.accumulator.finish();
  }
  function k8(e) {
    let { fn: t, min: n, max: r } = e,
      s = Math.floor(n),
      i = Math.ceil(r),
      o = true;
    i - s + 1 > mw && (i = s + (mw - 1), o = false);
    let a = [];
    for (let u = s; u <= i; u++) {
      let c = t(u);
      !isFinite(u) || !isFinite(c) || a.push([u, c]);
    }
    return { segments: a, resolved: o };
  }
  function H8(e, t, n, r) {
    let s = t.min,
      i = t.max - t.min,
      o = t.rtoleranceMath,
      a = Math.floor(i / (Math.PI / n)),
      u,
      c,
      l;
    function p(f, d) {
      let y = d % 2 === 0 ? 1 : -1;
      if (!r && y === -1) return false;
      let g = d * (Math.PI / n), m = [s, s + 1, s + 2, s + 3], h = false;
      for (let x = 0, T = m.length; x < T; x++) {
        let b = f(m[x]), M = f(m[x] + g);
        if (
          isFinite(b) && isFinite(M) && (h = true),
            isFinite(b) !== isFinite(M) || Math.abs(b - y * M) > o
        ) return false;
      }
      return !!h;
    }
    for (u = 1; u <= a; u++) {
      if (p(e, u)) {
        for (l = u, c = 2; c * u <= a; c++) p(e, c * u) || (l = void 0);
        if (l) break;
      }
    }
    return l ? l * (Math.PI / n) : null;
  }
  function Ew(e) {
    return [e[1] * Math.cos(e[0]), e[1] * Math.sin(e[0])];
  }
  function Pb(e, t) {
    if (t.max < t.min) return { segments: [], resolved: true };
    if (t.parameterTransform) {
      let p = t.parameterTransform, f = e;
      e = (d) => f(p(d));
    }
    let { xtolerance: n, ytolerance: r, ztolerance: s, map: i } = t,
      o = new $i({ xtolerance: n, ytolerance: r, ztolerance: s, map: i }),
      a = 10,
      u = t.min,
      c = e(u);
    isFinite(c[0]) && isFinite(c[1]) && o.addPoint(c);
    let l = t.nInitialSamples;
    for (let p = 1; p < l; p++) {
      let f = p / (l - 1), d = (1 - f) * t.min + f * t.max, y = e(d);
      vm(e, u, c, d, y, a, o, t.screen), u = d, c = y;
    }
    return o.finish();
  }
  function z8(e, t) {
    if (e.length !== t.length) return false;
    for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return false;
    return true;
  }
  function vm(e, t, n, r, s, i, o, a) {
    if (r === t) return;
    let { xtolerance: u, ytolerance: c, ztolerance: l, map: p } = o,
      f = Va(t, r),
      d = e(f),
      y = p(n),
      g = p(s),
      m = p(d),
      h = isFinite(y[0]) && isFinite(y[1]) &&
        (y.length === 2 || isFinite(y[2])),
      x = isFinite(g[0]) && isFinite(g[1]) &&
        (g.length === 2 || isFinite(g[2])),
      T = isFinite(m[0]) && isFinite(m[1]) &&
        (m.length === 2 || isFinite(m[2]));
    if (i === 0 || f === t || f === r) {
      o.breakSegment(), x && o.addPoint(s);
      return;
    }
    if (!(!h && !x)) {
      if (h !== x) {
        let b = t, M = r, P = n, D = s;
        for (; t !== f && f !== r;) {
          T == h ? (t = f, n = d, y = m, h = T) : (r = f, s = d, g = m, x = T),
            f = t + (r - t) / 2,
            d = e(f),
            m = p(d),
            T = isFinite(m[0]) && isFinite(m[1]) &&
              (m.length === 2 || isFinite(m[2]));
        }
        h
          ? (vm(e, b, P, t, n, i - 1, o, a), o.breakSegment())
          : (o.breakSegment(), o.addPoint(s), vm(e, r, s, M, D, i - 1, o, a));
        return;
      }
      if (h && T && x) {
        let b = z8(y, g),
          M = to(
            m[0],
            m[1],
            m[2] || 0,
            y[0],
            y[1],
            y[2] || 0,
            g[0],
            g[1],
            g[2] || 0,
          ),
          P = M > .2 && M < .8 &&
            Math.abs(m[0] - (y[0] + M * (g[0] - y[0]))) <= u &&
            Math.abs(m[1] - (y[1] + M * (g[1] - y[1]))) <= c &&
            (y.length === 2 ||
              Math.abs(m[2] - (y[2] + M * (g[2] - y[2]))) <= l);
        if (b || P || a && U8(y, m, g, a)) {
          o.addPoint(s);
          return;
        }
      }
      vm(e, t, n, f, d, i - 1, o, a), vm(e, f, d, r, s, i - 1, o, a);
    }
  }
  function U8(e, t, n, { width: r, height: s }) {
    return e[0] < 0 && n[0] < 0 && (e[0] >= t[0] || n[0] >= t[0]) ||
      e[0] > r && n[0] > r && (e[0] <= t[0] || n[0] <= t[0]) ||
      e[1] < 0 && n[1] < 0 && (e[1] >= t[1] || n[1] >= t[1]) ||
      e[1] > s && n[1] > s && (e[1] <= t[1] || n[1] <= t[1]);
  }
  function q8() {
    return Wi({
      positions: [],
      normals: [],
      faces: [],
      uvs: [],
      resolved: true,
      extraAttrs: [],
    });
  }
  function d1(e, t, n, r, s, { isInequality: i }) {
    let o = e.fn, a;
    return t && !t.includes("z")
      ? a = hb(o, n, r, "z")
      : t && !t.includes("x")
      ? a = hb(o, n, r, "x")
      : t && !t.includes("y")
      ? a = hb(o, n, r, "y")
      : a = DL(o, n, r, s, { isInequality: i }),
      Wi(a);
  }
  function Iw(e, t, n, r, s) {
    let i = Pm(e, t, n, r, s, 0);
    return Wi(i);
  }
  function $8(e, t, n) {
    let r = e.fn,
      s = lb(
        (i, o) => r(i, o),
        new qe(t.xmin, t.xmax),
        new qe(t.ymin, t.ymax),
        new qe(t.zmin, t.zmax),
        n,
      );
    return Wi(s);
  }
  function Y8(e, t, n) {
    let r = e.fn,
      s = lb(
        (i, o) => r(i, o),
        new qe(t.ymin, t.ymax),
        new qe(t.zmin, t.zmax),
        new qe(t.xmin, t.xmax),
        n,
        [2, 0, 1],
      );
    return Wi(s);
  }
  function X8(e, t, n) {
    let r = e.fn,
      s = lb(
        (i, o) => r(o, i),
        new qe(t.zmin, t.zmax),
        new qe(t.xmin, t.xmax),
        new qe(t.ymin, t.ymax),
        n,
        [1, 2, 0],
      );
    return Wi(s);
  }
  function Z8(e, t, n, r, s, i) {
    let o = i ? Math.PI / 180 : 1,
      a = e.fn,
      u = Pm(
        (c, l) => [c * cos(l * o), c * sin(l * o), a(c, l)],
        t,
        n,
        r,
        s,
        0,
      );
    return Wi(u);
  }
  function W8(e, t, n, r, s, i) {
    let o = i ? Math.PI / 180 : 1,
      a = e.fn,
      u = Pm(
        (c, l) => {
          let p = a(c, l);
          return [p * cos(c * o), p * sin(c * o), l, p];
        },
        t,
        n,
        r,
        s,
        1,
      );
    return Wi(u);
  }
  function j8(e, t, n, r, s, i) {
    let o = i ? Math.PI / 180 : 1,
      a = e.fn,
      u = Pm(
        (c, l) => {
          let p = a(c, l);
          return [
            p * sin(l * o) * cos(c * o),
            p * sin(l * o) * sin(c * o),
            p * cos(l * o),
            p,
          ];
        },
        t,
        n,
        r,
        s,
        1,
      );
    return Wi(u);
  }
  function Wi(e) {
    let {
      positions: t,
      normals: n,
      faces: r,
      uvs: s,
      extraAttrs: i,
      resolved: o,
    } = e;
    return {
      guid: Ns(),
      positions: new Float32Array(t),
      normals: new Float32Array(n),
      faces: new Uint32Array(r),
      uvs: new Float32Array(s),
      resolved: o,
      extraAttrs: new Float32Array(i),
    };
  }
  function Pw(e) {
    for (let t of e) if (t !== 0) return false;
    return true;
  }
  function dw(e, t) {
    let { min: n, max: r, mathToPixels: s, nInitialSamples: i } = t,
      o = s.interpolateX(n, r, 0),
      a = e(o),
      u = Pw(a),
      c = false,
      l = [];
    for (let p = 1; p < i; p++) {
      let f = s.interpolateX(n, r, p / (i - 1)), d = e(f), y = Pw(d);
      if (u) {
        o = f, a = d, y || (u = false);
        continue;
      }
      if (y) {
        c ? (u = true, c = false) : c = true;
        continue;
      }
      let g = QD(o, a, f, d, e);
      g !== void 0 && l.push(g), o = f, a = d;
    }
    return l;
  }
  function Mw(e) {
    if (!e) return false;
    let t = e.viewport.xmin,
      n = e.viewport.xmax,
      r = e.viewport.ymin,
      s = e.viewport.ymax;
    return !(!isFinite(t) || !isFinite(n) || n <= t || !isFinite(r) ||
      !isFinite(s) || s <= r || !isFinite(e.screen.width) ||
      e.screen.width <= 0 || !isFinite(e.screen.height) ||
      e.screen.height <= 0);
  }
  function zC(e, t) {
    let n = t - e;
    return 1 + Math.ceil(n / (n / 1e3));
  }
  var bo = .001, fc = new sc(SC(), SC());
  function Td(e, t, n) {
    var L, w, G, k, Z, F, Y, re, Ee;
    let {
        viewport: r,
        screen: s,
        xAxisScale: i,
        yAxisScale: o,
        degreeMode: a,
      } = e,
      u = a ? Math.PI / 180 : 1,
      c = e.viewport.xmin,
      l = e.viewport.xmax,
      p = e.viewport.ymin,
      f = e.viewport.ymax,
      d = (L = e.viewport.zmin) != null ? L : Dr.zmin,
      y = (w = e.viewport.zmax) != null ? w : Dr.zmax,
      g = ((G = t.domain) == null ? void 0 : G.type) === "2d",
      { uMin: m, uMax: h, vMin: x, vMax: T } =
        ((k = t.domain) == null ? void 0 : k.type) === "2d"
          ? t.domain
          : { uMin: 0, uMax: 1, vMin: 0, vMax: 1 },
      b = t.lineWidth;
    if (t.willConvertTo3D || b > 3) {
      let he = t.willConvertTo3D ? 200 : e.screen.width,
        K = b * (l - c) / he,
        Oe = t.willConvertTo3D ? 200 : e.screen.height,
        te = b * (f - p) / Oe;
      c -= K, l += K, p -= te, f += te;
    }
    let P = 1 / 4,
      D = t.domainBound,
      S,
      O = sc.fromRects(gb(r), yb(s), { xAxisScale: i, yAxisScale: o }),
      _ = { xmin: c, xmax: l, ymin: p, ymax: f, zmin: d, zmax: y };
    switch (t.graphMode) {
      case 1:
        switch (S = Gn(bi([p, f]), D), S.type) {
          case "empty":
            return false;
          case "interval":
            p = S.bounds[0], f = S.bounds[1];
        }
        let he = Math.max(
            Ub,
            1 + Math.ceil(Math.abs(O.mapY(f) - O.mapY(p)) / P),
          ),
          K = new sc(O.yScale, O.xScale);
        return {
          min: p,
          max: f,
          tolerance: P,
          nInitialSamples: he,
          mathToPixels: K,
          screen: { width: s.height, height: s.width },
        };
      case 2: {
        switch (S = Gn(bi([c, l]), D), S.type) {
          case "empty":
            return false;
          case "interval":
            c = S.bounds[0], l = S.bounds[1];
        }
        let Oe = Math.max(
          Ub,
          1 + Math.ceil(Math.abs(O.mapX(l) - O.mapX(c)) / P),
        );
        return {
          min: c,
          max: l,
          tolerance: P,
          nInitialSamples: Oe,
          mathToPixels: O,
          screen: s,
        };
      }
      case 6: {
        let Oe = e.degreeMode ? Math.PI / 180 : 1;
        if (((Z = t.domain) == null ? void 0 : Z.type) !== "1d") {
          throw new Error("Expected polar graph to have domain");
        }
        let { min: te, max: Ze } = t.domain;
        switch (S = Gn(bi([te, Ze]), D), S.type) {
          case "empty":
            return false;
          case "interval":
            te = S.bounds[0], Ze = S.bounds[1];
        }
        let dt = Math.max(
            Ub,
            1 +
              Math.min(
                Math.ceil(Oe * Math.abs(Ze - te) / (2 * Math.PI) * 1e3),
                12e3,
              ),
          ),
          me = Math.abs(O.mapX(l) - O.mapX(c)),
          J = Math.abs(O.mapY(f) - O.mapY(p)),
          W = Math.hypot(me, J),
          be = Math.hypot(l - c, f - p) / W,
          ue = {
            min: te,
            max: Ze,
            screen: s,
            nInitialSamples: dt,
            xtolerance: P,
            ytolerance: P,
            rtoleranceMath: be,
            map: ([_e, At]) => O.mapCoordinatePair(Ew([_e, At])),
          };
        if (!t.domain.isExplicit) {
          let _e = H8(n, ue, Oe, t.operator === "=");
          _e &&
            (ue.max = ue.min + _e,
              ue.nInitialSamples = Math.max(
                Ub,
                1 +
                  Math.min(
                    Math.ceil(
                      Oe * Math.abs(ue.max - ue.min) / (2 * Math.PI) * 1e3,
                    ),
                    12e3,
                  ),
              ));
        }
        return ue;
      }
      case 5:
      case 100: {
        let Oe = { min: 0, max: 1 },
          { min: te, max: Ze } =
            ((F = t.domain) == null ? void 0 : F.type) === "1d" ? t.domain : Oe;
        switch (S = Gn(bi([te, Ze]), D), S.type) {
          case "empty":
            return false;
          case "interval":
            te = S.bounds[0], Ze = S.bounds[1];
        }
        let dt;
        return (!isFinite(te) || !isFinite(Ze)) &&
          (dt = Cw, te = qb(te), Ze = qb(Ze)),
          {
            min: te,
            max: Ze,
            screen: s,
            nInitialSamples: zC(te, Ze),
            xtolerance: P,
            ytolerance: P,
            ztolerance: P,
            parameterTransform: dt,
            map: ([me, J]) => O.mapCoordinatePair([me, J]),
          };
      }
      case 8:
        return {
          xmin: c,
          xmax: l,
          ymin: p,
          ymax: f,
          mathToPixels: O,
          tolerance: P,
        };
      case 106:
        return { ..._, u: new qe(c, l), v: new qe(p, f) };
      case 120:
      case 122:
      case 107:
        return { ..._, u: new qe(p, f), v: new qe(d, y) };
      case 121:
      case 123:
      case 108:
        return { ..._, u: new qe(c, l), v: new qe(d, y) };
      case 109:
        return {
          ..._,
          u: new qe(m, g ? h : Dr.xmax),
          v: new qe(x, g ? T : 2 * Math.PI),
        };
      case 124:
      case 110: {
        let { min: Oe, max: te } =
          ((Y = t.domain) == null ? void 0 : Y.type) === "1d"
            ? t.domain
            : { min: 0, max: 2 * Math.PI };
        return { ..._, u: new qe(Oe, te), v: new qe(d, y) };
      }
      case 211: {
        let { min: Oe, max: te } =
          ((re = t.domain) == null ? void 0 : re.type) === "1d"
            ? t.domain
            : { min: 0, max: 2 * Math.PI / u };
        return {
          ...{ xmin: Oe, xmax: te, ymin: d, ymax: y },
          u: new qe(Oe, te),
          v: new qe(d, y),
          mathToPixels: fc,
          tolerance: bo,
        };
      }
      case 212: {
        let Oe = g ? h : 2 * Math.PI / u, te = g ? T : Math.PI / u;
        return {
          ...{ xmin: m, xmax: Oe, ymin: x, ymax: te },
          u: new qe(m, Oe),
          v: new qe(x, te),
          mathToPixels: fc,
          tolerance: bo,
        };
      }
      case 215:
      case 214:
        return {
          ...{ xmin: m, xmax: h, ymin: x, ymax: T },
          u: new qe(m, h),
          v: new qe(x, x),
          mathToPixels: fc,
          tolerance: bo,
        };
      case 213: {
        let Oe = g ? h : Dr.xmax, te = g ? T : 2 * Math.PI / u;
        return {
          ...{ xmin: m, xmax: Oe, ymin: x, ymax: te },
          u: new qe(m, Oe),
          v: new qe(x, te),
          mathToPixels: fc,
          tolerance: bo,
        };
      }
      case 111:
        return {
          ..._,
          u: new qe(m, g ? h : 2 * Math.PI / u),
          v: new qe(x, g ? T : Math.PI / u),
        };
      case 117:
      case 118:
      case 119:
      case 129:
      case 130:
      case 103:
      case 112:
      case 126:
      case 113:
      case 127:
      case 210:
      case 114:
        return { ..._, u: new qe(m, h), v: new qe(x, T) };
      case 200:
      case 201:
      case 202:
      case 206:
      case 205:
      case 203:
      case 204:
      case 207:
      case 208: {
        if (
          t.graphMode === 200 &&
          (t.slice_coordinate === "z" || t.slice_coordinate === "_implicit")
        ) {
          return {
            xmin: c,
            xmax: l,
            ymin: p,
            ymax: f,
            mathToPixels: O,
            tolerance: bo,
          };
        }
        if (
          t.graphMode === 201 &&
          (t.slice_coordinate === "x" || t.slice_coordinate === "_implicit")
        ) {
          return {
            ...{ xmin: p, xmax: f, ymin: d, ymax: y },
            mathToPixels: fc,
            tolerance: bo,
          };
        }
        if (
          t.graphMode === 202 &&
          (t.slice_coordinate === "y" || t.slice_coordinate === "_implicit")
        ) {
          return {
            ...{ xmin: c, xmax: l, ymin: d, ymax: y },
            mathToPixels: fc,
            tolerance: bo,
          };
        }
        let { min: Oe, max: te } =
          ((Ee = t.domain) == null ? void 0 : Ee.type) === "1d"
            ? t.domain
            : { min: 0, max: 2 * Math.PI };
        return {
          x: new qe(c, l),
          y: new qe(p, f),
          z: new qe(d, y),
          t: new qe(Oe, te),
          u: new qe(m, h),
          v: new qe(x, T),
        };
      }
      case 209:
        return t.slice_coordinate === "z"
          ? {
            xmin: c,
            xmax: l,
            ymin: p,
            ymax: f,
            mathToPixels: O,
            tolerance: bo,
          }
          : t.slice_coordinate === "x"
          ? {
            ...{ xmin: p, xmax: f, ymin: d, ymax: y },
            mathToPixels: fc,
            tolerance: bo,
          }
          : t.slice_coordinate === "y"
          ? {
            ...{ xmin: c, xmax: l, ymin: d, ymax: y },
            mathToPixels: fc,
            tolerance: bo,
          }
          : t.slice_coordinate === "_implicit"
          ? { ..._, u: new qe(c, l), v: new qe(p, f) }
          : false;
      default:
        return false;
    }
  }
  function Cw(e) {
    return Math.sinh(10 * e) / (1 - e * e);
  }
  function qb(e) {
    if (e === 1 / 0) return 1;
    if (e === -1 / 0) return -1;
    let t = Math.asinh(e);
    return 2 * t / (10 + Math.sqrt(100 + 4 * t * t));
  }
  function Nb(e) {
    let {
        viewState: t,
        graphInfo: n,
        compiled: r,
        maxOverride: s,
        showPoint: i,
      } = e,
      o = r.fn,
      a = Td(t, n, o),
      u;
    if (!a) u = { segments: [], resolved: true };
    else {
      let { min: p, max: f } = a;
      u = k8({
        fn: o,
        min: Math.max(p, 0),
        max: s !== void 0 ? Math.min(s, f) : f,
      });
    }
    let { points: c, droppedIndices: l } = Cm(u.segments);
    return {
      segments: [c],
      droppedIndices: l,
      graphMode: 3,
      color: n.color,
      style: n.pointStyle,
      poi: go(u.segments),
      resolved: u.resolved,
      showPoint: i,
    };
  }
  function J8(e) {
    switch (e) {
      case 120:
      case 122:
        return 107;
      case 121:
      case 123:
        return 108;
      case 124:
        return 110;
      case 126:
        return 112;
      case 127:
        return 113;
      default:
        return e;
    }
  }
  function cu(e) {
    var g, m, h, x, T, b, M, P, D;
    let { viewState: t, graphInfo: n, compiled: r, derivative: s } = e,
      i = r.fn,
      { degreeMode: o } = t,
      a = o ? Math.PI / 180 : 1,
      u = Td(t, n, i),
      c,
      l,
      p,
      f = J8(n.graphMode),
      d = t.xAxisScale === "linear" && t.yAxisScale === "linear";
    if (!u) c = { segments: [], resolved: true };
    else {
      switch (f) {
        case 1:
        case 2:
          let S = s ? s.fn : void 0;
          c = n.isLinear && d && Bo(n.linearCoefficients)
            ? y1(n.linearCoefficients, u)
            : h1(i, u, S);
          break;
        case 6:
          c = Pb((k) => [k, i(k)], u);
          break;
        case 8:
          c = hm(i, u);
          break;
        case 5:
          u.max === u.min
            ? c = G8(i, u.min)
            : c = n.isLinear && d && Bo(n.linearCoefficients)
              ? B8(n.linearCoefficients, u)
              : Pb(i, u);
          break;
        case 100:
          let O = r.fn,
            { min: _, max: L } =
              ((g = n.domain) == null ? void 0 : g.type) === "1d"
                ? n.domain
                : { min: 0, max: 1 };
          if (!isFinite(_) || !isFinite(L)) {
            _ = qb(_), L = qb(L);
            let k = O;
            O = (Z) => k(Cw(Z));
          }
          let w = new qe(_, L), G = Ml(O, w, n.resolution, t);
          return {
            graphMode: 100,
            guid: Ns(),
            points: G,
            color: n.color,
            thickness: n.lineWidth,
          };
        case 112:
        case 113:
        case 130:
        case 103:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111: {
          let k = u,
            { u: Z, v: F } = k,
            Y = f === 112 || f === 113,
            re = n.graphMode === 122 || n.graphMode === 123,
            Ee = Y ? Im : re ? 2 : _L,
            { resolution: he } = n,
            K = he === void 0 || isNaN(he) ? Ee : clamp(fw(he), 2, 100),
            Oe = bi([Z.min, Z.max]).type !== "empty" &&
              bi([F.min, F.max]).type !== "empty",
            te;
          switch (Oe && f) {
            case 103: {
              let me = r.fn;
              te = Iw(me, k, Z, F, K);
              break;
            }
            case 130: {
              te = Iw(
                (J, W) => {
                  let [Ge, be] = r.fn(J, W);
                  return [Ge, be, 0];
                },
                k,
                Z,
                F,
                K,
              );
              break;
            }
            case 106:
              te = $8(r, k, K);
              break;
            case 107:
              te = Y8(r, k, K);
              break;
            case 108:
              te = X8(r, k, K);
              break;
            case 109:
              te = Z8(r, k, Z, F, K, o);
              break;
            case 110:
              te = W8(r, k, Z, F, K, o);
              break;
            case 111:
              te = j8(r, k, Z, F, K, o);
              break;
            case 112:
            case 113:
              te = d1(r, e.dependencies, e.gradient, u, K, {
                isInequality: (m = e.isImplicit3dInequality) != null
                  ? m
                  : false,
              });
              break;
            case false:
              te = q8();
              break;
          }
          let Ze = n.graphMode === 113 || n.graphMode === 127;
          return {
            meshData: te,
            resolved: te.resolved,
            color: n.color,
            surfaceOpacity: Ze ? 1 : (h = n.surfaceOpacity) != null ? h : 1,
            uvArgs: (x = vi[n.graphMode]) != null ? x : [],
            extraMeshArgs: (T = Ol[n.graphMode]) != null ? T : [],
            graphMode: f,
            compiled: r,
            restrictionShader: e.restrictionShader3d,
          };
        }
        case 200:
        case 201:
        case 202:
        case 211:
        case 206:
        case 205:
        case 203:
        case 204:
        case 213:
        case 207:
        case 208:
        case 212:
        case 214:
        case 215:
        case 209: {
          let k = (J, W, Ge) => {
              let be = (Fm, Vm) => {
                  let Al = Ge(Fm, Vm);
                  return isNaN(Al[0]) || isNaN(Al[1]) || isNaN(Al[2])
                    ? NaN
                    : J(Fm, Vm);
                },
                ue = t.viewport,
                { xmin: _e, xmax: At, ymin: ze, ymax: Ce, zmin: _t, zmax: bc } =
                  ue,
                xc = (_e + At) / 2,
                nx = (ze + Ce) / 2,
                rx = (_t + bc) / 2,
                OF = At - _e,
                NF = Ce - ze,
                RF = bc - _t,
                $1 = hm(be, {
                  ...W,
                  map3d: (Fm, Vm) => {
                    let [Al, Y1, X1] = Ge(Fm, Vm);
                    return isNaN(Al) || isNaN(Y1) || isNaN(X1)
                      ? [NaN, NaN, NaN]
                      : [(Al - xc) / OF, (Y1 - nx) / NF, (X1 - rx) / RF];
                  },
                });
              return {
                segments: $1.segments,
                resolved: $1.resolved,
                graphMode: 8,
                color: n.color,
                lineWidth: n.lineWidth,
                lineOpacity: n.lineOpacity,
                listIndex: n.listIndex,
                operator: n.operator,
                compiled: r,
                poi: {},
              };
            },
            Z = r.fn,
            F = (b = n.slice_value) != null ? b : 0,
            Y = (M = n.slice_coordinate) != null ? M : "",
            re = u,
            Ee,
            he,
            K,
            Oe = true,
            te = (J, W) => {
              let be = k(J, u, (ze, Ce) => {
                  let { x: _t, y: bc, z: xc } = W(ze, Ce, J(ze, Ce));
                  return [_t, bc, xc];
                }),
                ue = n.lineWidth,
                _e = kb(be, t, ue, F),
                At = _e.points;
              for (let ze = 0; ze < At.length / 3; ze++) {
                let Ce = At[3 * ze],
                  _t = At[3 * ze + 1],
                  bc = At[3 * ze + 2],
                  { x: xc, y: nx, z: rx } = W(Ce, _t, bc);
                At[3 * ze] = xc, At[3 * ze + 1] = nx, At[3 * ze + 2] = rx;
              }
              return _e;
            },
            Ze = (J, W) => {
              let Ge = [];
              for (let _e = 0; _e < J.segments.length; _e++) {
                let At = J.segments[_e];
                for (let ze = 0; ze < At.length / 2; ze++) {
                  let Ce = At[2 * ze], _t = At[2 * ze + 1];
                  Ge.push(W(Ce, _t));
                }
                _e < J.segments.length - 1 && Ge.push([NaN, NaN, 0]);
              }
              let be = n.lineWidth, ue = t.viewport;
              return Dm(Ge, ue, be);
            },
            dt = u,
            me = (J, W) => {
              var be;
              let Ge = k(J, dt, W);
              return Oe = (be = Ge.resolved) != null ? be : true, Ze(Ge, W);
            };
          switch (f) {
            case 200: {
              if (Y === "z") return te((W, Ge) => Z(W, Ge) - F, yw);
              if (Y === "_implicit") {
                let W = n.slice_function.fn;
                K = me(
                  (ue, _e) => W(ue, _e, Z(ue, _e)),
                  (ue, _e) => [ue, _e, Z(ue, _e)],
                );
                break;
              }
              let J = Y === "x";
              Ee = J ? re.y : re.x,
                he = J ? (W) => [F, W, Z(F, W)] : (W) => [W, F, Z(W, F)],
                K = Ml(he, Ee, n.resolution, t);
              break;
            }
            case 201: {
              if (Y === "x") return te((W, Ge) => Z(W, Ge) - F, gw);
              if (Y === "_implicit") {
                let W = n.slice_function.fn;
                K = me(
                  (ue, _e) => W(Z(ue, _e), ue, _e),
                  (ue, _e) => [Z(ue, _e), ue, _e],
                );
                break;
              }
              let J = Y === "y";
              Ee = J ? re.z : re.y,
                he = J ? (W) => [Z(F, W), F, W] : (W) => [Z(W, F), W, F],
                K = Ml(he, Ee, n.resolution, t);
              break;
            }
            case 202: {
              if (Y === "y") return te((W, Ge) => Z(W, Ge) - F, hw);
              if (Y === "_implicit") {
                let W = n.slice_function.fn;
                K = me(
                  (ue, _e) => W(ue, Z(ue, _e), _e),
                  (ue, _e) => [ue, Z(ue, _e), _e],
                );
                break;
              }
              let J = Y === "x";
              Ee = J ? re.z : re.x,
                he = J ? (W) => [F, Z(F, W), W] : (W) => [W, Z(W, F), F],
                K = Ml(he, Ee, n.resolution, t);
              break;
            }
            case 209: {
              let J = r.fn;
              if (Y === "x") return te((W, Ge) => J(F, W, Ge), gw);
              if (Y === "y") return te((W, Ge) => J(W, F, Ge), hw);
              if (Y === "z") return te((W, Ge) => J(W, Ge, F), yw);
              if (Y === "_implicit") {
                let { resolution: W } = n,
                  Ge = W === void 0 || isNaN(W) ? Im : clamp(fw(W), 2, 100);
                K = AL(r.fn, n.slice_function.fn, u, Ge);
                let be = t.viewport, ue = [];
                for (let _e = 0; _e < K.length / 3; _e++) {
                  ue.push([K[3 * _e], K[3 * _e + 1], K[3 * _e + 2]]);
                }
                K = Dm(ue, be, n.lineWidth);
                break;
              } else {throw new Error(
                  "Programming Error: unexpected slice coordinate",
                );}
            }
            case 206:
            case 205: {
              let J = Y === "z";
              Ee = J ? re.t : re.z,
                he = J ? (W) => [Z(W, F), W, F] : (W) => [Z(F, W), F, W],
                K = HC(he, Ee, n.resolution, t);
              break;
            }
            case 211: {
              let J = r.fn, W;
              switch (Y) {
                case "x":
                  W = (ze, Ce) => J(ze, Ce) * cos(ze * a) - F;
                  break;
                case "y":
                  W = (ze, Ce) => J(ze, Ce) * sin(ze * a) - F;
                  break;
                case "r":
                  W = (ze, Ce) => J(ze, Ce) - F;
                  break;
                case "_implicit":
                  let At = n.slice_function.fn;
                  W = (ze, Ce) =>
                    At(
                      J(ze, Ce) * cos(ze * a),
                      J(ze, Ce) * sin(ze * a),
                      Ce,
                      J(ze, Ce),
                      ze,
                    );
                  break;
                default:
                  throw new Error("Programming Error: bad slice");
              }
              let Ge = Y === "x",
                be = Y === "y",
                ue = (
                  At,
                  ze,
                ) => [
                  Ge ? F : J(At, ze) * cos(At * a),
                  be ? F : J(At, ze) * sin(At * a),
                  ze,
                ],
                _e = k(W, dt, ue);
              K = Ze(_e, ue), Oe = (P = _e.resolved) != null ? P : true;
              break;
            }
            case 213: {
              let J = Y === "x", W = Y === "y", Ge = Y === "z", be = r.fn, ue;
              switch (Y) {
                case "x":
                  ue = (Ce, _t) => Ce * cos(_t * a) - F;
                  break;
                case "y":
                  ue = (Ce, _t) => Ce * sin(_t * a) - F;
                  break;
                case "z":
                  ue = (Ce, _t) => be(Ce, _t) - F;
                  break;
                case "_implicit":
                  let ze = n.slice_function.fn;
                  ue = (Ce, _t) =>
                    ze(Ce * cos(_t * a), Ce * sin(_t * a), be(Ce, _t), Ce, _t);
                  break;
                default:
                  throw new Error("Programming Error: bad slice");
              }
              let _e = (
                  ze,
                  Ce,
                ) => [
                  J ? F : ze * cos(Ce * a),
                  W ? F : ze * sin(Ce * a),
                  Ge ? F : be(ze, Ce),
                ],
                At = k(ue, dt, _e);
              K = Ze(At, _e);
              break;
            }
            case 212: {
              let J = Y === "x", W = Y === "y", Ge = Y === "z", be = r.fn, ue;
              switch (Y) {
                case "x":
                  ue = (Ce, _t) => be(Ce, _t) * sin(_t * a) * cos(Ce * a) - F;
                  break;
                case "y":
                  ue = (Ce, _t) => be(Ce, _t) * sin(_t * a) * sin(Ce * a) - F;
                  break;
                case "z":
                  ue = (Ce, _t) => be(Ce, _t) * cos(_t * a) - F;
                  break;
                case "rho":
                  ue = (Ce, _t) => be(Ce, _t) - F;
                  break;
                case "_implicit":
                  let ze = n.slice_function.fn;
                  ue = (Ce, _t) =>
                    ze(
                      be(Ce, _t) * sin(_t * a) * sin(Ce * a),
                      be(Ce, _t) * sin(_t * a) * cos(Ce * a),
                      be(Ce, _t) * cos(_t * a),
                      be(Ce, _t),
                      Ce,
                      _t,
                    );
                  break;
                default:
                  throw new Error("Programming Error: bad slice");
              }
              let _e = (
                  ze,
                  Ce,
                ) => [
                  J ? F : be(ze, Ce) * sin(Ce * a) * cos(ze * a),
                  W ? F : be(ze, Ce) * sin(Ce * a) * sin(ze * a),
                  Ge ? F : be(ze, Ce) * cos(Ce * a),
                ],
                At = k(ue, dt, _e);
              K = Ze(At, _e), Oe = (D = At.resolved) != null ? D : true;
              break;
            }
            case 215:
            case 214: {
              let J = f === 214 ? r.fn : (Ge, be) => {
                  let [ue, _e] = r.fn(Ge, be);
                  return [ue, _e, 0];
                },
                W;
              switch (Y) {
                case "x":
                  W = (be, ue) => J(be, ue)[0] - F;
                  break;
                case "y":
                  W = (be, ue) => J(be, ue)[1] - F;
                  break;
                case "z":
                  W = (be, ue) => J(be, ue)[2] - F;
                  break;
                case "u":
                  W = (be, ue) => be - F;
                  break;
                case "v":
                  W = (be, ue) => ue - F;
                  break;
                case "_implicit":
                  let Ge = n.slice_function.fn;
                  W = (be, ue) => {
                    let [_e, At, ze] = J(be, ue);
                    return Ge(_e, At, ze, be, ue);
                  };
                  break;
                default:
                  throw new Error("Programming Error: bad slice");
              }
              K = me(W, J);
              break;
            }
            case 203:
            case 204: {
              let J = Y === "r";
              Ee = J ? re.v : re.u,
                he = J ? (W) => [F, W, Z(F, W)] : (W) => [W, F, Z(W, F)],
                K = HC(he, Ee, n.resolution, t);
              break;
            }
            case 207:
            case 208: {
              let J = Y === "theta";
              Ee = J ? re.v : re.u,
                he = J ? (W) => [Z(F, W), F, W] : (W) => [Z(W, F), W, F],
                K = SL(he, Ee, n.resolution, t);
              break;
            }
          }
          return {
            graphMode: 100,
            guid: Ns(),
            points: K,
            resolved: Oe,
            color: n.color,
            thickness: n.lineWidth,
          };
        }
        default:
          throw new Error("Programming Error: unexpected graphmode " + f);
      }
      p = c.poi;
    }
    if (
      (!p ||
        p.zeros.x.length + p.extrema.x.length + p.intercept.x.length > 250) &&
      (p = V8()), f === 1
    ) {
      for (let S in p) {
        if (!p.hasOwnProperty(S)) continue;
        let O = S;
        l = p[O].y, p[O].y = p[O].x, p[O].x = l;
      }
    }
    let y = {
      segments: c.segments,
      resolved: c.resolved,
      graphMode: f,
      color: n.color,
      style: n.lineStyle,
      lineWidth: n.lineWidth,
      lineOpacity: n.lineOpacity,
      listIndex: n.listIndex,
      operator: n.operator,
      poi: p,
      compiled: r,
    };
    if (f === 6) {
      let S = u;
      y.sampledDomain = { min: S.min, max: S.max };
    }
    return c.fillSegments && (y.fillSegments = c.fillSegments), y;
  }
  function Q8(e, t, n) {
    let r, s, i, o, a = [], u = null;
    switch (n) {
      case 6:
        u = Ew;
        break;
      case 1:
        u = function (c) {
          return [c[1], c[0]];
        };
        break;
    }
    for (r = 0; r < e.length; r++) {
      for (o = e[r], s = 0; s < o.length; s += 2) {
        i = [o[s], o[s + 1]], u && (i = u(i)), a.push(i[0], i[1]);
      }
    }
    for (r = t.length - 1; r >= 0; r--) {
      for (o = t[r], s = o.length - 2; s >= 0; s -= 2) {
        i = [o[s], o[s + 1]], u && (i = u(i)), a.push(i[0], i[1]);
      }
    }
    return a;
  }
  function Hb(e, t, n) {
    let r = (l) => l[l.length - 2],
      s = [],
      i = 0,
      o = 0,
      a = [],
      u = [],
      c = -1 / 0;
    for (;;) {
      for (; o < e.length && !(e[o].length >= 2);) o += 1;
      for (; i < t.length && !(t[i].length >= 2);) i += 1;
      (o >= e.length || e[o][0] > c) && (i >= t.length || t[i][0] > c) &&
        (a.length > 0 && u.length > 0 && s.push(Q8(a, u, n)),
          a = [],
          u = [],
          c = Math.max(c, o < e.length ? r(e[o]) : 1 / 0),
          c = Math.max(c, i < t.length ? r(t[i]) : 1 / 0));
      let l = false;
      if (
        o < e.length && e[o][0] <= c &&
        (c = Math.max(c, r(e[o])), a.push(e[o]), o += 1, l = true),
          i < t.length && t[i][0] <= c &&
          (c = Math.max(c, r(t[i])), u.push(t[i]), i += 1, l = true),
          !l
      ) break;
    }
    return s;
  }
  function Cm(e) {
    let t = [], n = {};
    for (let r = 0; r < e.length; r++) {
      let s = e[r], [i, o] = s;
      !isNaN(i) && !isNaN(o) ? t.push(s) : n[r] = true;
    }
    return { points: t, droppedIndices: n };
  }
  var vi = {
      [8]: ["x", "y"],
      [106]: ["x", "y"],
      [120]: ["y", "z"],
      [122]: ["y", "z"],
      [107]: ["y", "z"],
      [121]: ["x", "z"],
      [123]: ["x", "z"],
      [108]: ["x", "z"],
      [109]: ["r", "theta"],
      [124]: ["theta", "z"],
      [110]: ["theta", "z"],
      [111]: ["theta", "phi"],
      [130]: ["u", "v"],
      [103]: ["u", "v"],
      [126]: ["x", "y"],
      [112]: ["x", "y", "z"],
      [113]: ["x", "y", "z"],
      [127]: ["x", "y"],
      [201]: ["y", "z"],
      [202]: ["x", "z"],
      [200]: ["x", "y"],
      [206]: ["theta", "z"],
      [205]: ["theta", "z"],
      [211]: ["theta", "z"],
      [203]: ["r", "theta"],
      [204]: ["r", "theta"],
      [213]: ["r", "theta"],
      [207]: ["theta", "phi"],
      [208]: ["theta", "phi"],
      [212]: ["theta", "phi"],
      [214]: ["u", "v"],
      [215]: ["u", "v"],
      [209]: ["x", "y", "z"],
      [210]: ["x", "y", "z"],
    },
    Ol = { [110]: ["r"], [111]: ["rho"] };
  function Voe(e) {
    return e.graphMode === 3 || e.graphMode === 25 || uu(e.graphMode);
  }
  function Boe(e) {
    return uu(e.graphMode);
  }
  var Id = class {
      constructor(
        {
          enableGeometry: t,
          enable3d: n,
          scales: r,
          includeFunctionParametersInRandomSeed: s,
          isComplexEnabled: i,
          customRegressions: o,
          isRecursionEnabled: a,
        },
      ) {
        this._isGeometry = false;
        this._is3dProduct = false;
        this._isGeometry = t,
          this._is3dProduct = n,
          this._scales = r,
          this._includeFunctionParametersInRandomSeed = s,
          this._isComplexEnabled = !!i,
          this._customRegressions = o,
          this._isRecursionEnabled = !!a;
      }
      isGeometryEnabled() {
        return this._isGeometry;
      }
      is3dProduct() {
        return this._is3dProduct;
      }
      is3dPolicy() {
        return false;
      }
      isComplexEnabled() {
        return this._isComplexEnabled;
      }
      isRecursionEnabled() {
        return this._isRecursionEnabled;
      }
      polygonUnsupportedPreferTriangle() {
        return false;
      }
      areAllScalesLinear() {
        return this._scales
          ? this._scales.xAxisScale === "linear" &&
            this._scales.yAxisScale === "linear"
          : true;
      }
      assignmentForbidden(t) {
        return t === "x" || t === "y" || t === "theta" || t === "index" ||
          t === "dt" || t.slice(0, 3) === "tmp" || tt.hasOwnProperty(t) ||
          this.isComplexEnabled() && t === br;
      }
      isValidSlider(t) {
        return t === "x" || t === "y"
          ? true
          : !(t.slice(0, 3) === "ans" || t.slice(0, 6) === "idref_" ||
            this.assignmentForbidden(t));
      }
      sliderVariables(t) {
        return t.indexOf("theta") !== -1 && (t = t.filter((n) => n !== "r")),
          t.filter((n) =>
            !(this.assignmentForbidden(n) || n.slice(0, 3) === "ans" ||
              n.slice(0, 6) === "idref_" || n[0] === "_" ||
              this.isGeometryEnabled() && n[0] === "$")
          );
      }
      tooManySliderVariables(t, n, r) {
        return r ? t.length >= 1 : t.length >= 2 && n.length >= 1;
      }
      graphingEnabled() {
        return true;
      }
      ansEnabled() {
        return false;
      }
      dimensionVarsEnabled() {
        return true;
      }
      validRegressionParameter(t) {
        return t !== "x" && t !== "y";
      }
      validLHS(t) {
        return t !== "theta" && t.slice(0, 6) !== "idref_";
      }
      unplottablePolarFunction(t, n) {
        return t !== "theta" ? false : n.indexOf("r") !== -1;
      }
      validDoubleInequalitySymbol(t) {
        return t === "x" || t === "y";
      }
      validDoubleInequalityVariables(t) {
        return t.length > 2 ? false : t.every(this.validDoubleInequalitySymbol);
      }
      validExpressionVariables(t) {
        return t.length === 1 && t[0] === "x";
      }
      validSolvedVariable(t) {
        return t === "x" || t === "y" || t === "r";
      }
      validImplicitVariables(t) {
        switch (t.length) {
          case 0:
            return true;
          case 1:
            return t[0] === "x" || t[0] === "y" || t[0] === "r";
          case 2:
            return t[0] === "x" && t[1] === "y" ||
              t[0] === "y" && t[1] === "x" ||
              t[0] === "r" && t[1] === "theta" ||
              t[0] === "theta" && t[1] === "r";
          default:
            return false;
        }
      }
      graphableListVariables(t, n) {
        return t === "x" || t === "y" || t === "r" || n === "x" || n === "y";
      }
      validParametricVariable(t) {
        return t === "t";
      }
      validParametricVariables(t) {
        return t.length === 1 && this.validParametricVariable(t[0]);
      }
      validInequalityVariables(t) {
        switch (t.length) {
          case 1:
            return t[0] === "x" || t[0] === "y" || t[0] === "r";
          case 2:
            return this.validImplicitVariables(t);
          default:
            return false;
        }
      }
      validFirstColumnVariable(t) {
        return t !== "y" && t !== "r" && t !== "theta" && !t.match(/y_(\d+)/);
      }
      validActionVariable(t) {
        return t === "dt" || t === "index";
      }
      complicatedPolarImplicit(t, n) {
        return t === "theta" || t === "r" && n !== 1;
      }
      graphMode(t, n, r) {
        if (n.length === 0) {
          return t === "x" ? 1 : t === "r" ? 6 : t === "y" ? 2 : 10;
        }
        let s = n[0];
        return s === "y"
          ? 1
          : t === "x"
          ? 1
          : t === "r" && s === "theta"
          ? 6
          : this.isComplexEnabled() && t !== "y" && s !== "x"
          ? 10
          : 2;
      }
      functionDefinitionGraphMode(t, n) {
        return this.graphMode(t, n);
      }
      tableableAsConstant(t) {
        return !(t === "x" || t === "r" || t === "theta");
      }
      implicitIndependent(t) {
        return "x";
      }
      implicitDependency(t) {
        return t.length !== 1
          ? "y"
          : t[0] === "y"
          ? "x"
          : t[0] === "theta"
          ? "r"
          : "y";
      }
      disabledFeatures() {
        return [];
      }
      shouldIncludeFunctionParametersInRandomSeed() {
        return this._includeFunctionParametersInRandomSeed;
      }
      isCustomRegressionSupported() {
        return this._customRegressions;
      }
    },
    $b = class {
      constructor(
        {
          beta3d: t,
          includeFunctionParametersInRandomSeed: n,
          isComplexEnabled: r,
          customRegressions: s,
          isRecursionEnabled: i,
        },
      ) {
        this._isBeta3d = false;
        this._isBeta3d = t,
          this.policy2d = new Id({
            enableGeometry: false,
            enable3d: true,
            scales: { xAxisScale: "linear", yAxisScale: "linear" },
            includeFunctionParametersInRandomSeed: n,
            isComplexEnabled: r,
            customRegressions: s,
            isRecursionEnabled: i,
          });
      }
      isGeometryEnabled() {
        return false;
      }
      is3dProduct() {
        return true;
      }
      is3dPolicy() {
        return true;
      }
      isBeta3d() {
        return this._isBeta3d;
      }
      isComplexEnabled() {
        return this.policy2d.isComplexEnabled();
      }
      isRecursionEnabled() {
        return this.policy2d.isRecursionEnabled();
      }
      polygonUnsupportedPreferTriangle() {
        return true;
      }
      areAllScalesLinear() {
        return true;
      }
      graphingEnabled() {
        return true;
      }
      ansEnabled() {
        return false;
      }
      dimensionVarsEnabled() {
        return false;
      }
      validInequalityVariables(t) {
        return this.validImplicitVariables(t);
      }
      validFirstColumnVariable(t) {
        return this.policy2d.validFirstColumnVariable(t);
      }
      validActionVariable(t) {
        return this.policy2d.validActionVariable(t);
      }
      tableableAsConstant(t) {
        return this.policy2d.tableableAsConstant(t);
      }
      implicitIndependent(t) {
        return this.policy2d.implicitIndependent(t);
      }
      validRegressionParameter(t) {
        return this.policy2d.validRegressionParameter(t);
      }
      assignmentForbidden(t) {
        return t === "x" || t === "y" || t === "z" || t === "r" ||
          t === "rho" || t === "theta" || t === "phi" ||
          this.policy2d.assignmentForbidden(t);
      }
      sliderVariables(t) {
        return t.filter((n) =>
          !(this.assignmentForbidden(n) || n.slice(0, 3) === "ans" ||
            n.slice(0, 6) === "idref_" || n[0] === "_")
        );
      }
      tooManySliderVariables(t, n, r) {
        return r
          ? this.isBeta3d() ? n.length >= 1 : t.length >= 1
          : n.length >= 1;
      }
      isValidSlider(t) {
        return !(t.slice(0, 3) === "ans" || t.slice(0, 6) === "idref_" ||
          this.assignmentForbidden(t));
      }
      validLHS(t) {
        return t !== "phi" && this.policy2d.validLHS(t);
      }
      unplottablePolarFunction(t, n) {
        return false;
      }
      complicatedPolarImplicit(t, n) {
        return false;
      }
      validDoubleInequalitySymbol(t) {
        return Om(t);
      }
      validDoubleInequalityVariables(t) {
        return t.every(Om);
      }
      validExpressionVariables(t) {
        return t.length === 2 && t.every((n) => n == "x" || n == "y");
      }
      validSolvedVariable(t) {
        return Om(t) || t === "r" || t === "rho";
      }
      validImplicitVariables(t) {
        return t.every(Om);
      }
      graphableListVariables(t, n) {
        return t === "x" || t === "y" || t === "z" || t === "r" ||
          t === "rho" || n === "x" || n === "y";
      }
      validParametricVariable(t) {
        return t === "t" || t === "u" || t === "v";
      }
      validParametricVariables(t) {
        return t.length === 1 && this.validParametricVariable(t[0]) ||
          t.length === 2 && t.every(b1);
      }
      functionDefinitionGraphMode(t, n) {
        if (n.length === 1) {
          switch (n[0]) {
            case "x":
              return 121;
            case "y":
              return 120;
            default:
              return 10;
          }
        } else if (n.length === 2 && n.every((r) => r == "x" || r == "y")) {
          return 106;
        }
        return 10;
      }
      graphMode(t, n, r) {
        if (r != null || (r = n), n.length === 0) {
          switch (t) {
            case "z":
              return r.some((s) => s === "r" || s === "theta") ? 109 : 106;
            case "y":
              return r.includes("z") ? 108 : 123;
            case "x":
              return r.includes("z") ? 107 : 122;
            case "r":
              return r.indexOf("r") > -1 ? 10 : Dw(r);
            case "rho":
              return 111;
            default:
              return 10;
          }
        }
        switch (t) {
          case "z":
            return n.every((s) => s == "x" || s == "y")
              ? 106
              : n.every((s) => s == "r" || s == "theta")
              ? 109
              : 10;
          case "y":
            return n.every((s) => s == "x")
              ? r.some((s) => s === "z") ? 108 : 121
              : n.every((s) => s == "x" || s == "z")
              ? 108
              : 10;
          case "x":
            return n.every((s) => s == "y")
              ? r.some((s) => s === "z") ? 107 : 120
              : n.every((s) => s == "y" || s == "z")
              ? 107
              : 10;
          case "r":
            return n.every((s) => s == "theta")
              ? Dw(r)
              : n.every((s) => s == "theta" || s == "z")
              ? 110
              : 10;
          case "rho":
            return n.every((s) => s == "theta" || s == "phi") ? 111 : 10;
          default:
            return 10;
        }
      }
      implicitDependency(t) {
        if (t.length !== 2) return "z";
        let n = t[0] < t[1] ? t[0] + t[1] : t[1] + t[0];
        return n === "xy" ? "z" : n === "xz" ? "y" : n === "yz" ? "x" : "z";
      }
      disabledFeatures() {
        return [];
      }
      shouldIncludeFunctionParametersInRandomSeed() {
        return this.policy2d.shouldIncludeFunctionParametersInRandomSeed();
      }
      isCustomRegressionSupported() {
        return this.policy2d.isCustomRegressionSupported();
      }
    },
    Om = (e) => e === "x" || e === "y" || e === "z",
    b1 = (e) => e === "u" || e === "v";
  function Dw(e) {
    return e.some((n) => Om(n) || n === "r") ? 110 : 124;
  }
  C.Base.prototype.getGraphMode = function (e, t) {
    return 10;
  };
  C.Base.prototype.graphmodeDependencies = Do;
  function Do(e, t) {
    let n = t.getDependencies();
    if (e.is3dProduct() && t instanceof on) {
      let r = new Set(pL(t._chunk));
      return n.filter((s) => r.has(s));
    } else return n;
  }
  function K8(e, t) {
    let n;
    return e && e.hasOwnProperty("dragMode")
      ? e.dragMode === "AUTO" ? n = t.defaultDragMode : n = e.dragMode
      : n = t.defaultDragMode,
      wD(n, t.moveStrategy);
  }
  function Sw(e, t) {
    let n = e.is3dPolicy();
    if (t.isMovablePoint && !n && K8(this.userData, t) !== "NONE") {
      return t.valueType === Complex ? 26 : 4;
    }
    let r = Do(e, t);
    switch (t.valueType) {
      case ListOfPoint3D:
      case Point3D:
        if (n) {
          if (r.length === 0) return 114;
          if (e.validParametricVariables(r)) {
            return r.length == 1 ? 100 : La(103, t);
          }
        }
        return 10;
      case Complex:
      case ListOfComplex:
      case Point:
      case ListOfPoint: {
        let s = se(t.valueType, Complex);
        return r.length === 0
          ? s ? 25 : 3
          : n && e.validParametricVariables(r)
          ? r.length === 1 ? 5 : r.every(b1) ? La(130, t) : 10
          : e.validParametricVariables(r)
          ? 5
          : 10;
      }
      case Number:
      case ListOfNumber:
        return !e.is3dPolicy() && r.length === 1
          ? 2
          : n && r.length === 2 && r.indexOf("x") > -1 && r.indexOf("y") > -1
          ? La(106, t)
          : 10;
    }
    if (r.length > 0) return 10;
    switch (t.valueType) {
      case MapIntervalComplex:
      case ListOfMapIntervalComplex:
        return 5;
      case MapIntervalPoint:
      case ListOfMapIntervalPoint:
        return 5;
      case MapIntervalPoint3D:
      case ListOfMapIntervalPoint3D:
        return n ? 100 : 10;
      case MapInterval2ToComplex:
      case ListOfMapInterval2ToComplex:
        return n ? La(130, t) : 10;
      case MapInterval2ToPoint:
      case ListOfMapInterval2ToPoint:
        return n ? La(130, t) : 10;
      case MapInterval2DPoint3D:
      case ListOfMapInterval2DPoint3D:
        return n ? La(103, t) : 10;
      case Segment3D:
      case ListOfSegment3D:
        return n ? 119 : 10;
      case Vector3D:
      case ListOfVector3D:
        return n ? 129 : 10;
      case Triangle3D:
      case ListOfTriangle3D:
        return n ? 117 : 10;
      case Sphere3D:
      case ListOfSphere3D:
        return n ? 118 : 10;
      case Polygon:
      case ListOfPolygon:
        return 16;
      case Circle:
      case ListOfCircle:
        return 20;
      case Arc:
      case ListOfArc:
        return 21;
      case Segment:
      case ListOfSegment:
        return 17;
      case Line:
      case ListOfLine:
        return 18;
      case Ray:
      case ListOfRay:
        return 19;
      case Vector:
      case ListOfVector:
        return this instanceof we && this.getDependencies().length === 1
          ? 10
          : 24;
      case AngleMarker:
      case ListOfAngleMarker:
      case DirectedAngleMarker:
      case ListOfDirectedAngleMarker:
        return 23;
      default:
        return 10;
    }
  }
  C.Expression.prototype.getGraphMode = Sw;
  function vw(e, t) {
    let n = t._expression.getDependencies();
    if (n.length > 1) return 10;
    if (t._expression.isList && t._expression.length === 0) return 10;
    let r = t._symbol, s = t.getDependencies();
    return e.graphMode(r, n, s);
  }
  C.Equation.prototype.getGraphMode =
    C.CallAssignment.prototype.getGraphMode =
    C.BaseComparator.prototype.getGraphMode =
    C.ComparatorChain.prototype.getGraphMode =
      function (e, t) {
        if (t.isError) return 10;
        let n = Do(e, t), r = t.getDependencies();
        if (e.is3dPolicy()) {
          let s = 10;
          return n.length > 0 &&
            (r.includes("z")
              ? s = this.isInequality() ? 113 : 112
              : s = this.isInequality() ? 127 : 126),
            La(s, t);
        }
        return t.isConstant
          ? 10
          : t instanceof C.SolvedEquation
          ? vw(e, t)
          : n.length === 1 || n.length === 2
          ? 8
          : 10;
      };
  function x1(e) {
    var t;
    return e === 106 || e === 200 || e === 107 || e === 201 || e === 108 ||
        e === 202
      ? ["x", "y", "z", "_implicit"]
      : e === 110 || e === 211
      ? ["x", "y", "z", "r", "theta", "_implicit"]
      : e === 111 || e === 212
      ? ["x", "y", "z", "rho", "theta", "phi", "_implicit"]
      : e === 109 || e === 213
      ? ["x", "y", "z", "r", "theta", "_implicit"]
      : e === 103 || e === 214 || e === 130 || e === 215
      ? ["x", "y", "z", "u", "v", "_implicit"]
      : e === 113 || e === 210 || e === 112 || e === 209
      ? ["x", "y", "z", "_implicit"]
      : (t = vi[e]) != null
      ? t
      : [];
  }
  function La(e, t) {
    let n = x1(e), r = t._chunk;
    try {
      let i = tu(r, n, { allowSlices: true }).getSliceVariablesOrImplicit();
      if (i.length !== 1) return e;
      let o = i[0];
      return n.indexOf(o) < 0 ? 10 : lL(e, o);
    } catch (s) {
      return 10;
    }
  }
  C.DoubleInequality.prototype.getGraphMode = function (e, t) {
    let n = t.getDependencies();
    return e.graphMode(t._symbol, [], n);
  };
  C.Assignment.prototype.getGraphMode = function (e, t) {
    if (t instanceof C.SolvedEquation) return vw(e, t);
    if (this.isEquation(e, t)) return this.asEquation().getGraphMode(e, t);
    let n = Do(e, t), r = this._symbol, s = t.getDependencies();
    switch (t.valueType) {
      case Number:
      case ListOfNumber:
      case EmptyList:
        switch (n.length) {
          case 0: {
            let o = e.graphMode(r, [], s);
            return e.is3dPolicy() ? La(o, t) : o;
          }
          case 1:
            if (
              t.valueType === ListOfNumber && !e.graphableListVariables(r, n[0])
            ) {
              return 10;
            }
            if (this.isSlider) return 10;
            let i = e.graphMode(r, n, s);
            return e.is3dPolicy() ? La(i, t) : i;
          default:
            return e.is3dPolicy() ? La(e.graphMode(r, n, s), t) : 10;
        }
      case Point3D:
        if (
          e.assignmentForbidden(r) ||
          n.length > 0 && !e.validParametricVariables(n)
        ) return 10;
        switch (n.length) {
          case 0:
            return 114;
          case 1:
            return 100;
          case 2:
            return 103;
          default:
            return 10;
        }
      default:
        return Sw.call(this, e, t);
    }
  };
  C.FunctionDefinition.prototype.getGraphMode = function (e, t) {
    let n = e.is3dPolicy();
    if (this._argSymbols.length !== 1 && !n) return 10;
    if (this.recursionInfo) {
      let i = t instanceof on ? t.getRecursiveFunctionMetadata() : void 0;
      if ((i == null ? void 0 : i.type) === "missing-non-recursive-branch") {
        return 10;
      }
      if (
        (i == null
          ? void 0
          : i.recursiveStructure.domainInfo[this._symbol][0]) === 1
      ) return 10;
    }
    let r = e.functionDefinitionGraphMode(this._symbol, this._argSymbols),
      s = Do(e, t);
    switch (t.valueType) {
      case Number:
      case ListOfNumber:
        if (n) return r;
        switch (s.length) {
          case 0:
            return r;
          case 1:
            return s[0] !== this._argSymbols[0] ? 10 : r;
          default:
            return 10;
        }
        break;
      default:
        return 10;
    }
  };
  C.Regression.prototype.getGraphMode = function (e, t) {
    return this.isLhsSimple
      ? t.isModelValid ? t.model.getDependencies().length !== 1 ? 10 : 2 : 10
      : 10;
  };
  function T1(e, t) {
    return t.isError ? 10 : 11;
  }
  C.Histogram.prototype.getGraphMode = T1;
  C.DotPlot.prototype.getGraphMode = T1;
  C.BoxPlot.prototype.getGraphMode = T1;
  C.Image.prototype.getGraphMode = function (e, t) {
    return this.userData.showPoints
      ? this.center.isError || this.radianAngle.isError || this.width.isError ||
          this.height.isError || this.opacity.isError
        ? 10
        : 3
      : 10;
  };
  function Ow(e) {
    let t = 0, n = 0, r = [], s = Vr(e, e.getReturnIndex());
    for (let i = 0; i < e.instructionsLength(); i++) {
      if (!s[i]) continue;
      let o = e.getInstruction(i);
      o.type === 25
        ? r[i] = 1
        : o.type === 31 || o.type === 32
        ? r[i] = r[o.args[0]] + r[o.args[1]]
        : r[i] = 0, Yu(e, o) && (t += 1, n += r[o.args[0]]);
    }
    return { numRestrictions: t, numEqualityRestrictions: n };
  }
  function Pd(e, t, n) {
    try {
      return e$(e, t, n);
    } catch (r) {
      return r instanceof v ? r : U(r);
    }
  }
  function e$(e, t, n) {
    var l, p;
    if (!e.is3dProduct() || n.isError) return n;
    if (!(n instanceof on)) {
      return U("Expected peel error to be checked on an IRExpression");
    }
    function r(f, d) {
      let y = d.filter((g) => f.indexOf(g) < 0);
      if (y.length) return kI(y[0]).allowExport().setDependencies(y);
    }
    function s() {
      let f = zb(o), d = t$(e, n);
      return r(f, d);
    }
    function i() {
      let f = Nw(o), d = n$(e, n, o);
      return r(f, d);
    }
    let o = t.getGraphMode(e, n),
      a = n._chunk,
      { numRestrictions: u, numEqualityRestrictions: c } = Ow(a);
    if (c !== 0) {
      if (c === 1) {
        if (u !== c && !t.isInequality()) return wT();
        let y = tu(a, [], { allowSlices: true }).getSliceVariablesOrImplicit();
        if (y.length !== 1) return ca();
        let g = x1(o), m = y[0];
        if (g.indexOf(m) < 0) {
          return m === "_implicit"
            ? ca().allowExport()
            : zI(m).allowExport().setDependencies([m]);
        }
      } else return LT();
    }
    return (p = (l = s()) != null ? l : i()) != null ? p : n;
  }
  function t$(e, t) {
    let n = Do(e, t);
    return t.getDependencies().filter((s) => n.indexOf(s) < 0);
  }
  function n$(e, t, n) {
    let r = Do(e, t), s = new Set();
    if (t instanceof on) {
      let o = t.getRestrictedFunctionForGLSL(zb(n), ac).concrete;
      for (let a of o.getDependencies()) r.indexOf(a) > -1 || s.add(a);
    }
    return [...s];
  }
  function zb(e) {
    var n;
    if (!va(e)) return [];
    let t = r$(e) ? ["x", "y", "z"] : [];
    return e === 211 && t.push("r"),
      e === 212 && t.push("rho"),
      t.push(...(n = Ol[e]) != null ? n : []),
      t.push(...Nw(e).filter((r) => t.indexOf(r) < 0)),
      t;
  }
  function r$(e) {
    return s$(e) || e == 200 || e == 201 || e == 202 || e == 211 || e == 212 ||
      e == 213 || e == 214 || e == 215;
  }
  function s$(e) {
    if (!va(e)) return false;
    switch (e) {
      case 106:
      case 107:
      case 108:
      case 110:
      case 111:
      case 109:
      case 122:
      case 123:
      case 112:
      case 113:
      case 127:
      case 130:
      case 103:
      case 210:
        return true;
      case 124:
      case 120:
      case 121:
      case 126:
      case 114:
      case 117:
      case 118:
      case 119:
      case 129:
      case 128:
      case 100:
      case 200:
      case 201:
      case 202:
      case 206:
      case 205:
      case 211:
      case 203:
      case 204:
      case 213:
      case 207:
      case 208:
      case 212:
      case 214:
      case 215:
      case 209:
        return false;
      default:
        return false;
    }
  }
  function Nw(e) {
    var t;
    return va(e) ? (t = vi[e]) != null ? t : [] : [];
  }
  function wa(e) {
    if (typeof e == "string") return e;
    if (e === void 0) return "";
    if (isNaN(e)) return "\\frac{0}{0}";
    if (e === 1 / 0) return "\\infty";
    if (e === -1 / 0) return "-\\infty";
    let t = e + "";
    return t = t.replace(/^1e\+?([-\d]+)/, "10^{$1}"),
      t = t.replace(/([-\d\.]+)e\+?([-\d]+)/, "$1\\cdot 10^{$2}"),
      t;
  }
  function i$(e) {
    let t = e + "";
    if (/\d+\.?\d*e[\+\-]*\d+/i.test(t)) {
      let n = "0",
        r = String(t).toLowerCase().split("e"),
        s = parseFloat(r[0]),
        i = parseInt(r[1], 10),
        o = Math.abs(i),
        a = Math.abs(s).toString().split(".");
      if (i < 0) t = "0." + new Array(o).join(n) + a.join("");
      else {
        let u = a[1];
        u && (o = o - u.length), t = a.join("") + new Array(o + 1).join(n);
      }
      s < 0 && (t = "-" + t);
    }
    return t;
  }
  function pae(e, t = 2) {
    let n = i$(e), r = n.indexOf(".");
    if (r === -1) return n;
    let s, i;
    for (i = r + 1; i < n.length; i++) {
      if (s) { if (n[i] !== s) break; }
      else if (n[i] === "0" || n[i] === "9") s = n[i];
      else break;
    }
    return n.substr(0, Math.max(r + 5, i + t));
  }
  function Ln(e, t) {
    if (j(e)) {
      let n = [];
      for (let r = 0; r < t.length; r++) n.push(Ln(Ve(e), t[r]));
      return `\\left[${n.join(",")}\\right]`;
    }
    switch (e) {
      case Number:
        return wa(t);
      case Complex:
        return complexNumberLabel(t);
      case Point: {
        let [i, o] = t;
        return `\\left(${wa(i)},${wa(o)}\\right)`;
      }
      case Point3D: {
        let [i, o, a] = t;
        return `\\left(${wa(i)},${wa(o)},${wa(a)}\\right)`;
      }
      case RGBColor:
        return "\\operatorname{rgb}\\left(" +
          [Ln(Number, t[0]), Ln(Number, t[1]), Ln(Number, t[2])].join(",") +
          "\\right)";
      case Polygon: {
        let i = [];
        for (let o of t) i.push(Ln(Point, o));
        return "\\operatorname{polygon}\\left(" + i.join(",") + "\\right)";
      }
      case Segment:
        return "\\operatorname{segment}\\left(" +
          [Ln(Point, t[0]), Ln(Point, t[1])].join(",") + "\\right)";
      case Line:
        return "\\operatorname{line}\\left(" +
          [Ln(Point, t[0]), Ln(Point, t[1])].join(",") + "\\right)";
      case Ray:
        return "\\operatorname{ray}\\left(" +
          [Ln(Point, t[0]), Ln(Point, t[1])].join(",") + "\\right)";
      case Vector:
        let n = t[0], r = t[1], s = [r[0] + n[0], r[1] + n[1]];
        return `\\operatorname{vector}\\left(${Ln(Point, r)},${
          Ln(Point, s)
        }\\right)`;
      case Circle:
        return "\\operatorname{circle}\\left(" +
          [Ln(Point, t[0]), Ln(Number, t[1])].join(",") + "\\right)";
      case Arc:
        return "\\operatorname{arc}\\left(" +
          [Ln(Point, t[0]), Ln(Point, t[1]), Ln(Point, t[2])].join(",") +
          "\\right)";
      case AngleMarker:
        return "\\operatorname{angle}\\left(" +
          [Ln(Point, t[0]), Ln(Number, t[1]), Ln(Number, t[2])].join(",") +
          "\\right)";
      case DirectedAngleMarker:
        return "\\operatorname{directedangle}\\left(" +
          [Ln(Point, t[0]), Ln(Number, t[1]), Ln(Number, t[2])].join(",") +
          "\\right)";
      case Tone:
        return `\\operatorname{tone}\\left(${Ln(Number, t[0])},${
          Ln(Number, t[1])
        }\\right)`;
      default:
        throw new Error("Cannot serialize a value of type " + oe(e) + ".");
    }
  }
  function I1(e) {
    let t = {};
    for (let n of We(e.updateRules)) t[n] = P1(e, n);
    return t;
  }
  function P1(e, t) {
    let { valueType: n, value: r } = e.updateRules[t];
    return `${identifierToLatex(t)}=${Ln(n, r)}`;
  }
  function Aw(e) {
    return e instanceof C.Constant ||
      e instanceof C.ParenSeq && e.args.length === 1 &&
        e.args[0] instanceof C.Constant;
  }
  function Rw(e) {
    return !!(e instanceof C.Identifier && e._symbol === br ||
      (e instanceof C.Multiply || e instanceof C.CrossMultiply ||
          e instanceof C.DotMultiply) &&
        e.args.length === 2 &&
        e.args.some((t) => t instanceof C.Identifier && t._symbol === br) &&
        e.args.some((t) => Aw(t)) ||
      e instanceof C.Negative && e.args[0] instanceof C.Identifier &&
        e.args[0]._symbol === br ||
      e instanceof C.FunctionCall && e._symbol === br && e.args.length === 1 &&
        e.args[0] instanceof C.Constant);
  }
  function Rm(e) {
    return !!(Rw(e) ||
      (e instanceof C.Add || e instanceof C.Subtract) &&
        e.args.some((t) => Rw(t)) && e.args.some((t) => Aw(t)) ||
      e instanceof C.Assignment && Rm(e._expression));
  }
  function E1(e) {
    let t;
    for (let n = 0; n < e.length; n++) {
      if (e[n].dependsOn(br)) {
        if (t !== void 0) return;
        t = n;
      }
    }
    return t;
  }
  function Nm(e, t) {
    var n;
    if (t.dependsOn(br)) {
      switch (t.type) {
        case "Identifier":
          return C.Constant(1);
        case "Negative": {
          let r = Nm(e, t.args[0]);
          return r === void 0 ? void 0 : t.copyWithArgs([r]);
        }
        case "Multiply":
        case "DotMultiply":
        case "CrossMultiply":
          switch (E1(t.args)) {
            case 0: {
              let s = Nm(e, t.args[0]);
              return s === void 0 ? void 0 : t.copyWithArgs([s, t.args[1]]);
            }
            case 1: {
              let s = Nm(e, t.args[1]);
              return s === void 0 ? void 0 : t.copyWithArgs([t.args[0], s]);
            }
            default:
              return;
          }
        case "Divide": {
          if (E1(t.args) !== 0) return;
          let s = Nm(e, t.args[0]);
          return s === void 0 ? void 0 : t.copyWithArgs([s, t.args[1]]);
        }
        case "FunctionCall":
          return t._symbol === br && t.args.length === 1 &&
              !t.args[0].dependsOn(br)
            ? t.args[0]
            : t.args.length === 1 && t.args[0].type === "Identifier" &&
                t.args[0]._symbol === br && t._symbol !== void 0 &&
                !((n = e[t._symbol]) != null && n.isFunction)
            ? C.Identifier(t._symbol)
            : void 0;
        default:
          return;
      }
    }
  }
  function Yb(e, t) {
    if (t.dependsOn(br)) {
      switch (t.type) {
        case "Add":
        case "Subtract":
          switch (E1(t.args)) {
            case 0: {
              let r = Yb(e, t.args[0]);
              return r === void 0
                ? void 0
                : [t.copyWithArgs([r[0], t.args[1]]), r[1]];
            }
            case 1: {
              let r = Yb(e, t.args[1]);
              return r === void 0 ? void 0 : [
                t.copyWithArgs([t.args[0], r[0]]),
                t.type === "Subtract" ? C.Negative([r[1]]) : r[1],
              ];
            }
            default:
              return;
          }
        default: {
          let n = Nm(e, t);
          return n === void 0 ? void 0 : [C.Constant(0), n];
        }
      }
    }
  }
  function o$(e) {
    return e.isError
      ? e.getError()
      : e.valueType === Complex
      ? e.asValue()
      : +e.asValue();
  }
  function a$(e, t, n, r) {
    let s = [], i = false;
    for (let o = 0; o < n.columns.length; o++) {
      let a = r.columns[o],
        u = n.columns[o],
        c = a.isError ? [] : a.rawArgs.map(o$),
        l = Kr(a)
          ? a.isCyclicDependencyError && ga(u) && u.isFreeVariable(t)
          : ha(a) && a.isIndependent,
        p = o >= 1 && !r.columns[0].isError && !a.isError &&
          !u.header.userData.hidden;
      p && (i = true);
      let f = { computed: !l, values: c, plotted: p };
      a.isError && (f.error = a.getError()), s.push(f);
    }
    return s[0].plotted = i, { column_data: s };
  }
  function u$(e, t, n) {
    let r = { variables: [], errorMap: {}, dimensions: {} };
    if (
      e.areAllScalesLinear() || (r.errorMap.scale = true),
        n.center.isError && (r.errorMap.center = true),
        n.radianAngle.isError && (r.errorMap.angle = true),
        n.width.isError && (r.errorMap.width = true),
        n.height.isError && (r.errorMap.height = true),
        n.opacity.isError && (r.errorMap.opacity = true),
        Object.keys(r.errorMap).length > 0
    ) return r.variables = t.getSliderVariables(e, n), r;
    r.dimensions.x = [],
      r.dimensions.y = [],
      r.dimensions.radianAngle = [],
      r.dimensions.width = [],
      r.dimensions.height = [],
      r.dimensions.opacity = [];
    let s = [n.center, n.radianAngle, n.width, n.height, n.opacity];
    return s.some((o) => o && o.valueType && j(o.valueType)) &&
      (r.is_concrete_list = true),
      C.List.eachArgs(s, (o) => {
        let a = o[0].asValue(),
          u = +o[1].asValue(),
          c = Math.atan2(Math.sin(u), Math.cos(u));
        r.dimensions.x.push(+a[0]),
          r.dimensions.y.push(+a[1]),
          r.dimensions.radianAngle.push(c),
          r.dimensions.width.push(+o[2].asValue()),
          r.dimensions.height.push(+o[3].asValue()),
          r.dimensions.opacity.push(Math.max(0, Math.min(1, +o[4].asValue())));
      }),
      (e.graphingEnabled() ? t.getGraphMode(e, n) : 10) !== 10 &&
      (r.is_graphable = true),
      n.moveStrategy && (r.move_strategy = n.moveStrategy),
      t.center &&
      (t.center.type === "Identifier"
        ? (r.center_reference_id = t.center.referencedStatementId,
          r.center_reference_symbol = t.center._symbol)
        : t.center.type === "ParenSeq" && n.center.valueType === Point &&
          (r.center_is_point_literal = true)),
      r;
  }
  function c$(e, t, n) {
    let r = n.handler, s = n.minStep, i = {}, o = {};
    for (let p of r.getDependencies()) {
      e.validActionVariable(p) || (i[p] = true);
    }
    for (let p of s.getDependencies()) o[p] = true;
    let a;
    if (Kr(s)) a = { status: "error", error: s.getError() };
    else {
      let p = s.asValue();
      typeof p == "number" && !isNaN(p) && p >= 0
        ? a = { status: "valid", value: p }
        : a = { status: "error", error: DI().getError() };
    }
    let u = Object.keys(i);
    u.length > 0 && (r = rn(u).setDependencies(r.getDependencies()));
    let c;
    r.isError && !C1(e, r)
      ? c = { status: "error", error: r.getError() }
      : r.isEmptyAction
      ? c = { status: "empty" }
      : c = { status: "maybe-valid" };
    let l = { handler: c, minStep: a, variables: [] };
    return mc(l, e, { ...i, ...o }), l;
  }
  function l$() {
    return { operator: "=", variables: [] };
  }
  function Lw(e, t, n, r) {
    if (Hi(n)) return a$(e, t, n, r);
    if (_f(n)) return u$(e, n, r);
    let s = l$();
    if (n instanceof C.Ticker) {
      return e.graphingEnabled()
        ? c$(e, n, r)
        : (s.error = U("Ticker without graphing").getError(), s);
    }
    if (e.is3dProduct()) {
      let c = e, l = n.getGraphMode(c, r);
      if ((l === 100 || l === 5) && r.getDependencies().length === 1) {
        let p = r.getDependencies()[0];
        (p === "u" || p === "v" || p === "t") &&
          (s.internal_domain_dependency = p);
      }
    }
    let i = am(n.userData);
    if (i) {
      let c = r.getCursorContext();
      if (c) s.cursor_context = { ...c, selection: i };
      else if (Kr(r)) {
        let l = d$(e, t, n);
        l && (s.cursor_context = { ...l, selection: i });
      }
    }
    if (
      (n instanceof C.FunctionDefinition || n instanceof C.Assignment ||
        n instanceof C.RecursiveFunctionBaseCase) &&
      (n._symbol.startsWith("_") || (s.defined_name = n._symbol)),
        n instanceof Cr && r instanceof on
          ? s.recursion = r.getRecursiveFunctionMetadata()
          : n instanceof Cr && r instanceof v && r.recursionMetadata &&
            (s.recursion = r.recursionMetadata),
        n instanceof Qr &&
        (s.recursion_base_case = {
          symbol: n._symbol,
          argValue: n.specifiedArg.valid ? n.specifiedArg.argValue : void 0,
        }),
        r.warning !== void 0 && (s.warning = r.warning),
        r.isError &&
        !((n instanceof C.FunctionDefinition ||
          n instanceof C.RecursiveFunctionBaseCase) && !r.blocksExport) &&
        !r.silent
    ) {
      s.error = r.getError(),
        s.variables = n.getSliderVariables(e, r),
        s.is_single_identifier = n instanceof C.Identifier,
        r.actionValue && (s.action_value = I1(r.actionValue));
      let c = _w(e, t, n, r);
      return c && (s.geometry = c), s;
    }
    if (r.valueType === RGBColor && r.getDependencies().length === 0) {
      let c = r.asValue();
      s.rgb_value = kc(c[0], c[1], c[2]).formatHex();
    }
    r.valueType === Action && r.getDependencies().length === 0 &&
    (s.action_value = I1(r.asValue())),
      r.moveStrategy &&
      (s.move_strategy = r.moveStrategy,
        s.default_drag_mode = r.defaultDragMode),
      n.isInequality() && (s.is_inequality = true),
      s.operator = n.getOperator(),
      r instanceof C.SolvedEquation
        ? r._expression.asValue() !== true &&
          r._expression.asValue() !== false &&
          (s.assignment = r._symbol)
        : n instanceof C.Assignment &&
          (n._symbol.startsWith("_") || (s.assignment = n._symbol)),
      n instanceof C.FunctionDefinition && (s.function_definition = n._symbol);
    let o = e.graphingEnabled() ? n.getGraphMode(e, r) : 10;
    if (
      e.graphingEnabled() && e.is3dPolicy() &&
      (!va(o) && !iw(o) && (o = 10),
        r instanceof C.OptimizedRegression && (o = 10)),
        o !== 10 &&
        (s.is_graphable = true,
          s.expression_type = n.getExpressionType(o, r.valueType),
          e.is3dPolicy() && (s.expression_type === "SINGLE_POINT"
            ? s.expression_type = "POINT3D"
            : s.expression_type === "POINT_LIST" &&
              (s.expression_type = "POINT3D_LIST")),
          r.valueType && ua(r.valueType) && (s.map_type = r.valueType),
          r.isShadeBetween() && (s.is_shade_between = true),
          s.expression_type !== "POINT3D" &&
          s.expression_type !== "POINT3D_LIST")
    ) {
      let c = n.tableInfo(e, r);
      c && (s.is_tableable = true, s.table_info = c);
    }
    if (
      r.valueType !== void 0 && j(r.valueType) &&
      (s.is_concrete_list = true,
        r.valueType === ListOfColor && r.getDependencies().length === 0)
    ) {
      let c = r.asValue();
      c && (s.rgb_value = c.map((l) => kc(l[0], l[1], l[2]).formatHex()));
    }
    if (
      s.variables = s.is_graphable ? [] : n.getSliderVariables(e, r),
        s.is_single_identifier = n instanceof C.Identifier,
        r.isTypedConstant
    ) {
      let c = r.asTypedValue();
      s.typed_constant_value = c,
        p$(c == null ? void 0 : c.valueType) && (s.geometry = _w(e, t, n, r));
    }
    if (
      r.getEvaluationInfo() && s.operator === "=" && !n.isConstant &&
      !n.isFunction && !(n instanceof C.RecursiveFunctionBaseCase) &&
      r.valueType !== Bool && r.valueType !== ListOfBool &&
      !(n instanceof C.Equation) &&
      !(n instanceof C.ComparatorChain) && !(e.isComplexEnabled() && Rm(n)) &&
      (s.is_evaluable = true), r instanceof C.OptimizedRegression
    ) {
      let c = r, l = {};
      for (let p of We(c.parameters)) {
        c.parameters.hasOwnProperty(p) &&
          (l[identifierToLatex(p)] = +c.parameters[p].asValue());
      }
      s.is_regression = true,
        s.regression = {
          parameters: l,
          displayPrecision: c.displayPrecision,
          residualVariable: identifierToLatex(c.residualVariable),
          residualSuggestionId: c.residualSuggestionId,
          shouldSuggestLogMode: c.shouldSuggestLogMode,
          isLinear: c.isLinear,
          statistics: c.statistics,
          parameterWarning: c.parameterWarning,
        };
    }
    let u = ou(n);
    return u && u.discrete && (s.is_discrete_distribution = true), s;
  }
  function p$(e) {
    switch (e) {
      case Point:
      case ListOfPoint:
      case Line:
      case ListOfLine:
      case Segment:
      case ListOfSegment:
      case Ray:
      case ListOfRay:
      case Vector:
      case ListOfVector:
      case Circle:
      case ListOfCircle:
      case Arc:
      case ListOfArc:
      case Polygon:
      case ListOfPolygon:
      case AngleMarker:
      case ListOfAngleMarker:
      case DirectedAngleMarker:
      case ListOfDirectedAngleMarker:
      case Transformation:
      case ListOfTransformation:
        return true;
      default:
        return false;
    }
  }
  function _w(e, t, n, r) {
    let s = {};
    r.valueType !== void 0 && (s.valueType = r.valueType),
      s.valueType && se(s.valueType, Point) && e.graphingEnabled() &&
      uu(n.getGraphMode(e, r)) && (s.isMovablePoint = true);
    let { identifier: i, listAccess: o, tree: a } = ah(n);
    if (
      i && (s.identifier = i),
        o && (s.listAccess = o),
        a &&
        (s.call = a,
          r.valueType && se(r.valueType, Transformation) && n instanceof Cr)
    ) {
      let c = n._expression;
      s.transformation_preview_info = {
        type: a.symbol,
        args: c.args.slice(1).map((l) =>
          l.tryGetConcreteTree(e, t).asTypedValue()
        ),
      };
    }
    let u = r.moveStrategy && r.moveStrategy[0];
    if (
      u && "initialValue" in u && u.initialValue !== void 0 &&
      (s.gliderParameter = u.initialValue), Object.keys(s).length > 0
    ) {
      let c = n.getLegalExports(e);
      return {
        parentDependencies: n.getDependencies().filter((p) =>
          !tt[p] && !c.includes(p)
        ),
        ...s,
      };
    }
  }
  function d$(e, t, n) {
    let r = am(n.userData);
    if (!r) return;
    let { input: s, start: i, end: o } = r;
    if (s.trim() === "") return { type: "empty", allowedTypes: [Any] };
    let a = "\\cursor",
      u = s.slice(0, i) + a + " " + s.slice(o),
      c = { start: i, end: i + a.length },
      l = Mi(u, { ...n.parseOptions });
    return l.userData = { ...n.userData, latex: u, latexSelection: c },
      l.isError
        ? l.getCursorContext()
        : od({ policy: e, frame: t }, l).getCursorContext();
  }
  function mc(e, t, n) {
    let r = e.variables;
    if (r && r.length) {
      let s = {};
      for (let i of r) s[i] = true;
      for (let i of We(n)) s[i] = true;
      n = s;
    }
    e.variables = t.sliderVariables(We(n));
  }
  function C1(e, t) {
    if (t.blocksExport) return false;
    let n = t.getDependencies();
    if (n.length === 0) return false;
    for (let r of n) if (!e.validActionVariable(r)) return false;
    return true;
  }
  var q = class {
    constructor(t, n, r, s) {
      this.policy = t,
        this.rawTree = r,
        this.concreteTree = s,
        this.evaluationState = Lw(t, n, r, s);
    }
    graph(t, n) {
      return this.rawTree.tryGraph(this.policy, this.concreteTree, t, n);
    }
    getGraphMode() {
      return this.policy.graphingEnabled()
        ? this.rawTree.getGraphMode(this.policy, this.concreteTree)
        : 10;
    }
    getGraphInfo() {
      return this.rawTree.getGraphInfo(this.policy, this.concreteTree);
    }
    shouldIntersect() {
      if (
        !this.evaluationState.is_graphable ||
        !this.rawTree.userData.shouldGraph || !Si.pointsOfInterest
      ) return false;
      let t = this.getGraphMode();
      return t === 1 || t === 2;
    }
  };
  var ww = new C.Constant(Se(0, 1));
  C.Assignment.prototype.getMoveStrategy = function (e, t, n, r) {
    return this._expression.getMoveStrategy(e, t, n, r);
  };
  function f$(e) {
    return {
      type: "updateSliderNonlinear",
      id: e.id,
      initialValue: e.initialValue,
      min: e.min,
      max: e.max,
      compiled: e.compiled,
      isComplex: e.isComplex,
    };
  }
  function m$(e) {
    return { type: "updateGliderParameter", span: e.span, movesOn: e.movesOn };
  }
  function y$(e) {
    return {
      type: "updateSliderForGlider",
      id: e.sliderId,
      movesOn: e.movesOn,
      min: e.min,
      max: e.max,
    };
  }
  function Fw(e, t, n, r, s, i) {
    let o = t.getDependencies();
    for (let a of o) if (s[a]) return;
    for (let a = o.length - 1; a >= 0; a--) {
      let u = o[a];
      if (i[u]) continue;
      let c = r[u];
      if (c === void 0) continue;
      let l = n[u];
      if (l.order !== 1) continue;
      let f = l.tree.getPolynomialCoefficients(u),
        d = f[1] || ww,
        y = f[0] || ww;
      if (
        !y.isConstant || !d.isConstant || !isFinite(y.asValue()) ||
        !isFinite(d.asValue()) || d.asValue() === 0
      ) continue;
      let g = [-y.asValue() / d.asValue(), 1 / d.asValue()];
      return { symbol: u, id: c, coefficients: g };
    }
  }
  function g$(e, t) {
    for (let n in t) if (t[n].evaluationState.assignment === e) return n;
  }
  function h$(e) {
    let t = {};
    for (let n = 0; n < e.length; n++) t[e[n]] = true;
    return t;
  }
  function D1(e, t) {
    let n = h$(e), r = {};
    for (let s in t) {
      let i = t[s].evaluationState.assignment;
      t[s].evaluationState.is_slidable && n[i] && (r[i] = s);
    }
    return r;
  }
  function Vw(e, t, n, r) {
    let s = [];
    for (let i = 0; i < n.length; i++) {
      let o = n[i], a = {};
      s.push(a);
      for (let u = 0; u < r.length; u++) {
        let c = r[u], l = Tn(t);
        l[c] = void 0;
        let p = o.tryGetConcreteTree(e, l);
        if (p.isError) {
          a[c] = { tree: p, order: 1 / 0 };
          continue;
        } else a[c] = { tree: p, order: p.polynomialOrder(c) };
      }
    }
    return s;
  }
  function Bw(e, t, n) {
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      t[s].order !== 0 && (n[s] = true);
    }
  }
  C.ParenSeq.prototype.getMoveStrategy = function (e, t, n, r) {
    return Gw(this, e, t, n, r);
  };
  function Gw(e, t, n, r, s) {
    var h;
    let i = r.valueType === Complex;
    if (r.valueType !== Point && !i || r.getDependencies().length !== 0) return;
    if (i && Rm(e)) {
      let x = e.getInputSpan();
      return x
        ? [{ type: "updateCoordinate", inputSpan: x }, {
          type: "updateCoordinate",
          inputSpan: x,
        }]
        : void 0;
    }
    let o = e.getDependencies(), a = D1(o, s), u = We(a), c;
    i ? c = Yb(n, e) : c = e.args;
    let l = [{ type: "none" }, { type: "none" }];
    if (c) {
      let x = Vw(t, n, c, u), T = {}, b = {};
      for (let M = 0; M < 2; M++) {
        let P = c[M], D = e.args[M];
        if (D.isConstant && !i) {
          let O = D.getInputSpan();
          l[M] = O
            ? { type: "updateCoordinate", inputSpan: O }
            : { type: "none" };
          continue;
        }
        let S = Fw(t, P, x[M], a, T, b);
        S &&
        (l[M] = {
          type: "updateSlider",
          id: S.id,
          coefficients: S.coefficients,
        },
          T[S.symbol] = true,
          Bw(u, x[M], b)), l[M] || (l[M] = { type: "none" });
      }
      i &&
        (l[0].type === "updateSlider" && l[1].type === "none"
          ? c[1].tryGetConcreteTree(t, n).valueType !== Number &&
            (l[0] = { type: "none" })
          : l[0].type === "none" && l[1].type === "updateSlider" &&
            c[0].tryGetConcreteTree(t, n).valueType !== Number &&
            (l[1] = { type: "none" }));
    }
    let [p, f] = l, d;
    if (
      p.type === "none" && f.type === "none" && u.length === 1 && (d = u[0]), !d
    ) return p.type !== "none" || f.type !== "none" ? l : void 0;
    let y = a[d], g;
    try {
      let x = Tn(n);
      x[d] = void 0, g = e.getConcreteTree(t, x).getCompiledFunction();
    } catch (x) {
      return;
    }
    f0(g);
    let m = s[y].evaluationState;
    return [
      f$({
        id: y,
        initialValue: (h = m.typed_constant_value) == null ? void 0 : h.value,
        min: m.slider_min_number,
        max: m.slider_max_number,
        compiled: g,
        isComplex: i,
      }),
      { type: "none" },
    ];
  }
  function b$(e, t, n, r, s) {
    if (!r.isTypedConstant || r.valueType !== Point) return;
    let i, o, a;
    switch (e.args[1].type) {
      case "Constant": {
        if (
          typeof e.args[1].asValue() != "number" ||
          (i = e.args[0].getConcreteTree(t, n), !i.isTypedConstant)
        ) return;
        a = i.asTypedValue();
        let c = e.args[1].getInputSpan();
        return [c ? m$({ span: c, movesOn: a }) : { type: "none" }, {
          type: "none",
        }];
      }
      case "Identifier": {
        let u = e.args[1]._symbol, l = D1([u], s)[u];
        if (l === void 0) return;
        let p = s[l].evaluationState, f = Tn(n);
        return f[u] = void 0,
          i = e.args[0].getConcreteTree(t, f),
          i.isTypedConstant
            ? (a = i.asTypedValue(),
              o = { min: p.slider_min_number, max: p.slider_max_number },
              [y$({ min: o.min, max: o.max, movesOn: a, sliderId: l }), {
                type: "none",
              }])
            : void 0;
      }
      default:
        return;
    }
  }
  function kw(e, t, n, r, s) {
    if (r.valueType === Complex) return Gw(e, t, n, r, s);
  }
  C.Expression.prototype.getMoveStrategy = function (e, t, n, r) {
    return kw(this, e, t, n, r);
  };
  C.FunctionCall.prototype.getMoveStrategy = function (e, t, n, r) {
    return this._symbol == "glider"
      ? b$(this, e, t, n, r)
      : kw(this, e, t, n, r);
  };
  C.Image.prototype.getMoveStrategy = function (e, t, n, r) {
    if (
      n.center.valueType !== Point || n.center.getDependencies().length !== 0 ||
      !n.width.isConstant || !n.height.isConstant ||
      !n.radianAngle.isConstant || !n.opacity.isConstant
    ) return;
    let s = this.getDependencies(),
      i = D1(s, r),
      o = We(i),
      a = [this.width, this.height];
    this.center.type === "ParenSeq"
      ? a.push(this.center.args[0], this.center.args[1])
      : this.center.type === "Identifier" &&
        (this.center.referencedStatementId = g$(this.center._symbol, r));
    let u = {}, c = {}, l = Vw(e, t, a, o), p = [], f = [2, 3, 0, 1];
    for (let d = 0; d < f.length; d++) {
      let y = f[d], g = a[y];
      if (!g) {
        p[y] = { type: "none" };
        continue;
      }
      if (g.isConstant) {
        let h = g.getInputSpan();
        p[y] = h
          ? { type: "updateCoordinate", inputSpan: h }
          : { type: "none" };
        continue;
      }
      let m = Fw(e, g, l[y], i, u, c);
      m &&
      (p[y] = { type: "updateSlider", id: m.id, coefficients: m.coefficients },
        u[m.symbol] = true,
        Bw(o, l[y], c)), p[y] || (p[y] = { type: "none" });
    }
    if (
      !(p[0].type === "none" && p[1].type === "none" && p[2].type === "none" &&
        p[3].type === "none")
    ) return p;
  };
  var S1 = (e) =>
    e == null ? void 0 : e.some((t) => "isComplex" in t && t.isComplex);
  C.Base.prototype.analyze = function (e, t) {
    return hs(this)
      ? bs(e, t, this)
      : new q(e, t, this, this.tryGetConcreteTree(e, t));
  };
  function Xb(e, t, n, r) {
    if (r.isError) return new q(e, t, n, r);
    if (!e.areAllScalesLinear() && !Ul(r.valueType)) {
      let u = Yl(oe(r.valueType));
      return u.setCursorContext(r.getCursorContext()), new q(e, t, n, u);
    }
    let s = Do(e, r),
      i = r.getDependencies(),
      o,
      a = se(r.valueType, Complex) &&
        s.some((u) => e.validParametricVariable(u));
    switch (
      r instanceof C.IRExpression && i.length > 0 && !a &&
      (r = r.coerceToNumericIfPossible()), r.valueType
    ) {
      case Distribution:
      case ListOfDistribution:
      case EmptyList: {
        o = r;
        break;
      }
      case RGBColor:
      case ListOfColor:
      case Segment:
      case ListOfSegment:
      case Circle:
      case ListOfCircle:
      case Arc:
      case ListOfArc:
      case Line:
      case ListOfLine:
      case Ray:
      case ListOfRay:
      case Vector:
      case ListOfVector:
      case AngleMarker:
      case ListOfAngleMarker:
      case DirectedAngleMarker:
      case ListOfDirectedAngleMarker:
      case Transformation:
      case ListOfTransformation:
      case Action:
      case Polygon:
      case ListOfPolygon:
      case Segment3D:
      case ListOfSegment3D:
      case Vector3D:
      case ListOfVector3D:
      case Triangle3D:
      case ListOfTriangle3D:
      case Sphere3D:
      case ListOfSphere3D:
      case Tone:
      case ListOfTone:
        s.length
          ? o = rn(n.getSliderVariables(e, r)).setDependencies(s)
          : o = r;
        break;
      case Point:
      case Point3D:
      case ListOfPoint:
      case ListOfPoint3D:
      case Complex:
      case ListOfComplex:
        if (s.length) {
          if (e.validParametricVariables(s)) o = r;
          else {
            let u = n.getSliderVariables(e, r);
            o = rn(u).setDependencies(u);
          }
        } else o = r;
        break;
      case MapIntervalPoint:
      case MapIntervalComplex:
      case MapInterval2ToPoint:
      case MapInterval2ToComplex:
      case MapIntervalPoint3D:
      case MapInterval2DPoint3D:
      case ListOfMapIntervalPoint:
      case ListOfMapIntervalComplex:
      case ListOfMapInterval2ToPoint:
      case ListOfMapInterval2ToComplex:
      case ListOfMapIntervalPoint3D:
      case ListOfMapInterval2DPoint3D: {
        s.length === 0
          ? o = r
          : o = rn(n.getSliderVariables(e, r)).setDependencies(s);
        break;
      }
      case Number:
      case ListOfNumber:
        s.length === 0
          ? o = r
          : s.length <= (e.is3dPolicy() ? 2 : 1)
          ? e.is3dPolicy() && i.length > s.length &&
              !e.validImplicitVariables(i)
            ? o = rn(n.getSliderVariables(e, r)).setDependencies(i)
            : e.validExpressionVariables(s)
            ? o = r
            : o = wy(e.implicitDependency(s)).setDependencies(s)
          : e.validImplicitVariables(s)
          ? o = wy().setDependencies(s)
          : o = rn(n.getSliderVariables(e, r)).setDependencies(i);
        break;
      default:
        o = U(`Programming error: unexpected value type ${r.valueType}`);
    }
    return Kr(o) && o.setCursorContext(r.getCursorContext()),
      o = Pd(e, n, o),
      new q(e, t, n, o);
  }
  function Uw(e) {
    return new C.FunctionCall("pdf", [e, new C.Identifier("x")]);
  }
  C.Identifier.prototype.analyze = function (e, t, n) {
    if (this._symbol === br) {
      let i = v1(this, e, t, this.tryGetConcreteTree(e, t), n);
      if (i) return new q(e, t, this, i);
    }
    let r = this.tryGetConcreteTree(e, t, {
        coerceToNumber: "all-except-complex",
      }),
      s = Xb(e, t, this, r);
    return hs(this) && !N1(s) ? bs(e, t, this) : s;
  };
  C.FunctionCall.prototype.analyze = function (e, t, n) {
    let r;
    Qh[this._symbol] && xl(t, this).length === 0 && !e.is3dPolicy()
      ? r = Uw(this).tryGetConcreteTree(e, t)
      : r = this.tryGetConcreteTree(e, t);
    let s = Xb(e, t, this, r);
    if (hs(this) && !N1(s)) return bs(e, t, this);
    let i = this.getMoveStrategy(e, t, r, n);
    if (i) {
      let o = this.getDefaultDragMode(i),
        a = r.asCompilerValue(),
        u = [new C.Constant(a[0]), new C.Constant(a[1])];
      return r = Zb(
        r,
        S1(i)
          ? new C.MovableComplexNumber(u, i, o)
          : new C.MovablePoint(u, i, o),
      ),
        new q(e, t, this, r);
    }
    return s;
  };
  function v1(e, t, n, r, s, i) {
    if (r.valueType !== Complex) return;
    let o = e.getMoveStrategy(t, n, r, s);
    if (!o) return;
    let a = (i != null ? i : e).getDefaultDragMode(o), u = r.asCompilerValue();
    return r = Zb(
      r,
      new C.MovableComplexNumber(
        [new C.Constant(u[0]), new C.Constant(u[1])],
        o,
        a,
      ),
    ),
      r.metaData = e.metaData,
      r;
  }
  C.Expression.prototype.analyze = function (e, t, n) {
    let r = Xb(e, t, this, this.tryGetConcreteTree(e, t));
    if (hs(this) && !N1(r)) return bs(e, t, this);
    let s = v1(this, e, t, r.concreteTree, n);
    return s ? new q(e, t, this, s) : r;
  };
  C.FunctionDefinition.prototype.analyze = function (e, t) {
    var a;
    if (hs(this)) return bs(e, t, this);
    if (tt[this._symbol]) return this.asEquation().analyze(e, t);
    let n = this._symbol.split("_")[0];
    if ((a = tt[n]) != null && a.isFunction) {
      return new q(e, t, this, Zl(this._symbol, n));
    }
    let r = this.tryGetConcreteTree(e, t);
    if (
      r instanceof C.Error && !r.blocksExport && this._argSymbols.length === 1
    ) {
      let u = Tn(t);
      u[this._argSymbols[0]] = new we("identityTransformation");
      let c = this._expression.tryGetConcreteTree(e, u);
      if (c instanceof on && se(c.valueType, Transformation)) {
        return new q(e, t, this, c);
      }
    }
    if (e.is3dPolicy() && e.assignmentForbidden(this._symbol)) {
      return new q(e, t, this, zy(this._symbol));
    }
    if (r.isError) return new q(e, t, this, r);
    let s = this._argSymbols, i = r.getDependencies();
    r instanceof C.IRExpression && i.length > 0 &&
      (r = r.coerceToNumericIfPossible());
    let o = i.filter((u) => s.indexOf(u) === -1);
    if (e.unplottablePolarFunction(this._symbol, i)) {
      return new q(e, t, this, qI());
    }
    if (o.some((u) => e.assignmentForbidden(u))) {
      return new q(e, t, this, Zd(o, this._symbol, s).setDependencies(i));
    }
    if (o.length) {
      let u = this.getSliderVariables(e, r);
      return new q(e, t, this, rn(u).setDependencies(u));
    }
    return !e.areAllScalesLinear() && !Ul(r.valueType)
      ? new q(e, t, this, Yl(oe(r.valueType)))
      : (r = Pd(e, this, r), new q(e, t, this, r));
  };
  C.Assignment.prototype.analyze = function (e, t, n) {
    if (hs(this)) return bs(e, t, this);
    let r = this._symbol;
    if (!e.validLHS(r)) return new q(e, t, this, UI(r));
    if (tt.hasOwnProperty(r) || e.isComplexEnabled() && r === br) {
      return this.asEquation().analyze(e, t);
    }
    let s;
    if (
      this._expression instanceof C.FunctionCall &&
      Qh[this._expression._symbol] && xl(t, this).length === 0 &&
      !e.is3dPolicy()
    ) s = Uw(this._expression).tryGetConcreteTree(e, t);
    else {
      let d = Tn(t);
      d[r] = e.validSolvedVariable(r) ? void 0 : Ac(),
        s = this.tryGetConcreteTree(e, d);
    }
    if (s.isError) return new q(e, t, this, s);
    if (!e.areAllScalesLinear() && !Ul(s.valueType)) {
      return new q(e, t, this, Yl(oe(s.valueType)));
    }
    if (this.isEquation(e, s)) return this.asEquation().analyze(e, t);
    let i = s.valueType === RGBColor || s.valueType === ListOfColor;
    if (e.assignmentForbidden(r) && i) {
      let d = HI(r).allowExport().setDependencies([r]);
      return new q(e, t, this, d);
    }
    let o = s.getDependencies(), a = Do(e, s);
    s instanceof C.IRExpression &&
      !(this.getGraphMode(e, s) === 5 && !e.assignmentForbidden(r)) &&
      (o.length > 0 || e.graphMode(r, a, o) !== 10) &&
      (s = s.coerceToNumericIfPossible());
    let u = a.includes("x") || a.includes("y"),
      c = a.includes("r") || a.includes("theta");
    if (r === "r" && o.includes("phi")) {
      let d = a.includes("z") ? Oy() : BI();
      return new q(e, t, this, d);
    }
    if (r === "rho" && a.includes("z")) {
      let d = o.includes("phi") ? Oy() : GI();
      return new q(e, t, this, d);
    }
    let l = this.getSliderVariables(e, s, o);
    if (e.tooManySliderVariables(o, l, i) || u && c) {
      let d = rn(l).allowExport().setDependencies(l);
      return new q(e, t, this, d);
    }
    let p = v1(this._expression, e, t, s, n, this);
    if (p) return new q(e, t, this, p);
    let f = this.getMoveStrategy(e, t, s, n);
    if (f) {
      let d = this.getDefaultDragMode(f);
      return s = Zb(
        s,
        S1(f)
          ? new C.MovableComplexNumber([s.slot(0), s.slot(1)], f, d)
          : new C.MovablePoint([s.slot(0), s.slot(1)], f, d),
      ),
        new q(e, t, this, s);
    }
    return s = Pd(e, this, s), new q(e, t, this, s);
  };
  C.RecursiveFunctionBaseCase.prototype.analyze = function (e, t) {
    if (hs(this)) return bs(e, t, this);
    if (!this.specifiedArg.valid) {
      return new q(e, t, this, this.specifiedArg.error);
    }
    let n = this.tryGetConcreteTree(e, t);
    if (n.isError) return new q(e, t, this, n);
    let r = this._argSymbols, s = n.getDependencies();
    if (e.is3dPolicy() && e.assignmentForbidden(this._symbol)) {
      return new q(e, t, this, zy(this._symbol));
    }
    let i = s.filter((o) => r.indexOf(o) === -1);
    if (i.includes(this.specifiedArg.argSymbol)) {
      return new q(e, t, this, Ox(this.specifiedArg.argSymbol));
    }
    for (let o of i) {
      if (e.assignmentForbidden(o)) return new q(e, t, this, vx(o));
    }
    if (i.length) {
      let o = this.getSliderVariables(e, n);
      return new q(e, t, this, rn(o).setDependencies(o));
    }
    return !e.areAllScalesLinear() && !Ul(n.valueType)
      ? new q(e, t, this, Yl(oe(n.valueType)))
      : new q(e, t, this, n);
  };
  function Hw(e, t, n) {
    let r = new we(n).tryGetConcreteTree(e, t);
    if (Kr(r)) return r;
    if (r.isTypedConstant) {
      let s = r.asTypedValue();
      if (s !== void 0) return s;
    }
    return IT();
  }
  function x$(e) {
    return e[1] !== 0 && !isNaN(e[1]);
  }
  function zw(e) {
    return e.valueType === ListOfComplex && e.value.some(x$);
  }
  function T$(e, t, n) {
    let [r, s] = n.variables, i = Hw(e, t, r), o = Hw(e, t, s);
    if (!("value" in i)) return i;
    if (!("value" in o)) return o;
    if (zw(i) || zw(o)) return TT(oe(Complex));
  }
  C.Regression.prototype.analyzeRegression = function (e, t, n, r, s) {
    if (!e.isCustomRegressionSupported() && !this.tableRegressionData) {
      return new q(e, t, this, CP());
    }
    if (hs(this)) return bs(e, t, this);
    let i = {
      policy: e,
      frame: t,
      exportFrame: n,
      lastExportFrame: r,
      tableStatements: s,
    };
    if (this.tableRegressionData) {
      let a = T$(e, t, this.tableRegressionData);
      if (a) return new q(e, t, this, a);
    }
    let o = iL(i, this);
    if (
      o instanceof Wa && o.model instanceof C.IRExpression &&
      (o.model = o.model.coerceToNumericIfPossible()),
        this.tableRegressionData && o instanceof Wa
    ) {
      let a = We(o.parameters).filter((u) => !/^regressionparameter_/.test(u));
      if (a.length) return new q(e, t, this, rn(a));
    }
    return new q(e, t, this, o);
  };
  function O1(e, t) {
    let n = this.tryGetConcreteTree(e, t), r = n.getDependencies();
    return r.length
      ? new q(e, t, this, rn(this.getSliderVariables(e, n)).setDependencies(r))
      : new q(e, t, this, this.tryGetConcreteTree(e, t));
  }
  C.Histogram.prototype.analyze = function (e, t) {
    return hs(this)
      ? bs(e, t, this)
      : e.areAllScalesLinear()
      ? O1.call(this, e, t)
      : new q(e, t, this, NT());
  };
  C.DotPlot.prototype.analyze = function (e, t) {
    return hs(this)
      ? bs(e, t, this)
      : e.areAllScalesLinear()
      ? O1.call(this, e, t)
      : new q(e, t, this, RT());
  };
  C.BoxPlot.prototype.analyze = function (e, t) {
    return hs(this)
      ? bs(e, t, this)
      : e.areAllScalesLinear()
      ? O1.call(this, e, t)
      : new q(e, t, this, AT());
  };
  function qw(e) {
    return function (t, n) {
      if (hs(this)) return bs(t, n, this);
      let r = this.tryGetConcreteTree(t, n), s = r.getDependencies();
      if (s.length) {
        return new q(
          t,
          n,
          this,
          rn(this.getSliderVariables(t, r)).setDependencies(s),
        );
      }
      let i = new q(t, n, this, this.tryGetConcreteTree(t, n));
      if (!r.isError) {
        i.evaluationState.expression_type = "TTEST";
        let o = r.args.map((a) => a.asValue());
        i.evaluationState.ttest_results = e.apply(null, o);
      }
      return i;
    };
  }
  C.TTest.prototype.analyze = qw(ttest);
  C.IndependentTTest.prototype.analyze = qw(ittest);
  C.Stats.prototype.analyze = function (e, t) {
    if (hs(this)) return bs(e, t, this);
    let n = this.tryGetConcreteTree(e, t), r = n.getDependencies();
    if (r.length) {
      return new q(
        e,
        t,
        this,
        rn(this.getSliderVariables(e, n)).setDependencies(r),
      );
    }
    let s = new q(e, t, this, this.tryGetConcreteTree(e, t));
    if (!n.isError) {
      s.evaluationState.expression_type = "STATS";
      let i = n.args.map((o) => o.asValue());
      s.evaluationState.stats_results = stats.apply(null, i);
    }
    return s;
  };
  C.Equation.prototype.analyze =
    C.CallAssignment.prototype.analyze =
    C
      .BaseComparator.prototype.analyze =
      I$;
  function I$(e, t) {
    if (hs(this)) return bs(e, t, this);
    if (this.getOperator() !== "=" && !Si.plotInequalities) {
      return new q(e, t, this, Ry());
    }
    let r = uL({ policy: e, frame: t }, this);
    if (r.isError) return new q(e, t, this, r);
    let s = Do(e, r);
    if (r instanceof C.SolvedEquation && s.length) {
      let i = s.concat(r._symbol);
      if (!e.validImplicitVariables(i)) {
        return new q(e, t, this, Ac().setDependencies(i));
      }
    }
    return this.getGraphMode(e, r) === 8 && !e.validImplicitVariables(s)
      ? new q(e, t, this, Ac().setDependencies(s))
      : (r = Pd(e, this, r), new q(e, t, this, r));
  }
  C.DoubleInequality.prototype.analyze = function (e, t) {
    if (hs(this)) return bs(e, t, this);
    if (!Si.plotInequalities) return new q(e, t, this, Ry());
    let n = this.tryGetConcreteTree(e, t);
    if (n.isError) return new q(e, t, this, n);
    let r = n.getDependencies();
    return Jr[this._operators[0]].direction !== Jr[this._operators[1]].direction
      ? new q(e, t, this, _y())
      : e.validDoubleInequalitySymbol(n._symbol)
      ? e.validDoubleInequalityVariables(r)
        ? r.length > 2
          ? new q(
            e,
            t,
            this,
            rn(this.getSliderVariables(e, n)).setDependencies(r),
          )
          : n._expressions[0].getDependencies().indexOf(n._symbol) !== -1 ||
              n._expressions[1].getDependencies().indexOf(n._symbol) !== -1
          ? new q(e, t, this, Ly().setDependencies(r))
          : new q(e, t, this, n)
        : new q(e, t, this, Ay().setDependencies(r))
      : new q(e, t, this, Ay().setDependencies(r));
  };
  C.ComparatorChain.prototype.analyze = function (e, t) {
    if (hs(this)) return bs(e, t, this);
    let n = this.tryGetConcreteTree(e, t);
    if (n.isError) return new q(e, t, this, n);
    let r = n.getDependencies();
    if (r.length) {
      if (e.is3dPolicy()) {
        if (!e.validImplicitVariables(r)) {
          return new q(
            e,
            t,
            this,
            (this.symbols.includes("=") ? YI() : jI()).setDependencies(r),
          );
        }
        if (
          !(this.symbols.every((i) => i === "<" || i === "<=") ||
            this.symbols.every((i) => i === ">" || i === ">=") ||
            this.symbols.every((i) => i === "="))
        ) return new q(e, t, this, _y().setDependencies(r));
        if (this.symbols.includes("=") && !r.includes("z")) {
          return new q(e, t, this, JI().setDependencies(r));
        }
        let s = this._difference.tryGetConcreteTree(e, t);
        return s = Pd(e, this, s), new q(e, t, this, s);
      } else {return this.symbols.includes("=")
          ? new q(e, t, this, QI())
          : this.symbols.length > 2
          ? new q(e, t, this, $x())
          : e.validDoubleInequalityVariables(r)
          ? new q(e, t, this, Ly())
          : new q(
            e,
            t,
            this,
            rn(this.getSliderVariables(e, n)).setDependencies(r),
          );}
    }
    return new q(e, t, this, n);
  };
  C.ParenSeq.prototype.analyze = function (e, t, n) {
    if (hs(this)) return bs(e, t, this);
    let r = this.tryGetConcreteTree(e, t);
    if (r.isError) return new q(e, t, this, r);
    let s = this.getMoveStrategy(e, t, r, n);
    if (s) {
      let i = this.getDefaultDragMode(s),
        o = r.asCompilerValue(),
        a = [new C.Constant(o[0]), new C.Constant(o[1])];
      return r = Zb(r, new C.MovablePoint(a, s, i)), new q(e, t, this, r);
    }
    return Xb(e, t, this, r);
  };
  C.Table.prototype.analyze = function (e, t) {
    let n = this.getConcreteTree(e, t), r = new q(e, t, this, n);
    return r.evaluationState.is_graphable = true, r;
  };
  C.Image.prototype.analyze = function (e, t, n) {
    let r = this.tryGetConcreteTree(e, t);
    if (
      r.radianAngle.isError || r.center.isError || r.width.isError ||
      r.height.isError || r.opacity.isError
    ) return new q(e, t, this, r);
    let s = r.center.getDependencies(),
      i = r.radianAngle.getDependencies(),
      o = r.width.getDependencies(),
      a = r.height.getDependencies(),
      u = r.opacity.getDependencies();
    return s.length || i.length || o.length || a.length || u.length
      ? new q(
        e,
        t,
        this,
        new C.Image({
          center: s.length ? rn(i).setDependencies(s) : r.center,
          radianAngle: i.length ? rn(i).setDependencies(i) : r.radianAngle,
          width: o.length ? rn(o).setDependencies(o) : r.width,
          height: a.length ? rn(a).setDependencies(a) : r.height,
          opacity: u.length ? rn(u).setDependencies(u) : r.opacity,
        }),
      )
      : (r.moveStrategy = this.getMoveStrategy(e, t, r, n),
        new q(e, t, this, r));
  };
  C.Slider.prototype.analyze = function (e, t) {
    if (hs(this)) return bs(e, t, this);
    let n = this.tryGetConcreteTree(e, t), r = n.sliderInfo, s;
    if (r.missingVars.length) {
      let o = ux(r.missingVars);
      s = new q(
        e,
        t,
        this,
        rn(e.sliderVariables(o)).setDependencies(o).allowExport(),
      );
    } else s = new q(e, t, this, n);
    let i = s.evaluationState;
    if (Si.sliders) {
      i.assignment = r.exportedSymbol,
        i.slider_min_number = r.values.min,
        i.slider_max_number = r.values.max,
        i.slider_step_number = r.values.step,
        i.slider_min_valid = r.valids.min,
        i.slider_max_valid = r.valids.max,
        i.slider_step_valid = r.valids.step;
      let o = i.slider_min_valid && i.slider_max_valid && i.slider_step_valid;
      i.is_slider = true,
        i.raw_slider_latex = this.getInputString(),
        i.is_slidable = o,
        i.is_animatable = i.is_slidable && !i.is_graphable,
        r.errMsg && (i.error = r.errMsg.getError());
    }
    return delete i.is_evaluable, s;
  };
  function hs(e) {
    return e.userData && "latex" in e.userData &&
      trimLatex(e.userData.latex).slice(-1) === "=";
  }
  function bs(e, t, n) {
    return new q(e, t, n, $d("="));
  }
  function N1(e) {
    return e.concreteTree.isConstant && e.concreteTree.valueType === Number ||
      e.concreteTree.isTypedConstant && e.concreteTree.valueType === Complex;
  }
  function Zb(e, t) {
    return t.warning = e.warning, t;
  }
  C.Base.prototype.analyzeFourFunction = function (e, t) {
    let n = this.tryGetConcreteTree(e, t);
    return n.isError
      ? new q(e, t, this, n)
      : new q(e, t, this, U(`Unexpected node type ${this.type}`));
  };
  C.Expression.prototype.analyzeFourFunction = function (e, t) {
    let n = this.tryGetConcreteTree(e, t);
    if (n.isError) return new q(e, t, this, n);
    let r = n.getDependencies();
    if (r.length > 0) {
      let s = r[0], i, o = tt[s];
      return o ? i = o.isFunction ? Li(s, e) : _c(s) : i = ef(s),
        new q(e, t, this, i);
    }
    return new q(e, t, this, n);
  };
  C.Assignment.prototype.analyzeFourFunction = function (e, t) {
    return new q(e, t, this, tf());
  };
  C.FunctionDefinition.prototype.analyzeFourFunction = function (e, t) {
    return new q(e, t, this, nf());
  };
  function $w(e, t) {
    return new q(e, t, this, Ua());
  }
  C.Equation.prototype.analyzeFourFunction = $w;
  C.CallAssignment.prototype.analyzeFourFunction = $w;
  function R1(e, t) {
    return new q(e, t, this, Lc());
  }
  C.DoubleInequality.prototype.analyzeFourFunction = R1;
  C.ComparatorChain.prototype.analyzeFourFunction = R1;
  C.BaseComparator.prototype.analyzeFourFunction = R1;
  C.Regression.prototype.analyzeFourFunction = function (e, t) {
    return new q(e, t, this, wc());
  };
  C.ParenSeq.prototype.analyzeFourFunction = function (e, t) {
    return new q(e, t, this, Fc());
  };
  C.Base.prototype.analyzeScientific = function (e, t) {
    let n = this.tryGetConcreteTree(e, t);
    return n.isError
      ? new q(e, t, this, n)
      : new q(e, t, this, U(`Unexpected node type ${this.type}`));
  };
  C.Expression.prototype.analyzeScientific = function (e, t) {
    let n = this.tryGetConcreteTree(e, t);
    if (n.isError) return new q(e, t, this, n);
    let r = n.getDependencies();
    return r.length > 0 ? new q(e, t, this, rn(r)) : new q(e, t, this, n);
  };
  C.Assignment.prototype.analyzeScientific = function (e, t) {
    let n = this._symbol;
    if (tt[n]) return new q(e, t, this, Zl(n));
    let r = Tn(t);
    r[n] = Ua();
    let s = this.tryGetConcreteTree(e, r);
    if (s.isError) return new q(e, t, this, s);
    let i = s.getDependencies();
    return this.isEquation(e, s)
      ? new q(e, t, this, Ua())
      : i.length > 0
      ? new q(e, t, this, rn(i))
      : new q(e, t, this, s);
  };
  C.FunctionDefinition.prototype.analyzeScientific = function (e, t) {
    if (tt[this._symbol]) return new q(e, t, this, Zl(this._symbol));
    let n = this.tryGetConcreteTree(e, t);
    if (n.isError) return new q(e, t, this, n);
    let r = this._argSymbols, s = n.getDependencies();
    if (s.indexOf(this._symbol) !== -1) {
      return new q(
        e,
        t,
        this,
        Rc([this._symbol], { suggestAlternativeFunctionName: false }),
      );
    }
    let i = s.filter((o) => r.indexOf(o) === -1);
    return i.length
      ? new q(e, t, this, Zd(i, this._symbol, r))
      : new q(e, t, this, n);
  };
  function Yw(e, t) {
    return new q(e, t, this, Ua());
  }
  C.Equation.prototype.analyzeScientific = Yw;
  C.CallAssignment.prototype.analyzeScientific = Yw;
  function A1(e, t) {
    return new q(e, t, this, Lc());
  }
  C.DoubleInequality.prototype.analyzeScientific = A1;
  C.ComparatorChain.prototype.analyzeScientific = A1;
  C.BaseComparator.prototype.analyzeScientific = A1;
  C.Regression.prototype.analyzeScientific = function (e, t) {
    return new q(e, t, this, wc());
  };
  C.ParenSeq.prototype.analyzeScientific = function (e, t) {
    return new q(e, t, this, Fc());
  };
  C.Base.prototype.analyzeSingleExpressionScientific = function (e, t) {
    let n = this.tryGetConcreteTree(e, t);
    return n.isError
      ? new q(e, t, this, n)
      : new q(e, t, this, U(`Unexpected node type ${this.type}`));
  };
  C.Expression.prototype.analyzeSingleExpressionScientific = function (e, t) {
    let n = this.tryGetConcreteTree(e, t);
    if (n.isError) return new q(e, t, this, n);
    let r = n.getDependencies();
    if (r.length > 0) {
      let s = r[0], i, o = tt[s];
      return o ? i = o.isFunction ? Li(s, e) : _c(s) : i = ef(s),
        new q(e, t, this, i);
    }
    return new q(e, t, this, n);
  };
  C.Assignment.prototype.analyzeSingleExpressionScientific = function (e, t) {
    return new q(e, t, this, tf());
  };
  C.FunctionDefinition.prototype.analyzeSingleExpressionScientific = function (
    e,
    t,
  ) {
    return new q(e, t, this, nf());
  };
  function Xw(e, t) {
    return new q(e, t, this, Ua());
  }
  C.Equation.prototype.analyzeSingleExpressionScientific = Xw;
  C.CallAssignment.prototype.analyzeSingleExpressionScientific = Xw;
  function _1(e, t) {
    return new q(e, t, this, Lc());
  }
  C.DoubleInequality.prototype.analyzeSingleExpressionScientific = _1;
  C.ComparatorChain.prototype.analyzeSingleExpressionScientific = _1;
  C.BaseComparator.prototype.analyzeSingleExpressionScientific = _1;
  C.Regression.prototype.analyzeSingleExpressionScientific = function (e, t) {
    return new q(e, t, this, wc());
  };
  C.ParenSeq.prototype.analyzeSingleExpressionScientific = function (e, t) {
    return new q(e, t, this, Fc());
  };
  C.Base.prototype.getGraphInfo = function (e, t) {
    let n = t.getDependencies(), r, s;
    switch (n.length) {
      case 0:
        r = Zw(t), s = t.boundDomain("x");
        break;
      case 1:
        s = t.boundDomain(n[0]), hi(s) && !Fs(s) && (r = Zw(t));
        break;
      default:
        s = dr();
        break;
    }
    return {
      graphMode: this.getGraphMode(e, t),
      color: Ra(this.userData, this.metaData),
      pointStyle: this.userData.pointStyle,
      lineStyle: this.userData.lineStyle,
      arrowMode: this.userData.arrowMode,
      operator: this.getOperator(),
      isLinear: !!r,
      linearCoefficients: r,
      domainBound: s,
    };
  };
  function Zw(e) {
    switch (e.valueType) {
      case Number:
        return L1(e);
      case Point: {
        let t = L1(e.slot(0)), n = L1(e.slot(1));
        return !t || !n ? void 0 : [t, n];
      }
      default:
        return;
    }
  }
  function L1(e) {
    let t = e.getDependencies();
    switch (t.length) {
      case 0:
        return [+e.asValue(), 0];
      case 1:
        if (e.polynomialOrder(t[0]) > 1) return;
        let n = e.getPolynomialCoefficients(t[0]);
        return [n[0] ? +n[0].asValue() : 0, n[1] ? +n[1].asValue() : 0];
      default:
        return;
    }
  }
  C.Assignment.prototype.getDefaultDragMode = function (e) {
    return e[0].type !== "none" && e[1].type !== "none"
      ? "XY"
      : e[0].type !== "none"
      ? "X"
      : e[1].type !== "none"
      ? "Y"
      : "NONE";
  };
  C.Expression.prototype.getDefaultDragMode = function (e) {
    return e[0].type === "updateSlider" && e[1].type === "updateSlider"
      ? "XY"
      : e[0].type === "updateSlider"
      ? "X"
      : e[1].type === "updateSlider"
      ? "Y"
      : e[0].type === "updateSliderNonlinear" && e[0].isComplex
      ? "X"
      : "NONE";
  };
  C.FunctionCall.prototype.getDefaultDragMode = function (e) {
    return C.Assignment.prototype.getDefaultDragMode.call(this, e);
  };
  var P$ = C.List;
  C.Base.prototype.tableInfo = function (e, t) {
    return false;
  };
  C.Identifier.prototype.tableInfo = function (e, t) {
    return e.validFirstColumnVariable(this._symbol)
      ? {
        independent_variable: this._symbol,
        dependent_column: this.getInputString(),
        by_reference: false,
      }
      : false;
  };
  C.Expression.prototype.tableInfo = function (e, t) {
    let n = t.getDependencies();
    if (ou(this)) return false;
    switch (t.valueType) {
      case Point:
      case ListOfPoint:
        return n.length !== 0 ||
            t.isMovablePoint &&
              (t.moveStrategy[0].type === "updateSlider" ||
                t.moveStrategy[1].type === "updateSlider")
          ? false
          : {
            independent_variable: "x",
            dependent_column: "y",
            by_reference: false,
            values: P$.wrap(t).asValue(),
          };
      case Number:
        if (n.length !== 1) return false;
        let s = n[0];
        return e.validFirstColumnVariable(s)
          ? {
            independent_variable: s,
            dependent_column: this.getInputString(),
            by_reference: false,
          }
          : false;
      default:
        return false;
    }
  };
  C.Assignment.prototype.tableInfo = function (e, t) {
    if (
      t instanceof C.SolvedEquation || !this.getInputString().length ||
      ou(this) || vd(t.valueType)
    ) return false;
    let n = t.getDependencies();
    if (n.length > 1) return false;
    let r;
    if (n.length === 0) {
      if (!e.tableableAsConstant(this._symbol)) return false;
      r = e.implicitIndependent(this._symbol);
    } else r = n[0];
    if (!e.validFirstColumnVariable(r)) return false;
    let s = e.assignmentForbidden(this._symbol)
      ? trimLatex(this.getInputString().replace(/[^=]*=/, ""))
      : trimLatex(this.getInputString().split("=")[0]);
    return {
      independent_variable: r,
      dependent_column: s,
      by_reference: !e.assignmentForbidden(this._symbol),
    };
  };
  C.FunctionDefinition.prototype.tableInfo = function (e, t) {
    if (
      this._argSymbols.length !== 1 || !this.getInputString().length ||
      t.getDependencies().length > 1
    ) return false;
    let r = this._argSymbols[0];
    if (!e.validFirstColumnVariable(r)) return false;
    let s = e.assignmentForbidden(this._symbol),
      i = s
        ? trimLatex(this.getInputString().replace(/[^=]*=/, ""))
        : trimLatex(this.getInputString().split("=")[0]);
    return { independent_variable: r, dependent_column: i, by_reference: !s };
  };
  C.BaseComparator.prototype.tableInfo = function (e, t) {
    return false;
  };
  C.ComparatorChain.prototype.tableInfo = function (e, t) {
    return false;
  };
  C.DoubleInequality.prototype.tableInfo = function (e, t) {
    return false;
  };
  C.Equation.prototype.tableInfo = function (e, t) {
    return false;
  };
  C.Base.prototype.tableError = function () {
    return this.isInequality()
      ? E("shared-calculator-error-table-inequality-supplement")
      : !(this instanceof C.Expression) && !(this instanceof C.IRExpression)
      ? E("shared-calculator-error-table-generic-supplement")
      : false;
  };
  C.List.prototype.tableError = function () {
    return E("shared-calculator-error-table-list-supplement");
  };
  C.Equation.prototype.tableError =
    C.Assignment.prototype.tableError =
      function () {
        return E("shared-calculator-error-table-equation-supplement");
      };
  C.ComparatorChain.prototype.tableError = function () {
    return this.symbols.includes("=")
      ? E("shared-calculator-error-table-equation-supplement")
      : E("shared-calculator-error-table-inequality-supplement");
  };
  C.FunctionDefinition.prototype.tableError = function () {
    return E("shared-calculator-error-table-function-definition-supplement");
  };
  C.Regression.prototype.tableError = function () {
    return E("shared-calculator-error-table-regression-supplement");
  };
  C.List.prototype.elementAt = function (e) {
    return e = Math.floor(e),
      e >= 0 && e < this.args.length ? this.args[e] : new C.Constant(NaN);
  };
  C.List.prototype.eachElement = function (t) {
    for (let n = 0; n < this.length; n++) t(this.elementAt(n), n);
  };
  C.List.prototype.mapElements = function (t) {
    let n = [];
    for (let r = 0; r < this.length; r++) n.push(t(this.elementAt(r), r));
    return n;
  };
  C.IRExpression.prototype.elementAt = function (e) {
    let t = this._chunk.elementAt(e);
    return new on(t);
  };
  function E$() {
    return identifierToLatex(this._symbol) + " ";
  }
  C.Identifier.prototype.printLatex = E$;
  C.Constant.prototype.printLatex = function () {
    return wa(this.asValue());
  };
  C.Ticker.prototype.printLatex = function () {
    return "\\ticker\\left(" + this.args.map(Ls).join(", ") + "\\right)";
  };
  C.Negative.prototype.printLatex = function () {
    return "-\\left(" + this.args[0].printLatex() + "\\right)";
  };
  C.Add.prototype.printLatex = function () {
    return "\\left(" + this.args[0].printLatex() + "\\right)+\\left(" +
      this.args[1].printLatex() + "\\right)";
  };
  C.PercentOf.prototype.printLatex = function () {
    return this.args[0].printLatex() + " \\% \\operatorname{of} " +
      this.args[1].printLatex();
  };
  C.Subtract.prototype.printLatex = function () {
    return "\\left(" + this.args[0].printLatex() + "\\right)-\\left(" +
      this.args[1].printLatex() + "\\right)";
  };
  C.Multiply.prototype.printLatex = function () {
    return "\\left(" + this.args[0].printLatex() + "\\right)*\\left(" +
      this.args[1].printLatex() + "\\right)";
  };
  C.DotMultiply.prototype.printLatex = function () {
    return "\\left(" + this.args[0].printLatex() + "\\right)\\cdot\\left(" +
      this.args[1].printLatex() + "\\right)";
  };
  C.CrossMultiply.prototype.printLatex = function () {
    return "\\left(" + this.args[0].printLatex() + "\\right)\\times\\left(" +
      this.args[1].printLatex() + "\\right)";
  };
  C.Divide.prototype.printLatex = function () {
    return "\\frac{" + this.args[0].printLatex() + "}{" +
      this.args[1].printLatex() + "}";
  };
  C.Exponent.prototype.printLatex = function () {
    return "\\left(" + this.args[0].printLatex() + "\\right)^{" +
      this.args[1].printLatex() + "}";
  };
  C.Assignment.prototype.printLatex = function () {
    return identifierToLatex(this._symbol) + "=" +
      this._expression.printLatex();
  };
  C.Equation.prototype.printLatex =
    C.CallAssignment.prototype.printLatex =
      function () {
        return this._lhs.printLatex() + "=" + this._rhs.printLatex();
      };
  function Wb(e) {
    switch (e) {
      case ">":
        return ">";
      case "<":
        return "<";
      case ">=":
        return "\\ge ";
      case "<=":
        return "\\le ";
      case "=":
        return "=";
    }
    return "";
  }
  C.BaseComparator.prototype.printLatex = function () {
    return "\\left(" + this.args[0].printLatex() + "\\right)" +
      Wb(this.operator) + "\\left(" + this.args[1].printLatex() + "\\right)";
  };
  C.ComparatorChain.prototype.printLatex = function () {
    let e = "";
    for (let t = 0; t < this.symbols.length; t++) {
      e += `\\left(${this.args[t].printLatex()}\\right)${Wb(this.symbols[t])}`;
    }
    return e += `\\left(${
      this.args[this.args.length - 1].printLatex()
    }\\right)`,
      e;
  };
  C.DoubleInequality.prototype.printLatex = function () {
    return "\\left(" + this.args[0].printLatex() + "\\right)" +
      Wb(this.args[1]) + this.args[2].printLatex() + Wb(this.args[3]) +
      "\\left(" + this.args[4].printLatex() + "\\right)";
  };
  C.Or.prototype.printLatex = function () {
    return this.args[0].printLatex() + "," + this.args[1].printLatex();
  };
  function Ls(e) {
    return e.printLatex();
  }
  function M$() {
    switch (this._symbol) {
      case "sqrt":
        return "\\sqrt{" + this.args[0].printLatex() + "}";
      case "nthroot":
        return "\\sqrt[" + this.args[1].printLatex() + "]{" +
          this.args[0].printLatex() + "}";
      case "logbase":
        return "\\log_{" + this.args[1].printLatex() + "}\\left(" +
          this.args[0].printLatex() + "\\right)";
      default:
        return identifierToLatex(this._symbol) + "\\left(" +
          this.args.map(Ls).join(", ") +
          "\\right)";
    }
  }
  C.FunctionCall.prototype.printLatex = M$;
  C.RecursiveFunctionBaseCase.prototype.printLatex = function () {
    return this.originalNode.printLatex();
  };
  C.SeededFunctionCall.prototype.printLatex = function () {
    return identifierToLatex(this._symbol) + "\\left(" +
      this.args.slice(1).map(Ls).join(", ") + "\\right)";
  };
  C.DotAccess.prototype.printLatex = function () {
    return "(" + this.args[0].printLatex() + ").(" + this.args[1].printLatex() +
      ")";
  };
  C.Prime.prototype.printLatex = function () {
    switch (this.args[0]._symbol) {
      case "logbase":
        return "\\log_{" + this.args[0].args[1].printLatex() + "}" +
          Array(this.order + 1).join("'") + "\\left(" +
          this.args[0].args[0].printLatex() + "\\right)";
      default:
        return identifierToLatex(this.args[0]._symbol) +
          Array(this.order + 1).join("'") +
          "\\left(" + this.args[0].args.map(Ls).join(", ") + "\\right)";
    }
  };
  C.List.prototype.printLatex = function () {
    return "\\left[" + this.args.map(Ls).join(", ") + "\\right]";
  };
  C.Range.prototype.printLatex = function () {
    return "\\left[" + this.args[0].args.map(Ls).join(", ") + " ... " +
      this.args[1].args.map(Ls).join(", ") + "\\right]";
  };
  C.UpdateRule.prototype.printLatex = function () {
    return this.args[0].printLatex() + "\\to(" + this.args[1].printLatex() +
      ")";
  };
  C.ListAccess.prototype.printLatex = function () {
    return "\\left(" + this.args[0].printLatex() + "\\right)\\left[" +
      this.args[1].printLatex() + "\\right]";
  };
  C.ParenSeq.prototype.printLatex = function () {
    return "\\left(" + this.args.map(Ls).join(", ") + "\\right)";
  };
  C.BareSeq.prototype.printLatex = function () {
    return this.args.map(Ls).join(", ");
  };
  C.NamedCoordinateAccess.prototype.printLatex = function () {
    return "\\left(\\left(" + this.args[0].printLatex() + "\\right)." +
      this.symbol + "\\right)";
  };
  C.Norm.prototype.printLatex = function () {
    return "\\left|" + this.args[0].printLatex() + "\\right|";
  };
  C.Sum.prototype.printLatex = function () {
    return "\\sum_{" + this.args[0].printLatex() + "=" +
      this.args[1].printLatex() + "}^{" + this.args[2].printLatex() +
      "}\\left(" + this.args[3].printLatex() + "\\right)";
  };
  C.Product.prototype.printLatex = function () {
    return "\\prod_{" + this.args[0].printLatex() + "=" +
      this.args[1].printLatex() + "}^{" + this.args[2].printLatex() +
      "}\\left(" + this.args[3].printLatex() + "\\right)";
  };
  C.Integral.prototype.printLatex = function () {
    return "\\int_{" + this.args[1].printLatex() + "}^{" +
      this.args[2].printLatex() + "}\\left(" + this.args[3].printLatex() +
      "\\right)d" + this.args[0].printLatex();
  };
  C.FunctionExponent.prototype.printLatex = function () {
    return this.args[0].printLatex() + "\\left(" + this.args[1].printLatex() +
      "\\right)^{" + this.args[2].printLatex() + "}";
  };
  C.FunctionFactorial.prototype.printLatex = function () {
    return this.args[0].printLatex() + "\\left(" + this.args[1].printLatex() +
      "\\right)!";
  };
  function w1(e) {
    return e.isConstant && e.asValue() === true;
  }
  function C$(e) {
    return e.isConstant && e.isNaN();
  }
  C.Piecewise.prototype.printLatex = function () {
    let e = this;
    if (w1(e.args[0])) return e.args[1].printLatex();
    let t = ["\\left\\{"];
    for (;;) {
      if (w1(e.args[0])) {
        t.push(e.args[1].printLatex());
        break;
      }
      if (t.push(e.args[0].printLatex(), ": "), C$(e.args[2])) {
        t.push(e.args[1].printLatex());
        break;
      }
      if (
        t.push(e.args[1].printLatex(), ", "),
          !(e.args[2] instanceof C.Piecewise)
      ) {
        t.push(e.args[2].printLatex());
        break;
      }
      e = e.args[2];
    }
    return t.push("\\right\\}"), t.join("");
  };
  C.Restriction.prototype.printLatex = function () {
    return w1(this.args[0])
      ? "\\left\\{\\right\\}"
      : "\\left\\{" + this.args[0].printLatex() + "\\right\\}";
  };
  C.FunctionDefinition.prototype.printLatex = function () {
    return identifierToLatex(this._symbol) + "\\left(" +
      this._argSymbols.map(identifierToLatex).join(", ") +
      "\\right) = " + this._expression.printLatex();
  };
  C.Derivative.prototype.printLatex = function () {
    return "\\frac{d}{d" + identifierToLatex(this._symbol) + "}\\left(" +
      this.args[0].printLatex() + "\\right)";
  };
  C.Regression.prototype.printLatex = function () {
    return "\\left(" + this._lhs.printLatex() + "\\right)\\sim\\left(" +
      this._rhs.printLatex() + "\\right)";
  };
  C.Histogram.prototype.printLatex = function () {
    return "\\histogram\\left(" + this.args.map(Ls).join(", ") + "\\right)";
  };
  C.DotPlot.prototype.printLatex = function () {
    return "\\dotplot\\left(" + this.args.map(Ls).join(", ") + "\\right)";
  };
  C.BoxPlot.prototype.printLatex = function () {
    return "\\boxplot\\left(" + this.args.map(Ls).join(", ") + "\\right)";
  };
  C.TTest.prototype.printLatex = function () {
    return "\\TTest\\left(" + this.args.map(Ls).join(", ") + "\\right)";
  };
  C.IndependentTTest.prototype.printLatex = function () {
    return "\\IndependentTTest\\left(" + this.args.map(Ls).join(", ") +
      "\\right)";
  };
  C.Stats.prototype.printLatex = function () {
    return "\\Stats\\left(" + this.args.map(Ls).join(", ") + "\\right)";
  };
  C.AssignmentExpression.prototype.printLatex = function () {
    return identifierToLatex(this._symbol) + "=" + this.args[1].printLatex();
  };
  C.ListComprehension.prototype.printLatex = function () {
    return "\\left[" + this._body.printLatex() + "\\operatorname{for}" +
      this._inputLists.map(Ls).join(", ") + "\\right]";
  };
  C.Substitution.prototype.printLatex = function () {
    return "\\left(\\left(" + this._body.printLatex() +
      "\\right)\\operatorname{with}" + this._assignments.map(Ls).join(", ") +
      "\\right)";
  };
  C.Construction.prototype.printLatex = function () {
    return "\\construction ";
  };
  C.ImaginaryUnit.prototype.printLatex = function () {
    return br;
  };
  C.MovableComplexNumber.prototype.printLatex = function () {
    return complexNumberLabel(this.asValue());
  };
  C.Base.prototype.getExpressionType = function (e, t) {
    switch (e) {
      case 114:
        return t && j(t) ? "POINT3D_LIST" : "POINT3D";
      case 100:
      case 128:
        return "CURVE3D_xyz_t";
      case 119:
        return "SEGMENT3D";
      case 129:
        return "VECTOR3D";
      case 130:
      case 103:
        return "SURFACE_xyz_uv";
      case 110:
        return "SURFACE_r_\u03B8z";
      case 124:
        return "SURFACE_r_\u03B8z_AMBIGUOUS";
      case 109:
        return "SURFACE_z_r\u03B8";
      case 111:
        return "SURFACE_r_\u03B8\u03C6";
      case 107:
      case 108:
      case 106:
        return "SURFACE";
      case 118:
        return "SPHERE3D";
      case 117:
        return "TRIANGLE3D";
      case 120:
      case 121:
        return "SURFACE_AMBIGUOUS";
      case 122:
      case 123:
        return "SURFACE_CONSTANT_AMBIGUOUS";
      case 112:
      case 113:
      case 210:
        return "IMPLICIT_SURFACE";
      case 126:
      case 127:
        return "IMPLICIT_SURFACE_AMBIGUOUS";
      case 3:
      case 4:
      case 25:
      case 26:
        return t && j(t) ? "POINT_LIST" : "SINGLE_POINT";
      case 1:
      case 2:
        return "X_OR_Y";
      case 5:
        return "PARAMETRIC";
      case 6:
        return "POLAR";
      case 8:
        return "IMPLICIT";
      case 24:
      case 17:
        return "VECTOR2D";
      case 200:
      case 201:
      case 202:
      case 205:
      case 209:
        return "SLICE";
      case 211:
      case 206:
        return "SLICE_r\u03B8z_at_z";
      case 203:
        return "SLICE_zr\u03B8_at_r";
      case 204:
        return "SLICE_zr\u03B8_at_\u03B8";
      case 213:
        return "SLICE_zr\u03B8_at_xyz";
      case 207:
        return "SLICE_r\u03B8\u03C6_at_\u03B8";
      case 208:
        return "SLICE_r\u03B8\u03C6_at_\u03C6";
      case 212:
        return "SLICE_r\u03B8\u03C6_at_xyz";
      case 214:
      case 215:
        return "SLICE_xyz_uv";
      default:
        return t !== void 0 && se(t, Polygon) ? "POLYGON" : "X_OR_Y";
    }
  };
  C.Histogram.prototype.getExpressionType = function (e, t) {
    return "HISTOGRAM";
  };
  C.DotPlot.prototype.getExpressionType = function (e, t) {
    return "DOTPLOT";
  };
  C.BoxPlot.prototype.getExpressionType = function (e, t) {
    return "BOXPLOT";
  };
  var jb = class extends Q {};
  var Jb = class extends Q {
    constructor(t) {
      super(t), this._symbol = "sphere";
    }
  };
  function D$(e) {
    return function (n) {
      return new e(n);
    };
  }
  var S$ = [
    Ep,
    Mp,
    Ru,
    Cp,
    Dp,
    Sp,
    Ms,
    jb,
    _u,
    vp,
    Lu,
    wu,
    Fu,
    Op,
    Np,
    Rp,
    lo,
    Go,
    Fp,
    Vp,
    Bp,
    Gp,
    ao,
    kp,
    Fr,
    zp,
    $p,
    Hp,
    Up,
    Jb,
    qp,
    Es,
    Xp,
    Zp,
  ];
  for (let e of S$) e.prototype.copyWithArgs = D$(e);
  uo.prototype.copyWithArgs = function (e) {
    return new ps[this.operator](e);
  };
  Au.prototype.copyWithArgs = function (e) {
    return new Au(this.symbols, e);
  };
  Et.prototype.copyWithArgs = function (e) {
    return new Et(this._constantValue);
  };
  rl.prototype.copyWithArgs = function (e) {
    return new rl(this.constructedObjectIds);
  };
  sl.prototype.copyWithArgs = function (e) {
    return new sl(this._symbol, e);
  };
  il.prototype.copyWithArgs = function (e) {
    return new il(this.tag, e);
  };
  gn.prototype.copyWithArgs = function (e) {
    return new gn(new we(this._symbol), e);
  };
  we.prototype.copyWithArgs = function (e) {
    return new we(this._symbol);
  };
  ko.prototype.copyWithArgs = function (e) {
    return new ko();
  };
  Ja.prototype.copyWithArgs = function (e) {
    return new Ja(
      e[0],
      e[1],
      e.slice(2),
      this.shouldCoerceToList,
      this.parameters,
    );
  };
  Ho.prototype.copyWithArgs = function (e) {
    return new Ho(this.symbol, e);
  };
  ul.prototype.copyWithArgs = function (e) {
    return new ul(this.order, e);
  };
  cl.prototype.copyWithArgs = function (e) {
    return new cl(this.value);
  };
  xa.prototype.copyWithArgs = function (e) {
    return new xa(e[0], e.slice(1));
  };
  ll.prototype.copyWithArgs = function (e) {
    return new ll(this._stringValue);
  };
  pl.prototype.copyWithArgs = function (e) {
    return new pl(e, this.moveStrategy, this.defaultDragMode);
  };
  function Ww(e, t, n) {
    try {
      return N$(e, t, n);
    } catch (r) {
      if (!(r instanceof v)) throw r;
      let s = [];
      for (let i of We(n)) {
        s.push({ id: i, stmtAnalysis: new q(e, t, n[i], r) });
      }
      return s;
    }
  }
  function N$(e, t, n) {
    let r = {};
    for (let c of We(n)) r[n[c]._symbol] = n[c];
    let s = new V1(r),
      i = {},
      o = { definitions: i, baseCases: s.getBaseCases() };
    for (let c of We(n)) {
      let l = n[c];
      R$(s, l, o);
    }
    for (let c of s.getBaseCaseExports()) {
      let l = c.analyze(e, t, {});
      for (let p of c.getLegalExports(e)) delete t[p];
      l.rawTree.exportTo(e, l.concreteTree, t);
    }
    let a = Tn(t);
    for (let c of We(i)) a[c] = i[c];
    let u = [];
    for (let c of We(n)) {
      let l = n[c], p = l._symbol, f = i[p];
      f.userData = l.userData,
        f.metaData = l.metaData,
        f instanceof v
          ? u.push({ id: c, stmtAnalysis: new q(e, t, l, f) })
          : u.push({ id: c, stmtAnalysis: f.analyze(e, a, {}) });
    }
    return u;
  }
  var V1 = class {
    constructor(t) {
      this.baseCases = {};
      this.baseCaseExports = [];
      this.analyzedFunctions = {};
      this.recursiveFunctionGroup = t;
      for (let n in t) this.baseCases[n] = [];
      for (let n in this.recursiveFunctionGroup) {
        this.analyzeRecursiveFunctionDefinition(this.recursiveFunctionGroup[n]);
      }
    }
    analyzeRecursiveFunctionDefinition(t) {
      let n;
      for (let r of t.getExternalBaseCases()) this.addBaseCase(r);
      if (t._expression instanceof Fr) {
        n = t._expression;
        do {
          let r = n.args[0], s = n.args[1];
          if (this.recursiveParameterIndex !== void 0 && r instanceof ps["="]) {
            let i = t._argSymbols[this.recursiveParameterIndex],
              o = r.args.findIndex((p) => p instanceof we && p._symbol === i);
            if (o === -1) break;
            let a = r.args[1 - o];
            if (!(a instanceof Et)) break;
            let u = a.asValue(),
              c = t._argSymbols.filter((p, f) =>
                f !== this.recursiveParameterIndex
              ).map((p) => new we(p)),
              l = new Qr(
                t._symbol,
                c,
                {
                  valid: true,
                  argIndex: this.recursiveParameterIndex,
                  argValue: u,
                  functionDefArgSymbols: t._argSymbols,
                  argSymbol: t._argSymbols[this.recursiveParameterIndex],
                },
                s,
                s,
              );
            this.baseCaseExports.push(l), this.addBaseCase(l);
          } else break;
          n = n.args[2];
        } while (n instanceof Fr);
      } else if (t._expression instanceof xa) {
        let r = [];
        for (let s of t._expression._assignments) {
          let i = Qr.fromCallAssignment(this.recursiveFunctionGroup, s);
          if ((i == null ? void 0 : i.specifiedArg.valid) === false) {
            throw i.specifiedArg.error;
          }
          i && t._symbol === i._symbol
            ? (this.baseCaseExports.push(i), this.addBaseCase(i))
            : r.push(s);
        }
        r.length > 0
          ? n = new xa(t._expression._body, r)
          : n = t._expression._body;
      } else n = t._expression;
      this.analyzedFunctions[t._symbol] = { recursiveExpression: n };
    }
    addBaseCase(t) {
      this.baseCases[t._symbol].push(t);
    }
    getBaseCases() {
      return this.baseCases;
    }
    getBaseCaseExports() {
      return this.baseCaseExports;
    }
    getFunctionAnalysis(t) {
      return this.analyzedFunctions[t];
    }
  };
  function R$(e, t, n) {
    let r = e.getFunctionAnalysis(t._symbol);
    if (!r) {
      n.definitions[t._symbol] = t;
      return;
    }
    let s = new Cr(
      new we(t._symbol),
      t._argSymbols.map((i) => new we(i)),
      r.recursiveExpression,
      n,
    );
    s.setExternalBaseCases(t.getExternalBaseCases()),
      n.definitions[t._symbol] = s;
  }
  function Jw(e, t) {
    let n = {};
    for (let r of We(t)) {
      let s = t[r], i = s.metaData;
      if (
        Am(n, r, s.getDependencies()),
          Am(n, r, s.getLegalExports(e)),
          ui(s) && s.userData && s.userData.residualVariable &&
          Am(n, r, [latexToIdentifier(s.userData.residualVariable)]),
          jw(n, r, i),
          Hi(s) && s.columns
      ) {
        for (let o = 0; o < s.columns.length; o++) {
          let a = s.columns[o];
          if (ha(a)) throw U("Unexpected concrete column.");
          !Kr(a) && a.header && a.header.metaData &&
            jw(n, r, a.header.metaData);
        }
      }
    }
    return n;
  }
  function Am(e, t, n) {
    for (let r of n) e[r] || (e[r] = []), e[r].push(t);
  }
  function jw(e, t, n) {
    if (n.extraDepNodes) {
      for (let r of n.extraDepNodes) r && Am(e, t, r.getDependencies());
    }
    n.clickHandler && Am(e, t, n.clickHandler.getDependencies());
  }
  function Ed(e, t, n, r, s) {
    let i = {}, o = {}, a = [], u = [];
    for (let c of We(r)) r[c] && (o[c] = true, a.push(c));
    for (let c of We(s)) s[c] && (i[c] = true, u.push(c));
    for (; a.length || u.length;) {
      for (; a.length;) {
        let c = a.pop(), l = t[c];
        if (l) {
          for (let p of l.getLegalExports(e)) i[p] || (i[p] = true, u.push(p));
        }
      }
      for (; u.length;) {
        let c = u.pop(), l = n[c];
        if (l) { for (let p of l) o[p] || (o[p] = true, a.push(p)); }
      }
    }
    return { ids: o, symbols: i };
  }
  function Qw(e) {
    return e.globalRandomSeed || [];
  }
  var A$ = 100;
  function Qb(e) {
    let t = [];
    for (let n = 0; n < e; n++) t[n] = { x: [], y: [], intersects: [] };
    return t;
  }
  function _$(e, t, n, r) {
    return n === 1 && r === 1 || n === 2 && r === 2
      ? function (s) {
        return t(s) - e(s);
      }
      : n === 1 && r === 2 || n === 2 && r === 1
      ? function (s) {
        return s - t(e(s));
      }
      : false;
  }
  function Kw(e, t) {
    t instanceof C.SolvedEquation
      ? t = t._expression
      : t instanceof C.OptimizedRegression && (t = t.model);
    let n = [], r = [];
    return t instanceof C.DoubleInequality
      ? C.List.eachArgs(t._expressions, (s) => {
        n.push(s[0].getCompiledFunction()),
          r.push(s[0].isConstant && s[1].isNaN()),
          n.push(s[1].getCompiledFunction()),
          r.push(s[1].isConstant && s[1].isNaN());
      })
      : C.List.wrap(t).eachElement((s) => {
        n.push(s.getCompiledFunction()), r.push(s.isConstant && s.isNaN());
      }),
      { functions: n, skipIntersecting: r };
  }
  function L$(e, t) {
    let n = [];
    for (let r in e) {
      if (
        !e.hasOwnProperty(r) || String(r) === String(t) ||
        !e[r].shouldIntersect()
      ) continue;
      let s = e[r], i = Kw(s.policy, s.concreteTree);
      n.push({
        id: r,
        graphMode: s.getGraphMode(),
        functions: i.functions,
        skipIntersecting: i.skipIntersecting,
      });
    }
    return n;
  }
  function w$(e, t) {
    e.intersects = Array(e.x.length);
    for (let n = 0; n < e.x.length; n++) e.intersects[n] = t;
  }
  function F$(e, t) {
    if (t === 1) {
      let n = e.y;
      e.y = e.x, e.x = n;
    }
  }
  function V$(e, t) {
    Array.prototype.push.apply(e.x, t.x),
      Array.prototype.push.apply(e.y, t.y),
      e.intersects && t.intersects &&
      Array.prototype.push.apply(e.intersects, t.intersects);
  }
  function B$(e, t, n) {
    let r = h1(e, t), s = r.poi.zeros, i = r.poi.extrema, o = [], a = 0, u = 0;
    for (a = 0; a < s.x.length; a++) {
      for (; u < i.x.length && i.x[u] < s.x[a]; u++) {
        si(i.y[u], 0) && o.push(i.x[u]);
      }
      o.push(s.x[a]);
    }
    for (; u < i.x.length; u++) si(i.y[u], 0) && o.push(i.x[u]);
    return { x: o, y: o.map(n) };
  }
  function eF(e, t, n) {
    let r = e[n], s = r.getGraphInfo(), i = r.getGraphMode(), o, a, u;
    try {
      o = Kw(r.policy, r.concreteTree),
        a = Qb(o.functions.length),
        u = L$(e, n);
    } catch (l) {
      return Qb(0);
    }
    if (!u) return a;
    let c = 0;
    for (let l = 0; l < u.length; l++) {
      let p = u[l];
      for (let f = 0; f < o.functions.length; f++) {
        if (o.skipIntersecting[f]) continue;
        let d = o.functions[f].fn, y = Td(t, s, d);
        for (let g = 0; g < p.functions.length; g++) {
          if (u[l].skipIntersecting[g]) continue;
          let m = p.functions[g].fn, h = _$(d, m, i, p.graphMode);
          if (!h) continue;
          let x;
          try {
            x = B$(h, y, d);
          } catch (T) {
            return Qb(0);
          }
          if (c += x.x.length, c > A$) return Qb(o.functions.length);
          w$(x, p.id), F$(x, i), V$(a[f], x);
        }
      }
    }
    return a;
  }
  var Rl = class {
    constructor(t) {
      this.localFrames = new Map();
      this.global = Tn(t);
    }
    hasLocalFrame(t) {
      return this.localFrames.has(t);
    }
    getLocalFrame(t) {
      let n = this.localFrames.get(t);
      if (n) return n;
      {
        let r = Tn(this.global);
        return this.localFrames.set(t, r), r;
      }
    }
    deleteLocalFrame(t) {
      this.localFrames.delete(t);
    }
  };
  var Kb = {};
  ia(Kb, { getFrame: () => G$ });
  function G$(e) {
    let t = {};
    return e.additionalFunctions &&
      e.additionalFunctions.indexOf("sqrt") !== -1 && (t.sqrt = tt.sqrt),
      e.width && (t.width = e.width),
      e.height && (t.height = e.height),
      t;
  }
  var _m = {};
  ia(_m, { getFrame: () => q$ });
  var tF = {
    segment: true,
    line: true,
    ray: true,
    circle: true,
    arc: true,
    vector: true,
    glider: true,
    parallel: true,
    perpendicular: true,
    center: true,
    radius: true,
    area: true,
    perimeter: true,
    start: true,
    end: true,
    angles: true,
    angle: true,
    directedangles: true,
    directedangle: true,
    coterminal: true,
    supplement: true,
    vertices: true,
    segments: true,
    intersection: true,
    strictintersection: true,
    translate: true,
    dilate: true,
    rotate: true,
    reflect: true,
    construction: true,
    points: true,
    lines: true,
    circles: true,
    arcs: true,
    polygons: true,
    rays: true,
    anglebisector: true,
  };
  var nF = {
    segment: true,
    triangle: true,
    vector: true,
    start: true,
    end: true,
    sphere: true,
  };
  var rF = [
      "csc",
      "sec",
      "cot",
      "arccsc",
      "arcsec",
      "arccot",
      "csch",
      "sech",
      "coth",
      "arccsch",
      "arcsech",
      "arccoth",
      "mad",
      "cov",
      "covp",
      "distance",
      "midpoint",
    ],
    sF = ["histogram", "dotplot", "boxplot"],
    k$ = [...sF, "polygon"],
    iF = [
      "erf",
      "ttest",
      "tscore",
      "ittest",
      "normaldist",
      "tdist",
      "poissondist",
      "binomialdist",
      "pdf",
      "cdf",
      "random",
      ...sF,
    ],
    H$ = ["distance", "midpoint"],
    z$ = ["det", "inv", "transpose", "rref", "trace"],
    oF = Object.keys(tF).filter((e) => e !== "construction"),
    aF = Object.keys(_d),
    U$ = [
      "complexMultiplyPoints",
      "rawTransform",
      "rawTransformConj",
      "transformWithoutTranslation",
      "transformScaleFactor",
      "scaleTangentTransformation",
      "addTangentVector",
      "addTangentTransformation",
      "complex",
      "complexDivide",
      "coerceComplexToReal",
      "coerceRealToComplex",
    ];
  function ex(e, t) {
    for (let n = 0; n < e.length; n++) {
      let r = e[n];
      if (!t.hasOwnProperty(r)) {
        throw new Error(
          "Programming Error: key '" + r +
            `' does not exist in table. Must be one of:
` + Object.keys(t).join(`
`),
        );
      }
    }
  }
  ex(rF, tt);
  ex(iF, tt);
  ex(oF, tt);
  ex(aF, tt);
  function q$(e) {
    let t = {}, n;
    for (n of We(tt)) {
      if (
        U$.includes(n) ||
        e.restrictedFunctions === true && rF.indexOf(n) !== -1 &&
          !(e.forceEnableGeometryFunctions === true && H$.indexOf(n) !== -1) ||
        e.distributions === false && iF.indexOf(n) !== -1
      ) continue;
      let r = oF.indexOf(n) !== -1, s = n in nF;
      if (r && s) {
        if (!(e.isGeometryCalculator || e.is3DCalculator)) continue;
      } else if (r) { if (!e.isGeometryCalculator) continue; }
      else if (s) { if (!e.is3DCalculator) continue; }
      else if (k$.indexOf(n) !== -1 && e.is3DCalculator) continue;
      aF.indexOf(n) !== -1 && !e.isComplexEnabled ||
        z$.indexOf(n) === -1 && (t[n] = tt[n]);
    }
    return e.trigAngleMultiplier &&
      (t.trigAngleMultiplier = e.trigAngleMultiplier),
      e.globalRandomSeed && (t.globalRandomSeed = e.globalRandomSeed),
      e.initialEvaluation && (t.initialEvaluation = e.initialEvaluation),
      e.globalEventCount && (t.globalEventCount = e.globalEventCount),
      e.width && (t.width = e.width),
      e.height && (t.height = e.height),
      e.isComplexEnabled && (t[br] = new ko()),
      t;
  }
  var B1 = {};
  ia(B1, { getFrame: () => X$ });
  var uF = ["pi", "e", "trigAngleMultiplier"],
    cF = [
      "sqrt",
      "nthroot",
      "abs",
      "ln",
      "sin",
      "cos",
      "tan",
      "log",
      "arcsin",
      "arccos",
      "arctan",
      "mean",
      "round",
      "stdev",
      "stdevp",
      "nCr",
      "nPr",
      "exp",
      "factorial",
    ],
    $$ = [
      "complexMultiplyPoints",
      "complex",
      "complexDivide",
      "coerceComplexToReal",
      "coerceRealToComplex",
      "complexSqrt",
    ],
    Y$ = Object.keys(_d);
  function lF(e, t) {
    for (let n of e) {
      if (!t.hasOwnProperty(n)) {
        throw new Error(
          "Programming Error: key '" + n +
            `' does not exist in table. Must be one of:
` + Object.keys(t).join(`
`),
        );
      }
    }
  }
  lF(uF, tt);
  lF(cF, tt);
  function X$(e) {
    let t = {};
    return uF.forEach((n) => {
      t[n] = tt[n];
    }),
      cF.forEach((n) => {
        e.replaceRoundWithReciprocal && n === "round" || (t[n] = tt[n]);
      }),
      e.trigAngleMultiplier && (t.trigAngleMultiplier = e.trigAngleMultiplier),
      e.isComplexEnabled &&
      (Y$.forEach((n) => t[n] = tt[n]),
        $$.forEach((n) => t[n] = tt[n]),
        t[br] = new ko()),
      e.width && (t.width = e.width),
      e.height && (t.height = e.height),
      t;
  }
  var G1 = {};
  ia(G1, { getFrame: () => Z$ });
  var pF = ["pi", "e", "trigAngleMultiplier"],
    dF = [
      "sqrt",
      "nthroot",
      "abs",
      "ln",
      "sin",
      "cos",
      "tan",
      "log",
      "arcsin",
      "arccos",
      "arctan",
      "exp",
      "factorial",
    ];
  function fF(e, t) {
    for (let n = 0; n < e.length; n++) {
      let r = e[n];
      if (!t.hasOwnProperty(r)) {
        throw new Error(
          "Programming Error: key '" + r +
            `' does not exist in table. Must be one of:
` + Object.keys(t).join(`
`),
        );
      }
    }
  }
  fF(pF, tt);
  fF(dF, tt);
  function Z$(e) {
    let t = {};
    return pF.forEach((n) => {
      t[n] = tt[n];
    }),
      dF.forEach((n) => {
        t[n] = tt[n];
      }),
      e.trigAngleMultiplier && (t.trigAngleMultiplier = e.trigAngleMultiplier),
      e.width && (t.width = e.width),
      e.height && (t.height = e.height),
      t;
  }
  function mF() {
    let e = {}, t = {}, n = {}, r = [], s = {};
    for (let i in this.statements) {
      let o = this.statements[i];
      if (o instanceof co) {
        let a = o.localFrameID;
        if (!a) {
          throw new Error(
            `Programming error: missing localFrameID on table column ${i}`,
          );
        }
        s[a] || (s[a] = []), s[a].push(o);
      }
    }
    for (let i in this.statements) {
      if (!this.statements.hasOwnProperty(i)) continue;
      let o = this.statements[i];
      if (
        !(o.type === "Construction" && !this.policy.isGeometryEnabled()) &&
        o.type !== "Ticker"
      ) {
        switch (o.type) {
          case "Error":
            break;
          case "Regression": {
            n[i] = [], r.push(i);
            break;
          }
          case "TableColumn":
            continue;
          default: {
            let a = o.getLegalExports(this.policy);
            if (o.type === "Table") {
              let u = s[i] || [];
              for (let c of u) {
                for (
                  let l of c.getLegalExports(this.policy)
                ) !l.startsWith("idref_") && !a.includes(l) && a.push(l);
              }
            }
            if (a) {
              for (let c of a) o.localFrameID !== void 0 ? t[c] = i : e[c] = i;
              let u = [];
              for (let c of o.getDependencies()) u.push(c);
              n[i] = cx(u, o.getOptionalDependencies(), a);
            }
            break;
          }
        }
      }
    }
    for (let i of r) {
      let o = this.statements[i],
        a = latexToIdentifier(o.userData.residualVariable);
      a && (t[a] = i);
      let u = o.getDependencies().slice(), c = {}, l;
      for (; l = u.pop();) {
        if (c[l]) continue;
        c[l] = true;
        let p = e[l] || t[l];
        if (p) {
          u.push(...n[p]), n[i].push(l);
          continue;
        }
        t[l] = i;
      }
    }
    return { exportMap: e, weakExportMap: t, dependencyMap: n };
  }
  function yF(e) {
    if (e.length < 2) return "text";
    let t = e.split("`").length - 1;
    return t < 2
      ? "text"
      : t === 2 && e[0] === "`" && e[e.length - 1] === "`"
      ? "latex"
      : "mixed";
  }
  function gF(e) {
    if (e.length === 0) return [""];
    let t = [], n = e.split(/(`)/), r = false, s = "";
    for (let i = 0; i < n.length; i++) {
      let o = n[i];
      o.length &&
        (o === "`"
          ? (s += "`", r = !r, r || (t.push(s), s = ""))
          : (s += o, r || (t.push(s), s = "")));
    }
    return s.length && t.push(s), t;
  }
  function k1(e) {
    return gF(e).map(W$);
  }
  function W$(e) {
    let n = "\\$({" +
        [
          "[a-zA-Z][0-9]*",
          "[a-zA-Z]_[a-zA-Z0-9]+",
          "[a-zA-Z]_\\{[a-zA-Z0-9]+\\}",
          "\\\\[a-zA-Z]+",
          "\\\\[a-zA-Z]+_{[a-zA-Z0-9]+}",
          "\\\\[a-zA-Z]+_[a-zA-Z0-9]+",
        ].join("})|\\$({") + "})",
      r = new RegExp(n, "g"),
      s = [],
      i = 0,
      o = 0,
      a;
    for (; a = r.exec(e);) {
      o = a.index, o > i && s.push(e.substr(i, o - i));
      let u = a[0],
        c = u.replace(/[{}\$]/g, "").replace(/^([a-zA-Z])([0-9]+)$/, "$1_$2");
      s.push({ symbol: c, str: u }), i = a.index + u.length;
    }
    return i < e.length && s.push(e.substr(i)), { raw: e, parts: s };
  }
  var hF = { bigCutoff: 1e7, digits: 8 };
  function bF(e, t) {
    let n = t ? truncatedLatexLabel(e, hF) : truncatedPlainmathLabel(e, hF);
    return t ? `{${n}}` : n;
  }
  function xF(e, t) {
    let n = {
        ...DEFAULT_COMPLEX_EVALUATION_LABEL_OPTIONS,
        digits: 8,
        scientificNotationDigits: 3,
      },
      r = t ? complexNumberLabel(e, n) : complexPlainMathNumberLabel(e, n);
    return t ? `{${r}}` : r;
  }
  function H1(e, t, n, r) {
    return e.map((s) => j$(s, t, n, r)).join("");
  }
  function j$(e, t, n, r) {
    var o, a;
    let s = [], i = yF(e.raw) === "latex";
    for (let u of e.parts) {
      if (typeof u == "string") s.push(u);
      else {
        let c = new C.Identifier(u.symbol).tryGetConcreteTree(t, n, {
          coerceToNumber: "all-except-complex",
        });
        if (c.valueType === Number && c.getDependencies().length === 0) {
          let l = c.asValue();
          if (typeof l == "number") {
            s.push(bF(l, i));
            continue;
          }
        } else if (
          c.valueType === ListOfNumber && r < c.length &&
          c.getDependencies().length === 0
        ) {
          let l = (o = c.elementAt) == null ? void 0 : o.call(c, r).asValue();
          if (typeof l == "number") {
            s.push(bF(l, i));
            continue;
          }
        } else if (
          c.valueType === Complex && c.getDependencies().length === 0
        ) {
          let l = c.asTypedValue();
          if ((l == null ? void 0 : l.valueType) === Complex) {
            s.push(xF(l.value, i));
            continue;
          }
        } else if (
          c.valueType === ListOfComplex && r < c.length &&
          c.getDependencies().length === 0
        ) {
          let l = (a = c.elementAt) == null
            ? void 0
            : a.call(c, r).asTypedValue();
          if ((l == null ? void 0 : l.valueType) === Complex) {
            s.push(xF(l.value, i));
            continue;
          }
        }
        i ? s.push("{?}") : s.push("?");
      }
    }
    return s.join("");
  }
  var Lm = class {
    constructor(t) {
      this.singleExpression = t.singleExpression,
        this.complexEnabled = !!t.isComplexEnabled;
    }
    isGeometryEnabled() {
      return false;
    }
    is3dProduct() {
      return false;
    }
    is3dPolicy() {
      return false;
    }
    isComplexEnabled() {
      return this.complexEnabled;
    }
    isRecursionEnabled() {
      return false;
    }
    polygonUnsupportedPreferTriangle() {
      return false;
    }
    areAllScalesLinear() {
      return true;
    }
    assignmentForbidden(t) {
      return this.singleExpression
        ? t.slice(0, 3) !== "ans"
        : t.slice(0, 3) === "tmp";
    }
    isValidSlider(t) {
      return false;
    }
    sliderVariables() {
      return [];
    }
    graphingEnabled() {
      return false;
    }
    ansEnabled() {
      return !this.singleExpression;
    }
    dimensionVarsEnabled() {
      return false;
    }
    disabledFeatures() {
      return this.singleExpression
        ? [
          "Sum",
          "Product",
          "Integral",
          "Derivative",
          "Piecewise",
          "Substitution",
          "PercentOf",
        ]
        : [
          "Sum",
          "Product",
          "Integral",
          "Derivative",
          "Piecewise",
          "Substitution",
        ];
    }
    shouldIncludeFunctionParametersInRandomSeed() {
      return true;
    }
  };
  function Q$(e) {
    let t = truncatedLatexLabel(e, {
      bigCutoff: 1e9,
      smallCutoff: 1e-6,
      digits: 12,
    });
    return t.indexOf("\\times") === -1
      ? t
      : t[0] === "-"
      ? "-\\left(" + t.substring(1) + "\\right)"
      : "\\left(" + t + "\\right)";
  }
  function K$(e) {
    switch (e) {
      case "exponential":
      case "power":
      case "logarithmic":
        return true;
      case "cubic":
      case "linear":
      case "logistic":
      case "sinusoidal":
      case "quadratic":
      case "quartic":
        return false;
    }
  }
  function e5(e, t) {
    let n = t.parameterValues || {},
      [r, s] = t.variables,
      i = (a) => {
        if (n === "canonical") return a;
        let u = n5(a), c = n && n[u];
        return c !== void 0 ? Q$(c) : u;
      },
      o;
    switch (e) {
      case "linear": {
        let [a, u] = [i("m"), i("b")];
        o = `${[`${a}${r}`, `${u}`].join("+")}`;
        break;
      }
      case "quadratic": {
        let [a, u, c] = [i("a"), i("b"), i("c")];
        o = `${[`${a}${r}^2`, `${u}${r}`, `${c}`].join("+")}`;
        break;
      }
      case "cubic": {
        let [a, u, c, l] = [i("a"), i("b"), i("c"), i("d")];
        o = `${[`${a}${r}^3`, `${u}${r}^2`, `${c}${r}`, `${l}`].join("+")}`;
        break;
      }
      case "quartic": {
        let [a, u, c, l, p] = [i("a"), i("b"), i("c"), i("d"), i("f")];
        o = `${
          [`${a}${r}^4`, `${u}${r}^3`, `${c}${r}^2`, `${l}${r}`, `${p}`].join(
            "+",
          )
        }`;
        break;
      }
      case "exponential": {
        let [a, u] = [i("a"), i("b")];
        o = `${a}\\cdot ${u}^{${r}}`;
        break;
      }
      case "logarithmic": {
        let [a, u] = [i("a"), i("b")];
        o = `${a}+${u}\\cdot \\ln\\left(${r}\\right)`;
        break;
      }
      case "logistic": {
        let [a, u, c] = [i("a"), i("b"), i("c")];
        o = `\\frac{${a}}{1+e^{-\\left(${u}${r}+${c}\\right)}}`;
        break;
      }
      case "power": {
        let [a, u] = [i("a"), i("b")];
        o = `${a}\\cdot ${r}^{${u}}`;
        break;
      }
      case "sinusoidal": {
        let [a, u, c, l] = [i("a"), i("b"), i("c"), i("d")];
        o = `${a}\\cdot \\sin\\left(${u}${r}+${c}\\right)+${l}`;
        break;
      }
      default:
        throw new Error(`Unknown regression type: ${e}`);
    }
    return `${s}${t.operator}${t5(o)}`;
  }
  function t5(e) {
    return e.replace(/\+-/g, "-").replace(/--/g, "");
  }
  function n5(e) {
    return `\\regressionparameter_{${e}}`;
  }
  var TF = /\\regressionparameter_{([^}]+)}/g;
  function jle(e) {
    var n;
    return ((n = e.match(TF)) != null ? n : []).map((r) =>
      r.replace(TF, (s, i) => i)
    );
  }
  function IF(e, t, n, r) {
    let s = e.regression;
    if (!s) return;
    K$(s.type) || (s.isLogMode = false);
    let i = e.columns, { columnIds: o } = s, a = r.get(o.x), u = r.get(o.y);
    if (!(a && u)) return U("Missing columns for table regression");
    let c = [{
        id: a.userData.id,
        isIdentifier: ki(a.header),
        latex: i[a.columnIndex].latex,
      }, {
        id: u.userData.id,
        isIdentifier: ki(u.header),
        latex: i[u.columnIndex].latex,
      }],
      l = [
        c[0].isIdentifier ? c[0].latex : `\\idref_{${c[0].id}}`,
        c[1].isIdentifier ? c[1].latex : `\\idref_{${c[1].id}}`,
      ],
      p = e5(s.type, { operator: "~", variables: l }),
      f = Mi(p, n);
    if (Kr(f)) return f;
    if (!ui(f)) {
      return U(
        `Expected table regression to parse as Regression, but got ${f.type}`,
      );
    }
    let d = f;
    return d.tableRegressionData = {
      tableId: t,
      columnInfo: c != null ? c : [],
      variables: l,
    },
      d.metaData = { extraDepNodes: [] },
      d.userData = {
        id: s.id,
        color: s.color,
        lineStyle: s.lineStyle,
        isLogModeRegression: s.isLogMode,
        shouldGraph: !s.hidden,
        residualVariable: s.residualVariable,
      },
      d;
  }
  var yc = typeof performance != "undefined"
      ? () => performance.now()
      : () => Date.now(),
    {
      Constant: So,
      Seed: EF,
      FunctionCall: a5,
      Image: u5,
      Slider: c5,
      Construction: l5,
    } = C;
  function p5(
    {
      evaluationMode: e,
      is3dProduct: t,
      isBeta3d: n,
      isComplexEnabled: r,
      scales: s,
      includeFunctionParametersInRandomSeed: i,
      customRegressions: o,
      isRecursionEnabled: a,
    },
  ) {
    switch (e) {
      case "fourFunction":
        return new Cc({ singleExpression: false });
      case "singleExpressionFourFunction":
        return new Cc({ singleExpression: true });
      case "scientific":
        return new Lm({ singleExpression: false, isComplexEnabled: r });
      case "singleExpressionScientific":
        return new Lm({ singleExpression: true, isComplexEnabled: r });
      case "graphing":
        return new Id({
          enableGeometry: false,
          enable3d: t,
          scales: s,
          isComplexEnabled: r,
          includeFunctionParametersInRandomSeed: i,
          customRegressions: o,
          isRecursionEnabled: a,
        });
      case "geometry":
        return new Id({
          enableGeometry: true,
          enable3d: false,
          scales: s,
          includeFunctionParametersInRandomSeed: i,
          isComplexEnabled: r,
          customRegressions: o,
          isRecursionEnabled: a,
        });
      case "graphing_3d":
        return new $b({
          beta3d: n,
          includeFunctionParametersInRandomSeed: i,
          isComplexEnabled: r,
          customRegressions: o,
          isRecursionEnabled: a,
        });
    }
  }
  var d5 = {
      fourFunction: Kb,
      singleExpressionFourFunction: Kb,
      scientific: B1,
      singleExpressionScientific: G1,
      graphing: _m,
      graphing_3d: _m,
      geometry: _m,
    },
    sa = "**geo_construction_statement_id**";
  function ri(e, t) {
    let n = Mi(e, t);
    return n.isError || n instanceof C.Expression ? n : Fd();
  }
  function f5(e) {
    let t = e.rawTree.userData, n = e.rawTree.metaData;
    return !!(t.cdf && t.cdf.show && n.distributionSpec);
  }
  function m5(e) {
    let t = e.evaluationState.expression_type, n = e.rawTree.userData;
    return !n.clickableInfo || !n.clickableInfo.enabled
      ? false
      : _f(e.rawTree)
      ? true
      : uu(e.getGraphMode())
      ? false
      : tC(t);
  }
  function yn(e, t) {
    let n = "id" + e;
    for (let [r, s] of t || []) n += "::" + r + s;
    return n;
  }
  var y5 = new So(Se(0, 1)), g5 = new So(Se(1, 1)), h5 = new So(NaN);
  function yi(e, t) {
    return e ? e === "0" ? y5 : e === "1" ? g5 : ri(e, t) : h5;
  }
  function gc(e, t) {
    if (e) return ri(e, t);
  }
  function b5(e) {
    return e.slice(0, 3) !== "ans";
  }
  function x5(e) {
    return e.slice(0, 6) !== "idref_";
  }
  function MF(e, t, n) {
    let { multiplyDefined: r, cycles: s, recursiveFunctionSymbols: i } = e;
    for (let o of s) {
      let a = [...new Set(o.map(({ symbol: u }) => u))].filter(b5).filter(x5)
        .sort();
      for (let { symbol: u, localFrameID: c } of o) {
        if (n && i.has(u)) continue;
        let l = MI(a);
        if (c !== void 0) {
          let p = t.getLocalFrame(c);
          p[u] = l, e.definitionLevel[u] === 1 && (t.global[u] = l);
        } else t.global[u] = l;
      }
    }
    for (let o of We(r)) r.hasOwnProperty(o) && (t.global[o] = Wl(o));
    for (let [o, a] of e.localDependencyOrder) {
      let u = t.getLocalFrame(o);
      for (let c of We(a.multiplyDefined)) u[c] = Wl(c);
    }
  }
  function hc(e, t) {
    return t.localFrameID !== void 0
      ? e.getLocalFrame(t.localFrameID)
      : e.global;
  }
  function T5(e, t, n) {
    let r = e.evaluationState,
      s = e.rawTree,
      i = s.metaData.cdfMin,
      o = s.metaData.cdfMax,
      a = {},
      u = s.type === "Assignment" ? s._expression : s,
      c = u && u.metaData && u.metaData.distributionSpec,
      l = Fa(t, n, i, a, -1 / 0),
      p = Fa(t, n, o, a, 1 / 0),
      f = true,
      d = true;
    if (
      isNaN(l) && (f = false, l = NaN),
        isNaN(p) && (d = false, p = NaN),
        f
          ? d
            ? l > p && (f = false, d = false, r.error = VI().getError())
            : r.error = FI().getError()
          : r.error = wI().getError(),
        f && d
    ) {
      let m = new a5("cdf", [u, new So(l), new So(p)]);
      r.cdf_evaluation = +m.tryGetConcreteTree(t, n).asValue();
    }
    let y = -1 / 0, g = 1 / 0;
    if (
      c &&
      (c.discrete && (y = 0),
        c.symbol === "binomialdist" && u.args && u.args[0])
    ) {
      let m = +u.args[0].asValue();
      isFinite(m) && (g = m);
    }
    s.metaData.evaluatedCDFMin = l,
      s.metaData.evaluatedCDFMax = p,
      r.cdf_min_valid = f,
      r.cdf_max_valid = d,
      r.cdf_min_default = y,
      r.cdf_max_default = g,
      r.is_single_identifier = false,
      mc(r, t, a);
  }
  var q1 = { coerceToNumber: "all" };
  function I5(e, t, n, r, s) {
    let i = {}, o = true, a = NaN, u, c = false;
    if (n) {
      let l = n.tryGetConcreteTree(e, t, q1);
      u = l.getDependencies().length === 0 ? l.asValue() : NaN,
        c = Array.isArray(u),
        a = c ? u : +u;
      for (let p of l.getDependencies()) i[p] = true;
    }
    if (c) {
      for (let l of a) {
        if (!isFinite(+l)) {
          o = false, a = NaN;
          break;
        }
      }
    } else {isFinite(+a)
        ? s !== void 0 && a > s && (a = s)
        : (o = false, a = NaN);}
    return n || (o = true, r !== void 0 && (a = r)),
      { value: a, valid: o, missingVarsMap: i };
  }
  var wm = {
    lineWidth: {
      parseNode: "lineWidth",
      valueOutputProp: "computedLineWidth",
      formulaOutputProp: "",
      validOutputProp: "line_width_valid",
      default: (e, t, n, r) => n.is3dPolicy() ? 1 : 2.5,
      transform: void 0,
      shouldEvaluate: void 0,
      seed: "lw",
    },
    resolution: {
      parseNode: "resolution",
      valueOutputProp: "computedResolution",
      formulaOutputProp: "",
      validOutputProp: "resolution_valid",
      default: () => {},
      transform: void 0,
      shouldEvaluate: void 0,
      seed: "re",
    },
    lineOpacity: {
      parseNode: "lineOpacity",
      valueOutputProp: "computedLineOpacity",
      formulaOutputProp: "",
      validOutputProp: "line_opacity_valid",
      default: () => 1,
      transform: void 0,
      shouldEvaluate: void 0,
      seed: "lo",
    },
    pointOpacity: {
      parseNode: "pointOpacity",
      valueOutputProp: "computedPointOpacity",
      formulaOutputProp: "",
      validOutputProp: "point_opacity_valid",
      default: () => 1,
      transform: void 0,
      shouldEvaluate: void 0,
      seed: "po",
    },
    pointSize: {
      parseNode: "pointSize",
      valueOutputProp: "computedPointSize",
      formulaOutputProp: "",
      validOutputProp: "point_size_valid",
      default: (e, t, n) => n.is3dProduct() ? 3 : 8,
      shouldEvaluate: void 0,
      transform: void 0,
      seed: "ps",
    },
    movablePointSize: {
      parseNode: "movablePointSize",
      valueOutputProp: "computedMovablePointSize",
      formulaOutputProp: "",
      validOutputProp: "movable_point_size_valid",
      default: () => 8,
      shouldEvaluate: void 0,
      transform: void 0,
      seed: "ps",
    },
    fillOpacity: {
      parseNode: "fillOpacity",
      valueOutputProp: "computedFillOpacity",
      formulaOutputProp: "",
      validOutputProp: "fill_opacity_valid",
      default: () => .4,
      transform: void 0,
      shouldEvaluate: (e) => {
        if (!e) return false;
        let { expression_type: t, is_inequality: n } = e.evaluationState;
        return !!(t === "POLYGON" || t === "PARAMETRIC" || n);
      },
      seed: "fo",
    },
    surfaceOpacity: {
      parseNode: "surfaceOpacity",
      valueOutputProp: "computedSurfaceOpacity",
      formulaOutputProp: "",
      validOutputProp: "surface_opacity_valid",
      default: () => 1,
      transform: void 0,
      shouldEvaluate: (e) => {
        if (!e) return false;
        let { expression_type: t } = e.evaluationState;
        return t === "CURVE3D_xyz_t" || t === "SURFACE" || t === "SPHERE3D" ||
          t === "SURFACE_AMBIGUOUS" || t === "SURFACE_CONSTANT_AMBIGUOUS" ||
          t === "IMPLICIT_SURFACE" || t === "IMPLICIT_SURFACE_AMBIGUOUS" ||
          t === "SURFACE_xyz_uv" || t === "SURFACE_z_r\u03B8" ||
          t === "SURFACE_r_\u03B8z" || t === "SURFACE_r_\u03B8\u03C6" ||
          t === "SURFACE_r_\u03B8z_AMBIGUOUS" || t === "TRIANGLE3D";
      },
      seed: "fo",
    },
    labelSize: {
      parseNode: "labelSize",
      valueOutputProp: "computedLabelSize",
      formulaOutputProp: "",
      validOutputProp: "label_size_valid",
      transform: void 0,
      default: () => 1,
      shouldEvaluate: void 0,
      seed: "ls",
    },
    labelAngle: {
      parseNode: "labelAngle",
      valueOutputProp: "computedLabelAngle",
      formulaOutputProp: "label_angle_value",
      validOutputProp: "label_angle_valid",
      default: () => 0,
      transform: (e) => `-\\trigAngleMultiplier*(${e})`,
      shouldEvaluate: void 0,
      seed: "la",
    },
  };
  function CF(e, t, n, r, s, i, o) {
    let a = wm[i], u;
    e && (u = e.tryGetConcreteTree(r, s));
    let c = a.default && a.default(e, u, r, o),
      l = ["lineWidth", "pointSize", "movablePointSize"].indexOf(i) >= 0,
      p = I5(r, s, n[a.parseNode], c, l ? 1e4 : void 0);
    n[a.valueOutputProp] = p.value,
      a.formulaOutputProp && (t[a.formulaOutputProp] = p.value),
      t[a.validOutputProp] = p.valid,
      mc(t, r, p.missingVarsMap);
  }
  function P5(e, t, n, r) {
    let s, i, o;
    if (
      Hi(e.rawTree) && e.evaluationState.column_data && e.rawTree.columns
    ) {
      for (let a = 0; a < e.evaluationState.column_data.length; a++) {
        s = e.evaluationState.column_data[a];
        let u = e.rawTree.columns[a];
        if (!Kr(u)) {
          if (ha(u)) throw U("Unexpected concrete column.");
          i = u.header.metaData,
            o = i[r],
            CF(o, s, i, t, n, r, e.concreteTree.valueType);
        }
      }
    } else {s = e.evaluationState,
        i = e.rawTree.metaData,
        o = i[r],
        CF(o, s, i, t, n, r, e.concreteTree.valueType);}
  }
  function DF(e) {
    return kc(e[0], e[1], e[2]).formatHex();
  }
  function SF(e, t, n, r, s) {
    let i;
    if (e) {
      let o = e.tryGetConcreteTree(r, s),
        a = o.getDependencies().length > 0 ? void 0 : o.asValue(),
        { valueType: u } = o;
      if (i = !!(a && (u === RGBColor || u === ListOfColor)), i) {
        let c = o && o.valueType === RGBColor ? DF(a) : a.map(DF);
        t.colorLatexValue = c, n.color_latex_value = c;
      } else delete t.colorLatexValue, delete n.color_latex_value;
    } else i = true;
    n.color_latex_valid = i;
  }
  function E5(e, t, n) {
    let r, s, i;
    if (
      Hi(e.rawTree) && e.evaluationState.column_data && e.rawTree.columns
    ) {
      for (let o = 0; o < e.evaluationState.column_data.length; o++) {
        r = e.evaluationState.column_data[o];
        let a = e.rawTree.columns[o];
        if (!Kr(a)) {
          if (ha(a)) throw U("Unexpected concrete column.");
          s = a.header.metaData, i = s.colorLatex, SF(i, s, r, t, n);
        }
      }
    } else {r = e.evaluationState,
        s = e.rawTree.metaData,
        i = s.colorLatex,
        SF(i, s, r, t, n);}
  }
  function M5(e) {
    if (
      e.concreteTree.valueType === RGBColor &&
      e.concreteTree.getDependencies().length > 0
    ) {
      let t = e.concreteTree._chunk;
      try {
        e.evaluationState.shader = Ma(t, 0);
      } catch (n) {
        e.evaluationState.error = n instanceof C.Error
          ? n.getError()
          : U(n).getError();
      }
    }
  }
  function C5(e, t, n) {
    let r = e.evaluationState,
      s = e.rawTree,
      i = {},
      o = s.metaData.clickHandler;
    if (!o) return;
    let a = o.tryGetConcreteTree(t, n);
    !a.isError && a.valueType !== Action && (a = kd(oe(a.valueType)));
    for (let c of a.getDependencies()) {
      t.validActionVariable(c) || (i[c] = true);
    }
    let u = Object.keys(i);
    u.length > 0 && (a = rn(u).setDependencies(a.getDependencies())),
      a.isError && !C1(t, a)
        ? r.click_handler = { status: "error", error: a.getError() }
        : a.isEmptyAction
        ? r.click_handler = { status: "empty" }
        : r.click_handler = { status: "maybe-valid" },
      mc(r, t, i);
  }
  function D5(e, t, n) {
    let r, s = e.evaluationState, i = e.rawTree, o, a;
    s.internal_domain_dependency
      ? (r = s.internal_domain_dependency,
        r === "u"
          ? (o = i.metaData.parametricDomain3DuMin,
            a = i.metaData.parametricDomain3DuMax)
          : r === "v"
          ? (o = i.metaData.parametricDomain3DvMin,
            a = i.metaData.parametricDomain3DvMax)
          : (o = i.metaData.parametricDomainMin,
            a = i.metaData.parametricDomainMax))
      : s.expression_type === "POLAR" || R_(s.expression_type)
      ? (o = i.metaData.polarDomainMin,
        a = i.metaData.polarDomainMax,
        r = "theta")
      : (o = i.metaData.parametricDomainMin,
        a = i.metaData.parametricDomainMax,
        r = "t");
    let u = {}, c = !!(o || a), l = Fa(t, n, o, u, 0), p = NaN;
    a ? p = Fa(t, n, a, u, NaN) : s.expression_type === "PARAMETRIC" ||
        s.expression_type === "CURVE3D_xyz_t"
      ? p = 1
      : s.expression_type === "POLAR"
      ? p = Math.PI * 12 / +n.trigAngleMultiplier.asValue()
      : (s.expression_type === "SURFACE_r_\u03B8z" ||
        s.expression_type === "SURFACE_r_\u03B8z_AMBIGUOUS" ||
        s.expression_type === "SLICE_r\u03B8z_at_z") &&
        (p = Math.PI * 2 / +n.trigAngleMultiplier.asValue());
    let f = U1(l, p, s);
    ({ min: l, max: p } = f),
      i.metaData.evaluatedDomainMin = l,
      i.metaData.evaluatedDomainMax = p,
      (s.expression_type === "POLAR" ||
        s.expression_type === "SURFACE_r_\u03B8z" ||
        s.expression_type === "SURFACE_r_\u03B8z_AMBIGUOUS" ||
        s.expression_type === "SLICE_r\u03B8z_at_z") &&
      (i.metaData.isExplicitDomain = c),
      s.domains = [{
        variable: r,
        minNumber: l,
        maxNumber: p,
        minValid: f.minValid,
        maxValid: f.maxValid,
      }],
      s.expression_type === "PARAMETRIC" && delete u.t,
      s.expression_type === "CURVE3D_xyz_t" &&
      (delete u.t, delete u.u, delete u.v),
      mc(s, t, u);
  }
  function S5(e, t, n) {
    let r = e.evaluationState,
      s = r.expression_type,
      i = e.rawTree,
      o,
      a,
      u,
      c,
      l = {},
      p = 0,
      f = 1,
      d = 0,
      y = 1,
      g,
      m;
    O_(s)
      ? (g = "theta",
        m = "phi",
        o = i.metaData.polarDomainMin,
        a = i.metaData.polarDomainMax,
        u = i.metaData.parametricDomain3DphiMin,
        c = i.metaData.parametricDomain3DphiMax,
        f = 2 * Math.PI / +n.trigAngleMultiplier.asValue(),
        y = Math.PI / +n.trigAngleMultiplier.asValue())
      : N_(s)
      ? (g = "r",
        m = "theta",
        o = i.metaData.parametricDomain3DrMin,
        a = i.metaData.parametricDomain3DrMax,
        u = i.metaData.polarDomainMin,
        c = i.metaData.polarDomainMax,
        f = Dr.xmax,
        y = 2 * Math.PI / +n.trigAngleMultiplier.asValue())
      : (g = "u",
        m = "v",
        o = i.metaData.parametricDomain3DuMin,
        a = i.metaData.parametricDomain3DuMax,
        u = i.metaData.parametricDomain3DvMin,
        c = i.metaData.parametricDomain3DvMax),
      p = Fa(t, n, o, l, p),
      f = Fa(t, n, a, l, f),
      d = Fa(t, n, u, l, d),
      y = Fa(t, n, c, l, y);
    let h = U1(p, f, r);
    ({ min: p, max: f } = h);
    let x = U1(d, y, r);
    ({ min: d, max: y } = x),
      i.metaData.evaluatedDomain3DMin1 = p,
      i.metaData.evaluatedDomain3DMax1 = f,
      i.metaData.evaluatedDomain3DMin2 = d,
      i.metaData.evaluatedDomain3DMax2 = y,
      r.domains = [{
        variable: g,
        minNumber: p,
        minValid: h.minValid,
        maxNumber: f,
        maxValid: h.maxValid,
      }, {
        variable: m,
        minNumber: d,
        minValid: x.minValid,
        maxNumber: y,
        maxValid: x.maxValid,
      }],
      (r.expression_type === "SURFACE_xyz_uv" ||
        r.expression_type === "SLICE_xyz_uv") && (delete l.u, delete l.v),
      mc(r, t, l);
  }
  function Fa(e, t, n, r, s) {
    if (n) {
      let i = n.tryGetConcreteTree(e, t, q1);
      for (let o of i.getDependencies()) r[o] = true;
      return i.isConstant ? +i.asValue() : NaN;
    } else return s;
  }
  function U1(e, t, n) {
    let r = true, s = true;
    return isFinite(e) || (r = false, e = NaN),
      isFinite(t) || (s = false, t = NaN),
      r
        ? s
          ? e > t && (r = false, s = false, n.error = LI().getError())
          : n.error = _I().getError()
        : n.error = AI().getError(),
      { min: e, max: t, minValid: r, maxValid: s };
  }
  function v5(e, t, n) {
    let r = e.evaluationState,
      s = e.rawTree,
      i = s.metaData.vizAxisOffset,
      o = s.metaData.vizBreadth,
      a = {},
      u = Fa(t, n, i, a, 1),
      c = Fa(t, n, o, a, 1),
      l = true,
      p = true;
    isFinite(u) || (l = false, u = NaN),
      isFinite(c) || (p = false, c = NaN),
      l ? p || (r.error = kT().getError()) : r.error = GT().getError(),
      s.metaData.evaluatedAxisOffset = u,
      s.metaData.evaluatedBreadth = c,
      r.viz_values = { axisOffset: u, breadth: c },
      r.viz_valids = { axisOffset: l, breadth: p },
      mc(r, t, a);
  }
  function z1(e, t, n) {
    if (e.isError || e.getDependencies().length || e.valueType !== Action) {
      return;
    }
    let r = e.asValue();
    if (r) {
      for (let s of We(r.updateRules)) {
        t[s] = P1(r, s);
        let { value: i, valueType: o } = r.updateRules[s];
        n[s] = new C.Assignment(s, lt(o, i));
      }
    }
  }
  function O5(e, t) {
    if (
      e.type !== "statement" || t.type !== "statement" ||
      ws(e.latexSelection, t.latexSelection)
    ) return false;
    let n = li(e), r = li(t);
    return delete n.latexSelection, delete r.latexSelection, ws(n, r);
  }
  function N5(e, t) {
    if (!(e instanceof Cr)) return false;
    let n = t[e._symbol];
    return n ? !!n.recursionInfo : false;
  }
  var tx = class {
    constructor(t) {
      this.sendMessageForProgressUpdate = t;
      this.statements = {};
      this.analysis = {};
      this.currentStatus = {};
      this.currentLabel = {};
      this.unpublishedIds = {};
      this.selectionOnlyChangeIds = {};
      this.intersectId = void 0;
      this.dirtyExportedSymbolRoots = {};
      this.dirtyStatementRoots = {};
      this.markedRegressionDirty = false;
      this.childIntersections = new hd();
      this.use_degrees = false;
      this.initialEvaluation = false;
      this.globalEventCount = 0;
      this.evaluationMode = "graphing";
      this.product = "graphing";
      this.beta3d = false;
      this.restrictedFunctions = false;
      this.forceEnableGeometryFunctions = false;
      this.functionDefinition = true;
      this.replaceRoundWithReciprocal = false;
      this.distributions = true;
      this.actions = true;
      this.substitutions = true;
      this.intervalComprehensions = true;
      this.recursion = true;
      this.lastClockTickTime = void 0;
      this.dimensions = { width: 0, height: 0 };
      this.includeFunctionParametersInRandomSeed = true;
      this.complex = false;
      this.customRegressions = true;
      this.getCLSymbolMap = mF;
      this.invalidate();
    }
    invalidate() {
      delete this.statements[sa];
      for (let t in this.statements) {
        this.statements.hasOwnProperty(t) && this.markAsDirtyRoot(t);
      }
      this.currentStatus = {},
        this.analysis = {},
        this.setPolicy(),
        this.parent_frame = d5[this.evaluationMode].getFrame({
          restrictedFunctions: this.restrictedFunctions,
          forceEnableGeometryFunctions: this.forceEnableGeometryFunctions,
          isGeometryCalculator: this.evaluationMode === "geometry",
          is3DCalculator: this.product === "graphing-3d",
          isComplexEnabled: this.complex,
          replaceRoundWithReciprocal: this.replaceRoundWithReciprocal,
          distributions: this.distributions,
          additionalFunctions: this.additionalFunctions,
          disableParentheses: this.disableParentheses,
          trigAngleMultiplier: new So(
            this.use_degrees ? Math.PI / 180 : Se(1, 1),
          ),
          initialEvaluation: new So(this.initialEvaluation ? 1 : 0),
          globalEventCount: new So(0),
          globalRandomSeed: new EF(this.globalRandomSeedString || ""),
          width: this.policy.dimensionVarsEnabled()
            ? new So(Se(this.dimensions.width, 1))
            : Hy("width"),
          height: this.policy.dimensionVarsEnabled()
            ? new So(Se(this.dimensions.height, 1))
            : Hy("height"),
        }),
        this.mainFrameContext = new Rl(this.parent_frame),
        this.lastFrame = Tn(this.parent_frame),
        this.regressionFrameContext = new Rl(this.parent_frame),
        this.lastClockTickTime = void 0;
    }
    setPolicy() {
      let t = this.viewState
        ? {
          xAxisScale: this.viewState.xAxisScale,
          yAxisScale: this.viewState.yAxisScale,
        }
        : void 0;
      this.policy = p5({
        evaluationMode: this.evaluationMode,
        is3dProduct: this.product === "graphing-3d",
        isBeta3d: this.beta3d,
        isComplexEnabled: this.complex,
        scales: t,
        includeFunctionParametersInRandomSeed:
          this.includeFunctionParametersInRandomSeed,
        customRegressions: this.customRegressions,
        isRecursionEnabled: this.recursion,
      });
    }
    getAllActionUpdateSymbols() {
      var n;
      let t = new Set();
      for (let r in this.statements) {
        let s = this.statements[r];
        s.getUpdateSymbols().forEach((o) => t.add(o)),
          s instanceof C.Ticker &&
          s.handler.getUpdateSymbols().forEach((o) => t.add(o));
        let i = this.analysis[r];
        (_f(s) ||
          i && !uu(i.getGraphMode()) &&
            tC(i.evaluationState.expression_type)) &&
          ((n = s.metaData.clickHandler) == null ||
            n.getUpdateSymbols().forEach((o) => t.add(o)));
      }
      return [...new Set(t)];
    }
    processChangeSet(t) {
      let n = yc(),
        r = { cacheWrites: 0, cacheReads: 0, cacheHits: 0, cacheMisses: 0 };
      wO(r);
      let s = { intersections: {}, graphs: {} };
      t.isCompleteState &&
        (this.invalidate(), this.statements = {}, this.currentLabel = {});
      let i = !!t.isCompleteState && !t.isUndoRedoState;
      i !== this.initialEvaluation &&
      (this.initialEvaluation = i,
        this.parent_frame.initialEvaluation = new So(i ? 1 : 0)),
        t.hasOwnProperty("logInternalErrors") && Dx(t.logInternalErrors),
        t.viewState && this.setViewState(t.viewState),
        t.hasOwnProperty("degreeMode") && this.setDegreeMode(t.degreeMode),
        t.hasOwnProperty("globalRandomSeed") &&
        this.setGlobalRandomSeed(t.globalRandomSeed),
        t.hasOwnProperty("includeFunctionParametersInRandomSeed") &&
        this.setIncludeFunctionParametersInRandomSeed(
          t.includeFunctionParametersInRandomSeed,
        ),
        t.hasOwnProperty("evaluationMode") &&
        this.setEvaluationMode(t.evaluationMode),
        t.hasOwnProperty("additionalFunctions") &&
        this.setAdditionalFunctions(t.additionalFunctions),
        t.hasOwnProperty("disableParentheses") &&
        this.setDisableParentheses(t.disableParentheses),
        t.hasOwnProperty("restrictedFunctions") &&
        this.setRestrictedFunctions(t.restrictedFunctions),
        t.hasOwnProperty("forceEnableGeometryFunctions") &&
        this.setForceEnableGeometryFunctions(t.forceEnableGeometryFunctions),
        t.hasOwnProperty("distributions") &&
        this.setDistributions(t.distributions),
        t.hasOwnProperty("functionDefinition") &&
        this.setFunctionDefinition(t.functionDefinition),
        t.hasOwnProperty("replaceRoundWithReciprocal") &&
        this.setReplaceRoundWithReciprocal(t.replaceRoundWithReciprocal),
        t.hasOwnProperty("pointsOfInterest") &&
        this.setWorkerConfigProperty("pointsOfInterest", t.pointsOfInterest),
        t.hasOwnProperty("plotSingleVariableImplicitEquations") &&
        this.setWorkerConfigProperty(
          "plotSingleVariableImplicitEquations",
          t.plotSingleVariableImplicitEquations,
        ),
        t.hasOwnProperty("plotImplicits") &&
        this.setWorkerConfigProperty("plotImplicits", t.plotImplicits),
        t.hasOwnProperty("plotInequalities") &&
        this.setWorkerConfigProperty("plotInequalities", t.plotInequalities),
        t.hasOwnProperty("sliders") &&
        this.setWorkerConfigProperty("sliders", t.sliders),
        t.hasOwnProperty("actions") && this.setActions(!!t.actions),
        t.hasOwnProperty("substitutions") &&
        this.setSubstitutions(!!t.substitutions),
        t.hasOwnProperty("intervalComprehensions") &&
        this.setIntervalComprehensions(!!t.intervalComprehensions),
        t.hasOwnProperty("recursion") && this.setRecursion(!!t.recursion);
      let o = t.recursionDepthLimit;
      if (
        o !== void 0 && o > 0 && o <= 10 ** 6 &&
        testingOnlySetRecursiveDepthLimit(o),
          t.hasOwnProperty("beta3d") && this.setBeta3d(!!t.beta3d),
          t.hasOwnProperty("product") && this.setProduct(t.product),
          t.hasOwnProperty("selectedIds")
      ) {
        let f = t.selectedIds || {};
        if (this.intersectId === void 0 || !f[this.intersectId]) {
          let [d] = Object.keys(f);
          this.intersectId = d;
        }
      }
      if (
        t.hasOwnProperty("dimensions") && this.setDimensions(t.dimensions),
          t.hasOwnProperty("complex") &&
          (this.setComplex(!!t.complex), !t.isCompleteState)
      ) throw U("Complex mode changed without a complete change set.");
      t.hasOwnProperty("customRegressions") &&
        this.setCustomRegressions(!!t.customRegressions);
      let a = yc();
      this.processStatements(t, s);
      let u = yc();
      r.processStatements = u - a, a = u;
      let c = this.updateAnalysis();
      u = yc(), r.updateAnalysis = u - a, a = u;
      let l = this._publishAllStatuses();
      u = yc(),
        r.publishAllStatuses = u - a,
        a = u,
        this._computeAllLabels(),
        u = yc(),
        r.computeAllLabels = u - a,
        a = u,
        this._computeAriaDescriptions(),
        u = yc(),
        r.computeAriaDescriptions = u - a,
        a = u,
        this._graphAllChanged(s),
        u = yc(),
        r.graphAllChanges = u - a,
        r.updateIntersections = 0;
      let p = this.processEvents(t.events);
      return this.unpublishedIds = {},
        this.selectionOnlyChangeIds = {},
        r.timeInWorker = u - n,
        {
          syncId: t.syncId,
          isCompleteState: t.isCompleteState,
          intersectionChanges: s.intersections,
          statusChanges: l,
          graphChanges: s.graphs,
          timingData: r,
          eventUpdates: p,
          dependencyOrder: {
            definitionLevel: c.definitionLevel,
            multiplyDefined: c.multiplyDefined,
          },
        };
    }
    processStatements(t, n) {
      if (t.removes) {
        for (let r in t.removes) {
          if (!t.isCompleteState && this.statements.hasOwnProperty(r)) {
            let s = this.statements[r];
            if (Hi(s)) {
              for (let i of s.getColumnIdsForGraphing()) {
                this._notifyGraphRemoved(i, n);
              }
            }
          }
          this.removeStatement(r, n);
        }
      }
      if (t.statements) {
        for (let r in t.statements) {
          let s = t.statements[r];
          s === null || this.addStatement(s, n);
        }
      }
    }
    setViewState(t) {
      if (ws(t, this.viewState)) return;
      let n = !!(this.viewState && t.xAxisScale === this.viewState.xAxisScale &&
        t.yAxisScale === this.viewState.yAxisScale);
      if (this.viewState = t, n) {
        for (let r in this.statements) {
          this.statements.hasOwnProperty(r) && this.markUnpublished(r);
        }
      } else this.invalidate();
    }
    getViewState() {
      return this.viewState;
    }
    setDegreeMode(t) {
      this.use_degrees = t, this.invalidate();
    }
    setDimensions(t) {
      t !== void 0 && (this.dimensions = t, this.invalidate());
    }
    setGlobalRandomSeed(t) {
      this.globalRandomSeedString = t,
        this.parent_frame.globalRandomSeed = new EF(t),
        this.dirtyExportedSymbolRoots.globalRandomSeed = true;
    }
    setIncludeFunctionParametersInRandomSeed(t) {
      this.includeFunctionParametersInRandomSeed = t, this.setPolicy();
    }
    setEvaluationMode(t) {
      this.evaluationMode = t, this.invalidate();
    }
    setProduct(t) {
      this.product = t, this.invalidate();
    }
    setBeta3d(t) {
      this.beta3d = t, this.invalidate();
    }
    setAdditionalFunctions(t) {
      this.additionalFunctions = t, this.invalidate();
    }
    setDisableParentheses(t) {
      this.disableParentheses = t, this.invalidate();
    }
    setRestrictedFunctions(t) {
      this.restrictedFunctions = t, this.invalidate();
    }
    setForceEnableGeometryFunctions(t) {
      this.forceEnableGeometryFunctions = t, this.invalidate();
    }
    setDistributions(t) {
      this.distributions = t, this.invalidate();
    }
    setFunctionDefinition(t) {
      this.functionDefinition = t, this.invalidate();
    }
    setReplaceRoundWithReciprocal(t) {
      this.replaceRoundWithReciprocal = t, this.invalidate();
    }
    setActions(t) {
      t !== this.actions && (this.actions = t, this.invalidate());
    }
    setSubstitutions(t) {
      t !== this.substitutions && (this.substitutions = t, this.invalidate());
    }
    setIntervalComprehensions(t) {
      t !== this.intervalComprehensions &&
        (this.intervalComprehensions = t, this.invalidate());
    }
    setRecursion(t) {
      t !== this.recursion && (this.recursion = t, this.invalidate());
    }
    setComplex(t) {
      t !== this.complex && (this.complex = t, this.invalidate());
    }
    setCustomRegressions(t) {
      t !== this.customRegressions &&
        (this.customRegressions = t, this.invalidate());
    }
    setWorkerConfigProperty(t, n) {
      n !== Si[t] && (Si[t] = n, this.invalidate());
    }
    _publishAllStatuses() {
      let t = {}, n = this.currentStatus;
      this.currentStatus = {};
      for (
        let r in { ...this.unpublishedIds, ...this.selectionOnlyChangeIds }
      ) {
        if (!this.analysis.hasOwnProperty(r)) continue;
        let s = this.analysis[r].evaluationState;
        ws(s, n[r]) || (t[r] = s), this.currentStatus[r] = s;
      }
      return t;
    }
    _computeAllLabels() {
      for (let t in this.currentLabel) {
        let n = this.statements[t];
        if (!n) continue;
        let r = hc(this.mainFrameContext, n),
          s = n.tryGetConcreteTree(this.policy, r),
          i = 1;
        (s.valueType === ListOfPoint || s.valueType === ListOfComplex ||
          s.valueType === ListOfSegment ||
          s.valueType === ListOfPolygon || s.valueType === ListOfAngleMarker ||
          s.valueType === ListOfDirectedAngleMarker) &&
          (i = s.length);
        let o = [], a = this.currentLabel[t];
        if (Bo(a)) {
          for (let u = 0; u < i; u++) o.push(H1(a, this.policy, r, u));
        }
        ws(o, n.computedLabels) ||
          (n.computedLabels = o, this.markUnpublished(t));
      }
    }
    _computeAriaDescriptions() {
      for (let t in this.analysis) {
        let n = this.analysis[t],
          r = n.evaluationState,
          i = n.rawTree.userData,
          o;
        if (i.description ? o = i.description : i.label && (o = i.label), o) {
          r.computed_description = [];
          let a = 1;
          n.concreteTree.isList
            ? a = n.concreteTree.length
            : r.dimensions && r.dimensions.x && Array.isArray(r.dimensions.x) &&
              (a = r.dimensions.x.length);
          for (let u = 0; u < a; u++) {
            r.computed_description.push(
              H1(
                k1(o),
                this.policy,
                hc(this.mainFrameContext, this.statements[t]),
                u,
              ),
            );
          }
        }
      }
    }
    _graphAllChanged(t) {
      var i;
      let n = this.getViewState();
      if (!n || !Mw(n)) return;
      let r = false, s = false;
      for (let o in this.unpublishedIds) {
        if (!this.analysis.hasOwnProperty(o)) continue;
        let a = this.analysis[o],
          u = a.evaluationState.expression_type,
          c = u === "SINGLE_POINT" || u === "POINT_LIST";
        if (Hi(a.rawTree)) {
          let l = a.graph(n, void 0), p = a.rawTree.getColumnIdsForGraphing();
          for (let f of p) {
            l[f]
              ? this._notifyGraphComputed(f, l[f], t)
              : this._notifyGraphRemoved(f, t);
          }
          if ((i = a.rawTree.regression) != null && i.userData) {
            let f = a.rawTree.regression.userData.id, d = this.analysis[f];
            if (
              d != null && d.evaluationState.is_graphable &&
              a.rawTree.regression.userData.shouldGraph
            ) {
              let y = d.graph(n, void 0);
              this._notifyGraphComputed(f, y, t);
            } else this._notifyGraphRemoved(f, t);
          }
        } else {a.evaluationState.is_graphable &&
              (a.rawTree.userData.shouldGraph ||
                a.rawTree.userData.showLabel && c)
            ? (this.postProgressUpdate("GRAPHING", [o]),
              s = true,
              this._notifyGraphComputed(
                o,
                a.graph(n, this.childIntersections.getChildIntersections(o)),
                t,
              ),
              o === this.intersectId &&
              (r = true, this._updateIntersections(o, t)),
              this.postProgressUpdate("UNPUBLISHED", [o]))
            : ga(a.rawTree) || this._notifyGraphRemoved(o, t);}
      }
      s && !r && (this.lastComputedIntersectId = void 0),
        this.intersectId !== void 0 && !r &&
        (s || this.intersectId !== this.lastComputedIntersectId) &&
        this._updateIntersections(this.intersectId, t);
    }
    _notifyGraphRemoved(t, n) {
      n.graphs[t] = void 0;
    }
    _notifyGraphComputed(t, n, r) {
      sO(n), r.graphs[t] = n;
    }
    _updateIntersections(t, n) {
      if (this.lastComputedIntersectId = t, !this.viewState) return;
      if (!this.analysis[t] || !this.analysis[t].shouldIntersect()) {
        n.intersections[t] = [];
        return;
      }
      this.postProgressUpdate("GRAPHING", [t]);
      let r = eF(this.analysis, this.viewState, t);
      n.intersections[t] = r, this.postProgressUpdate("UNPUBLISHED", [t]);
    }
    getDisabledFeatures() {
      let t = this.policy.disabledFeatures();
      this.functionDefinition === false && (t = t.concat("FunctionDefinition")),
        this.actions === false && (t = t.concat("UpdateRule")),
        this.substitutions === false &&
        (t = t.concat(["Substitution", "ListComprehension"]));
      let n = this.additionalFunctions || [];
      return t = t.filter((r) =>
        !(r === "Exponent" && n.indexOf("exponent") !== -1 ||
          r === "PercentOf" && n.indexOf("percent") !== -1)
      ),
        t;
    }
    areFractionsDisallowed() {
      let { evaluationMode: t } = this;
      return t !== "fourFunction" && t !== "singleExpressionFourFunction"
        ? false
        : !this.additionalFunctions ||
          this.additionalFunctions.indexOf("fraction") === -1;
    }
    addStatement(t, n) {
      if (!t) return;
      let r = t.id,
        s = this.statements[r],
        i = s == null ? void 0 : s.userData,
        o = !!i && O5(i, t) && !N5(s, this.mainFrameContext.global),
        a = {
          index: this.policy.ansEnabled() ? t.index : void 0,
          disabledFeatures: this.getDisabledFeatures(),
          disallowFrac: this.areFractionsDisallowed(),
          disableParentheses: !!this.disableParentheses,
          allowIntervalComprehensions: !!this.intervalComprehensions,
          seedPrefix: yn(r),
          writeIntegral: this.evaluationMode === "geometry",
          specializeDoubleInequalities: !this.policy.is3dProduct(),
          includeFunctionParametersInRandomSeed:
            this.includeFunctionParametersInRandomSeed,
        },
        u = { extraDepNodes: [] };
      switch (t.type) {
        case "table":
          let p;
          if (s && Hi(s)) {
            p = new Set([
              ...s.getColumnIdsForGraphing(),
              ...s.getColumnStatementIds(),
            ]);
            let _ = s.getRegressionId();
            _ !== void 0 && p.add(_);
          }
          t.shouldGraph = true;
          let f = t.columns,
            d = [],
            y = new Map(),
            g = (_) => !_.replace(/\\space|\\ /g, "").match(/\S/);
          for (let _ = 0; _ < f.length; _++) {
            let L = f[_],
              w = Mi(L.latex, {
                ...a,
                seedPrefix: yn(r, [["tr", 0], ["tc", _]]),
              }),
              G = [],
              k = -1;
            for (let re = 0; re < f[_].values.length; re++) {
              g(L.values[re]) ? G.push(new So(NaN)) : (G.push(
                Mi(L.values[re], {
                  ...a,
                  seedPrefix: yn(r, [["tr", re + 1], ["tc", _]]),
                }),
              ),
                k = re);
            }
            G = G.slice(0, k + 1);
            let Z = new co(w, G, t.id, _), F = `dcgcolumnstmt${L.id}`;
            Z.userData = { id: F },
              y.set(L.id, Z),
              this.updateSingleStatement(F, Z, { selectionOnlyChange: o });
            let Y = new co(w, G, t.id, _);
            if (Y.userData = L, Y.header) {
              if (
                Y.header.userData = L,
                  Y.header.metaData = { extraDepNodes: [] },
                  L.colorLatex
              ) {
                let re = ri(L.colorLatex, {
                  ...a,
                  seedPrefix: yn(r, [["tr", 0], ["tc", _], ["cl", _]]),
                });
                Y.header.metaData.colorLatex = re,
                  Y.header.metaData.extraDepNodes.push(re);
              }
              if (L.pointSize) {
                let re = ri(L.pointSize, {
                  ...a,
                  seedPrefix: yn(r, [["tr", 0], ["tc", _], ["ps", _]]),
                });
                Y.header.metaData.pointSize = re,
                  Y.header.metaData.extraDepNodes.push(re);
              }
              if (L.pointOpacity) {
                let re = ri(L.pointOpacity, {
                  ...a,
                  seedPrefix: yn(r, [["tr", 0], ["tc", _], ["po", _]]),
                });
                Y.header.metaData.pointOpacity = re,
                  Y.header.metaData.extraDepNodes.push(re);
              }
              if (L.lineWidth) {
                let re = ri(L.lineWidth, {
                  ...a,
                  seedPrefix: yn(r, [["tr", 0], ["tc", _], ["lw", _]]),
                });
                Y.header.metaData.lineWidth = re,
                  Y.header.metaData.extraDepNodes.push(re);
              }
              if (L.lineOpacity) {
                let re = ri(L.lineOpacity, {
                  ...a,
                  seedPrefix: yn(r, [["tr", 0], ["tc", _], ["lo", _]]),
                });
                Y.header.metaData.lineOpacity = re,
                  Y.header.metaData.extraDepNodes.push(re);
              }
            }
            d.push(Y);
          }
          let m;
          t.regression &&
            (m = IF(t, r, a, y),
              m !== void 0 &&
              this.updateSingleStatement(t.regression.id, m, {
                selectionOnlyChange: o,
              }));
          let h = new Yp(d, [...y.values()], m, r);
          if (this.updateSingleStatement(r, h, { selectionOnlyChange: o }), p) {
            let _ = new Set([
                ...h.getColumnIdsForGraphing(),
                ...h.getColumnStatementIds(),
              ]),
              L = h.getRegressionId();
            L && _.add(L);
            for (let w of p) _.has(w) || this.removeSingleStatement(w, n);
          }
          break;
        case "image":
          let x = "-\\trigAngleMultiplier*(" + t.angle + ")",
            T = ri(t.center, { ...a, seedPrefix: yn(r, [["ic", r]]) }),
            b = ri(x, { ...a, seedPrefix: yn(r, [["ia", r]]) }),
            M = ri(t.width, { ...a, seedPrefix: yn(r, [["iw", r]]) }),
            P = ri(t.height, { ...a, seedPrefix: yn(r, [["ih", r]]) }),
            D = ri(t.opacity, { ...a, seedPrefix: yn(r, [["io", r]]) });
          this.updateSingleStatement(
            r,
            new u5({
              center: T,
              radianAngle: b,
              width: M,
              height: P,
              opacity: D,
            }, void 0),
            { selectionOnlyChange: o },
          );
          break;
        case "ticker": {
          this.updateSingleStatement(
            r,
            new C.Ticker({
              handler: ri(t.handlerLatex, { ...a, allowDt: true }),
              minStep: ri(t.minStepLatex || "0", a),
            }),
            { selectionOnlyChange: o },
          );
          break;
        }
        case "geometry-toolbar-predicate": {
          this.updateSingleStatement(r, ri(`\\{${t.latex}:1,0\\}`, { ...a }), {
            selectionOnlyChange: o,
          });
          break;
        }
        default:
          t = t;
          let S, O = trimLatex(t.latex);
          O.slice(-1) === "=" ? S = O.substring(0, O.length - 1) : S = t.latex,
            this.updateSingleStatement(r, Mi(S, a), { selectionOnlyChange: o });
          for (let _ in wm) {
            let L = _;
            if (t[L]) {
              let w = wm[L], G = t[L];
              w.transform && (G = w.transform(G));
              let k = yi(G, { ...a, seedPrefix: yn(r, [[w.seed, r]]) });
              u[L] = k, u.extraDepNodes.push(k);
            }
          }
          if (t.colorLatex) {
            let _ = gc(t.colorLatex, { ...a, seedPrefix: yn(r, [["ac", r]]) });
            u.colorLatex = _, u.extraDepNodes.push(_);
          }
          if (
            t.polarDomain && t.polarDomain.min &&
            (u.polarDomainMin = yi(t.polarDomain.min, {
              ...a,
              seedPrefix: yn(r, [["lm", r]]),
            }),
              u.extraDepNodes.push(u.polarDomainMin)),
              t.polarDomain && t.polarDomain.max &&
              (u.polarDomainMax = yi(t.polarDomain.max, {
                ...a,
                seedPrefix: yn(r, [["lM", r]]),
              }),
                u.extraDepNodes.push(u.polarDomainMax)),
              t.parametricDomain && t.parametricDomain.min &&
              (u.parametricDomainMin = yi(t.parametricDomain.min, {
                ...a,
                seedPrefix: yn(r, [["lm", r]]),
              }),
                u.extraDepNodes.push(u.parametricDomainMin)),
              t.parametricDomain && t.parametricDomain.max &&
              (u.parametricDomainMax = yi(t.parametricDomain.max, {
                ...a,
                seedPrefix: yn(r, [["lM", r]]),
              }),
                u.extraDepNodes.push(u.parametricDomainMax)),
              t.parametricDomain3Du && t.parametricDomain3Du.min &&
              (u.parametricDomain3DuMin = yi(t.parametricDomain3Du.min, {
                ...a,
                seedPrefix: yn(r, [["lm", r]]),
              }),
                u.extraDepNodes.push(u.parametricDomain3DuMin)),
              t.parametricDomain3Du && t.parametricDomain3Du.max &&
              (u.parametricDomain3DuMax = yi(t.parametricDomain3Du.max, {
                ...a,
                seedPrefix: yn(r, [["lM", r]]),
              }),
                u.extraDepNodes.push(u.parametricDomain3DuMax)),
              t.parametricDomain3Dv && t.parametricDomain3Dv.min &&
              (u.parametricDomain3DvMin = yi(t.parametricDomain3Dv.min, {
                ...a,
                seedPrefix: yn(r, [["lm", r]]),
              }),
                u.extraDepNodes.push(u.parametricDomain3DvMin)),
              t.parametricDomain3Dv && t.parametricDomain3Dv.max &&
              (u.parametricDomain3DvMax = yi(t.parametricDomain3Dv.max, {
                ...a,
                seedPrefix: yn(r, [["lM", r]]),
              }),
                u.extraDepNodes.push(u.parametricDomain3DvMax)),
              t.parametricDomain3Dr && t.parametricDomain3Dr.min &&
              (u.parametricDomain3DrMin = yi(t.parametricDomain3Dr.min, {
                ...a,
                seedPrefix: yn(r, [["lm", r]]),
              }),
                u.extraDepNodes.push(u.parametricDomain3DrMin)),
              t.parametricDomain3Dr && t.parametricDomain3Dr.max &&
              (u.parametricDomain3DrMax = yi(t.parametricDomain3Dr.max, {
                ...a,
                seedPrefix: yn(r, [["lM", r]]),
              }),
                u.extraDepNodes.push(u.parametricDomain3DrMax)),
              t.parametricDomain3Dphi && t.parametricDomain3Dphi.min &&
              (u.parametricDomain3DphiMin = yi(t.parametricDomain3Dphi.min, {
                ...a,
                seedPrefix: yn(r, [["lm", r]]),
              }),
                u.extraDepNodes.push(u.parametricDomain3DphiMin)),
              t.parametricDomain3Dphi && t.parametricDomain3Dphi.max &&
              (u.parametricDomain3DphiMax = yi(t.parametricDomain3Dphi.max, {
                ...a,
                seedPrefix: yn(r, [["lM", r]]),
              }),
                u.extraDepNodes.push(u.parametricDomain3DphiMax)),
              t.vizProps &&
              (t.vizProps.axisOffset &&
                (u.vizAxisOffset = yi(t.vizProps.axisOffset, {
                  ...a,
                  seedPrefix: yn(r, [["vo", r]]),
                }),
                  u.extraDepNodes.push(u.vizAxisOffset)),
                t.vizProps.breadth &&
                (u.vizBreadth = yi(t.vizProps.breadth, {
                  ...a,
                  seedPrefix: yn(r, [["vb", r]]),
                }),
                  u.extraDepNodes.push(u.vizBreadth))),
              t.cdf && t.cdf.show
          ) {
            let _ = v_(t.latex);
            _ && _.type === "distribution" &&
              (u.distributionSpec = _,
                u.cdfMin = gc(t.cdf.min, {
                  ...a,
                  seedPrefix: yn(r, [["lm", r]]),
                }),
                u.extraDepNodes.push(u.cdfMin),
                u.cdfMax = gc(t.cdf.max, {
                  ...a,
                  seedPrefix: yn(r, [["lM", r]]),
                }),
                u.extraDepNodes.push(u.cdfMax));
          }
          if (this.statements[r].shouldPromoteToSlider(this.policy)) {
            let _ = t.slider,
              L = !!(_ && _.isPlayingOnce),
              w = gc(_ && _.softMin, a),
              G = gc(_ && _.softMax, a),
              k = gc(_ && _.min, { ...a, seedPrefix: yn(r, [["lm", r]]) }),
              Z = gc(_ && _.max, { ...a, seedPrefix: yn(r, [["lM", r]]) }),
              F = gc(_ && _.step, { ...a, seedPrefix: yn(r, [["ls", r]]) });
            this.updateSingleStatement(
              r,
              new c5(this.statements[r], {
                sliderMin: k,
                sliderMax: Z,
                sliderStep: F,
                sliderIsPlayingOnce: L,
                sliderSoftMin: w,
                sliderSoftMax: G,
              }),
              { selectionOnlyChange: o },
            );
          }
      }
      let c = t.clickableInfo;
      c && c.enabled && c.latex &&
      (u.clickHandler = ri(c.latex, { ...a, allowIndex: true })),
        this.statements[r].userData = t,
        this.statements[r].metaData = u;
      let l = t.label;
      if (l) {
        let p = this.currentLabel[r];
        (!p || p.raw !== l) && (this.currentLabel[r] = k1(l));
      } else delete this.currentLabel[r];
    }
    updateSingleStatement(t, n, { selectionOnlyChange: r }) {
      r
        ? this.selectionOnlyChangeIds[t] = true
        : (this.markExportsDirty(t), this.markAsDirtyRoot(t)),
        this.statements[t] = n;
    }
    removeStatement(t, n) {
      let r = this.statements[t];
      if (r && Hi(r)) {
        for (let i of r.getColumnStatementIds()) {
          this.removeSingleStatement(i, n);
        }
        let s = r.getRegressionId();
        s && this.removeSingleStatement(s, n);
      }
      this.removeSingleStatement(t, n);
    }
    removeSingleStatement(t, n) {
      this.statements[t] &&
        (this.markExportsDirty(t),
          this._notifyGraphRemoved(t, n),
          delete this.currentLabel[t],
          delete this.statements[t],
          delete this.analysis[t],
          delete this.currentStatus[t]);
    }
    markExportsDirty(t) {
      if (this.statements[t]) {
        ui(this.statements[t]) && (this.markedRegressionDirty = true);
        for (let n of this.statements[t].getLegalExports(this.policy)) {
          this.dirtyExportedSymbolRoots[n] = true;
        }
      }
    }
    markAsDirtyRoot(t) {
      this.dirtyStatementRoots[t] = true;
    }
    markUnpublished(t) {
      var r;
      let n = this.statements[t];
      n && ga(n) ||
        n && ui(n) &&
          ((r = n.tableRegressionData) == null ? void 0 : r.tableId) !==
            void 0 ||
        (this.unpublishedIds[t] = true, delete this.selectionOnlyChangeIds[t]);
    }
    getFrame() {
      return this.updateAnalysis(), this.mainFrameContext.global;
    }
    getAnalysis() {
      return this.updateAnalysis(), this.analysis;
    }
    getEvaluationState(t) {
      if (this.updateAnalysis(), !!this.analysis[t]) {
        return this.analysis[t].evaluationState;
      }
    }
    _updateRegressions(t) {
      var l;
      let n = this.lastFrame, r = this.regressionFrameContext;
      if (!this.policy.graphingEnabled()) return;
      let s = [];
      for (let p of t.keys()) ui(this.statements[p]) && s.push(p);
      let i = this;
      s.sort((p, f) => {
        var g, m;
        let d = (g = i.statements[p].userData) == null
            ? void 0
            : g.residualVariable,
          y = (m = i.statements[f].userData) == null
            ? void 0
            : m.residualVariable;
        return d && !y ? -1 : y && !d ? 1 : 0;
      });
      let o = Lf(this.policy, this.statements, s);
      $P(r.global, o), MF(o, r, this.recursion);
      let a = o.resolved;
      this.postProgressUpdate("RESOLVED", a);
      let u = {};
      for (let p in this.statements) {
        let f = this.statements[p];
        f && Hi(f) && (u[p] = f);
      }
      let c = new Set();
      for (let p of a) {
        if (p === sa) {
          this.postProgressUpdate("UNPUBLISHED", [p]);
          continue;
        }
        if (c.has(p)) continue;
        this.postProgressUpdate("ANALYZING", [p]);
        let f = this.statements[p];
        if (ui(f)) {
          let d = ((l = f.tableRegressionData) == null ? void 0 : l.tableId) ===
                void 0
              ? hc(r, f)
              : hc(r, u[f.tableRegressionData.tableId]),
            y = f.analyzeRegression(
              this.policy,
              d,
              this.mainFrameContext.global,
              n,
              u,
            );
          this.analysis[p] = y;
          let g = this.exportTo(
            { id: p, stmtAnalysis: y },
            this.mainFrameContext,
          );
          y.evaluationState.exported_variables = g,
            t.delete(p),
            this.postProgressUpdate("UNPUBLISHED", [p]);
        } else {
          let d = hc(r, f),
            y = this.analyzeSingleStatementGraphing(
              p,
              this.analysis,
              d,
              o,
              "regression",
            ),
            g = [];
          for (let m of y) {
            this.exportTo(m, r), g.push(m.id), m.id !== p && c.add(m.id);
          }
          this.postProgressUpdate("UNPUBLISHED", g);
        }
      }
    }
    _updateAnalysisAndFrame(t, n, r) {
      var u;
      let s = this.analysis;
      $P(this.mainFrameContext.global, t),
        MF(t, this.mainFrameContext, this.recursion);
      let o = t.resolved.filter((c) => r.has(c)).concat(
        Object.keys(this.selectionOnlyChangeIds),
      );
      this.postProgressUpdate("RESOLVED", o);
      let a = new Set();
      for (let c of o) {
        if (c === sa) {
          this.postProgressUpdate("UNPUBLISHED", [c]);
          continue;
        }
        if (n.has(c)) {
          this.postProgressUpdate("UNPUBLISHED", [c]);
          continue;
        }
        if (a.has(c)) continue;
        this.postProgressUpdate("ANALYZING", [c]);
        let l = this.analyzeSingleStatement(c, s, t), p = [];
        for (let f of l) {
          s[f.id] = f.stmtAnalysis;
          let d = this.exportTo(f, this.mainFrameContext);
          if (Hi(f.stmtAnalysis.rawTree)) {
            let y = f.stmtAnalysis.rawTree.getColumnStatementIds();
            for (let g of y) {
              let m = this.analysis[g],
                h = (u = m == null
                    ? void 0
                    : m.evaluationState.exported_variables) != null
                  ? u
                  : [];
              d.push(...h);
            }
          }
          f.stmtAnalysis.evaluationState.exported_variables = d,
            p.push(f.id),
            f.id !== c && a.add(f.id);
        }
        this.postProgressUpdate("UNPUBLISHED", p);
      }
      return { analyzedStatements: o };
    }
    exportTo(t, n) {
      let r = t.stmtAnalysis.rawTree.exportTo(
          this.policy,
          t.stmtAnalysis.concreteTree,
          n.global,
        ),
        s = this.statements[t.id];
      if (s instanceof co) {
        let i = hc(n, s);
        s.exportToLocal(this.policy, t.stmtAnalysis.concreteTree, i);
      }
      return r;
    }
    buildSymbolToExpressionDirtyMap() {
      return Jw(this.policy, this.statements);
    }
    buildChildIntersectionMap() {
      let t = this.childIntersections, n = new hd();
      for (let s in this.analysis) {
        let i = this.analysis[s], { geometry: o } = i.evaluationState;
        if (
          o != null && o.call && o.call.symbol === "intersection" &&
          this.statements[s].userData.shouldGraph && !i.concreteTree.isError
        ) {
          let a = !!this.unpublishedIds[s], u = i.concreteTree.asTypedValue();
          for (let c of o.call.parents) {
            if (c.type === "arbitrary-expression") continue;
            let l = Ta(c);
            if (!l) continue;
            let p = this.mainFrameContext.global[l], f = p && p.userData.id;
            if (f == null) continue;
            let y = this.analysis[f].concreteTree.asTypedValue();
            y && u &&
            n.addChildIntersection(
              { id: f, valueType: y.valueType, ref: c },
              u,
            ), a && this.markUnpublished(f);
          }
        }
      }
      let r = hd.compareIntersectionCounts({
        nextChildIntersections: n,
        prevChildIntersections: t,
      });
      for (let s in r) {
        let { prev: i, next: o } = r[s];
        o < i && this.markUnpublished(s);
      }
      return n;
    }
    findAllRegressionExports() {
      let t = new Map(), n = {};
      for (let r of We(this.statements)) {
        let s = this.statements[r];
        if (!ui(s)) continue;
        let i = this.analysis[r];
        if (!i || !ui(i.rawTree)) continue;
        let o = i.concreteTree,
          a = i.rawTree.getExportsFromConcrete(this.policy, o);
        t.set(r, a);
        for (let u of a) n[u] = true;
      }
      return { regressionExportMap: t, regressionExportRoots: n };
    }
    updateConstruction() {
      if (!this.policy.isGeometryEnabled) {
        this.parent_frame.construction = rf();
        return;
      }
      let t = [];
      for (let o in this.statements) {
        this.statements[o].userData.isInConstructionsFolder && t.push(o);
      }
      let n = this.statements[sa], r = new l5(t);
      r.metaData = { extraDepNodes: [] }, r.userData = {};
      let s = {};
      for (let o of (n == null ? void 0 : n.getDependencies()) || []) {
        s[o] = true;
      }
      let i = {};
      for (let o of r.getDependencies()) i[o] = true;
      (!n || !ws(s, i)) &&
        (this.statements[sa] = r,
          this.parent_frame.construction = r,
          this.markAsDirtyRoot(sa),
          this.markExportsDirty(sa));
    }
    analyzeExternalRecursiveBaseCases() {
      if (!this.recursion) return;
      let t = [], n = {};
      for (let a of Object.keys(this.statements)) {
        let u = this.statements[a];
        u instanceof Cr && !this.policy.assignmentForbidden(u._symbol) &&
          (t.push(a), n[u._symbol] = u);
      }
      let { recursiveFunctionGroups: r } = Lf(this.policy, this.statements, t),
        s = new Set();
      for (let a of t) {
        let u = this.statements[a];
        u instanceof Cr && r[a] && s.add(u._symbol);
      }
      let i = {}, o = [];
      for (let a of Object.keys(this.statements)) {
        let u = this.statements[a];
        if (u instanceof ku && s.has(u._lhs._symbol)) {
          let c = Qr.fromCallAssignment(n, u);
          if (!c) continue;
          this.updateSingleStatement(a, c, { selectionOnlyChange: false });
          let l = c._symbol;
          i[l] || (i[l] = []),
            i[l].push(c),
            c.getDependencies().length && o.push(a);
        } else if (u instanceof Qr) {
          let c = u._symbol;
          s.has(u._symbol)
            ? (i[c] || (i[c] = []),
              i[c].push(u),
              u.getDependencies().length && o.push(a))
            : this.updateSingleStatement(a, u.originalNode, {
              selectionOnlyChange: false,
            });
        }
      }
      for (let a of We(n)) {
        let u = n[a], c = u.getExternalBaseCases(), l = i[a] || [];
        R5(l, c) ||
          (u.setExternalBaseCases(l),
            this.markExportsDirty(u.userData.id),
            this.markAsDirtyRoot(u.userData.id));
      }
      if (o.length) {
        let { recursiveFunctionBaseCasesWithCycles: a } = Lf(
          this.policy,
          this.statements,
          o,
        );
        for (let u of a) {
          let c = this.statements[u];
          if (c instanceof Qr) {
            let l = n[c._symbol];
            l.setExternalBaseCases(
              l.getExternalBaseCases().filter((p) => p !== c),
            ), this.statements[u] = c.originalNode;
          }
        }
      }
    }
    updateAnalysis() {
      var m, h, x, T;
      this.updateConstruction(), this.analyzeExternalRecursiveBaseCases();
      let t = this.buildSymbolToExpressionDirtyMap(),
        n = Ed(
          this.policy,
          this.statements,
          t,
          this.dirtyStatementRoots,
          this.dirtyExportedSymbolRoots,
        ),
        r = this.markedRegressionDirty;
      for (let b in n.ids) {
        this.statements[b] && ui(this.statements[b]) && (r = true);
      }
      let s = new Set();
      if (r) {
        for (let b in this.statements) this.statements[b] && s.add(b);
        this.mainFrameContext = new Rl(this.parent_frame),
          this.regressionFrameContext = new Rl(this.parent_frame);
      } else {
        let b = n.ids;
        for (let P in b) this.statements[P] && s.add(P);
        let M = n.symbols;
        for (let P of We(M)) {
          M[P] &&
            (delete this.mainFrameContext.global[P],
              delete this.regressionFrameContext.global[P]);
        }
      }
      let i = false;
      for (let b of s.keys()) {
        this.markUnpublished(b),
          this.mainFrameContext.hasLocalFrame(b) &&
          (i = true, this.mainFrameContext.deleteLocalFrame(b));
      }
      if (i) {
        for (let b in this.statements) {
          let M = this.statements[b];
          M.localFrameID && s.has(M.localFrameID) && s.add(b);
        }
      }
      this.markedRegressionDirty = false,
        this.dirtyExportedSymbolRoots = {},
        this.dirtyStatementRoots = {};
      let o = this.analysis;
      (this.evaluationMode === "graphing" ||
        this.evaluationMode === "geometry" ||
        this.evaluationMode === "graphing_3d") && this._updateRegressions(s);
      let { regressionExportMap: a, regressionExportRoots: u } = this
          .findAllRegressionExports(),
        c = Lf(this.policy, this.statements, We(this.statements), a),
        { analyzedStatements: l } = this._updateAnalysisAndFrame(
          c,
          new Set(a.keys()),
          s,
        ),
        p = Ed(this.policy, this.statements, t, {}, u),
        f = {};
      for (let b of c.recursiveFunctionSymbols) f[b] = true;
      let d = Ed(this.policy, this.statements, t, {}, f);
      this.markRegressionAndRecursionDependents({
        regressionDependentStatements: p.ids,
        recursionDependentStatements: d.ids,
      });
      for (let b in this.analysis) {
        let M = this.analysis[b];
        if (
          ui(M.rawTree) &&
          ((m = M.rawTree.tableRegressionData) != null && m.tableId)
        ) {
          let P = M.evaluationState,
            D = this.analysis[M.rawTree.tableRegressionData.tableId];
          if (!D) {
            throw new Error(
              `Programming error: table ${M.rawTree.tableRegressionData.tableId} not found for table regression ${b}`,
            );
          }
          let S = D.evaluationState;
          if (P.regression) {
            let _ = M.rawTree.tableRegressionData.columnInfo.filter((G) =>
                G.isIdentifier
              ).map((G) => latexToIdentifier(G.latex)).filter((G) =>
                this.policy.assignmentForbidden(G)
              ),
              L = (h = M.rawTree.tableRegressionData.columnInfo.find((G) =>
                  !G.isIdentifier
                )) == null
                ? void 0
                : h.latex,
              w;
            _.length > 0 ? w = qP(_).getError() : L && (w = UP(L).getError()),
              S.table_regression = {
                status: "success",
                result: P.regression,
                export_info: w
                  ? { status: "unexportable", reason: w }
                  : { status: "exportable" },
              };
          } else {S.table_regression = {
              status: "error",
              error: (x = P.error) != null ? x : U(
                'Expected regression state to define either "regression" or "error"',
              ).getError(),
            };}
        }
      }
      if (this.policy.graphingEnabled()) {
        for (let b of l) {
          this.evaluateMetadataForStatement(
            b,
            hc(this.mainFrameContext, this.statements[b]),
            this.policy,
          );
        }
        this.childIntersections = this.buildChildIntersectionMap();
      }
      Qw(t).forEach((b) => {
        o[b].evaluationState.depends_on_random_seed = true;
      });
      let y = Ed(this.policy, this.statements, t, { [sa]: true }, {
        construction: true,
      });
      for (let b in y.ids) {
        if (b === sa) continue;
        let M = o[b].evaluationState;
        M.geometry && (M.geometry.unconstructable = true);
      }
      let g;
      for (let b in this.statements) {
        if ((T = this.statements[b].userData) != null && T.latexSelection) {
          g = b;
          break;
        }
      }
      if (g) {
        let b = Ed(this.policy, this.statements, t, { [g]: true }, {
          [`idref_${g}`]: true,
        });
        for (let M in b.ids) {
          if (M === sa) continue;
          let P = o[M].evaluationState;
          P.geometry && (P.geometry.depends_on_selected = true);
        }
      }
      this.lastFrame = Tn(this.parent_frame);
      for (let b of We(this.mainFrameContext.global)) {
        this.lastFrame[b] = this.mainFrameContext.global[b];
      }
      return c;
    }
    analyzeSingleStatement(t, n, r) {
      switch (this.evaluationMode) {
        case "fourFunction":
        case "singleExpressionFourFunction":
          return [{
            id: t,
            stmtAnalysis: this.statements[t].analyzeFourFunction(
              this.policy,
              this.mainFrameContext.global,
              n,
            ),
          }];
        case "scientific":
          return [{
            id: t,
            stmtAnalysis: this.statements[t].analyzeScientific(
              this.policy,
              this.mainFrameContext.global,
              n,
            ),
          }];
        case "singleExpressionScientific":
          return [{
            id: t,
            stmtAnalysis: this.statements[t].analyzeSingleExpressionScientific(
              this.policy,
              this.mainFrameContext.global,
              n,
            ),
          }];
        case "graphing":
        case "graphing_3d":
        case "geometry":
          return this.analyzeSingleStatementGraphing(
            t,
            n,
            hc(this.mainFrameContext, this.statements[t]),
            r,
            "main",
          );
      }
    }
    analyzeSingleStatementGraphing(t, n, r, s, i) {
      if (!this.policy.graphingEnabled()) throw U("Expected graphing policy");
      if (i === "main" && r.r) {
        let a = Tn(r);
        a.r = void 0;
        let u = this.statements[t].analyze(this.policy, a, n);
        if (u.getGraphMode() === 6) return [{ id: t, stmtAnalysis: u }];
      }
      let o = s.recursiveFunctionGroups[t];
      if (o && this.recursion) {
        if (i === "regression") {
          for (let u of o) {
            let c = this.statements[u],
              l = xT(),
              p = { policy: this.policy, rawTree: c, concreteTree: l };
            return [{ id: u, stmtAnalysis: p }];
          }
        }
        let a = {};
        for (let u of o) a[u] = this.statements[u];
        return Ww(this.policy, r, a);
      }
      if (i === "regression") {
        let a = this.statements[t],
          u = a.tryGetConcreteTree(this.policy, r),
          c = { policy: this.policy, rawTree: a, concreteTree: u };
        return [{ id: t, stmtAnalysis: c }];
      } else {
        let a = this.statements[t].analyze(this.policy, r, n);
        return [{ id: t, stmtAnalysis: a }];
      }
    }
    evaluateMetadataForStatement(t, n, r) {
      if (t === sa) return;
      let s = this.analysis[t], i = s.evaluationState.expression_type;
      for (let o in wm) {
        let a = o, u = wm[a];
        this.evaluationMode !== "graphing_3d" && a === "resolution" ||
          (!u.shouldEvaluate || u.shouldEvaluate(s)) && P5(s, r, n, a);
      }
      E5(s, r, n),
        this.product === "graphing-3d" && M5(s),
        this.actions && m5(s) && C5(s, r, n),
        i === "PARAMETRIC" || i === "CURVE3D_xyz_t" || i === "POLAR" ||
          i === "SURFACE_r_\u03B8z" || i === "SURFACE_r_\u03B8z_AMBIGUOUS" ||
          i === "SLICE_r\u03B8z_at_z"
          ? D5(s, r, n)
          : i === "SURFACE_xyz_uv" || i === "SLICE_xyz_uv" ||
              i === "SURFACE_r_\u03B8\u03C6" || i === "SURFACE_z_r\u03B8" ||
              i === "SLICE_zr\u03B8_at_r" || i === "SLICE_zr\u03B8_at_\u03B8" ||
              i === "SLICE_zr\u03B8_at_xyz" ||
              i === "SLICE_r\u03B8\u03C6_at_\u03B8" ||
              i === "SLICE_r\u03B8\u03C6_at_\u03C6" ||
              i === "SLICE_r\u03B8\u03C6_at_xyz"
          ? S5(s, r, n)
          : i === "BOXPLOT"
          ? v5(s, r, n)
          : f5(s) && T5(s, r, n);
    }
    markRegressionAndRecursionDependents(t) {
      for (let n in this.analysis) {
        let r = this.analysis[n];
        if (ga(r.rawTree)) {
          let s = this.analysis[r.rawTree.tableID];
          if (!s) continue;
          let i = s.evaluationState.column_data[r.rawTree.columnIndex];
          if (!i) continue;
          i.depends_on_regression = !!t.regressionDependentStatements[n],
            i.depends_on_recursive_function = !!t
              .recursionDependentStatements[n];
        } else {r.evaluationState.depends_on_regression = !!t
            .regressionDependentStatements[n],
            r.evaluationState.depends_on_recursive_function = !!t
              .recursionDependentStatements[n];}
      }
    }
    processEvents(t) {
      if (!t || !this.actions) return;
      let n = Tn(this.mainFrameContext.global), r = {}, s = false, i = false, o;
      for (let a of t) {
        switch (
          this.globalEventCount += 1,
            n.globalEventCount = new C.Constant(this.globalEventCount),
            a.type
        ) {
          case "step": {
            let c = this.statements[a.expressionId];
            if (!c) continue;
            let l = c.tryGetConcreteTree(this.policy, n);
            i = true, z1(l, r, n);
            break;
          }
          case "click": {
            let c = this.statements[a.expressionId];
            if (!c || !c.metaData.clickHandler) continue;
            n.index = new C.Constant(a.indexVar + 1);
            let l = c.metaData.clickHandler.tryGetConcreteTree(this.policy, n);
            i = true, s = true, z1(l, r, n);
            break;
          }
          case "clock-tick": {
            (o === void 0 || a.isFirstTick && !o.isFirstTick) && (o = a);
            break;
          }
          default:
            return a;
        }
      }
      if (o) {
        let a = this.statements[o.id];
        if (a && a instanceof C.Ticker) {
          let u = a.minStep.tryGetConcreteTree(this.policy, n, q1).asValue();
          if (typeof u == "number" && u >= 0 && isFinite(u)) {
            let l = this.lastClockTickTime;
            if (
              this.lastClockTickTime = Date.now(),
                !o.isFirstTick && l !== void 0
            ) {
              n.dt = new C.Constant(this.lastClockTickTime - l);
              let p = a.handler.tryGetConcreteTree(this.policy, n);
              z1(p, r, n);
            }
          }
        }
      }
      return { objectClicked: s, userAction: i, updates: r };
    }
    postProgressUpdate(t, n) {
      var r;
      (r = this.sendMessageForProgressUpdate) == null ||
        r.call(this, "evaluatorProgressUpdate", { update: t, ids: n });
    }
  };
  function R5(e, t) {
    if (e.length !== t.length) return false;
    for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return false;
    return true;
  }
  var vF = class {
    constructor(t) {
      this.context = new tx(t), this.sendMessage = t;
    }
    processChangeSet(t) {
      let n = this.context.processChangeSet(t);
      this.sendMessage("processChangeSet", n);
    }
  };
  Object.defineProperty(__dcg_chunk_exports__, "a", { get: () => _5 });
  Object.defineProperty(__dcg_chunk_exports__, "b", { get: () => L5 });
  Object.defineProperty(__dcg_chunk_exports__, "c", { get: () => w5 });
  Object.defineProperty(__dcg_chunk_exports__, "d", { get: () => ia });
  Object.defineProperty(__dcg_chunk_exports__, "e", { get: () => F5 });
  Object.defineProperty(__dcg_chunk_exports__, "f", { get: () => V5 });
  Object.defineProperty(__dcg_chunk_exports__, "g", { get: () => Fl });
  Object.defineProperty(__dcg_chunk_exports__, "h", { get: () => qm });
  Object.defineProperty(__dcg_chunk_exports__, "i", { get: () => XF });
  Object.defineProperty(__dcg_chunk_exports__, "j", { get: () => pY });
  Object.defineProperty(__dcg_chunk_exports__, "k", { get: () => dY });
  Object.defineProperty(__dcg_chunk_exports__, "l", { get: () => Ll });
  Object.defineProperty(__dcg_chunk_exports__, "m", { get: () => pD });
  Object.defineProperty(__dcg_chunk_exports__, "n", { get: () => ZF });
  Object.defineProperty(__dcg_chunk_exports__, "o", { get: () => mY });
  Object.defineProperty(__dcg_chunk_exports__, "p", { get: () => yY });
  Object.defineProperty(__dcg_chunk_exports__, "q", { get: () => gY });
  Object.defineProperty(__dcg_chunk_exports__, "r", { get: () => xY });
  Object.defineProperty(__dcg_chunk_exports__, "s", { get: () => TY });
  Object.defineProperty(__dcg_chunk_exports__, "t", { get: () => PY });
  Object.defineProperty(__dcg_chunk_exports__, "u", { get: () => EY });
  Object.defineProperty(__dcg_chunk_exports__, "v", { get: () => ux });
  Object.defineProperty(__dcg_chunk_exports__, "w", { get: () => JF });
  Object.defineProperty(__dcg_chunk_exports__, "x", { get: () => eV });
  Object.defineProperty(__dcg_chunk_exports__, "y", { get: () => SY });
  Object.defineProperty(__dcg_chunk_exports__, "z", { get: () => NY });
  Object.defineProperty(__dcg_chunk_exports__, "A", { get: () => RY });
  Object.defineProperty(__dcg_chunk_exports__, "B", { get: () => gi });
  Object.defineProperty(__dcg_chunk_exports__, "C", { get: () => Md });
  Object.defineProperty(__dcg_chunk_exports__, "D", { get: () => cV });
  Object.defineProperty(__dcg_chunk_exports__, "E", { get: () => ws });
  Object.defineProperty(__dcg_chunk_exports__, "F", { get: () => wY });
  Object.defineProperty(__dcg_chunk_exports__, "G", { get: () => Vl });
  Object.defineProperty(__dcg_chunk_exports__, "H", { get: () => Bl });
  Object.defineProperty(__dcg_chunk_exports__, "I", { get: () => fV });
  Object.defineProperty(__dcg_chunk_exports__, "J", { get: () => UY });
  Object.defineProperty(__dcg_chunk_exports__, "K", { get: () => $Y });
  Object.defineProperty(__dcg_chunk_exports__, "L", { get: () => va });
  Object.defineProperty(__dcg_chunk_exports__, "M", { get: () => uu });
  Object.defineProperty(__dcg_chunk_exports__, "N", { get: () => Hre });
  Object.defineProperty(__dcg_chunk_exports__, "O", { get: () => kD });
  Object.defineProperty(__dcg_chunk_exports__, "P", { get: () => W1 });
  Object.defineProperty(__dcg_chunk_exports__, "Q", { get: () => Bm });
  Object.defineProperty(__dcg_chunk_exports__, "R", { get: () => tY });
  Object.defineProperty(__dcg_chunk_exports__, "S", { get: () => MathHypot });
  Object.defineProperty(__dcg_chunk_exports__, "T", { get: () => Va });
  Object.defineProperty(__dcg_chunk_exports__, "U", { get: () => to });
  Object.defineProperty(__dcg_chunk_exports__, "V", { get: () => kF });
  Object.defineProperty(__dcg_chunk_exports__, "W", { get: () => rY });
  Object.defineProperty(__dcg_chunk_exports__, "X", { get: () => sY });
  Object.defineProperty(__dcg_chunk_exports__, "Y", { get: () => si });
  Object.defineProperty(__dcg_chunk_exports__, "Z", { get: () => iY });
  Object.defineProperty(__dcg_chunk_exports__, "_", { get: () => xi });
  Object.defineProperty(__dcg_chunk_exports__, "$", { get: () => $D });
  Object.defineProperty(__dcg_chunk_exports__, "aa", { get: () => EX });
  Object.defineProperty(__dcg_chunk_exports__, "ba", { get: () => vX });
  Object.defineProperty(__dcg_chunk_exports__, "ca", { get: () => hf });
  Object.defineProperty(__dcg_chunk_exports__, "da", { get: () => tg });
  Object.defineProperty(__dcg_chunk_exports__, "ea", { get: () => value });
  Object.defineProperty(__dcg_chunk_exports__, "fa", { get: () => point });
  Object.defineProperty(__dcg_chunk_exports__, "ga", {
    get: () => DEFAULT_EVALUATION_LABEL_OPTIONS,
  });
  Object.defineProperty(__dcg_chunk_exports__, "ha", {
    get: () => DEFAULT_COMPLEX_EVALUATION_LABEL_OPTIONS,
  });
  Object.defineProperty(__dcg_chunk_exports__, "ia", {
    get: () => canDisplayAsFraction,
  });
  Object.defineProperty(__dcg_chunk_exports__, "ja", {
    get: () => numericLabel,
  });
  Object.defineProperty(__dcg_chunk_exports__, "ka", {
    get: () => truncatedHTMLLabel,
  });
  Object.defineProperty(__dcg_chunk_exports__, "la", {
    get: () => truncatedLatexLabel,
  });
  Object.defineProperty(__dcg_chunk_exports__, "ma", {
    get: () => identifierToLatex,
  });
  Object.defineProperty(__dcg_chunk_exports__, "na", {
    get: () => latexToIdentifier,
  });
  Object.defineProperty(__dcg_chunk_exports__, "oa", { get: () => trimLatex });
  Object.defineProperty(__dcg_chunk_exports__, "pa", {
    get: () => complexNumberLabel,
  });
  Object.defineProperty(__dcg_chunk_exports__, "qa", { get: () => Oo });
  Object.defineProperty(__dcg_chunk_exports__, "ra", { get: () => Cd });
  Object.defineProperty(__dcg_chunk_exports__, "sa", { get: () => WY });
  Object.defineProperty(__dcg_chunk_exports__, "ta", { get: () => Vs });
  Object.defineProperty(__dcg_chunk_exports__, "ua", { get: () => kn });
  Object.defineProperty(__dcg_chunk_exports__, "va", { get: () => Any });
  Object.defineProperty(__dcg_chunk_exports__, "wa", { get: () => Number });
  Object.defineProperty(__dcg_chunk_exports__, "xa", { get: () => Bool });
  Object.defineProperty(__dcg_chunk_exports__, "ya", { get: () => Point });
  Object.defineProperty(__dcg_chunk_exports__, "za", { get: () => Action });
  Object.defineProperty(__dcg_chunk_exports__, "Aa", { get: () => ListOfAny });
  Object.defineProperty(__dcg_chunk_exports__, "Ba", {
    get: () => ListOfNumber,
  });
  Object.defineProperty(__dcg_chunk_exports__, "Ca", { get: () => ListOfBool });
  Object.defineProperty(__dcg_chunk_exports__, "Da", {
    get: () => ListOfPoint,
  });
  Object.defineProperty(__dcg_chunk_exports__, "Ea", { get: () => EmptyList });
  Object.defineProperty(__dcg_chunk_exports__, "Fa", { get: () => ErrorType });
  Object.defineProperty(__dcg_chunk_exports__, "Ga", { get: () => SeedType });
  Object.defineProperty(__dcg_chunk_exports__, "Ha", { get: () => RGBColor });
  Object.defineProperty(__dcg_chunk_exports__, "Ia", {
    get: () => ListOfColor,
  });
  Object.defineProperty(__dcg_chunk_exports__, "Ja", { get: () => Polygon });
  Object.defineProperty(__dcg_chunk_exports__, "Ka", {
    get: () => ListOfPolygon,
  });
  Object.defineProperty(__dcg_chunk_exports__, "La", { get: () => Segment });
  Object.defineProperty(__dcg_chunk_exports__, "Ma", {
    get: () => ListOfSegment,
  });
  Object.defineProperty(__dcg_chunk_exports__, "Na", { get: () => Circle });
  Object.defineProperty(__dcg_chunk_exports__, "Oa", {
    get: () => ListOfCircle,
  });
  Object.defineProperty(__dcg_chunk_exports__, "Pa", { get: () => Arc });
  Object.defineProperty(__dcg_chunk_exports__, "Qa", { get: () => ListOfArc });
  Object.defineProperty(__dcg_chunk_exports__, "Ra", { get: () => Line });
  Object.defineProperty(__dcg_chunk_exports__, "Sa", { get: () => ListOfLine });
  Object.defineProperty(__dcg_chunk_exports__, "Ta", { get: () => Ray });
  Object.defineProperty(__dcg_chunk_exports__, "Ua", { get: () => ListOfRay });
  Object.defineProperty(__dcg_chunk_exports__, "Va", {
    get: () => AngleMarker,
  });
  Object.defineProperty(__dcg_chunk_exports__, "Wa", {
    get: () => ListOfAngleMarker,
  });
  Object.defineProperty(__dcg_chunk_exports__, "Xa", {
    get: () => DirectedAngleMarker,
  });
  Object.defineProperty(__dcg_chunk_exports__, "Ya", {
    get: () => ListOfDirectedAngleMarker,
  });
  Object.defineProperty(__dcg_chunk_exports__, "Za", {
    get: () => Transformation,
  });
  Object.defineProperty(__dcg_chunk_exports__, "_a", {
    get: () => ListOfTransformation,
  });
  Object.defineProperty(__dcg_chunk_exports__, "$a", { get: () => Vector });
  Object.defineProperty(__dcg_chunk_exports__, "ab", {
    get: () => ListOfVector,
  });
  Object.defineProperty(__dcg_chunk_exports__, "bb", {
    get: () => Restriction,
  });
  Object.defineProperty(__dcg_chunk_exports__, "cb", {
    get: () => ListOfRestriction,
  });
  Object.defineProperty(__dcg_chunk_exports__, "db", { get: () => Complex });
  Object.defineProperty(__dcg_chunk_exports__, "eb", {
    get: () => ListOfComplex,
  });
  Object.defineProperty(__dcg_chunk_exports__, "fb", { get: () => Tone });
  Object.defineProperty(__dcg_chunk_exports__, "gb", { get: () => ListOfTone });
  Object.defineProperty(__dcg_chunk_exports__, "hb", { get: () => Point3D });
  Object.defineProperty(__dcg_chunk_exports__, "ib", {
    get: () => ListOfPoint3D,
  });
  Object.defineProperty(__dcg_chunk_exports__, "jb", { get: () => Segment3D });
  Object.defineProperty(__dcg_chunk_exports__, "kb", {
    get: () => ListOfSegment3D,
  });
  Object.defineProperty(__dcg_chunk_exports__, "lb", { get: () => Triangle3D });
  Object.defineProperty(__dcg_chunk_exports__, "mb", {
    get: () => ListOfTriangle3D,
  });
  Object.defineProperty(__dcg_chunk_exports__, "nb", { get: () => Sphere3D });
  Object.defineProperty(__dcg_chunk_exports__, "ob", {
    get: () => ListOfSphere3D,
  });
  Object.defineProperty(__dcg_chunk_exports__, "pb", { get: () => Vector3D });
  Object.defineProperty(__dcg_chunk_exports__, "qb", {
    get: () => ListOfVector3D,
  });
  Object.defineProperty(__dcg_chunk_exports__, "rb", { get: () => RD });
  Object.defineProperty(__dcg_chunk_exports__, "sb", { get: () => Qn });
  Object.defineProperty(__dcg_chunk_exports__, "tb", { get: () => RV });
  Object.defineProperty(__dcg_chunk_exports__, "ub", { get: () => at });
  Object.defineProperty(__dcg_chunk_exports__, "vb", { get: () => oe });
  Object.defineProperty(__dcg_chunk_exports__, "wb", { get: () => j });
  Object.defineProperty(__dcg_chunk_exports__, "xb", { get: () => Ve });
  Object.defineProperty(__dcg_chunk_exports__, "yb", { get: () => vd });
  Object.defineProperty(__dcg_chunk_exports__, "zb", { get: () => Qm });
  Object.defineProperty(__dcg_chunk_exports__, "Ab", { get: () => se });
  Object.defineProperty(__dcg_chunk_exports__, "Bb", { get: () => ua });
  Object.defineProperty(__dcg_chunk_exports__, "Cb", { get: () => kt });
  Object.defineProperty(__dcg_chunk_exports__, "Db", { get: () => Ae });
  Object.defineProperty(__dcg_chunk_exports__, "Eb", { get: () => ny });
  Object.defineProperty(__dcg_chunk_exports__, "Fb", { get: () => Ie });
  Object.defineProperty(__dcg_chunk_exports__, "Gb", { get: () => wD });
  Object.defineProperty(__dcg_chunk_exports__, "Hb", { get: () => FD });
  Object.defineProperty(__dcg_chunk_exports__, "Ib", { get: () => Cc });
  Object.defineProperty(__dcg_chunk_exports__, "Jb", { get: () => IT });
  Object.defineProperty(__dcg_chunk_exports__, "Kb", { get: () => HV });
  Object.defineProperty(__dcg_chunk_exports__, "Lb", { get: () => zV });
  Object.defineProperty(__dcg_chunk_exports__, "Mb", { get: () => We });
  Object.defineProperty(__dcg_chunk_exports__, "Nb", { get: () => Tn });
  Object.defineProperty(__dcg_chunk_exports__, "Ob", { get: () => bX });
  Object.defineProperty(__dcg_chunk_exports__, "Pb", { get: () => ls });
  Object.defineProperty(__dcg_chunk_exports__, "Qb", { get: () => hypot });
  Object.defineProperty(__dcg_chunk_exports__, "Rb", { get: () => toFraction });
  Object.defineProperty(__dcg_chunk_exports__, "Sb", { get: () => clamp });
  Object.defineProperty(__dcg_chunk_exports__, "Tb", { get: () => lcm });
  Object.defineProperty(__dcg_chunk_exports__, "Ub", { get: () => distance });
  Object.defineProperty(__dcg_chunk_exports__, "Vb", { get: () => arcCenter });
  Object.defineProperty(__dcg_chunk_exports__, "Wb", { get: () => arcOmega });
  Object.defineProperty(__dcg_chunk_exports__, "Xb", { get: () => lineGlider });
  Object.defineProperty(__dcg_chunk_exports__, "Yb", {
    get: () => segmentGlider,
  });
  Object.defineProperty(__dcg_chunk_exports__, "Zb", { get: () => rayGlider });
  Object.defineProperty(__dcg_chunk_exports__, "_b", {
    get: () => circleGlider,
  });
  Object.defineProperty(__dcg_chunk_exports__, "$b", { get: () => arcGlider });
  Object.defineProperty(__dcg_chunk_exports__, "ac", {
    get: () => polygonGlider,
  });
  Object.defineProperty(__dcg_chunk_exports__, "bc", {
    get: () => getArcDetails,
  });
  Object.defineProperty(__dcg_chunk_exports__, "cc", {
    get: () => circleCircleIntersection,
  });
  Object.defineProperty(__dcg_chunk_exports__, "dc", {
    get: () => lineCircleIntersection,
  });
  Object.defineProperty(__dcg_chunk_exports__, "ec", {
    get: () => circleLineIntersection,
  });
  Object.defineProperty(__dcg_chunk_exports__, "fc", {
    get: () => lineLineIntersection,
  });
  Object.defineProperty(__dcg_chunk_exports__, "gc", {
    get: () => circleArcIntersection,
  });
  Object.defineProperty(__dcg_chunk_exports__, "hc", {
    get: () => lineArcIntersection,
  });
  Object.defineProperty(__dcg_chunk_exports__, "ic", {
    get: () => arcCircleIntersection,
  });
  Object.defineProperty(__dcg_chunk_exports__, "jc", {
    get: () => arcLineIntersection,
  });
  Object.defineProperty(__dcg_chunk_exports__, "kc", {
    get: () => arcArcIntersection,
  });
  Object.defineProperty(__dcg_chunk_exports__, "lc", { get: () => dilation });
  Object.defineProperty(__dcg_chunk_exports__, "mc", {
    get: () => composeTransformation,
  });
  Object.defineProperty(__dcg_chunk_exports__, "nc", {
    get: () => invertTransformation,
  });
  Object.defineProperty(__dcg_chunk_exports__, "oc", {
    get: () => transformPoint,
  });
  Object.defineProperty(__dcg_chunk_exports__, "pc", { get: () => Et });
  Object.defineProperty(__dcg_chunk_exports__, "qc", { get: () => tt });
  Object.defineProperty(__dcg_chunk_exports__, "rc", { get: () => Jr });
  Object.defineProperty(__dcg_chunk_exports__, "sc", { get: () => Nu });
  Object.defineProperty(__dcg_chunk_exports__, "tc", { get: () => Bo });
  Object.defineProperty(__dcg_chunk_exports__, "uc", { get: () => $Z });
  Object.defineProperty(__dcg_chunk_exports__, "vc", { get: () => Mk });
  Object.defineProperty(__dcg_chunk_exports__, "wc", { get: () => C });
  Object.defineProperty(__dcg_chunk_exports__, "xc", { get: () => Dr });
  Object.defineProperty(__dcg_chunk_exports__, "yc", { get: () => $j });
  Object.defineProperty(__dcg_chunk_exports__, "zc", { get: () => sh });
  Object.defineProperty(__dcg_chunk_exports__, "Ac", { get: () => _O });
  Object.defineProperty(__dcg_chunk_exports__, "Bc", { get: () => zo });
  Object.defineProperty(__dcg_chunk_exports__, "Cc", { get: () => Ta });
  Object.defineProperty(__dcg_chunk_exports__, "Dc", { get: () => kf });
  Object.defineProperty(__dcg_chunk_exports__, "Ec", { get: () => UO });
  Object.defineProperty(__dcg_chunk_exports__, "Fc", { get: () => oK });
  Object.defineProperty(__dcg_chunk_exports__, "Gc", { get: () => pe });
  Object.defineProperty(__dcg_chunk_exports__, "Hc", { get: () => hK });
  Object.defineProperty(__dcg_chunk_exports__, "Ic", { get: () => bK });
  Object.defineProperty(__dcg_chunk_exports__, "Jc", { get: () => li });
  Object.defineProperty(__dcg_chunk_exports__, "Kc", { get: () => $K });
  Object.defineProperty(__dcg_chunk_exports__, "Lc", { get: () => nu });
  Object.defineProperty(__dcg_chunk_exports__, "Mc", { get: () => YK });
  Object.defineProperty(__dcg_chunk_exports__, "Nc", { get: () => lr });
  Object.defineProperty(__dcg_chunk_exports__, "Oc", { get: () => qR });
  Object.defineProperty(__dcg_chunk_exports__, "Pc", { get: () => Be });
  Object.defineProperty(__dcg_chunk_exports__, "Qc", { get: () => DM });
  Object.defineProperty(__dcg_chunk_exports__, "Rc", { get: () => OA });
  Object.defineProperty(__dcg_chunk_exports__, "Sc", { get: () => AA });
  Object.defineProperty(__dcg_chunk_exports__, "Tc", { get: () => mo });
  Object.defineProperty(__dcg_chunk_exports__, "Uc", { get: () => wh });
  Object.defineProperty(__dcg_chunk_exports__, "Vc", { get: () => UA });
  Object.defineProperty(__dcg_chunk_exports__, "Wc", { get: () => Mi });
  Object.defineProperty(__dcg_chunk_exports__, "Xc", { get: () => $z });
  Object.defineProperty(__dcg_chunk_exports__, "Yc", { get: () => v_ });
  Object.defineProperty(__dcg_chunk_exports__, "Zc", { get: () => eC });
  Object.defineProperty(__dcg_chunk_exports__, "_c", { get: () => tC });
  Object.defineProperty(__dcg_chunk_exports__, "$c", { get: () => O_ });
  Object.defineProperty(__dcg_chunk_exports__, "ad", { get: () => N_ });
  Object.defineProperty(__dcg_chunk_exports__, "bd", { get: () => R_ });
  Object.defineProperty(__dcg_chunk_exports__, "cd", { get: () => st });
  Object.defineProperty(__dcg_chunk_exports__, "dd", { get: () => Cq });
  Object.defineProperty(__dcg_chunk_exports__, "ed", { get: () => vC });
  Object.defineProperty(__dcg_chunk_exports__, "fd", { get: () => OC });
  Object.defineProperty(__dcg_chunk_exports__, "gd", { get: () => NC });
  Object.defineProperty(__dcg_chunk_exports__, "hd", { get: () => yb });
  Object.defineProperty(__dcg_chunk_exports__, "id", { get: () => gb });
  Object.defineProperty(__dcg_chunk_exports__, "jd", { get: () => sc });
  Object.defineProperty(__dcg_chunk_exports__, "kd", { get: () => Im });
  Object.defineProperty(__dcg_chunk_exports__, "ld", { get: () => _L });
  Object.defineProperty(__dcg_chunk_exports__, "md", { get: () => Em });
  Object.defineProperty(__dcg_chunk_exports__, "nd", { get: () => Db });
  Object.defineProperty(__dcg_chunk_exports__, "od", { get: () => Jse });
  Object.defineProperty(__dcg_chunk_exports__, "pd", { get: () => u8 });
  Object.defineProperty(__dcg_chunk_exports__, "qd", { get: () => eie });
  Object.defineProperty(__dcg_chunk_exports__, "rd", { get: () => sie });
  Object.defineProperty(__dcg_chunk_exports__, "sd", { get: () => iie });
  Object.defineProperty(__dcg_chunk_exports__, "td", { get: () => wL });
  Object.defineProperty(__dcg_chunk_exports__, "ud", { get: () => oie });
  Object.defineProperty(__dcg_chunk_exports__, "vd", { get: () => uie });
  Object.defineProperty(__dcg_chunk_exports__, "wd", { get: () => cie });
  Object.defineProperty(__dcg_chunk_exports__, "xd", { get: () => VL });
  Object.defineProperty(__dcg_chunk_exports__, "yd", { get: () => kL });
  Object.defineProperty(__dcg_chunk_exports__, "zd", { get: () => Sb });
  Object.defineProperty(__dcg_chunk_exports__, "Ad", { get: () => HL });
  Object.defineProperty(__dcg_chunk_exports__, "Bd", { get: () => zL });
  Object.defineProperty(__dcg_chunk_exports__, "Cd", { get: () => UL });
  Object.defineProperty(__dcg_chunk_exports__, "Dd", { get: () => Pie });
  Object.defineProperty(__dcg_chunk_exports__, "Ed", { get: () => Eie });
  Object.defineProperty(__dcg_chunk_exports__, "Fd", { get: () => c8 });
  Object.defineProperty(__dcg_chunk_exports__, "Gd", { get: () => Mie });
  Object.defineProperty(__dcg_chunk_exports__, "Hd", { get: () => Cie });
  Object.defineProperty(__dcg_chunk_exports__, "Id", { get: () => JC });
  Object.defineProperty(__dcg_chunk_exports__, "Jd", { get: () => Ob });
  Object.defineProperty(__dcg_chunk_exports__, "Kd", { get: () => l8 });
  Object.defineProperty(__dcg_chunk_exports__, "Ld", { get: () => qL });
  Object.defineProperty(__dcg_chunk_exports__, "Md", { get: () => p8 });
  Object.defineProperty(__dcg_chunk_exports__, "Nd", { get: () => $L });
  Object.defineProperty(__dcg_chunk_exports__, "Od", { get: () => vb });
  Object.defineProperty(__dcg_chunk_exports__, "Pd", { get: () => f8 });
  Object.defineProperty(__dcg_chunk_exports__, "Qd", { get: () => QC });
  Object.defineProperty(__dcg_chunk_exports__, "Rd", { get: () => Cl });
  Object.defineProperty(__dcg_chunk_exports__, "Sd", { get: () => m8 });
  Object.defineProperty(__dcg_chunk_exports__, "Td", { get: () => y8 });
  Object.defineProperty(__dcg_chunk_exports__, "Ud", { get: () => Aie });
  Object.defineProperty(__dcg_chunk_exports__, "Vd", { get: () => b8 });
  Object.defineProperty(__dcg_chunk_exports__, "Wd", { get: () => JL });
  Object.defineProperty(__dcg_chunk_exports__, "Xd", { get: () => A8 });
  Object.defineProperty(__dcg_chunk_exports__, "Yd", { get: () => Ab });
  Object.defineProperty(__dcg_chunk_exports__, "Zd", { get: () => bw });
  Object.defineProperty(__dcg_chunk_exports__, "_d", { get: () => Voe });
  Object.defineProperty(__dcg_chunk_exports__, "$d", { get: () => Boe });
  Object.defineProperty(__dcg_chunk_exports__, "ae", { get: () => Id });
  Object.defineProperty(__dcg_chunk_exports__, "be", { get: () => wa });
  Object.defineProperty(__dcg_chunk_exports__, "ce", { get: () => i$ });
  Object.defineProperty(__dcg_chunk_exports__, "de", { get: () => pae });
  Object.defineProperty(__dcg_chunk_exports__, "ee", { get: () => l$ });
  Object.defineProperty(__dcg_chunk_exports__, "fe", { get: () => F1 });
  Object.defineProperty(__dcg_chunk_exports__, "ge", { get: () => tF });
  Object.defineProperty(__dcg_chunk_exports__, "he", { get: () => nF });
  Object.defineProperty(__dcg_chunk_exports__, "ie", { get: () => yF });
  Object.defineProperty(__dcg_chunk_exports__, "je", { get: () => gF });
  Object.defineProperty(__dcg_chunk_exports__, "ke", { get: () => Lm });
  Object.defineProperty(__dcg_chunk_exports__, "le", { get: () => K$ });
  Object.defineProperty(__dcg_chunk_exports__, "me", { get: () => e5 });
  Object.defineProperty(__dcg_chunk_exports__, "ne", { get: () => TF });
  Object.defineProperty(__dcg_chunk_exports__, "oe", { get: () => jle });
  Object.defineProperty(__dcg_chunk_exports__, "pe", { get: () => tx });
  Object.defineProperty(__dcg_chunk_exports__, "qe", { get: () => G5 });
  Object.defineProperty(__dcg_chunk_exports__, "re", { get: () => vF });

  return __dcg_chunk_exports__;
})();
