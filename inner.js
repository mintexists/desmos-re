import { xhrFetch } from "./utils.js";

export default (() => {
  const __dcg_shared_module_source__ = xhrFetch("./shared.js");
  const __dcg_shared_module_exports__ = eval(
    __dcg_shared_module_source__,
  );
  const __dcg_worker_source_exports__ = (function () {
    // worker.js
    const __dcg_worker_source__ = `
// store the code for the worker module as a function that takes the shared module exports as an argument
const __dcg_worker_module__ = (__dcg_shared_module_exports__) => {
` +
      xhrFetch("./worker.js") +
      `
};
// execute the shared module store its exports
const __dcg_worker_shared_module_exports__ = ${__dcg_shared_module_source__};
// call the worker module, passing in the shared module exports
__dcg_worker_module__(__dcg_worker_shared_module_exports__);`;

    let createWorker;
    if (
      typeof Blob !== "undefined" && URL &&
      typeof URL.createObjectURL === "function"
    ) {
      createWorker = () => {
        const workerURL = URL.createObjectURL(
          new Blob([__dcg_worker_source__], {
            type: "application/javascript",
          }),
        );
        const worker = new Worker(workerURL);
        worker.revokeObjectURL = () => {
          URL.revokeObjectURL(workerURL);
        };
        return worker;
      };
    } else {
      // Just for testing in Node
      createWorker = () => {
        (new Function(__dcg_worker_source__))();
      };
    }

    return { createWorker, default: { createWorker } };
  })();
  var iB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var nB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var aB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var sB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var lB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var cB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var dB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var pB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var uB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var hB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var gB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var mB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var fB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var bB = __dcg_shared_module_exports__["lazyDefine"](() => {
    nB();
    aB();
    sB();
    lB();
    cB();
    dB();
    pB();
    uB();
    hB();
    gB();
    mB();
    fB();
  });
  var wQ,
    yge,
    yB = __dcg_shared_module_exports__["lazyDefine"](() => {
      wQ = ["education", "commercial", "generic", "prospect"],
        yge = [...wQ, "uncategorized"];
    });
  var xB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  function $M(r) {
    let e = {};
    for (let t in r) e[t] = r[t].getAuthoringConfig();
    return e;
  }
  function qx(r, e, t = {}) {
    let o = t[r] || r === "validation";
    return `"${r}"${o ? "?" : ""}:${e}`;
  }
  var Hx,
    Su,
    pt,
    Vi,
    lS,
    cS,
    dS,
    jM,
    hg,
    wB = __dcg_shared_module_exports__["lazyDefine"](() => {
      Hx = class {},
        Su = class extends Hx {
          constructor() {
            super(...arguments);
            this._conditionalAttributes = new Map();
            this.arrayBoundsChecks = [];
            this.latexs = [];
            this.labels = [];
          }
          parser(t) {
            return this.validation = t, this;
          }
          conditionalAttributes(t, o) {
            return this._conditionalAttributes.set(t, o), this;
          }
          ensureWithinArrayBounds(t) {
            return this.arrayBoundsChecks.push(t), this;
          }
          ensureWithinRange(t, o) {
            return this.numberRange = { min: t, max: o }, this;
          }
          latex(t) {
            return this.latexs.push(t), this;
          }
          label(t) {
            return this.labels.push(t), this;
          }
          validateReferences(
            { validator: t, path: o, value: i, concreteCtx: n },
          ) {
            if (this.arrayBoundsChecks.length) {
              if (
                !(typeof i == "number" && i >= 1 && Number.isInteger(i))
              ) {
                t.reportError(
                  o,
                  "array index must be an integer of at least 1. Got: " +
                    i,
                );
              } else {for (let s of this.arrayBoundsChecks) {
                  let l = [];
                  for (let c of n.nodes) {
                    c.type === "array" && c.node === s &&
                      l.push(c.rawValue.length);
                  }
                  if (l.length !== 1) {
                    t.reportError(
                      o,
                      "expected exactly 1 array reference. got: " +
                        l.length,
                    );
                  } else {
                    let c = l[0];
                    i > c &&
                      t.reportError(
                        o,
                        "expected to be at most " + c + ", got: " + i,
                      );
                  }
                }}
            }
          }
          addGraphMutations(
            { validator: t, path: o, value: i, graphMutations: n },
          ) {
            for (let a of this.latexs) {
              typeof i == "string" || typeof i == "number"
                ? n.push({ type: "value", identifier: a, value: i + "" })
                : typeof i == "boolean"
                ? n.push({
                  type: "value",
                  identifier: a,
                  value: i ? "1" : "0",
                })
                : t.reportError(
                  o,
                  "unexpected latexValue mutation value type:  " +
                    typeof i,
                );
            }
            for (let a of this.labels) {
              typeof i == "string"
                ? n.push({ type: "label", identifier: a, value: i + "" })
                : t.reportError(
                  o,
                  "unexpected label mutation value type:  " + typeof i,
                );
            }
          }
          parseString({ path: t, subData: o, validator: i }) {
            let n = o;
            if (!this.validation) {
              return i.reportError(
                t,
                'has no validation. Use "string" for no validation',
              ),
                n;
            }
            if (i.shouldSkipParsingDataVariable(i)) return n;
            if (typeof this.validation == "object") {
              return n in this.validation
                ? this.validation[n]
                : (i.reportError(t, "unknown type: " + n), n);
            }
            switch (this.validation) {
              case "string":
                return n;
              case "number":
                if (
                  !/^-?[0-9]*[.]?[0-9]*$/.test(n) || !/[0-9]/g.test(n)
                ) {
                  return i.reportError(
                    t,
                    "expected to be a number but it was not: " + n,
                  ),
                    NaN;
                }
                let a = parseFloat(n);
                return this.numberRange &&
                    (a < this.numberRange.min || a > this.numberRange.max)
                  ? (i.reportError(
                    t,
                    "expected to be between " + this.numberRange.min +
                      " and " + this.numberRange.max + " but was: " + n,
                  ),
                    NaN)
                  : a;
              default:
                this.validation;
                break;
            }
            return n;
          }
        };
      pt = class extends Hx {
        constructor(t) {
          super();
          this.config = t;
          this.computedConditionalAttributes = [];
          for (let i in this.config.attributes) {
            let n = this.config.attributes[i];
            if (n instanceof Su) {
              let a = n._conditionalAttributes;
              if (a.size > 0) {
                let s = [];
                for (let [l, c] of a.entries()) {
                  s.push({ value: l, attributes: c });
                }
                this.computedConditionalAttributes.push({
                  attribute_key: i,
                  conditions: s,
                });
              }
            }
          }
          let o = [];
          for (let i of this.computedConditionalAttributes) {
            let n = [];
            for (let a of i.conditions) {
              for (let s in a.attributes) {
                let l = a.attributes[s];
                if (l instanceof Su && l._conditionalAttributes.size) {
                  throw new Error(
                    "cannot have nested conditional attributes. Must route through object",
                  );
                }
              }
              n.push({ value: a.value, attributes: $M(a.attributes) });
            }
            o.push({ attribute_key: i.attribute_key, conditions: n });
          }
          this.authoringConfig = {
            type: "object",
            name: t.name,
            attributes: $M(t.attributes),
            conditional_attributes: o,
          };
        }
        getAuthoringConfig() {
          return this.authoringConfig;
        }
        getTypescriptType() {
          let t = [], o = [];
          for (let i in this.config.attributes) {
            o.push(qx(i, this.config.attributes[i].getTypescriptType()));
          }
          t.push(
            `{
` + o.join(`,
`) + `
}`,
          );
          for (let i of this.computedConditionalAttributes) {
            let n = [], a = this.config.attributes[i.attribute_key];
            if (!a) {
              throw new Error("did not find attribute_key in attributes");
            }
            if (!(a instanceof Su)) {
              throw new Error(
                "attribute_key must be a primitive attribute",
              );
            }
            let s = a.getEnumerableValues();
            if (!s) {
              throw new Error(
                "attribute_key must have a finite, enumerable set of values",
              );
            }
            let l = new Set(s);
            for (let c of i.conditions) {
              if (
                o = [],
                  o.push(qx(i.attribute_key, JSON.stringify(c.value))),
                  l.has(c.value)
              ) l.delete(c.value);
              else {throw new Error(
                  "conditional_attribute specified value multiple time: " +
                    c.value,
                );}
              for (let d in c.attributes) {
                o.push(qx(d, c.attributes[d].getTypescriptType()));
              }
              n.push(
                `{
` + o.join(`,
`) + `
}`,
              );
            }
            if (l.size) {
              for (let c of l) {
                n.push(`{
${qx(i.attribute_key, JSON.stringify(c))}}`);
              }
            }
            t.push("(" + n.join(" | ") + ")");
          }
          return t.length > 1 ? "(" + t.join(" & ") + ")" : t[0];
        }
        toConcrete(
          { validator: t, path: o, rawValue: i, concreteCtx: n },
        ) {
          if (!i || typeof i != "object") {
            t.reportError(o, "should be an object");
            return;
          }
          let a = {};
          for (let c in this.config.attributes) {
            a[c] = this.config.attributes[c].toConcrete({
              path: o + "." + c,
              validator: t,
              rawValue: i[c],
              concreteCtx: n,
            });
          }
          for (
            let { attribute_key: c, conditions: d } of this
              .computedConditionalAttributes
          ) {
            for (let { attributes: p, value: h } of d) {
              if (i[c] === h) {
                for (let u in p) {
                  a[u] = p[u].toConcrete({
                    path: o + "." + u,
                    validator: t,
                    rawValue: i[u],
                    concreteCtx: n,
                  });
                }
              }
            }
          }
          let s = {};
          for (let c in a) {
            let d = a[c];
            d ? s[c] = d.parsedValue : s[c] = void 0;
          }
          let l = {
            type: "object",
            path: o,
            rawValue: a,
            parsedValue: s,
            node: this,
          };
          return n.nodes.push(l), l;
        }
      },
        Vi = class extends Hx {
          constructor(t) {
            super();
            this.config = t;
            let o;
            ("minimum" in t || "maximum" in t) &&
            (o = { maximum: t.maximum, minimum: t.minimum }),
              this.authoringConfig = {
                type: "array",
                required: true,
                name: t.name,
                count: o,
                items: t.items.getAuthoringConfig(),
              };
          }
          getAuthoringConfig() {
            return this.authoringConfig;
          }
          getTypescriptType() {
            return `(${this.config.items.getTypescriptType()})[]`;
          }
          toConcrete(
            { validator: t, path: o, rawValue: i, concreteCtx: n },
          ) {
            if (!Array.isArray(i)) {
              t.reportError(o, "should be an array");
              return;
            }
            let a = i.map((c, d) =>
                this.config.items.toConcrete({
                  path: o + "[" + d + "]",
                  validator: t,
                  rawValue: c,
                  concreteCtx: n,
                })
              ),
              s = a.map((c) => {
                if (c) return c.parsedValue;
              }),
              l = {
                type: "array",
                path: o,
                rawValue: a,
                parsedValue: s,
                node: this,
              };
            return n.nodes.push(l), l;
          }
        },
        lS = class extends Su {
          constructor(e) {
            super(),
              this.authoringConfig = {
                type: "string",
                element: "editor",
                required: true,
                name: e.name,
                default: e.default,
              };
          }
          getAuthoringConfig() {
            return this.authoringConfig;
          }
          getEnumerableValues() {
            if (typeof this.validation == "object") {
              return Object.keys(this.validation);
            }
          }
          getTypescriptType() {
            let e = this.getEnumerableValues();
            return e ? e.map((t) => JSON.stringify(t)).join(" | ") : "string";
          }
          toConcrete(
            { validator: e, path: t, rawValue: o, concreteCtx: i },
          ) {
            if (typeof o != "string") {
              e.reportError(t, "should be a string");
              return;
            }
            let n = this.parseString({
                path: t,
                subData: o,
                validator: e,
              }),
              a = {
                type: "string",
                path: t,
                rawValue: o,
                parsedValue: n,
                node: this,
              };
            return i.nodes.push(a), a;
          }
        },
        cS = class extends Su {
          constructor(e) {
            super(),
              this.authoringConfig = {
                type: "string",
                element: "select",
                required: true,
                name: e.name,
                default: e.default,
                options: e.options,
              };
          }
          getAuthoringConfig() {
            return this.authoringConfig;
          }
          getEnumerableValues() {
            return this.authoringConfig.options.map((e) => e.value);
          }
          getTypescriptType() {
            return this.getEnumerableValues().map((e) => `"${e}"`).join(
              " | ",
            );
          }
          toConcrete(
            { validator: e, path: t, rawValue: o, concreteCtx: i },
          ) {
            if (typeof o != "string") {
              e.reportError(t, "should be a string");
              return;
            }
            if (
              !this.authoringConfig.options.find((s) => s.value === o)
            ) {
              e.reportError(
                t,
                "value must be one of the select options: " + o,
              );
              return;
            }
            let n = this.parseString({
                path: t,
                subData: o,
                validator: e,
              }),
              a = {
                type: "select",
                path: t,
                rawValue: o,
                parsedValue: n,
                node: this,
              };
            return i.nodes.push(a), a;
          }
        },
        dS = class extends Su {
          constructor(e) {
            super(),
              this.authoringConfig = {
                type: "boolean",
                required: true,
                name: e.name,
                default: e.default,
              };
          }
          getAuthoringConfig() {
            return this.authoringConfig;
          }
          getEnumerableValues() {
            return [true, false];
          }
          getTypescriptType() {
            return "boolean";
          }
          toConcrete(
            { validator: e, path: t, rawValue: o, concreteCtx: i },
          ) {
            if (typeof o != "boolean") {
              e.reportError(t, "should be a boolean");
              return;
            }
            let n = {
              type: "boolean",
              path: t,
              rawValue: o,
              parsedValue: o,
              node: this,
            };
            return i.nodes.push(n), n;
          }
        },
        jM = class {
          constructor(e) {
            this.shouldExpectDataVariables = e;
            this.errors = [];
          }
          hasErrors() {
            return !!this.errors.length;
          }
          getErrors() {
            return this.errors;
          }
          reportError(e, t) {
            this.errors.push(e + " - " + t);
          }
          shouldSkipParsingDataVariable(e) {
            return this.shouldExpectDataVariables
              ? !!(typeof e == "string" && e.includes("{{var:"))
              : false;
          }
        };
      hg = class {
        constructor(e) {
          this.optionalSections = {};
          this.config = {};
          for (let t in e) {
            let o = e[t], i = t;
            i.endsWith("?") &&
            (i = i.slice(0, t.length - 1), this.optionalSections[i] = true),
              this.config[i] = o;
          }
          this.authoringConfig = $M(this.config);
        }
        getAuthoringConfig() {
          return this.authoringConfig;
        }
        inflateWithData(e, t) {
          let o = new jM(e), i = { nodes: [] }, n = {};
          for (let s in this.config) {
            n[s] = this.config[s].toConcrete({
              path: s,
              rawValue: t[s],
              validator: o,
              concreteCtx: i,
            });
          }
          if (o.hasErrors()) {
            return { type: "errors", errors: o.getErrors() };
          }
          let a = [];
          for (let s of i.nodes) {
            switch (s.type) {
              case "array":
              case "object":
                break;
              case "boolean":
              case "select":
              case "string":
                s.node.validateReferences({
                  path: s.path,
                  validator: o,
                  value: s.parsedValue,
                  concreteCtx: i,
                }),
                  s.node.addGraphMutations({
                    path: s.path,
                    value: s.parsedValue,
                    validator: o,
                    graphMutations: a,
                  });
                break;
            }
          }
          return o.hasErrors()
            ? { type: "errors", errors: o.getErrors() }
            : { type: "results", graphMutations: a };
        }
        getTypescriptType() {
          let e = [];
          for (let t in this.config) {
            e.push(
              qx(
                t,
                this.config[t].getTypescriptType(),
                this.optionalSections,
              ),
            );
          }
          return `{
` + e.join(`,
`) + `
}`;
        }
      };
    });
  function dp(r, e) {
    return new lS({ name: r, default: e });
  }
  function Ft(r, e) {
    return dp(r, e).parser("number");
  }
  function er(r, e) {
    return dp(r, e).parser("string");
  }
  function vB(r, e) {
    return dp(r, e).parser("number").ensureWithinRange(-1, 1);
  }
  function YM(r, e) {
    return dp(r, e).parser({ left: 1, mid: 2, right: 3 });
  }
  function Kx(r, e) {
    return dp(r, e).parser({
      lowest: 1,
      lower: 2,
      low: 3,
      mid: 4,
      high: 5,
      higher: 6,
      highest: 7,
    });
  }
  function vQ(r, e) {
    return dp(r, e).parser({ small: 1, medium: 2, large: 3 });
  }
  function Mt(r, e) {
    return new dS({ name: r, default: e });
  }
  function lf(r, e, t) {
    return new cS({ name: r, default: e, options: t }).parser("string");
  }
  function la(r, e) {
    return lf(r, e || "blue", [
      { label: "Blue", value: "blue" },
      { label: "Green", value: "green" },
      { label: "Orange", value: "orange" },
      { label: "Purple", value: "purple" },
      { label: "Black", value: "black" },
      { label: "Red", value: "red" },
      { label: "Gray", value: "gray" },
    ]).parser({
      blue: "1",
      green: "2",
      orange: "3",
      purple: "4",
      black: "5",
      red: "6",
      gray: "7",
    });
  }
  function CQ(r) {
    return lf(r, "solid", [{ label: "Solid", value: "solid" }, {
      label: "Dashed",
      value: "dashed",
    }, { label: "Dotted", value: "dotted" }]).parser({
      solid: "1",
      dashed: "2",
      dotted: "3",
    });
  }
  function CB(r) {
    return dp(r, "attainable").parser({
      attainable: 1,
      unattainable: 2,
      efficient: 3,
    });
  }
  function Al(r) {
    return dp(r, "none").parser({ none: 0, negative: -1, positive: 1 });
  }
  function TB(r) {
    return dp(r, "standard").parser({
      horizontal: "1",
      gradual: "2",
      standard: "3",
      steep: "4",
      vertical: "5",
    });
  }
  function gg(r, e) {
    return lf(r, e || "none", [
      { label: "None", value: "none" },
      { label: "X", value: "x" },
      { label: "Y", value: "y" },
      { label: "Both", value: "both" },
    ]).parser({ none: "0", x: "1", y: "2", both: "3" });
  }
  var pS,
    uS,
    hS,
    SQ,
    SB,
    EB,
    EQ,
    TQ,
    DQ,
    kQ,
    _Q,
    IQ,
    AQ,
    gS,
    MQ,
    GQ,
    LQ,
    PQ,
    DB = __dcg_shared_module_exports__["lazyDefine"](() => {
      wB();
      pS = new pt({
        name: "Horizontal Axis",
        attributes: {
          min: Ft("X Min", "0").latex("x_{min}"),
          max: Ft("X Max", "50").latex("x_{max}"),
          res: Ft("X Res", "5").latex("x_{res}"),
          major_grid: Ft("X Major Grid", "5").latex("x_{majorGrid}"),
          label: er("X Axis Label", "Good 1").label("x_{label}"),
          tickmark_interval: Ft("X Tickmarks", "5").latex("x_{tick}"),
          label_interval: Ft("X Labels", "5").latex("x_{labelInt}"),
        },
      }),
        uS = new pt({
          name: "Vertical Axis",
          attributes: {
            min: Ft("Y Min", "0").latex("y_{min}"),
            max: Ft("Y Max", "50").latex("y_{max}"),
            res: Ft("Y Res", "5").latex("y_{res}"),
            major_grid: Ft("Y Major Grid", "5").latex("y_{majorGrid}"),
            label: er("Y Axis Label", "Good 2").label("y_{label}"),
            tickmark_interval: Ft("Y Tickmarks", "5").latex("y_{tick}"),
            label_interval: Ft("Y Labels", "5").latex("y_{labelInt}"),
          },
        }),
        hS = new pt({
          name: "Graph Properties",
          attributes: {
            title: er("Graph Title", "Graph Title").label("p_{Title}"),
          },
        }),
        SQ = new pt({
          name: "Endpoint Mover",
          attributes: {
            appearance: lf("Appearance", "1", [
              { label: "Concave Downward", value: "1" },
              { label: "Linear", value: "2" },
              { label: "Concave Upward", value: "3" },
            ]).parser({
              1: "1",
              concaveUp: "1",
              2: "2",
              linear: "2",
              3: "3",
              concaveDown: "3",
            }),
            color: la("Color"),
            style: CQ("Style"),
            given: Mt("Given", true).conditionalAttributes(true, {
              x_shift: Al("xShift"),
              y_shift: Al("yShift"),
              label: er("Label", ""),
            }).conditionalAttributes(false, {
              group_label: er("Label", ""),
              validation: new pt({
                attributes: {
                  x_shift: Al("xShift"),
                  y_shift: Al("yShift"),
                },
              }),
            }),
            group_points: new Vi({
              name: "Endpoint Mover Points",
              maximum: 3,
              items: new pt({
                attributes: {
                  color: la("Color"),
                  label: er("label", ""),
                  given: Mt("Given", true).conditionalAttributes(true, {
                    type: CB("Type"),
                  }).conditionalAttributes(false, {
                    validation: new pt({
                      attributes: { type: CB("Type") },
                    }),
                  }),
                  show_coords: Mt("Show Coords", false),
                },
              }),
            }),
          },
        }),
        SB = new Vi({
          name: "Increasing Lines",
          items: new pt({
            attributes: {
              color: la("Color", "orange"),
              scale: Ft("Scale", "1"),
              type: TB("Type"),
              label: er("Label", ""),
              ghost_label: er("Ghost Label", ""),
              post_shift_label: er("Post Shift Label", ""),
              given: Mt("Given", true).conditionalAttributes(false, {
                validation: new pt({
                  attributes: { shift: Al("Shift") },
                }),
                shifter_point: new pt({
                  attributes: {
                    show: Mt("Shifter Point", false).conditionalAttributes(
                      true,
                      {
                        drop_lines: gg("Drop Lines", "none"),
                        label: er("Label", ""),
                        ghost_label: er("Ghost Label", ""),
                        post_shift_label: er("Post Shift Label", ""),
                        validation: new pt({
                          attributes: { shift: Al("Shift") },
                        }),
                      },
                    ),
                  },
                }),
              }).conditionalAttributes(true, {
                shift: Al("Shift"),
                shifter_point: new pt({
                  attributes: {
                    show: Mt("Shifter Point", false).conditionalAttributes(
                      true,
                      {
                        drop_lines: gg("Drop Lines", "none"),
                        label: er("Label", ""),
                        ghost_label: er("Ghost Label", ""),
                        post_shift_label: er("Post Shift Label", ""),
                        shift: Al("Shift"),
                      },
                    ),
                  },
                }),
              }),
            },
          }),
        }),
        EB = new Vi({
          name: "Decreasing Lines",
          items: new pt({
            attributes: {
              color: la("Color"),
              scale: Ft("Scale", "1"),
              type: TB("Type"),
              label: er("Label", ""),
              ghost_label: er("Ghost Label", ""),
              post_shift_label: er("Post Shift Label", ""),
              given: Mt("Given", true).conditionalAttributes(false, {
                validation: new pt({
                  attributes: { shift: Al("Shift") },
                }),
                shifter_point: new pt({
                  attributes: {
                    show: Mt("Shifter Point", false).conditionalAttributes(
                      true,
                      {
                        drop_lines: gg("Drop Lines", "none"),
                        label: er("Label", ""),
                        ghost_label: er("Ghost Label", ""),
                        post_shift_label: er("Post Shift Label", ""),
                        validation: new pt({
                          attributes: { shift: Al("Shift") },
                        }),
                      },
                    ),
                  },
                }),
              }).conditionalAttributes(true, {
                shift: Al("Shift"),
                shifter_point: new pt({
                  attributes: {
                    show: Mt("Shifter Point", false).conditionalAttributes(
                      true,
                      {
                        drop_lines: gg("Drop Lines", "none"),
                        label: er("Label", ""),
                        ghost_label: er("Ghost Label", ""),
                        post_shift_label: er("Post Shift Label", ""),
                        shift: Al("Shift"),
                      },
                    ),
                  },
                }),
              }),
            },
          }),
        }),
        EQ = new pt({
          name: "Shifter",
          attributes: {
            increasing_lines: SB,
            decreasing_lines: EB,
            shifter_intersections: new Vi({
              name: "Intersections",
              items: new pt({
                attributes: {
                  increasing_line: Ft("Increasing Line", "1")
                    .ensureWithinArrayBounds(SB),
                  decreasing_line: Ft("Decreasing Line", "1")
                    .ensureWithinArrayBounds(EB),
                  drop_lines: gg("Drop Lines", "both"),
                  show_coords: Mt("Show Coords", false),
                  show_point: Mt("Show Point", true),
                },
              }),
            }),
          },
        }),
        TQ = new pt({
          name: "Cost Curves",
          attributes: {
            role: lf("Role", "taker", [{
              label: "Price Taker",
              value: "taker",
            }, {
              label: "Price Setter Upward MC",
              value: "setter-upward",
            }, {
              label: "Price Setter Constant MC",
              value: "setter-constant",
            }]).conditionalAttributes("taker", {
              mc: new pt({
                attributes: {
                  horizontal: YM("MC Horizontal Alignment", "mid"),
                  vertical: Kx("MC Vertical Alignment", "mid"),
                  show: Mt("Show MC", true).conditionalAttributes(true, {
                    label: er("MC Label", "MC"),
                    color: la("MC Color", "orange"),
                  }),
                },
              }),
              avc: new pt({
                attributes: {
                  vertical: Kx("AVC Vertical Alignment", "mid"),
                  show: Mt("Show AVC", true).conditionalAttributes(true, {
                    label: er("AVC Label", "AVC"),
                    color: la("AVC Color", "purple"),
                  }),
                },
              }),
              atc: new pt({
                attributes: {
                  show: Mt("Show ATC", true).conditionalAttributes(true, {
                    label: er("ATC Label", "ATC"),
                    color: la("ATC Color", "green"),
                  }),
                },
              }),
            }).conditionalAttributes("setter-upward", {
              mc: new pt({
                attributes: {
                  horizontal: YM("MC Horizontal Alignment", "mid"),
                  vertical: Kx("MC Vertical Alignment", "mid"),
                  show: Mt("Show MC", true).conditionalAttributes(true, {
                    label: er("MC Label", "MC"),
                    color: la("MC Color", "orange"),
                  }),
                },
              }),
              avc: new pt({
                attributes: {
                  show: Mt("Show AVC", true).conditionalAttributes(true, {
                    label: er("AVC Label", "AVC"),
                    color: la("AVC Color", "purple"),
                  }),
                },
              }),
              atc: new pt({
                attributes: {
                  horizontal: YM("ATC Horizontal Alignment", "mid"),
                  vertical: Kx("ATC Vertical Alignment", "mid"),
                  show: Mt("Show ATC", true).conditionalAttributes(true, {
                    label: er("ATC Label", "ATC"),
                    color: la("ATC Color", "green"),
                  }),
                },
              }),
            }).conditionalAttributes("setter-constant", {
              mc: new pt({
                attributes: {
                  vertical: Kx("MC Vertical Alignment", "mid"),
                  show: Mt("Show MC", true).conditionalAttributes(true, {
                    label: er("MC Label", "MC"),
                    color: la("MC Color", "orange"),
                  }),
                },
              }),
              atc: new pt({
                attributes: {
                  show: Mt("Show ATC", true).conditionalAttributes(true, {
                    label: er("ATC Label", "ATC"),
                    color: la("ATC Color", "green"),
                  }),
                },
              }),
              fc_scale: vQ("FC Scale", "medium"),
            }),
          },
        }),
        DQ = new pt({
          attributes: {
            color: la("Color"),
            connected: Mt("Connected", false),
            given: Mt("Given", true).conditionalAttributes(true, {
              when_given: new pt({
                attributes: {
                  group_points: new Vi({
                    name: "Group Points",
                    minimum: 1,
                    items: new pt({
                      name: "Group Points",
                      attributes: {
                        x_coord: Ft("X", ""),
                        y_coord: Ft("Y", ""),
                        label: er("label", ""),
                        drop_lines: gg("Drop Lines"),
                        show_point: Mt("Show Point", true)
                          .conditionalAttributes(true, {
                            show_coords: Mt("Show Coords", false),
                          }),
                      },
                    }),
                  }),
                },
              }),
            }).conditionalAttributes(false, {
              when_required: new pt({
                attributes: {
                  group_label: er("Group Label", ""),
                  group_points: new Vi({
                    name: "Group Points",
                    minimum: 1,
                    items: new pt({
                      name: "Group Points",
                      attributes: {
                        drop_lines: gg("Drop Lines"),
                        show_coords: Mt("Show Coords", false),
                        validation: new pt({
                          attributes: {
                            x_coord: Ft("X", ""),
                            y_coord: Ft("Y", ""),
                          },
                        }),
                      },
                    }),
                  }),
                },
              }),
            }),
          },
        }),
        kQ = new pt({
          attributes: {
            color: la("Color"),
            given: Mt("Given", true).conditionalAttributes(true, {
              when_given: new pt({
                attributes: {
                  group_lines: new Vi({
                    name: "Group Lines",
                    minimum: 1,
                    items: new pt({
                      attributes: {
                        show_x_int: Mt("Show X Intercept", false),
                        show_y_int: Mt("Show Y Intercept", false),
                        show_slope: Mt("Show Slope", false),
                        use_slope: Mt("Use Slope", true)
                          .conditionalAttributes(true, {
                            when_slope: new pt({
                              attributes: {
                                x_coord_1: Ft("X1", ""),
                                y_coord_1: Ft("Y1", ""),
                                label_1: er("Label", ""),
                                slope: Ft("Slope", ""),
                              },
                            }),
                          }).conditionalAttributes(false, {
                            when_not_slope: new pt({
                              attributes: {
                                x_coord_1: Ft("X1", ""),
                                y_coord_1: Ft("Y1", ""),
                                label_1: er("Label", ""),
                                x_coord_2: Ft("X2", ""),
                                y_coord_2: Ft("Y2", ""),
                                label_2: er("Label", ""),
                              },
                            }),
                          }),
                        show_points: Mt("Show Points", true)
                          .conditionalAttributes(true, {
                            show_coords: Mt("Show Coords", false),
                          }),
                      },
                    }),
                  }),
                },
              }),
            }).conditionalAttributes(false, {
              when_required: new pt({
                attributes: {
                  group_label: er("Group Label", ""),
                  group_lines: new Vi({
                    name: "Group Lines",
                    minimum: 1,
                    items: new pt({
                      attributes: {
                        show_coords: Mt("Show Coords", false),
                        show_x_int: Mt("Show X Intercept", false),
                        show_y_int: Mt("Show Y Intercept", false),
                        show_slope: Mt("Show Slope", false),
                        use_slope: Mt("Use Slope", true)
                          .conditionalAttributes(true, {
                            when_slope: new pt({
                              attributes: {
                                validation: new pt({
                                  attributes: {
                                    x_coord_1: Ft("X1", ""),
                                    y_coord_1: Ft("Y1", ""),
                                    slope: Ft("slope", ""),
                                  },
                                }),
                              },
                            }),
                          }).conditionalAttributes(false, {
                            when_not_slope: new pt({
                              attributes: {
                                validation: new pt({
                                  attributes: {
                                    x_coord_1: Ft("X1", ""),
                                    y_coord_1: Ft("Y1", ""),
                                    x_coord_2: Ft("X2", ""),
                                    y_coord_2: Ft("Y2", ""),
                                  },
                                }),
                              },
                            }),
                          }),
                      },
                    }),
                  }),
                },
              }),
            }),
          },
        }),
        _Q = new pt({
          attributes: {
            color: la("Color"),
            given: Mt("Given", true).conditionalAttributes(true, {
              when_given: new pt({
                attributes: {
                  group_curves: new Vi({
                    name: "Group Curves",
                    minimum: 1,
                    items: new pt({
                      attributes: {
                        curve_points: new Vi({
                          name: "Curve Points",
                          minimum: 3,
                          maximum: 6,
                          items: new pt({
                            attributes: {
                              x_coord: Ft("X", ""),
                              y_coord: Ft("Y", ""),
                              label: er("Label", ""),
                            },
                          }),
                        }),
                        show_points: Mt("Show Points", true)
                          .conditionalAttributes(true, {
                            show_coords: Mt("Show Coords", false),
                          }),
                      },
                    }),
                  }),
                },
              }),
            }).conditionalAttributes(false, {
              when_required: new pt({
                attributes: {
                  group_label: er("Group Label", ""),
                  group_curves: new Vi({
                    minimum: 1,
                    name: "Group Curves",
                    items: new pt({
                      attributes: {
                        show_coords: Mt("Show Coords", false),
                        curve_points: new Vi({
                          name: "Curve Points",
                          minimum: 3,
                          maximum: 6,
                          items: new pt({
                            attributes: {
                              validation: new pt({
                                attributes: {
                                  x_coord: Ft("X", ""),
                                  y_coord: Ft("Y", ""),
                                },
                              }),
                            },
                          }),
                        }),
                      },
                    }),
                  }),
                },
              }),
            }),
          },
        }),
        IQ = new pt({
          attributes: {
            color: la("Color"),
            given: Mt("Given", true).conditionalAttributes(true, {
              when_given: new pt({
                attributes: {
                  group_mono_arcs: new Vi({
                    name: "Group Monotonic Arcs",
                    minimum: 1,
                    items: new pt({
                      attributes: {
                        concavity: vB("Concavity", ""),
                        x_coord_1: Ft("X1", ""),
                        y_coord_1: Ft("Y1", ""),
                        label_1: er("Label 1", ""),
                        x_coord_2: Ft("X2", ""),
                        y_coord_2: Ft("Y2", ""),
                        label_2: er("Label 2", ""),
                        show_points: Mt("Show Points", true)
                          .conditionalAttributes(true, {
                            show_coords: Mt("Show Coords", false),
                          }),
                      },
                    }),
                  }),
                },
              }),
            }).conditionalAttributes(false, {
              when_required: new pt({
                attributes: {
                  group_label: er("Group Label", ""),
                  group_mono_arcs: new Vi({
                    minimum: 1,
                    name: "Group Monotonic Arcs",
                    items: new pt({
                      attributes: {
                        show_coords: Mt("Show Coords", false),
                        concavity: vB("Concavity", ""),
                        validation: new pt({
                          attributes: {
                            x_coord_1: Ft("X", ""),
                            y_coord_1: Ft("Y", ""),
                            x_coord_2: Ft("X", ""),
                            y_coord_2: Ft("Y", ""),
                          },
                        }),
                      },
                    }),
                  }),
                },
              }),
            }),
          },
        }),
        AQ = new pt({
          attributes: {
            color: la("Color"),
            given: Mt("Given", true).conditionalAttributes(true, {
              when_given: new pt({
                attributes: {
                  group_polygons: new Vi({
                    name: "Group Polygons",
                    minimum: 1,
                    items: new pt({
                      attributes: {
                        show_area: Mt("Show Area", false),
                        show_perimeter: Mt("Show Perimeter", false),
                        fill_pattern: Mt("Fill Pattern", true),
                        polygon_points: new Vi({
                          name: "Polygon Points",
                          minimum: 3,
                          maximum: 10,
                          items: new pt({
                            attributes: {
                              x_coord: Ft("X", ""),
                              y_coord: Ft("Y", ""),
                              label: er("Label", ""),
                            },
                          }),
                        }),
                        show_points: Mt("Show Points", true)
                          .conditionalAttributes(true, {
                            show_coords: Mt("Show Coords", false),
                          }),
                      },
                    }),
                  }),
                },
              }),
            }).conditionalAttributes(false, {
              when_required: new pt({
                attributes: {
                  group_label: er("Group Label", ""),
                  group_polygons: new Vi({
                    minimum: 1,
                    name: "Group Polygons",
                    items: new pt({
                      attributes: {
                        show_coords: Mt("Show Coords", false),
                        show_area: Mt("Show Area", false),
                        show_perimeter: Mt("Show Perimeter", false),
                        fill_pattern: Mt("Fill Pattern", true),
                        polygon_points: new Vi({
                          name: "Polygon Points",
                          minimum: 3,
                          maximum: 10,
                          items: new pt({
                            attributes: {
                              validation: new pt({
                                attributes: {
                                  x_coord: Ft("X", ""),
                                  y_coord: Ft("Y", ""),
                                },
                              }),
                            },
                          }),
                        }),
                      },
                    }),
                  }),
                },
              }),
            }),
          },
        }),
        gS = new Vi({
          name: "Common Components",
          items: new pt({
            name: "Common Component",
            attributes: {
              object_type: lf("Component Type", "common_point", [
                { label: "Point", value: "common_point" },
                { label: "Line", value: "common_line" },
                { label: "Curve", value: "common_curve" },
                { label: "Monotonic Arc", value: "common_mono_arc" },
                { label: "Polygon", value: "common_polygon" },
              ]).conditionalAttributes("common_point", { when_point: DQ })
                .conditionalAttributes("common_line", { when_line: kQ })
                .conditionalAttributes("common_curve", { when_curve: _Q })
                .conditionalAttributes("common_mono_arc", {
                  when_mono_arc: IQ,
                }).conditionalAttributes("common_polygon", {
                  when_polygon: AQ,
                }),
            },
          }),
        }),
        MQ = new hg({
          dcg_x_axis: pS,
          dcg_y_axis: uS,
          dcg_graph_properties: hS,
          dcg_common_components: gS,
        }),
        GQ = new hg({
          dcg_x_axis: pS,
          dcg_y_axis: uS,
          dcg_graph_properties: hS,
          dcg_common_components: gS,
          dcg_endpoint_mover: SQ,
        }),
        LQ = new hg({
          dcg_x_axis: pS,
          dcg_y_axis: uS,
          dcg_graph_properties: hS,
          dcg_common_components: gS,
          dcg_shifter: EQ,
        }),
        PQ = new hg({
          dcg_x_axis: pS,
          dcg_y_axis: uS,
          dcg_graph_properties: hS,
          dcg_common_components: gS,
          dcg_cost_curves: TQ,
        });
    });
  var kB = __dcg_shared_module_exports__["lazyDefine"](() => {
    DB();
  });
  var _B = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var IB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  function NQ(r) {
    var o;
    let [e, t] = (o = RQ.exec(r)) != null ? o : [];
    return t;
  }
  function XM(r) {
    let e = NQ(r);
    return e ? FQ.test(e) : true;
  }
  function mS(r, e) {
    var i;
    let t = "";
    if (
      e !== void 0 ? t = e : typeof window != "undefined" &&
        (t = (i = new URLSearchParams(window.location.search).get(
            "lang",
          )) != null
          ? i
          : ""), r === "" || t === "" || VQ.test(r) || OQ.test(r) || !XM(r)
    ) return r;
    let o = encodeURIComponent(t);
    if (r.length) {
      let n = r.split("#"),
        a = /\?/.test(r) ? `${n[0]}&lang=${o}` : `${n[0]}?lang=${o}`;
      return n[1] !== void 0 ? `${a}#${n[1]}` : a;
    } else return `?lang=${o}`;
  }
  var VQ,
    OQ,
    RQ,
    FQ,
    AB = __dcg_shared_module_exports__["lazyDefine"](() => {
      VQ = /lang=[A-Za-z]+/,
        OQ = /(cl|learn|help).desmos.com/,
        RQ = /^(?:https?:)?(?:\/\/)?([^\s:\/\?]+)/i,
        FQ = /(^desmos\.com$)|(\.desmos.com$)/;
    });
  var MB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  var GB,
    LB = __dcg_shared_module_exports__["lazyDefine"](() => {
      GB = () => {};
    });
  var PB,
    cf,
    Mge,
    VB = __dcg_shared_module_exports__["lazyDefine"](() => {
      PB = "v1_10",
        cf = `dcg-calculator-api-container-${PB}`,
        Mge = `dcg-matrix-api-container-${PB}`;
    });
  var mg = __dcg_shared_module_exports__["lazyDefine"](() => {
    bB();
    yB();
    xB();
    kB();
    _B();
    IB();
    AB();
    MB();
    LB();
    VB();
  });
  function So(r, e) {
    df == null || df.notify(r, e);
  }
  function Wx(r, e, t) {
    df == null || df.leaveBreadcrumb(r, e, t);
  }
  var df, Ss = __dcg_shared_module_exports__["lazyDefine"](() => {});
  function fS(r) {
    let e = () => r;
    return e.isDCGViewConst = true, e;
  }
  function Hn(r) {
    return typeof r == "function" && !!r.isDCGViewConst;
  }
  var pc = __dcg_shared_module_exports__["lazyDefine"](() => {});
  function OB(r) {
    let e = r();
    if (typeof e == "string") return e;
    if (typeof e != "object") {
      throw new Error(
        `Unsupported type returned from class getter: ${typeof e}`,
      );
    }
    return Object.keys(e).filter((t) => e.hasOwnProperty(t) && e[t]).join(
      " ",
    );
  }
  function BQ(r, e, t) {
    let o = r.className.replace(RB, "").split(FB),
      i = e.replace(RB, "").split(FB),
      n = {};
    for (let s of i) n[s] = true;
    let a = o.filter((s) => !n.hasOwnProperty(s));
    return t ? `${t} ${a.join(" ")}`.trim() : a.join(" ");
  }
  function NB(r) {
    let e = OB(r),
      t = Hn(r) ? void 0 : {
        onUpdate: (o) => {
          let i = OB(r);
          e !== i &&
            (o.className = o.className === e ? i : BQ(o, e, i), e = i);
        },
      };
    return { value: e, bindings: t };
  }
  var RB,
    FB,
    BB = __dcg_shared_module_exports__["lazyDefine"](() => {
      pc();
      RB = /^\s+|\s+$/g, FB = /\s+/;
    });
  function UB(r) {
    return (e) => {
      if (typeof e != "function") {
        throw new Error(
          `The ${r} attribute expects a function for the value`,
        );
      }
      if (Hn(e)) {
        throw new Error(
          `The ${r} attribute does not expect a const for the value`,
        );
      }
      return { bindings: { [r]: e } };
    };
  }
  var zB = __dcg_shared_module_exports__["lazyDefine"](() => {
    pc();
  });
  function bS(r, e, t) {
    return t === void 0 ? r.removeAttribute(e) : r.setAttribute(e, `${t}`);
  }
  var JM = __dcg_shared_module_exports__["lazyDefine"](() => {});
  function qB(r) {
    let e = r(), t = typeof e;
    if (t === "string") return e;
    if (!t || t !== "object") {
      throw new Error(
        `Unsupported type returned from style getter: ${t}`,
      );
    }
    return Object.entries(e).filter(([o, i]) =>
      e.hasOwnProperty(o) && i !== null && i !== void 0
    ).map(([o, i]) => `${o}:${i}`).join(";");
  }
  function HB(r) {
    let e = qB(r),
      t = Hn(r) ? void 0 : {
        onUpdate: (o) => {
          let i = qB(r);
          e !== i && (bS(o, "style", i), e = i);
        },
      };
    return { value: e, bindings: t };
  }
  var KB = __dcg_shared_module_exports__["lazyDefine"](() => {
    JM();
    pc();
  });
  function pf(r, e) {
    QM[r] = e;
  }
  function WB(r) {
    return QM.hasOwnProperty(r);
  }
  function $B(r, e) {
    let t = QM[r];
    return t(e);
  }
  var QM,
    yS = __dcg_shared_module_exports__["lazyDefine"](() => {
      QM = {};
    });
  function jB(r, e) {
    if (e != null) {
      if (typeof r != "string") {
        throw new Error("Must pass a string for an EventHandler name");
      }
      if (typeof e != "function") {
        throw new Error(
          "Must pass a function for an EventHandler callback",
        );
      }
      return {
        bindings: {
          onMount(t) {
            t && (t[r.toLowerCase()] = (o, ...i) => {
              o && e.apply(t, [o, ...i]);
            });
          },
        },
      };
    }
  }
  var YB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  function XB(r, e) {
    let t = e(), o;
    return Hn(e) || (o = {
      onUpdate(i) {
        if (!i) return;
        let n = e();
        n !== t && (t = n, bS(i, r, n));
      },
    }),
      { value: t, bindings: o };
  }
  var JB = __dcg_shared_module_exports__["lazyDefine"](() => {
    JM();
    pc();
  });
  function QB(r) {
    return r.startsWith("on") && r[2] === r[2].toUpperCase();
  }
  var ZB = __dcg_shared_module_exports__["lazyDefine"](() => {});
  function e5(r, e) {
    if (typeof e != "function") {
      throw new Error(
        `The "${r}" attr must be a function. It is: ${JSON.stringify(e)}`,
      );
    }
    return WB(r) ? $B(r, e) : QB(r) ? jB(r, e) : XB(r, e);
  }
  var t5 = __dcg_shared_module_exports__["lazyDefine"](() => {
    YB();
    JB();
    yS();
    ZB();
  });
  function r5(r, e, t) {
    let o = r._bindings[e];
    r._bindings[e] = o ? [...o, t] : [t];
  }
  function uc(r, e) {
    var o;
    ((o = r._bindings[e]) != null ? o : []).forEach((i) => i());
  }
  var ZM = __dcg_shared_module_exports__["lazyDefine"](() => {});
  function o5(r) {
    $x.push(r);
  }
  function i5(r) {
    let e = $x.filter((t) => t !== r);
    $x.length = 0, $x.push(...e);
  }
  function fg(r, e) {
    if (Eu(e)) {
      let o = `[${e._viewName}]`,
        i = e.traceViewHierarchy(),
        n = i.ancestors.length > 0
          ? `
View Hierarchy:
${i.formatted}`
          : "";
      r = `${r} ${o}${n}`;
    }
    let t = new Error(r);
    console.warn(t), $x.forEach((o) => o(t));
  }
  var $x,
    xS = __dcg_shared_module_exports__["lazyDefine"](() => {
      id();
      $x = [];
    });
  var qa,
    bg,
    wS,
    vS,
    uf = __dcg_shared_module_exports__["lazyDefine"](() => {
      pc();
      xS();
      qa = class {
        assertNotMounted() {
          if (this._domNode) {
            throw new Error("Cannot remount a DCGElement");
          }
        }
      },
        bg = Symbol("DCGPlaceholderElement"),
        wS = class extends qa {
          renderTo(e) {
            this.assertNotMounted(),
              this._domNode = document.createTextNode(""),
              e.appendChild(this._domNode);
          }
        },
        vS = class extends qa {
          constructor(t, o, i) {
            super();
            this.tagName = t;
            this.attributes = o;
            this.children = i;
            Array.isArray(this.children) && this.children.forEach((n) => {
              n instanceof qa && (n._parentElement = this);
            });
          }
          appendTextNode(t) {
            this._domNode.appendChild(document.createTextNode(t));
          }
          renderTo(t, o) {
            this.assertNotMounted(),
              this._domNode = document.createElement(this.tagName),
              o.bindAttributesTo(this._domNode, this.attributes),
              t.appendChild(this._domNode),
              this.children.forEach((i) => {
                if (i instanceof qa) {
                  i.renderTo(this._domNode, o);
                  return;
                }
                if (Hn(i)) {
                  this.appendTextNode(i());
                  return;
                }
                if (typeof i == "function") {
                  o.bindText(this._domNode, i);
                  return;
                }
                fg(
                  "Text should be a const or a getter: " +
                    JSON.stringify(i),
                  o,
                ), this.appendTextNode(i);
              });
          }
        };
    });
  function n5(r, e) {
    r != null &&
      (Array.isArray(r) ? r.forEach((t) => n5(t, e)) : e.push(r));
  }
  function nd(r, e, ...t) {
    let o = [];
    t.forEach((s) => n5(s, o));
    let i = e != null ? e : {}, n;
    o.length === 0 ? n = void 0 : o.length === 1 ? n = o[0] : n = o;
    let a = { ...i, children: n };
    return r === bg
      ? new wS()
      : typeof r == "string"
      ? new vS(r, i, o)
      : new r(a)._construct();
  }
  var hf = __dcg_shared_module_exports__["lazyDefine"](() => {
    uf();
  });
  var Eu,
    qi,
    id = __dcg_shared_module_exports__["lazyDefine"](() => {
      t5();
      ZM();
      pc();
      hf();
      uf();
      xS();
      Eu = (r) => !!r && r instanceof qi,
        qi = class extends qa {
          constructor(t) {
            var o, i;
            super();
            this.__generatedHTMLBefore = false;
            this._childViews = [];
            this._bindings = {};
            this._isMounted = false;
            this._willBeUnmounted = false;
            this.const = fS;
            this.createElement = nd;
            this._viewName =
              (i = (o = this.constructor) == null ? void 0 : o.name) !=
                  null
                ? i
                : "Anonymous DCGView",
              Object.entries(t != null ? t : {}).filter(([n]) =>
                n !== "children"
              ).forEach(([n, a]) => {
                if (typeof a != "function" && a !== void 0) {
                  throw new Error(
                    `The "${n}" prop must be a function. It is: ${
                      JSON.stringify(a)
                    }`,
                  );
                }
              }),
              this.props = t != null ? t : {};
          }
          init() {}
          template() {
            throw new Error("template() must be implemented");
          }
          _construct() {
            var t;
            if (
              (t = this.init) == null || t.call(this),
                this._element = this.template(),
                !(this._element instanceof qa)
            ) throw new Error("template() must return a DCGElement");
            return this._element._parentElement = this, this;
          }
          bindFn(t) {
            return t.bind(this);
          }
          bindIfMounted(t) {
            return this.bindFn((...o) => {
              if (this._isMounted) return t.apply(this, o);
            });
          }
          traceViewHierarchy() {
            let t = [], o = this._parentElement;
            for (; o;) t.unshift(o), o = o._parentElement;
            let i = (a) =>
                Eu(a) &&
                !(a._viewName === "Switch" && Eu(a._parentElement) &&
                  a._parentElement._viewName === "If") &&
                ![
                  "IfDefinedWrapper",
                  "SwitchWrapper",
                  "SwitchUnionWrapper",
                ].includes(a._viewName),
              n = [...t, this].filter(i).map((a, s) =>
                "  ".repeat(s) + "<" + a._viewName + ">"
              ).join(`
`);
            return { ancestors: t, formatted: n };
          }
          renderTo(t, o) {
            if (
              o && o._childViews.push(this), this.__generatedHTMLBefore
            ) throw new Error("Cannot remount a DCGView");
            this.__generatedHTMLBefore = true, this._element.renderTo(t, this);
          }
          findFirstRootDOMNode() {
            let t = this._element;
            return Eu(t) ? t.findFirstRootDOMNode() : t._domNode;
          }
          findLastRootDOMNode() {
            let t = this._element;
            return Eu(t) ? t.findLastRootDOMNode() : t._domNode;
          }
          findAllRootDOMNodes() {
            let t = this.findFirstRootDOMNode(),
              o = this.findLastRootDOMNode(),
              i = [],
              n = t;
            for (; n && (i.push(n), n !== o);) n = n.nextSibling;
            return i;
          }
          update() {
            var t, o, i;
            if (!this._isMounted) {
              return fg(
                "Trying to update view that is not mounted. Ignoring update.",
                this,
              );
            }
            this.shouldUpdate && !this.shouldUpdate() ||
              ((t = this.willUpdate) == null || t.call(this),
                uc(this, "willUpdate"),
                uc(this, "onUpdate"),
                (o = this.onUpdate) == null || o.call(this),
                this.updateChildren(),
                uc(this, "didUpdate"),
                (i = this.didUpdate) == null || i.call(this));
          }
          updateChildren() {
            this._childViews.forEach((t) => t.update());
          }
          bindText(t, o) {
            var a;
            let i = (a = o()) != null ? a : "",
              n = document.createTextNode(i);
            t.appendChild(n),
              r5(this, "onUpdate", () => {
                var l;
                let s = (l = o()) != null ? l : "";
                i !== s && (n.nodeValue = s, i = s);
              });
          }
          addAttributeBindingsTo(t, o) {
            Object.entries(o).forEach(([i, n]) => {
              if (!n) return;
              if (
                [
                  "onMount",
                  "didMount",
                  "willUnmount",
                  "willUpdate",
                  "onUpdate",
                  "didUpdate",
                ].includes(i) && (n = n.bind(null, t)),
                  [
                    "willMount",
                    "onMount",
                    "didMount",
                    "willUnmount",
                    "onUnmount",
                    "didUnmount",
                  ].includes(i)
              ) {
                let c = false, d = n;
                n = (...p) => {
                  if (c) {
                    fg(
                      `${i} is a one-time binding but was called multiple times`,
                      this,
                    );
                    return;
                  }
                  c = true, d(...p);
                };
              }
              let l = this._bindings[i];
              this._bindings[i] = l ? [...l, n] : [n];
            });
          }
          bindAttributesTo(t, o) {
            t instanceof Text || !o ||
              Object.keys(o).filter((i) => i !== "children").forEach(
                (i) => {
                  let n = e5(i, o[i]);
                  n &&
                    ("value" in n && n.value !== void 0 &&
                      t.setAttribute(i, n.value),
                      n.bindings &&
                      this.addAttributeBindingsTo(t, n.bindings));
                },
              );
          }
        };
    });
  var Tme,
    CS,
    a5 = __dcg_shared_module_exports__["lazyDefine"](() => {
      Tme = __dcg_shared_module_exports__["defineDefaultExport"](ne());
      id();
      CS = class extends qi {
        constructor() {
          super(...arguments), this._viewName = "Checkbox";
        }
        computeChecked() {
          return !!this.props.checked();
        }
        template() {
          if (!this.props.checked) {
            throw new Error('<Checkbox> expects a "checked={}" prop');
          }
          if (!this.props.onChange) {
            throw new Error('<Checkbox> expects an "onChange={}" prop');
          }
          let e = {
            ...this.props,
            type: this.const("checkbox"),
            checked: this.const(
              this.computeChecked() ? "checked" : void 0,
            ),
            onChange: (t) => {
              this.props.onChange(t.target.checked),
                this._isMounted && this.update();
            },
            onMount: (t) => {
              this.rootDOM = t, this.props.onMount && this.props.onMount(t);
            },
          };
          return this.createElement("input", e);
        }
        didUpdate() {
          let e = this.computeChecked();
          this.rootDOM.checked !== e && (this.rootDOM.checked = e);
        }
      };
    });
  var s5,
    l5 = __dcg_shared_module_exports__["lazyDefine"](() => {
      s5 = (r) => {
        let e = r.length,
          t = new Array(e),
          o = new Array(e + 1),
          i = 0,
          n;
        for (let l = 0; l < e; l++) {
          if (r[o[i]] < r[l]) n = i + 1;
          else {
            let c = 1, d = i - 1;
            for (; c <= d;) {
              let p = Math.ceil((c + d) / 2);
              r[o[p]] < r[l] ? c = p + 1 : d = p - 1;
            }
            n = c;
          }
          t[l] = o[n - 1], o[n] = l, n > i && (i = n);
        }
        let a = new Array(i), s = o[i];
        for (let l = i - 1; l >= 0; l--) a[l] = r[s], s = t[s];
        return a;
      };
    });
  function c5(r, e) {
    let t = {};
    for (let l = 0; l < e.length; l++) t[e[l]] = l;
    let o = r.filter((l) => t[l] === void 0),
      i = r.map((l) => t[l]).filter((l) => l !== void 0),
      n = s5(i),
      a = {};
    for (let l = 0; l < n.length; l++) {
      let c = n[l];
      a[e[c]] = true;
    }
    let s = [];
    for (let l = e.length - 1; l >= 0; l--) {
      let c = e[l];
      a[c] || s.push({ key: c, beforeKey: e[l + 1] });
    }
    return { removes: o, inserts: s };
  }
  var d5 = __dcg_shared_module_exports__["lazyDefine"](() => {
    l5();
  });
  function p5(r, e, t) {
    if (!e || e.nodeType !== 1) {
      throw new Error("Must pass an HTMLElement for the node");
    }
    if (e._mountedDCGView) {
      throw new Error("This node is already mounted by a view");
    }
    let o = new r(t)._construct(), i = document.createDocumentFragment();
    return o.renderTo(i),
      e.innerHTML = "",
      gf(o),
      e._mountedDCGView = o,
      e.appendChild(i),
      mf(o),
      ff(o),
      o;
  }
  function u5(r) {
    let e = r._mountedDCGView;
    if (!e) throw new Error("This node is not mounted by a DCGView");
    bf(e), r.innerHTML = "", delete r._mountedDCGView, yf(e), xf(e);
  }
  function gf(r) {
    r.willMount && r.willMount(), uc(r, "willMount"), r._childViews.forEach(gf);
  }
  function mf(r) {
    r._isMounted = true,
      r.onMount && r.onMount(),
      uc(r, "onMount"),
      r._childViews.forEach(mf);
  }
  function ff(r) {
    r.didMount && r.didMount(), uc(r, "didMount"), r._childViews.forEach(ff);
  }
  function bf(r) {
    r.willUnmount && r.willUnmount(),
      uc(r, "willUnmount"),
      r._childViews.forEach(bf);
  }
  function yf(r) {
    r._isMounted = false,
      r._childViews.forEach(yf),
      uc(r, "onUnmount"),
      r.onUnmount && r.onUnmount();
  }
  function xf(r) {
    r._childViews.forEach(xf),
      uc(r, "didUnmount"),
      r.didUnmount && r.didUnmount();
  }
  function SS(r, e) {
    let t = document.createDocumentFragment();
    return r.renderTo(t, e), t.childNodes;
  }
  var ES = __dcg_shared_module_exports__["lazyDefine"](() => {
    ZM();
  });
  var Lme,
    eG,
    wf,
    tG = __dcg_shared_module_exports__["lazyDefine"](() => {
      Lme = __dcg_shared_module_exports__["defineDefaultExport"](ne());
      d5();
      pc();
      uf();
      ES();
      id();
      eG = class extends qi {
        constructor() {
          super(...arguments), this._viewName = "ForWrapper";
        }
        template() {
          return this.props.children;
        }
      },
        wf = class extends qi {
          constructor() {
            super(...arguments), this._viewName = "For";
          }
          getKeys() {
            this._keyToItem = {};
            let e = this.props.each();
            if (!Array.isArray(e)) {
              throw new Error("<For each={}> must return an array");
            }
            let t = this.props.key ? e.map(this.props.key) : [...e];
            if (!this._chosenKeyType && t.length) {
              let o = typeof t[0];
              if (o !== "string" && o !== "number") {
                throw new Error(
                  `The key: ${JSON.stringify(t[0])} is not a string or number`,
                );
              }
              this._chosenKeyType = o;
            }
            return t.forEach((o, i) => {
              if (typeof o !== this._chosenKeyType) {
                throw new Error(
                  `Keys must be the same type. ${
                    JSON.stringify(o)
                  } is not a ${this._chosenKeyType}`,
                );
              }
              let n = o;
              if (n in this._keyToItem) {
                throw new Error(
                  `The key: ${JSON.stringify(o)} is not unique`,
                );
              }
              this._keyToItem[n] = e[i];
            }),
              t;
          }
          createViewForKey(e) {
            let t = this._keyToItem[e],
              o = this._viewFunction.call(this, t, e),
              i = o;
            return Eu(i) || (i = this.createElement(eG, {}, o)),
              this._keyToView[e] = i,
              i;
          }
          template() {
            if (typeof this.props.each != "function") {
              throw new Error("<For each={}> must be a function");
            }
            if (!("children" in this.props)) {
              throw new Error("<For> expects a child.");
            }
            if (Array.isArray(this.props.children)) {
              throw new Error(
                `<For> expects a single child. You passed ${this.props.children.length}.`,
              );
            }
            if (
              this._viewFunction = this.props.children,
                this._viewFunction && this._viewFunction instanceof qa
            ) {
              throw new Error(
                "<For> expects a function that constructs a DCGElement. You passed a DCGElement directly",
              );
            }
            if (typeof this._viewFunction != "function") {
              let e = JSON.stringify(this._viewFunction);
              throw new Error(
                `<For> expects a function that constructs a DCGElement. You passed ${e}`,
              );
            }
            if (Hn(this._viewFunction)) {
              throw new Error(
                "<For> expects a function that constructs a DCGElement. You passed a constant",
              );
            }
            return this._keyToView = {},
              this._keys = this.getKeys(),
              this._startPlaceholder = this.createElement(bg, null),
              this._keys.map((e) => {
                let t = this.createViewForKey(e);
                return t._parentElement = this, t;
              }),
              this._endPlaceholder = this.createElement(bg, null),
              this._startPlaceholder;
          }
          detachAllRemovedViews() {
            let e = this._childViews, t = 0;
            for (let o = 0; o < e.length; o++) {
              let i = e[o];
              i._willBeUnmounted ? t++ : e[o - t] = i;
            }
            e.splice(e.length - t, t);
          }
          findFirstRootDOMNode() {
            return this._startPlaceholder._domNode;
          }
          findLastRootDOMNode() {
            return this._endPlaceholder._domNode;
          }
          updateChildren() {
            let e = this._keys, t = this.getKeys();
            this._keys = t;
            let o = c5(e, t), i = [];
            for (let a = o.removes.length - 1; a >= 0; a--) {
              let s = o.removes[a], l = this._keyToView[s];
              bf(l),
                delete this._keyToView[s],
                l._willBeUnmounted = true,
                l.findAllRootDOMNodes().forEach((c) => c.remove()),
                i.push(l);
            }
            i.length > 0 &&
              (this.detachAllRemovedViews(), i.forEach(yf), i.forEach(xf));
            let n = [];
            for (let a = o.inserts.length - 1; a >= 0; a--) {
              let s = o.inserts[a].key;
              if (s in this._keyToView) continue;
              let l = this.createViewForKey(s);
              SS(l, this), n.push(l);
            }
            n.forEach(gf),
              o.inserts.forEach((a) => {
                let s = this._keyToView[a.key].findAllRootDOMNodes(), l;
                a.beforeKey
                  ? l = this._keyToView[a.beforeKey]
                    .findFirstRootDOMNode()
                  : l = this.findLastRootDOMNode(),
                  s.forEach((c) => {
                    l.before(c);
                  });
              }),
              n.forEach(mf),
              n.forEach(ff);
            for (let a = 0; a < this._childViews.length - n.length; a++) {
              this._childViews[a].update();
            }
          }
          renderTo(e, t) {
            super.renderTo(e, t);
            for (let o of this._keys) {
              this._keyToView[o].renderTo(e, this);
            }
            this._endPlaceholder.renderTo(e, this);
          }
        };
    });
  function h5(r, e) {
    let t = { each: r, key: e.key }, o = nd(wf, t, e.item);
    return o._viewName = "Each", o;
  }
  var Bme,
    g5 = __dcg_shared_module_exports__["lazyDefine"](() => {
      Bme = __dcg_shared_module_exports__["defineDefaultExport"](ne());
      hf();
      tG();
    });
  var Hme,
    rG,
    ad,
    jx = __dcg_shared_module_exports__["lazyDefine"](() => {
      Hme = __dcg_shared_module_exports__["defineDefaultExport"](ne());
      pc();
      uf();
      ES();
      id();
      rG = class extends qi {
        constructor() {
          super(...arguments), this._viewName = "SwitchWrapper";
        }
        template() {
          return this.props.children;
        }
      },
        ad = class extends qi {
          constructor() {
            super(...arguments), this._viewName = "Switch";
          }
          updateKey() {
            this._key = this.props.key();
          }
          createView() {
            let e = this._viewFunction(this._key);
            e = e != null ? e : this.createElement(bg, null);
            let t = this.createElement(rG, {}, e);
            return t._parentElement = this, t;
          }
          template() {
            if (typeof this.props.key != "function") {
              throw new Error("<Switch key={}> must be a function");
            }
            if (!("children" in this.props)) {
              throw new Error("<Switch> expects a child.");
            }
            if (Array.isArray(this.props.children)) {
              throw new Error(
                `<Switch> expects a single child. You passed ${this.props.children.length}.`,
              );
            }
            if (
              this._viewFunction = this.props.children,
                this._viewFunction && this._viewFunction instanceof qa
            ) {
              throw new Error(
                "<Switch> expects a function that constructs a DCGElement. You passed a DCGElement directly",
              );
            }
            if (typeof this._viewFunction != "function") {
              let e = JSON.stringify(this._viewFunction);
              throw new Error(
                "<Switch> expects a function that constructs a DCGElement. You passed " +
                  e,
              );
            }
            if (Hn(this._viewFunction)) {
              throw new Error(
                "<Switch> expects a function that constructs a DCGElement. You passed a constant",
              );
            }
            return this.updateKey(), this.createView();
          }
          updateChildren() {
            let e = this._key;
            this.updateKey();
            let t = this._key;
            if (e === t) {
              this._element.update();
              return;
            }
            let o = this.findAllRootDOMNodes(),
              i = document.createTextNode("");
            o[0].before(i),
              bf(this._element),
              this._childViews = [],
              o.forEach((a) => a.remove()),
              yf(this._element),
              xf(this._element),
              this._element = this.createView();
            let n = SS(this._element, this);
            gf(this._element),
              n.forEach((a) => {
                i.before(a);
              }),
              i.remove(),
              mf(this._element),
              ff(this._element);
          }
        };
    });
  var Xme,
    TS,
    m5 = __dcg_shared_module_exports__["lazyDefine"](() => {
      Xme = __dcg_shared_module_exports__["defineDefaultExport"](ne());
      pc();
      uf();
      jx();
      id();
      TS = class extends qi {
        constructor() {
          super(...arguments), this._viewName = "If";
        }
        template() {
          let { predicate: e } = this.props;
          if (typeof e != "function") {
            throw new Error("<If predicate={}> must be a function");
          }
          if (!("children" in this.props)) {
            throw new Error("<If> expects a child.");
          }
          if (Array.isArray(this.props.children)) {
            throw new Error(
              `<If> expects a single child. You passed ${this.props.children.length}.`,
            );
          }
          let t = this.props.children;
          if (t && t instanceof qa) {
            throw new Error(
              "<If> expects a function that constructs a DCGElement. You passed a DCGElement directly",
            );
          }
          if (typeof t != "function") {
            let n = JSON.stringify(t);
            throw new Error(
              `<If> expects a function that constructs a DCGElement. You passed ${n}`,
            );
          }
          if (Hn(t)) {
            throw new Error(
              "<If> expects a function that constructs a DCGElement. You passed a constant",
            );
          }
          let o = () => !!e(), i = (n) => n ? t() : void 0;
          return this.createElement(ad, { key: o }, i);
        }
      };
    });
  function f5(r, e) {
    let t = nd(ad, {
      key: () => {
        let o = r();
        return o != null;
      },
    }, (o) => o ? e(r) : void 0);
    return t._viewName = "IfDefined", t;
  }
  var rfe,
    b5 = __dcg_shared_module_exports__["lazyDefine"](() => {
      rfe = __dcg_shared_module_exports__["defineDefaultExport"](ne());
      hf();
      jx();
    });
  function DS(r, e) {
    return typeof r == "string" ? y5.bind(this, r, e) : y5(void 0, r, e);
  }
  var afe,
    y5,
    oG = __dcg_shared_module_exports__["lazyDefine"](() => {
      afe = __dcg_shared_module_exports__["defineDefaultExport"](ne());
      hf();
      jx();
      y5 = (r, e, t) => {
        let o = nd(ad, {
          key() {
            let i = e();
            return r ? i && i[r] : i;
          },
        }, (i) => {
          let n = t[i];
          return n ? n(e) : void 0;
        });
        return o._viewName = "SwitchUnion", o;
      };
    });
  function x5(r, e) {
    let t = DS(() => r() ? "true" : "false", e);
    return t._viewName = "IfElse", t;
  }
  var dfe,
    w5 = __dcg_shared_module_exports__["lazyDefine"](() => {
      dfe = __dcg_shared_module_exports__["defineDefaultExport"](ne());
      oG();
    });
  var hfe,
    kS,
    v5 = __dcg_shared_module_exports__["lazyDefine"](() => {
      hfe = __dcg_shared_module_exports__["defineDefaultExport"](ne());
      id();
      kS = class extends qi {
        constructor() {
          super(...arguments), this._viewName = "Input";
        }
        computeValue() {
          let e = this.props.value();
          return e == null ? "" : `${e}`;
        }
        template() {
          let {
            value: e,
            onInput: t,
            onEnterPressed: o,
            disabled: i,
            readOnly: n,
          } = this.props;
          if (!e) throw new Error('<Input> expects a "value={}" prop');
          if (!t) throw new Error('<Input> expects an "onInput={}" prop');
          let a = {
            ...this.props,
            value: this.const(this.computeValue()),
            onInput: ((s) => {
              t(s.target.value), this._isMounted && this.update();
            }).bind(this),
          };
          return o && (a.onKeypress = (s) => {
            s.which === 13 && o();
          }),
            i && (a.disabled = () => i() ? true : void 0),
            n && (a.readOnly = () => n() ? true : void 0),
            a.hasOwnProperty("tabIndex") ||
            (a.tabIndex = () => i && i() ? "-1" : "0"),
            a.onMount = (s) => {
              this.rootDOM = s, this.props.onMount && this.props.onMount(s);
            },
            this.createElement("input", a);
        }
        didUpdate() {
          let e = this.computeValue();
          this.rootDOM.value !== e && (this.rootDOM.value = e);
        }
      };
    });
  var ffe,
    _S,
    C5 = __dcg_shared_module_exports__["lazyDefine"](() => {
      ffe = __dcg_shared_module_exports__["defineDefaultExport"](ne());
      id();
      _S = class extends qi {
        constructor() {
          super(...arguments), this._viewName = "Textarea";
        }
        computeValue() {
          let e = this.props.value();
          return e == null ? "" : `${e}`;
        }
        template() {
          let { value: e, onInput: t, disabled: o, readOnly: i } = this.props;
          if (!e) throw new Error('<Textarea> expects a "value={}" prop');
          if (!t) {
            throw new Error('<Textarea> expects an "onInput={}" prop');
          }
          let n = {
            ...this.props,
            onInput: ((a) => {
              this.props.onInput(a.target.value),
                this._isMounted && this.update();
            }).bind(this),
          };
          return o && (n.disabled = () => o() ? true : void 0),
            i && (n.readOnly = () => i() ? true : void 0),
            n.onMount = (a) => {
              this.rootDOM = a, this.props.onMount && this.props.onMount(a);
            },
            delete n.value,
            this.createElement(
              "textarea",
              n,
              this.const(this.computeValue()),
            );
        }
        didUpdate() {
          let e = this.computeValue();
          this.rootDOM.value !== e && (this.rootDOM.value = e);
        }
      };
    });
  var IS = {};
  __dcg_shared_module_exports__["defineProperties"](IS, {
    Checkbox: () => CS,
    Each: () => h5,
    For: () => wf,
    If: () => TS,
    IfDefined: () => f5,
    IfElse: () => x5,
    Input: () => kS,
    Switch: () => ad,
    SwitchUnion: () => DS,
    Textarea: () => _S,
  });
  var S5 = __dcg_shared_module_exports__["lazyDefine"](() => {
    a5();
    g5();
    tG();
    m5();
    b5();
    w5();
    v5();
    jx();
    oG();
    C5();
  });
  var iG = {};
  __dcg_shared_module_exports__["defineProperties"](iG, {
    Class: () => UQ,
    Components: () => IS,
    View: () => qi,
    _warn: () => fg,
    addCustomAttribute: () => pf,
    addWarningHandler: () => o5,
    const: () => fS,
    createElement: () => nd,
    isConst: () => Hn,
    mountToNode: () => p5,
    removeWarningHandler: () => i5,
    unmountFromNode: () => u5,
  });
  var UQ,
    nG = __dcg_shared_module_exports__["lazyDefine"](() => {
      BB();
      zB();
      KB();
      yS();
      id();
      S5();
      pc();
      hf();
      yS();
      ES();
      id();
      xS();
      UQ = qi;
      pf("style", HB);
      pf("class", NB);
      [
        "willMount",
        "onMount",
        "didMount",
        "willUnmount",
        "onUnmount",
        "didUnmount",
        "willUpdate",
        "onUpdate",
        "didUpdate",
      ].forEach((r) => pf(r, UB(r)));
    });
  var sd,
    E5 = __dcg_shared_module_exports__["lazyDefine"](() => {
      nG();
      nG();
      sd = iG;
    });
  function VS(r) {
    return r == null
      ? r + ""
      : typeof r == "object" || typeof r == "function"
      ? PS[O5.call(r)] || "object"
      : typeof r;
  }
  function aG(r) {
    var e = !!r && "length" in r && r.length, t = VS(r);
    return gp(r) || Tf(r) ? false : t === "array" || e === 0 ||
      typeof e == "number" && e > 0 && e - 1 in r;
  }
  function vf(r, e) {
    return r.nodeName && r.nodeName.toLowerCase() === e.toLowerCase();
  }
  function XQ(r, e) {
    return e.toUpperCase();
  }
  function pp(r) {
    return r.replace(jQ, "ms-").replace(YQ, XQ);
  }
  function Jx() {
    this.expando = le.expando + Jx.uid++;
  }
  function ZQ(r) {
    return r === "true"
      ? true
      : r === "false"
      ? false
      : r === "null"
      ? null
      : r === +r + ""
      ? +r
      : JQ.test(r)
      ? JSON.parse(r)
      : r;
  }
  function T5(r, e, t) {
    var o;
    if (t === void 0 && r.nodeType === 1) {
      if (
        o = "data-" + e.replace(QQ, "-$&").toLowerCase(),
          t = r.getAttribute(o),
          typeof t == "string"
      ) {
        try {
          t = ZQ(t);
        } catch (i) {}
        up.set(r, e, t);
      } else t = void 0;
    }
    return t;
  }
  function tZ(r, e, t, o) {
    var i,
      n,
      a = 20,
      s = o
        ? function () {
          return o.cur();
        }
        : function () {
          return le.css(r, e, "");
        },
      l = s(),
      c = t && t[3] || (le.cssNumber[e] ? "" : "px"),
      d = r.nodeType && (le.cssNumber[e] || c !== "px" && +l) &&
        OS.exec(le.css(r, e));
    if (d && d[3] !== c) {
      for (l = l / 2, c = c || d[3], d = +l || 1; a--;) {
        le.style(r, e, d + c),
          (1 - n) * (1 - (n = s() / l || .5)) <= 0 && (a = 0),
          d = d / n;
      }
      d = d * 2, le.style(r, e, d + c), t = t || [];
    }
    return t &&
      (d = +d || +l || 0,
        i = t[1] ? d + (t[1] + 1) * t[2] : +t[2],
        o && (o.unit = c, o.start = d, o.end = i)),
      i;
  }
  function Sf() {
    return true;
  }
  function Ef() {
    return false;
  }
  function rZ(r, e) {
    return r === oZ() == (e === "focus");
  }
  function oZ() {
    try {
      return En.activeElement;
    } catch (r) {}
  }
  function cG(r, e, t, o, i, n) {
    var a, s;
    if (typeof e == "object") {
      typeof t != "string" && (o = o || t, t = void 0);
      for (s in e) cG(r, s, t, o, e[s], n);
      return r;
    }
    if (
      o == null && i == null
        ? (i = t, o = t = void 0)
        : i == null && (typeof t == "string"
          ? (i = o, o = void 0)
          : (i = o, o = t, t = void 0)), i === false
    ) i = Ef;
    else if (!i) return r;
    return n === 1 && (a = i,
      i = function (l) {
        return le().off(l), a.apply(this, arguments);
      },
      i.guid = a.guid || (a.guid = le.guid++)),
      r.each(function () {
        le.event.add(this, e, i, o, t);
      });
  }
  function LS(r, e, t) {
    if (!t) {
      Qo.get(r, e) === void 0 && le.event.add(r, e, Sf);
      return;
    }
    Qo.set(r, e, false),
      le.event.add(r, e, {
        namespace: false,
        handler: function (o) {
          var i, n, a = Qo.get(this, e);
          if (o.isTrigger & 1 && this[e]) {
            if (a.length) {
              (le.event.special[e] || {}).delegateType &&
                o.stopPropagation();
            } else if (
              a = AS.call(arguments),
                Qo.set(this, e, a),
                i = t(this, e),
                this[e](),
                n = Qo.get(this, e),
                a !== n || i ? Qo.set(this, e, false) : n = {},
                a !== n
            ) {
              return o.stopImmediatePropagation(),
                o.preventDefault(),
                n && n.value;
            }
          } else {a.length &&
              (Qo.set(this, e, {
                value: le.event.trigger(
                  le.extend(a[0], le.Event.prototype),
                  a.slice(1),
                  this,
                ),
              }),
                o.stopImmediatePropagation());}
        },
      });
  }
  function Yx(r, e, t) {
    var o, i, n, a, s = r.style;
    return t = t || RS(r),
      t &&
      (a = t.getPropertyValue(e) || t[e],
        a === "" && !U5(r) && (a = le.style(r, e)),
        !Tn.pixelBoxStyles() && uG.test(a) && iZ.test(e) &&
        (o = s.width,
          i = s.minWidth,
          n = s.maxWidth,
          s.minWidth = s.maxWidth = s.width = a,
          a = t.width,
          s.width = o,
          s.minWidth = i,
          s.maxWidth = n)),
      a !== void 0 ? a + "" : a;
  }
  function q5(r, e) {
    return {
      get: function () {
        if (r()) {
          delete this.get;
          return;
        }
        return (this.get = e).apply(this, arguments);
      },
    };
  }
  function nZ(r) {
    for (var e = r[0].toUpperCase() + r.slice(1), t = k5.length; t--;) {
      if (r = k5[t] + e, r in H5) return r;
    }
  }
  function I5(r) {
    var e = le.cssProps[r] || _5[r];
    return e || (r in H5 ? r : _5[r] = nZ(r) || r);
  }
  function K5(r, e, t) {
    var o = OS.exec(e);
    return o ? Math.max(0, o[2] - (t || 0)) + (o[3] || "px") : e;
  }
  function dG(r, e, t, o, i, n) {
    var a = e === "width" ? 1 : 0, s = 0, l = 0;
    if (t === (o ? "border" : "content")) return 0;
    for (; a < 4; a += 2) {
      t === "margin" && (l += le.css(r, t + Tu[a], true, i)),
        o
          ? (t === "content" &&
            (l -= le.css(r, "padding" + Tu[a], true, i)),
            t !== "margin" &&
            (l -= le.css(r, "border" + Tu[a] + "Width", true, i)))
          : (l += le.css(r, "padding" + Tu[a], true, i),
            t !== "padding"
              ? l += le.css(r, "border" + Tu[a] + "Width", true, i)
              : s += le.css(r, "border" + Tu[a] + "Width", true, i));
    }
    return !o && n >= 0 &&
      (l += Math.max(
        0,
        Math.ceil(
          r["offset" + e[0].toUpperCase() + e.slice(1)] - n - l - s -
            .5,
        ),
      ) || 0),
      l;
  }
  function G5(r, e, t) {
    var o = RS(r),
      i = !Tn.boxSizingReliable() || t,
      n = i && le.css(r, "boxSizing", false, o) === "border-box",
      a = n,
      s = Yx(r, e, o),
      l = "offset" + e[0].toUpperCase() + e.slice(1);
    if (uG.test(s)) {
      if (!t) return s;
      s = "auto";
    }
    return (!Tn.boxSizingReliable() && n ||
      !Tn.reliableTrDimensions() && vf(r, "tr") || s === "auto" ||
      !parseFloat(s) && le.css(r, "display", false, o) === "inline") &&
      r.getClientRects().length &&
      (n = le.css(r, "boxSizing", false, o) === "border-box",
        a = l in r,
        a && (s = r[l])),
      s = parseFloat(s) || 0,
      s + dG(r, e, t || (n ? "border" : "content"), a, o, s) + "px";
  }
  function pG(r, e, t, o) {
    var i;
    if (Array.isArray(e)) {
      le.each(e, function (n, a) {
        t || lZ.test(r) ? o(r, a) : pG(
          r + "[" + (typeof a == "object" && a != null ? n : "") + "]",
          a,
          t,
          o,
        );
      });
    } else if (!t && VS(e) === "object") {
      for (i in e) pG(r + "[" + i + "]", e[i], t, o);
    } else o(r, e);
  }
  var hp,
    zQ,
    AS,
    qQ,
    V5,
    HQ,
    PS,
    O5,
    MS,
    R5,
    KQ,
    Tn,
    gp,
    Tf,
    En,
    F5,
    le,
    WQ,
    N5,
    $Q,
    lG,
    Xx,
    jQ,
    YQ,
    GS,
    Qo,
    up,
    JQ,
    QQ,
    B5,
    OS,
    Tu,
    Cf,
    U5,
    eZ,
    sG,
    D5,
    uG,
    RS,
    z5,
    iZ,
    k5,
    H5,
    _5,
    aZ,
    A5,
    sZ,
    M5,
    L5,
    P5,
    lZ,
    cZ,
    dZ,
    pZ,
    ee,
    qt = __dcg_shared_module_exports__["lazyDefine"](() => {
      "use strict";
      hp = [],
        zQ = Object.getPrototypeOf,
        AS = hp.slice,
        qQ = hp.flat
          ? function (r) {
            return hp.flat.call(r);
          }
          : function (r) {
            return hp.concat.apply([], r);
          },
        V5 = hp.push,
        HQ = hp.indexOf,
        PS = {},
        O5 = PS.toString,
        MS = PS.hasOwnProperty,
        R5 = MS.toString,
        KQ = R5.call(Object),
        Tn = {},
        gp = function (e) {
          return typeof e == "function" &&
            typeof e.nodeType != "number" && typeof e.item != "function";
        },
        Tf = function (e) {
          return e != null && e === e.window;
        },
        En = window.document;
      F5 = "3.6.0",
        le = function (r, e) {
          return new le.fn.init(r, e);
        };
      le.fn = le.prototype = {
        jquery: F5,
        constructor: le,
        length: 0,
        toArray: function () {
          return AS.call(this);
        },
        get: function (r) {
          return r == null
            ? AS.call(this)
            : r < 0
            ? this[r + this.length]
            : this[r];
        },
        pushStack: function (r) {
          var e = le.merge(this.constructor(), r);
          return e.prevObject = this, e;
        },
        each: function (r) {
          return le.each(this, r);
        },
        map: function (r) {
          return this.pushStack(le.map(this, function (e, t) {
            return r.call(e, t, e);
          }));
        },
        slice: function () {
          return this.pushStack(AS.apply(this, arguments));
        },
        first: function () {
          return this.eq(0);
        },
        last: function () {
          return this.eq(-1);
        },
        even: function () {
          return this.pushStack(le.grep(this, function (r, e) {
            return (e + 1) % 2;
          }));
        },
        odd: function () {
          return this.pushStack(le.grep(this, function (r, e) {
            return e % 2;
          }));
        },
        eq: function (r) {
          var e = this.length, t = +r + (r < 0 ? e : 0);
          return this.pushStack(t >= 0 && t < e ? [this[t]] : []);
        },
        end: function () {
          return this.prevObject || this.constructor();
        },
        push: V5,
        sort: hp.sort,
        splice: hp.splice,
      };
      le.extend = le.fn.extend = function () {
        var r,
          e,
          t,
          o,
          i,
          n,
          a = arguments[0] || {},
          s = 1,
          l = arguments.length,
          c = false;
        for (
          typeof a == "boolean" && (c = a, a = arguments[s] || {}, s++),
            typeof a != "object" && !gp(a) && (a = {}),
            s === l && (a = this, s--);
          s < l;
          s++
        ) {
          if ((r = arguments[s]) != null) {
            for (e in r) {
              o = r[e],
                !(e === "__proto__" || a === o) &&
                (c && o && (le.isPlainObject(o) || (i = Array.isArray(o)))
                  ? (t = a[e],
                    i && !Array.isArray(t)
                      ? n = []
                      : !i && !le.isPlainObject(t)
                      ? n = {}
                      : n = t,
                    i = false,
                    a[e] = le.extend(c, n, o))
                  : o !== void 0 && (a[e] = o));
            }
          }
        }
        return a;
      };
      le.extend({
        expando: "jQuery" + (F5 + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function (r) {
          throw new Error(r);
        },
        noop: function () {},
        isPlainObject: function (r) {
          var e, t;
          return !r || O5.call(r) !== "[object Object]"
            ? false
            : (e = zQ(r),
              e
                ? (t = MS.call(e, "constructor") && e.constructor,
                  typeof t == "function" && R5.call(t) === KQ)
                : true);
        },
        isEmptyObject: function (r) {
          var e;
          for (e in r) return false;
          return true;
        },
        each: function (r, e) {
          var t, o = 0;
          if (aG(r)) {
            for (
              t = r.length;
              o < t && e.call(r[o], o, r[o]) !== false;
              o++
            );
          } else for (o in r) if (e.call(r[o], o, r[o]) === false) break;
          return r;
        },
        makeArray: function (r, e) {
          var t = e || [];
          return r != null &&
            (aG(Object(r))
              ? le.merge(t, typeof r == "string" ? [r] : r)
              : V5.call(t, r)),
            t;
        },
        inArray: function (r, e, t) {
          return e == null ? -1 : HQ.call(e, r, t);
        },
        merge: function (r, e) {
          for (var t = +e.length, o = 0, i = r.length; o < t; o++) {
            r[i++] = e[o];
          }
          return r.length = i, r;
        },
        grep: function (r, e, t) {
          for (var o, i = [], n = 0, a = r.length, s = !t; n < a; n++) {
            o = !e(r[n], n), o !== s && i.push(r[n]);
          }
          return i;
        },
        map: function (r, e, t) {
          var o, i, n = 0, a = [];
          if (aG(r)) {
            for (o = r.length; n < o; n++) {
              i = e(r[n], n, t), i != null && a.push(i);
            }
          } else for (n in r) i = e(r[n], n, t), i != null && a.push(i);
          return qQ(a);
        },
        guid: 1,
        support: Tn,
      });
      typeof Symbol == "function" &&
        (le.fn[Symbol.iterator] = hp[Symbol.iterator]);
      le.each(
        "Boolean Number String Function Array Date RegExp Object Error Symbol"
          .split(" "),
        function (r, e) {
          PS["[object " + e + "]"] = e.toLowerCase();
        },
      );
      WQ = function (r) {
        var e,
          t,
          o,
          i,
          n,
          a,
          s,
          l = r.document,
          c = [],
          d = c.push,
          p = c.push,
          h = c.slice,
          u = /HTML$/i,
          f = /^[^{]+\{\s*\[native \w/,
          y = function () {
            o();
          };
        try {
          p.apply(c = h.call(l.childNodes), l.childNodes),
            c[l.childNodes.length].nodeType;
        } catch (v) {
          p = {
            apply: c.length
              ? function (w, S) {
                d.apply(w, h.call(S));
              }
              : function (w, S) {
                for (var k = w.length, _ = 0; w[k++] = S[_++];);
                w.length = k - 1;
              },
          };
        }
        function C() {}
        function E(v) {
          var w = i.createElement("fieldset");
          try {
            return !!v(w);
          } catch (S) {
            return false;
          } finally {
            w.parentNode && w.parentNode.removeChild(w), w = null;
          }
        }
        return e = C.support = {},
          t = C.isXML = function (v) {
            var w = v && v.namespaceURI,
              S = v && (v.ownerDocument || v).documentElement;
            return !u.test(w || S && S.nodeName || "HTML");
          },
          o = C.setDocument = function (v) {
            var w, S, k = v ? v.ownerDocument || v : l;
            return k == i || k.nodeType !== 9 || !k.documentElement ||
              (i = k,
                n = i.documentElement,
                a = !t(i),
                l != i && (S = i.defaultView) && S.top !== S &&
                (S.addEventListener
                  ? S.addEventListener("unload", y, false)
                  : S.attachEvent && S.attachEvent("onunload", y)),
                e.attributes = E(function (_) {
                  return _.className = "i", !_.getAttribute("className");
                }),
                e.getElementsByTagName = E(function (_) {
                  return _.appendChild(i.createComment("")),
                    !_.getElementsByTagName("*").length;
                }),
                w = f.test(n.compareDocumentPosition),
                s = w || f.test(n.contains)
                  ? function (_, A) {
                    var P = _.nodeType === 9 ? _.documentElement : _,
                      O = A && A.parentNode;
                    return _ === O ||
                      !!(O && O.nodeType === 1 && (P.contains
                        ? P.contains(O)
                        : _.compareDocumentPosition &&
                          _.compareDocumentPosition(O) & 16));
                  }
                  : function (_, A) {
                    if (A) {
                      for (; A = A.parentNode;) if (A === _) return true;
                    }
                    return false;
                  }),
              i;
          },
          C.contains = function (v, w) {
            return (v.ownerDocument || v) != i && o(v), s(v, w);
          },
          o(),
          e.sortDetached = E(function (v) {
            return v.compareDocumentPosition(
              i.createElement("fieldset"),
            ) & 1;
          }),
          C;
      }(window);
      le.contains = WQ.contains;
      $Q = le.fn.init = function (r, e, t) {
        if (!r) return this;
        if (t = t || N5, typeof r == "string") {
          throw new Error("$(string) implementation has been removed");
        }
        if (r.nodeType) return this[0] = r, this.length = 1, this;
        if (gp(r)) {
          throw new Error("$(function) implementation has been removed");
        }
        return le.makeArray(r, this);
      };
      $Q.prototype = le.fn;
      N5 = le(En);
      lG = /[^\x20\t\r\n\f]+/g,
        Xx = function (r, e, t, o, i, n, a) {
          var s = 0, l = r.length, c = t == null;
          if (VS(t) === "object") {
            i = true;
            for (s in t) Xx(r, e, s, t[s], true, n, a);
          } else if (
            o !== void 0 &&
            (i = true,
              gp(o) || (a = true),
              c &&
              (a ? (e.call(r, o), e = null) : (c = e,
                e = function (d, p, h) {
                  return c.call(le(d), h);
                })),
              e)
          ) {
            for (; s < l; s++) {
              e(r[s], t, a ? o : o.call(r[s], s, e(r[s], t)));
            }
          }
          return i ? r : c ? e.call(r) : l ? e(r[0], t) : n;
        },
        jQ = /^-ms-/,
        YQ = /-([a-z])/g;
      GS = function (r) {
        return r.nodeType === 1 || r.nodeType === 9 || !+r.nodeType;
      };
      Jx.uid = 1;
      Jx.prototype = {
        cache: function (r) {
          var e = r[this.expando];
          return e ||
            (e = {},
              GS(r) &&
              (r.nodeType
                ? r[this.expando] = e
                : Object.defineProperty(r, this.expando, {
                  value: e,
                  configurable: true,
                }))),
            e;
        },
        set: function (r, e, t) {
          var o, i = this.cache(r);
          if (typeof e == "string") i[pp(e)] = t;
          else for (o in e) i[pp(o)] = e[o];
          return i;
        },
        get: function (r, e) {
          return e === void 0
            ? this.cache(r)
            : r[this.expando] && r[this.expando][pp(e)];
        },
        access: function (r, e, t) {
          return e === void 0 || e && typeof e == "string" && t === void 0
            ? this.get(r, e)
            : (this.set(r, e, t), t !== void 0 ? t : e);
        },
        remove: function (r, e) {
          var t, o = r[this.expando];
          if (o !== void 0) {
            if (e !== void 0) {
              for (
                Array.isArray(e)
                  ? e = e.map(pp)
                  : (e = pp(e), e = e in o ? [e] : e.match(lG) || []),
                  t = e.length;
                t--;
              ) delete o[e[t]];
            }
            (e === void 0 || le.isEmptyObject(o)) &&
              (r.nodeType ? r[this.expando] = void 0 : delete r[this.expando]);
          }
        },
        hasData: function (r) {
          var e = r[this.expando];
          return e !== void 0 && !le.isEmptyObject(e);
        },
      };
      Qo = new Jx(),
        up = new Jx(),
        JQ = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        QQ = /[A-Z]/g;
      le.extend({
        hasData: function (r) {
          return up.hasData(r) || Qo.hasData(r);
        },
        data: function (r, e, t) {
          return up.access(r, e, t);
        },
        removeData: function (r, e) {
          up.remove(r, e);
        },
        _data: function (r, e, t) {
          return Qo.access(r, e, t);
        },
        _removeData: function (r, e) {
          Qo.remove(r, e);
        },
      });
      le.fn.extend({
        data: function (r, e) {
          var t, o, i, n = this[0], a = n && n.attributes;
          if (r === void 0) {
            if (
              this.length &&
              (i = up.get(n), n.nodeType === 1 && !Qo.get(n, "hasDataAttrs"))
            ) {
              for (t = a.length; t--;) {
                a[t] &&
                  (o = a[t].name,
                    o.indexOf("data-") === 0 &&
                    (o = pp(o.slice(5)), T5(n, o, i[o])));
              }
              Qo.set(n, "hasDataAttrs", true);
            }
            return i;
          }
          return typeof r == "object"
            ? this.each(function () {
              up.set(this, r);
            })
            : Xx(
              this,
              function (s) {
                var l;
                if (n && s === void 0) {
                  return l = up.get(n, r),
                    l !== void 0 || (l = T5(n, r), l !== void 0) ? l : void 0;
                }
                this.each(function () {
                  up.set(this, r, s);
                });
              },
              null,
              e,
              arguments.length > 1,
              null,
              true,
            );
        },
        removeData: function (r) {
          return this.each(function () {
            up.remove(this, r);
          });
        },
      });
      B5 = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        OS = new RegExp("^(?:([+-])=|)(" + B5 + ")([a-z%]*)$", "i"),
        Tu = ["Top", "Right", "Bottom", "Left"],
        Cf = En.documentElement,
        U5 = function (r) {
          return le.contains(r.ownerDocument, r);
        },
        eZ = { composed: true };
      Cf.getRootNode && (U5 = function (r) {
        return le.contains(r.ownerDocument, r) ||
          r.getRootNode(eZ) === r.ownerDocument;
      });
      sG = /^(?:checkbox|radio)$/i;
      (function () {
        var r = En.createDocumentFragment(),
          e = r.appendChild(En.createElement("div")),
          t = En.createElement("input");
        t.setAttribute("type", "radio"),
          t.setAttribute("checked", "checked"),
          t.setAttribute("name", "t"),
          e.appendChild(t),
          Tn.checkClone = e.cloneNode(true).cloneNode(true).lastChild.checked,
          e.innerHTML = "<textarea>x</textarea>",
          Tn.noCloneChecked = !!e.cloneNode(true).lastChild.defaultValue,
          e.innerHTML = "<option></option>",
          Tn.option = !!e.lastChild;
      })();
      D5 = /^([^.]*)(?:\.(.+)|)/;
      le.event = {
        global: {},
        add: function (r, e, t, o, i) {
          var n, a, s, l, c, d, p, h, u, f, y, C = Qo.get(r);
          if (GS(r)) {
            if (t.handler && (n = t, t = n.handler, i = n.selector), i) {
              throw new Error(
                "Support for event delegation has been removed",
              );
            }
            for (
              t.guid || (t.guid = le.guid++),
                (l = C.events) || (l = C.events = Object.create(null)),
                (a = C.handle) || (a = C.handle = function (E) {
                  return typeof le != "undefined" &&
                      le.event.triggered !== E.type
                    ? le.event.dispatch.apply(r, arguments)
                    : void 0;
                }),
                e = (e || "").match(lG) || [""],
                c = e.length;
              c--;
            ) {
              if (
                s = D5.exec(e[c]) || [],
                  u = y = s[1],
                  f = (s[2] || "").split(".").sort(),
                  !!u
              ) {
                if (
                  p = le.event.special[u] || {},
                    u = (i ? p.delegateType : p.bindType) || u,
                    p = le.event.special[u] || {},
                    d = le.extend({
                      type: u,
                      origType: y,
                      data: o,
                      handler: t,
                      guid: t.guid,
                      selector: i,
                      namespace: f.join("."),
                    }, n),
                    (h = l[u]) ||
                    (h = l[u] = [],
                      h.delegateCount = 0,
                      (!p.setup || p.setup.call(r, o, f, a) === false) &&
                      r.addEventListener && r.addEventListener(u, a)),
                    p.add &&
                    (p.add.call(r, d),
                      d.handler.guid || (d.handler.guid = t.guid)),
                    i
                ) {
                  throw new Error(
                    "Support for event delegation has been removed",
                  );
                }
                h.push(d), le.event.global[u] = true;
              }
            }
          }
        },
        remove: function (r, e, t, o, i) {
          var n,
            a,
            s,
            l,
            c,
            d,
            p,
            h,
            u,
            f,
            y,
            C = Qo.hasData(r) && Qo.get(r);
          if (!(!C || !(l = C.events))) {
            for (e = (e || "").match(lG) || [""], c = e.length; c--;) {
              if (
                s = D5.exec(e[c]) || [],
                  u = y = s[1],
                  f = (s[2] || "").split(".").sort(),
                  !u
              ) {
                for (u in l) le.event.remove(r, u + e[c], t, o, true);
                continue;
              }
              for (
                p = le.event.special[u] || {},
                  u = (o ? p.delegateType : p.bindType) || u,
                  h = l[u] || [],
                  s = s[2] &&
                    new RegExp(
                      "(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)",
                    ),
                  a = n = h.length;
                n--;
              ) {
                d = h[n],
                  (i || y === d.origType) && (!t || t.guid === d.guid) &&
                  (!s || s.test(d.namespace)) &&
                  (!o || o === d.selector || o === "**" && d.selector) &&
                  (h.splice(n, 1),
                    d.selector && h.delegateCount--,
                    p.remove && p.remove.call(r, d));
              }
              a && !h.length &&
                ((!p.teardown ||
                  p.teardown.call(r, f, C.handle) === false) &&
                  le.removeEvent(r, u, C.handle),
                  delete l[u]);
            }
            le.isEmptyObject(l) && Qo.remove(r, "handle events");
          }
        },
        dispatch: function (r) {
          var e,
            t,
            o,
            i,
            n,
            a,
            s = new Array(arguments.length),
            l = le.event.fix(r),
            c = (Qo.get(this, "events") || Object.create(null))[l.type] ||
              [],
            d = le.event.special[l.type] || {};
          for (s[0] = l, e = 1; e < arguments.length; e++) {
            s[e] = arguments[e];
          }
          if (
            l.delegateTarget = this,
              !(d.preDispatch && d.preDispatch.call(this, l) === false)
          ) {
            for (
              a = le.event.handlers.call(this, l, c), e = 0;
              (i = a[e++]) && !l.isPropagationStopped();
            ) {
              for (
                l.currentTarget = i.elem, t = 0;
                (n = i.handlers[t++]) &&
                !l.isImmediatePropagationStopped();
              ) {
                (!l.rnamespace || n.namespace === false ||
                  l.rnamespace.test(n.namespace)) &&
                  (l.handleObj = n,
                    l.data = n.data,
                    o = ((le.event.special[n.origType] || {}).handle ||
                      n.handler).apply(i.elem, s),
                    o !== void 0 && (l.result = o) === false &&
                    (l.preventDefault(), l.stopPropagation()));
              }
            }
            return d.postDispatch && d.postDispatch.call(this, l), l.result;
          }
        },
        handlers: function (r, e) {
          var t = [], o = e.delegateCount, i = r.target;
          if (o) {
            throw new Error(
              "Support for event delegtaion has been removed",
            );
          }
          return i = this,
            o < e.length && t.push({ elem: i, handlers: e.slice(o) }),
            t;
        },
        addProp: function (r, e) {
          Object.defineProperty(le.Event.prototype, r, {
            enumerable: true,
            configurable: true,
            get: gp(e)
              ? function () {
                if (this.originalEvent) return e(this.originalEvent);
              }
              : function () {
                if (this.originalEvent) return this.originalEvent[r];
              },
            set: function (t) {
              Object.defineProperty(this, r, {
                enumerable: true,
                configurable: true,
                writable: true,
                value: t,
              });
            },
          });
        },
        fix: function (r) {
          return r[le.expando] ? r : new le.Event(r);
        },
        special: {
          load: { noBubble: true },
          click: {
            setup: function (r) {
              var e = this || r;
              return sG.test(e.type) && e.click && vf(e, "input") &&
                LS(e, "click", Sf),
                false;
            },
            trigger: function (r) {
              var e = this || r;
              return sG.test(e.type) && e.click && vf(e, "input") &&
                LS(e, "click"),
                true;
            },
            _default: function (r) {
              var e = r.target;
              return sG.test(e.type) && e.click && vf(e, "input") &&
                  Qo.get(e, "click") || vf(e, "a");
            },
          },
          beforeunload: {
            postDispatch: function (r) {
              r.result !== void 0 && r.originalEvent &&
                (r.originalEvent.returnValue = r.result);
            },
          },
        },
      };
      le.removeEvent = function (r, e, t) {
        r.removeEventListener && r.removeEventListener(e, t);
      };
      le.Event = function (r, e) {
        if (!(this instanceof le.Event)) return new le.Event(r, e);
        r && r.type
          ? (this.originalEvent = r,
            this.type = r.type,
            this.isDefaultPrevented = r.defaultPrevented ||
                r.defaultPrevented === void 0 && r.returnValue === false
              ? Sf
              : Ef,
            this.target = r.target && r.target.nodeType === 3
              ? r.target.parentNode
              : r.target,
            this.currentTarget = r.currentTarget,
            this.relatedTarget = r.relatedTarget)
          : this.type = r,
          e && le.extend(this, e),
          this.timeStamp = r && r.timeStamp || Date.now(),
          this[le.expando] = true;
      };
      le.Event.prototype = {
        constructor: le.Event,
        isDefaultPrevented: Ef,
        isPropagationStopped: Ef,
        isImmediatePropagationStopped: Ef,
        isSimulated: false,
        preventDefault: function () {
          var r = this.originalEvent;
          this.isDefaultPrevented = Sf,
            r && !this.isSimulated && r.preventDefault();
        },
        stopPropagation: function () {
          var r = this.originalEvent;
          this.isPropagationStopped = Sf,
            r && !this.isSimulated && r.stopPropagation();
        },
        stopImmediatePropagation: function () {
          var r = this.originalEvent;
          this.isImmediatePropagationStopped = Sf,
            r && !this.isSimulated && r.stopImmediatePropagation(),
            this.stopPropagation();
        },
      };
      le.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        char: true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true,
      }, le.event.addProp);
      le.each({ focus: "focusin", blur: "focusout" }, function (r, e) {
        le.event.special[r] = {
          setup: function () {
            return LS(this, r, rZ), false;
          },
          trigger: function () {
            return LS(this, r), true;
          },
          _default: function () {
            return true;
          },
          delegateType: e,
        };
      });
      le.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout",
      }, function (r, e) {
        le.event.special[r] = {
          delegateType: e,
          bindType: e,
          handle: function (t) {
            var o, i = this, n = t.relatedTarget, a = t.handleObj;
            return (!n || n !== i && !le.contains(i, n)) &&
              (t.type = a.origType,
                o = a.handler.apply(this, arguments),
                t.type = e),
              o;
          },
        };
      });
      le.fn.extend({
        on: function (r, e, t, o) {
          return cG(this, r, e, t, o);
        },
        one: function (r, e, t, o) {
          return cG(this, r, e, t, o, 1);
        },
        off: function (r, e, t) {
          var o, i;
          if (r && r.preventDefault && r.handleObj) {
            return o = r.handleObj,
              le(r.delegateTarget).off(
                o.namespace ? o.origType + "." + o.namespace : o.origType,
                o.selector,
                o.handler,
              ),
              this;
          }
          if (typeof r == "object") {
            for (i in r) this.off(i, e, r[i]);
            return this;
          }
          return (e === false || typeof e == "function") &&
            (t = e, e = void 0),
            t === false && (t = Ef),
            this.each(function () {
              le.event.remove(this, r, t, e);
            });
        },
      });
      uG = new RegExp("^(" + B5 + ")(?!px)[a-z%]+$", "i"),
        RS = function (r) {
          var e = r.ownerDocument.defaultView;
          return (!e || !e.opener) && (e = window), e.getComputedStyle(r);
        },
        z5 = function (r, e, t) {
          var o, i, n = {};
          for (i in e) n[i] = r.style[i], r.style[i] = e[i];
          o = t.call(r);
          for (i in e) r.style[i] = n[i];
          return o;
        },
        iZ = new RegExp(Tu.join("|"), "i");
      (function () {
        function r() {
          if (c) {
            l.style.cssText =
              "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",
              c.style.cssText =
                "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",
              Cf.appendChild(l).appendChild(c);
            var d = window.getComputedStyle(c);
            t = d.top !== "1%",
              s = e(d.marginLeft) === 12,
              c.style.right = "60%",
              n = e(d.right) === 36,
              o = e(d.width) === 36,
              c.style.position = "absolute",
              i = e(c.offsetWidth / 3) === 12,
              Cf.removeChild(l),
              c = null;
          }
        }
        function e(d) {
          return Math.round(parseFloat(d));
        }
        var t,
          o,
          i,
          n,
          a,
          s,
          l = En.createElement("div"),
          c = En.createElement("div");
        c.style &&
          (c.style.backgroundClip = "content-box",
            c.cloneNode(true).style.backgroundClip = "",
            Tn.clearCloneStyle = c.style.backgroundClip === "content-box",
            le.extend(Tn, {
              boxSizingReliable: function () {
                return r(), o;
              },
              pixelBoxStyles: function () {
                return r(), n;
              },
              pixelPosition: function () {
                return r(), t;
              },
              reliableMarginLeft: function () {
                return r(), s;
              },
              scrollboxSize: function () {
                return r(), i;
              },
              reliableTrDimensions: function () {
                var d, p, h, u;
                return a == null &&
                  (d = En.createElement("table"),
                    p = En.createElement("tr"),
                    h = En.createElement("div"),
                    d.style.cssText =
                      "position:absolute;left:-11111px;border-collapse:separate",
                    p.style.cssText = "border:1px solid",
                    p.style.height = "1px",
                    h.style.height = "9px",
                    h.style.display = "block",
                    Cf.appendChild(d).appendChild(p).appendChild(h),
                    u = window.getComputedStyle(p),
                    a = parseInt(u.height, 10) +
                        parseInt(u.borderTopWidth, 10) +
                        parseInt(u.borderBottomWidth, 10) ===
                      p.offsetHeight,
                    Cf.removeChild(d)),
                  a;
              },
            }));
      })();
      k5 = ["Webkit", "Moz", "ms"], H5 = En.createElement("div").style, _5 = {};
      aZ = /^(none|table(?!-c[ea]).+)/,
        A5 = /^--/,
        sZ = {
          position: "absolute",
          visibility: "hidden",
          display: "block",
        },
        M5 = { letterSpacing: "0", fontWeight: "400" };
      le.extend({
        cssHooks: {
          opacity: {
            get: function (r, e) {
              if (e) {
                var t = Yx(r, "opacity");
                return t === "" ? "1" : t;
              }
            },
          },
        },
        cssNumber: {
          animationIterationCount: true,
          columnCount: true,
          fillOpacity: true,
          flexGrow: true,
          flexShrink: true,
          fontWeight: true,
          gridArea: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnStart: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowStart: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          widows: true,
          zIndex: true,
          zoom: true,
        },
        cssProps: {},
        style: function (r, e, t, o) {
          if (!(!r || r.nodeType === 3 || r.nodeType === 8 || !r.style)) {
            var i, n, a, s = pp(e), l = A5.test(e), c = r.style;
            if (
              l || (e = I5(s)),
                a = le.cssHooks[e] || le.cssHooks[s],
                t !== void 0
            ) {
              if (
                n = typeof t,
                  n === "string" && (i = OS.exec(t)) && i[1] &&
                  (t = tZ(r, e, i), n = "number"),
                  t == null || t !== t
              ) return;
              n === "number" && !l &&
              (t += i && i[3] || (le.cssNumber[s] ? "" : "px")),
                !Tn.clearCloneStyle && t === "" &&
                e.indexOf("background") === 0 && (c[e] = "inherit"),
                (!a || !("set" in a) ||
                  (t = a.set(r, t, o)) !== void 0) &&
                (l ? c.setProperty(e, t) : c[e] = t);
            } else {return a && "get" in a &&
                  (i = a.get(r, false, o)) !== void 0
                ? i
                : c[e];}
          }
        },
        css: function (r, e, t, o) {
          var i, n, a, s = pp(e), l = A5.test(e);
          return l || (e = I5(s)),
            a = le.cssHooks[e] || le.cssHooks[s],
            a && "get" in a && (i = a.get(r, true, t)),
            i === void 0 && (i = Yx(r, e, o)),
            i === "normal" && e in M5 && (i = M5[e]),
            t === "" || t
              ? (n = parseFloat(i), t === true || isFinite(n) ? n || 0 : i)
              : i;
        },
      });
      le.each(["height", "width"], function (r, e) {
        le.cssHooks[e] = {
          get: function (t, o, i) {
            if (o) {
              return aZ.test(le.css(t, "display")) &&
                  (!t.getClientRects().length ||
                    !t.getBoundingClientRect().width)
                ? z5(t, sZ, function () {
                  return G5(t, e, i);
                })
                : G5(t, e, i);
            }
          },
          set: function (t, o, i) {
            var n,
              a = RS(t),
              s = !Tn.scrollboxSize() && a.position === "absolute",
              l = s || i,
              c = l && le.css(t, "boxSizing", false, a) === "border-box",
              d = i ? dG(t, e, i, c, a) : 0;
            return c && s &&
              (d -= Math.ceil(
                t["offset" + e[0].toUpperCase() + e.slice(1)] -
                  parseFloat(a[e]) - dG(t, e, "border", false, a) - .5,
              )),
              d && (n = OS.exec(o)) && (n[3] || "px") !== "px" &&
              (t.style[e] = o, o = le.css(t, e)),
              K5(t, o, d);
          },
        };
      });
      le.cssHooks.marginLeft = q5(Tn.reliableMarginLeft, function (r, e) {
        if (e) {
          return (parseFloat(Yx(r, "marginLeft")) ||
            r.getBoundingClientRect().left -
              z5(r, { marginLeft: 0 }, function () {
                return r.getBoundingClientRect().left;
              })) + "px";
        }
      });
      le.each(
        { margin: "", padding: "", border: "Width" },
        function (r, e) {
          le.cssHooks[r + e] = {
            expand: function (t) {
              for (
                var o = 0,
                  i = {},
                  n = typeof t == "string" ? t.split(" ") : [t];
                o < 4;
                o++
              ) i[r + Tu[o] + e] = n[o] || n[o - 2] || n[0];
              return i;
            },
          }, r !== "margin" && (le.cssHooks[r + e].set = K5);
        },
      );
      le.fn.extend({
        css: function (r, e) {
          return Xx(
            this,
            function (t, o, i) {
              var n, a, s = {}, l = 0;
              if (Array.isArray(o)) {
                for (n = RS(t), a = o.length; l < a; l++) {
                  s[o[l]] = le.css(t, o[l], false, n);
                }
                return s;
              }
              return i !== void 0 ? le.style(t, o, i) : le.css(t, o);
            },
            r,
            e,
            arguments.length > 1,
          );
        },
      });
      (function () {
        var r = En.createElement("input"),
          e = En.createElement("select"),
          t = e.appendChild(En.createElement("option"));
        r.type = "checkbox",
          Tn.checkOn = r.value !== "",
          Tn.optSelected = t.selected,
          r = En.createElement("input"),
          r.value = "t",
          r.type = "radio",
          Tn.radioValue = r.value === "t";
      })();
      Tn.focusin = "onfocusin" in window;
      L5 = /^(?:focusinfocus|focusoutblur)$/,
        P5 = function (r) {
          r.stopPropagation();
        };
      le.extend(le.event, {
        trigger: function (r, e, t, o) {
          var i,
            n,
            a,
            s,
            l,
            c,
            d,
            p,
            h = [t || En],
            u = MS.call(r, "type") ? r.type : r,
            f = MS.call(r, "namespace") ? r.namespace.split(".") : [];
          if (
            n =
              p =
              a =
              t =
                t || En,
              !(t.nodeType === 3 || t.nodeType === 8) &&
              !L5.test(u + le.event.triggered) &&
              (u.indexOf(".") > -1 &&
                (f = u.split("."), u = f.shift(), f.sort()),
                l = u.indexOf(":") < 0 && "on" + u,
                r = r[le.expando]
                  ? r
                  : new le.Event(u, typeof r == "object" && r),
                r.isTrigger = o ? 2 : 3,
                r.namespace = f.join("."),
                r.rnamespace = r.namespace
                  ? new RegExp(
                    "(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)",
                  )
                  : null,
                r.result = void 0,
                r.target || (r.target = t),
                e = e == null ? [r] : le.makeArray(e, [r]),
                d = le.event.special[u] || {},
                !(!o && d.trigger && d.trigger.apply(t, e) === false))
          ) {
            if (!o && !d.noBubble && !Tf(t)) {
              for (
                s = d.delegateType || u, L5.test(s + u) || (n = n.parentNode);
                n;
                n = n.parentNode
              ) h.push(n), a = n;
              a === (t.ownerDocument || En) &&
                h.push(a.defaultView || a.parentWindow || window);
            }
            for (i = 0; (n = h[i++]) && !r.isPropagationStopped();) {
              p = n,
                r.type = i > 1 ? s : d.bindType || u,
                c = (Qo.get(n, "events") || Object.create(null))[r.type] &&
                  Qo.get(n, "handle"),
                c && c.apply(n, e),
                c = l && n[l],
                c && c.apply && GS(n) &&
                (r.result = c.apply(n, e),
                  r.result === false && r.preventDefault());
            }
            return r.type = u,
              !o && !r.isDefaultPrevented() &&
              (!d._default || d._default.apply(h.pop(), e) === false) &&
              GS(t) && l && gp(t[u]) && !Tf(t) &&
              (a = t[l],
                a && (t[l] = null),
                le.event.triggered = u,
                r.isPropagationStopped() && p.addEventListener(u, P5),
                t[u](),
                r.isPropagationStopped() && p.removeEventListener(u, P5),
                le.event.triggered = void 0,
                a && (t[l] = a)),
              r.result;
          }
        },
        simulate: function (r, e, t) {
          var o = le.extend(new le.Event(), t, {
            type: r,
            isSimulated: true,
          });
          le.event.trigger(o, null, e);
        },
      });
      le.fn.extend({
        trigger: function (r, e) {
          return this.each(function () {
            le.event.trigger(r, e, this);
          });
        },
        triggerHandler: function (r, e) {
          var t = this[0];
          if (t) return le.event.trigger(r, e, t, true);
        },
      });
      Tn.focusin ||
        le.each({ focus: "focusin", blur: "focusout" }, function (r, e) {
          var t = function (o) {
            le.event.simulate(e, o.target, le.event.fix(o));
          };
          le.event.special[e] = {
            setup: function () {
              var o = this.ownerDocument || this.document || this,
                i = Qo.access(o, e);
              i || o.addEventListener(r, t, true),
                Qo.access(o, e, (i || 0) + 1);
            },
            teardown: function () {
              var o = this.ownerDocument || this.document || this,
                i = Qo.access(o, e) - 1;
              i
                ? Qo.access(o, e, i)
                : (o.removeEventListener(r, t, true), Qo.remove(o, e));
            },
          };
        });
      lZ = /\[\]$/;
      le.param = function (r, e) {
        var t,
          o = [],
          i = function (n, a) {
            var s = gp(a) ? a() : a;
            o[o.length] = encodeURIComponent(n) + "=" +
              encodeURIComponent(s == null ? "" : s);
          };
        if (r == null) return "";
        if (Array.isArray(r) || r.jquery && !le.isPlainObject(r)) {
          le.each(r, function () {
            i(this.name, this.value);
          });
        } else for (t in r) pG(t, r[t], e, i);
        return o.join("&");
      };
      le.offset = {
        setOffset: function (r, e, t) {
          var o,
            i,
            n,
            a,
            s,
            l,
            c,
            d = le.css(r, "position"),
            p = le(r),
            h = {};
          d === "static" && (r.style.position = "relative"),
            s = p.offset(),
            n = le.css(r, "top"),
            l = le.css(r, "left"),
            c = (d === "absolute" || d === "fixed") &&
              (n + l).indexOf("auto") > -1,
            c
              ? (o = p.position(), a = o.top, i = o.left)
              : (a = parseFloat(n) || 0, i = parseFloat(l) || 0),
            gp(e) && (e = e.call(r, t, le.extend({}, s))),
            e.top != null && (h.top = e.top - s.top + a),
            e.left != null && (h.left = e.left - s.left + i),
            "using" in e ? e.using.call(r, h) : p.css(h);
        },
      };
      le.fn.extend({
        offset: function (r) {
          if (arguments.length) {
            return r === void 0 ? this : this.each(function (i) {
              le.offset.setOffset(this, r, i);
            });
          }
          var e, t, o = this[0];
          if (o) {
            return o.getClientRects().length
              ? (e = o.getBoundingClientRect(),
                t = o.ownerDocument.defaultView,
                {
                  top: e.top + t.pageYOffset,
                  left: e.left + t.pageXOffset,
                })
              : { top: 0, left: 0 };
          }
        },
        position: function () {
          if (this[0]) {
            var r, e, t, o = this[0], i = { top: 0, left: 0 };
            if (le.css(o, "position") === "fixed") {
              e = o.getBoundingClientRect();
            } else {
              for (
                e = this.offset(),
                  t = o.ownerDocument,
                  r = o.offsetParent || t.documentElement;
                r && (r === t.body || r === t.documentElement) &&
                le.css(r, "position") === "static";
              ) r = r.parentNode;
              r && r !== o && r.nodeType === 1 &&
                (i = le(r).offset(),
                  i.top += le.css(r, "borderTopWidth", true),
                  i.left += le.css(r, "borderLeftWidth", true));
            }
            return {
              top: e.top - i.top - le.css(o, "marginTop", true),
              left: e.left - i.left - le.css(o, "marginLeft", true),
            };
          }
        },
        offsetParent: function () {
          return this.map(function () {
            for (
              var r = this.offsetParent;
              r && le.css(r, "position") === "static";
            ) r = r.offsetParent;
            return r || Cf;
          });
        },
      });
      le.each(
        { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" },
        function (r, e) {
          var t = e === "pageYOffset";
          le.fn[r] = function (o) {
            return Xx(
              this,
              function (i, n, a) {
                var s;
                if (
                  Tf(i) ? s = i : i.nodeType === 9 && (s = i.defaultView),
                    a === void 0
                ) return s ? s[e] : i[n];
                s
                  ? s.scrollTo(
                    t ? s.pageXOffset : a,
                    t ? a : s.pageYOffset,
                  )
                  : i[n] = a;
              },
              r,
              o,
              arguments.length,
            );
          };
        },
      );
      le.each(["top", "left"], function (r, e) {
        le.cssHooks[e] = q5(Tn.pixelPosition, function (t, o) {
          if (o) {
            return o = Yx(t, e), uG.test(o) ? le(t).position()[e] + "px" : o;
          }
        });
      });
      le.each({ Height: "height", Width: "width" }, function (r, e) {
        le.each(
          { padding: "inner" + r, content: e, "": "outer" + r },
          function (t, o) {
            le.fn[o] = function (i, n) {
              var a = arguments.length && (t || typeof i != "boolean"),
                s = t || (i === true || n === true ? "margin" : "border");
              return Xx(
                this,
                function (l, c, d) {
                  var p;
                  return Tf(l)
                    ? o.indexOf("outer") === 0
                      ? l["inner" + r]
                      : l.document.documentElement["client" + r]
                    : l.nodeType === 9
                    ? (p = l.documentElement,
                      Math.max(
                        l.body["scroll" + r],
                        p["scroll" + r],
                        l.body["offset" + r],
                        p["offset" + r],
                        p["client" + r],
                      ))
                    : d === void 0
                    ? le.css(l, c, s)
                    : le.style(l, c, d, s);
                },
                e,
                a ? i : void 0,
                a,
              );
            };
          },
        );
      });
      le.fn.extend({
        bind: function (r, e, t) {
          return this.on(r, null, e, t);
        },
        unbind: function (r, e) {
          return this.off(r, null, e);
        },
        delegate: function (r, e, t, o) {
          return this.on(e, r, t, o);
        },
        undelegate: function (r, e, t) {
          return arguments.length === 1
            ? this.off(r, "**")
            : this.off(e, r || "**", t);
        },
        hover: function (r, e) {
          return this.mouseenter(r).mouseleave(e || r);
        },
      });
      le.each(
        "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu"
          .split(" "),
        function (r, e) {
          le.fn[e] = function (t, o) {
            return arguments.length > 0
              ? this.on(e, null, t, o)
              : this.trigger(e);
          };
        },
      );
      cZ = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
      le.isArray = Array.isArray;
      le.parseJSON = JSON.parse;
      le.nodeName = vf;
      le.isFunction = gp;
      le.isWindow = Tf;
      le.camelCase = pp;
      le.type = VS;
      le.now = Date.now;
      le.isNumeric = function (r) {
        var e = le.type(r);
        return (e === "number" || e === "string") &&
          !isNaN(r - parseFloat(r));
      };
      le.trim = function (r) {
        return r == null ? "" : (r + "").replace(cZ, "");
      };
      dZ = window.jQuery, pZ = window.$;
      le.noConflict = function (r) {
        return window.$ === le && (window.$ = pZ),
          r && window.jQuery === le && (window.jQuery = dZ),
          le;
      };
      typeof noGlobal == "undefined" && (window.jQuery = window.$ = le);
      ee = le;
    });
  var ne = __dcg_shared_module_exports__["defineModule"](($fe, W5) => {
    iB();
    mg();
    Ss();
    E5();
    qt();
    sd.addWarningHandler((r) => So(r));
    sd.addCustomAttribute("href", (r) => {
      let e = mS(r());
      return {
        value: `${mS(r())}`,
        bindings: {
          onMount(t) {
            if (!["a", "use"].includes(t.tagName.toLowerCase())) {
              throw new Error(
                "Cannot have an href on a non-link element.",
              );
            }
          },
          onUpdate(t) {
            let o = mS(r());
            e !== o && (e = o, t.setAttribute("href", o));
          },
        },
      };
    });
    sd.addCustomAttribute(
      "onTap",
      (r) => ({
        value: "",
        bindings: {
          onMount(e) {
            ee(e).on("dcg-tap", r);
          },
        },
      }),
    );
    sd.addCustomAttribute("onTapStart", (r) => ({
      bindings: {
        onMount(e) {
          ee(e).on("dcg-tapstart", r);
        },
      },
    }));
    sd.addCustomAttribute("onTapMove", (r) => ({
      bindings: {
        onMount(e) {
          ee(e).on("dcg-tapmove", r);
        },
      },
    }));
    sd.addCustomAttribute("onTapEnd", (r) => ({
      bindings: {
        onMount(e) {
          ee(e).on("dcg-tapend", r);
        },
      },
    }));
    sd.addCustomAttribute("onLongHold", (r) => ({
      bindings: {
        onMount(e) {
          ee(e).on("dcg-longhold", r);
        },
      },
    }));
    sd.addCustomAttribute("manageFocus", (r) =>
      r() === void 0 ? {} : {
        bindings: {
          onMount(e) {
            r().shouldBeFocused() && e.focus(),
              e.onfocus = function (t) {
                r().shouldBeFocused() || r().onFocusedChanged(true, t);
              },
              e.onblur = function (t) {
                r().shouldBeFocused() &&
                  t.target !== document.activeElement &&
                  r().onFocusedChanged(false, t);
              };
          },
          onUpdate(e) {
            let t = r().shouldBeFocused(),
              o = document.activeElement === e;
            t && !o ? e.focus() : o && !t && e.blur();
          },
          willUnmount(e) {
            e.onfocus = null, e.onblur = null;
          },
        },
      });
    W5.exports = sd;
  });
  var CU = __dcg_shared_module_exports__["defineModule"]((sw) => {
    var ht = sw && sw.__extends || function () {
        var r = function (e, t) {
          return r = Object.setPrototypeOf ||
            { __proto__: [] } instanceof Array && function (o, i) {
                o.__proto__ = i;
              } ||
            function (o, i) {
              for (
                var n in i
              ) {
                Object.prototype.hasOwnProperty.call(i, n) &&
                  (o[n] = i[n]);
              }
            },
            r(e, t);
        };
        return function (e, t) {
          if (typeof t != "function" && t !== null) {
            throw new TypeError(
              "Class extends value " + String(t) +
                " is not a constructor or null",
            );
          }
          r(e, t);
          function o() {
            this.constructor = e;
          }
          e.prototype = t === null
            ? Object.create(t)
            : (o.prototype = t.prototype, new o());
        };
      }(),
      YS = sw && sw.__assign || function () {
        return YS = Object.assign || function (r) {
          for (var e, t = 1, o = arguments.length; t < o; t++) {
            e = arguments[t];
            for (var i in e) {
              Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i]);
            }
          }
          return r;
        },
          YS.apply(this, arguments);
      };
    (function () {
      var r = -1, e = 1, t = Math.min, o = Math.max;
      function i() {}
      function n(D) {
        for (; D;) {
          if (!D.parent) return D;
          D = D.parent;
        }
      }
      function a(D, b, g) {
        if (!b) {
          var m = new Error("prayer failed: " + D);
          if (g) {
            var T = {};
            m.dcgExtraErrorMetaData = T;
            for (var G in g) {
              var B = g[G], H = T[G] = {};
              if (B) {
                H.localLatex = B.latex();
                var X = n(B);
                X && (H.rootLatex = X.latex());
              } else H.emptyNode = true;
            }
          }
          throw m;
        }
      }
      function s(D) {
        a("a direction was passed", D === r || D === e);
      }
      function l(D) {
        var b = document.implementation.createHTMLDocument("");
        if (b.body.innerHTML = D, b.body.children.length === 1) {
          return b.body.children[0];
        }
        for (
          var g = document.createDocumentFragment();
          b.body.firstChild;
        ) g.appendChild(b.body.firstChild);
        return g;
      }
      var c = function (b, g, m) {
        var T;
        switch (b) {
          case "svg":
          case "path":
            T = document.createElementNS("http://www.w3.org/2000/svg", b);
            break;
          default:
            T = document.createElement(b);
        }
        for (var G in g) {
          var B = g[G];
          B !== void 0 &&
            T.setAttribute(G, typeof B == "string" ? B : String(B));
        }
        if (m) { for (var H = 0; H < m.length; H++) T.appendChild(m[H]); }
        return T;
      };
      c.text = function (D) {
        return document.createTextNode(D);
      },
        c.block = function (D, b, g, m) {
          var T = [g.html()];
          m != null && m.beforeChild && T.unshift(m.beforeChild),
            m != null && m.afterChild && T.push(m.afterChild);
          var G = c(D, b, T);
          return g.setDOM(G), V.linkElementByBlockNode(G, g), G;
        },
        c.entityText = function (D) {
          var b = l(D);
          return a(
            "entity parses to a single text node",
            b instanceof DocumentFragment && b.childNodes.length === 1 &&
              b.childNodes[0] instanceof Text,
          ),
            b.childNodes[0];
        };
      function d(D, b) {
        var g, m;
        if (typeof (D == null ? void 0 : D.closest) == "function") {
          return D.closest(b);
        }
        if (!(D instanceof HTMLElement)) return null;
        var T = Element.prototype.matches ||
            Element.prototype.msMatchesSelector ||
            Element.prototype.webkitMatchesSelector,
          G = D;
        do {
          if (T.call(G, b)) return G;
          G = (m = (g = G == null ? void 0 : G.parentElement) !== null &&
                    g !== void 0
                  ? g
                  : G == null
                  ? void 0
                  : G.parentNode) !== null && m !== void 0
            ? m
            : null;
        } while (G !== null && G.nodeType === 1);
        return null;
      }
      var p = "\xA0",
        h = "\u200B",
        u = "\u02D9",
        f = "\u2211",
        y = "\u220F",
        C = "\u2210",
        E = "\u222B";
      function v(D) {
        return D.getClientRects().length ? D.getBoundingClientRect() : {
          top: 0,
          left: 0,
          height: 0,
          width: 0,
          x: 0,
          y: 0,
          bottom: 0,
          right: 0,
        };
      }
      function w() {
        return window.pageXOffset !== void 0
          ? window.pageXOffset
          : (document.documentElement || document.body.parentNode ||
            document.body).scrollLeft;
      }
      function S() {
        return window.pageYOffset !== void 0
          ? window.pageYOffset
          : (document.documentElement || document.body.parentNode ||
            document.body).scrollTop;
      }
      var k = function () {
          var D, b;
          return typeof requestAnimationFrame == "function" &&
              typeof cancelAnimationFrame == "function"
            ? (D = requestAnimationFrame, b = cancelAnimationFrame)
            : (D = function (g) {
              return setTimeout(g, 13);
            },
              b = clearTimeout),
            function (g, m) {
              var T = Date.now(), G, B = 0;
              function H() {
                var Oe = (Date.now() - T) / g;
                Oe <= B ? ge() : B = Oe, m(B, ge, X);
              }
              function X() {
                G !== void 0 && b(G), G = void 0;
              }
              function ge() {
                X(), G = D(H);
              }
              m(g <= 0 ? 1 : 0, ge, X);
            };
        }(),
        _ = function () {
          function D(b) {
            this.span = c("span", {
              class: "dcg-mq-aria-alert",
              "aria-live": "assertive",
              "aria-atomic": "true",
            }),
              this.msg = "",
              this.items = [],
              this.controller = b;
          }
          return D.prototype.attach = function () {
            var b = this.controller.container;
            this.span.parentNode !== b && P(b).prepend(P(this.span));
          },
            D.prototype.queue = function (b, g) {
              g === void 0 && (g = false);
              var m = "";
              if (b instanceof Dt) {
                var T = b.mathspeak({ ignoreShorthand: true });
                g &&
                (b.parent && b.parent.ariaLabel && b.ariaLabel === "block"
                  ? m = b.parent.ariaLabel + " " + T
                  : b.ariaLabel && (m = b.ariaLabel + " " + T)),
                  m === "" && (m = T);
              } else m = b || "";
              return this.items.push(m), this;
            },
            D.prototype.queueDirOf = function (b) {
              return s(b), this.queue(b === r ? "before" : "after");
            },
            D.prototype.queueDirEndOf = function (b) {
              return s(b), this.queue(b === r ? "beginning of" : "end of");
            },
            D.prototype.alert = function (b) {
              return this.attach(),
                b && this.queue(b),
                this.items.length &&
                (this.msg = this.items.join(" ").replace(/ +(?= )/g, "")
                  .trim(),
                  this.controller.containerHasFocus() &&
                  (this.controller.options.logAriaAlerts && this.msg &&
                    console.log(this.msg),
                    this.span.textContent = this.msg)),
                this.clear();
            },
            D.prototype.clear = function (b) {
              return this.items.length = 0,
                b != null && b.emptyContent &&
                (this.span.textContent = ""),
                this;
            },
            D;
        }(),
        A = function () {
          function D(b, g) {
            var m;
            arguments.length === 1 && (g = b),
              !(!b || !g) &&
              (this.ends = (m = {}, m[r] = b, m[e] = g, m));
          }
          return D.create = function (b, g) {
            arguments.length === 1 && (g = b),
              a("No half-empty DOMFragments", !!b == !!g);
            var m = new D(b, g);
            return a("last is a forward sibling of first", m.isValid()), m;
          },
            D.prototype.isEmpty = function () {
              return this.ends === void 0;
            },
            D.prototype.isOneNode = function () {
              return !!(this.ends && this.ends[r] === this.ends[e]);
            },
            D.prototype.isValid = function () {
              if (!this.ends || this.ends[r] === this.ends[e]) return true;
              var b;
              return this.eachNode(function (g) {
                return b = g;
              }),
                b === this.ends[e];
            },
            D.prototype.firstNode = function () {
              return a("Fragment is not empty", this.ends), this.ends[r];
            },
            D.prototype.lastNode = function () {
              return a("Fragment is not empty", this.ends), this.ends[e];
            },
            D.prototype.children = function () {
              var b = this.oneNode(), g = b.firstChild, m = b.lastChild;
              return g && m ? new D(g, m) : new D();
            },
            D.prototype.join = function (b) {
              if (!this.ends) return b;
              if (!b.ends) return this;
              for (var g = false, m = this.ends[e].nextSibling; m;) {
                if (m === b.ends[r]) {
                  g = true;
                  break;
                }
                m = m.nextSibling;
              }
              return a(
                "sibling must be a forward DOM sibling of this fragment",
                g,
              ),
                new D(this.ends[r], b.ends[e]);
            },
            D.prototype.oneNode = function () {
              return a(
                "Fragment has a single node",
                this.ends && this.ends[r] === this.ends[e],
              ),
                this.ends[r];
            },
            D.prototype.oneElement = function () {
              var b = this.oneNode();
              return a(
                "Node is an Element",
                b.nodeType === Node.ELEMENT_NODE,
              ),
                b;
            },
            D.prototype.oneText = function () {
              var b = this.oneNode();
              return a("Node is Text", b.nodeType === Node.TEXT_NODE), b;
            },
            D.prototype.eachNode = function (b) {
              if (!this.ends) return this;
              for (
                var g = this.ends[e], m = this.ends[r], T = void 0;
                m && (T = m.nextSibling, b(m), m !== g);
                m = T
              );
              return this;
            },
            D.prototype.eachElement = function (b) {
              return this.eachNode(function (g) {
                g.nodeType === Node.ELEMENT_NODE && b(g);
              }),
                this;
            },
            D.prototype.text = function () {
              var b = "";
              return this.eachNode(function (g) {
                b += g.textContent || "";
              }),
                b;
            },
            D.prototype.toNodeArray = function () {
              var b = [];
              return this.eachNode(function (g) {
                return b.push(g);
              }),
                b;
            },
            D.prototype.toElementArray = function () {
              var b = [];
              return this.eachElement(function (g) {
                return b.push(g);
              }),
                b;
            },
            D.prototype.toDocumentFragment = function () {
              var b = document.createDocumentFragment();
              return this.eachNode(function (g) {
                return b.appendChild(g);
              }),
                b;
            },
            D.prototype.insertBefore = function (b) {
              return this.insDirOf(r, b);
            },
            D.prototype.insertAfter = function (b) {
              return this.insDirOf(e, b);
            },
            D.prototype.append = function (b) {
              return b.appendTo(this.oneElement()), this;
            },
            D.prototype.prepend = function (b) {
              return b.prependTo(this.oneElement()), this;
            },
            D.prototype.appendTo = function (b) {
              return this.insAtDirEnd(e, b);
            },
            D.prototype.prependTo = function (b) {
              return this.insAtDirEnd(r, b);
            },
            D.prototype.parent = function () {
              if (!this.ends) return this;
              var b = this.ends[r].parentNode;
              return b ? new D(b) : new D();
            },
            D.prototype.wrapAll = function (b) {
              if (b.textContent = "", !this.ends) return this;
              var g = this.ends[r].parentNode,
                m = this.ends[e].nextSibling;
              return this.appendTo(b), g && g.insertBefore(b, m), this;
            },
            D.prototype.replaceWith = function (b) {
              var g,
                m = (g = this.ends) === null || g === void 0 ? void 0 : g[e],
                T = m == null ? void 0 : m.parentNode,
                G = m == null ? void 0 : m.nextSibling;
              this.detach();
              var B = b.toDocumentFragment();
              return !m || !T ? this : (T.insertBefore(B, G || null), this);
            },
            D.prototype.nthElement = function (b) {
              if (this.ends && !(b < 0 || b !== Math.floor(b))) {
                for (var g = this.ends[r]; g;) {
                  if (g.nodeType === Node.ELEMENT_NODE) {
                    if (b <= 0) {
                      return g;
                    }
                    b -= 1;
                  }
                  if (g === this.ends[e]) return;
                  g = g.nextSibling;
                }
              }
            },
            D.prototype.firstElement = function () {
              return this.nthElement(0);
            },
            D.prototype.lastElement = function () {
              if (this.ends) {
                for (var b = this.ends[e]; b;) {
                  if (b.nodeType === Node.ELEMENT_NODE) return b;
                  if (b === this.ends[r]) return;
                  b = b.previousSibling;
                }
              }
            },
            D.prototype.first = function () {
              return new D(this.firstElement());
            },
            D.prototype.last = function () {
              return new D(this.lastElement());
            },
            D.prototype.eq = function (b) {
              return new D(this.nthElement(b));
            },
            D.prototype.slice = function (b) {
              if (!this.ends) return this;
              var g = this.nthElement(b);
              return g ? new D(g, this.ends[e]) : new D();
            },
            D.prototype.next = function () {
              for (var b = this.oneNode(); b;) {
                if (
                  b = b.nextSibling, b && b.nodeType === Node.ELEMENT_NODE
                ) return new D(b);
              }
              return new D();
            },
            D.prototype.prev = function () {
              for (var b = this.oneNode(); b;) {
                if (
                  b = b.previousSibling, b && b.nodeType === Node.ELEMENT_NODE
                ) return new D(b);
              }
              return new D();
            },
            D.prototype.empty = function () {
              return this.eachElement(function (b) {
                b.textContent = "";
              }),
                this;
            },
            D.prototype.remove = function () {
              return this.toDocumentFragment(), this;
            },
            D.prototype.detach = function () {
              return this.remove();
            },
            D.prototype.insDirOf = function (b, g) {
              var m;
              if (!this.ends) return this;
              var T = (m = g.ends) === null || m === void 0 ? void 0 : m[b];
              return !T || !T.parentNode
                ? this.detach()
                : (O(b, T.parentNode, this.toDocumentFragment(), T), this);
            },
            D.prototype.insAtDirEnd = function (b, g) {
              return this.ends
                ? (U(b, this.toDocumentFragment(), g), this)
                : this;
            },
            D.prototype.hasClass = function (b) {
              var g = false;
              return this.eachElement(function (m) {
                m.classList.contains(b) && (g = true);
              }),
                g;
            },
            D.prototype.addClass = function (b) {
              for (
                var g = function (H) {
                    if (!H) return "continue";
                    m.eachElement(function (X) {
                      X.classList.add(H);
                    });
                  },
                  m = this,
                  T = 0,
                  G = b.split(/\s+/);
                T < G.length;
                T++
              ) {
                var B = G[T];
                g(B);
              }
              return this;
            },
            D.prototype.removeClass = function (b) {
              for (
                var g = function (H) {
                    if (!H) return "continue";
                    m.eachElement(function (X) {
                      X.classList.remove(H);
                    });
                  },
                  m = this,
                  T = 0,
                  G = b.split(/\s+/);
                T < G.length;
                T++
              ) {
                var B = G[T];
                g(B);
              }
              return this;
            },
            D.prototype.toggleClass = function (b, g) {
              if (g === true) return this.addClass(b);
              if (g === false) return this.removeClass(b);
              for (
                var m = function (X) {
                    if (!X) return "continue";
                    T.eachElement(function (ge) {
                      ge.classList.toggle(X);
                    });
                  },
                  T = this,
                  G = 0,
                  B = b.split(/\s+/);
                G < B.length;
                G++
              ) {
                var H = B[G];
                m(H);
              }
              return this;
            },
            D;
        }(),
        P = A.create;
      function O(D, b, g, m) {
        b.insertBefore(g, D === r ? m : m.nextSibling);
      }
      function U(D, b, g) {
        D === r ? g.insertBefore(b, g.firstChild) : g.appendChild(b);
      }
      var z = function () {
        function D(b, g, m) {
          this.init(b, g, m);
        }
        return D.prototype.init = function (b, g, m) {
          this.parent = b, this[r] = g, this[e] = m;
        },
          D.copy = function (b) {
            return new D(b.parent, b[r], b[e]);
          },
          D;
      }();
      function x(D, b) {
        var g = D[r];
        if (g) {
          var m = D[e];
          if (m) {
            for (m = m[e]; g !== m; g = g[e]) {
              var T = b(g);
              if (T === false) break;
            }
          }
        }
      }
      function L(D, b, g) {
        var m = D[r];
        if (!m) return b;
        var T = D[e];
        if (!T) return b;
        for (T = T[e]; m !== T; m = m[e]) b = g(b, m);
        return b;
      }
      var V = function () {
        function D() {
          var m;
          this[b] = 0,
            this[g] = 0,
            this.parent = 0,
            this.ends = (m = {}, m[r] = 0, m[e] = 0, m),
            this.id = D.uniqueNodeId();
        }
        D.uniqueNodeId = function () {
          return D.idCounter += 1;
        },
          D.getNodeOfElement = function (m) {
            if (m) {
              if (!m.nodeType) {
                throw new Error(
                  "must pass an Element to NodeBase.getNodeOfElement",
                );
              }
              var T = m;
              return T.mqBlockNode || T.mqCmdNode;
            }
          },
          D.linkElementByBlockNode = function (m, T) {
            m.mqBlockNode = T;
          },
          D.linkElementByCmdNode = function (m, T) {
            m.mqCmdNode = T;
          },
          D.prototype.setEnds = function (m) {
            this.ends = m,
              a(
                "No half-empty node ends",
                !!this.ends[r] == !!this.ends[e],
              );
          },
          D.prototype.getEnd = function (m) {
            return this.ends[m];
          },
          D.prototype.toString = function () {
            return "{{ MathQuill Node #" + this.id + " }}";
          },
          D.prototype.setDOM = function (m) {
            return m &&
              a(
                "DOM is an element or a text node",
                m.nodeType === Node.ELEMENT_NODE ||
                  m.nodeType === Node.TEXT_NODE,
              ),
              this._el = m,
              this;
          },
          D.prototype.domFrag = function () {
            return P(this._el);
          },
          D.prototype.createDir = function (m, T) {
            s(m);
            var G = this;
            return G.html(),
              G.domFrag().insDirOf(m, T.domFrag()),
              T[m] = G.adopt(T.parent, T[r], T[e]),
              G;
          },
          D.prototype.createLeftOf = function (m) {
            this.createDir(r, m);
          },
          D.prototype.selectChildren = function (m, T) {
            return new he(m, T);
          },
          D.prototype.bubble = function (m) {
            for (var T = this.getSelfNode(), G = T; G; G = G.parent) {
              var B = m(G);
              if (B === false) break;
            }
            return this;
          },
          D.prototype.postOrder = function (m) {
            var T = this.getSelfNode();
            return function G(B) {
              return B ? (B.eachChild(G), m(B), true) : false;
            }(T),
              T;
          },
          D.prototype.isEmpty = function () {
            return this.ends[r] === 0 && this.ends[e] === 0;
          },
          D.prototype.isQuietEmptyDelimiter = function (m) {
            if (
              !this.isEmpty() || !m || !this.parent ||
              this.parent.ctrlSeq === void 0
            ) return false;
            var T = this.parent.ctrlSeq.replace(/^\\(left|right)?/, "");
            return m.hasOwnProperty(T);
          },
          D.prototype.isStyleBlock = function () {
            return false;
          },
          D.prototype.isTextBlock = function () {
            return false;
          },
          D.prototype.children = function () {
            return new N(this.getEnd(r), this.getEnd(e));
          },
          D.prototype.eachChild = function (m) {
            return x(this.ends, m), this;
          },
          D.prototype.foldChildren = function (m, T) {
            return L(this.ends, m, T);
          },
          D.prototype.withDirAdopt = function (m, T, G, B) {
            var H = this.getSelfNode();
            return new N(H, H).withDirAdopt(m, T, G, B), this;
          },
          D.prototype.adopt = function (m, T, G) {
            var B = this.getSelfNode();
            return new N(B, B).adopt(m, T, G), this.getSelfNode();
          },
          D.prototype.disown = function () {
            var m = this.getSelfNode();
            return new N(m, m).disown(), this;
          },
          D.prototype.remove = function () {
            return this.domFrag().remove(), this.disown();
          },
          D.prototype.shouldIgnoreSubstitutionInSimpleSubscript = function (m) {
            var T = m.disableAutoSubstitutionInSubscripts;
            if (
              !T || !this.parent || !(this.parent.parent instanceof ac)
            ) return false;
            var G = this.parent.parent[r];
            return !(typeof T == "object" && G instanceof Zt &&
                G.endsWord && T.except[G.endsWord] ||
              !this.parent.domFrag().hasClass("dcg-mq-sub"));
          },
          D.prototype.getSelfNode = function () {
            return this;
          },
          D.prototype.parser = function () {
            a("Abstract parser() method is never called", false);
          },
          D.prototype.html = function () {
            throw new Error("html() unimplemented in NodeBase");
          },
          D.prototype.text = function () {
            return "";
          },
          D.prototype.latex = function () {
            var m = { latex: "", startIndex: -1, endIndex: -1 };
            return this.latexRecursive(m), m.latex;
          },
          D.prototype.latexRecursive = function (m) {},
          D.prototype.checkCursorContextOpen = function (m) {
            m.startSelectionBefore === this &&
            (m.startIndex = m.latex.length),
              m.endSelectionBefore === this &&
              (m.endIndex = m.latex.length);
          },
          D.prototype.checkCursorContextClose = function (m) {
            m.startSelectionAfter === this &&
            (m.startIndex = m.latex.length),
              m.endSelectionAfter === this &&
              (m.endIndex = m.latex.length);
          },
          D.prototype.finalizeTree = function (m, T) {},
          D.prototype.contactWeld = function (m, T) {},
          D.prototype.blur = function (m) {},
          D.prototype.focus = function () {},
          D.prototype.intentionalBlur = function () {},
          D.prototype.reflow = function () {},
          D.prototype.registerInnerField = function (m, T) {},
          D.prototype.chToCmd = function (m, T) {
            a("Abstract chToCmd() method is never called", false);
          },
          D.prototype.mathspeak = function (m) {
            return "";
          },
          D.prototype.seek = function (m, T) {},
          D.prototype.siblingDeleted = function (m, T) {},
          D.prototype.siblingCreated = function (m, T) {},
          D.prototype.finalizeInsert = function (m, T) {},
          D.prototype.fixDigitGrouping = function (m) {},
          D.prototype.writeLatex = function (m, T) {},
          D.prototype.write = function (m, T) {};
        var b, g;
        return b = r, g = e, D.idCounter = 0, D;
      }();
      function R(D, b, g) {
        a("a parent is always present", D),
          a(
            "leftward is properly set up",
            function () {
              return b ? b[e] === g && b.parent === D : D.getEnd(r) === g;
            }(),
            {
              parent: D,
              leftward: b,
              leftwardL: b && b[r],
              leftwardR: b && b[e],
              rightwardL: g && g[r],
              rightwardR: g && g[e],
            },
          ),
          a(
            "rightward is properly set up",
            function () {
              return g ? g[r] === b && g.parent === D : D.getEnd(e) === b;
            }(),
            {
              parent: D,
              rightward: g,
              leftwardL: b && b[r],
              leftwardR: b && b[e],
              rightwardL: g && g[r],
              rightwardR: g && g[e],
              rightwardParent: g && g.parent,
            },
          );
      }
      var N = function () {
          function D(b, g, m) {
            var T, G;
            if (
              this.disowned = false,
                m === void 0 && (m = r),
                s(m),
                a("no half-empty fragments", !b == !g, {
                  withDir: b,
                  oppDir: g,
                }),
                !b || !g
            ) {
              this.setEnds((T = {}, T[r] = 0, T[e] = 0, T));
              return;
            }
            a("withDir is passed to Fragment", b instanceof Dt),
              a("oppDir is passed to Fragment", g instanceof Dt),
              a(
                "withDir and oppDir have the same parent",
                b.parent === g.parent,
              );
            var B = (G = {}, G[m] = b, G[-m] = g, G);
            this.setEnds(B);
            var H = 0;
            this.each(function (X) {
              H = X;
            }),
              a(
                "following direction siblings from start reaches end",
                H === B[e],
              );
          }
          return D.prototype.getDOMFragFromEnds = function () {
            var b = this.ends[r], g = this.ends[e];
            return b === 0 || g === 0
              ? P()
              : b === g
              ? b.domFrag()
              : b.domFrag().join(g.domFrag());
          },
            D.prototype.setEnds = function (b) {
              this.ends = b;
            },
            D.prototype.getEnd = function (b) {
              return this.ends ? this.ends[b] : 0;
            },
            D.prototype.domFrag = function () {
              return this.getDOMFragFromEnds();
            },
            D.prototype.withDirAdopt = function (b, g, m, T) {
              return b === r ? this.adopt(g, m, T) : this.adopt(g, T, m);
            },
            D.prototype.adopt = function (b, g, m) {
              var T;
              R(b, g, m);
              var G = this;
              this.disowned = false;
              var B = G.ends[r];
              if (!B) return this;
              var H = G.ends[e];
              if (!H) return this;
              var X = (T = {}, T[r] = b.getEnd(r), T[e] = b.getEnd(e), T);
              return g || (X[r] = B),
                m ? m[r] = H : X[e] = H,
                b.setEnds(X),
                H[e] = m,
                G.each(function (ge) {
                  return ge[r] = g,
                    ge.parent = b,
                    g && (g[e] = ge),
                    g = ge,
                    true;
                }),
                G;
            },
            D.prototype.disown = function () {
              var b, g = this, m = g.ends[r];
              if (!m || g.disowned) return g;
              this.disowned = true;
              var T = g.ends[e];
              if (!T) return g;
              var G = m.parent;
              R(G, m[r], m), R(G, T, T[e]);
              var B = (b = {}, b[r] = G.getEnd(r), b[e] = G.getEnd(e), b);
              if (m[r]) {
                var H = m[r];
                H[e] = T[e];
              } else B[r] = T[e];
              if (T[e]) {
                var X = T[e];
                X[r] = m[r];
              } else B[e] = m[r];
              return B[r] && B[e] ? G.setEnds(B) : G.ends = B, g;
            },
            D.prototype.remove = function () {
              return this.domFrag().remove(), this.disown();
            },
            D.prototype.each = function (b) {
              return x(this.ends, b), this;
            },
            D.prototype.fold = function (b, g) {
              return L(this.ends, b, g);
            },
            D;
        }(),
        M = {},
        F = {};
      function Z(D) {
        return D && D.prototype instanceof Dt;
      }
      var te = function (D) {
          ht(b, D);
          function b(g, m, T) {
            var G = D.call(this, g, m, T) || this;
            return G.ancestors = {}, G;
          }
          return b.fromCursor = function (g) {
            return new b(g.parent, g[r], g[e]);
          },
            b;
        }(z),
        Y = function (D) {
          ht(b, D);
          function b(g, m, T) {
            var G = D.call(this, g, 0, 0) || this;
            return G.upDownCache = {},
              G.cursorElement = c("span", { class: "dcg-mq-cursor" }, [
                c.text(h),
              ]),
              G._domFrag = P(),
              G.controller = T,
              G.options = m,
              G.setDOMFrag(P(G.cursorElement)),
              G.blink = function () {
                P(G.cursorElement).toggleClass("dcg-mq-blink");
              },
              G;
          }
          return b.prototype.setDOMFrag = function (g) {
            return this._domFrag = g, this;
          },
            b.prototype.domFrag = function () {
              return this._domFrag;
            },
            b.prototype.show = function () {
              if (
                P(this.cursorElement).removeClass("dcg-mq-blink"),
                  this.setDOMFrag(P(this.cursorElement)),
                  this.intervalId
              ) clearInterval(this.intervalId);
              else {
                var g = this[e];
                if (g) {
                  var m = this.selection;
                  m && m.getEnd(r)[r] === this[r]
                    ? this.domFrag().insertBefore(m.domFrag())
                    : this.domFrag().insertBefore(g.domFrag());
                } else {this.domFrag().appendTo(
                    this.parent.domFrag().oneElement(),
                  );}
                this.parent.focus();
              }
              return this.intervalId = setInterval(this.blink, 500), this;
            },
            b.prototype.hide = function () {
              return this.intervalId && clearInterval(this.intervalId),
                this.intervalId = 0,
                this.domFrag().detach(),
                this.setDOMFrag(P()),
                this;
            },
            b.prototype.withDirInsertAt = function (g, m, T, G) {
              var B = this.parent;
              this.parent = m,
                this[g] = T,
                this[-g] = G,
                B !== m && B.blur && B.blur(this);
            },
            b.prototype.insDirOf = function (g, m) {
              return s(g),
                this.domFrag().insDirOf(g, m.domFrag()),
                this.withDirInsertAt(g, m.parent, m[g], m),
                this.parent.domFrag().addClass("dcg-mq-hasCursor"),
                this;
            },
            b.prototype.insLeftOf = function (g) {
              return this.insDirOf(r, g);
            },
            b.prototype.insRightOf = function (g) {
              return this.insDirOf(e, g);
            },
            b.prototype.insAtDirEnd = function (g, m) {
              return s(g),
                this.domFrag().insAtDirEnd(g, m.domFrag().oneElement()),
                this.withDirInsertAt(g, m, 0, m.getEnd(g)),
                m.focus(),
                this;
            },
            b.prototype.insAtLeftEnd = function (g) {
              return this.insAtDirEnd(r, g);
            },
            b.prototype.insAtRightEnd = function (g) {
              return this.insAtDirEnd(e, g);
            },
            b.prototype.jumpUpDown = function (g, m) {
              var T = this;
              T.upDownCache[g.id] = z.copy(T);
              var G = T.upDownCache[m.id];
              if (G) {
                var B = G[e];
                B ? T.insLeftOf(B) : T.insAtRightEnd(G.parent);
              } else {
                var H = T.getBoundingClientRectWithoutMargin().left;
                m.seek(H, T);
              }
              T.controller.aria.queue(m, true);
            },
            b.prototype.getBoundingClientRectWithoutMargin = function () {
              var g = this.domFrag();
              g.removeClass("dcg-mq-cursor");
              var m = v(g.oneElement()), T = m.left, G = m.right;
              return g.addClass("dcg-mq-cursor"), { left: T, right: G };
            },
            b.prototype.unwrapGramp = function () {
              var g = this.parent.parent,
                m = g.parent,
                T = g[e],
                G = this,
                B = g[r];
              if (
                g.disown().eachChild(function (Ie) {
                  return Ie.isEmpty() ||
                    (Ie.children().adopt(m, B, T).each(function (qe) {
                      return qe.domFrag().insertBefore(g.domFrag()), true;
                    }),
                      B = Ie.getEnd(e)),
                    true;
                }), !this[e]
              ) {
                var H = this[r];
                if (H) this[e] = H[e];
                else {for (; !this[e];) {
                    var X = this.parent[e];
                    if (X) this.parent = X, this[e] = X.getEnd(r);
                    else {
                      this[e] = g[e], this.parent = m;
                      break;
                    }
                  }}
              }
              var ge = this[e];
              ge ? this.insLeftOf(ge) : this.insAtRightEnd(m),
                g.domFrag().remove();
              var Oe = g[r], Ae = g[e];
              Oe && Oe.siblingDeleted(G.options, e),
                Ae && Ae.siblingDeleted(G.options, r);
            },
            b.prototype.startSelection = function () {
              for (
                var g = this.anticursor = te.fromCursor(this),
                  m = g.ancestors,
                  T = g;
                T.parent;
                T = T.parent
              ) m[T.parent.id] = T;
            },
            b.prototype.endSelection = function () {
              delete this.anticursor;
            },
            b.prototype.select = function () {
              var g, m = this.anticursor;
              if (this[r] === m[r] && this.parent === m.parent) return false;
              for (var T = this; T.parent; T = T.parent) {
                if (T.parent.id in m.ancestors) {
                  g = T.parent;
                  break;
                }
              }
              a("cursor and anticursor in the same tree", g);
              var G = g, B = m.ancestors[G.id], H, X, ge = e;
              if (T[r] !== B) {
                for (var Oe = T; Oe; Oe = Oe[e]) {
                  if (Oe[e] === B[e]) {
                    ge = r, H = T, X = B;
                    break;
                  }
                }
              }
              ge === e && (H = B, X = T),
                H instanceof z && (H = H[e]),
                X instanceof z && (X = X[r]),
                this.hide().selection = G.selectChildren(H, X);
              var Ae = this.selection.getEnd(ge);
              return this.insDirOf(ge, Ae), this.selectionChanged(), true;
            },
            b.prototype.resetToEnd = function (g) {
              this.clearSelection();
              var m = g.root;
              this[e] = 0, this[r] = m.getEnd(e), this.parent = m;
            },
            b.prototype.clearSelection = function () {
              return this.selection &&
                (this.selection.clear(),
                  delete this.selection,
                  this.selectionChanged()),
                this;
            },
            b.prototype.deleteSelection = function () {
              var g = this.selection;
              g &&
                (this[r] = g.getEnd(r)[r],
                  this[e] = g.getEnd(e)[e],
                  g.remove(),
                  this.selectionChanged(),
                  delete this.selection);
            },
            b.prototype.replaceSelection = function () {
              var g = this.selection;
              return g &&
                (this[r] = g.getEnd(r)[r],
                  this[e] = g.getEnd(e)[e],
                  delete this.selection),
                g;
            },
            b.prototype.depth = function () {
              for (var g = this, m = 0; g = g.parent;) {
                m += g instanceof Te ? 1 : 0;
              }
              return m;
            },
            b.prototype.isTooDeep = function (g) {
              return this.options.maxDepth !== void 0
                ? this.depth() + (g || 0) > this.options.maxDepth
                : false;
            },
            b.prototype.selectionChanged = function () {},
            b;
        }(z),
        he = function (D) {
          ht(b, D);
          function b(g, m, T) {
            var G = D.call(this, g, m, T) || this;
            return G._el = c("span", { class: "dcg-mq-selection" }),
              G.getDOMFragFromEnds().wrapAll(G._el),
              G;
          }
          return b.prototype.isCleared = function () {
            return this._el === void 0;
          },
            b.prototype.domFrag = function () {
              return this.isCleared() ? this.getDOMFragFromEnds() : P(this._el);
            },
            b.prototype.setEnds = function (g) {
              a("Selection ends are never empty", g[r] && g[e]), this.ends = g;
            },
            b.prototype.getEnd = function (g) {
              return this.ends[g];
            },
            b.prototype.adopt = function (g, m, T) {
              return this.clear(), D.prototype.adopt.call(this, g, m, T);
            },
            b.prototype.clear = function () {
              var g = this.getDOMFragFromEnds();
              return this.domFrag().replaceWith(g), this._el = void 0, this;
            },
            b.prototype.join = function (g, m) {
              return m === void 0 && (m = ""),
                this.fold("", function (T, G) {
                  return T + m + G[g]();
                });
            },
            b;
        }(N),
        se = function () {
          function D(b, g, m) {
            this.textareaEventListeners = {},
              this.id = b.id,
              this.data = {},
              this.root = b,
              this.container = g,
              this.options = m,
              this.aria = new _(this.getControllerSelf()),
              this.ariaLabel = "Math Input",
              this.ariaPostLabel = "",
              b.controller = this.getControllerSelf(),
              this.cursor = b.cursor = new Y(
                b,
                m,
                this.getControllerSelf(),
              );
          }
          return D.prototype.getControllerSelf = function () {
            return this;
          },
            D.prototype.handle = function (b, g) {
              var m,
                T = this.options.handlers,
                G = (m = this.options.handlers) === null || m === void 0
                  ? void 0
                  : m.fns[b];
              if (G) {
                var B = T == null ? void 0 : T.APIClasses[this.KIND_OF_MQ];
                a("APIClass is defined", B);
                var H = new B(this);
                g === r || g === e ? G(g, H) : G(H);
              }
            },
            D.onNotify = function (b) {
              D.notifyees.push(b);
            },
            D.prototype.notify = function (b) {
              for (var g = 0; g < D.notifyees.length; g += 1) {
                D.notifyees[g](this.cursor, b);
              }
              return this;
            },
            D.prototype.setAriaLabel = function (b) {
              var g = this.getAriaLabel();
              return b && typeof b == "string" && b !== ""
                ? this.ariaLabel = b
                : this.editable
                ? this.ariaLabel = "Math Input"
                : this.ariaLabel = "",
                this.ariaLabel !== g && !this.containerHasFocus() &&
                this.updateMathspeak(),
                this;
            },
            D.prototype.getAriaLabel = function () {
              return this.ariaLabel !== "Math Input"
                ? this.ariaLabel
                : this.editable
                ? "Math Input"
                : "";
            },
            D.prototype.setAriaPostLabel = function (b, g) {
              var m = this;
              return b && typeof b == "string" && b !== ""
                ? (b !== this.ariaPostLabel && typeof g == "number" &&
                  (this._ariaAlertTimeout &&
                    clearTimeout(this._ariaAlertTimeout),
                    this._ariaAlertTimeout = setTimeout(function () {
                      m.containerHasFocus()
                        ? m.aria.alert(
                          m.root.mathspeak().trim() + " " + b.trim(),
                        )
                        : m.updateMathspeak();
                    }, g)),
                  this.ariaPostLabel = b)
                : (this._ariaAlertTimeout &&
                  clearTimeout(this._ariaAlertTimeout),
                  this.ariaPostLabel = ""),
                this;
            },
            D.prototype.getAriaPostLabel = function () {
              return this.ariaPostLabel || "";
            },
            D.prototype.containerHasFocus = function () {
              return document.activeElement &&
                this.container.contains(document.activeElement);
            },
            D.prototype.getTextarea = function () {
              var b = this.textarea;
              return a("textarea initialized", b), b;
            },
            D.prototype.getTextareaSpan = function () {
              var b = this.textareaSpan;
              return a("textareaSpan initialized", b), b;
            },
            D.prototype.addTextareaEventListeners = function (b) {
              if (this.textarea) {
                for (var g in b) {
                  var m = g;
                  this.removeTextareaEventListener(m),
                    this.textarea.addEventListener(m, b[m]);
                }
              }
            },
            D.prototype.removeTextareaEventListener = function (b) {
              if (this.textarea) {
                var g = this.textareaEventListeners[b];
                g && this.textarea.removeEventListener(b, g);
              }
            },
            D.prototype.exportMathSpeak = function () {
              return this.root.mathspeak();
            },
            D.prototype.updateMathspeak = function (b) {},
            D.prototype.scrollHoriz = function () {},
            D.prototype.selectionChanged = function () {},
            D.prototype.setOverflowClasses = function () {},
            D.notifyees = [],
            D;
        }(),
        ae = {},
        q = {},
        oe = {
          handlers: true,
          autoCommands: true,
          quietEmptyDelimiters: true,
          autoParenthesizedFunctions: true,
          autoOperatorNames: true,
          infixOperatorNames: true,
          prefixOperatorNames: true,
          leftRightIntoCmdGoes: true,
          maxDepth: true,
          interpretTildeAsSim: true,
          disableAutoSubstitutionInSubscripts: true,
        },
        K = {},
        fe = function () {
          function D(b) {
            this.version = b;
          }
          return D.prototype.assertJquery = function () {
            return a(
              "Interface versions > 2 do not depend on JQuery",
              this.version <= 2,
            ),
              a("JQuery is set for interface v < 3", this.jQuery),
              this.jQuery;
          },
            D;
        }(),
        me = function () {
          function D() {}
          return D;
        }(),
        we = function () {
          window.console &&
            console.warn(
              `You are using the MathQuill API without specifying an interface version, which will fail in v1.0.0. Easiest fix is to do the following before doing anything else:

MathQuill = MathQuill.getInterface(1);
// now MathQuill.MathField() works like it used to

See also the "\`dev\` branch (2014\u20132015) \u2192 v0.10.0 Migration Guide" at
https://github.com/mathquill/mathquill/wiki/%60dev%60-branch-(2014%E2%80%932015)-%E2%86%92-v0.10.0-Migration-Guide`,
            );
        },
        Ce;
      function _e(D) {
        return we(), Ce || (Ce = W(1)), Ce(D);
      }
      _e.prototype = me.prototype,
        _e.VERSION = "vv1.10",
        _e.interfaceVersion = function (D) {
          if (D !== 1) {
            throw "Only interface version 1 supported. You specified: " +
              D;
          }
          return we = function () {
            window.console &&
              console.warn(
                `You called MathQuill.interfaceVersion(1); to specify the interface version, which will fail in v1.0.0. You can fix this easily by doing this before doing anything else:

MathQuill = MathQuill.getInterface(1);
// now MathQuill.MathField() works like it used to

See also the "\`dev\` branch (2014\u20132015) \u2192 v0.10.0 Migration Guide" at
https://github.com/mathquill/mathquill/wiki/%60dev%60-branch-(2014%E2%80%932015)-%E2%86%92-v0.10.0-Migration-Guide`,
              );
          },
            we(),
            _e;
        },
        _e.getInterface = W;
      var We = W.MIN = 1, $ = W.MAX = 3;
      function W(D) {
        if (D !== 1 && D !== 2 && D !== 3) {
          throw "Only interface versions between " + We + " and " + $ +
            " supported. You specified: " + D;
        }
        var b = D;
        if (b < 3) {
          var g = window.jQuery;
          if (!g) {
            throw "MathQuill interface version ".concat(
              b,
              " requires jQuery 1.5.2+ to be loaded first",
            );
          }
          fe.prototype.jQuery = g;
        }
        var m = YS(YS({}, K), {
          handlers: function (Ae) {
            return { fns: Ae || {}, APIClasses: X };
          },
        });
        function T(Ae, Ie) {
          for (var qe in Ie) {
            if (Ie.hasOwnProperty(qe)) {
              if (qe === "substituteKeyboardEvents" && b >= 3) {
                throw new Error(
                  [
                    "As of interface version 3, the 'substituteKeyboardEvents'",
                    "option is no longer supported. Use 'overrideTypedText' and",
                    "'overrideKeystroke' instead.",
                  ].join(" "),
                );
              }
              var He = Ie[qe], lt = m[qe];
              Ae[qe] = lt ? lt(He) : He;
            }
          }
        }
        var G = b < 3 ? fe : function (Ae) {
            ht(Ie, Ae);
            function Ie() {
              return Ae !== null && Ae.apply(this, arguments) || this;
            }
            return Ie;
          }(fe),
          B = function (Ae) {
            ht(Ie, Ae);
            function Ie(qe) {
              var He = Ae.call(this) || this;
              return He.__controller = qe,
                He.__options = qe.options,
                He.id = qe.id,
                He.data = qe.data,
                He;
            }
            return Ie.prototype.mathquillify = function (qe) {
              var He = this.__controller, lt = He.root, gt = He.container;
              He.createTextarea();
              var At = P(gt).addClass(qe).children().detach();
              lt.setDOM(
                P(c("span", {
                  class: "dcg-mq-root-block",
                  "aria-hidden": true,
                })).appendTo(gt).oneElement(),
              ),
                V.linkElementByBlockNode(lt.domFrag().oneElement(), lt),
                this.latex(At.text()),
                this.revert = function () {
                  return He.removeMouseEventListener(),
                    P(gt).removeClass(
                      "dcg-mq-editable-field dcg-mq-math-mode dcg-mq-text-mode",
                    ).empty().append(At),
                    b < 3 ? this.__options.assertJquery()(gt) : gt;
                };
            },
              Ie.prototype.setAriaLabel = function (qe) {
                return this.__controller.setAriaLabel(qe), this;
              },
              Ie.prototype.getAriaLabel = function () {
                return this.__controller.getAriaLabel();
              },
              Ie.prototype.config = function (qe) {
                return T(this.__options, qe), this;
              },
              Ie.prototype.el = function () {
                return this.__controller.container;
              },
              Ie.prototype.text = function () {
                return this.__controller.exportText();
              },
              Ie.prototype.mathspeak = function () {
                return this.__controller.exportMathSpeak();
              },
              Ie.prototype.latex = function (qe) {
                if (arguments.length > 0) {
                  this.__controller.renderLatexMath(qe);
                  var He = this.__controller.cursor;
                  return this.__controller.blurred &&
                    He.hide().parent.blur(He),
                    this;
                }
                return this.__controller.exportLatex();
              },
              Ie.prototype.selection = function () {
                return this.__controller.exportLatexSelection();
              },
              Ie.prototype.html = function () {
                return this.__controller.root.domFrag().oneElement()
                  .innerHTML.replace(/ jQuery\d+="(?:\d+|null)"/g, "")
                  .replace(/ mathquill-(?:command|block)-id="?\d+"?/g, "")
                  .replace(
                    /<span class="?dcg-mq-cursor( dcg-mq-blink)?"?>.?<\/span>/i,
                    "",
                  ).replace(/ dcg-mq-hasCursor|dcg-mq-hasCursor ?/, "")
                  .replace(/ class=(""|(?= |>))/g, "");
              },
              Ie.prototype.reflow = function () {
                return this.__controller.root.postOrder(function (qe) {
                  qe.reflow();
                }),
                  this;
              },
              Ie.prototype.focus = function () {
                return this.__controller.getTextarea().focus(),
                  this.__controller.editable &&
                  this.__controller.scrollHoriz(),
                  this;
              },
              Ie.prototype.blur = function () {
                return this.__controller.getTextarea().blur(), this;
              },
              Ie;
          }(me),
          H = function (Ae) {
            ht(Ie, Ae);
            function Ie() {
              return Ae !== null && Ae.apply(this, arguments) || this;
            }
            return Ie.prototype.mathquillify = function (qe) {
              return Ae.prototype.mathquillify.call(this, qe),
                this.__controller.editable = true,
                this.__controller.addMouseEventListener(),
                this.__controller.editablesTextareaEvents(),
                this;
            },
              Ie.prototype.select = function () {
                return this.__controller.selectAll(), this;
              },
              Ie.prototype.clearSelection = function () {
                return this.__controller.cursor.clearSelection(), this;
              },
              Ie.prototype.write = function (qe) {
                this.__controller.writeLatex(qe),
                  this.__controller.scrollHoriz();
                var He = this.__controller.cursor;
                return this.__controller.blurred &&
                  He.hide().parent.blur(He),
                  this;
              },
              Ie.prototype.empty = function () {
                var qe,
                  He = this.__controller.root,
                  lt = this.__controller.cursor;
                return He.setEnds((qe = {}, qe[r] = 0, qe[e] = 0, qe)),
                  He.domFrag().empty(),
                  delete lt.selection,
                  lt.insAtRightEnd(He),
                  this;
              },
              Ie.prototype.cmd = function (qe) {
                var He = this.__controller.notify(void 0), lt = He.cursor;
                if (/^\\[a-z]+$/i.test(qe) && !lt.isTooDeep()) {
                  qe = qe.slice(1);
                  var gt = M[qe], At;
                  gt &&
                    (gt.constructor ? At = new gt(qe) : At = gt(qe),
                      lt.selection && At.replaces(lt.replaceSelection()),
                      At.createLeftOf(lt.show()));
                } else lt.parent.write(lt, qe);
                return He.scrollHoriz(),
                  He.blurred && lt.hide().parent.blur(lt),
                  this;
              },
              Ie.prototype.moveToDirEnd = function (qe) {
                return this.__controller.notify("move").cursor
                  .insAtDirEnd(qe, this.__controller.root),
                  this;
              },
              Ie.prototype.moveToLeftEnd = function () {
                return this.moveToDirEnd(r);
              },
              Ie.prototype.moveToRightEnd = function () {
                return this.moveToDirEnd(e);
              },
              Ie.prototype.keystroke = function (qe, He) {
                for (
                  var lt = qe.replace(/^\s+|\s+$/g, "").split(/\s+/),
                    gt = 0;
                  gt < lt.length;
                  gt += 1
                ) this.__controller.keystroke(lt[gt], He);
                return this;
              },
              Ie.prototype.typedText = function (qe) {
                for (var He = 0; He < qe.length; He += 1) {
                  this.__controller.typedText(qe.charAt(He));
                }
                return this;
              },
              Ie.prototype.dropEmbedded = function (qe, He, lt) {
                var gt = qe - w(),
                  At = He - S(),
                  Gr = document.elementFromPoint(gt, At);
                this.__controller.seek(Gr, gt, At);
                var wn = new WR().setOptions(lt);
                wn.createLeftOf(this.__controller.cursor);
              },
              Ie.prototype.setAriaPostLabel = function (qe, He) {
                return this.__controller.setAriaPostLabel(qe, He), this;
              },
              Ie.prototype.getAriaPostLabel = function () {
                return this.__controller.getAriaPostLabel();
              },
              Ie.prototype.clickAt = function (qe, He, lt) {
                lt = lt || document.elementFromPoint(qe, He);
                var gt = this.__controller,
                  At = gt.root,
                  Gr = At.domFrag().oneElement();
                return Gr.contains(lt) || (lt = Gr),
                  gt.seek(lt, qe, He),
                  gt.blurred && this.focus(),
                  this;
              },
              Ie.prototype.ignoreNextMousedown = function (qe) {
                return this.__controller.cursor.options
                  .ignoreNextMousedown = qe,
                  this;
              },
              Ie;
          }(B),
          X = { AbstractMathQuill: B, EditableField: H };
        a("API.StaticMath defined", ae.StaticMath),
          X.StaticMath = ae.StaticMath(X),
          a("API.MathField defined", ae.MathField),
          X.MathField = ae.MathField(X),
          a("API.InnerMathField defined", ae.InnerMathField),
          X.InnerMathField = ae.InnerMathField(X),
          ae.TextField && (X.TextField = ae.TextField(X));
        var ge = function (Ae) {
          if (!Ae || !Ae.nodeType) return null;
          for (
            var Ie,
              qe = P(Ae).children().toElementArray(),
              He = 0,
              lt = qe;
            He < lt.length;
            He++
          ) {
            var gt = lt[He];
            if (gt.classList.contains("dcg-mq-root-block")) {
              Ie = gt;
              break;
            }
          }
          var At = V.getNodeOfElement(Ie),
            Gr = At && At.controller,
            wn = Gr && X[Gr.KIND_OF_MQ];
          return Gr && wn ? new wn(Gr) : null;
        };
        ge.L = r,
          ge.R = e,
          ge.config = function (Ae) {
            return T(G.prototype, Ae), this;
          },
          ge.registerEmbed = function (Ae, Ie) {
            if (!/^[a-z][a-z0-9]*$/i.test(Ae)) {
              throw "Embed name must start with letter and be only letters and digits";
            }
            q[Ae] = Ie;
          },
          ge.StaticMath = Oe("StaticMath", X.StaticMath),
          ge.MathField = Oe("MathField", X.MathField),
          ge.InnerMathField = Oe("InnerMathField", X.InnerMathField),
          X.TextField && (ge.TextField = Oe("TextField", X.TextField)),
          ge.prototype = B.prototype,
          ge.EditableField = function () {
            throw "wtf don't call me, I'm 'abstract'";
          },
          ge.EditableField.prototype = H.prototype,
          b < 3 && (ge.saneKeyboardEvents = Bn);
        function Oe(Ae, Ie) {
          a(Ae + " is defined", Ie);
          function qe(He, lt) {
            if (!He || !He.nodeType) return null;
            var gt = ge(He);
            if (gt instanceof Ie) return gt;
            var At = new co(new Ie.RootBlock(), He, new G(b));
            return At.KIND_OF_MQ = Ae, new Ie(At).__mathquillify(lt || {}, b);
          }
          return qe.prototype = Ie.prototype, qe;
        }
        return ge;
      }
      _e.noConflict = function () {
        return window.MathQuill = ue, _e;
      };
      var ue = window.MathQuill;
      window.MathQuill = _e;
      function Ee(D) {
        D.moveOutOf = function (b) {
          a("controller is defined", this.controller),
            this.controller.handle("moveOutOf", b);
        },
          D.deleteOutOf = function (b) {
            a("controller is defined", this.controller),
              this.controller.handle("deleteOutOf", b);
          },
          D.selectOutOf = function (b) {
            a("controller is defined", this.controller),
              this.controller.handle("selectOutOf", b);
          },
          D.upOutOf = function () {
            a("controller is defined", this.controller),
              this.controller.handle("upOutOf");
          },
          D.downOutOf = function () {
            a("controller is defined", this.controller),
              this.controller.handle("downOutOf");
          },
          D.reflow = function () {
            a("controller is defined", this.controller),
              this.controller.handle("reflow"),
              this.controller.handle("edited"),
              this.controller.handle("edit");
          };
      }
      function Be(D, b) {
        throw D ? D = "'" + D + "'" : D = "EOF",
          "Parse Error: " + b + " at " + D;
      }
      var ce = function () {
          function D(b) {
            this._ = b;
          }
          return D.prototype.parse = function (b) {
            return this.skip(D.eof)._("" + b, g, Be);
            function g(m, T) {
              return T;
            }
          },
            D.prototype.or = function (b) {
              a("or is passed a parser", b instanceof D);
              var g = this;
              return new D(function (m, T, G) {
                return g._(m, T, B);
                function B(H) {
                  return b._(m, T, G);
                }
              });
            },
            D.prototype.then = function (b) {
              var g = this;
              return new D(function (m, T, G) {
                return g._(m, B, G);
                function B(H, X) {
                  var ge = b instanceof D ? b : b(X);
                  return a("a parser is returned", ge instanceof D),
                    ge._(H, T, G);
                }
              });
            },
            D.prototype.many = function () {
              var b = this;
              return new D(function (g, m, T) {
                for (var G = []; b._(g, B, H););
                return m(g, G);
                function B(X, ge) {
                  return g = X, G.push(ge), true;
                }
                function H() {
                  return false;
                }
              });
            },
            D.prototype.times = function (b, g) {
              arguments.length < 2 && (g = b);
              var m = this;
              return new D(function (T, G, B) {
                for (var H = [], X = true, ge, Oe = 0; Oe < b; Oe += 1) {
                  if (X = !!m._(T, Ae, Ie), !X) return B(T, ge);
                }
                for (; Oe < g && X; Oe += 1) m._(T, Ae, qe);
                return G(T, H);
                function Ae(He, lt) {
                  return H.push(lt), T = He, true;
                }
                function Ie(He, lt) {
                  return ge = lt, T = He, false;
                }
                function qe(He, lt) {
                  return false;
                }
              });
            },
            D.prototype.result = function (b) {
              return this.then(D.succeed(b));
            },
            D.prototype.atMost = function (b) {
              return this.times(0, b);
            },
            D.prototype.atLeast = function (b) {
              var g = this;
              return g.times(b).then(function (m) {
                return g.many().map(function (T) {
                  return m.concat(T);
                });
              });
            },
            D.prototype.map = function (b) {
              return this.then(function (g) {
                return D.succeed(b(g));
              });
            },
            D.prototype.skip = function (b) {
              return this.then(function (g) {
                return b.result(g);
              });
            },
            D.string = function (b) {
              var g = b.length, m = "expected '" + b + "'";
              return new D(function (T, G, B) {
                var H = T.slice(0, g);
                return H === b ? G(T.slice(g), H) : B(T, m);
              });
            },
            D.regex = function (b) {
              a(
                "regexp parser is anchored",
                b.toString().charAt(1) === "^",
              );
              var g = "expected " + b;
              return new D(function (m, T, G) {
                var B = b.exec(m);
                if (B) {
                  var H = B[0];
                  return T(m.slice(H.length), H);
                } else return G(m, g);
              });
            },
            D.succeed = function (b) {
              return new D(function (g, m) {
                return m(g, b);
              });
            },
            D.fail = function (b) {
              return new D(function (g, m, T) {
                return T(g, b);
              });
            },
            D.letter = D.regex(/^[a-z]/i),
            D.letters = D.regex(/^[a-z]*/i),
            D.digit = D.regex(/^[0-9]/),
            D.digits = D.regex(/^[0-9]*/),
            D.whitespace = D.regex(/^\s+/),
            D.optWhitespace = D.regex(/^\s*/),
            D.any = new D(function (b, g, m) {
              return b
                ? g(b.slice(1), b.charAt(0))
                : m(b, "expected any character");
            }),
            D.all = new D(function (b, g, m) {
              return g("", b);
            }),
            D.eof = new D(function (b, g, m) {
              return b ? m(b, "expected EOF") : g(b, b);
            }),
            D;
        }(),
        ot = function () {
          function D() {
            this.fn = i;
          }
          return D.prototype.listen = function (b) {
            this.fn = b,
              clearTimeout(this.timeoutId),
              this.timeoutId = setTimeout(this.fn);
          },
            D.prototype.listenOnce = function (b) {
              var g = this;
              this.listen(function () {
                for (var m = [], T = 0; T < arguments.length; T++) {
                  m[T] = arguments[T];
                }
                g.clearListener(), b.apply(void 0, m);
              });
            },
            D.prototype.clearListener = function () {
              this.fn = i, clearTimeout(this.timeoutId);
            },
            D.prototype.trigger = function () {
              for (var b = [], g = 0; g < arguments.length; g++) {
                b[g] = arguments[g];
              }
              this.fn.apply(this, b);
            },
            D;
        }(),
        it = function () {
          var D = {
              8: "Backspace",
              9: "Tab",
              10: "Enter",
              13: "Enter",
              16: "Shift",
              17: "Control",
              18: "Alt",
              20: "CapsLock",
              27: "Esc",
              32: "Spacebar",
              33: "PageUp",
              34: "PageDown",
              35: "End",
              36: "Home",
              37: "Left",
              38: "Up",
              39: "Right",
              40: "Down",
              45: "Insert",
              46: "Del",
              144: "NumLock",
            },
            b = {
              ArrowRight: "Right",
              ArrowLeft: "Left",
              ArrowDown: "Down",
              ArrowUp: "Up",
              Delete: "Del",
              Escape: "Esc",
              " ": "Spacebar",
            };
          function g(B) {
            switch (T(B)) {
              case "Right":
              case "Left":
              case "Down":
              case "Up":
                return true;
            }
            return false;
          }
          function m(B) {
            return B.length === 1 && B >= "a" && B <= "z";
          }
          function T(B) {
            var H;
            if (B.key === void 0) {
              var X = B.which || B.keyCode;
              return D[X] || String.fromCharCode(X);
            }
            return m(B.key)
              ? B.key.toUpperCase()
              : (H = b[B.key]) !== null && H !== void 0
              ? H
              : B.key;
          }
          function G(B) {
            var H = T(B), X = [];
            return B.ctrlKey && X.push("Ctrl"),
              B.metaKey && X.push("Meta"),
              B.altKey && X.push("Alt"),
              B.shiftKey && X.push("Shift"),
              X.length
                ? (H !== "Alt" && H !== "Control" && H !== "Meta" &&
                  H !== "Shift" && X.push(H),
                  X.join("-"))
                : H;
          }
          return function (H, X) {
            var ge = null, Oe = null, Ae = new ot();
            function Ie() {
              try {
                H instanceof HTMLTextAreaElement && H.select();
              } catch (Lr) {}
            }
            function qe(Lr) {
              Ae.trigger(),
                Ae.clearListener(),
                H instanceof HTMLTextAreaElement && (H.value = Lr),
                Lr && Ie(),
                He = !!Lr;
            }
            var He = false;
            function lt() {
              return !("selectionStart" in H) ||
                  !(H instanceof HTMLTextAreaElement)
                ? false
                : H.selectionStart !== H.selectionEnd;
            }
            function gt() {
              X.options && X.options.overrideKeystroke
                ? X.options.overrideKeystroke(G(ge), ge)
                : X.keystroke(G(ge), ge);
            }
            function At(Lr) {
              Ae.trigger(Lr),
                Lr.target === H &&
                (ge = Lr,
                  Oe = null,
                  He && Ae.listenOnce(function (sc) {
                    sc && sc.type === "focusout" || Ie();
                  }),
                  gt());
            }
            function Gr(Lr) {
              Ae.trigger(Lr),
                Lr.target === H &&
                (ge && Oe && gt(),
                  Oe = Lr,
                  g(Lr) ? Ae.listenOnce(xi) : Ae.listen($r));
            }
            function wn(Lr) {
              Ae.trigger(Lr),
                Lr.target === H && ge && !Oe &&
                (g(Lr) ? Ae.listenOnce(xi) : Ae.listen($r));
            }
            function $r() {
              if (!lt() && H instanceof HTMLTextAreaElement) {
                var Lr = H.value;
                ge &&
                    (ge.key === "Unidentified" ||
                      !ge.altKey && ge.ctrlKey && !ge.metaKey &&
                        ge.shiftKey &&
                        (ge.key === "U" || ge.key === "Process")) ||
                  (Lr.length === 1
                    ? (H.value = "",
                      X.options && X.options.overrideTypedText
                        ? X.options.overrideTypedText(Lr)
                        : X.typedText(Lr))
                    : xi());
              }
            }
            function xi() {
              H instanceof HTMLTextAreaElement && H.value.length > 1 &&
                Ie();
            }
            function js() {
              ge = null,
                Oe = null,
                Ae.clearListener(),
                H instanceof HTMLTextAreaElement && (H.value = "");
            }
            function El(Lr) {
              Ae.trigger(),
                Lr.target === H &&
                (document.activeElement !== H && H.focus(),
                  Ae.listen(function () {
                    if (H instanceof HTMLTextAreaElement) {
                      var ys = H.value;
                      H.value = "", ys && X.paste(ys);
                    }
                  }));
            }
            function zh(Lr) {
              Ae.trigger(Lr);
            }
            return X.KIND_OF_MQ === "StaticMath"
              ? (X.addTextareaEventListeners({
                keydown: function (Lr) {
                  var sc, ys;
                  (ys = (sc = X.options).overrideKeystroke) === null ||
                    ys === void 0 || ys.call(sc, G(Lr), Lr);
                },
              }),
                { select: qe })
              : (X.options && X.options.disableCopyPaste
                ? X.addTextareaEventListeners({
                  keydown: At,
                  keypress: Gr,
                  keyup: wn,
                  focusout: js,
                  copy: function (Lr) {
                    Lr.preventDefault();
                  },
                  cut: function (Lr) {
                    Lr.preventDefault();
                  },
                  paste: function (Lr) {
                    Ae.trigger(), Lr.preventDefault();
                  },
                  input: zh,
                })
                : X.addTextareaEventListeners({
                  keydown: At,
                  keypress: Gr,
                  keyup: wn,
                  focusout: js,
                  cut: function () {
                    Ae.listenOnce(function () {
                      X.cut();
                    });
                  },
                  copy: function () {
                    Ae.listenOnce(function () {
                      X.copy();
                    });
                  },
                  paste: El,
                  input: zh,
                }),
                { select: qe });
          };
        }(),
        Se = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.exportText = function () {
            return this.root.foldChildren("", function (g, m) {
              return g + m.text();
            });
          },
            b;
        }(se);
      se.onNotify(function (D, b) {
        if (b === "edit" || b === "replace" || b === void 0) {
          var g = D.controller;
          if (!g || !g.options.enableDigitGrouping || g.blurred !== false) {
            return;
          }
          g.disableGroupingForSeconds(1);
        }
      });
      var Lt = function (D) {
          ht(b, D);
          function b() {
            var g = D !== null && D.apply(this, arguments) || this;
            return g.handleTextareaFocusEditable = function () {
              var m = g.cursor;
              g.updateMathspeak(),
                g.blurred = false,
                clearTimeout(g.blurTimeout),
                P(g.container).addClass("dcg-mq-focused"),
                m.parent || m.insAtRightEnd(g.root),
                m.selection
                  ? (m.selection.domFrag().removeClass("dcg-mq-blur"),
                    g.selectionChanged())
                  : m.show(),
                g.setOverflowClasses();
            },
              g.handleTextareaBlurEditable = function () {
                g.textareaSelectionTimeout &&
                (clearTimeout(g.textareaSelectionTimeout),
                  g.textareaSelectionTimeout = 0),
                  g.disableGroupingForSeconds(0),
                  g.blurred = true,
                  g.blurTimeout = setTimeout(function () {
                    g.root.postOrder(function (m) {
                      m.intentionalBlur();
                    }),
                      g.cursor.clearSelection().endSelection(),
                      g.blur(),
                      g.updateMathspeak({ emptyContent: true }),
                      g.scrollHoriz();
                  }),
                  window.addEventListener("blur", g.handleWindowBlur);
              },
              g.handleTextareaFocusStatic = function () {
                g.cursor.selection || g.cursor.controller.selectAll(),
                  g.blurred = false;
              },
              g.handleTextareaBlurStatic = function () {
                g.cursor.clearSelection(),
                  g.updateMathspeak({ emptyContent: true });
              },
              g.handleWindowBlur = function () {
                clearTimeout(g.blurTimeout),
                  g.cursor.selection &&
                  g.cursor.selection.domFrag().addClass("dcg-mq-blur"),
                  g.blurWithoutResettingCursor(),
                  g.updateMathspeak({ emptyContent: true });
              },
              g;
          }
          return b.prototype.disableGroupingForSeconds = function (g) {
            var m = this;
            clearTimeout(this.__disableGroupingTimeout),
              g === 0
                ? this.root.domFrag().removeClass(
                  "dcg-mq-suppress-grouping",
                )
                : (this.root.domFrag().addClass(
                  "dcg-mq-suppress-grouping",
                ),
                  this.__disableGroupingTimeout = setTimeout(function () {
                    m.root.domFrag().removeClass(
                      "dcg-mq-suppress-grouping",
                    );
                  }, g * 1e3));
          },
            b.prototype.blur = function () {
              this.blurWithoutResettingCursor(),
                this.options && this.options.resetCursorOnBlur &&
                this.cursor.resetToEnd(this);
            },
            b.prototype.blurWithoutResettingCursor = function () {
              this.cursor.hide().parent.blur(this.cursor),
                P(this.container).removeClass("dcg-mq-focused"),
                window.removeEventListener("blur", this.handleWindowBlur);
            },
            b.prototype.addEditableFocusBlurListeners = function () {
              var g = this, m = g.cursor;
              this.addTextareaEventListeners({
                focus: this.handleTextareaFocusEditable,
                blur: this.handleTextareaBlurEditable,
              }),
                g.blurred = true,
                m.hide().parent.blur(m);
            },
            b.prototype.addStaticFocusBlurListeners = function () {
              this.addTextareaEventListeners({
                focus: this.handleTextareaFocusStatic,
                blur: this.handleTextareaBlurStatic,
              });
            },
            b;
        }(Se),
        It = false,
        Dt = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.keystroke = function (g, m, T) {
            var G = T.cursor;
            switch (g) {
              case "Ctrl-Shift-Backspace":
              case "Ctrl-Backspace":
                T.ctrlDeleteDir(r);
                break;
              case "Shift-Backspace":
              case "Backspace":
                T.backspace();
                break;
              case "Esc":
              case "Tab":
                T.escapeDir(e, g, m);
                return;
              case "Shift-Tab":
              case "Shift-Esc":
                T.escapeDir(r, g, m);
                return;
              case "End":
                T.notify("move").cursor.insAtRightEnd(G.parent),
                  T.aria.queue("end of").queue(G.parent, true);
                break;
              case "Ctrl-End":
                T.notify("move").cursor.insAtRightEnd(T.root),
                  T.aria.queue("end of").queue(T.ariaLabel).queue(T.root)
                    .queue(T.ariaPostLabel);
                break;
              case "Shift-End":
                T.selectToBlockEndInDir(e);
                break;
              case "Ctrl-Shift-End":
                T.selectToRootEndInDir(e);
                break;
              case "Home":
                T.notify("move").cursor.insAtLeftEnd(G.parent),
                  T.aria.queue("beginning of").queue(G.parent, true);
                break;
              case "Ctrl-Home":
                T.notify("move").cursor.insAtLeftEnd(T.root),
                  T.aria.queue("beginning of").queue(T.ariaLabel).queue(
                    T.root,
                  ).queue(T.ariaPostLabel);
                break;
              case "Shift-Home":
                T.selectToBlockEndInDir(r);
                break;
              case "Ctrl-Shift-Home":
                T.selectToRootEndInDir(r);
                break;
              case "Left":
                T.moveLeft();
                break;
              case "Shift-Left":
                T.selectLeft();
                break;
              case "Ctrl-Left":
                break;
              case "Right":
                T.moveRight();
                break;
              case "Shift-Right":
                T.selectRight();
                break;
              case "Ctrl-Right":
                break;
              case "Up":
                T.moveUp();
                break;
              case "Down":
                T.moveDown();
                break;
              case "Shift-Up":
                T.withIncrementalSelection(function (B) {
                  if (G[r]) { for (; G[r];) B(r); }
                  else B(r);
                });
                break;
              case "Shift-Down":
                T.withIncrementalSelection(function (B) {
                  if (G[e]) { for (; G[e];) B(e); }
                  else B(e);
                });
                break;
              case "Ctrl-Up":
                break;
              case "Ctrl-Down":
                break;
              case "Ctrl-Shift-Del":
              case "Ctrl-Del":
                T.ctrlDeleteDir(e);
                break;
              case "Shift-Del":
              case "Del":
                T.deleteForward();
                break;
              case "Meta-A":
              case "Ctrl-A":
                T.selectAll();
                break;
              case "Ctrl-Alt-Up":
                G.parent.parent && G.parent.parent instanceof b
                  ? T.aria.queue(G.parent.parent)
                  : T.aria.queue("nothing above");
                break;
              case "Ctrl-Alt-Down":
                G.parent && G.parent instanceof b
                  ? T.aria.queue(G.parent)
                  : T.aria.queue("block is empty");
                break;
              case "Ctrl-Alt-Left":
                G.parent.parent && G.parent.parent.getEnd(r)
                  ? T.aria.queue(G.parent.parent.getEnd(r))
                  : T.aria.queue("nothing to the left");
                break;
              case "Ctrl-Alt-Right":
                G.parent.parent && G.parent.parent.getEnd(e)
                  ? T.aria.queue(G.parent.parent.getEnd(e))
                  : T.aria.queue("nothing to the right");
                break;
              case "Ctrl-Alt-Shift-Down":
                G.selection
                  ? T.aria.queue(
                    G.selection.join("mathspeak", " ").trim() +
                      " selected",
                  )
                  : T.aria.queue("nothing selected");
                break;
              case "Ctrl-Alt-=":
              case "Ctrl-Alt-Shift-Right":
                T.ariaPostLabel.length
                  ? T.aria.queue(T.ariaPostLabel)
                  : T.aria.queue("no answer");
                break;
              default:
                return;
            }
            T.aria.alert(), m == null || m.preventDefault(), T.scrollHoriz();
          },
            b.prototype.moveOutOf = function (g, m, T) {
              a("overridden or never called on this node", false);
            },
            b.prototype.moveTowards = function (g, m, T) {
              a("overridden or never called on this node", false);
            },
            b.prototype.deleteOutOf = function (g, m) {
              a("overridden or never called on this node", false);
            },
            b.prototype.deleteTowards = function (g, m) {
              a("overridden or never called on this node", false);
            },
            b.prototype.unselectInto = function (g, m) {
              a("overridden or never called on this node", false);
            },
            b.prototype.selectOutOf = function (g, m) {
              a("overridden or never called on this node", false);
            },
            b.prototype.selectTowards = function (g, m) {
              a("overridden or never called on this node", false);
            },
            b;
        }(V);
      se.onNotify(function (D, b) {
        (b === "move" || b === "upDown") && D.show().clearSelection();
      }),
        K.leftRightIntoCmdGoes = function (D) {
          if (D && D !== "up" && D !== "down") {
            throw '"up" or "down" required for leftRightIntoCmdGoes option, got "' +
              D + '"';
          }
          return D;
        },
        se.onNotify(function (D, b) {
          b !== "upDown" && (D.upDownCache = {});
        }),
        se.onNotify(function (D, b) {
          b === "edit" && D.show().deleteSelection();
        }),
        se.onNotify(function (D, b) {
          b !== "select" && D.endSelection();
        });
      var Mr = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.keystroke = function (g, m) {
            this.cursor.parent.keystroke(g, m, this.getControllerSelf());
          },
            b.prototype.escapeDir = function (g, m, T) {
              s(g);
              var G = this.cursor;
              if (
                G.parent !== this.root &&
                (T == null || T.preventDefault()), G.parent !== this.root
              ) {
                return G.clearSelection(),
                  G.parent.moveOutOf(g, G),
                  G.controller.aria.alert(),
                  this.notify("move");
              }
            },
            b.prototype.moveDir = function (g) {
              s(g);
              var m = this.cursor,
                T = m.options.leftRightIntoCmdGoes,
                G = m[g];
              return m.selection
                ? m.insDirOf(g, m.selection.getEnd(g))
                : G
                ? G.moveTowards(g, m, T)
                : m.parent.moveOutOf(g, m, T),
                this.notify("move");
            },
            b.prototype.moveLeft = function () {
              return this.moveDir(r);
            },
            b.prototype.moveRight = function () {
              return this.moveDir(e);
            },
            b.prototype.moveUp = function () {
              return this.moveUpDown("up");
            },
            b.prototype.moveDown = function () {
              return this.moveUpDown("down");
            },
            b.prototype.moveUpDown = function (g) {
              var m = this, T = m.notify("upDown").cursor, G, B;
              g === "up"
                ? (G = "upInto", B = "upOutOf")
                : (G = "downInto", B = "downOutOf");
              var H = T[r], X = T[e], ge = X && X[G], Oe = H && H[G];
              return ge
                ? T.insAtLeftEnd(ge)
                : Oe
                ? T.insAtRightEnd(Oe)
                : T.parent.bubble(function (Ae) {
                  var Ie = Ae[B];
                  if (
                    Ie &&
                    (typeof Ie == "function" && (Ie = Ie.call(Ae, T)),
                      Ie instanceof Dt && T.jumpUpDown(Ae, Ie),
                      Ie !== true)
                  ) return false;
                }),
                m;
            },
            b.prototype.deleteDir = function (g) {
              s(g);
              var m = this.cursor,
                T = m[g],
                G = m.parent.parent,
                B = m.controller;
              if (T && T instanceof Dt) {
                T.sides
                  ? B.aria.queue(
                    T.parent.chToCmd(T.sides[-g].ch).mathspeak({
                      createdLeftOf: m,
                    }),
                  )
                  : !T.blocks && T.parent.ctrlSeq !== "\\text" &&
                    B.aria.queue(T);
              } else if (G && G instanceof Dt) {
                if (G.sides) {
                  B.aria.queue(
                    G.parent.chToCmd(G.sides[g].ch).mathspeak({
                      createdLeftOf: m,
                    }),
                  );
                } else if (G.blocks && G.mathspeakTemplate) {
                  if (G.upInto && G.downInto) {
                    B.aria.queue(G.mathspeakTemplate[1]);
                  } else {
                    var H = G.mathspeakTemplate,
                      X = g === r ? H[0] : H[H.length - 1];
                    B.aria.queue(X);
                  }
                } else B.aria.queue(G);
              }
              var ge = m.selection;
              if (this.notify("edit"), !ge) {
                var Oe = m[g];
                Oe ? Oe.deleteTowards(g, m) : m.parent.deleteOutOf(g, m);
              }
              var Ae = m[r], Ie = m[e];
              return Ae.siblingDeleted && Ae.siblingDeleted(m.options, e),
                Ie.siblingDeleted && Ie.siblingDeleted(m.options, r),
                m.parent.bubble(function (qe) {
                  qe.reflow();
                }),
                this;
            },
            b.prototype.ctrlDeleteDir = function (g) {
              s(g);
              var m = this.cursor;
              if (!m[g] || m.selection) return this.deleteDir(g);
              this.notify("edit");
              var T;
              g === r
                ? T = new N(m.parent.getEnd(r), m[r])
                : T = new N(m[e], m.parent.getEnd(e)),
                m.controller.aria.queue(T),
                T.remove(),
                m.insAtDirEnd(g, m.parent);
              var G = m[r], B = m[e];
              return G && G.siblingDeleted(m.options, e),
                B && B.siblingDeleted(m.options, r),
                m.parent.bubble(function (H) {
                  H.reflow();
                }),
                this;
            },
            b.prototype.backspace = function () {
              return this.deleteDir(r);
            },
            b.prototype.deleteForward = function () {
              return this.deleteDir(e);
            },
            b.prototype.startIncrementalSelection = function () {
              a("Multiple selections can't be simultaneously open", !It),
                It = true,
                this.notify("select");
              var g = this.cursor;
              g.anticursor || g.startSelection();
            },
            b.prototype.selectDirIncremental = function (g) {
              a("A selection is open", It), It = true;
              var m = this.cursor, T = m.selection;
              s(g);
              var G = m[g];
              G
                ? T && T.getEnd(g) === G && m.anticursor[-g] !== G
                  ? G.unselectInto(g, m)
                  : G.selectTowards(g, m)
                : m.parent.selectOutOf(g, m);
            },
            b.prototype.finishIncrementalSelection = function () {
              a("A selection is open", It);
              var g = this.cursor;
              g.clearSelection(), g.select() || g.show();
              var m = g.selection;
              m &&
              g.controller.aria.clear().queue(
                m.join("mathspeak", " ").trim() + " selected",
              ), It = false;
            },
            b.prototype.withIncrementalSelection = function (g) {
              var m = this;
              try {
                this.startIncrementalSelection();
                try {
                  g(function (T) {
                    return m.selectDirIncremental(T);
                  });
                } finally {
                  this.finishIncrementalSelection();
                }
              } finally {
                It = false;
              }
            },
            b.prototype.selectDir = function (g) {
              this.withIncrementalSelection(function (m) {
                return m(g);
              });
            },
            b.prototype.selectLeft = function () {
              return this.selectDir(r);
            },
            b.prototype.selectRight = function () {
              return this.selectDir(e);
            },
            b.prototype.selectAll = function () {
              this.notify("move");
              var g = this.cursor;
              g.insAtRightEnd(this.root),
                this.withIncrementalSelection(function (m) {
                  for (; g[r];) m(r);
                });
            },
            b.prototype.selectToBlockEndInDir = function (g) {
              var m = this.cursor;
              this.withIncrementalSelection(function (T) {
                for (; m[g];) T(g);
              });
            },
            b.prototype.selectToRootEndInDir = function (g) {
              var m = this, T = this.cursor;
              this.withIncrementalSelection(function (G) {
                for (; T[g] || T.parent !== m.root;) G(g);
              });
            },
            b;
        }(Lt),
        Q = function (D) {
          ht(b, D);
          function b(g) {
            return D.call(this) || this;
          }
          return b;
        }(Dt),
        j = function () {
          function D($r) {
            var xi = new Te();
            return $r.adopt(xi, 0, 0), xi;
          }
          function b($r) {
            for (
              var xi = $r[0] || new Te(), js = 1;
              js < $r.length;
              js += 1
            ) $r[js].children().adopt(xi, xi.getEnd(e), 0);
            return xi;
          }
          var g = ce.string,
            m = ce.regex,
            T = ce.letter,
            G = ce.digit,
            B = ce.any,
            H = ce.optWhitespace,
            X = ce.succeed,
            ge = ce.fail,
            Oe = T.map(function ($r) {
              return new Zt($r);
            }),
            Ae = G.map(function ($r) {
              return new Gt($r);
            }),
            Ie = m(/^[^${}\\_^]/).map(function ($r) {
              return new be($r);
            }),
            qe = m(/^[^\\a-eg-zA-Z]/).or(
              g("\\").then(m(/^[a-z]+/i).or(m(/^\s+/).result(" ")).or(B)),
            ).then(function ($r) {
              var xi = M[$r];
              if (xi) {
                if (xi.constructor) {
                  var js = xi;
                  return new js($r).parser();
                } else {
                  var El = xi;
                  return El($r).parser();
                }
              } else return ge("unknown command: \\" + $r);
            }),
            He = qe.or(Oe).or(Ae).or(Ie),
            lt = g("{").then(function () {
              return At;
            }).skip(g("}")),
            gt = H.then(lt.or(He.map(D))),
            At = gt.many().map(b).skip(H),
            Gr = g("[").then(
              gt.then(function ($r) {
                return $r.join("latex") !== "]" ? X($r) : ge("");
              }).many().map(b).skip(H),
            ).skip(g("]")),
            wn = At;
          return wn.block = gt, wn.optBlock = Gr, wn;
        }();
      K.maxDepth = function (D) {
        return typeof D == "number" ? D : void 0;
      };
      var Ge = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.cleanLatex = function (g) {
            return g.replace(/(\\[a-z]+) (?![a-z])/gi, "$1");
          },
            b.prototype.exportLatex = function () {
              return this.cleanLatex(this.root.latex());
            },
            b.prototype.writeLatex = function (g) {
              var m = this.notify("edit").cursor;
              return m.parent.writeLatex(m, g), this;
            },
            b.prototype.exportLatexSelection = function () {
              var g = { latex: "", startIndex: -1, endIndex: -1 },
                m = this.cursor.selection;
              if (m) {
                g.startSelectionBefore = m.getEnd(r),
                  g.endSelectionAfter = m.getEnd(e);
              } else {
                var T = this.cursor[r];
                T
                  ? g.startSelectionAfter = T
                  : g.startSelectionBefore = this.cursor.parent;
                var G = this.cursor[e];
                G
                  ? g.endSelectionBefore = G
                  : g.endSelectionAfter = this.cursor.parent;
              }
              this.root.latexRecursive(g);
              for (
                var B = g.latex,
                  H = this.cleanLatex(B),
                  X = g.startIndex,
                  ge = g.endIndex,
                  Oe = 0,
                  Ae = 0;
                Ae < g.endIndex;
                Ae++
              ) {
                B[Ae] !== H[Oe]
                  ? (Ae < g.startIndex && (X -= 1), ge -= 1)
                  : Oe += 1;
              }
              return { latex: H, startIndex: X, endIndex: ge };
            },
            b.prototype.classifyLatexForEfficientUpdate = function (g) {
              if (typeof g == "string") {
                var m = g.match(/-?[0-9.]+$/g);
                if (m && m.length === 1) {
                  return {
                    latex: g,
                    prefix: g.substr(0, g.length - m[0].length),
                    digits: m[0],
                  };
                }
              }
            },
            b.prototype.updateLatexMathEfficiently = function (g, m) {
              var T,
                G,
                B,
                H,
                X = this.root,
                ge,
                Oe = this.classifyLatexForEfficientUpdate(g);
              if (Oe) {
                if (
                  ge = this.classifyLatexForEfficientUpdate(m),
                    !ge || ge.prefix !== Oe.prefix
                ) return false;
              } else return false;
              var Ae = ge.digits, Ie = Oe.digits, qe = false, He = false;
              Ae[0] === "-" && (qe = true, Ae = Ae.substr(1)),
                Ie[0] === "-" && (He = true, Ie = Ie.substr(1));
              for (
                var lt = this.root.getEnd(e), gt = [], At = Ae.length - 1;
                At >= 0;
                At--
              ) {
                if (!lt || lt.ctrlSeq !== Ae[At] || lt.parent !== X) {
                  return false;
                }
                gt.unshift(lt), lt = lt[r];
              }
              if (qe && !He) {
                var Gr = lt;
                if (
                  !Gr || Gr.ctrlSeq !== "-" || Gr[e] !== gt[0] ||
                  Gr.parent !== X
                ) return false;
                var wn = Gr[r];
                if (wn && wn.parent !== X) return false;
                gt[0][r] = Gr[r],
                  X.getEnd(r) === Gr &&
                  X.setEnds(
                    (T = {}, T[r] = gt[0], T[e] = X.getEnd(e), T),
                  ),
                  wn && (wn[e] = gt[0]),
                  Gr.domFrag().remove();
              }
              if (!qe && He) {
                var $r = new Na("-"), xi = document.createElement("span");
                xi.textContent = "-", $r.setDOM(xi);
                var js = gt[0][r];
                js && (js[e] = $r),
                  X.getEnd(r) === gt[0] &&
                  X.setEnds((G = {}, G[r] = $r, G[e] = X.getEnd(e), G)),
                  $r.parent = X,
                  $r[r] = gt[0][r],
                  $r[e] = gt[0],
                  gt[0][r] = $r,
                  $r.contactWeld(this.cursor),
                  $r.domFrag().insertBefore(gt[0].domFrag());
              }
              var El = Math.min(Ae.length, Ie.length);
              for (At = 0; At < El; At++) {
                var zh = Ie[At];
                lt = gt[At],
                  lt.ctrlSeq !== zh &&
                  (lt.ctrlSeq = zh,
                    lt.domFrag().oneElement().textContent = zh,
                    lt.mathspeakName = zh);
              }
              if (Ae.length > Ie.length) {
                for (
                  lt = gt[Ie.length - 1],
                    X.setEnds((B = {}, B[r] = X.getEnd(r), B[e] = lt, B)),
                    lt[e] = 0,
                    At = Ae.length - 1;
                  At >= El;
                  At--
                ) gt[At].domFrag().remove();
              }
              if (Ie.length > Ae.length) {
                var Lr = document.createDocumentFragment();
                for (At = El; At < Ie.length; At++) {
                  var sc = document.createElement("span");
                  sc.className = "dcg-mq-digit", sc.textContent = Ie[At];
                  var ys = new Gt(Ie[At]);
                  ys.parent = X,
                    ys.setDOM(sc),
                    Lr.appendChild(sc),
                    ys[r] = X.getEnd(e),
                    ys[e] = 0;
                  var qj = ys[r];
                  qj[e] = ys,
                    X.setEnds((H = {}, H[r] = X.getEnd(r), H[e] = ys, H));
                }
                X.domFrag().oneElement().appendChild(Lr);
              }
              var jR = this.exportLatex();
              if (jR !== g) {
                return console.warn(
                  "tried updating latex efficiently but did not work. Attempted: " +
                    g + " but wrote: " + jR,
                ),
                  false;
              }
              var YR = X.getEnd(e);
              return YR && YR.fixDigitGrouping(this.cursor.options), true;
            },
            b.prototype.renderLatexMathFromScratch = function (g) {
              var m,
                T = this.root,
                G = this.cursor,
                B = ce.all,
                H = ce.eof,
                X = j.skip(H).or(B.result(false)).parse(g);
              if (
                T.setEnds((m = {}, m[r] = 0, m[e] = 0, m)),
                  X && X.children().adopt(T, 0, 0),
                  X
              ) {
                var ge = T.domFrag();
                ge.children().remove(),
                  ge.oneElement().appendChild(X.html()),
                  T.finalizeInsert(G.options, G);
              } else T.domFrag().empty();
            },
            b.prototype.renderLatexMath = function (g) {
              var m = this.cursor, T = this.root;
              this.notify("replace"), m.clearSelection();
              var G = this.exportLatex();
              (!T.getEnd(r) || !T.getEnd(e) || G !== g) &&
              (this.updateLatexMathEfficiently(g, G) ||
                this.renderLatexMathFromScratch(g),
                this.updateMathspeak()), m.insAtRightEnd(T);
            },
            b.prototype.renderLatexText = function (g) {
              var m, T = this.root, G = this.cursor;
              T.domFrag().children().slice(1).remove(),
                T.setEnds((m = {}, m[r] = 0, m[e] = 0, m)),
                delete G.selection,
                G.show().insAtRightEnd(T);
              var B = ce.regex,
                H = ce.string,
                X = ce.eof,
                ge = ce.all,
                Oe = H("$").then(j).skip(H("$").or(X)).map(function (gt) {
                  var At = new RootMathCommand(G);
                  At.createBlocks();
                  var Gr = At.getEnd(r);
                  return gt.children().adopt(Gr, 0, 0), At;
                }),
                Ae = H("\\$").result("$"),
                Ie = Ae.or(B(/^[^$]/)).map(function (gt) {
                  return new be(gt);
                }),
                qe = Oe.or(Ie).many(),
                He = qe.skip(X).or(ge.result(false)).parse(g);
              if (He) {
                for (var lt = 0; lt < He.length; lt += 1) {
                  He[lt].adopt(T, T.getEnd(e), 0);
                }
                P(T.html()).appendTo(T.domFrag().oneElement()),
                  T.finalizeInsert(G.options, G);
              }
            },
            b;
        }(Mr),
        de = function (D) {
          return false;
        };
      fe.prototype.ignoreNextMousedown = de;
      var Ye;
      (function () {
        se.onNotify(function (D, b) {
          (b === "edit" || b === "replace") && Ye && Ye.cursor === D &&
            Ye.cb();
        });
      })();
      var Ve = function (D) {
          ht(b, D);
          function b() {
            var g = D !== null && D.apply(this, arguments) || this;
            return g.handleMouseDown = function (m) {
              var T = d(m.target, ".dcg-mq-root-block"),
                G = T && V.getNodeOfElement(T) ||
                  V.getNodeOfElement(g.root.domFrag().oneElement()),
                B = G.domFrag().firstNode().ownerDocument,
                H = G.controller,
                X = H.cursor,
                ge = X.blink,
                Oe = H.getTextarea();
              if (
                m.preventDefault(),
                  m.target.unselectable = true,
                  X.options.ignoreNextMousedown(m) ||
                  d(m.target, ".dcg-mq-ignore-mousedown")
              ) return;
              var Ae = null;
              function Ie(Gr) {
                Ae = Gr.target;
              }
              function qe(Gr) {
                X.anticursor || X.startSelection(),
                  H.seek(Ae, Gr.clientX, Gr.clientY).cursor.select(),
                  X.selection &&
                  X.controller.aria.clear().queue(
                    X.selection.join("mathspeak") + " selected",
                  ).alert(),
                  Ae = null;
              }
              function He() {
                T == null || T.removeEventListener("mousemove", Ie),
                  B == null || B.removeEventListener("mousemove", qe),
                  B == null || B.removeEventListener("mouseup", gt),
                  Ye = void 0;
              }
              function lt() {
                H.editable &&
                  (X.show(), X.controller.aria.queue(X.parent).alert());
              }
              function gt() {
                X.blink = ge, X.selection || lt(), He();
              }
              var At;
              Ye = {
                cursor: X,
                cb: function () {
                  At = true, X.blink = ge, X.clearSelection(), lt(), He();
                },
              },
                !(H.blurred && (Oe.focus(), At)) &&
                (X.blink = i,
                  H.seek(m.target, m.clientX, m.clientY).cursor
                    .startSelection(),
                  T == null || T.addEventListener("mousemove", Ie),
                  B == null || B.addEventListener("mousemove", qe),
                  B == null || B.addEventListener("mouseup", gt));
            },
              g;
          }
          return b.prototype.addMouseEventListener = function () {
            this.container.addEventListener(
              "mousedown",
              this.handleMouseDown,
            );
          },
            b.prototype.removeMouseEventListener = function () {
              this.container.removeEventListener(
                "mousedown",
                this.handleMouseDown,
              );
            },
            b.prototype.seek = function (g, m, T) {
              for (
                var G = this.notify("select").cursor, B;
                g && (B = V.getNodeOfElement(g), !B);
              ) g = g.parentElement;
              return B || (B = this.root),
                G.clearSelection().show(),
                B.seek(m, G),
                this.scrollHoriz(),
                this;
            },
            b;
        }(Ge),
        Qr = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.setOverflowClasses = function () {
            var g = this.root.domFrag().oneElement(), m = false, T = false;
            if (!this.blurred) {
              var G = v(g).width, B = g.scrollWidth, H = g.scrollLeft;
              m = B > G + H, T = H > 0;
            }
            g.classList.contains("dcg-mq-editing-overflow-right") !== m &&
            g.classList.toggle("dcg-mq-editing-overflow-right"),
              g.classList.contains("dcg-mq-editing-overflow-left") !==
                T && g.classList.toggle("dcg-mq-editing-overflow-left");
          },
            b.prototype.scrollHoriz = function () {
              var g = this,
                m = this.cursor,
                T = m.selection,
                G = v(this.root.domFrag().oneElement());
              if (m.domFrag().isEmpty() && !T) {
                this.cancelScrollHoriz &&
                  (this.cancelScrollHoriz(), this.cancelScrollHoriz = void 0);
                var B = this.root.domFrag().oneElement(),
                  H = B.scrollLeft;
                k(
                  this.getScrollAnimationDuration(),
                  function (gt, At, Gr) {
                    gt >= 1
                      ? (g.cancelScrollHoriz = void 0,
                        B.scrollLeft = 0,
                        g.setOverflowClasses())
                      : (g.cancelScrollHoriz = Gr,
                        At(),
                        B.scrollLeft = Math.round((1 - gt) * H));
                  },
                );
                return;
              } else if (T) {
                var Oe = v(T.domFrag().oneElement()),
                  Ae = Oe.left - (G.left + 20),
                  Ie = Oe.right - (G.right - 20);
                if (T.getEnd(r) === m[e]) {
                  if (Ae < 0) { var ge = Ae; }
                  else if (Ie > 0) {
                    if (Oe.left - Ie < G.left + 20) { var ge = Ae; }
                    else var ge = Ie;
                  } else return;
                } else if (Ie > 0) { var ge = Ie; }
                else if (Ae < 0) {
                  if (Oe.right - Ae > G.right - 20) {
                    var ge = Ie;
                  } else var ge = Ae;
                } else return;
              } else {
                var X = v(m.domFrag().oneElement()).left;
                if (X > G.right - 20) { var ge = X - (G.right - 20); }
                else if (X < G.left + 20) { var ge = X - (G.left + 20); }
                else return;
              }
              var qe = this.root.domFrag().oneElement();
              if (
                !(ge < 0 && qe.scrollLeft === 0) &&
                !(ge > 0 && qe.scrollWidth <= qe.scrollLeft + G.width)
              ) {
                this.cancelScrollHoriz &&
                  (this.cancelScrollHoriz(), this.cancelScrollHoriz = void 0);
                var He = this.root.domFrag().oneElement(),
                  lt = He.scrollLeft;
                k(
                  this.getScrollAnimationDuration(),
                  function (gt, At, Gr) {
                    gt >= 1
                      ? (g.cancelScrollHoriz = void 0,
                        He.scrollLeft = Math.round(lt + ge),
                        g.setOverflowClasses())
                      : (g.cancelScrollHoriz = Gr,
                        At(),
                        He.scrollLeft = Math.round(lt + gt * ge));
                  },
                );
              }
            },
            b.prototype.getScrollAnimationDuration = function () {
              var g;
              return (g = this.options.scrollAnimationDuration) !==
                    null && g !== void 0
                ? g
                : 100;
            },
            b;
        }(Ve);
      fe.prototype.substituteTextarea = function (D) {
        return c("textarea", {
          autocapitalize: "off",
          autocomplete: "off",
          autocorrect: "off",
          spellcheck: false,
          "x-palm-disable-ste-all": true,
          tabindex: D ? void 0 : "-1",
        });
      };
      function st() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
          /[xy]/g,
          function (D) {
            var b = Math.random() * 16 | 0, g = D === "x" ? b : b & 3 | 8;
            return g.toString(16);
          },
        );
      }
      function Bn(D, b) {
        return it(D[0], b);
      }
      fe.prototype.substituteKeyboardEvents = Bn;
      var co = function (D) {
          ht(b, D);
          function b() {
            var g = D !== null && D.apply(this, arguments) || this;
            return g.selectFn = i, g;
          }
          return b.prototype.createTextarea = function () {
            this.textareaSpan = c("span", { class: "dcg-mq-textarea" });
            var g = this.options.tabbable !== void 0
                ? this.options.tabbable
                : this.KIND_OF_MQ !== "StaticMath",
              m = this.options.substituteTextarea(g);
            if (!m.nodeType) {
              throw "substituteTextarea() must return a DOM element, got " +
                m;
            }
            !this.options.tabbable && this.KIND_OF_MQ === "StaticMath" &&
            m.setAttribute("aria-hidden", "true"),
              this.textarea = P(m).appendTo(this.textareaSpan)
                .oneElement(),
              this.mathspeakSpan ||
              (this.mathspeakId = st(),
                this.mathspeakSpan = c("span", {
                  class: "dcg-mq-mathspeak",
                  id: this.mathspeakId,
                }),
                P(this.textareaSpan).prepend(P(this.mathspeakSpan))),
              this.mathspeakId &&
              (m == null ||
                m.setAttribute("aria-labelledby", this.mathspeakId)),
              g && this.mathspeakSpan &&
              this.mathspeakSpan.setAttribute("aria-hidden", "true");
            var T = this;
            T.cursor.selectionChanged = function () {
              T.selectionChanged();
            };
          },
            b.prototype.selectionChanged = function () {
              var g = this;
              g.textareaSelectionTimeout ||
                (g.textareaSelectionTimeout = setTimeout(function () {
                  g.setTextareaSelection();
                }));
            },
            b.prototype.setTextareaSelection = function () {
              this.textareaSelectionTimeout = 0;
              var g = "";
              this.cursor.selection &&
              (g = this.cleanLatex(this.cursor.selection.join("latex")),
                this.options.statelessClipboard && (g = "$" + g + "$")),
                this.selectFn(g);
            },
            b.prototype.staticMathTextareaEvents = function () {
              var g = this;
              this.removeTextareaEventListener("cut"),
                this.removeTextareaEventListener("paste"),
                g.options.disableCopyPaste
                  ? this.removeTextareaEventListener("copy")
                  : this.addTextareaEventListeners({
                    copy: function () {
                      g.setTextareaSelection();
                    },
                  }),
                this.addStaticFocusBlurListeners();
              var m = this.getTextarea(), T = it(m, this).select;
              this.selectFn = T;
              var G = this.getTextareaSpan();
              P(this.container).prepend(P(G));
            },
            b.prototype.editablesTextareaEvents = function () {
              var g = this, m = g.getTextarea(), T = g.getTextareaSpan();
              if (this.options.version < 3) {
                var G = this.options.assertJquery(),
                  B = this.options.substituteKeyboardEvents(G(m), this);
                this.selectFn = function (X) {
                  B.select(X);
                };
              } else {
                var H = it(m, this).select;
                this.selectFn = H;
              }
              P(this.container).prepend(P(T)),
                this.addEditableFocusBlurListeners(),
                this.updateMathspeak();
            },
            b.prototype.unbindEditablesEvents = function () {
              var g = this, m = g.getTextarea(), T = g.getTextareaSpan();
              this.selectFn = function (G) {
                m instanceof HTMLTextAreaElement &&
                  (m.value = G, G && m.select());
              },
                P(T).remove(),
                this.removeTextareaEventListener("focus"),
                this.removeTextareaEventListener("blur"),
                g.blurred = true,
                this.removeTextareaEventListener("cut"),
                this.removeTextareaEventListener("paste");
            },
            b.prototype.typedText = function (g) {
              if (
                g === `
`
              ) return this.handle("enter");
              var m = this.notify(void 0).cursor;
              m.parent.write(m, g), this.scrollHoriz();
            },
            b.prototype.cut = function () {
              var g = this, m = g.cursor;
              m.selection && setTimeout(function () {
                g.notify("edit"),
                  m.parent.bubble(function (T) {
                    T.reflow();
                  }),
                  g.options && g.options.onCut && g.options.onCut();
              });
            },
            b.prototype.copy = function () {
              this.setTextareaSelection();
            },
            b.prototype.paste = function (g) {
              this.options.statelessClipboard &&
              (g.slice(0, 1) === "$" && g.slice(-1) === "$"
                ? g = g.slice(1, -1)
                : g = "\\text{" + g + "}"),
                this.writeLatex(g).cursor.show(),
                this.scrollHoriz(),
                this.options && this.options.onPaste &&
                this.options.onPaste();
            },
            b.prototype.setupStaticField = function () {
              this.updateMathspeak(),
                this.blurred = true,
                this.cursor.hide().parent.blur(this.cursor);
            },
            b.prototype.updateMathspeak = function (g) {
              var m = this,
                T = m.getAriaLabel(),
                G = /[A-Za-z0-9]$/.test(T) ? T + ":" : T,
                B = m.root.mathspeak().trim(),
                H = !!(g != null && g.emptyContent);
              this.aria.clear({ emptyContent: H }),
                m.mathspeakSpan &&
                (m.mathspeakSpan.textContent =
                  (G + " " + B + " " + m.ariaPostLabel).trim());
            },
            b;
        }(Qr),
        Vo = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.finalizeInsert = function (g, m) {
            var T = this;
            T.postOrder(function (H) {
              H.finalizeTree(g);
            }),
              T.postOrder(function (H) {
                H.contactWeld(m);
              }),
              T.postOrder(function (H) {
                H.blur(m);
              }),
              T.postOrder(function (H) {
                H.reflow();
              });
            var G = T[e], B = T[r];
            G && G.siblingCreated(g, r),
              B && B.siblingCreated(g, e),
              T.bubble(function (H) {
                H.reflow();
              });
          },
            b.prototype.prepareInsertionAt = function (g) {
              var m = g.options.maxDepth;
              if (m !== void 0) {
                var T = g.depth();
                if (T > m) return false;
                this.removeNodesDeeperThan(m - T);
              }
              return true;
            },
            b.prototype.removeNodesDeeperThan = function (g) {
              for (var m = 0, T = [[this, m]], G; G = T.shift();) {
                var B = G;
                B[0].children().each(function (H) {
                  var X = H instanceof Te ? 1 : 0;
                  m = B[1] + X,
                    m <= g ? T.push([H, m]) : (X ? H.children() : H).remove();
                });
              }
            },
            b;
        }(Dt),
        Ue = function () {
          function D(b, g) {
            this.childCount = b, this.render = g;
          }
          return D;
        }(),
        at = function (D) {
          ht(b, D);
          function b(g, m, T) {
            var G = D.call(this) || this;
            return G.textTemplate = [""],
              G.mathspeakTemplate = [""],
              G.setCtrlSeqHtmlAndText(g, m, T),
              G;
          }
          return b.prototype.setEnds = function (g) {
            a("MathCommand ends are never empty", g[r] && g[e]), this.ends = g;
          },
            b.prototype.getEnd = function (g) {
              return this.ends[g];
            },
            b.prototype.setCtrlSeqHtmlAndText = function (g, m, T) {
              this.ctrlSeq || (this.ctrlSeq = g),
                m && (this.domView = m),
                T && (this.textTemplate = T);
            },
            b.prototype.replaces = function (g) {
              g.disown(), this.replacedFragment = g;
            },
            b.prototype.isEmpty = function () {
              return this.foldChildren(true, function (g, m) {
                return g && m.isEmpty();
              });
            },
            b.prototype.parser = function () {
              var g = this, m = j.block;
              return m.times(this.numBlocks()).map(function (T) {
                g.blocks = T;
                for (var G = 0; G < T.length; G += 1) {
                  T[G].adopt(g, g.getEnd(e), 0);
                }
                return g;
              });
            },
            b.prototype.createLeftOf = function (g) {
              var m = this, T = m.replacedFragment;
              if (
                m.createBlocks(), D.prototype.createLeftOf.call(this, g), T
              ) {
                var G = m.getEnd(r);
                T.adopt(G, 0, 0),
                  T.domFrag().appendTo(G.domFrag().oneElement()),
                  m.placeCursor(g),
                  m.prepareInsertionAt(g);
              }
              m.finalizeInsert(g.options, g), m.placeCursor(g);
            },
            b.prototype.createBlocks = function () {
              for (
                var g = this,
                  m = g.numBlocks(),
                  T = g.blocks = Array(m),
                  G = 0;
                G < m;
                G += 1
              ) {
                var B = T[G] = new Te();
                B.adopt(g, g.getEnd(e), 0);
              }
            },
            b.prototype.placeCursor = function (g) {
              g.insAtRightEnd(
                this.foldChildren(this.getEnd(r), function (m, T) {
                  return m.isEmpty() ? m : T;
                }),
              );
            },
            b.prototype.moveTowards = function (g, m, T) {
              var G;
              T === "up"
                ? G = this.upInto
                : T === "down" && (G = this.downInto);
              var B = G || this.getEnd(-g);
              m.insAtDirEnd(-g, B),
                m.controller.aria.queueDirEndOf(-g).queue(m.parent, true);
            },
            b.prototype.deleteTowards = function (g, m) {
              this.isEmpty() ? m[g] = this.remove()[g] : this.moveTowards(g, m);
            },
            b.prototype.selectTowards = function (g, m) {
              m[-g] = this, m[g] = this[g];
            },
            b.prototype.selectChildren = function () {
              return new he(this, this);
            },
            b.prototype.unselectInto = function (g, m) {
              var T = m.anticursor, G = T.ancestors[this.id];
              m.insAtDirEnd(-g, G);
            },
            b.prototype.seek = function (g, m) {
              function T(X) {
                var ge,
                  Oe = X.domFrag().oneElement(),
                  Ae = v(Oe).left,
                  Ie = Ae + Oe.offsetWidth;
                return ge = {}, ge[r] = Ae, ge[e] = Ie, ge;
              }
              var G = this, B = T(G);
              if (g < B[r]) return m.insLeftOf(G);
              if (g > B[e]) return m.insRightOf(G);
              var H = B[r];
              G.eachChild(function (X) {
                var ge = T(X);
                if (g < ge[r]) {
                  return g - H < ge[r] - g
                    ? X[r] ? m.insAtRightEnd(X[r]) : m.insLeftOf(G)
                    : m.insAtLeftEnd(X),
                    false;
                }
                if (g > ge[e]) {
                  X[e]
                    ? H = ge[e]
                    : B[e] - g < g - ge[e]
                    ? m.insRightOf(G)
                    : m.insAtRightEnd(X);
                  return;
                } else return X.seek(g, m), false;
              });
            },
            b.prototype.numBlocks = function () {
              return this.domView.childCount;
            },
            b.prototype.html = function () {
              var g = this.blocks;
              a("domView is defined", this.domView);
              var m = this.domView, T = m.render(g || []);
              return this.setDOM(T), V.linkElementByCmdNode(T, this), T;
            },
            b.prototype.latexRecursive = function (g) {
              this.checkCursorContextOpen(g),
                g.latex += this.ctrlSeq || "",
                this.eachChild(function (m) {
                  g.latex += "{";
                  var T = g.latex.length;
                  m.latexRecursive(g);
                  var G = g.latex.length;
                  T === G && (g.latex += " "), g.latex += "}";
                }),
                this.checkCursorContextClose(g);
            },
            b.prototype.text = function () {
              var g = this, m = 0;
              return g.foldChildren(g.textTemplate[m], function (T, G) {
                m += 1;
                var B = G.text();
                return T && g.textTemplate[m] === "(" && B[0] === "(" &&
                    B.slice(-1) === ")"
                  ? T + B.slice(1, -1) + g.textTemplate[m]
                  : T + B + (g.textTemplate[m] || "");
              });
            },
            b.prototype.mathspeak = function () {
              var g = this, m = 0;
              return g.foldChildren(
                g.mathspeakTemplate[m] || "Start" + g.ctrlSeq + " ",
                function (T, G) {
                  return m += 1,
                    T + " " + G.mathspeak() + " " +
                    (g.mathspeakTemplate[m] + " " ||
                      "End" + g.ctrlSeq + " ");
                },
              );
            },
            b;
        }(Vo),
        ft = function (D) {
          ht(b, D);
          function b(g, m, T, G) {
            var B = D.call(this) || this;
            return B.setCtrlSeqHtmlTextAndMathspeak(
              g,
              m
                ? new Ue(0, function () {
                  return m.cloneNode(true);
                })
                : void 0,
              T,
              G,
            ),
              B;
          }
          return b.prototype.setCtrlSeqHtmlTextAndMathspeak = function (
            g,
            m,
            T,
            G,
          ) {
            !T && g && (T = g.replace(/^\\/, "")),
              this.mathspeakName = G || T,
              D.prototype.setCtrlSeqHtmlAndText.call(this, g, m, [
                T || "",
              ]);
          },
            b.prototype.parser = function () {
              return ce.succeed(this);
            },
            b.prototype.numBlocks = function () {
              return 0;
            },
            b.prototype.replaces = function (g) {
              g.remove();
            },
            b.prototype.createBlocks = function () {},
            b.prototype.moveTowards = function (g, m) {
              m.domFrag().insDirOf(g, this.domFrag()),
                m[-g] = this,
                m[g] = this[g],
                m.controller.aria.queue(this);
            },
            b.prototype.deleteTowards = function (g, m) {
              m[g] = this.remove()[g];
            },
            b.prototype.seek = function (g, m) {
              var T = this.domFrag().oneElement(), G = v(T).left;
              return g - G < T.offsetWidth / 2
                ? m.insLeftOf(this)
                : m.insRightOf(this),
                m;
            },
            b.prototype.latexRecursive = function (g) {
              this.checkCursorContextOpen(g),
                g.latex += this.ctrlSeq || "",
                this.checkCursorContextClose(g);
            },
            b.prototype.text = function () {
              return this.textTemplate.join("");
            },
            b.prototype.mathspeak = function (g) {
              return this.mathspeakName || "";
            },
            b.prototype.placeCursor = function () {},
            b.prototype.isEmpty = function () {
              return true;
            },
            b;
        }(at),
        be = function (D) {
          ht(b, D);
          function b(g, m, T) {
            return D.call(
              this,
              g,
              c("span", {}, [m || c.text(g)]),
              void 0,
              T,
            ) || this;
          }
          return b;
        }(ft);
      function J(D, b, g) {
        return function () {
          return new be(D, b ? c.entityText(b) : void 0, g);
        };
      }
      var pe = function (D) {
        ht(b, D);
        function b(g, m, T, G, B) {
          var H = this;
          return B
            ? H = D.call(
              this,
              g,
              c("span", {}, [m || c.text(g || "")]),
              void 0,
              G,
            ) || this
            : H = D.call(
              this,
              g,
              c(
                "span",
                { class: "dcg-mq-binary-operator" },
                m ? [m] : [],
              ),
              T,
              G,
            ) || this,
            H;
        }
        return b.prototype.isBinaryOperator = function () {
          return true;
        },
          b;
      }(ft);
      function Ne(D, b, g, m) {
        return function () {
          return new pe(D, b ? c.entityText(b) : void 0, g, m);
        };
      }
      var Te = function (D) {
        ht(b, D);
        function b() {
          var g = D !== null && D.apply(this, arguments) || this;
          return g.ariaLabel = "block", g;
        }
        return b.prototype.join = function (g) {
          return this.foldChildren("", function (m, T) {
            return m + T[g]();
          });
        },
          b.prototype.html = function () {
            var g = document.createDocumentFragment();
            return this.eachChild(function (m) {
              var T = m.html();
              g.appendChild(T);
            }),
              g;
          },
          b.prototype.latexRecursive = function (g) {
            this.checkCursorContextOpen(g),
              this.eachChild(function (m) {
                return m.latexRecursive(g);
              }),
              this.checkCursorContextClose(g);
          },
          b.prototype.text = function () {
            var g = this.getEnd(r), m = this.getEnd(e);
            return g === m && g !== 0 ? g.text() : this.join("text");
          },
          b.prototype.mathspeak = function () {
            var g = "", m = {};
            return this.controller &&
              (m = this.controller.options.autoOperatorNames),
              this.foldChildren([], function (T, G) {
                if (G.isPartOfOperator) g += G.mathspeak();
                else {
                  if (g !== "") {
                    if (m._maxLength > 0) {
                      var B = m[g.toLowerCase()];
                      typeof B == "string" && (g = B);
                    }
                    T.push(g + " "), g = "";
                  }
                  var H = G.mathspeak(), X = G.ctrlSeq;
                  isNaN(X) && X !== "." &&
                  (!G.parent || !G.parent.parent ||
                    !G.parent.parent.isTextBlock()) &&
                  (H = " " + H + " "), T.push(H);
                }
                return T;
              }).join("").replace(/ +(?= )/g, "").replace(
                /(\.)([0-9]+)/g,
                function (T, G, B) {
                  return G + B.split("").join(" ").trim();
                },
              );
          },
          b.prototype.keystroke = function (g, m, T) {
            if (
              T.options.spaceBehavesLikeTab &&
              (g === "Spacebar" || g === "Shift-Spacebar")
            ) {
              m == null || m.preventDefault(),
                T.escapeDir(g === "Shift-Spacebar" ? r : e, g, m);
              return;
            }
            return D.prototype.keystroke.call(this, g, m, T);
          },
          b.prototype.moveOutOf = function (g, m, T) {
            var G;
            if (
              T === "up"
                ? G = this.parent.upInto
                : T === "down" && (G = this.parent.downInto), !G && this[g]
            ) {
              var B = -g;
              m.insAtDirEnd(B, this[g]),
                m.controller.aria.queueDirEndOf(B).queue(m.parent, true);
            } else {m.insDirOf(g, this.parent),
                m.controller.aria.queueDirOf(g).queue(this.parent);}
          },
          b.prototype.selectOutOf = function (g, m) {
            m.insDirOf(g, this.parent);
          },
          b.prototype.deleteOutOf = function (g, m) {
            m.unwrapGramp();
          },
          b.prototype.seek = function (g, m) {
            var T = this.getEnd(e);
            if (!T) return m.insAtRightEnd(this);
            var G = T.domFrag().oneElement(), B = v(G).left;
            if (B + G.offsetWidth < g) return m.insAtRightEnd(this);
            var H = this.getEnd(r);
            if (g < v(H.domFrag().oneElement()).left) {
              return m.insAtLeftEnd(this);
            }
            for (; g < v(T.domFrag().oneElement()).left;) T = T[r];
            return T.seek(g, m);
          },
          b.prototype.chToCmd = function (g, m) {
            var T;
            return g.match(/^[a-eg-zA-Z]$/)
              ? new Zt(g)
              : /^\d$/.test(g)
              ? new Gt(g)
              : m && m.typingSlashWritesDivisionSymbol && g === "/"
              ? M["\xF7"](g)
              : m && m.typingAsteriskWritesTimesSymbol && g === "*"
              ? M["\xD7"](g)
              : m && m.typingPercentWritesPercentOf && g === "%"
              ? M.percentof(g)
              : (T = F[g] || M[g])
              ? T.constructor ? new T(g) : T(g)
              : new be(g);
          },
          b.prototype.write = function (g, m) {
            var T = this.chToCmd(m, g.options);
            g.selection && T.replaces(g.replaceSelection()),
              g.isTooDeep() ||
              (T.createLeftOf(g.show()),
                m === "/"
                  ? g.controller.aria.alert("over")
                  : g.controller.aria.alert(
                    T.mathspeak({ createdLeftOf: g }),
                  ));
          },
          b.prototype.writeLatex = function (g, m) {
            var T = ce.all,
              G = ce.eof,
              B = j.skip(G).or(T.result(false)).parse(m);
            if (B && !B.isEmpty() && B.prepareInsertionAt(g)) {
              B.children().adopt(g.parent, g[r], g[e]),
                P(B.html()).insertBefore(g.domFrag()),
                g[r] = B.getEnd(e),
                B.finalizeInsert(g.options, g);
              var H = B.getEnd(e), X = B.getEnd(r), ge = H[e], Oe = X[r];
              ge && ge.siblingCreated(g.options, r),
                Oe && Oe.siblingCreated(g.options, e),
                g.parent.bubble(function (Ae) {
                  Ae.reflow();
                });
            }
          },
          b.prototype.focus = function () {
            return this.domFrag().addClass("dcg-mq-hasCursor"),
              this.domFrag().removeClass("dcg-mq-empty"),
              this;
          },
          b.prototype.blur = function (g) {
            return this.domFrag().removeClass("dcg-mq-hasCursor"),
              this.isEmpty() &&
              (this.domFrag().addClass("dcg-mq-empty"),
                g &&
                this.isQuietEmptyDelimiter(
                  g.options.quietEmptyDelimiters,
                ) && this.domFrag().addClass("dcg-mq-quiet-delimiter")),
              this;
          },
          b;
      }(Vo);
      fe.prototype.mouseEvents = true,
        ae.StaticMath = function (D) {
          var b;
          return b = function (g) {
            ht(m, g);
            function m(T) {
              var G = g.call(this, T) || this, B = G.innerFields = [];
              return G.__controller.root.postOrder(function (H) {
                H.registerInnerField(B, D.InnerMathField);
              }),
                G;
            }
            return m.prototype.__mathquillify = function (T, G) {
              return this.config(T),
                g.prototype.mathquillify.call(this, "dcg-mq-math-mode"),
                this.__controller.setupStaticField(),
                this.__options.mouseEvents &&
                this.__controller.addMouseEventListener(),
                this.__controller.staticMathTextareaEvents(),
                this;
            },
              m.prototype.latex = function (T) {
                var G = g.prototype.latex.apply(this, arguments);
                if (arguments.length > 0) {
                  var B = this.innerFields = [];
                  this.__controller.root.postOrder(function (H) {
                    H.registerInnerField(B, D.InnerMathField);
                  }), this.__controller.updateMathspeak();
                }
                return G;
              },
              m.prototype.setAriaLabel = function (T) {
                return this.__controller.setAriaLabel(T), this;
              },
              m.prototype.getAriaLabel = function () {
                return this.__controller.getAriaLabel();
              },
              m;
          }(D.AbstractMathQuill),
            b.RootBlock = Te,
            b;
        };
      var dt = function (D) {
        ht(b, D);
        function b() {
          return D !== null && D.apply(this, arguments) || this;
        }
        return b;
      }(Te);
      Ee(dt.prototype),
        ae.MathField = function (D) {
          var b;
          return b = function (g) {
            ht(m, g);
            function m() {
              return g !== null && g.apply(this, arguments) || this;
            }
            return m.prototype.__mathquillify = function (T, G) {
              return this.config(T),
                G > 1 && (this.__controller.root.reflow = i),
                g.prototype.mathquillify.call(
                  this,
                  "dcg-mq-editable-field dcg-mq-math-mode",
                ),
                delete this.__controller.root.reflow,
                this;
            },
              m;
          }(D.EditableField),
            b.RootBlock = dt,
            b;
        },
        ae.InnerMathField = function (D) {
          return a("MathField class is defined", D.MathField),
            function (b) {
              ht(g, b);
              function g() {
                return b !== null && b.apply(this, arguments) || this;
              }
              return g.prototype.makeStatic = function () {
                this.__controller.editable = false,
                  this.__controller.root.blur(),
                  this.__controller.unbindEditablesEvents(),
                  P(this.__controller.container).removeClass(
                    "dcg-mq-editable-field",
                  );
              },
                g.prototype.makeEditable = function () {
                  this.__controller.editable = true,
                    this.__controller.editablesTextareaEvents(),
                    this.__controller.cursor.insAtRightEnd(
                      this.__controller.root,
                    ),
                    P(this.__controller.container).addClass(
                      "dcg-mq-editable-field",
                    );
                },
                g;
            }(D.MathField);
        };
      var ut = "\\ ",
        kt = ".",
        Qt = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.finalizeTree = function (g, m) {
            this.sharedSiblingMethod(g, m);
          },
            b.prototype.siblingDeleted = function (g, m) {
              this.sharedSiblingMethod(g, m);
            },
            b.prototype.siblingCreated = function (g, m) {
              this.sharedSiblingMethod(g, m);
            },
            b.prototype.sharedSiblingMethod = function (g, m) {
              m !== r && this[e] instanceof b || this.fixDigitGrouping(g);
            },
            b.prototype.fixDigitGrouping = function (g) {
              if (g.enableDigitGrouping) {
                var m = this, T = m;
                do if (/^[0-9]$/.test(T.ctrlSeq)) m = T;
                else if (T.ctrlSeq === ut) m = T;
                else if (T.ctrlSeq === kt) m = T;
                else break; while (T = m[r]);
                b.fixDigitGroupingFromLeft(g, m);
              }
            },
            b.fixDigitGroupingFromLeft = function (g, m) {
              for (; m && m.ctrlSeq === ut;) {
                if (!m[e]) return;
                m = m[e];
              }
              if (m instanceof b) {
                var T = m;
                a("node", T);
                var G = m, B = 0, H = 0, X = [];
                do {
                  if (/^[0-9]$/.test(T.ctrlSeq)) G = T, H = 0;
                  else if (T.ctrlSeq === ut) G = T, B += 1, H = 0;
                  else if (T.ctrlSeq === kt && T instanceof b) {
                    G = T, X.push(T), g.tripleDotsAreEllipsis && (H += 1);
                  } else break;
                  if (H == 3) break;
                } while (T = G[e]);
                if (H === 3) {
                  var ge = X.pop(), Oe = X.pop(), Ae = X.pop();
                  if (
                    ge[e] instanceof b &&
                    b.fixDigitGroupingFromLeft(g, ge[e]),
                      ge.setGroupingClass("dcg-mq-ellipsis-end"),
                      Oe.setGroupingClass("dcg-mq-ellipsis-middle"),
                      Ae.setGroupingClass("dcg-mq-ellipsis-start"),
                      G = Ae[r],
                      m === Ae
                  ) return;
                }
                for (; G !== m && G && G.ctrlSeq === ut;) {
                  G = G[r], B -= 1;
                }
                if (!(m === G && m && m.ctrlSeq === ut)) {
                  var Ie = B > 0 || X.length > 1;
                  Ie
                    ? b.removeGroupingBetween(m, G)
                    : X[0]
                    ? (X[0] !== m && b.addGroupingBetween(X[0][r], m),
                      X[0] !== G && b.removeGroupingBetween(X[0], G))
                    : b.addGroupingBetween(G, m);
                }
              }
            },
            b.removeGroupingBetween = function (g, m) {
              var T = g;
              do if (
                T instanceof b && T.setGroupingClass(void 0), !T || T === m
              ) break; while (T = T[e]);
            },
            b.addGroupingBetween = function (g, m) {
              for (
                var H = g, T = 0, G = 0;
                H && (G += 1, a("digit", H instanceof b), H !== m);
              ) H = H[r];
              var B = G % 3;
              B === 0 && (B = 3);
              for (var H = g; H;) {
                T += 1;
                var X = void 0;
                if (
                  G >= 4 && (T === G
                    ? X = "dcg-mq-group-leading-" + B
                    : T % 3 === 0 && T !== G &&
                      (X = "dcg-mq-group-start"),
                    X || (X = "dcg-mq-group-other")),
                    H instanceof b && H.setGroupingClass(X),
                    H === m
                ) break;
                H = H[r];
              }
            },
            b.prototype.setGroupingClass = function (g) {
              this._groupingClass !== g &&
                (this._groupingClass &&
                  this.domFrag().removeClass(this._groupingClass),
                  g && this.domFrag().addClass(g),
                  this._groupingClass = g);
            },
            b;
        }(ft),
        Gt = function (D) {
          ht(b, D);
          function b(g, m) {
            return D.call(
              this,
              g,
              c("span", { class: "dcg-mq-digit" }, [c.text(g)]),
              void 0,
              m,
            ) || this;
          }
          return b.prototype.createLeftOf = function (g) {
            var m = g[r],
              T = m && m[r],
              G = g.parent.parent instanceof ac ? g.parent.parent.sub : void 0;
            g.options.autoSubscriptNumerals && g.parent !== G &&
              (m instanceof Vt && m.isItalic !== false ||
                m instanceof ac && T instanceof Vt && T.isItalic !== false)
              ? (new FR().createLeftOf(g),
                D.prototype.createLeftOf.call(this, g),
                g.insRightOf(g.parent.parent))
              : D.prototype.createLeftOf.call(this, g);
          },
            b.prototype.mathspeak = function (g) {
              if (g && g.createdLeftOf) {
                var m = g.createdLeftOf,
                  T = m[r],
                  G = T && T[r],
                  B = m.parent.parent instanceof ac
                    ? m.parent.parent.sub
                    : void 0;
                if (
                  m.options.autoSubscriptNumerals && m.parent !== B &&
                  (T instanceof Vt && T.isItalic !== false ||
                    m[r] instanceof ac && G instanceof Vt &&
                      G.isItalic !== false)
                ) {
                  return "Subscript " + D.prototype.mathspeak.call(this) +
                    " Baseline";
                }
              }
              return D.prototype.mathspeak.call(this);
            },
            b;
        }(Qt),
        Vt = function (D) {
          ht(b, D);
          function b(g, m) {
            return D.call(this, g, c("var", {}, [m || c.text(g)])) ||
              this;
          }
          return b.prototype.text = function () {
            var g = this.ctrlSeq || "";
            return this.isPartOfOperator
              ? g[0] == "\\"
                ? g = g.slice(1, g.length)
                : g[g.length - 1] == " " && (g = g.slice(0, -1))
              : (this[r] && !(this[r] instanceof b) &&
                !(this[r] instanceof pe) && this[r].ctrlSeq !== "\\ " &&
                (g = "*" + g),
                this[e] && !(this[e] instanceof pe) &&
                !(this[e] instanceof ac) && (g += "*")),
              g;
          },
            b.prototype.mathspeak = function () {
              var g = this.ctrlSeq || "";
              return this.isPartOfOperator || g.length > 1 ||
                  this.parent && this.parent.parent &&
                    this.parent.parent.isTextBlock()
                ? D.prototype.mathspeak.call(this)
                : '"' + g + '"';
            },
            b;
        }(ft);
      function Ct(D, b, g) {
        return function () {
          return new Vt(D, c.entityText(b));
        };
      }
      fe.prototype.autoCommands = { _maxLength: 0 },
        K.autoCommands = function (D) {
          if (typeof D != "string" || !/^[a-z]+(?: [a-z]+)*$/i.test(D)) {
            throw '"' + D +
              '" not a space-delimited list of only letters';
          }
          for (
            var b = D.split(" "), g = {}, m = 0, T = 0;
            T < b.length;
            T += 1
          ) {
            var G = b[T];
            if (G.length < 2) {
              throw 'autocommand "' + G + '" not minimum length of 2';
            }
            if (M[G] === Ho) {
              throw '"' + G + '" is a built-in operator name';
            }
            g[G] = 1, m = o(m, G.length);
          }
          return g._maxLength = m, g;
        },
        fe.prototype.quietEmptyDelimiters = {},
        K.quietEmptyDelimiters = function (D) {
          D === void 0 && (D = "");
          for (
            var b = D.split(" "), g = {}, m = 0;
            m < b.length;
            m += 1
          ) {
            var T = b[m];
            g[T] = 1;
          }
          return g;
        },
        fe.prototype.autoParenthesizedFunctions = { _maxLength: 0 },
        K.autoParenthesizedFunctions = function (D) {
          if (typeof D != "string" || !/^[a-z]+(?: [a-z]+)*$/i.test(D)) {
            throw '"' + D +
              '" not a space-delimited list of only letters';
          }
          for (
            var b = D.split(" "), g = {}, m = 0, T = 0;
            T < b.length;
            T += 1
          ) {
            var G = b[T];
            if (G.length < 2) {
              throw 'autocommand "' + G + '" not minimum length of 2';
            }
            g[G] = 1, m = o(m, G.length);
          }
          return g._maxLength = m, g;
        };
      function xr(D, b) {
        for (
          var g = "", m = 0;
          D instanceof Zt && D.ctrlSeq === D.letter && m < b;
        ) g = D.letter + g, D = D[r], m += 1;
        return g;
      }
      var Zt = function (D) {
          ht(b, D);
          function b(g) {
            var m = D.call(this, g) || this;
            return m.letter = g, m;
          }
          return b.prototype.checkAutoCmds = function (g) {
            var m;
            if (
              !this.shouldIgnoreSubstitutionInSimpleSubscript(g.options)
            ) {
              var T = g.options.autoCommands, G = T._maxLength || 0;
              if (G > 0) {
                for (
                  var B = (m = xr(this, G)) !== null && m !== void 0 ? m : "";
                  B.length;
                ) {
                  if (T.hasOwnProperty(B)) {
                    for (
                      var H = this, X = 1;
                      H && X < B.length;
                      X += 1, H = H[r]
                    );
                    new N(H, this).remove(), g[r] = H[r];
                    var ge = M[B], Oe;
                    return Z(ge) ? Oe = new ge(B) : Oe = ge(B),
                      Oe.createLeftOf(g);
                  }
                  B = B.slice(1);
                }
              }
            }
          },
            b.prototype.autoParenthesize = function (g) {
              var m = g.parent.getEnd(e);
              if (
                !(m && m instanceof Sl && m.ctrlSeq === "\\left(") &&
                !this.shouldIgnoreSubstitutionInSimpleSubscript(g.options)
              ) {
                for (
                  var T = "",
                    G = this,
                    B = 0,
                    H = g.options.autoParenthesizedFunctions,
                    X = H._maxLength || 0,
                    ge = g.options.autoOperatorNames;
                  G instanceof b && B < X;
                ) T = G.letter + T, G = G[r], B += 1;
                for (; T.length;) {
                  if (H.hasOwnProperty(T) && ge.hasOwnProperty(T)) {
                    return g.parent.write(g, "(");
                  }
                  T = T.slice(1);
                }
              }
            },
            b.prototype.createLeftOf = function (g) {
              D.prototype.createLeftOf.call(this, g),
                this.checkAutoCmds(g),
                this.autoParenthesize(g);
            },
            b.prototype.italicize = function (g) {
              return this.isItalic = g,
                this.isPartOfOperator = !g,
                g && (delete this.endsCategory, delete this.endsWord),
                this.domFrag().toggleClass("dcg-mq-operator-name", !g),
                this;
            },
            b.prototype.finalizeTree = function (g, m) {
              this.sharedSiblingMethod(g, m);
            },
            b.prototype.siblingDeleted = function (g, m) {
              this.sharedSiblingMethod(g, m);
            },
            b.prototype.siblingCreated = function (g, m) {
              this.sharedSiblingMethod(g, m);
            },
            b.prototype.sharedSiblingMethod = function (g, m) {
              m !== r && this[e] instanceof b || this.autoUnItalicize(g);
            },
            b.prototype.autoUnItalicize = function (g) {
              var m = g.autoOperatorNames;
              if (
                m._maxLength !== 0 &&
                !this.shouldIgnoreSubstitutionInSimpleSubscript(g)
              ) {
                for (
                  var T = this.letter, G = this[r];
                  G instanceof b;
                  G = G[r]
                ) T = G.letter + T;
                for (var B = this[e]; B instanceof b; B = B[e]) {
                  T += B.letter;
                }
                var H = G && G[e], X = B && B[r];
                new N(
                  H || this.parent.getEnd(r),
                  X || this.parent.getEnd(e),
                ).each(function (El) {
                  El instanceof b &&
                    (El.italicize(true).domFrag().removeClass(
                      "dcg-mq-first dcg-mq-last dcg-mq-followed-by-supsub",
                    ),
                      El.ctrlSeq = El.letter);
                });
                var ge = m._maxLength || 0;
                e: for (
                  var Oe = 0, Ae = G[e] || this.parent.getEnd(r);
                  Ae && Oe < T.length;
                  Oe += 1, Ae = Ae[e]
                ) {
                  for (var Ie = t(ge, T.length - Oe); Ie > 0; Ie -= 1) {
                    var qe = T.slice(Oe, Oe + Ie), He = void 0;
                    if (m.hasOwnProperty(qe)) {
                      for (
                        var lt = 0, gt = Ae;
                        lt < Ie;
                        lt += 1, gt = gt[e]
                      ) gt instanceof b && (gt.italicize(false), He = gt);
                      var At = Xo.hasOwnProperty(qe);
                      if (
                        Ae.ctrlSeq = (At ? "\\" : "\\operatorname{") +
                          Ae.ctrlSeq,
                          He.ctrlSeq += At ? " " : "}",
                          He.endsWord = qe,
                          g.infixOperatorNames[qe]
                            ? He.endsCategory = "infix"
                            : g.prefixOperatorNames[qe] &&
                              (He.endsCategory = "prefix"),
                          Zi.hasOwnProperty(qe)
                      ) {
                        var Gr = He[r],
                          wn = Gr && Gr[r],
                          $r = wn && wn[r];
                        $r.domFrag().addClass("dcg-mq-last");
                      }
                      if (
                        this.shouldOmitPadding(Ae[r]) ||
                        Ae.domFrag().addClass("dcg-mq-first"),
                          !this.shouldOmitPadding(He[e])
                      ) {
                        if (He[e] instanceof ac) {
                          var xi = He[e],
                            js = xi.siblingCreated =
                              xi.siblingDeleted =
                                function () {
                                  xi.domFrag().toggleClass(
                                    "dcg-mq-after-operator-name",
                                    !(xi[e] instanceof Sl),
                                  );
                                };
                          js();
                        } else {He.domFrag().toggleClass(
                            "dcg-mq-last",
                            !(He[e] instanceof Sl),
                          );}
                      }
                      Oe += Ie - 1, Ae = He;
                      continue e;
                    }
                  }
                }
              }
            },
            b.prototype.shouldOmitPadding = function (g) {
              return !!(!g || g.ctrlSeq === "." ||
                g instanceof pe && g.isBinaryOperator() ||
                g instanceof Uh);
            },
            b;
        }(Vt),
        Xo = {};
      fe.prototype.autoOperatorNames = na();
      var Zi = { limsup: 1, liminf: 1, projlim: 1, injlim: 1 };
      function na() {
        for (
          var D = { _maxLength: 9 },
            b =
              "arg deg det dim exp gcd hom inf ker lg lim ln log max min sup limsup liminf injlim projlim Pr"
                .split(" "),
            g = 0;
          g < b.length;
          g += 1
        ) Xo[b[g]] = D[b[g]] = 1;
        for (
          var m =
              "sin cos tan arcsin arccos arctan sinh cosh tanh sec csc cot coth"
                .split(" "),
            g = 0;
          g < m.length;
          g += 1
        ) Xo[m[g]] = 1;
        for (
          var T = "sin cos tan sec cosec csc cotan cot ctg".split(" "),
            g = 0;
          g < T.length;
          g += 1
        ) {
          D[T[g]] =
            D["arc" + T[g]] =
            D[T[g] + "h"] =
            D["ar" + T[g] + "h"] =
            D["arc" + T[g] + "h"] =
              1;
        }
        for (
          var G = "gcf hcf lcm proj span".split(" "), g = 0;
          g < G.length;
          g += 1
        ) D[G[g]] = 1;
        return D;
      }
      K.autoOperatorNames = function (D) {
        if (typeof D != "string") {
          throw '"' + D + '" not a space-delimited list';
        }
        if (!/^[a-z\|\-]+(?: [a-z\|\-]+)*$/i.test(D)) {
          throw '"' + D +
            '" not a space-delimited list of letters or "|"';
        }
        for (
          var b = D.split(" "), g = {}, m = 0, T = 0;
          T < b.length;
          T += 1
        ) {
          var G = b[T];
          if (G.length < 2) throw '"' + G + '" not minimum length of 2';
          if (G.indexOf("|") < 0) g[G] = G, m = o(m, G.length);
          else {
            var B = G.split("|");
            if (B.length > 2) {
              throw '"' + G + '" has more than 1 mathspeak delimiter';
            }
            if (B[0].length < 2) {
              throw '"' + G[0] + '" not minimum length of 2';
            }
            g[B[0]] = B[1].replace(/-/g, " "), m = o(m, B[0].length);
          }
        }
        return g._maxLength = m, g;
      },
        fe.prototype.infixOperatorNames = {},
        K.infixOperatorNames = xn,
        fe.prototype.prefixOperatorNames = {},
        K.prefixOperatorNames = xn,
        fe.prototype.disableAutoSubstitutionInSubscripts = false,
        K.disableAutoSubstitutionInSubscripts = function (D) {
          if (typeof D == "boolean") return D;
          if (typeof D != "object" || D === null || !("except" in D)) {
            throw '"' + D + '" not an object with property "except"';
          }
          return { except: xn(D.except) };
        };
      function xn(D) {
        if (typeof D != "string") {
          throw '"' + D + '" not a space-delimited list';
        }
        if (!/^[a-z]+(?: [a-z]+)*$/i.test(D)) {
          throw '"' + D + '" not a space-delimited list of letters';
        }
        for (var b = D.split(" "), g = {}, m = 0; m < b.length; m += 1) {
          var T = b[m];
          if (T.length < 2) throw '"' + T + '" not minimum length of 2';
          g[T] = true;
        }
        return g;
      }
      var Ho = function (D) {
        ht(b, D);
        function b(g) {
          return D.call(this, g || "") || this;
        }
        return b.prototype.createLeftOf = function (g) {
          for (var m = this.ctrlSeq, T = 0; T < m.length; T += 1) {
            new Zt(m.charAt(T)).createLeftOf(g);
          }
        },
          b.prototype.parser = function () {
            for (
              var g = this.ctrlSeq, m = new Te(), T = 0;
              T < g.length;
              T += 1
            ) new Zt(g.charAt(T)).adopt(m, m.getEnd(e), 0);
            return ce.succeed(m.children());
          },
          b;
      }(ft);
      for (var en in fe.prototype.autoOperatorNames) {
        fe.prototype.autoOperatorNames.hasOwnProperty(en) && (M[en] = Ho);
      }
      M.operatorname = function (D) {
        ht(b, D);
        function b() {
          return D !== null && D.apply(this, arguments) || this;
        }
        return b.prototype.createLeftOf = function () {},
          b.prototype.numBlocks = function () {
            return 1;
          },
          b.prototype.parser = function () {
            return j.block.map(function (g) {
              var m = true, T = "", G = g.children();
              return G.each(function (B) {
                B instanceof Zt ? T += B.letter : m = false;
              }),
                m && T === "ans" ? BR() : G;
            });
          },
          b;
      }(at),
        M.f = function (D) {
          ht(b, D);
          function b() {
            var g = this, m = "f";
            return g = D.call(this, m) || this,
              g.letter = m,
              g.domView = new Ue(0, function () {
                return c("var", { class: "dcg-mq-f" }, [c.text("f")]);
              }),
              g;
          }
          return b.prototype.italicize = function (g) {
            return this.domFrag().eachElement(function (m) {
              return m.textContent = "f";
            }),
              this.domFrag().toggleClass("dcg-mq-f", g),
              D.prototype.italicize.call(this, g);
          },
            b;
        }(Zt),
        M[" "] = M.space = function () {
          return new Qt("\\ ", c("span", {}, [c.text(p)]), " ");
        },
        M["."] = function () {
          return new Qt(
            ".",
            c("span", { class: "dcg-mq-digit" }, [c.text(".")]),
            ".",
          );
        },
        M["'"] = M.prime = J("'", "&prime;", "prime"),
        M["\u2033"] = M.dprime = J("\u2033", "&Prime;", "double prime"),
        M.backslash = J("\\backslash ", "\\", "backslash"),
        F["\\"] || (F["\\"] = M.backslash),
        M.$ = J("\\$", "$", "dollar"),
        M["\u25A1"] = M.square = J("\\square ", "\u25A1", "square"),
        M.mid = J("\\mid ", "\u2223", "mid");
      var Ws = function (D) {
        ht(b, D);
        function b(g, m, T) {
          return D.call(
            this,
            g,
            c("span", { class: "dcg-mq-nonSymbola" }, [m || c.text(g)]),
          ) || this;
        }
        return b;
      }(ft);
      M["@"] = function () {
        return new Ws("@");
      },
        M["&"] = function () {
          return new Ws("\\&", c.entityText("&amp;"), "and");
        },
        M["%"] = function (D) {
          ht(b, D);
          function b() {
            return D.call(this, "\\%", c.text("%"), "percent") || this;
          }
          return b.prototype.parser = function () {
            var g = ce.optWhitespace, m = ce.string;
            return g.then(
              m("\\operatorname{of}").map(function () {
                return UR();
              }),
            ).or(D.prototype.parser.call(this));
          },
            b;
        }(Ws),
        M["\u2225"] = M.parallel = J(
          "\\parallel ",
          "&#x2225;",
          "parallel",
        ),
        M["\u2226"] = M.nparallel = J(
          "\\nparallel ",
          "&#x2226;",
          "not parallel",
        ),
        M["\u27C2"] = M.perp = J("\\perp ", "&#x27C2;", "perpendicular");
      function po(D) {
        return Ct("\\" + D + " ", "&" + D + ";", D);
      }
      M. = M.alpha = po("alpha"),
        M. = M.beta = po("beta"),
        M. = M.gamma = po("gamma"),
        M. = M.delta = po("delta"),
        M. = M.zeta = po("zeta"),
        M. = M.eta = po("eta"),
        M. = M.theta = po("theta"),
        M. = M.iota = po("iota"),
        M. = M.kappa = po("kappa"),
        M. = M.mu = po("mu"),
        M. = M.nu = po("nu"),
        M. = M.xi = po("xi"),
        M. = M.rho = po("rho"),
        M. = M.sigma = po("sigma"),
        M. = M.tau = po("tau"),
        M. = M.chi = po("chi"),
        M. = M.psi = po("psi"),
        M. = M.omega = po("omega"),
        M. = M.phi = Ct("\\phi ", "&#981;", "phi"),
        M. = M.phiv = M.varphi = Ct("\\varphi ", "&phi;", "phi"),
        M["\u03F5"] = M.epsilon = Ct("\\epsilon ", "&#1013;", "epsilon"),
        M. = M.epsiv = M.varepsilon = Ct(
          "\\varepsilon ",
          "&epsilon;",
          "epsilon",
        ),
        M. = M.piv = M.varpi = Ct("\\varpi ", "&piv;", "piv"),
        M. =
          M.sigmaf =
          M.sigmav =
          M.varsigma =
            Ct("\\varsigma ", "&sigmaf;", "sigma"),
        M. =
          M.thetav =
          M.vartheta =
          M.thetasym =
            Ct("\\vartheta ", "&thetasym;", "theta"),
        M. = M.upsilon = M.upsi = Ct(
          "\\upsilon ",
          "&upsilon;",
          "upsilon",
        ),
        M. =
          M.gammad =
          M.Gammad =
          M.digamma =
            Ct("\\digamma ", "&#989;", "gamma"),
        M. = M.kappav = M.varkappa = Ct(
          "\\varkappa ",
          "&#1008;",
          "kappa",
        ),
        M. = M.rhov = M.varrho = Ct("\\varrho ", "&#1009;", "rho"),
        M.pi = M. = function () {
          return new Ws("\\pi ", c.entityText("&pi;"), "pi");
        },
        M. = M.lambda = function () {
          return new Ws("\\lambda ", c.entityText("&lambda;"), "lambda");
        },
        M. =
          M.Upsilon =
          M.Upsi =
          M.upsih =
          M.Upsih =
            function () {
              return new ft(
                "\\Upsilon ",
                c("var", { style: "font-family: serif" }, [
                  c.entityText("&upsih;"),
                ]),
                "capital upsilon",
              );
            };
      function Cl(D) {
        return function () {
          return new be("\\" + D + " ", c.entityText("&" + D + ";"));
        };
      }
      M. = M.Gamma = Cl("Gamma"),
        M. = M.Delta = Cl("Delta"),
        M. = M.Theta = Cl("Theta"),
        M. = M.Lambda = Cl("Lambda"),
        M. = M.Xi = Cl("Xi"),
        M. = M.Pi = Cl("Pi"),
        M. = M.Sigma = Cl("Sigma"),
        M. = M.Phi = Cl("Phi"),
        M. = M.Psi = Cl("Psi"),
        M. = M.Omega = Cl("Omega"),
        M["\u2200"] = M.forall = Cl("forall");
      var Un = function (D) {
        ht(b, D);
        function b(g) {
          var m = D.call(this) || this;
          return m.latexStr = g, m;
        }
        return b.prototype.createLeftOf = function (g) {
          var m = j.parse(this.latexStr);
          m.children().adopt(g.parent, g[r], g[e]),
            g[r] = m.getEnd(e),
            P(m.html()).insertBefore(g.domFrag()),
            m.finalizeInsert(g.options, g);
          var T = m.getEnd(e), G = T && T[e];
          G && G.siblingCreated(g.options, r);
          var B = m.getEnd(r), H = B && B[r];
          H && H.siblingCreated(g.options, e),
            g.parent.bubble(function (X) {
              X.reflow();
            });
        },
          b.prototype.mathspeak = function () {
            return j.parse(this.latexStr).mathspeak();
          },
          b.prototype.parser = function () {
            var g = j.parse(this.latexStr).children();
            return ce.succeed(g);
          },
          b;
      }(at);
      M["\u2070"] = function () {
        return new Un("^0");
      },
        M["\xB9"] = function () {
          return new Un("^1");
        },
        M["\xB2"] = function () {
          return new Un("^2");
        },
        M["\xB3"] = function () {
          return new Un("^3");
        },
        M["\u2074"] = function () {
          return new Un("^4");
        },
        M["\u2075"] = function () {
          return new Un("^5");
        },
        M["\u2076"] = function () {
          return new Un("^6");
        },
        M["\u2077"] = function () {
          return new Un("^7");
        },
        M["\u2078"] = function () {
          return new Un("^8");
        },
        M["\u2079"] = function () {
          return new Un("^9");
        },
        M["\xBC"] = function () {
          return new Un("\\frac14");
        },
        M["\xBD"] = function () {
          return new Un("\\frac12");
        },
        M["\xBE"] = function () {
          return new Un("\\frac34");
        },
        M["\u221A"] = function () {
          return new Un("\\sqrt{}");
        };
      function Jd(D) {
        return D instanceof pe ||
          D instanceof Zt && D.endsCategory == "infix";
      }
      function qc(D) {
        if (!D) return false;
        var b = D[r];
        if (b) {
          if (
            Jd(b) || b instanceof Zt && b.endsCategory == "prefix" ||
            !(b instanceof Sl) && /^(\\ )|[,;:\(\[]$/.test(b.ctrlSeq)
          ) return false;
        } else {return D.parent && D.parent.parent &&
              D.parent.parent.isStyleBlock()
            ? qc(D.parent.parent)
            : false;}
        return true;
      }
      var Na = function (D) {
        ht(b, D);
        function b(g, m, T) {
          return D.call(this, g, m, void 0, T, true) || this;
        }
        return b.prototype.isBinaryOperator = function () {
          return qc(this);
        },
          b.prototype.contactWeld = function (g, m) {
            this.sharedSiblingMethod(g.options, m);
          },
          b.prototype.siblingCreated = function (g, m) {
            this.sharedSiblingMethod(g, m);
          },
          b.prototype.siblingDeleted = function (g, m) {
            this.sharedSiblingMethod(g, m);
          },
          b.prototype.sharedSiblingMethod = function (g, m) {
            if (m !== e) {
              return this.domFrag().oneElement().className = qc(this)
                ? "dcg-mq-binary-operator"
                : "",
                this;
            }
          },
          b;
      }(pe);
      M["+"] = function (D) {
        ht(b, D);
        function b() {
          return D.call(this, "+", c.text("+")) || this;
        }
        return b.prototype.mathspeak = function () {
          return qc(this) ? "plus" : "positive";
        },
          b;
      }(Na);
      var Ex = function (D) {
        ht(b, D);
        function b() {
          return D.call(this, "-", c.entityText("&minus;")) || this;
        }
        return b.prototype.mathspeak = function () {
          return qc(this) ? "minus" : "negative";
        },
          b;
      }(Na);
      M["\u2212"] =
        M["\u2014"] =
        M["\u2013"] =
        M["-"] =
          Ex,
        M["\xB1"] =
          M.pm =
          M.plusmn =
          M.plusminus =
            function () {
              return new Na(
                "\\pm ",
                c.entityText("&plusmn;"),
                "plus-or-minus",
              );
            },
        M.mp = M.mnplus = M.minusplus = function () {
          return new Na(
            "\\mp ",
            c.entityText("&#8723;"),
            "minus-or-plus",
          );
        },
        F["*"] = M.sdot = M.cdot = Ne(
          "\\cdot ",
          "&middot;",
          "*",
          "times",
        );
      var Bh = function (D) {
        ht(b, D);
        function b() {
          return D.call(this, "\\to ", c.entityText("&rarr;"), "to") ||
            this;
        }
        return b.prototype.deleteTowards = function (g, m) {
          if (g === r) {
            var T = m[r];
            new N(T, this).remove(),
              m[r] = T[r],
              new Ex().createLeftOf(m),
              m[r].bubble(function (G) {
                G.reflow();
              });
            return;
          }
          D.prototype.deleteTowards.call(this, g, m);
        },
          b;
      }(pe);
      M["\u2192"] = M.to = Bh;
      var Qd = function (D) {
          ht(b, D);
          function b(g, m) {
            var T = this, G = m ? "Strict" : "";
            return T = D.call(
              this,
              g["ctrlSeq".concat(G)],
              c.entityText(g["htmlEntity".concat(G)]),
              g["text".concat(G)],
              g["mathspeak".concat(G)],
            ) || this,
              T.data = g,
              T.strict = m,
              T;
          }
          return b.prototype.swap = function (g) {
            this.strict = g;
            var m = g ? "Strict" : "";
            this.ctrlSeq = this.data["ctrlSeq".concat(m)],
              this.domFrag().children().replaceWith(
                P(c.entityText(this.data["htmlEntity".concat(m)])),
              ),
              this.textTemplate = [this.data["text".concat(m)]],
              this.mathspeakName = this.data["mathspeak".concat(m)];
          },
            b.prototype.deleteTowards = function (g, m) {
              if (g === r && !this.strict) {
                this.swap(true),
                  this.bubble(function (T) {
                    T.reflow();
                  });
                return;
              }
              D.prototype.deleteTowards.call(this, g, m);
            },
            b;
        }(pe),
        $s = {
          ctrlSeq: "\\le ",
          htmlEntity: "&le;",
          text: "\u2264",
          mathspeak: "less than or equal to",
          ctrlSeqStrict: "<",
          htmlEntityStrict: "&lt;",
          textStrict: "<",
          mathspeakStrict: "less than",
        },
        PR = {
          ctrlSeq: "\\ge ",
          htmlEntity: "&ge;",
          text: "\u2265",
          mathspeak: "greater than or equal to",
          ctrlSeqStrict: ">",
          htmlEntityStrict: "&gt;",
          textStrict: ">",
          mathspeakStrict: "greater than",
        },
        Fj = function (D) {
          ht(b, D);
          function b() {
            return D.call(this, PR, true) || this;
          }
          return b.prototype.createLeftOf = function (g) {
            var m = g[r];
            if (m instanceof pe && m.ctrlSeq === "-") {
              var T = m;
              g[r] = T[r],
                T.remove(),
                new Bh().createLeftOf(g),
                g[r].bubble(function (G) {
                  G.reflow();
                });
              return;
            }
            D.prototype.createLeftOf.call(this, g);
          },
            b;
        }(Qd);
      M["<"] = M.lt = function () {
        return new Qd($s, true);
      },
        M[">"] = M.gt = Fj,
        M["\u2264"] = M.le = M.leq = function () {
          return new Qd($s, false);
        },
        M["\u2265"] = M.ge = M.geq = function () {
          return new Qd(PR, false);
        },
        M["\u221E"] =
          M.infty =
          M.infin =
          M.infinity =
            J("\\infty ", "&infin;", "infinity"),
        M["\u2260"] = M.ne = M.neq = Ne("\\ne ", "&ne;", "not equal");
      var VR = function (D) {
        ht(b, D);
        function b() {
          return D.call(this, "=", c.text("="), "=", "equals") || this;
        }
        return b.prototype.createLeftOf = function (g) {
          var m = g[r];
          if (m instanceof Qd && m.strict) {
            m.swap(false),
              m.bubble(function (T) {
                T.reflow();
              });
            return;
          }
          D.prototype.createLeftOf.call(this, g);
        },
          b;
      }(pe);
      M["="] = VR,
        M["\xD7"] = M.times = M.cross = Ne(
          "\\times ",
          "&times;",
          "[x]",
          "times",
        ),
        M["\xF7"] =
          M.div =
          M.divide =
          M.divides =
            Ne("\\div ", "&divide;", "[/]", "over");
      var OR = function (D) {
          ht(b, D);
          function b() {
            return D.call(this, "\\sim ", c.text("~"), "~", "tilde") ||
              this;
          }
          return b.prototype.createLeftOf = function (g) {
            if (g[r] instanceof b) {
              var m = g[r];
              g[r] = m[r],
                m.remove(),
                new RR().createLeftOf(g),
                g[r].bubble(function (T) {
                  T.reflow();
                });
              return;
            }
            D.prototype.createLeftOf.call(this, g);
          },
            b;
        }(pe),
        RR = function (D) {
          ht(b, D);
          function b() {
            return D.call(
              this,
              "\\approx ",
              c.entityText("&approx;"),
              "\u2248",
              "approximately equal",
            ) || this;
          }
          return b.prototype.deleteTowards = function (g, m) {
            if (g === r) {
              var T = m[r];
              new N(T, this).remove(),
                m[r] = T[r],
                new OR().createLeftOf(m),
                m[r].bubble(function (G) {
                  G.reflow();
                });
              return;
            }
            D.prototype.deleteTowards.call(this, g, m);
          },
            b;
        }(pe);
      M.tildeNbsp = J("~", p, " "),
        M.sim = OR,
        M["\u2248"] = M.approx = RR,
        F["~"] = M.sim,
        M["~"] = M.tildeNbsp,
        K.interpretTildeAsSim = function (D) {
          var b = !!D;
          return b ? M["~"] = M.sim : M["~"] = M.tildeNbsp, b;
        },
        M["\u25EF"] = M.bigcirc = J("\\bigcirc ", "&#9711;", "circle"),
        M["\u2220"] = M.ang = M.angle = J("\\angle ", "&ang;", "angle"),
        M["\xB0"] = M.degree = J("\\degree ", "&deg;", "degrees"),
        M["\u25B3"] = M.triangle = J(
          "\\triangle ",
          "&#9651;",
          "triangle",
        ),
        M["\u2245"] = M.cong = Ne(
          "\\cong ",
          "&cong;",
          "cong",
          "congruent",
        ),
        M["\u2221"] = M.measuredangle = J(
          "\\measuredangle ",
          "&#8737;",
          "measured angle",
        ),
        M["\u25B1"] = M.parallelogram = J(
          "\\parallelogram ",
          "&#9649;",
          "parallelogram",
        ),
        M["\u2247"] = M.ncong = Ne(
          "\\ncong ",
          "&ncong;",
          "ncong",
          "not congruent",
        ),
        M["\u2241"] = M.nsim = Ne(
          "\\nsim ",
          "&nsim;",
          "nsim",
          "not similar",
        );
      var Tx = {
          sqrt: {
            width: "",
            html: function () {
              return c("svg", {
                preserveAspectRatio: "none",
                viewBox: "0 0 32 54",
              }, [
                c("path", {
                  d: "M0 33 L7 27 L12.5 47 L13 47 L30 0 L32 0 L13 54 L11 54 L4.5 31 L0 33",
                }),
              ]);
            },
          },
          "|": {
            width: ".4em",
            html: function () {
              return c("svg", {
                preserveAspectRatio: "none",
                viewBox: "0 0 10 54",
              }, [c("path", { d: "M4.4 0 L4.4 54 L5.6 54 L5.6 0" })]);
            },
          },
          "[": {
            width: ".55em",
            html: function () {
              return c("svg", {
                preserveAspectRatio: "none",
                viewBox: "0 0 11 24",
              }, [
                c("path", {
                  d: "M8 0 L3 0 L3 24 L8 24 L8 23 L4 23 L4 1 L8 1",
                }),
              ]);
            },
          },
          "]": {
            width: ".55em",
            html: function () {
              return c("svg", {
                preserveAspectRatio: "none",
                viewBox: "0 0 11 24",
              }, [
                c("path", {
                  d: "M3 0 L8 0 L8 24 L3 24 L3 23 L7 23 L7 1 L3 1",
                }),
              ]);
            },
          },
          "(": {
            width: ".55em",
            html: function () {
              return c("svg", {
                preserveAspectRatio: "none",
                viewBox: "3 0 106 186",
              }, [
                c("path", {
                  d: "M85 0 A61 101 0 0 0 85 186 L75 186 A75 101 0 0 1 75 0",
                }),
              ]);
            },
          },
          ")": {
            width: ".55em",
            html: function () {
              return c("svg", {
                preserveAspectRatio: "none",
                viewBox: "3 0 106 186",
              }, [
                c("path", {
                  d: "M24 0 A61 101 0 0 1 24 186 L34 186 A75 101 0 0 0 34 0",
                }),
              ]);
            },
          },
          "{": {
            width: ".7em",
            html: function () {
              return c("svg", {
                preserveAspectRatio: "none",
                viewBox: "10 0 210 350",
              }, [c("path", {
                d: "M170 0 L170 6 A47 52 0 0 0 123 60 L123 127 A35 48 0 0 1 88 175 A35 48 0 0 1 123 223 L123 290 A47 52 0 0 0 170 344 L170 350 L160 350 A58 49 0 0 1 102 301 L103 220 A45 40 0 0 0 58 180 L58 170 A45 40 0 0 0 103 130 L103 49 A58 49 0 0 1 161 0",
              })]);
            },
          },
          "}": {
            width: ".7em",
            html: function () {
              return c("svg", {
                preserveAspectRatio: "none",
                viewBox: "10 0 210 350",
              }, [c("path", {
                d: "M60 0 L60 6 A47 52 0 0 1 107 60 L107 127 A35 48 0 0 0 142 175 A35 48 0 0 0 107 223 L107 290 A47 52 0 0 1 60 344 L60 350 L70 350 A58 49 0 0 0 128 301 L127 220 A45 40 0 0 1 172 180 L172 170 A45 40 0 0 1 127 130 L127 49 A58 49 0 0 0 70 0",
              })]);
            },
          },
          "&#8741;": {
            width: ".7em",
            html: function () {
              return c("svg", {
                preserveAspectRatio: "none",
                viewBox: "0 0 10 54",
              }, [
                c("path", {
                  d: "M3.2 0 L3.2 54 L4 54 L4 0 M6.8 0 L6.8 54 L6 54 L6 0",
                }),
              ]);
            },
          },
          "&lang;": {
            width: ".55em",
            html: function () {
              return c("svg", {
                preserveAspectRatio: "none",
                viewBox: "0 0 10 54",
              }, [
                c("path", {
                  d: "M6.8 0 L3.2 27 L6.8 54 L7.8 54 L4.2 27 L7.8 0",
                }),
              ]);
            },
          },
          "&rang;": {
            width: ".55em",
            html: function () {
              return c("svg", {
                preserveAspectRatio: "none",
                viewBox: "0 0 10 54",
              }, [
                c("path", {
                  d: "M3.2 0 L6.8 27 L3.2 54 L2.2 54 L5.8 27 L2.2 0",
                }),
              ]);
            },
          },
        },
        W1 = "\u27A4",
        nc = function (D) {
          ht(b, D);
          function b(g, m, T, G, B) {
            var H = D.call(
              this,
              g,
              new Ue(1, function (X) {
                var ge, Oe;
                return c.block(m, T, X[0], {
                  beforeChild:
                    (ge = B == null ? void 0 : B.beforeChild) === null ||
                      ge === void 0
                      ? void 0
                      : ge.call(B),
                  afterChild:
                    (Oe = B == null ? void 0 : B.afterChild) === null ||
                      Oe === void 0
                      ? void 0
                      : Oe.call(B),
                });
              }),
            ) || this;
            return H.ariaLabel = G || g.replace(/^\\/, ""),
              H.mathspeakTemplate = [
                "Start" + H.ariaLabel + ",",
                "End" + H.ariaLabel,
              ],
              H.shouldNotSpeakDelimiters = B &&
                B.shouldNotSpeakDelimiters,
              H;
          }
          return b.prototype.mathspeak = function (g) {
            return !this.shouldNotSpeakDelimiters ||
                g && g.ignoreShorthand
              ? D.prototype.mathspeak.call(this)
              : this.foldChildren("", function (m, T) {
                return m + " " + T.mathspeak(g);
              }).trim();
          },
            b;
        }(at);
      M.mathrm = function (D) {
        ht(b, D);
        function b() {
          return D.call(
            this,
            "\\mathrm",
            "span",
            { class: "dcg-mq-roman dcg-mq-font" },
            "Roman Font",
            { shouldNotSpeakDelimiters: true },
          ) || this;
        }
        return b.prototype.isTextBlock = function () {
          return true;
        },
          b;
      }(nc),
        M.mathit = function () {
          return new nc(
            "\\mathit",
            "i",
            { class: "dcg-mq-font" },
            "Italic Font",
          );
        },
        M.mathbf = function () {
          return new nc(
            "\\mathbf",
            "b",
            { class: "dcg-mq-font" },
            "Bold Font",
          );
        },
        M.mathsf = function () {
          return new nc("\\mathsf", "span", {
            class: "dcg-mq-sans-serif dcg-mq-font",
          }, "Serif Font");
        },
        M.mathtt = function () {
          return new nc("\\mathtt", "span", {
            class: "dcg-mq-monospace dcg-mq-font",
          }, "Math Text");
        },
        M.underline = function () {
          return new nc("\\underline", "span", {
            class: "dcg-mq-non-leaf dcg-mq-underline",
          }, "Underline");
        },
        M.overline = M.bar = function () {
          return new nc("\\overline", "span", {
            class: "dcg-mq-non-leaf dcg-mq-overline",
          }, "Overline");
        },
        M.overrightarrow = function () {
          return new nc(
            "\\overrightarrow",
            "span",
            { class: "dcg-mq-non-leaf dcg-mq-overarrow" },
            "Over Right Arrow",
            {
              afterChild: function () {
                return c(
                  "span",
                  { class: "dcg-mq-arrow-right-content" },
                  [c.text(W1)],
                );
              },
            },
          );
        },
        M.overleftarrow = function () {
          return new nc(
            "\\overleftarrow",
            "span",
            { class: "dcg-mq-non-leaf dcg-mq-overarrow" },
            "Over Left Arrow",
            {
              beforeChild: function () {
                return c("span", { class: "dcg-mq-arrow-left-content" }, [
                  c.text(W1),
                ]);
              },
            },
          );
        },
        M.overleftrightarrow = function () {
          return new nc(
            "\\overleftrightarrow ",
            "span",
            { class: "dcg-mq-non-leaf dcg-mq-overarrow" },
            "Over Left and Right Arrow",
            {
              beforeChild: function () {
                return c("span", { class: "dcg-mq-arrow-left-content" }, [
                  c.text(W1),
                ]);
              },
              afterChild: function () {
                return c(
                  "span",
                  { class: "dcg-mq-arrow-right-content" },
                  [c.text(W1)],
                );
              },
            },
          );
        },
        M.overarc = function () {
          return new nc("\\overarc", "span", {
            class: "dcg-mq-non-leaf dcg-mq-overarc",
          }, "Over Arc");
        },
        M.dot = function () {
          return new at(
            "\\dot",
            new Ue(1, function (D) {
              return c("span", { class: "dcg-mq-non-leaf" }, [
                c("span", { class: "dcg-mq-dot-recurring-inner" }, [
                  c("span", { class: "dcg-mq-dot-recurring" }, [
                    c.text(u),
                  ]),
                  c.block("span", { class: "dcg-mq-empty-box" }, D[0]),
                ]),
              ]);
            }),
          );
        },
        M.textcolor = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.setColor = function (g) {
            this.color = g,
              this.domView = new Ue(1, function (m) {
                return c.block("span", {
                  class: "dcg-mq-textcolor",
                  style: "color:" + g,
                }, m[0]);
              }),
              this.ariaLabel = g.replace(/^\\/, ""),
              this.mathspeakTemplate = [
                "Start " + this.ariaLabel + ",",
                "End " + this.ariaLabel,
              ];
          },
            b.prototype.latexRecursive = function (g) {
              this.checkCursorContextOpen(g);
              var m = this.blocks[0];
              g.latex += "\\textcolor{" + this.color + "}{",
                m.latexRecursive(g),
                g.latex += "}",
                this.checkCursorContextClose(g);
            },
            b.prototype.parser = function () {
              var g = this,
                m = ce.optWhitespace,
                T = ce.string,
                G = ce.regex;
              return m.then(T("{")).then(G(/^[#\w\s.,()%-]*/)).skip(
                T("}"),
              ).then(function (B) {
                return g.setColor(B), D.prototype.parser.call(g);
              });
            },
            b.prototype.isStyleBlock = function () {
              return true;
            },
            b;
        }(at);
      var Hpe = M.class = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.parser = function () {
            var g = this, m = ce.string, T = ce.regex;
            return ce.optWhitespace.then(m("{")).then(
              T(/^[-\w\s\\\xA0-\xFF]*/),
            ).skip(m("}")).then(function (G) {
              return g.cls = G || "",
                g.domView = new Ue(1, function (B) {
                  return c.block("span", {
                    class: "dcg-mq-class ".concat(G),
                  }, B[0]);
                }),
                g.ariaLabel = G + " class",
                g.mathspeakTemplate = [
                  "Start " + g.ariaLabel + ",",
                  "End " + g.ariaLabel,
                ],
                D.prototype.parser.call(g);
            });
          },
            b.prototype.latexRecursive = function (g) {
              this.checkCursorContextOpen(g);
              var m = this.blocks[0];
              g.latex += "\\class{" + this.cls + "}{",
                m.latexRecursive(g),
                g.latex += "}",
                this.checkCursorContextClose(g);
            },
            b.prototype.isStyleBlock = function () {
              return true;
            },
            b;
        }(at),
        $1 = /^[\+\-]?[\d]+$/;
      function IA(D) {
        if (!D) return "";
        var b = "";
        return D.eachChild(function (g) {
          g.ctrlSeq !== void 0 && (b += g.ctrlSeq);
        }),
          b;
      }
      fe.prototype.charsThatBreakOutOfSupSub = "";
      var ac = function (D) {
        ht(b, D);
        function b() {
          var g = D !== null && D.apply(this, arguments) || this;
          return g.ctrlSeq = "_{...}^{...}", g;
        }
        return b.prototype.setEnds = function (g) {
          a(
            "SupSub ends must be MathBlocks",
            g[r] instanceof Te && g[e] instanceof Te,
          ), this.ends = g;
        },
          b.prototype.getEnd = function (g) {
            return this.ends[g];
          },
          b.prototype.createLeftOf = function (g) {
            if (
              !(!this.replacedFragment && !g[r] &&
                g.options.supSubsRequireOperand)
            ) return D.prototype.createLeftOf.call(this, g);
          },
          b.prototype.contactWeld = function (g) {
            for (var m = r; m; m = m === r ? e : false) {
              var T = this[m], G = void 0;
              if (T instanceof b) {
                for (var B = "sub"; B; B = B === "sub" ? "sup" : false) {
                  var H = this[B], X = T[B];
                  if (H) {
                    if (!X) T.addBlock(H.disown());
                    else if (H.isEmpty()) G = new z(X, 0, X.getEnd(r));
                    else {
                      H.domFrag().children().insAtDirEnd(
                        -m,
                        X.domFrag().oneElement(),
                      );
                      var ge = H.children().disown();
                      G = new z(X, ge.getEnd(e), X.getEnd(r)),
                        m === r
                          ? ge.adopt(X, X.getEnd(e), 0)
                          : ge.adopt(X, 0, X.getEnd(r));
                    }
                    this.placeCursor = function (Oe, Ae) {
                      return function (Ie) {
                        Ie.insAtDirEnd(-m, Oe || Ae);
                      };
                    }(X, H);
                  }
                }
                this.remove(),
                  g && g[r] === this &&
                  (m === e && G
                    ? G[r] ? g.insRightOf(G[r]) : g.insAtLeftEnd(G.parent)
                    : g.insRightOf(T));
                break;
              }
            }
          },
          b.prototype.finalizeTree = function () {
            var g = this.getEnd(r);
            g.write = function (m, T) {
              if (
                m.options.autoSubscriptNumerals &&
                this === this.parent.sub && "0123456789".indexOf(T) >= 0
              ) {
                var G = this.chToCmd(T, m.options);
                G instanceof ft
                  ? m.deleteSelection()
                  : m.clearSelection().insRightOf(this.parent),
                  G.createLeftOf(m.show()),
                  m.controller.aria.queue("Baseline").alert(
                    G.mathspeak({ createdLeftOf: m }),
                  );
                return;
              }
              m[r] && !m[e] && !m.selection &&
              m.options.charsThatBreakOutOfSupSub.indexOf(T) > -1 &&
              (m.insRightOf(this.parent), m.controller.aria.queue("Baseline")),
                Te.prototype.write.call(this, m, T);
            };
          },
          b.prototype.moveTowards = function (g, m, T) {
            m.options.autoSubscriptNumerals && !this.sup
              ? m.insDirOf(g, this)
              : D.prototype.moveTowards.call(this, g, m, T);
          },
          b.prototype.deleteTowards = function (g, m) {
            if (m.options.autoSubscriptNumerals && this.sub) {
              var T = this.sub.getEnd(-g);
              T instanceof ft
                ? T.remove()
                : T && T.deleteTowards(g, m.insAtDirEnd(-g, this.sub)),
                this.sub.isEmpty() &&
                (this.sub.deleteOutOf(r, m.insAtLeftEnd(this.sub)),
                  this.sup && m.insDirOf(-g, this));
            } else D.prototype.deleteTowards.call(this, g, m);
          },
          b.prototype.latexRecursive = function (g) {
            if (this.checkCursorContextOpen(g), this.sub) {
              g.latex += "_{";
              var m = g.latex.length;
              this.sub.latexRecursive(g);
              var T = g.latex.length;
              m === T && (g.latex += " "), g.latex += "}";
            }
            if (this.sup) {
              g.latex += "^{";
              var m = g.latex.length;
              this.sup.latexRecursive(g);
              var T = g.latex.length;
              m === T && (g.latex += " "), g.latex += "}";
            }
            this.checkCursorContextClose(g);
          },
          b.prototype.text = function () {
            function g(m, T) {
              var G = T && T.text() || "";
              return T ? m + (G.length === 1 ? G : "(" + (G || " ") + ")") : "";
            }
            return g("_", this.sub) + g("^", this.sup);
          },
          b.prototype.addBlock = function (g) {
            this.supsub === "sub"
              ? (this.sup = this.upInto = this.sub.upOutOf = g,
                g.adopt(this, this.sub, 0).downOutOf = this.sub,
                g.setDOM(
                  P(c("span", { class: "dcg-mq-sup" })).append(
                    g.domFrag().children(),
                  ).prependTo(this.domFrag().oneElement()).oneElement(),
                ),
                V.linkElementByBlockNode(g.domFrag().oneElement(), g))
              : (this.sub = this.downInto = this.sup.downOutOf = g,
                g.adopt(this, 0, this.sup).upOutOf = this.sup,
                this.domFrag().removeClass("dcg-mq-sup-only"),
                g.setDOM(
                  P(c("span", { class: "dcg-mq-sub" })).append(
                    g.domFrag().children(),
                  ).appendTo(this.domFrag().oneElement()).oneElement(),
                ),
                V.linkElementByBlockNode(g.domFrag().oneElement(), g),
                this.domFrag().append(
                  P(c("span", { style: "display:inline-block;width:0" }, [
                    c.text(h),
                  ])),
                ));
            for (var m = 0; m < 2; m += 1) {
              (function (T, G, B, H) {
                var X = T[G];
                X.deleteOutOf = function (ge, Oe) {
                  if (
                    Oe.insDirOf(this[ge] ? -ge : ge, this.parent),
                      !this.isEmpty()
                  ) {
                    var Ae = this.getEnd(ge);
                    this.children().disown().withDirAdopt(
                      ge,
                      Oe.parent,
                      Oe[ge],
                      Oe[-ge],
                    ).domFrag().insDirOf(-ge, Oe.domFrag()), Oe[-ge] = Ae;
                  }
                  T.supsub = B, delete T[G], delete T["".concat(H, "Into")];
                  var Ie = T[B];
                  Ie["".concat(H, "OutOf")] = AA,
                    delete Ie.deleteOutOf,
                    G === "sub" &&
                    T.domFrag().addClass("dcg-mq-sup-only").children()
                      .last().remove(),
                    this.remove();
                };
              })(
                this,
                "sub sup".split(" ")[m],
                "sup sub".split(" ")[m],
                "down up".split(" ")[m],
              );
            }
          },
          b;
      }(at);
      function AA(D) {
        var b = this.parent, g = D;
        do {
          if (g[e]) return D.insLeftOf(b);
          g = g.parent.parent;
        } while (g !== b);
        D.insRightOf(b);
      }
      var FR = function (D) {
        ht(b, D);
        function b() {
          var g = D !== null && D.apply(this, arguments) || this;
          return g.supsub = "sub",
            g.domView = new Ue(1, function (m) {
              return c(
                "span",
                { class: "dcg-mq-supsub dcg-mq-non-leaf" },
                [
                  c.block("span", { class: "dcg-mq-sub" }, m[0]),
                  c("span", { style: "display:inline-block;width:0" }, [
                    c.text(h),
                  ]),
                ],
              );
            }),
            g.textTemplate = ["_"],
            g.mathspeakTemplate = ["Subscript,", ", Baseline"],
            g.ariaLabel = "subscript",
            g;
        }
        return b.prototype.finalizeTree = function () {
          this.downInto = this.sub = this.getEnd(r),
            this.sub.upOutOf = AA,
            D.prototype.finalizeTree.call(this);
        },
          b;
      }(ac);
      M.subscript = M._ = FR,
        M.superscript = M.supscript = M["^"] = function (D) {
          ht(b, D);
          function b() {
            var g = D !== null && D.apply(this, arguments) || this;
            return g.supsub = "sup",
              g.domView = new Ue(1, function (m) {
                return c("span", {
                  class: "dcg-mq-supsub dcg-mq-non-leaf dcg-mq-sup-only",
                }, [c.block("span", { class: "dcg-mq-sup" }, m[0])]);
              }),
              g.textTemplate = ["^(", ")"],
              g.ariaLabel = "superscript",
              g.mathspeakTemplate = ["Superscript,", ", Baseline"],
              g;
          }
          return b.prototype.mathspeak = function (g) {
            var m = this.upInto;
            if (m !== void 0) {
              var T = IA(m);
              if ((!g || !g.ignoreShorthand) && $1.test(T)) {
                if (T === "0") return "to the 0 power";
                if (T === "2") return "squared";
                if (T === "3") return "cubed";
                var G = "";
                /^[+-]?\d{1,3}$/.test(T) &&
                  (/(11|12|13|4|5|6|7|8|9|0)$/.test(T)
                    ? G = "th"
                    : /1$/.test(T)
                    ? G = "st"
                    : /2$/.test(T)
                    ? G = "nd"
                    : /3$/.test(T) && (G = "rd"));
                var B = typeof m == "object" ? m.mathspeak() : T;
                return "to the " + B + G + " power";
              }
            }
            return D.prototype.mathspeak.call(this);
          },
            b.prototype.finalizeTree = function () {
              this.upInto = this.sup = this.getEnd(e),
                this.sup.downOutOf = AA,
                D.prototype.finalizeTree.call(this);
            },
            b;
        }(ac);
      var Uh = function (D) {
        ht(b, D);
        function b(g, m, T) {
          var G = D.call(this) || this;
          G.ariaLabel = T || g.replace(/^\\/, "");
          var B = new Ue(2, function (H) {
            return c("span", {
              class: "dcg-mq-large-operator dcg-mq-non-leaf",
            }, [
              c("span", { class: "dcg-mq-to" }, [
                c.block("span", {}, H[1]),
              ]),
              c("big", {}, [c.text(m)]),
              c("span", { class: "dcg-mq-from" }, [
                c.block("span", {}, H[0]),
              ]),
            ]);
          });
          return ft.prototype.setCtrlSeqHtmlTextAndMathspeak.call(
            G,
            g,
            B,
          ),
            G;
        }
        return b.prototype.createLeftOf = function (g) {
          D.prototype.createLeftOf.call(this, g),
            g.options.sumStartsWithNEquals &&
            (new Zt("n").createLeftOf(g), new VR().createLeftOf(g));
        },
          b.prototype.latexRecursive = function (g) {
            this.checkCursorContextOpen(g), g.latex += this.ctrlSeq + "_{";
            var m = g.latex.length;
            this.getEnd(r).latexRecursive(g);
            var T = g.latex.length;
            T === m && (g.latex += " "),
              g.latex += "}^{",
              m = g.latex.length,
              this.getEnd(e).latexRecursive(g),
              T = g.latex.length,
              m === T && (g.latex += " "),
              g.latex += "}",
              this.checkCursorContextClose(g);
          },
          b.prototype.mathspeak = function () {
            return "Start " + this.ariaLabel + " from " +
              this.getEnd(r).mathspeak() + " to " +
              this.getEnd(e).mathspeak() + ", end " + this.ariaLabel +
              ", ";
          },
          b.prototype.parser = function () {
            for (
              var g = ce.string,
                m = ce.optWhitespace,
                T = ce.succeed,
                G = j.block,
                B = this,
                H = B.blocks = [new Te(), new Te()],
                X = 0;
              X < H.length;
              X += 1
            ) H[X].adopt(B, B.getEnd(e), 0);
            return m.then(g("_").or(g("^"))).then(function (ge) {
              var Oe = H[ge === "_" ? 0 : 1];
              return G.then(function (Ae) {
                return Ae.children().adopt(Oe, Oe.getEnd(e), 0), T(B);
              });
            }).many().result(B);
          },
          b.prototype.finalizeTree = function () {
            var g = this.getEnd(r), m = this.getEnd(e);
            g.ariaLabel = "lower bound",
              m.ariaLabel = "upper bound",
              this.downInto = g,
              this.upInto = m,
              g.upOutOf = m,
              m.downOutOf = g;
          },
          b;
      }(at);
      M["\u2211"] = M.sum = M.summation = function () {
        return new Uh("\\sum ", f, "sum");
      },
        M["\u220F"] = M.prod = M.product = function () {
          return new Uh("\\prod ", y, "product");
        },
        M.coprod = M.coproduct = function () {
          return new Uh("\\coprod ", C, "co product");
        },
        M["\u222B"] = M.int = M.integral = function (D) {
          ht(b, D);
          function b() {
            var g = D.call(this, "\\int ", "", "integral") || this;
            return g.ariaLabel = "integral",
              g.domView = new Ue(2, function (m) {
                return c(
                  "span",
                  { class: "dcg-mq-int dcg-mq-non-leaf" },
                  [
                    c("big", {}, [c.text(E)]),
                    c(
                      "span",
                      { class: "dcg-mq-supsub dcg-mq-non-leaf" },
                      [
                        c("span", { class: "dcg-mq-sup" }, [
                          c.block(
                            "span",
                            { class: "dcg-mq-sup-inner" },
                            m[1],
                          ),
                        ]),
                        c.block("span", { class: "dcg-mq-sub" }, m[0]),
                        c("span", {
                          style: "display:inline-block;width:0",
                        }, [c.text(h)]),
                      ],
                    ),
                  ],
                );
              }),
              g;
          }
          return b.prototype.createLeftOf = function (g) {
            at.prototype.createLeftOf.call(this, g);
          },
            b;
        }(Uh);
      var NR = M.frac =
          M.dfrac =
          M.cfrac =
          M.fraction =
            function (D) {
              ht(b, D);
              function b() {
                var g = D !== null && D.apply(this, arguments) || this;
                return g.ctrlSeq = "\\frac",
                  g.domView = new Ue(2, function (m) {
                    return c("span", {
                      class: "dcg-mq-fraction dcg-mq-non-leaf",
                    }, [
                      c.block(
                        "span",
                        { class: "dcg-mq-numerator" },
                        m[0],
                      ),
                      c.block(
                        "span",
                        { class: "dcg-mq-denominator" },
                        m[1],
                      ),
                      c(
                        "span",
                        { style: "display:inline-block;width:0" },
                        [c.text(h)],
                      ),
                    ]);
                  }),
                  g.textTemplate = ["(", ")/(", ")"],
                  g;
              }
              return b.prototype.finalizeTree = function () {
                var g = this.getEnd(r), m = this.getEnd(e);
                this.upInto = m.upOutOf = g,
                  this.downInto = g.downOutOf = m,
                  g.ariaLabel = "numerator",
                  m.ariaLabel = "denominator",
                  this.getFracDepth() > 1
                    ? this.mathspeakTemplate = [
                      "StartNestedFraction,",
                      "NestedOver",
                      ", EndNestedFraction",
                    ]
                    : this.mathspeakTemplate = [
                      "StartFraction,",
                      "Over",
                      ", EndFraction",
                    ];
              },
                b.prototype.mathspeak = function (g) {
                  if (g && g.createdLeftOf) {
                    var m = g.createdLeftOf;
                    return m.parent.mathspeak();
                  }
                  var T = IA(this.getEnd(r)), G = IA(this.getEnd(e));
                  if (
                    (!g || !g.ignoreShorthand) && $1.test(T) && $1.test(G)
                  ) {
                    var B = T === "1" || T === "-1", H = "";
                    if (
                      G === "2"
                        ? H = B ? "half" : "halves"
                        : G === "3"
                        ? H = B ? "third" : "thirds"
                        : G === "4"
                        ? H = B ? "quarter" : "quarters"
                        : G === "5"
                        ? H = B ? "fifth" : "fifths"
                        : G === "6"
                        ? H = B ? "sixth" : "sixths"
                        : G === "7"
                        ? H = B ? "seventh" : "sevenths"
                        : G === "8"
                        ? H = B ? "eighth" : "eighths"
                        : G === "9" && (H = B ? "ninth" : "ninths"), H !== ""
                    ) {
                      for (
                        var X = "", ge = false, Oe = this[r];
                        Oe && Oe[r] !== void 0;
                        Oe = Oe[r]
                      ) {
                        if (Oe.ctrlSeq !== "\\ ") {
                          if ($1.test(Oe.ctrlSeq || "")) {
                            ge = true;
                          } else {
                            ge = false;
                            break;
                          }
                        }
                      }
                      return ge && (X += "and "),
                        X += this.getEnd(r).mathspeak() + " " + H,
                        X;
                    }
                  }
                  return D.prototype.mathspeak.call(this);
                },
                b.prototype.getFracDepth = function () {
                  var g = 0,
                    m = function (T, G) {
                      return T instanceof Dt && T.ctrlSeq &&
                        T.ctrlSeq.toLowerCase().search("frac") >= 0 &&
                        (G += 1),
                        T && T.parent ? m(T.parent, G) : G;
                    };
                  return m(this, g);
                },
                b;
            }(at),
        Nj = M.over = F["/"] = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.createLeftOf = function (g) {
            if (!this.replacedFragment) {
              var m = g[r],
                T = g.options.typingSlashCreatesNewFraction &&
                  this instanceof NR;
              if (!T) {
                for (
                  ;
                  m &&
                  !(Jd(m) ||
                    m instanceof Qt &&
                      m._groupingClass === "dcg-mq-ellipsis-end" ||
                    m instanceof (M.text || i) || m instanceof Uh ||
                    m.ctrlSeq === "\\ " || /^[,;:]$/.test(m.ctrlSeq));
                ) m = m[r];
              }
              if (m instanceof Uh && m[e] instanceof ac) {
                m = m[e];
                var G = m[e];
                G instanceof ac && G.ctrlSeq != m.ctrlSeq && (m = m[e]);
              }
              if (m !== g[r] && !g.isTooDeep(1)) {
                var G = m[e], B = g[r];
                this.replaces(new N(G || g.parent.getEnd(r), B)), g[r] = m;
              }
            }
            D.prototype.createLeftOf.call(this, g);
          },
            b;
        }(NR),
        BR = function () {
          return new ft(
            "\\operatorname{ans}",
            c("span", { class: "dcg-mq-ans" }, [c.text("ans")]),
            "ans",
          );
        };
      M.ans = BR;
      var UR = function () {
        return new ft(
          "\\%\\operatorname{of}",
          c("span", { class: "dcg-mq-nonSymbola dcg-mq-operator-name" }, [
            c.text("% of "),
          ]),
          "percent of",
        );
      };
      M.percent = M.percentof = UR;
      var Bj = function (D) {
        ht(b, D);
        function b() {
          var g = D !== null && D.apply(this, arguments) || this;
          return g.tokenId = "",
            g.ctrlSeq = "\\token",
            g.textTemplate = ["token(", ")"],
            g.mathspeakTemplate = ["StartToken,", ", EndToken"],
            g.ariaLabel = "token",
            g;
        }
        return b.prototype.html = function () {
          var g = c("span", {
            class: "dcg-mq-token dcg-mq-ignore-mousedown",
            "data-dcg-mq-token": this.tokenId,
          });
          return this.setDOM(g), V.linkElementByCmdNode(g, this), g;
        },
          b.prototype.latexRecursive = function (g) {
            this.checkCursorContextOpen(g),
              g.latex += "\\token{" + this.tokenId + "}",
              this.checkCursorContextClose(g);
          },
          b.prototype.mathspeak = function () {
            var g = [];
            return this.domFrag().children().eachElement(function (m) {
              var T = m.getAttribute("aria-label");
              typeof T == "string" && T !== "" && g.push(T);
            }),
              g.length > 0 ? g.join(" ").trim() : "token " + this.tokenId;
          },
          b.prototype.parser = function () {
            var g = this;
            return j.block.map(function (m) {
              var T = m.getEnd(r);
              if (T) {
                for (g.tokenId += T.ctrlSeq; T = T[e];) {
                  g.tokenId += T.ctrlSeq;
                }
              }
              return g;
            });
          },
          b;
      }(ft);
      M.token = Bj;
      var zR = function (D) {
        ht(b, D);
        function b() {
          var g = D !== null && D.apply(this, arguments) || this;
          return g.ctrlSeq = "\\sqrt",
            g.domView = new Ue(1, function (m) {
              return c("span", {
                class: "dcg-mq-non-leaf dcg-mq-sqrt-container",
              }, [
                c("span", { class: "dcg-mq-scaled dcg-mq-sqrt-prefix" }, [
                  Tx.sqrt.html(),
                ]),
                c.block("span", {
                  class: "dcg-mq-non-leaf dcg-mq-sqrt-stem",
                }, m[0]),
              ]);
            }),
            g.textTemplate = ["sqrt(", ")"],
            g.mathspeakTemplate = ["StartRoot,", ", EndRoot"],
            g.ariaLabel = "root",
            g;
        }
        return b.prototype.parser = function () {
          return j.optBlock.then(function (g) {
            return j.block.map(function (m) {
              var T = new MA();
              return T.blocks = [g, m], g.adopt(T, 0, 0), m.adopt(T, g, 0), T;
            });
          }).or(D.prototype.parser.call(this));
        },
          b.prototype.deleteTowards = function (g, m) {
            if (!this.isEmpty() && g === 1) {
              this.moveTowards(e, m), m.parent.deleteOutOf(r, m);
              return;
            }
            D.prototype.deleteTowards.call(this, g, m);
          },
          b;
      }(at);
      M.sqrt = zR,
        M.hat = function (D) {
          ht(b, D);
          function b() {
            var g = D !== null && D.apply(this, arguments) || this;
            return g.ctrlSeq = "\\hat",
              g.domView = new Ue(1, function (m) {
                return c("span", { class: "dcg-mq-non-leaf" }, [
                  c("span", { class: "dcg-mq-hat-prefix" }, [
                    c.text("^"),
                  ]),
                  c.block("span", { class: "dcg-mq-hat-stem" }, m[0]),
                ]);
              }),
              g.textTemplate = ["hat(", ")"],
              g;
          }
          return b;
        }(at);
      var MA = function (D) {
        ht(b, D);
        function b() {
          var g = D !== null && D.apply(this, arguments) || this;
          return g.domView = new Ue(2, function (m) {
            return c("span", {
              class: "dcg-mq-nthroot-container dcg-mq-non-leaf",
            }, [
              c.block(
                "sup",
                { class: "dcg-mq-nthroot dcg-mq-non-leaf" },
                m[0],
              ),
              c(
                "span",
                { class: "dcg-mq-scaled dcg-mq-sqrt-container" },
                [
                  c(
                    "span",
                    { class: "dcg-mq-sqrt-prefix dcg-mq-scaled" },
                    [Tx.sqrt.html()],
                  ),
                  c.block("span", {
                    class: "dcg-mq-sqrt-stem dcg-mq-non-leaf",
                  }, m[1]),
                ],
              ),
            ]);
          }),
            g.textTemplate = ["sqrt[", "](", ")"],
            g;
        }
        return b.prototype.latexRecursive = function (g) {
          this.checkCursorContextOpen(g),
            g.latex += "\\sqrt[",
            this.getEnd(r).latexRecursive(g),
            g.latex += "]{",
            this.getEnd(e).latexRecursive(g),
            g.latex += "}",
            this.checkCursorContextClose(g);
        },
          b.prototype.mathspeak = function () {
            var g = this.getEnd(r).mathspeak(),
              m = this.getEnd(e).mathspeak();
            return this.getEnd(r).ariaLabel = "Index",
              this.getEnd(e).ariaLabel = "Radicand",
              g === "3"
                ? "Start Cube Root, " + m + ", End Cube Root"
                : "Root Index " + g + ", Start Root, " + m + ", End Root";
          },
          b.prototype.deleteTowards = function (g, m) {
            at.prototype.deleteTowards.call(this, g, m);
          },
          b;
      }(zR);
      M.nthroot = MA,
        M.cbrt = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.createLeftOf = function (g) {
            D.prototype.createLeftOf.call(this, g),
              new Gt("3").createLeftOf(g),
              g.controller.moveRight();
          },
            b;
        }(MA);
      var qR = function (D) {
        ht(b, D);
        function b(g, m, T) {
          var G = new Ue(1, function (B) {
            return c("span", { class: "dcg-mq-non-leaf" }, [
              c("span", { class: "dcg-mq-diacritic-above" }, [m]),
              c.block("span", { class: "dcg-mq-diacritic-stem" }, B[0]),
            ]);
          });
          return D.call(this, g, G, T) || this;
        }
        return b;
      }(at);
      M.vec = function () {
        return new qR("\\vec", c.entityText("&rarr;"), ["vec(", ")"]);
      },
        M.tilde = function () {
          return new qR("\\tilde", c.text("~"), ["tilde(", ")"]);
        };
      var HR = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.setDOM = function (g) {
            var m;
            D.prototype.setDOM.call(this, g);
            var T = this.domFrag().children();
            return T.isEmpty() ||
              (this.delimFrags =
                (m = {}, m[r] = T.first(), m[e] = T.last(), m)),
              this;
          },
            b;
        }(at),
        Sl = function (D) {
          ht(b, D);
          function b(g, m, T, G, B) {
            var H, X = D.call(this, "\\left" + G, void 0, [m, T]) || this;
            return X.side = g,
              X.sides =
                (H = {},
                  H[r] = { ch: m, ctrlSeq: G },
                  H[e] = { ch: T, ctrlSeq: B },
                  H),
              X;
          }
          return b.prototype.numBlocks = function () {
            return 1;
          },
            b.prototype.html = function () {
              var g = this, m = this.getSymbol(r), T = this.getSymbol(e);
              return this.domView = new Ue(1, function (G) {
                return c("span", {
                  class: "dcg-mq-non-leaf dcg-mq-bracket-container",
                }, [
                  c("span", {
                    style: "width:" + m.width,
                    class: "dcg-mq-scaled dcg-mq-bracket-l dcg-mq-paren" +
                      (g.side === e ? " dcg-mq-ghost" : ""),
                  }, [m.html()]),
                  c.block("span", {
                    style: "margin-left:" + m.width + ";margin-right:" +
                      T.width,
                    class: "dcg-mq-bracket-middle dcg-mq-non-leaf",
                  }, G[0]),
                  c("span", {
                    style: "width:" + T.width,
                    class: "dcg-mq-scaled dcg-mq-bracket-r dcg-mq-paren" +
                      (g.side === r ? " dcg-mq-ghost" : ""),
                  }, [T.html()]),
                ]);
              }),
                D.prototype.html.call(this);
            },
            b.prototype.getSymbol = function (g) {
              var m = this.sides[g || e].ch;
              return Tx[m] || { width: "0", html: "" };
            },
            b.prototype.latexRecursive = function (g) {
              this.checkCursorContextOpen(g),
                g.latex += "\\left" + this.sides[r].ctrlSeq,
                this.getEnd(r).latexRecursive(g),
                g.latex += "\\right" + this.sides[e].ctrlSeq,
                this.checkCursorContextClose(g);
            },
            b.prototype.mathspeak = function (g) {
              var m = this.sides[r].ch, T = this.sides[e].ch;
              if (m === "|" && T === "|") {
                this.mathspeakTemplate = [
                  "StartAbsoluteValue,",
                  ", EndAbsoluteValue",
                ], this.ariaLabel = "absolute value";
              } else if (g && g.createdLeftOf && this.side) {
                var G = "";
                return this.side === r
                  ? G = this.textTemplate[0]
                  : this.side === e && (G = this.textTemplate[1]),
                  (this.side === r ? "left " : "right ") + Pm[G];
              } else {this.mathspeakTemplate = [
                  "left " + Pm[m] + ",",
                  ", right " + Pm[T],
                ],
                  this.ariaLabel = Pm[m] + " block";}
              return D.prototype.mathspeak.call(this);
            },
            b.prototype.matchBrack = function (g, m, T) {
              return T instanceof b && T.side && T.side !== -m &&
                (!g.restrictMismatchedBrackets ||
                  Dx[this.sides[this.side].ch] === T.sides[T.side].ch ||
                  g.restrictMismatchedBrackets !== "none" &&
                    { "(": "]", "[": ")" }[this.sides[r].ch] ===
                      T.sides[e].ch) &&
                T;
            },
            b.prototype.closeOpposing = function (g) {
              g.side = 0, g.sides[this.side] = this.sides[this.side];
              var m = g.delimFrags[this.side === r ? r : e].removeClass(
                "dcg-mq-ghost",
              );
              this.replaceBracket(m, this.side);
            },
            b.prototype.createLeftOf = function (g) {
              var m;
              if (!this.replacedFragment) {
                var T = g.options;
                this.sides[r].ch === "|"
                  ? m = this.matchBrack(T, e, g[e]) ||
                    this.matchBrack(T, r, g[r]) ||
                    this.matchBrack(T, 0, g.parent.parent)
                  : m = this.matchBrack(T, -this.side, g[-this.side]) ||
                    this.matchBrack(T, -this.side, g.parent.parent);
              }
              if (m) {
                var G = this.side = -m.side;
                this.closeOpposing(m),
                  m === g.parent.parent && g[G] &&
                  new N(g[G], g.parent.getEnd(G), -G).disown()
                    .withDirAdopt(-G, m.parent, m, m[G]).domFrag()
                    .insDirOf(G, m.domFrag()),
                  m.bubble(function (B) {
                    B.reflow();
                  });
              } else {m = this,
                  G = m.side,
                  m.replacedFragment ? m.side = 0 : g[-G] &&
                    (m.replaces(new N(g[-G], g.parent.getEnd(-G), G)),
                      g[-G] = 0),
                  D.prototype.createLeftOf.call(this, g);}
              G === r ? g.insAtLeftEnd(m.getEnd(r)) : g.insRightOf(m);
            },
            b.prototype.placeCursor = function () {},
            b.prototype.unwrap = function () {
              this.getEnd(r).children().disown().adopt(
                this.parent,
                this,
                this[e],
              ).domFrag().insertAfter(this.domFrag()), this.remove();
            },
            b.prototype.deleteSide = function (g, m, T) {
              var G = this.parent, B = this[g], H = G.getEnd(g);
              if (g === this.side) {
                this.unwrap(), B ? T.insDirOf(-g, B) : T.insAtDirEnd(g, G);
                return;
              }
              var X = T.options, ge = !this.side;
              if (
                this.side = -g,
                  this.matchBrack(X, g, this.getEnd(r).getEnd(this.side))
              ) {
                this.closeOpposing(this.getEnd(r).getEnd(this.side));
                var Oe = this.getEnd(r).getEnd(g);
                this.unwrap(),
                  Oe && Oe.siblingCreated(T.options, g),
                  B ? T.insDirOf(-g, B) : T.insAtDirEnd(g, G);
              } else {
                if (this.matchBrack(X, g, this.parent.parent)) {
                  this.parent.parent.closeOpposing(this),
                    this.parent.parent.unwrap();
                } else if (m && ge) {
                  this.unwrap(), B ? T.insDirOf(-g, B) : T.insAtDirEnd(g, G);
                  return;
                } else {
                  this.sides[g] = Uj(this),
                    this.delimFrags[r].removeClass("dcg-mq-ghost"),
                    this.delimFrags[e].removeClass("dcg-mq-ghost");
                  var Ae = this.delimFrags[g].addClass("dcg-mq-ghost");
                  this.replaceBracket(Ae, g);
                }
                if (B) {
                  var Ie = this.getEnd(r), Oe = Ie.getEnd(g);
                  Ie.domFrag().removeClass("dcg-mq-empty"),
                    new N(B, H, -g).disown().withDirAdopt(-g, Ie, Oe, 0)
                      .domFrag().insAtDirEnd(
                        g,
                        Ie.domFrag().oneElement(),
                      ),
                    Oe && Oe.siblingCreated(T.options, g),
                    T.insDirOf(-g, B);
                } else {m
                    ? T.insDirOf(g, this)
                    : T.insAtDirEnd(g, this.getEnd(r));}
              }
            },
            b.prototype.replaceBracket = function (g, m) {
              var T = this.getSymbol(m);
              if (
                g.children().replaceWith(P(T.html())),
                  g.oneElement().style.width = T.width,
                  m === r
              ) {
                var G = g.next();
                G.isEmpty() ||
                  (G.oneElement().style.marginLeft = T.width);
              } else {
                var B = g.prev();
                B.isEmpty() ||
                  (B.oneElement().style.marginRight = T.width);
              }
            },
            b.prototype.deleteTowards = function (g, m) {
              this.deleteSide(-g, false, m);
            },
            b.prototype.finalizeTree = function () {
              this.getEnd(r).deleteOutOf = function (g, m) {
                this.parent.deleteSide(g, true, m);
              },
                this.finalizeTree = this.intentionalBlur = function () {
                  this.delimFrags[this.side === r ? e : r].removeClass(
                    "dcg-mq-ghost",
                  ), this.side = 0;
                };
            },
            b.prototype.siblingCreated = function (g, m) {
              m === -this.side && this.finalizeTree();
            },
            b;
        }(HR);
      function Uj(D) {
        var b = D.side, g = D.sides[b];
        return { ch: Dx[g.ch], ctrlSeq: Dx[g.ctrlSeq] };
      }
      var Dx = {
          "(": ")",
          ")": "(",
          "[": "]",
          "]": "[",
          "{": "}",
          "}": "{",
          "\\{": "\\}",
          "\\}": "\\{",
          "&lang;": "&rang;",
          "&rang;": "&lang;",
          "\\langle ": "\\rangle ",
          "\\rangle ": "\\langle ",
          "|": "|",
          "\\lVert ": "\\rVert ",
          "\\rVert ": "\\lVert ",
        },
        Pm = {
          "&lang;": "angle-bracket",
          "&rang;": "angle-bracket",
          "|": "pipe",
        };
      function GA(D, m, g) {
        var m = m || D, T = Dx[D], G = Dx[m];
        F[D] = function () {
          return new Sl(r, D, T, m, G);
        },
          F[T] = function () {
            return new Sl(e, D, T, m, G);
          },
          Pm[D] = Pm[T] = g;
      }
      GA("(", "", "parenthesis"),
        GA("[", "", "bracket"),
        GA("{", "\\{", "brace"),
        M.langle = function () {
          return new Sl(r, "&lang;", "&rang;", "\\langle ", "\\rangle ");
        },
        M.rangle = function () {
          return new Sl(e, "&lang;", "&rang;", "\\langle ", "\\rangle ");
        },
        F["|"] = function () {
          return new Sl(r, "|", "|", "|", "|");
        },
        M.lVert = function () {
          return new Sl(r, "&#8741;", "&#8741;", "\\lVert ", "\\rVert ");
        },
        M.rVert = function () {
          return new Sl(e, "&#8741;", "&#8741;", "\\lVert ", "\\rVert ");
        },
        M.left = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.parser = function () {
            var g = ce.regex, m = ce.string, T = ce.optWhitespace;
            return T.then(
              g(/^(?:[([|]|\\\{|\\langle(?![a-zA-Z])|\\lVert(?![a-zA-Z]))/),
            ).then(function (G) {
              var B = G.replace(/^\\/, "");
              return G == "\\langle" && (B = "&lang;", G = G + " "),
                G == "\\lVert" && (B = "&#8741;", G = G + " "),
                j.then(function (H) {
                  return m("\\right").skip(T).then(
                    g(/^(?:[\])|]|\\\}|\\rangle(?![a-zA-Z])|\\rVert(?![a-zA-Z]))/),
                  ).map(function (X) {
                    var ge = X.replace(/^\\/, "");
                    X == "\\rangle" && (ge = "&rang;", X = X + " "),
                      X == "\\rVert" && (ge = "&#8741;", X = X + " ");
                    var Oe = new Sl(0, B, ge, G, X);
                    return Oe.blocks = [H], H.adopt(Oe, 0, 0), Oe;
                  });
                });
            });
          },
            b;
        }(at),
        M.right = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.parser = function () {
            return ce.fail("unmatched \\right");
          },
            b;
        }(at);
      var LA = Tx["("],
        PA = Tx[")"],
        KR = function (D) {
          ht(b, D);
          function b() {
            var g = D !== null && D.apply(this, arguments) || this;
            return g.ctrlSeq = "\\binom",
              g.domView = new Ue(2, function (m) {
                return c("span", {
                  class: "dcg-mq-non-leaf dcg-mq-bracket-container",
                }, [
                  c("span", {
                    style: "width:" + LA.width,
                    class: "dcg-mq-paren dcg-mq-bracket-l dcg-mq-scaled",
                  }, [LA.html()]),
                  c("span", {
                    style: "margin-left:" + LA.width + "; margin-right:" +
                      PA.width,
                    class: "dcg-mq-non-leaf dcg-mq-bracket-middle",
                  }, [
                    c("span", { class: "dcg-mq-array dcg-mq-non-leaf" }, [
                      c.block("span", {}, m[0]),
                      c.block("span", {}, m[1]),
                    ]),
                  ]),
                  c("span", {
                    style: "width:" + PA.width,
                    class: "dcg-mq-paren dcg-mq-bracket-r dcg-mq-scaled",
                  }, [PA.html()]),
                ]);
              }),
              g.textTemplate = ["choose(", ",", ")"],
              g.mathspeakTemplate = [
                "StartBinomial,",
                "Choose",
                ", EndBinomial",
              ],
              g.ariaLabel = "binomial",
              g;
          }
          return b.prototype.finalizeTree = function () {
            var g = this.getEnd(r), m = this.getEnd(e);
            this.upInto = m.upOutOf = g,
              this.downInto = g.downOutOf = m,
              g.ariaLabel = "upper index",
              m.ariaLabel = "lower index";
          },
            b;
        }(HR);
      M.binom = M.binomial = KR,
        M.choose = function (D) {
          ht(b, D);
          function b() {
            return D !== null && D.apply(this, arguments) || this;
          }
          return b.prototype.createLeftOf = function (g) {
            Nj.prototype.createLeftOf.call(this, g);
          },
            b;
        }(KR);
      var zj = function (D) {
        ht(b, D);
        function b() {
          var g = D !== null && D.apply(this, arguments) || this;
          return g.ctrlSeq = "\\MathQuillMathField",
            g.domView = new Ue(1, function (m) {
              return c("span", { class: "dcg-mq-editable-field" }, [
                c.block("span", {
                  class: "dcg-mq-root-block",
                  "aria-hidden": "true",
                }, m[0]),
              ]);
            }),
            g;
        }
        return b.prototype.parser = function () {
          var g = this, m = ce.string, T = ce.regex, G = ce.succeed;
          return m("[").then(T(/^[a-z][a-z0-9]*/i)).skip(m("]")).map(
            function (B) {
              g.name = B;
            },
          ).or(G(void 0)).then(D.prototype.parser.call(this));
        },
          b.prototype.finalizeTree = function (g) {
            var m = new co(
              this.getEnd(r),
              this.domFrag().oneElement(),
              g,
            );
            m.KIND_OF_MQ = "MathField",
              m.editable = true,
              m.createTextarea(),
              m.editablesTextareaEvents(),
              m.cursor.insAtRightEnd(m.root),
              Ee(m.root);
            function T(G) {
              if (
                G.parentNode && !P(G).hasClass("dcg-mq-root-block") &&
                T(G.parentNode), G.nodeType === Node.ELEMENT_NODE
              ) {
                var B = G;
                B.getAttribute("aria-hidden") === "true" &&
                  (B.removeAttribute("aria-hidden"),
                    P(G).children().eachElement(function (H) {
                      H.setAttribute("aria-hidden", "true");
                    }));
              }
            }
            T(this.domFrag().parent().oneElement()),
              this.domFrag().oneElement().removeAttribute("aria-hidden");
          },
          b.prototype.registerInnerField = function (g, m) {
            var T = this.getEnd(r).controller, G = new m(T);
            g[this.name] = G, g.push(G);
          },
          b.prototype.latexRecursive = function (g) {
            this.checkCursorContextOpen(g),
              this.getEnd(r).latexRecursive(g),
              this.checkCursorContextClose(g);
          },
          b.prototype.text = function () {
            return this.getEnd(r).text();
          },
          b;
      }(at);
      M.editable = M.MathQuillMathField = zj;
      var WR = function (D) {
        ht(b, D);
        function b() {
          return D !== null && D.apply(this, arguments) || this;
        }
        return b.prototype.setOptions = function (g) {
          function m() {
            return "";
          }
          return this.text = g.text || m,
            this.domView = new Ue(0, function () {
              return c("span", {}, [l(g.htmlString || "")]);
            }),
            this.latex = g.latex || m,
            this;
        },
          b.prototype.latexRecursive = function (g) {
            this.checkCursorContextOpen(g),
              g.latex += this.latex(),
              this.checkCursorContextClose(g);
          },
          b.prototype.parser = function () {
            var g = this, m = ce.string, T = ce.regex, G = ce.succeed;
            return m("{").then(T(/^[a-z][a-z0-9]*/i)).skip(m("}")).then(
              function (B) {
                return m("[").then(T(/^[-\w\s]*/)).skip(m("]")).or(
                  G(void 0),
                ).map(function (H) {
                  return g.setOptions(q[B](H));
                });
              },
            );
          },
          b;
      }(ft);
      if (M.embed = WR, window.jQuery) {
        Ce = W(1);
        for (var $R in Ce) {
          (function (D, b) {
            typeof b == "function"
              ? (_e[D] = function () {
                return we(), b.apply(this, arguments);
              },
                _e[D].prototype = b.prototype)
              : _e[D] = b;
          })($R, Ce[$R]);
        }
      }
    })();
  });
  var sK = __dcg_shared_module_exports__["defineModule"]((nke, aK) => {
    aK.exports = {
      area: true,
      base: true,
      br: true,
      col: true,
      embed: true,
      hr: true,
      img: true,
      input: true,
      keygen: true,
      link: true,
      menuitem: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true,
    };
  });
  var cK = __dcg_shared_module_exports__["defineModule"]((ake, lK) => {
    var Woe = /([\w-]+)|=|(['"])([.\s\S]*?)\2/g, $oe = sK();
    lK.exports = function (r) {
      var e = 0,
        t,
        o = true,
        i = {
          type: "tag",
          name: "",
          voidElement: false,
          attrs: {},
          children: [],
        };
      return r.replace(Woe, function (n) {
        if (n === "=") {
          o = true, e++;
          return;
        }
        o
          ? e === 0
            ? (($oe[n] || r.charAt(r.length - 2) === "/") &&
              (i.voidElement = true),
              i.name = n)
            : (i.attrs[t] = n.replace(/^['"]|['"]$/g, ""), t = void 0)
          : (t && (i.attrs[t] = t), t = n),
          e++,
          o = false;
      }),
        i;
    };
  });
  var pK = __dcg_shared_module_exports__["defineModule"]((ske, dK) => {
    var joe = /(?:<!--[\S\s]*?-->|<(?:"[^"]*"['"]*|'[^']*'['"]*|[^'">])+>)/g,
      Yoe = cK(),
      Xoe = Object.create ? Object.create(null) : {};
    function AP(r, e, t, o, i) {
      var n = e.indexOf("<", o), a = e.slice(o, n === -1 ? void 0 : n);
      /^\s*$/.test(a) && (a = " "),
        (!i && n > -1 && t + r.length >= 0 || a !== " ") &&
        r.push({ type: "text", content: a });
    }
    dK.exports = function (e, t) {
      t || (t = {}), t.components || (t.components = Xoe);
      var o = [], i, n = -1, a = [], s = {}, l = false;
      return e.replace(joe, function (c, d) {
        if (l) {
          if (c !== "</" + i.name + ">") return;
          l = false;
        }
        var p = c.charAt(1) !== "/",
          h = c.indexOf("<!--") === 0,
          u = d + c.length,
          f = e.charAt(u),
          y;
        p && !h &&
        (n++,
          i = Yoe(c),
          i.type === "tag" && t.components[i.name] &&
          (i.type = "component", l = true),
          !i.voidElement && !l && f && f !== "<" &&
          AP(i.children, e, n, u, t.ignoreWhitespace),
          s[i.tagName] = i,
          n === 0 && o.push(i),
          y = a[n - 1],
          y && y.children.push(i),
          a[n] = i),
          (h || !p || i.voidElement) &&
          (h || n--,
            !l && f !== "<" && f &&
            (y = n === -1 ? o : a[n].children,
              AP(y, e, n, u, t.ignoreWhitespace)));
      }),
        !o.length && e.length && AP(o, e, 0, 0, t.ignoreWhitespace),
        o;
    };
  });
  var gK = __dcg_shared_module_exports__["defineModule"]((lke, hK) => {
    function Joe(r) {
      var e = [];
      for (var t in r) e.push(t + '="' + r[t] + '"');
      return e.length ? " " + e.join(" ") : "";
    }
    function uK(r, e) {
      switch (e.type) {
        case "text":
          return r + e.content;
        case "tag":
          return r += "<" + e.name + (e.attrs ? Joe(e.attrs) : "") +
            (e.voidElement ? "/>" : ">"),
            e.voidElement
              ? r
              : r + e.children.reduce(uK, "") + "</" + e.name + ">";
      }
    }
    hK.exports = function (r) {
      return r.reduce(function (e, t) {
        return e + uK("", t);
      }, "");
    };
  });
  var fK = __dcg_shared_module_exports__["defineModule"]((cke, mK) => {
    mK.exports = { parse: pK(), stringify: gK() };
  });
  var td = {};
  __dcg_shared_module_exports__["defineProperties"](td, {
    UnicodeBraille: () => sa,
    latexToNemeth: () => lp,
    latexToUeb: () => cp,
    nemethToLatex: () => fM,
    uebToLatex: () => bM,
    version: () => GX,
  });
  var T3 = Object.defineProperty,
    Hj = Object.getOwnPropertyNames,
    p3 = Object.getOwnPropertySymbols,
    Kj = Object.prototype.hasOwnProperty,
    Wj = Object.prototype.propertyIsEnumerable,
    u3 = (r, e, t) =>
      e in r
        ? T3(r, e, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: t,
        })
        : r[e] = t,
    Jm = (r, e) => {
      for (var t in e || (e = {})) Kj.call(e, t) && u3(r, t, e[t]);
      if (p3) { for (var t of p3(e)) Wj.call(e, t) && u3(r, t, e[t]); }
      return r;
    },
    Qm =
      ((r) =>
        typeof __dcg_shared_module_exports__["requireModule"] != "undefined"
          ? __dcg_shared_module_exports__["requireModule"]
          : typeof Proxy != "undefined"
          ? new Proxy(r, {
            get: (e, t) =>
              (typeof __dcg_shared_module_exports__["requireModule"] !=
                  "undefined"
                ? __dcg_shared_module_exports__["requireModule"]
                : e)[t],
          })
          : r)(function (r) {
          if (
            typeof __dcg_shared_module_exports__["requireModule"] != "undefined"
          ) {
            return __dcg_shared_module_exports__["requireModule"].apply(
              this,
              arguments,
            );
          }
          throw new Error(
            'Dynamic require of "' + r + '" is not supported',
          );
        }),
    nM = (r, e) =>
      function () {
        return e || (0, r[Hj(r)[0]])((e = { exports: {} }).exports, e),
          e.exports;
      },
    aM = (r, e) => {
      for (var t in e) T3(r, t, { get: e[t], enumerable: true });
    },
    $j = nM({
      "generated/latex.jison.js"(r, e) {
        "use strict";
        var t = function () {
          var o = function (x, L, V, R) {
              for (V = V || {}, R = x.length; R--; V[x[R]] = L);
              return V;
            },
            i = [1, 13],
            n = [1, 14],
            a = [1, 15],
            s = [1, 16],
            l = [1, 17],
            c = [1, 21],
            d = [1, 18],
            p = [1, 19],
            h = [1, 20],
            u = [1, 22],
            f = [1, 23],
            y = [1, 28],
            C = [1, 30],
            E = [1, 31],
            v = [1, 32],
            w = [1, 33],
            S = [1, 29],
            k = [5, 21, 27, 38],
            _ = [
              5,
              19,
              21,
              22,
              23,
              24,
              25,
              26,
              27,
              28,
              32,
              33,
              34,
              35,
              36,
              37,
              38,
            ],
            A = [
              5,
              10,
              12,
              13,
              14,
              19,
              21,
              22,
              23,
              24,
              25,
              26,
              27,
              28,
              32,
              33,
              34,
              35,
              36,
              37,
              38,
            ],
            P = [
              5,
              10,
              19,
              21,
              22,
              23,
              24,
              25,
              26,
              27,
              28,
              32,
              33,
              34,
              35,
              36,
              37,
              38,
            ],
            O = {
              trace: function () {},
              yy: {},
              symbols_: {
                error: 2,
                sentence: 3,
                group: 4,
                EOF: 5,
                level: 6,
                expression: 7,
                subscript: 8,
                superscript: 9,
                _: 10,
                atom: 11,
                "^": 12,
                "PRIMES^": 13,
                PRIMES: 14,
                delimited_group: 15,
                typeform: 16,
                frac: 17,
                radical: 18,
                LEFT: 19,
                delimiter: 20,
                RIGHT: 21,
                FRAC: 22,
                OPERATOR_NAME: 23,
                MATHRM: 24,
                TEXT: 25,
                RADICAL_OPTARG: 26,
                CLOSE_OPTARG: 27,
                RADICAL: 28,
                curly_group: 29,
                greek: 30,
                command: 31,
                SYMBOL: 32,
                DELIMITER: 33,
                DELIMITER_COMMAND: 34,
                GREEK: 35,
                COMMAND: 36,
                "{": 37,
                "}": 38,
                $accept: 0,
                $end: 1,
              },
              terminals_: {
                2: "error",
                5: "EOF",
                10: "_",
                12: "^",
                13: "PRIMES^",
                14: "PRIMES",
                19: "LEFT",
                21: "RIGHT",
                22: "FRAC",
                23: "OPERATOR_NAME",
                24: "MATHRM",
                25: "TEXT",
                26: "RADICAL_OPTARG",
                27: "CLOSE_OPTARG",
                28: "RADICAL",
                32: "SYMBOL",
                33: "DELIMITER",
                34: "DELIMITER_COMMAND",
                35: "GREEK",
                36: "COMMAND",
                37: "{",
                38: "}",
              },
              productions_: [
                0,
                [3, 2],
                [3, 1],
                [4, 3],
                [4, 2],
                [4, 1],
                [4, 2],
                [4, 1],
                [6, 2],
                [6, 2],
                [6, 1],
                [6, 1],
                [8, 2],
                [9, 2],
                [9, 2],
                [9, 1],
                [7, 1],
                [7, 1],
                [7, 1],
                [7, 1],
                [7, 1],
                [15, 5],
                [15, 4],
                [17, 3],
                [16, 2],
                [16, 2],
                [16, 2],
                [18, 4],
                [18, 3],
                [18, 2],
                [18, 2],
                [11, 1],
                [11, 1],
                [11, 1],
                [11, 1],
                [11, 1],
                [20, 1],
                [20, 1],
                [30, 1],
                [31, 1],
                [29, 3],
                [29, 2],
              ],
              performAction: function (L, V, R, N, M, F, Z) {
                var te = F.length - 1;
                switch (M) {
                  case 1:
                    return F[te - 1];
                  case 2:
                    return N.group();
                  case 3:
                    this.$ = N.group(F[te - 2], F[te - 1], F[te]);
                    break;
                  case 4:
                  case 6:
                    this.$ = N.group(F[te - 1], F[te]);
                    break;
                  case 5:
                  case 7:
                    this.$ = N.group(F[te]);
                    break;
                  case 8:
                    this.$ = N.level({
                      _: N.group(F[te - 1]),
                      "^": N.group(F[te]),
                    });
                    break;
                  case 9:
                    this.$ = N.level({
                      _: N.group(F[te]),
                      "^": N.group(F[te - 1]),
                    });
                    break;
                  case 10:
                    this.$ = N.level({ "^": N.group(F[te]) });
                    break;
                  case 11:
                    this.$ = N.level({ _: N.group(F[te]) });
                    break;
                  case 12:
                  case 13:
                    this.$ = F[te];
                    break;
                  case 14:
                    this.$ = N.processPrimes(F[te - 1], F[te]);
                    break;
                  case 15:
                    this.$ = N.processPrimes(F[te], N.group());
                    break;
                  case 21:
                    this.$ = N.group(F[te - 3], F[te - 2], F[te]);
                    break;
                  case 22:
                    this.$ = N.group(F[te - 2], F[te]);
                    break;
                  case 23:
                    this.$ = N.fraction(
                      N.group(F[te - 1]),
                      N.group(F[te]),
                    );
                    break;
                  case 24:
                    this.$ = N.typeform("operator_name", N.group(F[te]));
                    break;
                  case 25:
                    this.$ = N.typeform("mathrm", N.group(F[te]));
                    break;
                  case 26:
                    this.$ = N.typeform("text", N.group(F[te]));
                    break;
                  case 27:
                    this.$ = N.radical(F[te], N.group(F[te - 2]));
                    break;
                  case 28:
                    this.$ = N.radical(N.group(F[te]), N.group());
                    break;
                  case 29:
                  case 30:
                    this.$ = N.radical(N.group(F[te]));
                    break;
                  case 35:
                  case 36:
                    this.$ = N.terminal(F[te]);
                    break;
                  case 37:
                  case 39:
                    this.$ = N.command(F[te]);
                    break;
                  case 38:
                    this.$ = N.greek(F[te]);
                    break;
                  case 40:
                    this.$ = F[te - 1];
                    break;
                  case 41:
                    this.$ = N.group();
                    break;
                }
              },
              table: [
                {
                  3: 1,
                  4: 2,
                  5: [1, 3],
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  10: i,
                  11: 12,
                  12: n,
                  13: a,
                  14: s,
                  15: 8,
                  16: 9,
                  17: 10,
                  18: 11,
                  19: l,
                  20: 25,
                  22: c,
                  23: d,
                  24: p,
                  25: h,
                  26: u,
                  28: f,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                { 1: [3] },
                { 5: [1, 34] },
                { 1: [2, 2] },
                o(k, [2, 5], {
                  15: 8,
                  16: 9,
                  17: 10,
                  18: 11,
                  11: 12,
                  29: 24,
                  20: 25,
                  30: 26,
                  31: 27,
                  7: 35,
                  19: l,
                  22: c,
                  23: d,
                  24: p,
                  25: h,
                  26: u,
                  28: f,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                }),
                o(k, [2, 7], {
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  15: 8,
                  16: 9,
                  17: 10,
                  18: 11,
                  11: 12,
                  29: 24,
                  20: 25,
                  30: 26,
                  31: 27,
                  4: 36,
                  10: i,
                  12: n,
                  13: a,
                  14: s,
                  19: l,
                  22: c,
                  23: d,
                  24: p,
                  25: h,
                  26: u,
                  28: f,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                }),
                o(_, [2, 11], { 9: 37, 12: n, 13: a, 14: s }),
                o(_, [2, 10], { 8: 38, 10: i }),
                o(A, [2, 16]),
                o(A, [2, 17]),
                o(A, [2, 18]),
                o(A, [2, 19]),
                o(A, [2, 20]),
                {
                  11: 39,
                  20: 25,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                {
                  11: 40,
                  20: 25,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                {
                  11: 41,
                  20: 25,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                o(P, [2, 15]),
                { 20: 42, 33: C, 34: E },
                {
                  11: 43,
                  20: 25,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                {
                  11: 44,
                  20: 25,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                {
                  11: 45,
                  20: 25,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                {
                  11: 46,
                  20: 25,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                {
                  4: 47,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  10: i,
                  11: 12,
                  12: n,
                  13: a,
                  14: s,
                  15: 8,
                  16: 9,
                  17: 10,
                  18: 11,
                  19: l,
                  20: 25,
                  22: c,
                  23: d,
                  24: p,
                  25: h,
                  26: u,
                  27: [1, 48],
                  28: f,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                {
                  11: 49,
                  17: 50,
                  20: 25,
                  22: c,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                o(A, [2, 31]),
                o(A, [2, 32]),
                o(A, [2, 33]),
                o(A, [2, 34]),
                o(A, [2, 35]),
                {
                  4: 51,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  10: i,
                  11: 12,
                  12: n,
                  13: a,
                  14: s,
                  15: 8,
                  16: 9,
                  17: 10,
                  18: 11,
                  19: l,
                  20: 25,
                  22: c,
                  23: d,
                  24: p,
                  25: h,
                  26: u,
                  28: f,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                  38: [1, 52],
                },
                o(A, [2, 36]),
                o(A, [2, 37]),
                o(A, [2, 38]),
                o(A, [2, 39]),
                { 1: [2, 1] },
                o(k, [2, 4], {
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  15: 8,
                  16: 9,
                  17: 10,
                  18: 11,
                  11: 12,
                  29: 24,
                  20: 25,
                  30: 26,
                  31: 27,
                  4: 53,
                  10: i,
                  12: n,
                  13: a,
                  14: s,
                  19: l,
                  22: c,
                  23: d,
                  24: p,
                  25: h,
                  26: u,
                  28: f,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                }),
                o(k, [2, 6]),
                o(_, [2, 8]),
                o(_, [2, 9]),
                o([
                  5,
                  12,
                  13,
                  14,
                  19,
                  21,
                  22,
                  23,
                  24,
                  25,
                  26,
                  27,
                  28,
                  32,
                  33,
                  34,
                  35,
                  36,
                  37,
                  38,
                ], [2, 12]),
                o(P, [2, 13]),
                o(P, [2, 14]),
                {
                  4: 54,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  10: i,
                  11: 12,
                  12: n,
                  13: a,
                  14: s,
                  15: 8,
                  16: 9,
                  17: 10,
                  18: 11,
                  19: l,
                  20: 25,
                  21: [1, 55],
                  22: c,
                  23: d,
                  24: p,
                  25: h,
                  26: u,
                  28: f,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                o(A, [2, 24]),
                o(A, [2, 25]),
                o(A, [2, 26]),
                {
                  11: 56,
                  20: 25,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                { 27: [1, 57] },
                {
                  11: 58,
                  20: 25,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                o(A, [2, 29]),
                o(A, [2, 30]),
                { 38: [1, 59] },
                o(A, [2, 41]),
                o(k, [2, 3]),
                { 21: [1, 60] },
                { 20: 61, 33: C, 34: E },
                o(A, [2, 23]),
                {
                  11: 62,
                  20: 25,
                  29: 24,
                  30: 26,
                  31: 27,
                  32: y,
                  33: C,
                  34: E,
                  35: v,
                  36: w,
                  37: S,
                },
                o(A, [2, 28]),
                o(A, [2, 40]),
                { 20: 63, 33: C, 34: E },
                o(A, [2, 22]),
                o(A, [2, 27]),
                o(A, [2, 21]),
              ],
              defaultActions: { 3: [2, 2], 34: [2, 1] },
              parseError: function (L, V) {
                if (V.recoverable) this.trace(L);
                else {
                  var R = new Error(L);
                  throw R.hash = V, R;
                }
              },
              parse: function (L) {
                var V = this,
                  R = [0],
                  N = [],
                  M = [null],
                  F = [],
                  Z = this.table,
                  te = "",
                  Y = 0,
                  he = 0,
                  se = 0,
                  ae = 2,
                  q = 1,
                  oe = F.slice.call(arguments, 1),
                  K = Object.create(this.lexer),
                  fe = { yy: {} };
                for (var me in this.yy) {
                  Object.prototype.hasOwnProperty.call(this.yy, me) &&
                    (fe.yy[me] = this.yy[me]);
                }
                K.setInput(L, fe.yy),
                  fe.yy.lexer = K,
                  fe.yy.parser = this,
                  typeof K.yylloc == "undefined" && (K.yylloc = {});
                var we = K.yylloc;
                F.push(we);
                var Ce = K.options && K.options.ranges;
                typeof fe.yy.parseError == "function"
                  ? this.parseError = fe.yy.parseError
                  : this.parseError = Object.getPrototypeOf(this).parseError;
                function _e(Mr) {
                  R.length = R.length - 2 * Mr,
                    M.length = M.length - Mr,
                    F.length = F.length - Mr;
                }
                for (
                  var We = function () {
                      var Mr;
                      return Mr = K.lex() || q,
                        typeof Mr != "number" &&
                        (Mr = V.symbols_[Mr] || Mr),
                        Mr;
                    },
                    $,
                    W,
                    ue,
                    Ee,
                    Be,
                    ce,
                    ot = {},
                    it,
                    Se,
                    Lt,
                    It;;
                ) {
                  if (
                    ue = R[R.length - 1],
                      this.defaultActions[ue]
                        ? Ee = this.defaultActions[ue]
                        : (($ === null || typeof $ == "undefined") &&
                          ($ = We()),
                          Ee = Z[ue] && Z[ue][$]),
                      typeof Ee == "undefined" || !Ee.length || !Ee[0]
                  ) {
                    var Dt = "";
                    It = [];
                    for (it in Z[ue]) {
                      this.terminals_[it] && it > ae &&
                        It.push("'" + this.terminals_[it] + "'");
                    }
                    K.showPosition
                      ? Dt = "Parse error on line " + (Y + 1) + `:
` + K.showPosition() + `
Expecting ` + It.join(", ") + ", got '" + (this.terminals_[$] || $) + "'"
                      : Dt = "Parse error on line " + (Y + 1) +
                        ": Unexpected " + ($ == q
                          ? "end of input"
                          : "'" + (this.terminals_[$] || $) + "'"),
                      this.parseError(Dt, {
                        text: K.match,
                        token: this.terminals_[$] || $,
                        line: K.yylineno,
                        loc: we,
                        expected: It,
                      });
                  }
                  if (Ee[0] instanceof Array && Ee.length > 1) {
                    throw new Error(
                      "Parse Error: multiple actions possible at state: " +
                        ue + ", token: " + $,
                    );
                  }
                  switch (Ee[0]) {
                    case 1:
                      R.push($),
                        M.push(K.yytext),
                        F.push(K.yylloc),
                        R.push(Ee[1]),
                        $ = null,
                        W
                          ? ($ = W, W = null)
                          : (he = K.yyleng,
                            te = K.yytext,
                            Y = K.yylineno,
                            we = K.yylloc,
                            se > 0 && se--);
                      break;
                    case 2:
                      if (
                        Se = this.productions_[Ee[1]][1],
                          ot.$ = M[M.length - Se],
                          ot._$ = {
                            first_line: F[F.length - (Se || 1)].first_line,
                            last_line: F[F.length - 1].last_line,
                            first_column: F[F.length - (Se || 1)].first_column,
                            last_column: F[F.length - 1].last_column,
                          },
                          Ce &&
                          (ot._$.range = [
                            F[F.length - (Se || 1)].range[0],
                            F[F.length - 1].range[1],
                          ]),
                          ce = this.performAction.apply(
                            ot,
                            [te, he, Y, fe.yy, Ee[1], M, F].concat(oe),
                          ),
                          typeof ce != "undefined"
                      ) return ce;
                      Se &&
                      (R = R.slice(0, -1 * Se * 2),
                        M = M.slice(0, -1 * Se),
                        F = F.slice(0, -1 * Se)),
                        R.push(this.productions_[Ee[1]][0]),
                        M.push(ot.$),
                        F.push(ot._$),
                        Lt = Z[R[R.length - 2]][R[R.length - 1]],
                        R.push(Lt);
                      break;
                    case 3:
                      return true;
                  }
                }
                return true;
              },
            },
            U = function () {
              var x = {
                EOF: 1,
                parseError: function (V, R) {
                  if (this.yy.parser) this.yy.parser.parseError(V, R);
                  else throw new Error(V);
                },
                setInput: function (L, V) {
                  return this.yy = V || this.yy || {},
                    this._input = L,
                    this._more = this._backtrack = this.done = false,
                    this.yylineno = this.yyleng = 0,
                    this.yytext = this.matched = this.match = "",
                    this.conditionStack = ["INITIAL"],
                    this.yylloc = {
                      first_line: 1,
                      first_column: 0,
                      last_line: 1,
                      last_column: 0,
                    },
                    this.options.ranges && (this.yylloc.range = [0, 0]),
                    this.offset = 0,
                    this;
                },
                input: function () {
                  var L = this._input[0];
                  this.yytext += L,
                    this.yyleng++,
                    this.offset++,
                    this.match += L,
                    this.matched += L;
                  var V = L.match(/(?:\r\n?|\n).*/g);
                  return V
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                    this.options.ranges && this.yylloc.range[1]++,
                    this._input = this._input.slice(1),
                    L;
                },
                unput: function (L) {
                  var V = L.length, R = L.split(/(?:\r\n?|\n)/g);
                  this._input = L + this._input,
                    this.yytext = this.yytext.substr(
                      0,
                      this.yytext.length - V,
                    ),
                    this.offset -= V;
                  var N = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(
                    0,
                    this.match.length - 1,
                  ),
                    this.matched = this.matched.substr(
                      0,
                      this.matched.length - 1,
                    ),
                    R.length - 1 && (this.yylineno -= R.length - 1);
                  var M = this.yylloc.range;
                  return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: R
                      ? (R.length === N.length ? this.yylloc.first_column : 0) +
                        N[N.length - R.length].length - R[0].length
                      : this.yylloc.first_column - V,
                  },
                    this.options.ranges &&
                    (this.yylloc.range = [M[0], M[0] + this.yyleng - V]),
                    this.yyleng = this.yytext.length,
                    this;
                },
                more: function () {
                  return this._more = true, this;
                },
                reject: function () {
                  if (this.options.backtrack_lexer) this._backtrack = true;
                  else {return this.parseError(
                      "Lexical error on line " + (this.yylineno + 1) +
                        `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(),
                      { text: "", token: null, line: this.yylineno },
                    );}
                  return this;
                },
                less: function (L) {
                  this.unput(this.match.slice(L));
                },
                pastInput: function () {
                  var L = this.matched.substr(
                    0,
                    this.matched.length - this.match.length,
                  );
                  return (L.length > 20 ? "..." : "") +
                    L.substr(-20).replace(/\n/g, "");
                },
                upcomingInput: function () {
                  var L = this.match;
                  return L.length < 20 &&
                    (L += this._input.substr(0, 20 - L.length)),
                    (L.substr(0, 20) + (L.length > 20 ? "..." : ""))
                      .replace(/\n/g, "");
                },
                showPosition: function () {
                  var L = this.pastInput(),
                    V = new Array(L.length + 1).join("-");
                  return L + this.upcomingInput() + `
` + V + "^";
                },
                test_match: function (L, V) {
                  var R, N, M;
                  if (
                    this.options.backtrack_lexer && (M = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    },
                      this.options.ranges &&
                      (M.yylloc.range = this.yylloc.range.slice(0))),
                      N = L[0].match(/(?:\r\n?|\n).*/g),
                      N && (this.yylineno += N.length),
                      this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: N
                          ? N[N.length - 1].length -
                            N[N.length - 1].match(/\r?\n?/)[0].length
                          : this.yylloc.last_column + L[0].length,
                      },
                      this.yytext += L[0],
                      this.match += L[0],
                      this.matches = L,
                      this.yyleng = this.yytext.length,
                      this.options.ranges &&
                      (this.yylloc.range = [
                        this.offset,
                        this.offset += this.yyleng,
                      ]),
                      this._more = false,
                      this._backtrack = false,
                      this._input = this._input.slice(L[0].length),
                      this.matched += L[0],
                      R = this.performAction.call(
                        this,
                        this.yy,
                        this,
                        V,
                        this
                          .conditionStack[this.conditionStack.length - 1],
                      ),
                      this.done && this._input && (this.done = false),
                      R
                  ) return R;
                  if (this._backtrack) {
                    for (var F in M) this[F] = M[F];
                    return false;
                  }
                  return false;
                },
                next: function () {
                  if (this.done) return this.EOF;
                  this._input || (this.done = true);
                  var L, V, R, N;
                  this._more || (this.yytext = "", this.match = "");
                  for (
                    var M = this._currentRules(), F = 0;
                    F < M.length;
                    F++
                  ) {
                    if (
                      R = this._input.match(this.rules[M[F]]),
                        R && (!V || R[0].length > V[0].length)
                    ) {
                      if (V = R, N = F, this.options.backtrack_lexer) {
                        if (
                          L = this.test_match(R, M[F]), L !== false
                        ) return L;
                        if (this._backtrack) {
                          V = false;
                          continue;
                        } else return false;
                      } else if (!this.options.flex) break;
                    }
                  }
                  return V
                    ? (L = this.test_match(V, M[N]), L !== false ? L : false)
                    : this._input === ""
                    ? this.EOF
                    : this.parseError(
                      "Lexical error on line " + (this.yylineno + 1) +
                        `. Unrecognized text.
` + this.showPosition(),
                      { text: "", token: null, line: this.yylineno },
                    );
                },
                lex: function () {
                  var V = this.next();
                  return V || this.lex();
                },
                begin: function (V) {
                  this.conditionStack.push(V);
                },
                popState: function () {
                  var V = this.conditionStack.length - 1;
                  return V > 0
                    ? this.conditionStack.pop()
                    : this.conditionStack[0];
                },
                _currentRules: function () {
                  return this.conditionStack.length &&
                      this.conditionStack[this.conditionStack.length - 1]
                    ? this
                      .conditions[
                        this
                          .conditionStack[this.conditionStack.length - 1]
                      ].rules
                    : this.conditions.INITIAL.rules;
                },
                topState: function (V) {
                  return V = this.conditionStack.length - 1 -
                    Math.abs(V || 0),
                    V >= 0 ? this.conditionStack[V] : "INITIAL";
                },
                pushState: function (V) {
                  this.begin(V);
                },
                stateStackSize: function () {
                  return this.conditionStack.length;
                },
                options: {},
                performAction: function (V, R, N, M) {
                  var F = M;
                  switch (N) {
                    case 0:
                      break;
                    case 1:
                      return this.begin("optarg"), 26;
                      break;
                    case 2:
                      return this.popState(), 27;
                      break;
                    case 3:
                      return 23;
                    case 4:
                      return 24;
                    case 5:
                      return 25;
                    case 6:
                      return 28;
                    case 7:
                      return 22;
                    case 8:
                      return 13;
                    case 9:
                      return 14;
                    case 10:
                      return 12;
                    case 11:
                      return 10;
                    case 12:
                      return 19;
                    case 13:
                      return 21;
                    case 14:
                      return 34;
                    case 15:
                      return 33;
                    case 16:
                      return 37;
                    case 17:
                      return 38;
                    case 18:
                      return 32;
                    case 19:
                      return 32;
                    case 20:
                      return 32;
                    case 21:
                      return 35;
                    case 22:
                      return 35;
                    case 23:
                      return 36;
                    case 24:
                      return 32;
                    case 25:
                      return 5;
                  }
                },
                rules: [
                  /^(?:\s+)/,
                  /^(?:(\\sqrt)\s*\[)/,
                  /^(?:\])/,
                  /^(?:(\\operatorname))/,
                  /^(?:(\\mathrm))/,
                  /^(?:(\\text))/,
                  /^(?:(\\sqrt))/,
                  /^(?:(\\frac))/,
                  /^(?:'+\^)/,
                  /^(?:'+)/,
                  /^(?:\^)/,
                  /^(?:[_])/,
                  /^(?:(\\left))/,
                  /^(?:(\\right))/,
                  /^(?:(\\langle|\\rangle|\\vert|\\Vert))/,
                  /^(?:\[|\]|\\\{|\\\}|\(|\)|\||\\\|)/,
                  /^(?:\{)/,
                  /^(?:\})/,
                  /^(?:\\(infty))/,
                  /^(?:\\(int))/,
                  /^(?:!)/,
                  /^(?:\\(alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|omicron|pi|rho|sigma|tau|xi|upsilon|phi|chi|psi|omega))/,
                  /^(?:\\(Alpha|Beta|Gamma|Delta|Epsilon|Zeta|Eta|Theta|Iota|Kappa|Lambda|Mu|Nu|Omicron|Pi|Rho|Sigma|Tau|Xi|Upsilon|Phi|Chi|Psi|Omega))/,
                  /^(?:\\[A-Za-z]+)/,
                  /^(?:\\.|.)/,
                  /^(?:$)/,
                ],
                conditions: {
                  optarg: {
                    rules: [
                      0,
                      1,
                      2,
                      3,
                      4,
                      5,
                      6,
                      7,
                      8,
                      9,
                      10,
                      11,
                      12,
                      13,
                      14,
                      15,
                      16,
                      17,
                      18,
                      19,
                      20,
                      21,
                      22,
                      23,
                      24,
                      25,
                    ],
                    inclusive: true,
                  },
                  INITIAL: {
                    rules: [
                      0,
                      1,
                      3,
                      4,
                      5,
                      6,
                      7,
                      8,
                      9,
                      10,
                      11,
                      12,
                      13,
                      14,
                      15,
                      16,
                      17,
                      18,
                      19,
                      20,
                      21,
                      22,
                      23,
                      24,
                      25,
                    ],
                    inclusive: true,
                  },
                },
              };
              return x;
            }();
          O.lexer = U;
          function z() {
            this.yy = {};
          }
          return z.prototype = O, O.Parser = z, new z();
        }();
        typeof Qm != "undefined" && typeof r != "undefined" &&
          (r.parser = t,
            r.Parser = t.Parser,
            r.parse = function () {
              return t.parse.apply(t, arguments);
            },
            r.main = function () {},
            typeof e != "undefined" && Qm.main === e &&
            r.main(process.argv.slice(1)));
      },
    }),
    D3 = nM({
      "generated/nemeth-to-latex.jison.js"(r, e) {
        "use strict";
        var t = function () {
          var o = function (Mr, Q, j, Ge) {
              for (j = j || {}, Ge = Mr.length; Ge--; j[Mr[Ge]] = Q);
              return j;
            },
            i = [1, 11],
            n = [1, 12],
            a = [1, 13],
            s = [1, 79],
            l = [1, 80],
            c = [1, 77],
            d = [1, 78],
            p = [1, 39],
            h = [1, 40],
            u = [1, 67],
            f = [1, 68],
            y = [1, 69],
            C = [1, 70],
            E = [1, 71],
            v = [1, 72],
            w = [1, 73],
            S = [1, 74],
            k = [1, 75],
            _ = [1, 76],
            A = [1, 41],
            P = [1, 35],
            O = [1, 36],
            U = [1, 37],
            z = [1, 38],
            x = [1, 42],
            L = [1, 43],
            V = [1, 44],
            R = [1, 45],
            N = [1, 46],
            M = [1, 47],
            F = [1, 48],
            Z = [1, 49],
            te = [1, 50],
            Y = [1, 51],
            he = [1, 52],
            se = [1, 53],
            ae = [1, 54],
            q = [1, 55],
            oe = [1, 56],
            K = [1, 57],
            fe = [1, 58],
            me = [1, 59],
            we = [1, 60],
            Ce = [1, 61],
            _e = [1, 17],
            We = [1, 62],
            $ = [1, 63],
            W = [1, 64],
            ue = [1, 65],
            Ee = [1, 66],
            Be = [5, 12, 13, 14, 18, 24, 25],
            ce = [
              5,
              11,
              12,
              13,
              14,
              15,
              17,
              18,
              20,
              21,
              23,
              24,
              25,
              27,
              48,
              49,
              50,
              51,
              52,
              53,
              54,
              55,
              56,
              57,
              58,
              59,
              60,
              61,
              62,
              63,
              64,
              65,
              66,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              75,
              76,
              77,
              78,
              79,
              80,
              81,
              82,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              91,
            ],
            ot = [1, 84],
            it = [
              5,
              11,
              12,
              13,
              14,
              15,
              17,
              18,
              20,
              21,
              23,
              24,
              25,
              27,
              48,
              49,
              50,
              51,
              52,
              53,
              54,
              55,
              56,
              57,
              58,
              59,
              60,
              61,
              62,
              63,
              64,
              65,
              66,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              75,
              76,
              77,
              78,
              79,
              80,
              81,
              82,
              83,
              84,
              86,
              87,
              88,
              89,
              91,
            ],
            Se = [
              5,
              11,
              12,
              13,
              14,
              15,
              17,
              18,
              20,
              21,
              23,
              24,
              25,
              27,
              48,
              49,
              50,
              51,
              52,
              53,
              54,
              55,
              56,
              57,
              58,
              59,
              60,
              61,
              62,
              63,
              64,
              65,
              66,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              75,
              76,
              77,
              78,
              79,
              80,
              81,
              82,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              90,
              91,
            ],
            Lt = {
              trace: function () {},
              yy: {},
              symbols_: {
                error: 2,
                sentence: 3,
                group: 4,
                EOF: 5,
                element: 6,
                index_element: 7,
                modified_expression: 8,
                radical: 9,
                primes: 10,
                OPEN_MODEXP: 11,
                MODEXP_UNDER: 12,
                MODEXP_OVER: 13,
                CLOSE_MODEXP: 14,
                RADICAL_INDEX: 15,
                index_group: 16,
                OPEN_RADICAL: 17,
                CLOSE_RADICAL: 18,
                level: 19,
                LEVEL: 20,
                BASELINE: 21,
                frac: 22,
                OPEN_FRAC: 23,
                SLASH: 24,
                CLOSE_FRAC: 25,
                geo_token: 26,
                GEO_TOKEN: 27,
                number: 28,
                subscript_head: 29,
                atom: 30,
                command: 31,
                greek: 32,
                letter: 33,
                comma: 34,
                period: 35,
                space: 36,
                operation: 37,
                comparison: 38,
                level_with_comparison: 39,
                ellipsis: 40,
                colon: 41,
                infinity: 42,
                integral: 43,
                factorial: 44,
                ampersand: 45,
                question_mark: 46,
                bracket: 47,
                ",": 48,
                ".": 49,
                "[": 50,
                "{": 51,
                "(": 52,
                "]": 53,
                "}": 54,
                ")": 55,
                LANGLE: 56,
                RANGLE: 57,
                PIPE: 58,
                DOUBLE_PIPE: 59,
                SPACE: 60,
                COMMAND: 61,
                GREEK: 62,
                LETTER: 63,
                CAPITAL_LETTER: 64,
                "+": 65,
                "-": 66,
                CDOT: 67,
                TIMES: 68,
                "*": 69,
                "/": 70,
                DIV: 71,
                PERCENT_OF: 72,
                PERCENT: 73,
                MEASURED_ANGLE: 74,
                ANGLE: 75,
                CIRCLE: 76,
                PARALLELOGRAM: 77,
                TO: 78,
                TRIANGLE: 79,
                DEGREE: 80,
                COMPARISON: 81,
                LEVEL_WITH_COMPARISON: 82,
                ELLIPSIS: 83,
                COLON: 84,
                NUMBER: 85,
                INFINITY: 86,
                INTEGRAL: 87,
                FACTORIAL: 88,
                "&": 89,
                PRIMES: 90,
                "?": 91,
                unknown: 92,
                UNKNOWN: 93,
                $accept: 0,
                $end: 1,
              },
              terminals_: {
                2: "error",
                5: "EOF",
                11: "OPEN_MODEXP",
                12: "MODEXP_UNDER",
                13: "MODEXP_OVER",
                14: "CLOSE_MODEXP",
                15: "RADICAL_INDEX",
                17: "OPEN_RADICAL",
                18: "CLOSE_RADICAL",
                20: "LEVEL",
                21: "BASELINE",
                23: "OPEN_FRAC",
                24: "SLASH",
                25: "CLOSE_FRAC",
                27: "GEO_TOKEN",
                48: ",",
                49: ".",
                50: "[",
                51: "{",
                52: "(",
                53: "]",
                54: "}",
                55: ")",
                56: "LANGLE",
                57: "RANGLE",
                58: "PIPE",
                59: "DOUBLE_PIPE",
                60: "SPACE",
                61: "COMMAND",
                62: "GREEK",
                63: "LETTER",
                64: "CAPITAL_LETTER",
                65: "+",
                66: "-",
                67: "CDOT",
                68: "TIMES",
                69: "*",
                70: "/",
                71: "DIV",
                72: "PERCENT_OF",
                73: "PERCENT",
                74: "MEASURED_ANGLE",
                75: "ANGLE",
                76: "CIRCLE",
                77: "PARALLELOGRAM",
                78: "TO",
                79: "TRIANGLE",
                80: "DEGREE",
                81: "COMPARISON",
                82: "LEVEL_WITH_COMPARISON",
                83: "ELLIPSIS",
                84: "COLON",
                85: "NUMBER",
                86: "INFINITY",
                87: "INTEGRAL",
                88: "FACTORIAL",
                89: "&",
                90: "PRIMES",
                91: "?",
                93: "UNKNOWN",
              },
              productions_: [
                0,
                [3, 2],
                [3, 1],
                [4, 2],
                [4, 1],
                [6, 1],
                [6, 1],
                [6, 2],
                [6, 1],
                [8, 7],
                [8, 6],
                [8, 5],
                [8, 6],
                [8, 5],
                [8, 5],
                [8, 4],
                [8, 4],
                [8, 3],
                [8, 4],
                [8, 4],
                [8, 4],
                [8, 4],
                [8, 3],
                [8, 3],
                [8, 2],
                [9, 5],
                [9, 4],
                [9, 4],
                [9, 3],
                [9, 3],
                [9, 2],
                [19, 1],
                [19, 1],
                [22, 5],
                [22, 4],
                [22, 4],
                [22, 3],
                [26, 2],
                [16, 2],
                [16, 1],
                [7, 3],
                [7, 2],
                [7, 2],
                [7, 3],
                [7, 2],
                [7, 2],
                [7, 1],
                [7, 1],
                [7, 1],
                [29, 1],
                [29, 1],
                [29, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [34, 1],
                [35, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [36, 1],
                [31, 1],
                [32, 1],
                [33, 1],
                [33, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [37, 1],
                [38, 1],
                [39, 1],
                [40, 1],
                [41, 1],
                [28, 1],
                [42, 1],
                [43, 1],
                [44, 1],
                [45, 1],
                [10, 1],
                [46, 1],
                [92, 1],
              ],
              performAction: function (Q, j, Ge, de, Ye, Ve, Qr) {
                var st = Ve.length - 1;
                switch (Ye) {
                  case 1:
                    return Ve[st - 1];
                  case 2:
                    return de.group();
                  case 3:
                  case 38:
                  case 42:
                  case 44:
                  case 45:
                    this.$ = de.group(Ve[st - 1], Ve[st]);
                    break;
                  case 4:
                  case 39:
                    this.$ = de.group(Ve[st]);
                    break;
                  case 7:
                    this.$ = de.group(Ve[st - 1], Ve[st]);
                    break;
                  case 9:
                    this.$ = de.modified_expression(
                      Ve[st - 5],
                      Ve[st - 3],
                      Ve[st - 1],
                    );
                    break;
                  case 10:
                    this.$ = de.modified_expression(
                      Ve[st - 4],
                      Ve[st - 2],
                    );
                    break;
                  case 11:
                    this.$ = de.modified_expression(
                      Ve[st - 3],
                      Ve[st - 1],
                    );
                    break;
                  case 12:
                    this.$ = de.modified_expression(
                      Ve[st - 4],
                      de.group(),
                      Ve[st - 1],
                    );
                    break;
                  case 13:
                    this.$ = de.modified_expression(
                      Ve[st - 3],
                      de.group(),
                      Ve[st - 1],
                    );
                    break;
                  case 14:
                    this.$ = de.modified_expression(
                      Ve[st - 3],
                      de.group(),
                      de.group(),
                    );
                    break;
                  case 15:
                  case 16:
                    this.$ = de.modified_expression(
                      Ve[st - 2],
                      de.group(),
                    );
                    break;
                  case 17:
                    this.$ = de.modified_expression(Ve[st - 1]);
                    break;
                  case 18:
                  case 19:
                  case 22:
                  case 23:
                  case 24:
                    this.$ = de.modified_expression(de.group());
                    break;
                  case 20:
                  case 21:
                    de.warnOrError(
                      "Multi-level modified expressions are not supported.",
                    ), this.$ = de.modified_expression(de.group());
                    break;
                  case 25:
                    this.$ = de.radical(Ve[st - 1], Ve[st - 3]);
                    break;
                  case 26:
                    this.$ = de.radical(Ve[st - 1], de.group());
                    break;
                  case 27:
                    this.$ = de.radical(de.group(), Ve[st - 2]);
                    break;
                  case 28:
                    this.$ = de.radical(de.group(), de.group());
                    break;
                  case 29:
                    this.$ = de.radical(Ve[st - 1]);
                    break;
                  case 30:
                    this.$ = de.radical(de.group());
                    break;
                  case 31:
                    this.$ = de.level(Ve[st]);
                    break;
                  case 32:
                    this.$ = de.baseline();
                    break;
                  case 33:
                    this.$ = de.fraction(Ve[st - 3], Ve[st - 1]);
                    break;
                  case 34:
                    this.$ = de.fraction(Ve[st - 2], de.group());
                    break;
                  case 35:
                    this.$ = de.fraction(de.group(), Ve[st - 1]);
                    break;
                  case 36:
                    this.$ = de.fraction(de.group(), de.group());
                    break;
                  case 37:
                    this.$ = de.geo_token(Ve[st]);
                    break;
                  case 40:
                    this.$ = de.group(
                      de.simple_subscript(Ve[st - 2], Ve[st]),
                      Ve[st - 1],
                    );
                    break;
                  case 41:
                    this.$ = de.simple_subscript(Ve[st - 1], Ve[st]);
                    break;
                  case 43:
                    de.warnOrError("Illegal use of Nemeth primes"),
                      this.$ = de.group(
                        de.simple_subscript(Ve[st - 2], Ve[st - 1]),
                        Ve[st],
                      );
                    break;
                  case 69:
                    this.$ = de.terminal(",");
                    break;
                  case 70:
                    this.$ = de.terminal(".");
                    break;
                  case 71:
                    this.$ = de.terminal("[");
                    break;
                  case 72:
                    this.$ = de.terminal("\\{");
                    break;
                  case 73:
                    this.$ = de.terminal("(");
                    break;
                  case 74:
                    this.$ = de.terminal("]");
                    break;
                  case 75:
                    this.$ = de.terminal("\\}");
                    break;
                  case 76:
                    this.$ = de.terminal(")");
                    break;
                  case 77:
                    this.$ = de.terminal("\\langle ");
                    break;
                  case 78:
                    this.$ = de.terminal("\\rangle ");
                    break;
                  case 79:
                    this.$ = de.terminal("|");
                    break;
                  case 80:
                    this.$ = de.terminal("\\|");
                    break;
                  case 81:
                    this.$ = de.terminal(" ");
                    break;
                  case 82:
                    this.$ = de.command(Ve[st].toLowerCase());
                    break;
                  case 83:
                    this.$ = de.terminal(de.greek(Ve[st]));
                    break;
                  case 84:
                    this.$ = de.terminal(Ve[st].toLowerCase());
                    break;
                  case 85:
                    this.$ = de.terminal(Ve[st].toUpperCase());
                    break;
                  case 86:
                    this.$ = de.terminal("+");
                    break;
                  case 87:
                    this.$ = de.terminal("-");
                    break;
                  case 88:
                    this.$ = de.terminal("\\cdot ");
                    break;
                  case 89:
                    this.$ = de.terminal("\\times ");
                    break;
                  case 90:
                    this.$ = de.terminal("*");
                    break;
                  case 91:
                    this.$ = de.terminal("/");
                    break;
                  case 92:
                    this.$ = de.terminal("\\div ");
                    break;
                  case 93:
                    this.$ = de.terminal("\\%\\operatorname{of}");
                    break;
                  case 94:
                    this.$ = de.terminal("\\%");
                    break;
                  case 95:
                    this.$ = de.terminal("\\measuredangle ");
                    break;
                  case 96:
                    this.$ = de.terminal("\\angle ");
                    break;
                  case 97:
                    this.$ = de.terminal("\\bigcirc ");
                    break;
                  case 98:
                    this.$ = de.terminal("\\parallelogram ");
                    break;
                  case 99:
                    this.$ = de.terminal("\\to ");
                    break;
                  case 100:
                    this.$ = de.terminal("\\triangle ");
                    break;
                  case 101:
                    this.$ = de.terminal("\\degree ");
                    break;
                  case 102:
                    this.$ = de.comparison(Ve[st].trim());
                    break;
                  case 103:
                    this.$ = de.level_with_comparison(Ve[st].trim());
                    break;
                  case 104:
                    this.$ = de.terminal("\\ldots ");
                    break;
                  case 105:
                    this.$ = de.terminal(":");
                    break;
                  case 106:
                    this.$ = de.terminal(Ve[st]);
                    break;
                  case 107:
                    this.$ = de.terminal("\\infty ");
                    break;
                  case 108:
                    this.$ = de.terminal("\\int ");
                    break;
                  case 109:
                    this.$ = de.terminal("!");
                    break;
                  case 110:
                    this.$ = de.terminal("\\&");
                    break;
                  case 111:
                    this.$ = de.primes(Ve[st]);
                    break;
                  case 112:
                    this.$ = de.terminal("?");
                    break;
                }
              },
              table: [
                {
                  3: 1,
                  4: 2,
                  5: [1, 3],
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  15: n,
                  17: a,
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                { 1: [3] },
                { 5: [1, 81] },
                { 1: [2, 2] },
                o(Be, [2, 4], {
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  29: 8,
                  28: 9,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  22: 32,
                  26: 33,
                  19: 34,
                  4: 82,
                  11: i,
                  15: n,
                  17: a,
                  20: s,
                  21: l,
                  23: c,
                  27: d,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                }),
                o(ce, [2, 5]),
                o(ce, [2, 6]),
                o(ce, [2, 8], { 10: 83, 90: ot }),
                o(it, [2, 46], { 10: 85, 28: 86, 85: _e, 90: ot }),
                o(ce, [2, 47], { 10: 87, 90: ot }),
                o(ce, [2, 48], { 10: 88, 90: ot }),
                {
                  4: 89,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  12: [1, 91],
                  13: [1, 90],
                  14: [1, 92],
                  15: n,
                  17: a,
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                {
                  7: 95,
                  16: 93,
                  17: [1, 94],
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                {
                  4: 96,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  15: n,
                  17: a,
                  18: [1, 97],
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                o(Se, [2, 49]),
                o(Se, [2, 50]),
                o(Se, [2, 51]),
                o(Se, [2, 106]),
                o(Se, [2, 52]),
                o(Se, [2, 53]),
                o(Se, [2, 54]),
                o(Se, [2, 55]),
                o(Se, [2, 56]),
                o(Se, [2, 57]),
                o(Se, [2, 58]),
                o(Se, [2, 59]),
                o(Se, [2, 60]),
                o(Se, [2, 61]),
                o(Se, [2, 62]),
                o(Se, [2, 63]),
                o(Se, [2, 64]),
                o(Se, [2, 65]),
                o(Se, [2, 66]),
                o(Se, [2, 67]),
                o(Se, [2, 68]),
                o(Se, [2, 82]),
                o(Se, [2, 83]),
                o(Se, [2, 84]),
                o(Se, [2, 85]),
                o(Se, [2, 69]),
                o(Se, [2, 70]),
                o(Se, [2, 81]),
                o(Se, [2, 86]),
                o(Se, [2, 87]),
                o(Se, [2, 88]),
                o(Se, [2, 89]),
                o(Se, [2, 90]),
                o(Se, [2, 91]),
                o(Se, [2, 92]),
                o(Se, [2, 93]),
                o(Se, [2, 94]),
                o(Se, [2, 95]),
                o(Se, [2, 96]),
                o(Se, [2, 97]),
                o(Se, [2, 98]),
                o(Se, [2, 99]),
                o(Se, [2, 100]),
                o(Se, [2, 101]),
                o(Se, [2, 102]),
                o(Se, [2, 103]),
                o(Se, [2, 104]),
                o(Se, [2, 105]),
                o(Se, [2, 107]),
                o(Se, [2, 108]),
                o(Se, [2, 109]),
                o(Se, [2, 110]),
                o(Se, [2, 112]),
                o(Se, [2, 71]),
                o(Se, [2, 72]),
                o(Se, [2, 73]),
                o(Se, [2, 74]),
                o(Se, [2, 75]),
                o(Se, [2, 76]),
                o(Se, [2, 77]),
                o(Se, [2, 78]),
                o(Se, [2, 79]),
                o(Se, [2, 80]),
                {
                  4: 98,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  15: n,
                  17: a,
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  24: [1, 99],
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                { 28: 100, 85: _e },
                o(Se, [2, 31]),
                o(Se, [2, 32]),
                { 1: [2, 1] },
                o(Be, [2, 3]),
                o(ce, [2, 7]),
                o(ce, [2, 111]),
                o(it, [2, 42], { 28: 101, 85: _e }),
                o(ce, [2, 41], { 10: 102, 90: ot }),
                o(ce, [2, 44]),
                o(ce, [2, 45]),
                { 12: [1, 103], 13: [1, 104], 14: [1, 105] },
                { 12: [1, 106], 13: [1, 107], 14: [1, 108] },
                { 12: [1, 110], 13: [1, 109], 14: [1, 111] },
                o(ce, [2, 24]),
                { 17: [1, 112] },
                {
                  4: 113,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  15: n,
                  17: a,
                  18: [1, 114],
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                {
                  7: 95,
                  16: 115,
                  17: [2, 39],
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                { 18: [1, 116] },
                o(Se, [2, 30]),
                { 24: [1, 117] },
                {
                  4: 118,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  15: n,
                  17: a,
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  25: [1, 119],
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                o(Se, [2, 37]),
                o(ce, [2, 40]),
                o(ce, [2, 43]),
                {
                  4: 120,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  13: [1, 121],
                  14: [1, 122],
                  15: n,
                  17: a,
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                {
                  4: 123,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  14: [1, 124],
                  15: n,
                  17: a,
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                o(ce, [2, 17]),
                { 14: [1, 125] },
                { 14: [1, 126] },
                o(ce, [2, 22]),
                { 14: [1, 127] },
                { 14: [1, 128] },
                o(ce, [2, 23]),
                {
                  4: 129,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  15: n,
                  17: a,
                  18: [1, 130],
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                { 18: [1, 131] },
                o(Se, [2, 28]),
                { 17: [2, 38] },
                o(Se, [2, 29]),
                {
                  4: 132,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  15: n,
                  17: a,
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  25: [1, 133],
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                { 25: [1, 134] },
                o(Se, [2, 36]),
                { 13: [1, 135], 14: [1, 136] },
                {
                  4: 137,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  14: [1, 138],
                  15: n,
                  17: a,
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                o(ce, [2, 16]),
                { 14: [1, 139] },
                o(ce, [2, 15]),
                o(ce, [2, 18]),
                o(ce, [2, 20]),
                o(ce, [2, 19]),
                o(ce, [2, 21]),
                { 18: [1, 140] },
                o(Se, [2, 27]),
                o(Se, [2, 26]),
                { 25: [1, 141] },
                o(Se, [2, 34]),
                o(Se, [2, 35]),
                {
                  4: 142,
                  6: 4,
                  7: 5,
                  8: 6,
                  9: 7,
                  11: i,
                  14: [1, 143],
                  15: n,
                  17: a,
                  19: 34,
                  20: s,
                  21: l,
                  22: 32,
                  23: c,
                  26: 33,
                  27: d,
                  28: 9,
                  29: 8,
                  30: 10,
                  31: 14,
                  32: 15,
                  33: 16,
                  34: 18,
                  35: 19,
                  36: 20,
                  37: 21,
                  38: 22,
                  39: 23,
                  40: 24,
                  41: 25,
                  42: 26,
                  43: 27,
                  44: 28,
                  45: 29,
                  46: 30,
                  47: 31,
                  48: p,
                  49: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: v,
                  56: w,
                  57: S,
                  58: k,
                  59: _,
                  60: A,
                  61: P,
                  62: O,
                  63: U,
                  64: z,
                  65: x,
                  66: L,
                  67: V,
                  68: R,
                  69: N,
                  70: M,
                  71: F,
                  72: Z,
                  73: te,
                  74: Y,
                  75: he,
                  76: se,
                  77: ae,
                  78: q,
                  79: oe,
                  80: K,
                  81: fe,
                  82: me,
                  83: we,
                  84: Ce,
                  85: _e,
                  86: We,
                  87: $,
                  88: W,
                  89: ue,
                  91: Ee,
                },
                o(ce, [2, 11]),
                { 14: [1, 144] },
                o(ce, [2, 14]),
                o(ce, [2, 13]),
                o(Se, [2, 25]),
                o(Se, [2, 33]),
                { 14: [1, 145] },
                o(ce, [2, 10]),
                o(ce, [2, 12]),
                o(ce, [2, 9]),
              ],
              defaultActions: { 3: [2, 2], 81: [2, 1], 115: [2, 38] },
              parseError: function (Q, j) {
                if (j.recoverable) this.trace(Q);
                else {
                  var Ge = new Error(Q);
                  throw Ge.hash = j, Ge;
                }
              },
              parse: function (Q) {
                var j = this,
                  Ge = [0],
                  de = [],
                  Ye = [null],
                  Ve = [],
                  Qr = this.table,
                  st = "",
                  Bn = 0,
                  co = 0,
                  Vo = 0,
                  Ue = 2,
                  at = 1,
                  ft = Ve.slice.call(arguments, 1),
                  be = Object.create(this.lexer),
                  J = { yy: {} };
                for (var pe in this.yy) {
                  Object.prototype.hasOwnProperty.call(this.yy, pe) &&
                    (J.yy[pe] = this.yy[pe]);
                }
                be.setInput(Q, J.yy),
                  J.yy.lexer = be,
                  J.yy.parser = this,
                  typeof be.yylloc == "undefined" && (be.yylloc = {});
                var Ne = be.yylloc;
                Ve.push(Ne);
                var Te = be.options && be.options.ranges;
                typeof J.yy.parseError == "function"
                  ? this.parseError = J.yy.parseError
                  : this.parseError = Object.getPrototypeOf(this).parseError;
                function dt(en) {
                  Ge.length = Ge.length - 2 * en,
                    Ye.length = Ye.length - en,
                    Ve.length = Ve.length - en;
                }
                for (
                  var ut = function () {
                      var en;
                      return en = be.lex() || at,
                        typeof en != "number" &&
                        (en = j.symbols_[en] || en),
                        en;
                    },
                    kt,
                    Qt,
                    Gt,
                    Vt,
                    Ct,
                    xr,
                    Zt = {},
                    Xo,
                    Zi,
                    na,
                    xn;;
                ) {
                  if (
                    Gt = Ge[Ge.length - 1],
                      this.defaultActions[Gt]
                        ? Vt = this.defaultActions[Gt]
                        : ((kt === null || typeof kt == "undefined") &&
                          (kt = ut()),
                          Vt = Qr[Gt] && Qr[Gt][kt]),
                      typeof Vt == "undefined" || !Vt.length || !Vt[0]
                  ) {
                    var Ho = "";
                    xn = [];
                    for (Xo in Qr[Gt]) {
                      this.terminals_[Xo] && Xo > Ue &&
                        xn.push("'" + this.terminals_[Xo] + "'");
                    }
                    be.showPosition
                      ? Ho = "Parse error on line " + (Bn + 1) + `:
` + be.showPosition() + `
Expecting ` + xn.join(", ") + ", got '" + (this.terminals_[kt] || kt) + "'"
                      : Ho = "Parse error on line " + (Bn + 1) +
                        ": Unexpected " + (kt == at
                          ? "end of input"
                          : "'" + (this.terminals_[kt] || kt) + "'"),
                      this.parseError(Ho, {
                        text: be.match,
                        token: this.terminals_[kt] || kt,
                        line: be.yylineno,
                        loc: Ne,
                        expected: xn,
                      });
                  }
                  if (Vt[0] instanceof Array && Vt.length > 1) {
                    throw new Error(
                      "Parse Error: multiple actions possible at state: " +
                        Gt + ", token: " + kt,
                    );
                  }
                  switch (Vt[0]) {
                    case 1:
                      Ge.push(kt),
                        Ye.push(be.yytext),
                        Ve.push(be.yylloc),
                        Ge.push(Vt[1]),
                        kt = null,
                        Qt
                          ? (kt = Qt, Qt = null)
                          : (co = be.yyleng,
                            st = be.yytext,
                            Bn = be.yylineno,
                            Ne = be.yylloc,
                            Vo > 0 && Vo--);
                      break;
                    case 2:
                      if (
                        Zi = this.productions_[Vt[1]][1],
                          Zt.$ = Ye[Ye.length - Zi],
                          Zt._$ = {
                            first_line: Ve[Ve.length - (Zi || 1)].first_line,
                            last_line: Ve[Ve.length - 1].last_line,
                            first_column:
                              Ve[Ve.length - (Zi || 1)].first_column,
                            last_column: Ve[Ve.length - 1].last_column,
                          },
                          Te &&
                          (Zt._$.range = [
                            Ve[Ve.length - (Zi || 1)].range[0],
                            Ve[Ve.length - 1].range[1],
                          ]),
                          xr = this.performAction.apply(
                            Zt,
                            [st, co, Bn, J.yy, Vt[1], Ye, Ve].concat(ft),
                          ),
                          typeof xr != "undefined"
                      ) return xr;
                      Zi &&
                      (Ge = Ge.slice(0, -1 * Zi * 2),
                        Ye = Ye.slice(0, -1 * Zi),
                        Ve = Ve.slice(0, -1 * Zi)),
                        Ge.push(this.productions_[Vt[1]][0]),
                        Ye.push(Zt.$),
                        Ve.push(Zt._$),
                        na = Qr[Ge[Ge.length - 2]][Ge[Ge.length - 1]],
                        Ge.push(na);
                      break;
                    case 3:
                      return true;
                  }
                }
                return true;
              },
            },
            It = function () {
              var Mr = {
                EOF: 1,
                parseError: function (j, Ge) {
                  if (this.yy.parser) this.yy.parser.parseError(j, Ge);
                  else throw new Error(j);
                },
                setInput: function (Q, j) {
                  return this.yy = j || this.yy || {},
                    this._input = Q,
                    this._more = this._backtrack = this.done = false,
                    this.yylineno = this.yyleng = 0,
                    this.yytext = this.matched = this.match = "",
                    this.conditionStack = ["INITIAL"],
                    this.yylloc = {
                      first_line: 1,
                      first_column: 0,
                      last_line: 1,
                      last_column: 0,
                    },
                    this.options.ranges && (this.yylloc.range = [0, 0]),
                    this.offset = 0,
                    this;
                },
                input: function () {
                  var Q = this._input[0];
                  this.yytext += Q,
                    this.yyleng++,
                    this.offset++,
                    this.match += Q,
                    this.matched += Q;
                  var j = Q.match(/(?:\r\n?|\n).*/g);
                  return j
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                    this.options.ranges && this.yylloc.range[1]++,
                    this._input = this._input.slice(1),
                    Q;
                },
                unput: function (Q) {
                  var j = Q.length, Ge = Q.split(/(?:\r\n?|\n)/g);
                  this._input = Q + this._input,
                    this.yytext = this.yytext.substr(
                      0,
                      this.yytext.length - j,
                    ),
                    this.offset -= j;
                  var de = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(
                    0,
                    this.match.length - 1,
                  ),
                    this.matched = this.matched.substr(
                      0,
                      this.matched.length - 1,
                    ),
                    Ge.length - 1 && (this.yylineno -= Ge.length - 1);
                  var Ye = this.yylloc.range;
                  return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: Ge
                      ? (Ge.length === de.length
                        ? this.yylloc.first_column
                        : 0) +
                        de[de.length - Ge.length].length - Ge[0].length
                      : this.yylloc.first_column - j,
                  },
                    this.options.ranges &&
                    (this.yylloc.range = [
                      Ye[0],
                      Ye[0] + this.yyleng - j,
                    ]),
                    this.yyleng = this.yytext.length,
                    this;
                },
                more: function () {
                  return this._more = true, this;
                },
                reject: function () {
                  if (this.options.backtrack_lexer) this._backtrack = true;
                  else {return this.parseError(
                      "Lexical error on line " + (this.yylineno + 1) +
                        `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(),
                      { text: "", token: null, line: this.yylineno },
                    );}
                  return this;
                },
                less: function (Q) {
                  this.unput(this.match.slice(Q));
                },
                pastInput: function () {
                  var Q = this.matched.substr(
                    0,
                    this.matched.length - this.match.length,
                  );
                  return (Q.length > 20 ? "..." : "") +
                    Q.substr(-20).replace(/\n/g, "");
                },
                upcomingInput: function () {
                  var Q = this.match;
                  return Q.length < 20 &&
                    (Q += this._input.substr(0, 20 - Q.length)),
                    (Q.substr(0, 20) + (Q.length > 20 ? "..." : ""))
                      .replace(/\n/g, "");
                },
                showPosition: function () {
                  var Q = this.pastInput(),
                    j = new Array(Q.length + 1).join("-");
                  return Q + this.upcomingInput() + `
` + j + "^";
                },
                test_match: function (Q, j) {
                  var Ge, de, Ye;
                  if (
                    this.options.backtrack_lexer && (Ye = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    },
                      this.options.ranges &&
                      (Ye.yylloc.range = this.yylloc.range.slice(0))),
                      de = Q[0].match(/(?:\r\n?|\n).*/g),
                      de && (this.yylineno += de.length),
                      this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: de
                          ? de[de.length - 1].length -
                            de[de.length - 1].match(/\r?\n?/)[0].length
                          : this.yylloc.last_column + Q[0].length,
                      },
                      this.yytext += Q[0],
                      this.match += Q[0],
                      this.matches = Q,
                      this.yyleng = this.yytext.length,
                      this.options.ranges &&
                      (this.yylloc.range = [
                        this.offset,
                        this.offset += this.yyleng,
                      ]),
                      this._more = false,
                      this._backtrack = false,
                      this._input = this._input.slice(Q[0].length),
                      this.matched += Q[0],
                      Ge = this.performAction.call(
                        this,
                        this.yy,
                        this,
                        j,
                        this
                          .conditionStack[this.conditionStack.length - 1],
                      ),
                      this.done && this._input && (this.done = false),
                      Ge
                  ) return Ge;
                  if (this._backtrack) {
                    for (var Ve in Ye) this[Ve] = Ye[Ve];
                    return false;
                  }
                  return false;
                },
                next: function () {
                  if (this.done) return this.EOF;
                  this._input || (this.done = true);
                  var Q, j, Ge, de;
                  this._more || (this.yytext = "", this.match = "");
                  for (
                    var Ye = this._currentRules(), Ve = 0;
                    Ve < Ye.length;
                    Ve++
                  ) {
                    if (
                      Ge = this._input.match(this.rules[Ye[Ve]]),
                        Ge && (!j || Ge[0].length > j[0].length)
                    ) {
                      if (j = Ge, de = Ve, this.options.backtrack_lexer) {
                        if (Q = this.test_match(Ge, Ye[Ve]), Q !== false) {
                          return Q;
                        }
                        if (this._backtrack) {
                          j = false;
                          continue;
                        } else return false;
                      } else if (!this.options.flex) {
                        break;
                      }
                    }
                  }
                  return j
                    ? (Q = this.test_match(j, Ye[de]), Q !== false ? Q : false)
                    : this._input === ""
                    ? this.EOF
                    : this.parseError(
                      "Lexical error on line " + (this.yylineno + 1) +
                        `. Unrecognized text.
` + this.showPosition(),
                      { text: "", token: null, line: this.yylineno },
                    );
                },
                lex: function () {
                  var j = this.next();
                  return j || this.lex();
                },
                begin: function (j) {
                  this.conditionStack.push(j);
                },
                popState: function () {
                  var j = this.conditionStack.length - 1;
                  return j > 0
                    ? this.conditionStack.pop()
                    : this.conditionStack[0];
                },
                _currentRules: function () {
                  return this.conditionStack.length &&
                      this.conditionStack[this.conditionStack.length - 1]
                    ? this
                      .conditions[
                        this
                          .conditionStack[this.conditionStack.length - 1]
                      ].rules
                    : this.conditions.INITIAL.rules;
                },
                topState: function (j) {
                  return j = this.conditionStack.length - 1 -
                    Math.abs(j || 0),
                    j >= 0 ? this.conditionStack[j] : "INITIAL";
                },
                pushState: function (j) {
                  this.begin(j);
                },
                stateStackSize: function () {
                  return this.conditionStack.length;
                },
                options: {},
                performAction: function (j, Ge, de, Ye) {
                  var Ve = Ye;
                  switch (de) {
                    case 0:
                      return this.begin("modexp"), 11;
                      break;
                    case 1:
                      return 21;
                    case 2:
                      return this.begin("modexp"), 11;
                      break;
                    case 3:
                      return 12;
                    case 4:
                      return 13;
                    case 5:
                      return this.popState(), 14;
                      break;
                    case 6:
                      return 65;
                    case 7:
                      return 66;
                    case 8:
                      return 67;
                    case 9:
                      return 68;
                    case 10:
                      return 69;
                    case 11:
                      return 70;
                    case 12:
                      return 71;
                    case 13:
                      return 56;
                    case 14:
                      return 50;
                    case 15:
                      return 51;
                    case 16:
                      return 52;
                    case 17:
                      return 57;
                    case 18:
                      return 53;
                    case 19:
                      return 54;
                    case 20:
                      return 55;
                    case 21:
                      return 59;
                    case 22:
                      return 58;
                    case 23:
                      return 84;
                    case 24:
                      return 72;
                    case 25:
                      return 73;
                    case 26:
                      return 74;
                    case 27:
                      return 75;
                    case 28:
                      return 76;
                    case 29:
                      return 77;
                    case 30:
                      return 78;
                    case 31:
                      return 79;
                    case 32:
                      return 80;
                    case 33:
                      return 82;
                    case 34:
                      return 82;
                    case 35:
                      return 82;
                    case 36:
                      return 82;
                    case 37:
                      return 82;
                    case 38:
                      return 82;
                    case 39:
                      return 82;
                    case 40:
                      return 82;
                    case 41:
                      return 82;
                    case 42:
                      return 81;
                    case 43:
                      return 82;
                    case 44:
                      return 82;
                    case 45:
                      return 81;
                    case 46:
                      return 81;
                    case 47:
                      return 81;
                    case 48:
                      return 81;
                    case 49:
                      return 81;
                    case 50:
                      return 81;
                    case 51:
                      return 81;
                    case 52:
                      return 81;
                    case 53:
                      return 81;
                    case 54:
                      return 81;
                    case 55:
                      return 81;
                    case 56:
                      return 83;
                    case 57:
                      return 20;
                    case 58:
                      return 49;
                    case 59:
                      return 21;
                    case 60:
                      return 90;
                    case 61:
                      return 62;
                    case 62:
                      return 15;
                    case 63:
                      return this.begin("radical"), 17;
                      break;
                    case 64:
                      return this.popState(), 18;
                      break;
                    case 65:
                      return 18;
                    case 66:
                      return 87;
                    case 67:
                      return 89;
                    case 68:
                      return 88;
                    case 69:
                      return 61;
                    case 70:
                      return 61;
                    case 71:
                      return 27;
                    case 72:
                      return Ge.yytext = this.matches[1], 85;
                      break;
                    case 73:
                      return 23;
                    case 74:
                      return 24;
                    case 75:
                      return 25;
                    case 76:
                      return Ge.yytext = this.matches[1], 64;
                      break;
                    case 77:
                      return 63;
                    case 78:
                      return 86;
                    case 79:
                      return 91;
                    case 80:
                      return 48;
                    case 81:
                      return 49;
                    case 82:
                      return 60;
                    case 83:
                      return 5;
                    case 84:
                      return 93;
                  }
                },
                rules: [
                  /^(?:"(?=[^>\]]+%))/,
                  /^(?:")/,
                  /^(?:"(?=[^>\]]+\]|[^>\]]+%))/,
                  /^(?:%)/,
                  /^(?:<)/,
                  /^(?:\])/,
                  /^(?:[+])/,
                  /^(?:[-])/,
                  /^(?:[*])/,
                  /^(?:[@][*])/,
                  /^(?:[@][\#])/,
                  /^(?:[_][/])/,
                  /^(?:[.][/])/,
                  /^(?:[.][.][(])/,
                  /^(?:[@][(])/,
                  /^(?:[.][(])/,
                  /^(?:[(])/,
                  /^(?:[.][.][)])/,
                  /^(?:[@][)])/,
                  /^(?:[.][)])/,
                  /^(?:[)])/,
                  /^(?:[\\][\\])/,
                  /^(?:[\\])/,
                  /^(?:[_][3])/,
                  /^(?:[@][0][O][F][ ]?)/,
                  /^(?:[@][0])/,
                  /^(?:[M][$][\[][ ])/,
                  /^(?:[$][\[][ ])/,
                  /^(?:[$]C[ ])/,
                  /^(?:[$]G[ ])/,
                  /^(?:[ ][$]O[ ])/,
                  /^(?:[$]T[ ])/,
                  /^(?:[^][.][*])/,
                  /^(?:[ ][\^;]+[.]K[ ])/,
                  /^(?:[\^;]+[=])/,
                  /^(?:[ ][\^;]+[/][.]K[ ])/,
                  /^(?:[ ][\^;]+[@][:][@][:][ ])/,
                  /^(?:[ ][\^;]+["]K[:][ ])/,
                  /^(?:[ ][\^;]+[.]1[:][ ])/,
                  /^(?:[ ][\^;]+["]K[ ])/,
                  /^(?:[ ][\^;]+[.]1[ ])/,
                  /^(?:[ ][\^;]+[/][$][L][ ])/,
                  /^(?:[ ][.]K[ ])/,
                  /^(?:[ ][\^;]+[/]?[$][L][ ])/,
                  /^(?:[ ][\^;]+[$]P[ ])/,
                  /^(?:[=])/,
                  /^(?:[ ][/][.]K[ ])/,
                  /^(?:[ ][@][:][@][:][ ])/,
                  /^(?:[ ][/]?[@][:][.][K][ ])/,
                  /^(?:[ ]["]K[:][ ])/,
                  /^(?:[ ][.]1[:][ ])/,
                  /^(?:[ ]["]K[ ])/,
                  /^(?:[ ][.]1[ ])/,
                  /^(?:[/]?[@][:])/,
                  /^(?:[ ][/]?[$][L][ ])/,
                  /^(?:[ ][$]P[ ])/,
                  /^(?:[ ]['][']['][ ])/,
                  /^(?:[\^;]+)/,
                  /^(?:[.]["])/,
                  /^(?:["])/,
                  /^(?:[']+)/,
                  /^(?:[.][,]?[ABGDEZ\?\:IKLMNXOPRSTUYF\&W])/,
                  /^(?:[.]*[<])/,
                  /^(?:[.]*[>])/,
                  /^(?:[.]*\])/,
                  /^(?:[.]*\])/,
                  /^(?:!)/,
                  /^(?:[_]&)/,
                  /^(?:&)/,
                  /^(?:(ARC)?(SIN|COS|TAN|CSC|SEC|COT)(H)?)/,
                  /^(?:(ARG|DET|EXP|IM|INF|LIM|LN|LOG|MAX|MIN|MOD|RE|SUP))/,
                  /^(?:(TOKEN)[ ]?)/,
                  /^(?:#?(\d*\.?\d+))/,
                  /^(?:[,]*[?])/,
                  /^(?:[,]*[/])/,
                  /^(?:[,]*#)/,
                  /^(?:[,]([A-Z]))/,
                  /^(?:[A-Z])/,
                  /^(?:[,][=])/,
                  /^(?:[_][8])/,
                  /^(?:[,][ ]?)/,
                  /^(?:[.])/,
                  /^(?:[ ])/,
                  /^(?:$)/,
                  /^(?:.)/,
                ],
                conditions: {
                  radical: {
                    rules: [
                      0,
                      1,
                      2,
                      6,
                      7,
                      8,
                      9,
                      10,
                      11,
                      12,
                      13,
                      14,
                      15,
                      16,
                      17,
                      18,
                      19,
                      20,
                      21,
                      22,
                      23,
                      24,
                      25,
                      26,
                      27,
                      28,
                      29,
                      30,
                      31,
                      32,
                      33,
                      34,
                      35,
                      36,
                      37,
                      38,
                      39,
                      40,
                      41,
                      42,
                      43,
                      44,
                      45,
                      46,
                      47,
                      48,
                      49,
                      50,
                      51,
                      52,
                      53,
                      54,
                      55,
                      56,
                      57,
                      58,
                      59,
                      60,
                      61,
                      62,
                      63,
                      64,
                      65,
                      66,
                      67,
                      68,
                      69,
                      70,
                      71,
                      72,
                      73,
                      74,
                      75,
                      76,
                      77,
                      78,
                      79,
                      80,
                      81,
                      82,
                      83,
                      84,
                    ],
                    inclusive: true,
                  },
                  modexp: {
                    rules: [
                      2,
                      3,
                      4,
                      5,
                      6,
                      7,
                      8,
                      9,
                      10,
                      11,
                      12,
                      13,
                      14,
                      15,
                      16,
                      17,
                      18,
                      19,
                      20,
                      21,
                      22,
                      23,
                      24,
                      25,
                      26,
                      27,
                      28,
                      29,
                      30,
                      31,
                      32,
                      33,
                      34,
                      35,
                      36,
                      37,
                      38,
                      39,
                      40,
                      41,
                      42,
                      43,
                      44,
                      45,
                      46,
                      47,
                      48,
                      49,
                      50,
                      51,
                      52,
                      53,
                      54,
                      55,
                      56,
                      57,
                      58,
                      59,
                      60,
                      61,
                      62,
                      63,
                      65,
                      66,
                      67,
                      68,
                      69,
                      70,
                      71,
                      72,
                      73,
                      74,
                      75,
                      76,
                      77,
                      78,
                      79,
                      80,
                      81,
                      82,
                      83,
                      84,
                    ],
                    inclusive: true,
                  },
                  INITIAL: {
                    rules: [
                      2,
                      6,
                      7,
                      8,
                      9,
                      10,
                      11,
                      12,
                      13,
                      14,
                      15,
                      16,
                      17,
                      18,
                      19,
                      20,
                      21,
                      22,
                      23,
                      24,
                      25,
                      26,
                      27,
                      28,
                      29,
                      30,
                      31,
                      32,
                      33,
                      34,
                      35,
                      36,
                      37,
                      38,
                      39,
                      40,
                      41,
                      42,
                      43,
                      44,
                      45,
                      46,
                      47,
                      48,
                      49,
                      50,
                      51,
                      52,
                      53,
                      54,
                      55,
                      56,
                      57,
                      58,
                      59,
                      60,
                      61,
                      62,
                      63,
                      65,
                      66,
                      67,
                      68,
                      69,
                      70,
                      71,
                      72,
                      73,
                      74,
                      75,
                      76,
                      77,
                      78,
                      79,
                      80,
                      81,
                      82,
                      83,
                      84,
                    ],
                    inclusive: true,
                  },
                },
              };
              return Mr;
            }();
          Lt.lexer = It;
          function Dt() {
            this.yy = {};
          }
          return Dt.prototype = Lt, Lt.Parser = Dt, new Dt();
        }();
        typeof Qm != "undefined" && typeof r != "undefined" &&
          (r.parser = t,
            r.Parser = t.Parser,
            r.parse = function () {
              return t.parse.apply(t, arguments);
            },
            r.main = function () {},
            typeof e != "undefined" && Qm.main === e &&
            r.main(process.argv.slice(1)));
      },
    }),
    k3 = nM({
      "generated/ueb-to-latex.jison.js"(r, e) {
        "use strict";
        var t = function () {
          var o = function (Vo, Ue, at, ft) {
              for (at = at || {}, ft = Vo.length; ft--; at[Vo[ft]] = Ue);
              return at;
            },
            i = [1, 15],
            n = [1, 16],
            a = [1, 17],
            s = [1, 37],
            l = [1, 38],
            c = [1, 39],
            d = [1, 40],
            p = [1, 45],
            h = [1, 14],
            u = [1, 49],
            f = [1, 50],
            y = [1, 41],
            C = [1, 42],
            E = [1, 43],
            v = [1, 59],
            w = [1, 44],
            S = [1, 46],
            k = [1, 47],
            _ = [1, 48],
            A = [1, 57],
            P = [1, 58],
            O = [1, 60],
            U = [1, 61],
            z = [1, 62],
            x = [1, 63],
            L = [1, 64],
            V = [1, 65],
            R = [1, 66],
            N = [1, 67],
            M = [1, 68],
            F = [1, 69],
            Z = [1, 70],
            te = [1, 71],
            Y = [1, 72],
            he = [1, 73],
            se = [1, 74],
            ae = [1, 75],
            q = [1, 76],
            oe = [1, 77],
            K = [1, 78],
            fe = [1, 79],
            me = [1, 80],
            we = [1, 81],
            Ce = [1, 82],
            _e = [1, 83],
            We = [1, 84],
            $ = [1, 85],
            W = [1, 86],
            ue = [1, 87],
            Ee = [1, 88],
            Be = [1, 89],
            ce = [1, 51],
            ot = [1, 52],
            it = [1, 53],
            Se = [1, 54],
            Lt = [1, 55],
            It = [1, 90],
            Dt = [1, 56],
            Mr = [5, 14, 18, 19, 32, 55, 56, 57],
            Q = [5, 10, 13, 14, 15, 18, 19, 32, 55, 56, 57],
            j = [
              5,
              10,
              13,
              14,
              15,
              17,
              18,
              19,
              21,
              23,
              24,
              26,
              31,
              32,
              50,
              51,
              52,
              53,
              54,
              55,
              56,
              57,
              58,
              59,
              60,
              61,
              62,
              63,
              64,
              65,
              66,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              75,
              76,
              77,
              78,
              79,
              80,
              81,
              82,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              90,
              91,
              92,
              93,
              94,
              95,
              96,
              97,
              98,
              99,
              100,
              101,
            ],
            Ge = [1, 98],
            de = [1, 99],
            Ye = [1, 100],
            Ve = [2, 40],
            Qr = [
              10,
              13,
              15,
              17,
              21,
              23,
              24,
              26,
              31,
              50,
              51,
              52,
              53,
              54,
              55,
              56,
              57,
              58,
              59,
              60,
              61,
              62,
              63,
              64,
              65,
              66,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              75,
              76,
              77,
              78,
              79,
              80,
              81,
              82,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              90,
              91,
              92,
              93,
              94,
              95,
              96,
              97,
              98,
              99,
              100,
              101,
            ],
            st = {
              trace: function () {},
              yy: {},
              symbols_: {
                error: 2,
                sentence: 3,
                group: 4,
                EOF: 5,
                expression_group: 6,
                delimited_expression: 7,
                level: 8,
                radical: 9,
                LEVEL: 10,
                basic_token: 11,
                bracketed_expression: 12,
                RADICAL_WITH_INDEX: 13,
                CLOSE_RADICAL: 14,
                RADICAL: 15,
                frac: 16,
                OPEN_FRAC: 17,
                OVER: 18,
                CLOSE_FRAC: 19,
                simple_frac: 20,
                NUMBER: 21,
                NUMBER_FRAC_DENOMINATOR: 22,
                NUMBER_FRAC_NUMERATOR_BAD: 23,
                NUMBER_FRAC_DENOMINATOR_BAD: 24,
                geo_token: 25,
                GEO_TOKEN: 26,
                number: 27,
                atom: 28,
                lbracket: 29,
                rbracket: 30,
                OPEN_GROUP: 31,
                CLOSE_GROUP: 32,
                command: 33,
                greek: 34,
                letter: 35,
                comma: 36,
                period: 37,
                colon: 38,
                infinity: 39,
                integral: 40,
                factorial: 41,
                ampersand: 42,
                question_mark: 43,
                bracket: 44,
                space: 45,
                operation: 46,
                comparison: 47,
                ellipsis: 48,
                primes: 49,
                ",": 50,
                ".": 51,
                "[": 52,
                "{": 53,
                "(": 54,
                "]": 55,
                "}": 56,
                ")": 57,
                SPACE: 58,
                COMMAND: 59,
                GREEK: 60,
                CAPITAL_LETTER: 61,
                LETTER: 62,
                PIPE: 63,
                DOUBLE_PIPE: 64,
                "+": 65,
                "-": 66,
                CDOT: 67,
                TIMES: 68,
                "*": 69,
                DIV: 70,
                SLASH: 71,
                PERCENT_OF: 72,
                PERCENT: 73,
                TO: 74,
                ANGLE: 75,
                MEASURED_ANGLE: 76,
                DEGREE: 77,
                CIRCLE: 78,
                PARALLELOGRAM: 79,
                TRIANGLE: 80,
                "=": 81,
                NEQ: 82,
                "<": 83,
                ">": 84,
                LEQ: 85,
                APPROX: 86,
                GEQ: 87,
                SIM: 88,
                NSIM: 89,
                PARALLEL: 90,
                PERPENDICULAR: 91,
                CONG: 92,
                NCONG: 93,
                ELLIPSIS: 94,
                COLON: 95,
                INFINITY: 96,
                INTEGRAL: 97,
                FACTORIAL: 98,
                "&": 99,
                PRIMES: 100,
                "?": 101,
                unknown: 102,
                UNKNOWN: 103,
                $accept: 0,
                $end: 1,
              },
              terminals_: {
                2: "error",
                5: "EOF",
                10: "LEVEL",
                13: "RADICAL_WITH_INDEX",
                14: "CLOSE_RADICAL",
                15: "RADICAL",
                17: "OPEN_FRAC",
                18: "OVER",
                19: "CLOSE_FRAC",
                21: "NUMBER",
                22: "NUMBER_FRAC_DENOMINATOR",
                23: "NUMBER_FRAC_NUMERATOR_BAD",
                24: "NUMBER_FRAC_DENOMINATOR_BAD",
                26: "GEO_TOKEN",
                31: "OPEN_GROUP",
                32: "CLOSE_GROUP",
                50: ",",
                51: ".",
                52: "[",
                53: "{",
                54: "(",
                55: "]",
                56: "}",
                57: ")",
                58: "SPACE",
                59: "COMMAND",
                60: "GREEK",
                61: "CAPITAL_LETTER",
                62: "LETTER",
                63: "PIPE",
                64: "DOUBLE_PIPE",
                65: "+",
                66: "-",
                67: "CDOT",
                68: "TIMES",
                69: "*",
                70: "DIV",
                71: "SLASH",
                72: "PERCENT_OF",
                73: "PERCENT",
                74: "TO",
                75: "ANGLE",
                76: "MEASURED_ANGLE",
                77: "DEGREE",
                78: "CIRCLE",
                79: "PARALLELOGRAM",
                80: "TRIANGLE",
                81: "=",
                82: "NEQ",
                83: "<",
                84: ">",
                85: "LEQ",
                86: "APPROX",
                87: "GEQ",
                88: "SIM",
                89: "NSIM",
                90: "PARALLEL",
                91: "PERPENDICULAR",
                92: "CONG",
                93: "NCONG",
                94: "ELLIPSIS",
                95: "COLON",
                96: "INFINITY",
                97: "INTEGRAL",
                98: "FACTORIAL",
                99: "&",
                100: "PRIMES",
                101: "?",
                103: "UNKNOWN",
              },
              productions_: [
                0,
                [3, 2],
                [3, 1],
                [4, 3],
                [4, 2],
                [4, 1],
                [4, 2],
                [4, 1],
                [7, 1],
                [7, 1],
                [8, 2],
                [8, 2],
                [8, 2],
                [9, 4],
                [9, 3],
                [9, 3],
                [9, 2],
                [9, 4],
                [9, 3],
                [9, 2],
                [16, 5],
                [16, 4],
                [16, 4],
                [16, 3],
                [16, 2],
                [20, 2],
                [20, 1],
                [20, 1],
                [25, 2],
                [11, 1],
                [11, 1],
                [11, 1],
                [6, 2],
                [6, 2],
                [6, 1],
                [6, 1],
                [12, 3],
                [12, 2],
                [12, 3],
                [12, 2],
                [27, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [28, 1],
                [36, 1],
                [37, 1],
                [29, 1],
                [29, 1],
                [29, 1],
                [30, 1],
                [30, 1],
                [30, 1],
                [45, 1],
                [33, 1],
                [34, 1],
                [35, 1],
                [35, 1],
                [44, 1],
                [44, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [46, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [47, 1],
                [48, 1],
                [38, 1],
                [39, 1],
                [40, 1],
                [41, 1],
                [42, 1],
                [49, 1],
                [43, 1],
                [102, 1],
              ],
              performAction: function (Ue, at, ft, be, J, pe, Ne) {
                var Te = pe.length - 1;
                switch (J) {
                  case 1:
                    return pe[Te - 1];
                  case 2:
                    return be.group();
                  case 3:
                  case 36:
                    this.$ = be.group(pe[Te - 2], pe[Te - 1], pe[Te]);
                    break;
                  case 4:
                  case 6:
                  case 32:
                  case 33:
                  case 37:
                    this.$ = be.group(pe[Te - 1], pe[Te]);
                    break;
                  case 5:
                  case 7:
                  case 34:
                  case 35:
                    this.$ = be.group(pe[Te]);
                    break;
                  case 10:
                  case 11:
                  case 12:
                    this.$ = be.basic_level(pe[Te - 1], be.group(pe[Te]));
                    break;
                  case 13:
                  case 17:
                    this.$ = be.radical(pe[Te - 1], be.group(pe[Te - 2]));
                    break;
                  case 14:
                  case 15:
                    this.$ = be.radical(be.group(), be.group(pe[Te - 1]));
                    break;
                  case 16:
                    this.$ = be.radical(be.group(), be.group());
                    break;
                  case 18:
                    this.$ = be.radical(pe[Te - 1]);
                    break;
                  case 19:
                    this.$ = be.radical(be.group());
                    break;
                  case 20:
                    this.$ = be.fraction(pe[Te - 3], pe[Te - 1]);
                    break;
                  case 21:
                    this.$ = be.fraction(pe[Te - 2], be.group());
                    break;
                  case 22:
                    this.$ = be.fraction(be.group(), pe[Te - 1]);
                    break;
                  case 23:
                  case 24:
                    this.$ = be.fraction(be.group(), be.group());
                    break;
                  case 25:
                    this.$ = be.fraction(
                      be.group(be.terminal(be.to_number(pe[Te - 1]))),
                      be.group(be.terminal(be.to_number(pe[Te]))),
                    );
                    break;
                  case 26:
                    this.$ = be.fraction(
                      be.group(be.terminal(be.to_number(pe[Te]))),
                      be.group(),
                    );
                    break;
                  case 27:
                    this.$ = be.fraction(
                      be.group(),
                      be.group(be.terminal(be.to_number(pe[$01]))),
                    );
                    break;
                  case 28:
                    this.$ = be.geo_token(pe[Te]);
                    break;
                  case 38:
                    this.$ = be.group(pe[Te - 1]);
                    break;
                  case 39:
                    this.$ = be.group();
                    break;
                  case 40:
                    this.$ = be.terminal(be.to_number(pe[Te]));
                    break;
                  case 60:
                    this.$ = be.terminal(",");
                    break;
                  case 61:
                    this.$ = be.terminal(".");
                    break;
                  case 62:
                    this.$ = be.terminal("[");
                    break;
                  case 63:
                    this.$ = be.terminal("\\{");
                    break;
                  case 64:
                    this.$ = be.terminal("(");
                    break;
                  case 65:
                    this.$ = be.terminal("]");
                    break;
                  case 66:
                    this.$ = be.terminal("\\}");
                    break;
                  case 67:
                    this.$ = be.terminal(")");
                    break;
                  case 68:
                    this.$ = be.terminal(" ");
                    break;
                  case 69:
                    this.$ = be.command(
                      "\\" + pe[Te].trim().toLowerCase(),
                    );
                    break;
                  case 70:
                    this.$ = be.terminal(be.greek(pe[Te]));
                    break;
                  case 71:
                    this.$ = be.terminal(pe[Te].toUpperCase());
                    break;
                  case 72:
                    this.$ = be.terminal(pe[Te].toLowerCase());
                    break;
                  case 73:
                    this.$ = be.terminal("|");
                    break;
                  case 74:
                    this.$ = be.terminal("\\|");
                    break;
                  case 75:
                    this.$ = be.terminal("+");
                    break;
                  case 76:
                    this.$ = be.terminal("-");
                    break;
                  case 77:
                    this.$ = be.terminal("\\cdot ");
                    break;
                  case 78:
                    this.$ = be.terminal("\\times ");
                    break;
                  case 79:
                    this.$ = be.terminal("*");
                    break;
                  case 80:
                    this.$ = be.terminal("\\div ");
                    break;
                  case 81:
                    this.$ = be.terminal("/");
                    break;
                  case 82:
                    this.$ = be.terminal("\\%\\operatorname{of}");
                    break;
                  case 83:
                    this.$ = be.terminal("\\%");
                    break;
                  case 84:
                    this.$ = be.terminal("\\to ");
                    break;
                  case 85:
                    this.$ = be.terminal("\\angle ");
                    break;
                  case 86:
                    this.$ = be.terminal("\\measuredangle ");
                    break;
                  case 87:
                    this.$ = be.terminal("\\degree ");
                    break;
                  case 88:
                    this.$ = be.terminal("\\bigcirc ");
                    break;
                  case 89:
                    this.$ = be.terminal("\\parallelogram ");
                    break;
                  case 90:
                    this.$ = be.terminal("\\triangle ");
                    break;
                  case 91:
                    this.$ = be.terminal("=");
                    break;
                  case 92:
                    this.$ = be.terminal("\\neq ");
                    break;
                  case 93:
                    this.$ = be.terminal("<");
                    break;
                  case 94:
                    this.$ = be.terminal(">");
                    break;
                  case 95:
                    this.$ = be.terminal("\\leq ");
                    break;
                  case 96:
                    this.$ = be.terminal("\\approx ");
                    break;
                  case 97:
                    this.$ = be.terminal("\\geq ");
                    break;
                  case 98:
                    this.$ = be.terminal("\\sim ");
                    break;
                  case 99:
                    this.$ = be.terminal("\\nsim ");
                    break;
                  case 100:
                    this.$ = be.terminal("\\parallel ");
                    break;
                  case 101:
                    this.$ = be.terminal("\\perp ");
                    break;
                  case 102:
                    this.$ = be.terminal("\\cong ");
                    break;
                  case 103:
                    this.$ = be.terminal("\\ncong ");
                    break;
                  case 104:
                    this.$ = be.terminal("\\ldots ");
                    break;
                  case 105:
                    this.$ = be.terminal(":");
                    break;
                  case 106:
                    this.$ = be.terminal("\\infty ");
                    break;
                  case 107:
                    this.$ = be.terminal("\\int ");
                    break;
                  case 108:
                    this.$ = be.terminal("!");
                    break;
                  case 109:
                    this.$ = be.terminal("\\&");
                    break;
                  case 110:
                    this.$ = be.primes(pe[Te]);
                    break;
                  case 111:
                    this.$ = be.terminal("?");
                    break;
                }
              },
              table: [
                {
                  3: 1,
                  4: 2,
                  5: [1, 3],
                  6: 4,
                  7: 5,
                  8: 8,
                  9: 9,
                  10: i,
                  11: 6,
                  12: 7,
                  13: n,
                  15: a,
                  16: 11,
                  17: s,
                  20: 12,
                  21: l,
                  23: c,
                  24: d,
                  25: 20,
                  26: p,
                  27: 18,
                  28: 10,
                  29: 13,
                  31: h,
                  33: 19,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                },
                { 1: [3] },
                { 5: [1, 91] },
                { 1: [2, 2] },
                o(Mr, [2, 5], { 8: 8, 9: 9, 7: 92, 10: i, 13: n, 15: a }),
                o(Mr, [2, 7], {
                  6: 4,
                  7: 5,
                  11: 6,
                  12: 7,
                  8: 8,
                  9: 9,
                  28: 10,
                  16: 11,
                  20: 12,
                  29: 13,
                  27: 18,
                  33: 19,
                  25: 20,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  4: 93,
                  10: i,
                  13: n,
                  15: a,
                  17: s,
                  21: l,
                  23: c,
                  24: d,
                  26: p,
                  31: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                }),
                o(Q, [2, 34], {
                  11: 6,
                  12: 7,
                  28: 10,
                  16: 11,
                  20: 12,
                  29: 13,
                  27: 18,
                  33: 19,
                  25: 20,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  6: 94,
                  17: s,
                  21: l,
                  23: c,
                  24: d,
                  26: p,
                  31: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                }),
                o(Q, [2, 35], {
                  11: 6,
                  12: 7,
                  28: 10,
                  16: 11,
                  20: 12,
                  29: 13,
                  27: 18,
                  33: 19,
                  25: 20,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  6: 95,
                  17: s,
                  21: l,
                  23: c,
                  24: d,
                  26: p,
                  31: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                }),
                o(j, [2, 8]),
                o(j, [2, 9]),
                o(j, [2, 29]),
                o(j, [2, 30]),
                o(j, [2, 31]),
                {
                  4: 96,
                  6: 4,
                  7: 5,
                  8: 8,
                  9: 9,
                  10: i,
                  11: 6,
                  12: 7,
                  13: n,
                  15: a,
                  16: 11,
                  17: s,
                  20: 12,
                  21: l,
                  23: c,
                  24: d,
                  25: 20,
                  26: p,
                  27: 18,
                  28: 10,
                  29: 13,
                  30: 97,
                  31: h,
                  33: 19,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  55: Ge,
                  56: de,
                  57: Ye,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                },
                {
                  4: 101,
                  6: 4,
                  7: 5,
                  8: 8,
                  9: 9,
                  10: i,
                  11: 6,
                  12: 7,
                  13: n,
                  15: a,
                  16: 11,
                  17: s,
                  20: 12,
                  21: l,
                  23: c,
                  24: d,
                  25: 20,
                  26: p,
                  27: 18,
                  28: 10,
                  29: 13,
                  31: h,
                  32: [1, 102],
                  33: 19,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                },
                {
                  9: 105,
                  11: 103,
                  12: 104,
                  13: n,
                  15: a,
                  16: 11,
                  17: s,
                  20: 12,
                  21: l,
                  23: c,
                  24: d,
                  25: 20,
                  26: p,
                  27: 18,
                  28: 10,
                  29: 13,
                  31: h,
                  33: 19,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                },
                {
                  11: 106,
                  12: 107,
                  14: [1, 108],
                  16: 11,
                  17: s,
                  20: 12,
                  21: l,
                  23: c,
                  24: d,
                  25: 20,
                  26: p,
                  27: 18,
                  28: 10,
                  29: 13,
                  31: h,
                  33: 19,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                },
                {
                  4: 109,
                  6: 4,
                  7: 5,
                  8: 8,
                  9: 9,
                  10: i,
                  11: 6,
                  12: 7,
                  13: n,
                  14: [1, 110],
                  15: a,
                  16: 11,
                  17: s,
                  20: 12,
                  21: l,
                  23: c,
                  24: d,
                  25: 20,
                  26: p,
                  27: 18,
                  28: 10,
                  29: 13,
                  31: h,
                  33: 19,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                },
                o(j, [2, 41]),
                o(j, [2, 42]),
                o(j, [2, 43]),
                o(j, [2, 44]),
                o(j, [2, 45]),
                o(j, [2, 46]),
                o(j, [2, 47]),
                o(j, [2, 48]),
                o(j, [2, 49]),
                o(j, [2, 50]),
                o(j, [2, 51]),
                o(j, [2, 52]),
                o(j, [2, 53]),
                o(j, [2, 54]),
                o(j, [2, 55]),
                o(j, [2, 56]),
                o(j, [2, 57]),
                o(j, [2, 58]),
                o(j, [2, 59]),
                {
                  4: 111,
                  6: 4,
                  7: 5,
                  8: 8,
                  9: 9,
                  10: i,
                  11: 6,
                  12: 7,
                  13: n,
                  15: a,
                  16: 11,
                  17: s,
                  18: [1, 112],
                  19: [1, 113],
                  20: 12,
                  21: l,
                  23: c,
                  24: d,
                  25: 20,
                  26: p,
                  27: 18,
                  28: 10,
                  29: 13,
                  31: h,
                  33: 19,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                },
                o(j, Ve, { 22: [1, 114] }),
                o(j, [2, 26]),
                o(j, [2, 27]),
                o(Qr, [2, 62]),
                o(Qr, [2, 63]),
                o(Qr, [2, 64]),
                o(j, [2, 69]),
                { 21: [1, 116], 27: 115 },
                o(j, [2, 70]),
                o(j, [2, 71]),
                o(j, [2, 72]),
                o(j, [2, 60]),
                o(j, [2, 61]),
                o(j, [2, 105]),
                o(j, [2, 106]),
                o(j, [2, 107]),
                o(j, [2, 108]),
                o(j, [2, 109]),
                o(j, [2, 111]),
                o(j, [2, 73]),
                o(j, [2, 74]),
                o(j, [2, 68]),
                o(j, [2, 75]),
                o(j, [2, 76]),
                o(j, [2, 77]),
                o(j, [2, 78]),
                o(j, [2, 79]),
                o(j, [2, 80]),
                o(j, [2, 81]),
                o(j, [2, 82]),
                o(j, [2, 83]),
                o(j, [2, 84]),
                o(j, [2, 85]),
                o(j, [2, 86]),
                o(j, [2, 87]),
                o(j, [2, 88]),
                o(j, [2, 89]),
                o(j, [2, 90]),
                o(j, [2, 91]),
                o(j, [2, 92]),
                o(j, [2, 93]),
                o(j, [2, 94]),
                o(j, [2, 95]),
                o(j, [2, 96]),
                o(j, [2, 97]),
                o(j, [2, 98]),
                o(j, [2, 99]),
                o(j, [2, 100]),
                o(j, [2, 101]),
                o(j, [2, 102]),
                o(j, [2, 103]),
                o(j, [2, 104]),
                o(j, [2, 110]),
                { 1: [2, 1] },
                o(Mr, [2, 4], {
                  6: 4,
                  7: 5,
                  11: 6,
                  12: 7,
                  8: 8,
                  9: 9,
                  28: 10,
                  16: 11,
                  20: 12,
                  29: 13,
                  27: 18,
                  33: 19,
                  25: 20,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  4: 117,
                  10: i,
                  13: n,
                  15: a,
                  17: s,
                  21: l,
                  23: c,
                  24: d,
                  26: p,
                  31: h,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                }),
                o(Mr, [2, 6]),
                o(Q, [2, 32]),
                o(Q, [2, 33]),
                { 30: 118, 55: Ge, 56: de, 57: Ye },
                o(j, [2, 37]),
                o(j, [2, 65]),
                o(j, [2, 66]),
                o(j, [2, 67]),
                { 32: [1, 119] },
                o(j, [2, 39]),
                o(j, [2, 10]),
                o(j, [2, 11]),
                o(j, [2, 12]),
                {
                  4: 120,
                  6: 4,
                  7: 5,
                  8: 8,
                  9: 9,
                  10: i,
                  11: 6,
                  12: 7,
                  13: n,
                  14: [1, 121],
                  15: a,
                  16: 11,
                  17: s,
                  20: 12,
                  21: l,
                  23: c,
                  24: d,
                  25: 20,
                  26: p,
                  27: 18,
                  28: 10,
                  29: 13,
                  31: h,
                  33: 19,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                },
                {
                  4: 123,
                  6: 4,
                  7: 5,
                  8: 8,
                  9: 9,
                  10: i,
                  11: 6,
                  12: 7,
                  13: n,
                  14: [1, 122],
                  15: a,
                  16: 11,
                  17: s,
                  20: 12,
                  21: l,
                  23: c,
                  24: d,
                  25: 20,
                  26: p,
                  27: 18,
                  28: 10,
                  29: 13,
                  31: h,
                  33: 19,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                },
                o(j, [2, 16]),
                { 14: [1, 124] },
                o(j, [2, 19]),
                { 18: [1, 125] },
                {
                  4: 126,
                  6: 4,
                  7: 5,
                  8: 8,
                  9: 9,
                  10: i,
                  11: 6,
                  12: 7,
                  13: n,
                  15: a,
                  16: 11,
                  17: s,
                  19: [1, 127],
                  20: 12,
                  21: l,
                  23: c,
                  24: d,
                  25: 20,
                  26: p,
                  27: 18,
                  28: 10,
                  29: 13,
                  31: h,
                  33: 19,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                },
                o(j, [2, 24]),
                o(j, [2, 25]),
                o(j, [2, 28]),
                o(j, Ve),
                o(Mr, [2, 3]),
                o(j, [2, 36]),
                o(j, [2, 38]),
                { 14: [1, 128] },
                o(j, [2, 15]),
                o(j, [2, 14]),
                { 14: [1, 129] },
                o(j, [2, 18]),
                {
                  4: 130,
                  6: 4,
                  7: 5,
                  8: 8,
                  9: 9,
                  10: i,
                  11: 6,
                  12: 7,
                  13: n,
                  15: a,
                  16: 11,
                  17: s,
                  19: [1, 131],
                  20: 12,
                  21: l,
                  23: c,
                  24: d,
                  25: 20,
                  26: p,
                  27: 18,
                  28: 10,
                  29: 13,
                  31: h,
                  33: 19,
                  34: 21,
                  35: 22,
                  36: 23,
                  37: 24,
                  38: 25,
                  39: 26,
                  40: 27,
                  41: 28,
                  42: 29,
                  43: 30,
                  44: 31,
                  45: 32,
                  46: 33,
                  47: 34,
                  48: 35,
                  49: 36,
                  50: u,
                  51: f,
                  52: y,
                  53: C,
                  54: E,
                  58: v,
                  59: w,
                  60: S,
                  61: k,
                  62: _,
                  63: A,
                  64: P,
                  65: O,
                  66: U,
                  67: z,
                  68: x,
                  69: L,
                  70: V,
                  71: R,
                  72: N,
                  73: M,
                  74: F,
                  75: Z,
                  76: te,
                  77: Y,
                  78: he,
                  79: se,
                  80: ae,
                  81: q,
                  82: oe,
                  83: K,
                  84: fe,
                  85: me,
                  86: we,
                  87: Ce,
                  88: _e,
                  89: We,
                  90: $,
                  91: W,
                  92: ue,
                  93: Ee,
                  94: Be,
                  95: ce,
                  96: ot,
                  97: it,
                  98: Se,
                  99: Lt,
                  100: It,
                  101: Dt,
                },
                { 19: [1, 132] },
                o(j, [2, 23]),
                o(j, [2, 13]),
                o(j, [2, 17]),
                { 19: [1, 133] },
                o(j, [2, 21]),
                o(j, [2, 22]),
                o(j, [2, 20]),
              ],
              defaultActions: { 3: [2, 2], 91: [2, 1] },
              parseError: function (Ue, at) {
                if (at.recoverable) this.trace(Ue);
                else {
                  var ft = new Error(Ue);
                  throw ft.hash = at, ft;
                }
              },
              parse: function (Ue) {
                var at = this,
                  ft = [0],
                  be = [],
                  J = [null],
                  pe = [],
                  Ne = this.table,
                  Te = "",
                  dt = 0,
                  ut = 0,
                  kt = 0,
                  Qt = 2,
                  Gt = 1,
                  Vt = pe.slice.call(arguments, 1),
                  Ct = Object.create(this.lexer),
                  xr = { yy: {} };
                for (var Zt in this.yy) {
                  Object.prototype.hasOwnProperty.call(this.yy, Zt) &&
                    (xr.yy[Zt] = this.yy[Zt]);
                }
                Ct.setInput(Ue, xr.yy),
                  xr.yy.lexer = Ct,
                  xr.yy.parser = this,
                  typeof Ct.yylloc == "undefined" && (Ct.yylloc = {});
                var Xo = Ct.yylloc;
                pe.push(Xo);
                var Zi = Ct.options && Ct.options.ranges;
                typeof xr.yy.parseError == "function"
                  ? this.parseError = xr.yy.parseError
                  : this.parseError = Object.getPrototypeOf(this).parseError;
                function na($s) {
                  ft.length = ft.length - 2 * $s,
                    J.length = J.length - $s,
                    pe.length = pe.length - $s;
                }
                for (
                  var xn = function () {
                      var $s;
                      return $s = Ct.lex() || Gt,
                        typeof $s != "number" &&
                        ($s = at.symbols_[$s] || $s),
                        $s;
                    },
                    Ho,
                    en,
                    Ws,
                    po,
                    Cl,
                    Un,
                    Jd = {},
                    qc,
                    Na,
                    Ex,
                    Bh;;
                ) {
                  if (
                    Ws = ft[ft.length - 1],
                      this.defaultActions[Ws]
                        ? po = this.defaultActions[Ws]
                        : ((Ho === null || typeof Ho == "undefined") &&
                          (Ho = xn()),
                          po = Ne[Ws] && Ne[Ws][Ho]),
                      typeof po == "undefined" || !po.length || !po[0]
                  ) {
                    var Qd = "";
                    Bh = [];
                    for (qc in Ne[Ws]) {
                      this.terminals_[qc] && qc > Qt &&
                        Bh.push("'" + this.terminals_[qc] + "'");
                    }
                    Ct.showPosition
                      ? Qd = "Parse error on line " + (dt + 1) + `:
` + Ct.showPosition() + `
Expecting ` + Bh.join(", ") + ", got '" + (this.terminals_[Ho] || Ho) + "'"
                      : Qd = "Parse error on line " + (dt + 1) +
                        ": Unexpected " + (Ho == Gt
                          ? "end of input"
                          : "'" + (this.terminals_[Ho] || Ho) + "'"),
                      this.parseError(Qd, {
                        text: Ct.match,
                        token: this.terminals_[Ho] || Ho,
                        line: Ct.yylineno,
                        loc: Xo,
                        expected: Bh,
                      });
                  }
                  if (po[0] instanceof Array && po.length > 1) {
                    throw new Error(
                      "Parse Error: multiple actions possible at state: " +
                        Ws + ", token: " + Ho,
                    );
                  }
                  switch (po[0]) {
                    case 1:
                      ft.push(Ho),
                        J.push(Ct.yytext),
                        pe.push(Ct.yylloc),
                        ft.push(po[1]),
                        Ho = null,
                        en
                          ? (Ho = en, en = null)
                          : (ut = Ct.yyleng,
                            Te = Ct.yytext,
                            dt = Ct.yylineno,
                            Xo = Ct.yylloc,
                            kt > 0 && kt--);
                      break;
                    case 2:
                      if (
                        Na = this.productions_[po[1]][1],
                          Jd.$ = J[J.length - Na],
                          Jd._$ = {
                            first_line: pe[pe.length - (Na || 1)].first_line,
                            last_line: pe[pe.length - 1].last_line,
                            first_column:
                              pe[pe.length - (Na || 1)].first_column,
                            last_column: pe[pe.length - 1].last_column,
                          },
                          Zi &&
                          (Jd._$.range = [
                            pe[pe.length - (Na || 1)].range[0],
                            pe[pe.length - 1].range[1],
                          ]),
                          Un = this.performAction.apply(
                            Jd,
                            [Te, ut, dt, xr.yy, po[1], J, pe].concat(Vt),
                          ),
                          typeof Un != "undefined"
                      ) return Un;
                      Na &&
                      (ft = ft.slice(0, -1 * Na * 2),
                        J = J.slice(0, -1 * Na),
                        pe = pe.slice(0, -1 * Na)),
                        ft.push(this.productions_[po[1]][0]),
                        J.push(Jd.$),
                        pe.push(Jd._$),
                        Ex = Ne[ft[ft.length - 2]][ft[ft.length - 1]],
                        ft.push(Ex);
                      break;
                    case 3:
                      return true;
                  }
                }
                return true;
              },
            },
            Bn = function () {
              var Vo = {
                EOF: 1,
                parseError: function (at, ft) {
                  if (this.yy.parser) this.yy.parser.parseError(at, ft);
                  else throw new Error(at);
                },
                setInput: function (Ue, at) {
                  return this.yy = at || this.yy || {},
                    this._input = Ue,
                    this._more = this._backtrack = this.done = false,
                    this.yylineno = this.yyleng = 0,
                    this.yytext = this.matched = this.match = "",
                    this.conditionStack = ["INITIAL"],
                    this.yylloc = {
                      first_line: 1,
                      first_column: 0,
                      last_line: 1,
                      last_column: 0,
                    },
                    this.options.ranges && (this.yylloc.range = [0, 0]),
                    this.offset = 0,
                    this;
                },
                input: function () {
                  var Ue = this._input[0];
                  this.yytext += Ue,
                    this.yyleng++,
                    this.offset++,
                    this.match += Ue,
                    this.matched += Ue;
                  var at = Ue.match(/(?:\r\n?|\n).*/g);
                  return at
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                    this.options.ranges && this.yylloc.range[1]++,
                    this._input = this._input.slice(1),
                    Ue;
                },
                unput: function (Ue) {
                  var at = Ue.length, ft = Ue.split(/(?:\r\n?|\n)/g);
                  this._input = Ue + this._input,
                    this.yytext = this.yytext.substr(
                      0,
                      this.yytext.length - at,
                    ),
                    this.offset -= at;
                  var be = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(
                    0,
                    this.match.length - 1,
                  ),
                    this.matched = this.matched.substr(
                      0,
                      this.matched.length - 1,
                    ),
                    ft.length - 1 && (this.yylineno -= ft.length - 1);
                  var J = this.yylloc.range;
                  return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: ft
                      ? (ft.length === be.length
                        ? this.yylloc.first_column
                        : 0) +
                        be[be.length - ft.length].length - ft[0].length
                      : this.yylloc.first_column - at,
                  },
                    this.options.ranges &&
                    (this.yylloc.range = [J[0], J[0] + this.yyleng - at]),
                    this.yyleng = this.yytext.length,
                    this;
                },
                more: function () {
                  return this._more = true, this;
                },
                reject: function () {
                  if (this.options.backtrack_lexer) this._backtrack = true;
                  else {return this.parseError(
                      "Lexical error on line " + (this.yylineno + 1) +
                        `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(),
                      { text: "", token: null, line: this.yylineno },
                    );}
                  return this;
                },
                less: function (Ue) {
                  this.unput(this.match.slice(Ue));
                },
                pastInput: function () {
                  var Ue = this.matched.substr(
                    0,
                    this.matched.length - this.match.length,
                  );
                  return (Ue.length > 20 ? "..." : "") +
                    Ue.substr(-20).replace(/\n/g, "");
                },
                upcomingInput: function () {
                  var Ue = this.match;
                  return Ue.length < 20 &&
                    (Ue += this._input.substr(0, 20 - Ue.length)),
                    (Ue.substr(0, 20) + (Ue.length > 20 ? "..." : ""))
                      .replace(/\n/g, "");
                },
                showPosition: function () {
                  var Ue = this.pastInput(),
                    at = new Array(Ue.length + 1).join("-");
                  return Ue + this.upcomingInput() + `
` + at + "^";
                },
                test_match: function (Ue, at) {
                  var ft, be, J;
                  if (
                    this.options.backtrack_lexer && (J = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    },
                      this.options.ranges &&
                      (J.yylloc.range = this.yylloc.range.slice(0))),
                      be = Ue[0].match(/(?:\r\n?|\n).*/g),
                      be && (this.yylineno += be.length),
                      this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: be
                          ? be[be.length - 1].length -
                            be[be.length - 1].match(/\r?\n?/)[0].length
                          : this.yylloc.last_column + Ue[0].length,
                      },
                      this.yytext += Ue[0],
                      this.match += Ue[0],
                      this.matches = Ue,
                      this.yyleng = this.yytext.length,
                      this.options.ranges &&
                      (this.yylloc.range = [
                        this.offset,
                        this.offset += this.yyleng,
                      ]),
                      this._more = false,
                      this._backtrack = false,
                      this._input = this._input.slice(Ue[0].length),
                      this.matched += Ue[0],
                      ft = this.performAction.call(
                        this,
                        this.yy,
                        this,
                        at,
                        this
                          .conditionStack[this.conditionStack.length - 1],
                      ),
                      this.done && this._input && (this.done = false),
                      ft
                  ) return ft;
                  if (this._backtrack) {
                    for (var pe in J) this[pe] = J[pe];
                    return false;
                  }
                  return false;
                },
                next: function () {
                  if (this.done) return this.EOF;
                  this._input || (this.done = true);
                  var Ue, at, ft, be;
                  this._more || (this.yytext = "", this.match = "");
                  for (
                    var J = this._currentRules(), pe = 0;
                    pe < J.length;
                    pe++
                  ) {
                    if (
                      ft = this._input.match(this.rules[J[pe]]),
                        ft && (!at || ft[0].length > at[0].length)
                    ) {
                      if (
                        at = ft, be = pe, this.options.backtrack_lexer
                      ) {
                        if (
                          Ue = this.test_match(ft, J[pe]), Ue !== false
                        ) return Ue;
                        if (this._backtrack) {
                          at = false;
                          continue;
                        } else return false;
                      } else if (!this.options.flex) break;
                    }
                  }
                  return at
                    ? (Ue = this.test_match(at, J[be]),
                      Ue !== false ? Ue : false)
                    : this._input === ""
                    ? this.EOF
                    : this.parseError(
                      "Lexical error on line " + (this.yylineno + 1) +
                        `. Unrecognized text.
` + this.showPosition(),
                      { text: "", token: null, line: this.yylineno },
                    );
                },
                lex: function () {
                  var at = this.next();
                  return at || this.lex();
                },
                begin: function (at) {
                  this.conditionStack.push(at);
                },
                popState: function () {
                  var at = this.conditionStack.length - 1;
                  return at > 0
                    ? this.conditionStack.pop()
                    : this.conditionStack[0];
                },
                _currentRules: function () {
                  return this.conditionStack.length &&
                      this.conditionStack[this.conditionStack.length - 1]
                    ? this
                      .conditions[
                        this
                          .conditionStack[this.conditionStack.length - 1]
                      ].rules
                    : this.conditions.INITIAL.rules;
                },
                topState: function (at) {
                  return at = this.conditionStack.length - 1 -
                    Math.abs(at || 0),
                    at >= 0 ? this.conditionStack[at] : "INITIAL";
                },
                pushState: function (at) {
                  this.begin(at);
                },
                stateStackSize: function () {
                  return this.conditionStack.length;
                },
                options: {},
                performAction: function (at, ft, be, J) {
                  var pe = J;
                  switch (be) {
                    case 0:
                      this.begin("captext");
                      return;
                    case 1:
                      return 61;
                    case 2:
                      return this.popState(), 61;
                      break;
                    case 3:
                      return 65;
                    case 4:
                      return 66;
                    case 5:
                      return 67;
                    case 6:
                      return 68;
                    case 7:
                      return 69;
                    case 8:
                      return 70;
                    case 9:
                      return 52;
                    case 10:
                      return 53;
                    case 11:
                      return 54;
                    case 12:
                      return 55;
                    case 13:
                      return 56;
                    case 14:
                      return 57;
                    case 15:
                      return 82;
                    case 16:
                      return 85;
                    case 17:
                      return 86;
                    case 18:
                      return 87;
                    case 19:
                      return 81;
                    case 20:
                      return 83;
                    case 21:
                      return 84;
                    case 22:
                      return 89;
                    case 23:
                      return 88;
                    case 24:
                      return 72;
                    case 25:
                      return 73;
                    case 26:
                      return 74;
                    case 27:
                      return 76;
                    case 28:
                      return 75;
                    case 29:
                      return 78;
                    case 30:
                      return 79;
                    case 31:
                      return 80;
                    case 32:
                      return 93;
                    case 33:
                      return 92;
                    case 34:
                      return 94;
                    case 35:
                      return 13;
                    case 36:
                      return 15;
                    case 37:
                      return 14;
                    case 38:
                      return 10;
                    case 39:
                      return 31;
                    case 40:
                      return 32;
                    case 41:
                      return 97;
                    case 42:
                      return 98;
                    case 43:
                      return 99;
                    case 44:
                      return 17;
                    case 45:
                      return 18;
                    case 46:
                      return 19;
                    case 47:
                      return 90;
                    case 48:
                      return 91;
                    case 49:
                      return 96;
                    case 50:
                      return ft.yytext = this.matches[1], 21;
                      break;
                    case 51:
                      return ft.yytext = this.matches[1], 22;
                      break;
                    case 52:
                      return ft.yytext = this.matches[1], 24;
                      break;
                    case 53:
                      return 71;
                    case 54:
                      return 50;
                    case 55:
                      return 51;
                    case 56:
                      return 100;
                    case 57:
                      return 64;
                    case 58:
                      return 63;
                    case 59:
                      return 95;
                    case 60:
                      return 59;
                    case 61:
                      return 59;
                    case 62:
                      return 26;
                    case 63:
                      return 60;
                    case 64:
                      return 77;
                    case 65:
                      return ft.yytext = this.matches[1], 61;
                      break;
                    case 66:
                      return 62;
                    case 67:
                      return;
                    case 68:
                      return 101;
                    case 69:
                      return;
                    case 70:
                      return 58;
                    case 71:
                      return 5;
                    case 72:
                      return 103;
                  }
                },
                rules: [
                  /^(?:([,][,])(?=[A-Z]))/,
                  /^(?:[A-Z](?=[A-Z]))/,
                  /^(?:[A-Z])/,
                  /^(?:["][6])/,
                  /^(?:["][-])/,
                  /^(?:["][4])/,
                  /^(?:["][8])/,
                  /^(?:["][9])/,
                  /^(?:["][/])/,
                  /^(?:[.][<])/,
                  /^(?:[_][<])/,
                  /^(?:["][<])/,
                  /^(?:[.][>])/,
                  /^(?:[_][>])/,
                  /^(?:["][>])/,
                  /^(?:["][7][@][:])/,
                  /^(?:[_][@][<])/,
                  /^(?:[\^][9])/,
                  /^(?:[_][@][>])/,
                  /^(?:["][7])/,
                  /^(?:[@][<])/,
                  /^(?:[@][>])/,
                  /^(?:[@][9][@][:])/,
                  /^(?:[@][9])/,
                  /^(?:[.][0][O][F][ ]?)/,
                  /^(?:[.][0])/,
                  /^(?:[:][O])/,
                  /^(?:[.][_][\[])/,
                  /^(?:[_][\[])/,
                  /^(?:[$][=])/,
                  /^(?:[$][@][#][D])/,
                  /^(?:[$][#][C])/,
                  /^(?:["][_][9][@][:])/,
                  /^(?:["][_][9])/,
                  /^(?:[4][4][4])/,
                  /^(?:[%][9])/,
                  /^(?:[%])/,
                  /^(?:[\+])/,
                  /^(?:[95]+(?=.))/,
                  /^(?:[<])/,
                  /^(?:[>])/,
                  /^(?:!)/,
                  /^(?:[6])/,
                  /^(?:[@]&)/,
                  /^(?:[(])/,
                  /^(?:[.][/])/,
                  /^(?:[)])/,
                  /^(?:#[L])/,
                  /^(?:#-)/,
                  /^(?:#=)/,
                  /^(?:#([A-J4]+))/,
                  /^(?:[/]([A-J4]+))/,
                  /^(?:[#][/]([A-J4]+))/,
                  /^(?:[_]?[/])/,
                  /^(?:[1])/,
                  /^(?:[4])/,
                  /^(?:[7]+)/,
                  /^(?:[_][\\][_][\\])/,
                  /^(?:[_][\\])/,
                  /^(?:[3])/,
                  /^(?:(ARC)?(SIN|COS|TAN|CSC|SEC|COT)(H)?)/,
                  /^(?:(ARG|DET|EXP|IM|INF|LIM|LN|LOG|MAX|MIN|MOD|RE|SUP))/,
                  /^(?:(TOKEN)[ ]?)/,
                  /^(?:[,]?[.][ABGDEZ\?\:IKLMNXOPRSTUYF\&W])/,
                  /^(?:[^][J])/,
                  /^(?:[,]([A-Z]))/,
                  /^(?:[A-Z])/,
                  /^(?:[,]['])/,
                  /^(?:[8])/,
                  /^(?:[;])/,
                  /^(?:[ ])/,
                  /^(?:$)/,
                  /^(?:.)/,
                ],
                conditions: {
                  captext: {
                    rules: [
                      0,
                      1,
                      2,
                      3,
                      4,
                      5,
                      6,
                      7,
                      8,
                      9,
                      10,
                      11,
                      12,
                      13,
                      14,
                      15,
                      16,
                      17,
                      18,
                      19,
                      20,
                      21,
                      22,
                      23,
                      24,
                      25,
                      26,
                      27,
                      28,
                      29,
                      30,
                      31,
                      32,
                      33,
                      34,
                      35,
                      36,
                      37,
                      38,
                      39,
                      40,
                      41,
                      42,
                      43,
                      44,
                      45,
                      46,
                      47,
                      48,
                      49,
                      50,
                      51,
                      52,
                      53,
                      54,
                      55,
                      56,
                      57,
                      58,
                      59,
                      60,
                      61,
                      62,
                      63,
                      64,
                      65,
                      66,
                      67,
                      68,
                      69,
                      70,
                      71,
                      72,
                    ],
                    inclusive: true,
                  },
                  INITIAL: {
                    rules: [
                      0,
                      3,
                      4,
                      5,
                      6,
                      7,
                      8,
                      9,
                      10,
                      11,
                      12,
                      13,
                      14,
                      15,
                      16,
                      17,
                      18,
                      19,
                      20,
                      21,
                      22,
                      23,
                      24,
                      25,
                      26,
                      27,
                      28,
                      29,
                      30,
                      31,
                      32,
                      33,
                      34,
                      35,
                      36,
                      37,
                      38,
                      39,
                      40,
                      41,
                      42,
                      43,
                      44,
                      45,
                      46,
                      47,
                      48,
                      49,
                      50,
                      51,
                      52,
                      53,
                      54,
                      55,
                      56,
                      57,
                      58,
                      59,
                      60,
                      61,
                      62,
                      63,
                      64,
                      65,
                      66,
                      67,
                      68,
                      69,
                      70,
                      71,
                      72,
                    ],
                    inclusive: true,
                  },
                },
              };
              return Vo;
            }();
          st.lexer = Bn;
          function co() {
            this.yy = {};
          }
          return co.prototype = st, st.Parser = co, new co();
        }();
        typeof Qm != "undefined" && typeof r != "undefined" &&
          (r.parser = t,
            r.Parser = t.Parser,
            r.parse = function () {
              return t.parse.apply(t, arguments);
            },
            r.main = function () {},
            typeof e != "undefined" && Qm.main === e &&
            r.main(process.argv.slice(1)));
      },
    }),
    sM = [
      "abs",
      "ans",
      "arccosh",
      "arccot",
      "arccoth",
      "arccsc",
      "arccsch",
      "arcsec",
      "arcsech",
      "arcsinh",
      "arctanh",
      "binomialdist",
      "boxplot",
      "cdf",
      "ceil",
      "corr",
      "cov",
      "csch",
      "distance",
      "dotplot",
      "erf",
      "floor",
      "gcf",
      "histogram",
      "IndependentTTest",
      "iTTest",
      "ittest",
      "lcm",
      "length",
      "mad",
      "mcd",
      "mcm",
      "mean",
      "median",
      "midpoint",
      "mod",
      "nCr",
      "normaldist",
      "nPr",
      "pdf",
      "poissondist",
      "polygon",
      "quantile",
      "quartile",
      "random",
      "round",
      "sech",
      "sign",
      "signum",
      "sgn",
      "stdDev",
      "stddev",
      "stdDevP",
      "stddevp",
      "stdev",
      "stdevp",
      "tdist",
      "total",
      "TScore",
      "TScore",
      "Tscore",
      "tscore",
      "tscore",
      "TTest",
      "ttest",
      "var",
      "variance",
      "varp",
    ],
    RC = sM,
    jj = I3(sM),
    lM;
  function _3(r) {
    let e = false, t = 0, o = "", i = "";
    for (let n of r) {
      if (n.type === "terminal" && /[A-Za-z]/.test(n.value)) {
        o += n.value, t++;
      } else break;
    }
    return i = o.replace(lM, "\\operatorname{$1}"),
      e = t > 0 && i !== o,
      { modified: e, terminalCount: t, value: i };
  }
  function cM(r) {
    return RC.indexOf(r.toLowerCase()) !== -1;
  }
  function FC(r) {
    if (!Array.isArray(r)) {
      throw new Error("Operator names must be an array, got " + typeof r);
    }
    for (let e of r) {
      if (typeof e != "string") {
        throw new Error(
          "Operator names must be strings, found " + typeof e,
        );
      }
    }
    RC = r, Yj();
  }
  function NC() {
    RC = sM, lM = jj;
  }
  function Yj() {
    lM = I3(RC);
  }
  function I3(r) {
    let e = r.sort((t, o) => o.length - t.length || o.localeCompare(t))
      .join("|");
    return new RegExp("(" + e + ")", "g");
  }
  var A3 = {};
  aM(A3, {
    command: () => dM,
    fraction: () => Qj,
    greek: () => Xj,
    group: () => pM,
    level: () => G3,
    processPrimes: () => Jj,
    radical: () => Zj,
    terminal: () => M3,
    typeform: () => L3,
  });
  function M3(r) {
    return { type: "terminal", value: r };
  }
  function dM(r) {
    return { type: "command", value: r };
  }
  function Xj(r) {
    return { type: "greek", value: r };
  }
  function G3(r) {
    return { subscript: r._, superscript: r["^"], type: "level" };
  }
  function Jj(r, e) {
    let t = [], o = r.match(/'+/);
    if (o !== null) {
      let i = o[0].length;
      for (let n = 0; n < i; n++) t.push(dM("\\prime"));
    }
    return pM(t, e);
  }
  function Qj(r, e) {
    return { type: "fraction", numerator: r, denominator: e };
  }
  function L3(r, e) {
    return { name: r, type: "typeform", value: e };
  }
  function Zj(r, e) {
    return { type: "radical", index: e, radicand: r };
  }
  function pM(...r) {
    return Array.prototype.concat.apply([], r);
  }
  var IC = {
      "~": "\\ ",
      "\\,": "\\ ",
      "\\:": "\\ ",
      "\\;": "\\ ",
      "\\!": "\\ ",
    },
    h3 = {
      "\\Vert": "\\|",
      "\\ge": "\\geq",
      "\\le": "\\leq",
      "\\vert": "|",
    },
    eY = { "\\space": true };
  function bu(r) {
    let e = [];
    for (let t = 0; t < r.length; t++) {
      let o = r[t];
      switch (o.type) {
        case "command":
          let i = o.value.slice(1).trim();
          h3.hasOwnProperty(o.value)
            ? e.push(dM(h3[o.value]))
            : cM(i)
            ? e.push(L3("operator_name", tY(i)))
            : eY[o.value] || e.push(o);
          break;
        case "level":
          let n = {
            subscript: o.subscript && o.subscript.length > 0
              ? bu(o.subscript)
              : void 0,
            superscript: o.superscript && o.superscript.length > 0
              ? bu(o.superscript)
              : void 0,
            type: o.type,
          };
          (n.subscript || n.superscript) && e.push(n);
          break;
        case "fraction":
          e.push({
            denominator: bu(o.denominator),
            numerator: bu(o.numerator),
            type: o.type,
          });
          break;
        case "radical":
          e.push({
            index: o.index ? bu(o.index) : void 0,
            radicand: bu(o.radicand),
            type: o.type,
          });
          break;
        case "terminal":
          rY(r.slice(t))
            ? (e.push({ type: "command", value: "\\ldots" }), t += 2)
            : e.push({
              type: o.type,
              value: IC.hasOwnProperty(o.value) ? IC[o.value] : o.value,
            });
          break;
        case "typeform":
          e.push(o);
          break;
        case "greek":
          e.push({
            type: o.type,
            value: IC.hasOwnProperty(o.value) ? IC[o.value] : o.value,
          });
          break;
        default:
          throw new Error(
            `Unexpected item:
` + JSON.stringify({ group: r, item: o }),
          );
      }
    }
    return e;
  }
  function tY(r) {
    let e = [];
    for (let t of r) e.push(M3(t));
    return e;
  }
  function rY(r) {
    let e = 0;
    for (let t = 0; t < Math.min(3, r.length); t++) {
      let o = r[t];
      o.type === "terminal" && o.value === "." && e++;
    }
    return e === 3;
  }
  function uM(r) {
    if (!r.hash) throw r;
    return {
      _diagnostic: {
        expected: r.hash.expected,
        message: r.message,
        text: r.hash.text,
        token: r.hash.token,
      },
      location: r.hash.loc,
    };
  }
  var P3 = $j();
  P3.parser.yy = A3;
  function V3(r) {
    try {
      return { isError: false, value: P3.parser.parse(r) };
    } catch (e) {
      return { isError: true, error: uM(e) };
    }
  }
  function oY(r) {
    return r.isError;
  }
  function iY(r, e) {
    return oY(r) ? r : { isError: false, value: e(r.value) };
  }
  function Zm(r, e) {
    let t = iY(r, e);
    return r.warnings && (t.warnings = r.warnings), t;
  }
  function nY(r) {
    return Zm(V3(r), (e) => fY(bu(e)));
  }
  var g3 = {
    "!": "&",
    "*": "@#",
    ",": ", ",
    "/": "_/",
    ":": "_3",
    "<": ' "K ',
    "=": " .K ",
    ">": " .1 ",
    "?": "_8",
    "[": "@(",
    "\\ ": " ",
    "\\%": "@0",
    "\\&": "_&",
    "\\,": " ",
    "\\infty": ",=",
    "\\int": "!",
    "\\{": ".(",
    "\\|": "\\\\",
    "\\}": ".)",
    "]": "@)",
    "|": "\\",
  };
  function XA(r) {
    return /^[a-z]$/.test(r.value)
      ? r.value.toUpperCase()
      : /^[A-Z]$/.test(r.value)
      ? "," + r.value
      : /^[0-9.]$/.test(r.value) || /^[+\-()]$/.test(r.value)
      ? r.value
      : g3.hasOwnProperty(r.value)
      ? g3[r.value]
      : "[terminal: " + r.value + "]";
  }
  var m3 = {
      "\\Vert": "\\\\",
      "\\angle": "$[ ",
      "\\approx": " @:@: ",
      "\\bigcirc": "$C ",
      "\\cong": " @:.K ",
      "\\cdot": "*",
      "\\degree": "~.*",
      "\\div": "./",
      "\\ge": " .1: ",
      "\\geq": " .1: ",
      "\\langle": "..(",
      "\\ldots": " ''' ",
      "\\le": ' "K: ',
      "\\leq": ' "K: ',
      "\\measuredangle": "M$[ ",
      "\\ncong": " /@:.K ",
      "\\ne": " /.K ",
      "\\neq": " /.K ",
      "\\nparallel": " /$L ",
      "\\nsim": "/@:",
      "\\parallel": " $L ",
      "\\parallelogram": "$G ",
      "\\perp": " $P ",
      "\\prime": "'",
      "\\prod": ".,P",
      "\\rangle": "..)",
      "\\sim": "@:",
      "\\sum": ".,S",
      "\\times": "@*",
      "\\to": " $O ",
      "\\triangle": "$T ",
      "\\vert": "\\",
    },
    f3 = {
      "\\Alpha": ".,A",
      "\\Beta": ".,B",
      "\\Chi": ".,&",
      "\\Delta": ".,D",
      "\\Epsilon": ".,E",
      "\\Eta": ".,:",
      "\\Gamma": ".,G",
      "\\Iota": ".,I",
      "\\Kappa": ".,K",
      "\\Lambda": ".,L",
      "\\Mu": ".,M",
      "\\Nu": ".,N",
      "\\Omega": ".,W",
      "\\Omicron": ".,O",
      "\\Phi": ".,F",
      "\\Pi": ".,P",
      "\\Psi": ".,Y",
      "\\Rho": ".,R",
      "\\Sigma": ".,S",
      "\\Tau": ".,T",
      "\\Theta": ".,?",
      "\\Upsilon": ".,U",
      "\\Xi": ".,X",
      "\\Zeta": ".,Z",
      "\\alpha": ".A",
      "\\beta": ".B",
      "\\chi": ".&",
      "\\delta": ".D",
      "\\epsilon": ".E",
      "\\eta": ".:",
      "\\gamma": ".G",
      "\\iota": ".I",
      "\\kappa": ".K",
      "\\lambda": ".L",
      "\\mu": ".M",
      "\\nu": ".N",
      "\\omega": ".W",
      "\\omicron": ".O",
      "\\phi": ".F",
      "\\pi": ".P",
      "\\psi": ".Y",
      "\\rho": ".R",
      "\\sigma": ".S",
      "\\tau": ".T",
      "\\theta": ".?",
      "\\upsilon": ".U",
      "\\xi": ".X",
      "\\zeta": ".Z",
    };
  function b3(r) {
    return m3.hasOwnProperty(r.value)
      ? m3[r.value]
      : r.value.slice(1).toUpperCase() + " ";
  }
  function aY(r) {
    return f3.hasOwnProperty(r.value)
      ? f3[r.value]
      : r.value.slice(1).toUpperCase() + " ";
  }
  function sY(r) {
    return r.value === "\\space";
  }
  function lY(r, e) {
    return r.isStartOfLine && /^-?$/.test(e) || /\s-?$/.test(e) ||
      r.wasFraction;
  }
  function cY(r) {
    return r.value === "\\sum" || r.value === "\\prod";
  }
  function dY(r, e) {
    if (e >= r.length) return false;
    let t = r[e];
    if (t.type === "terminal") {
      if (/^[0-9]$/.test(t.value)) return true;
      if (t.value !== "." || e + 1 >= r.length) return false;
      if (t = r[e + 1], t.type === "terminal") {
        return /^[0-9]$/.test(t.value);
      }
    }
    return false;
  }
  function xu(r, e) {
    let t = "", o = r.levelIndicator, i = 0, n = false;
    for (let a = 0; a < e.length; a++) {
      dY(e, a) &&
        (o === "" && /[A-Z]$/.test(t) ? t += Zc(o) : lY(r, t) && (t += "#"));
      let s = e[a], l = a < e.length - 1 ? e[a + 1] : null;
      switch (
        s.type !== "level" && o !== r.levelIndicator &&
        (JA(s)
          ? o = ""
          : (r.wasModifiedExpression && r.levelIndicator === ""
            ? r = Js(r, { wasModifiedExpression: false })
            : t += Zc(r.levelIndicator),
            o = r.levelIndicator)), s.type
      ) {
        case "terminal":
          !r.wasModifiedExpression && o !== "" && JA(s)
            ? t += " " + Zc(o) + XA(s).trim() + " "
            : t += XA(s),
            s.value === "." && l &&
            (l.type === "terminal" && /^[^_\d,]/.test(XA(l)) ||
              l.type === "greek") &&
            (t += '"'),
            r = Js(r, { wasFraction: false, wasRomanCommand: false });
          break;
        case "command":
          if (!sY(s)) {
            let u = cY(s);
            u && (t += '"'),
              !u && o !== "" && JA(s)
                ? t += " " + Zc(o) + b3(s).trim() + " "
                : t += b3(s),
              r = Js(r, {
                wasFraction: false,
                wasModifiedExpression: u,
                wasRomanCommand: true,
              });
          }
          break;
        case "greek":
          t += aY(s), r = Js(r, { wasFraction: false });
          break;
        case "fraction":
          let c = pY(r, s);
          t += c.value,
            i = Math.max(i, c.fractionLevel),
            r = Js(r, { wasFraction: true, wasRomanCommand: false });
          break;
        case "radical":
          let d = uY(r, s);
          t += d.value,
            i = Math.max(i, d.fractionLevel),
            r = Js(r, { wasFraction: false, wasRomanCommand: false });
          break;
        case "level":
          !r.wasModifiedExpression && r.wasRomanCommand
            ? (n = /\s$/.test(t), n && (t = t.replace(/\s$/, "")))
            : n = false;
          let p = t.length > 0 && /[A-Za-z]/.test(t[t.length - 1]) === true,
            h = hY(r, p, n, s);
          t += h.value,
            o = h.levelIndicator,
            r = Js(r, { wasFraction: false, wasRomanCommand: false });
          break;
        case "typeform":
          t += xu(r, s.value).value,
            s.name === "operator_name" && (t += " "),
            r = Js(r, {
              wasFraction: false,
              wasModifiedExpression: false,
              wasRomanCommand: false,
            });
          break;
      }
    }
    return { fractionLevel: i, levelIndicator: o, value: t };
  }
  function pY(r, e) {
    r = Js(r, { isStartOfLine: false });
    let t = xu(r, e.numerator),
      o = xu(r, e.denominator),
      i = Math.max(t.fractionLevel, o.fractionLevel),
      n = "";
    for (let s = 0; s < i; s++) n += ",";
    let a = n + "?" + t.value;
    return t.levelIndicator !== r.levelIndicator &&
      (a += Zc(r.levelIndicator)),
      /\.$/.test(t.value) && (a += '"'),
      a += n + "/" + o.value,
      o.levelIndicator !== r.levelIndicator &&
      (a += Zc(r.levelIndicator)),
      /\.$/.test(o.value) && (a += '"'),
      a += n + "#",
      { fractionLevel: i + 1, value: a };
  }
  function uY(r, e) {
    let t = r.radicalLevel, o = "", i = "";
    for (let a = 0; a < t; a++) i += ".";
    if (e.index) {
      o += i + "<";
      let a = xu(Js(r, { isStartOfLine: false }), e.index);
      o += a.value,
        /\.$/.test(a.value) && (o += '"'),
        a.levelIndicator !== r.levelIndicator &&
        (o += Zc(r.levelIndicator)),
        o += ">";
    } else o += i + ">";
    let n = xu(
      Js(r, { isStartOfLine: false, radicalLevel: t + 1 }),
      e.radicand,
    );
    return o += n.value,
      /\.$/.test(n.value) && (o += '"'),
      n.levelIndicator !== r.levelIndicator &&
      (o += Zc(r.levelIndicator)),
      o += i + "]",
      { fractionLevel: n.fractionLevel, value: o };
  }
  function hY(r, e, t, o) {
    let i = r.levelIndicator, n = "", a = gY(o.superscript);
    if (n += a, o.subscript) {
      r.wasModifiedExpression && (n += "%"), i = r.levelIndicator + ";";
      let s = xu(
        Js(r, { isStartOfLine: false, levelIndicator: i }),
        o.subscript,
      );
      e && /^[0-9]*(\.|\,)?[0-9]+$/.test(s.value) && i.length <= 1
        ? i = r.levelIndicator
        : !r.wasModifiedExpression && o.subscript[0] &&
          o.subscript[0].type !== "level" && (n += Zc(i)),
        n += s.value,
        /\.$/.test(s.value) && (n += '"');
    }
    if (o.superscript) {
      r.wasModifiedExpression && (n += "<"), i = r.levelIndicator + "^";
      let s = xu(
        Js(r, { isStartOfLine: false, levelIndicator: i }),
        o.superscript.slice(a.length),
      );
      !r.wasModifiedExpression && o.superscript[0] &&
      o.superscript[0].type !== "level" && s.value !== "" && (n += Zc(i)),
        n += s.value,
        /\.$/.test(s.value) && (n += '"');
    }
    return r.wasModifiedExpression ? n += "]" : r.wasRomanCommand && t &&
      (n += " ", i = i.slice(0, i.length - 1)),
      { levelIndicator: i, value: n };
  }
  function gY(r) {
    let e = "";
    if (r) {
      for (let t of r) {
        if (t.type === "command" && t.value === "\\prime") e += "'";
        else break;
      }
    }
    return e;
  }
  function Zc(r) {
    return r || '"';
  }
  function mY() {
    return {
      isStartOfLine: true,
      levelIndicator: "",
      radicalLevel: 0,
      wasFraction: false,
      wasModifiedExpression: false,
      wasRomanCommand: false,
    };
  }
  function Js(r, e) {
    return Jm(Jm({}, r), e);
  }
  function JA(r) {
    return r.type === "terminal" || r.type === "command"
      ? /^<|>|\=|\\leq?|\\geq?|\\neq?$/.test(r.value)
      : false;
  }
  function fY(r) {
    let e = mY();
    return xu(e, r).value;
  }
  function bY(r) {
    return Zm(V3(r), (e) => IY(bu(e)));
  }
  var y3 = {
    "!": "6",
    "(": '"<',
    ")": '">',
    "*": '"9',
    "+": '"6',
    ",": "1",
    "-": '"-',
    ".": "4",
    "/": "_/",
    ":": "3",
    "<": "@<",
    "=": '"7',
    ">": "@>",
    "?": "8",
    "[": ".<",
    "\\ ": " ",
    "\\%": ".0",
    "\\&": "@&",
    "\\,": " ",
    "\\infty": "#=",
    "\\int": "!",
    "\\{": "_<",
    "\\|": "_\\_\\",
    "\\}": "_>",
    "]": ".>",
    "|": "_\\",
  };
  function yY(r, e, t) {
    let o = "",
      i = e.value,
      n = t && t.type === "terminal" ? t.value : "";
    return O3(i, r) && (o += ";"),
      /^[\D]/.test(i) && (r = ed(r, { wasNumber: false })),
      /^[a-z]$/.test(i)
        ? r.capsLock
          ? (r = ed(r, { capsLock: false }), o += ",'" + i.toUpperCase())
          : o += i.toUpperCase()
        : /^[A-Z]$/.test(i)
        ? r.capsLock
          ? o += i
          : /[A-Z]/.test(n)
          ? (r = ed(r, { capsLock: true }), o += ",," + i)
          : o += "," + i
        : (r = ed(r, { capsLock: false }),
          /^[0-9.]$/.test(i)
            ? o += SY(i)
            : y3.hasOwnProperty(i)
            ? o += y3[i]
            : o += "[terminal: " + i + "]"),
      { value: o, ctx: r };
  }
  var x3 = {
      "\\Vert": "_\\_\\",
      "\\angle": "_{",
      "\\approx": "^9",
      "\\bigcirc": "$=",
      "\\cdot": '"4',
      "\\cong": '"_9',
      "\\degree": "~J",
      "\\div": '"/',
      "\\ge": "_@>",
      "\\geq": "_@>",
      "\\langle": "@<",
      "\\ldots": "444",
      "\\le": "_@<",
      "\\leq": "_@<",
      "\\measuredangle": "._{",
      "\\ncong": '"_9@:',
      "\\ne": '"7@:',
      "\\neq": '"7@:',
      "\\nsim": "@9@:",
      "\\parallel": "#L",
      "\\parallelogram": "$@#D",
      "\\perp": "#-",
      "\\prime": "7",
      "\\prod": ",.P",
      "\\rangle": "@>",
      "\\sim": "@9",
      "\\sum": ",.S",
      "\\times": '"8',
      "\\to": ":O",
      "\\triangle": "$#C",
      "\\vert": "_\\",
    },
    w3 = {
      "\\Alpha": ",.A",
      "\\Beta": ",.B",
      "\\Chi": ",.&",
      "\\Delta": ",.D",
      "\\Epsilon": ",.E",
      "\\Eta": ",.:",
      "\\Gamma": ",.G",
      "\\Iota": ",.I",
      "\\Kappa": ",.K",
      "\\Lambda": ",.L",
      "\\Mu": ",.M",
      "\\Nu": ",.N",
      "\\Omega": ",.W",
      "\\Omicron": ",.O",
      "\\Phi": ",.F",
      "\\Pi": ",.P",
      "\\Psi": ",.Y",
      "\\Rho": ",.R",
      "\\Sigma": ",.S",
      "\\Tau": ",.T",
      "\\Theta": ",.?",
      "\\Upsilon": ",.U",
      "\\Xi": ",.X",
      "\\Zeta": ",.Z",
      "\\alpha": ".A",
      "\\beta": ".B",
      "\\chi": ".&",
      "\\delta": ".D",
      "\\epsilon": ".E",
      "\\eta": ".:",
      "\\gamma": ".G",
      "\\iota": ".I",
      "\\kappa": ".K",
      "\\lambda": ".L",
      "\\mu": ".M",
      "\\nu": ".N",
      "\\omega": ".W",
      "\\omicron": ".O",
      "\\phi": ".F",
      "\\pi": ".P",
      "\\psi": ".Y",
      "\\rho": ".R",
      "\\sigma": ".S",
      "\\tau": ".T",
      "\\theta": ".?",
      "\\upsilon": ".U",
      "\\xi": ".X",
      "\\zeta": ".Z",
    };
  function xY(r, e) {
    let t;
    return x3.hasOwnProperty(r.value)
      ? t = x3[r.value]
      : t = r.value.slice(1).toUpperCase() + " ",
      O3(t, e) && (t = ";" + t),
      /^[\D]/.test(t) && (e = ed(e, { wasNumber: false })),
      { value: t, ctx: e };
  }
  function wY(r) {
    return w3.hasOwnProperty(r.value)
      ? w3[r.value]
      : r.value.slice(1).toUpperCase() + " ";
  }
  function vY(r) {
    return r.value === "\\space";
  }
  function CY(r, e) {
    if (e < r.length) {
      let t = r[e];
      if (t.type === "terminal") {
        if (/^\d$/.test(t.value)) return true;
        if (t.value !== "." || e + 1 >= r.length) return false;
        if (t = r[e + 1], t.type === "terminal") {
          return /^\d$/.test(t.value);
        }
      }
    }
    return false;
  }
  function SY(r) {
    let e = "";
    for (let o of r) {
      o === ","
        ? e += "1"
        : o === "."
        ? e += "4"
        : o === "0"
        ? e += "J"
        : e += String.fromCharCode(64 + Number(o));
    }
    return e;
  }
  function wu(r, e) {
    let t, o, i = "", n = true;
    for (let a = 0; a < e.length; a++) {
      CY(e, a)
        ? (r = ed(r, { wasNumber: true }), n && (i += "#", n = false))
        : n = true;
      let s = e[a];
      switch (s.type) {
        case "terminal":
          let l = a < e.length - 1 ? e[a + 1] : void 0;
          t = yY(r, s, l),
            r = t.ctx,
            i += t.value,
            i[i.length - 1] === " " && (n = true);
          break;
        case "command":
          vY(s) ||
            (o = xY(s, r),
              r = o.ctx,
              i += o.value,
              i[i.length - 1] === " " && (n = true));
          break;
        case "greek":
          i += wY(s), i[i.length - 1] === " " && (n = true);
          break;
        case "fraction":
          let c = EY(r, s);
          i += c.value, r = c.ctx, n = false;
          break;
        case "radical":
          let d = TY(r, s);
          i += d.value, n = true;
          break;
        case "level":
          let p = DY(r, s);
          i += p.value, r = p.ctx, n = true;
          break;
        case "typeform":
          let h = wu(r, s.value).value;
          i += h, /(ARC)?(SIN|COS|TAN|CSC|SEC|COT)(H)?/.test(h) && (i += " ");
          break;
      }
    }
    return { ctx: r, value: i };
  }
  function O3(r, e) {
    return e.wasNumber && /^[A-Ja-j]/.test(r);
  }
  function EY(r, e) {
    let t = wu(r, e.numerator), o = wu(r, e.denominator), i;
    return eM(t.value) && eM(o.value)
      ? (r = ed(r, { wasNumber: true }), i = t.value + "/" + o.value.slice(1))
      : (r = ed(r, { wasNumber: false }),
        i = "(" + t.value + "./" + o.value + ")"),
      { ctx: r, value: i };
  }
  function eM(r) {
    return /^\#[A-J41]+$/.test(r);
  }
  function TY(r, e) {
    let t = "%", o = wu(r, e.radicand);
    if (e.index) {
      let i = wu(r, pM(G3({ "^": e.index })));
      t += i.value,
        /\#[A-J]$/.test(i.value) && /^[A-J]/.test(o.value) && (t += ";");
    }
    return t += o.value + "+", { ctx: r, value: t };
  }
  function DY(r, e) {
    let t = "", o = kY(e.superscript);
    t += o;
    let i;
    if (e.subscript) {
      let n = wu(r, e.subscript);
      C3(e.subscript, n.value, 0) ? i = "<" + v3(n.value) + ">" : i = n.value,
        r = ed(r, { wasNumber: n.ctx.wasNumber }),
        i !== "" && (t += "5" + i);
    }
    if (e.superscript) {
      let n = wu(r, e.superscript.slice(o.length));
      C3(e.superscript, n.value, o.length)
        ? i = "<" + v3(n.value) + ">"
        : i = n.value,
        r = ed(r, { wasNumber: n.ctx.wasNumber }),
        (o === "" || i !== "") && (t += "9" + i);
    }
    return { ctx: r, value: t };
  }
  function v3(r) {
    return /^;/.test(r) ? r.slice(1) : r;
  }
  function kY(r) {
    let e = "";
    if (r) {
      for (let t of r) {
        if (t.type === "command" && t.value === "\\prime") e += "7";
        else break;
      }
    }
    return e;
  }
  function C3(r, e, t) {
    let o = r[0],
      i = (e.match(/\</g) || []).length,
      n = /^["|\.|_]?\</.test(e),
      a = (e.match(/\>/g) || []).length,
      s = /["|\.|_]?\>$/.test(e);
    return !eM(e) && r.length - t > 1 && i === 0 && a === 0 ||
      i > 0 && a > 0 && (!n || !s) || i > 1 || a > 1 ||
      o && o.type === "typeform";
  }
  function _Y() {
    return { capsLock: false, wasNumber: false };
  }
  function ed(r, e) {
    return Jm(Jm({}, r), e);
  }
  function IY(r) {
    let e = _Y();
    return wu(e, r).value;
  }
  var tM = {};
  aM(tM, {
    baseline: () => VY,
    command: () => MY,
    comparison: () => PY,
    expression: () => BY,
    fraction: () => RY,
    geo_token: () => GY,
    greek: () => zY,
    group: () => qY,
    level: () => hM,
    level_with_comparison: () => LY,
    modified_expression: () => FY,
    primes: () => OY,
    radical: () => NY,
    simple_subscript: () => UY,
    terminal: () => AY,
  });
  function AY(r) {
    return { type: "terminal", value: r };
  }
  function MY(r) {
    return { type: "command", value: "\\" + r.trim() + " " };
  }
  function GY(r) {
    return { type: "geo_token", index: r };
  }
  var R3 = {
    '"K': "<",
    '"K:': "\\leq ",
    $L: "\\parallel ",
    $O: "\\to ",
    $P: "\\perp ",
    ".1": ">",
    ".1:": "\\geq ",
    ".K": "=",
    "@:.K": "\\cong ",
    "/@:.K": "\\ncong ",
    "@:@:": "\\approx",
    "/$L": "\\nparallel ",
    "/.K": "\\neq ",
    "=": "=",
    "@:": "\\sim ",
    "/@:": "\\nsim ",
  };
  function LY(r) {
    let e = /[\^;]+/.exec(r),
      t = e ? e.toString() : "",
      o = r.slice(hM.length);
    return { type: "level_with_comparison", level: t, value: R3[o] };
  }
  function PY(r) {
    return { type: "comparison", value: R3[r] };
  }
  function hM(r) {
    return { type: "level", value: r };
  }
  function VY() {
    return hM("");
  }
  function OY(r) {
    return { type: "primes", value: r };
  }
  function RY(r, e) {
    return { type: "fraction", numerator: r, denominator: e };
  }
  function FY(r, e, t) {
    return {
      type: "modified_expression",
      expression: r,
      under: e,
      over: t,
    };
  }
  function NY(r, e) {
    return { type: "radical", value: r, index: e };
  }
  function BY(r) {
    return { type: "expression", value: r };
  }
  function UY(r, e) {
    return { type: "simple_subscript", base: r, subscript: e };
  }
  var S3 = {
    ".&": "\\chi",
    ".,&": "\\Chi",
    ".,:": "\\Eta",
    ".,?": "\\Theta",
    ".,A": "\\Alpha",
    ".,B": "\\Beta",
    ".,D": "\\Delta",
    ".,E": "\\Epsilon",
    ".,F": "\\Phi",
    ".,G": "\\Gamma",
    ".,I": "\\Iota",
    ".,K": "\\Kappa",
    ".,L": "\\Lambda",
    ".,M": "\\Mu",
    ".,N": "\\Nu",
    ".,O": "\\Omicron",
    ".,P": "\\prod",
    ".,R": "\\Rho",
    ".,S": "\\sum",
    ".,T": "\\Tau",
    ".,U": "\\Upsilon",
    ".,W": "\\Omega",
    ".,X": "\\Xi",
    ".,Y": "\\Psi",
    ".,Z": "\\Zeta",
    ".:": "\\eta",
    ".?": "\\theta",
    ".A": "\\alpha",
    ".B": "\\beta",
    ".D": "\\delta",
    ".E": "\\epsilon",
    ".F": "\\phi",
    ".G": "\\gamma",
    ".I": "\\iota",
    ".K": "\\kappa",
    ".L": "\\lambda",
    ".M": "\\mu",
    ".N": "\\nu",
    ".O": "\\omicron",
    ".P": "\\pi",
    ".R": "\\rho",
    ".S": "\\sigma",
    ".T": "\\tau",
    ".U": "\\upsilon",
    ".W": "\\omega",
    ".X": "\\xi",
    ".Y": "\\psi",
    ".Z": "\\zeta",
  };
  function zY(r) {
    if (S3.hasOwnProperty(r)) return S3[r] + " ";
    throw new Error("Unknown Greek letter");
  }
  function qY(...r) {
    return Array.prototype.concat.apply([], r);
  }
  var gM = D3(),
    PC = gM.parser.lexer,
    ag = Object.create(PC),
    HY = ag,
    Ox = gM.parser.terminals_,
    Pi = gM.parser.symbols_;
  ag.setInput = function (r, e) {
    this.delimiterStack = [],
      this.outputQueue = [],
      this.canAcceptPrimes = false,
      PC.setInput.call(this, r, e);
  };
  ag.lex = function () {
    let r = -1;
    if (!this) return r;
    if (this.outputQueue.length) return this.outputQueue.shift();
    let e = PC.lex.call(this);
    for (
      ;
      Ox[e] === "UNKNOWN" || !this.canAcceptPrimes && Ox[e] === "PRIMES";
    ) this.warn(), e = PC.lex.call(this);
    this.canAcceptPrimes = true;
    let t,
      o,
      i = this.delimiterStack
        ? this.delimiterStack[this.delimiterStack.length - 1]
        : -1;
    switch (Ox[e]) {
      case "OPEN_FRAC":
      case "OPEN_MODEXP":
        this.delimiterStack.push(e), this.canAcceptPrimes = false;
        break;
      case "RADICAL_INDEX":
        i === Pi.RADICAL_INDEX &&
        (this.delimiterStack.pop(), this.pushCloseTokens(i)),
          this.delimiterStack.push(e),
          this.canAcceptPrimes = false;
        break;
      case "OPEN_RADICAL":
        i === Pi.RADICAL_INDEX && this.delimiterStack.pop(),
          this.delimiterStack.push(e),
          this.canAcceptPrimes = false;
        break;
      case "SLASH":
        for (t = false; this.delimiterStack.length;) {
          if (o = this.delimiterStack.pop() || -1, o === Pi.OPEN_FRAC) {
            t = true;
            break;
          } else this.pushCloseTokens(o);
        }
        t || this.pushOpenTokens(e),
          this.delimiterStack.push(e),
          this.canAcceptPrimes = false;
        break;
      case "CLOSE_FRAC":
        for (t = false; this.delimiterStack.length;) {
          if (o = this.delimiterStack.pop() || -1, o === Pi.SLASH) {
            t = true;
            break;
          } else if (o === Pi.OPEN_FRAC) {
            this.addMissingToken(Pi.SLASH), t = true;
            break;
          } else this.pushCloseTokens(o);
        }
        if (!t) return this.warn(), this.canAcceptPrimes = false, this.lex();
        break;
      case "CLOSE_RADICAL":
        for (t = false; this.delimiterStack.length;) {
          if (
            o = this.delimiterStack.pop() || -1, o === Pi.OPEN_RADICAL
          ) {
            t = true;
            break;
          } else if (o === Pi.RADICAL_INDEX) {
            t = true, this.addMissingToken(Pi.OPEN_RADICAL);
            break;
          } else this.pushCloseTokens(o);
        }
        t || this.pushOpenTokens(e);
        break;
      case "CLOSE_MODEXP":
        for (t = false; this.delimiterStack.length;) {
          if (o = this.delimiterStack.pop() || -1, o === Pi.OPEN_MODEXP) {
            t = true;
            break;
          } else this.pushCloseTokens(o);
        }
        t || this.pushOpenTokens(e);
        break;
      case "EOF":
        for (; this.delimiterStack.length;) {
          o = this.delimiterStack.pop() || -1, this.pushCloseTokens(o);
        }
        break;
    }
    return this.outputQueue.push(e), r = this.outputQueue.shift() || -1, r;
  };
  ag.warn = function () {
    this.yylloc && this.yy.warnings.push({ location: this.yylloc });
  };
  ag.addMissingToken = function (r) {
    this.outputQueue.push(r), this.warn();
  };
  ag.pushCloseTokens = function (r) {
    switch (Ox[r]) {
      case "OPEN_FRAC":
        this.addMissingToken(Pi.SLASH), this.addMissingToken(Pi.CLOSE_FRAC);
        break;
      case "SLASH":
        this.addMissingToken(Pi.CLOSE_FRAC);
        break;
      case "RADICAL_INDEX":
        this.addMissingToken(Pi.OPEN_RADICAL),
          this.addMissingToken(Pi.CLOSE_RADICAL);
        break;
      case "OPEN_RADICAL":
        this.addMissingToken(Pi.CLOSE_RADICAL);
        break;
      case "OPEN_MODEXP":
        this.addMissingToken(Pi.CLOSE_MODEXP);
        break;
    }
  };
  ag.pushOpenTokens = function (r) {
    switch (Ox[r]) {
      case "SLASH":
        this.addMissingToken(Pi.OPEN_FRAC);
        break;
      case "CLOSE_FRAC":
        this.addMissingToken(Pi.OPEN_FRAC), this.addMissingToken(Pi.SLASH);
        break;
      case "CLOSE_RADICAL":
        this.addMissingToken(Pi.OPEN_RADICAL);
        break;
      case "CLOSE_MODEXP":
        this.addMissingToken(Pi.OPEN_MODEXP);
        break;
    }
  };
  var KY = D3();
  function WY(r, e) {
    e || (e = {});
    let t = KY.parser, o = Object.create(t);
    o.yy = tM,
      o.yy.warnOrError = (n) => {
        o.parseError(n, { recoverable: false });
      };
    let i = Object.create(t);
    i.yy = Jm({ warnings: [] }, tM),
      i.yy.warnOrError = (n) => {
        i.yy.warnings.push(n);
      },
      i.lexer = HY,
      e.strict ? t = o : t = i;
    try {
      return {
        isError: false,
        value: t.parse(r),
        warnings: t.yy.warnings || [],
      };
    } catch (n) {
      return { error: uM(n), isError: true };
    }
  }
  function yu(r, e) {
    let t = "", o = e, i = "", n = false, a = "", s = "", l = $Y(r);
    for (let c = 0; c < r.length; c++) {
      let d = r[c], p = c + 1 < r.length ? r[c + 1] : null;
      switch (d.type) {
        case "terminal":
          let h = _3(r.slice(c));
          h.value !== ""
            ? (t += h.value, c += h.terminalCount - 1, n = n || h.modified)
            : d.value === " "
            ? (n ? (i = a, t += Vx(o, i), o = i) : t += "\\ ", n = false)
            : (l[c] === GC ? t += "\\left" : l[c] === rM && (t += "\\right"),
              t += d.value);
          break;
        case "comparison":
          i = "", t += Vx(o, i), o = i, n = false, t += d.value;
          break;
        case "level_with_comparison":
          t += Vx(o, d.level), o = d.level, n = false, t += d.value;
          break;
        case "command":
          let u = d.value.slice(1).trim();
          p && p.type === "terminal" && /[a-z]/.test(p.value)
            ? (t += u, n = false)
            : cM(u)
            ? (t += "\\operatorname{" + u + "}", n = true)
            : (t += d.value, n = true), a = o;
          break;
        case "expression":
          t += d.value;
          break;
        case "fraction":
          t += JY(d.numerator, d.denominator, o);
          break;
        case "geo_token":
          t += "\\token{" + d.index.value + "}";
          break;
        case "modified_expression":
          t += yu(d.expression, o) + " ",
            d.under && (t += "_{" + yu(d.under, o) + "}"),
            d.over && (t += "^{" + yu(d.over, o) + "}");
          break;
        case "radical":
          t += "\\sqrt",
            d.index && (t += "[" + yu(d.index, o) + "]"),
            t += "{" + yu(d.value, o) + "}";
          break;
        case "simple_subscript":
          o === ""
            ? (t += d.base.value + "_{" + d.subscript.value + "}",
              d.base.type === "command" && (n = true, a = o))
            : t += d.base.value + d.subscript.value;
          break;
        case "level":
          t += Vx(o, d.value, s),
            o = d.value,
            d.value === "^" && s !== "" && (s = "");
          break;
        case "primes":
          p && p.type === "level" && p.value === ";"
            ? s = d.value
            : o !== ""
            ? (t += Array(d.value.length + 1).join("\\prime "), s = "")
            : (t += d.value, s = "");
          break;
      }
    }
    return t += Vx(o, e) + s, t.replace(/([^\\])( )$/, "$1");
  }
  var GC = 1, rM = -1, AC = 0, QA = 2;
  function $Y(r) {
    let e = [], t = [];
    for (let o = 0; o < r.length; o++) {
      let i = r[o];
      if (jY(i)) e.push({ direction: GC, index: o }), t.push(AC);
      else if (YY(i)) {
        for (; e.length && e[e.length - 1].direction === QA;) e.pop();
        if (e.length) {
          let n = e.pop();
          if (n) {
            let a = n.index;
            t[a] = GC, t.push(rM);
          }
        } else t.push(AC);
      } else if (XY(i)) {
        if (e.length && e[e.length - 1].direction === QA) {
          let n = e.pop();
          if (n) {
            let a = n.index;
            t[a] = GC, t.push(rM);
          }
        } else e.push({ direction: QA, index: o }), t.push(AC);
      } else t.push(AC);
    }
    return t;
  }
  function jY(r) {
    return r.type === "terminal"
      ? /^(\\langle |\[|\(|\\{)$/.test(r.value)
      : false;
  }
  function YY(r) {
    return r.type === "terminal"
      ? /^(\\rangle |\]|\)|\\})$/.test(r.value)
      : false;
  }
  function XY(r) {
    return r.type === "terminal" ? /^(\\\||\|)$/.test(r.value) : false;
  }
  function JY(r, e, t) {
    return "\\frac{" + yu(r, t) + "}{" + yu(e, t) + "}";
  }
  function Vx(r, e, t) {
    let o = "", i, n, a, s = Math.max(r.length, e.length);
    for (i = 0; i < s && r[i] === e[i]; i++);
    for (n = r.length - 1; n >= i; n--) o += "}";
    for (a = i; a < e.length; a++) {
      e[a] === "^" && (t && (o += t), o += "^{"), e[a] === ";" && (o += "_{");
    }
    return o;
  }
  function QY(r) {
    return yu(r, "");
  }
  function ZY(r, e) {
    return e && e.operatorNames ? FC(e.operatorNames) : NC(), Zm(WY(r, e), QY);
  }
  var mM = k3(),
    VC = mM.parser.lexer,
    sg = Object.create(VC),
    eX = sg,
    OC = mM.parser.terminals_,
    Cn = mM.parser.symbols_;
  sg.setInput = function (r, e) {
    this.delimiterStack = [],
      this.outputQueue = [],
      VC.setInput.call(this, r, e);
  };
  sg.lex = function () {
    let r = -1;
    if (this.outputQueue.length) return this.outputQueue.shift();
    let e = VC.lex.call(this);
    for (; OC[e] === "UNKNOWN";) this.warn(), e = VC.lex.call(this);
    let t,
      o,
      i = this.delimiterStack
        ? this.delimiterStack[this.delimiterStack.length - 1]
        : -1;
    switch (OC[e]) {
      case "OPEN_FRAC":
        this.delimiterStack.push(e);
        break;
      case "OPEN_GROUP":
        this.delimiterStack.push(e);
        break;
      case "RADICAL_WITH_INDEX":
        i === Cn.RADICAL_WITH_INDEX &&
        (this.delimiterStack.pop(), this.pushCloseTokens(i)),
          this.delimiterStack.push(e);
        break;
      case "RADICAL":
        i === Cn.RADICAL_WITH_INDEX && this.delimiterStack.pop(),
          this.delimiterStack.push(e);
        break;
      case "OVER":
        for (t = false; this.delimiterStack.length;) {
          if (o = this.delimiterStack.pop() || -1, o === Cn.OPEN_FRAC) {
            t = true;
            break;
          } else this.pushCloseTokens(o);
        }
        t || this.pushOpenTokens(e), this.delimiterStack.push(e);
        break;
      case "CLOSE_FRAC":
        for (t = false; this.delimiterStack.length;) {
          if (o = this.delimiterStack.pop() || -1, o === Cn.OVER) {
            t = true;
            break;
          } else if (o === Cn.OPEN_FRAC) {
            this.outputQueue.push(Cn.OVER), t = true;
            break;
          } else this.pushCloseTokens(o);
        }
        t || this.pushOpenTokens(e);
        break;
      case "CLOSE_GROUP":
        for (t = false; this.delimiterStack.length;) {
          if (o = this.delimiterStack.pop() || -1, o === Cn.OPEN_GROUP) {
            t = true;
            break;
          } else this.pushCloseTokens(o);
        }
        t || this.pushOpenTokens(e);
        break;
      case "CLOSE_RADICAL":
        for (t = false; this.delimiterStack.length;) {
          if (
            o = this.delimiterStack.pop() || -1,
              o === Cn.RADICAL || o === Cn.RADICAL_WITH_INDEX
          ) {
            t = true;
            break;
          } else this.pushCloseTokens(o);
        }
        t || this.pushOpenTokens(e);
        break;
      case "EOF":
        for (; this.delimiterStack.length;) {
          o = this.delimiterStack.pop() || -1, this.pushCloseTokens(o);
        }
        break;
    }
    return this.outputQueue.push(e), r = this.outputQueue.shift() || -1, r;
  };
  sg.warn = function () {
    this.yylloc && this.yy.warnings.push({ location: this.yylloc });
  };
  sg.addMissingToken = function (r) {
    this.outputQueue.push(r), this.warn();
  };
  sg.pushCloseTokens = function (r) {
    switch (OC[r]) {
      case "OPEN_FRAC":
        this.addMissingToken(Cn.OVER), this.addMissingToken(Cn.CLOSE_FRAC);
        break;
      case "OVER":
        this.addMissingToken(Cn.CLOSE_FRAC);
        break;
      case "OPEN_GROUP":
        this.addMissingToken(Cn.CLOSE_GROUP);
        break;
      case "RADICAL_WITH_INDEX":
      case "RADICAL":
        this.addMissingToken(Cn.CLOSE_RADICAL);
        break;
    }
  };
  sg.pushOpenTokens = function (r) {
    switch (OC[r]) {
      case "OVER":
        this.addMissingToken(Cn.OPEN_FRAC);
        break;
      case "CLOSE_FRAC":
        this.addMissingToken(Cn.OPEN_FRAC), this.addMissingToken(Cn.OVER);
        break;
      case "CLOSE_GROUP":
        this.addMissingToken(Cn.OPEN_GROUP);
        break;
      case "CLOSE_RADICAL":
        this.addMissingToken(Cn.RADICAL);
        break;
    }
  };
  var oM = {};
  aM(oM, {
    basic_level: () => oX,
    bracketed_level: () => iX,
    command: () => rX,
    expression: () => cX,
    fraction: () => aX,
    geo_token: () => lX,
    greek: () => pX,
    group: () => dX,
    primes: () => nX,
    radical: () => sX,
    terminal: () => tX,
    to_number: () => uX,
  });
  function tX(r) {
    return { type: "terminal", value: r };
  }
  function rX(r) {
    return { type: "command", value: r };
  }
  function oX(r, e) {
    return { type: "basic_level", level: r, value: e };
  }
  function iX(r, e, t, o) {
    return {
      type: "bracketed_level",
      level: r,
      lbrack: e,
      value: t,
      rbrack: o,
    };
  }
  function nX(r) {
    return {
      type: "primes",
      value: r.length > 0 ? Array(r.length + 1).join("'") : "",
    };
  }
  function aX(r, e) {
    return { type: "fraction", numerator: r, denominator: e };
  }
  function sX(r, e) {
    return { type: "radical", value: r, index: e };
  }
  function lX(r) {
    return { type: "geo_token", index: r };
  }
  function cX(r) {
    return { type: "expression", value: r };
  }
  function dX(...r) {
    return Array.prototype.concat.apply([], r);
  }
  var E3 = {
    ",.&": "\\Chi",
    ",.:": "\\Eta",
    ",.?": "\\Theta",
    ",.A": "\\Alpha",
    ",.B": "\\Beta",
    ",.D": "\\Delta",
    ",.E": "\\Epsilon",
    ",.F": "\\Phi",
    ",.G": "\\Gamma",
    ",.I": "\\Iota",
    ",.K": "\\Kappa",
    ",.L": "\\Lambda",
    ",.M": "\\Mu",
    ",.N": "\\Nu",
    ",.O": "\\Omicron",
    ",.P": "\\prod",
    ",.R": "\\Rho",
    ",.S": "\\sum",
    ",.T": "\\Tau",
    ",.U": "\\Upsilon",
    ",.W": "\\Omega",
    ",.X": "\\Xi",
    ",.Y": "\\Psi",
    ",.Z": "\\Zeta",
    ".&": "\\chi",
    ".:": "\\eta",
    ".?": "\\theta",
    ".A": "\\alpha",
    ".B": "\\beta",
    ".D": "\\delta",
    ".E": "\\epsilon",
    ".F": "\\phi",
    ".G": "\\gamma",
    ".I": "\\iota",
    ".K": "\\kappa",
    ".L": "\\lambda",
    ".M": "\\mu",
    ".N": "\\nu",
    ".O": "\\omicron",
    ".P": "\\pi",
    ".R": "\\rho",
    ".S": "\\sigma",
    ".T": "\\tau",
    ".U": "\\upsilon",
    ".W": "\\omega",
    ".X": "\\xi",
    ".Y": "\\psi",
    ".Z": "\\zeta",
  };
  function pX(r) {
    if (E3.hasOwnProperty(r)) return E3[r] + " ";
    throw new Error("Unknown Greek letter");
  }
  function uX(r) {
    let e = "";
    for (let o of r) {
      o === "4" ? e += "." : o === "J" ? e += "0" : e += o.charCodeAt(0) - 64;
    }
    return e;
  }
  var hX = k3();
  function gX(r, e) {
    e || (e = {});
    let t = hX.parser, o = Object.create(t);
    o.yy = oM;
    let i = Object.create(t);
    i.yy = Jm({ warnings: [] }, oM), i.lexer = eX, e.strict ? t = o : t = i;
    try {
      return {
        isError: false,
        value: t.parse(r),
        warnings: t.yy.warnings || [],
      };
    } catch (n) {
      return { error: uM(n), isError: true };
    }
  }
  function ng(r, e) {
    let t = "", o = false, i = "", n = mX(r);
    for (let a = 0; a < r.length; a++) {
      let s = r[a], l = a + 1 < r.length ? r[a + 1] : null;
      switch (s.type) {
        case "terminal":
          let c = _3(r.slice(a));
          c.value !== ""
            ? (t += c.value, a += c.terminalCount - 1)
            : s.value === " " && !o
            ? t += "\\ "
            : (n[a] === LC ? t += "\\left" : n[a] === iM && (t += "\\right"),
              t += s.value), o = false;
          break;
        case "command":
          let d = s.value.slice(1).trim();
          l && l.type === "terminal" && /[a-z]/.test(l.value)
            ? (t += d, o = false)
            : cM(d)
            ? (t += "\\operatorname{" + d + "}", o = true)
            : (t += s.value, o = true);
          break;
        case "expression":
          t += s.value;
          break;
        case "fraction":
          t += xX(s.numerator, s.denominator);
          break;
        case "radical":
          t += "\\sqrt",
            s.index && (t += "[" + ng(s.index) + "]"),
            t += "{" + ng(s.value) + "}";
          break;
        case "geo_token":
          t += "\\token{" + s.index.value + "}";
          break;
        case "basic_level":
          t += wX(s.level, s.value, i), s.level === "9" && (i = "");
          break;
        case "bracketed_level":
          t += vX(s.level, s.lbrack, s.value, s.rbrack, i),
            s.level === "9" && (i = "");
          break;
        case "primes":
          l &&
            (l.type === "basic_level" || l.type === "bracketed_level") &&
            l.level === "5"
            ? i = s.value
            : e && e !== ""
            ? (t += Array(s.value.length + 1).join("\\prime "), i = "")
            : (t += s.value, i = "");
          break;
      }
    }
    return t += i, t.replace(/([^\\])( )$/, "$1");
  }
  var LC = 1, iM = -1, MC = 0, ZA = 2;
  function mX(r) {
    let e = [], t = [];
    for (let o = 0; o < r.length; o++) {
      let i = r[o];
      if (fX(i)) e.push({ direction: LC, index: o }), t.push(MC);
      else if (bX(i)) {
        for (; e.length && e[e.length - 1].direction === ZA;) e.pop();
        if (e.length) {
          let n = e.pop();
          if (n) {
            let a = n.index;
            t[a] = LC, t.push(iM);
          }
        } else t.push(MC);
      } else if (yX(i)) {
        if (e.length && e[e.length - 1].direction === ZA) {
          let n = e.pop();
          if (n) {
            let a = n.index;
            t[a] = LC, t.push(iM);
          }
        } else e.push({ direction: ZA, index: o }), t.push(MC);
      } else t.push(MC);
    }
    return t;
  }
  function fX(r) {
    return r.type === "terminal"
      ? /^(\\langle |\[|\(|\\{)$/.test(r.value)
      : false;
  }
  function bX(r) {
    return r.type === "terminal"
      ? /^(\\rangle |\]|\)|\\})$/.test(r.value)
      : false;
  }
  function yX(r) {
    return r.type === "terminal" ? /^(\\\||\|)$/.test(r.value) : false;
  }
  function xX(r, e) {
    return "\\frac{" + ng(r) + "}{" + ng(e) + "}";
  }
  function wX(r, e, t) {
    let o = "", i = "{" + ng(e, r) + "}";
    return r === "9" ? o += t + "^" + i : r === "5" && (o += "_" + i), o;
  }
  function vX(r, e, t, o, i) {
    let n = "", a = "{" + e + ng(t, r) + o + "}";
    return r === "9" ? n += i + "^" + a : r === "5" && (n += "_" + a), n;
  }
  var CX = ng;
  function SX(r, e) {
    return e && e.operatorNames ? FC(e.operatorNames) : NC(),
      Zm(gX(r, e), (t) => CX(t, ""));
  }
  var F3 = ` A1B'K2L@CIF/MSP"E3H9O6R^DJG>NTQ,*5<-U8V.%[$+X!&;:4\\0Z7(_?W]#Y)=`,
    N3 = 10240;
  function EX(r) {
    return String.fromCharCode(N3 + r);
  }
  function TX(r) {
    return r.charCodeAt(0) - N3;
  }
  function DX(r) {
    return F3[r];
  }
  function kX(r) {
    return F3.indexOf(r);
  }
  function _X(r) {
    let e = "";
    for (let t of r) e += EX(kX(t));
    return e;
  }
  function B3(r) {
    let e = "";
    for (let t of r) e += DX(TX(t));
    return e;
  }
  function IX(r) {
    return B3(r).replace(
      /[@-^]/g,
      (e) => String.fromCharCode(e.charCodeAt(0) + 32),
    );
  }
  function AX(r) {
    let e = "";
    if (r) {
      for (let t of r) {
        let o = t.charCodeAt(0);
        96 <= o && o <= 127 && (o -= 32, t = String.fromCharCode(o)),
          32 <= o && o <= 95 && (t = _X(t), o = t.charCodeAt(0)),
          10305 <= o && o <= 10495 &&
          (o = 10240 + (o - 1024) % 64, t = String.fromCharCode(o)),
          10240 <= o && o <= 10304 ? e += t : e += "\u2800";
      }
    }
    return e;
  }
  function MX(r) {
    for (let e = 0; e < r.length; e++) {
      let t = r.charCodeAt(e);
      if (t < 10240 || t > 10304) return false;
    }
    return true;
  }
  function U3(r) {
    if (!MX(r)) {
      throw new Error(
        "EncodingError: Expected input to be six-dot unicode braille characters.",
      );
    }
  }
  function fM(r, e) {
    return U3(r), ZY(sa.toBrailleAscii(r), e);
  }
  function lp(r, e) {
    return e && e.operatorNames ? FC(e.operatorNames) : NC(),
      Zm(nY(r), sa.coerceToSixDotCells);
  }
  function bM(r, e) {
    return U3(r), SX(sa.toBrailleAscii(r), e);
  }
  function cp(r, e) {
    return e && e.operatorNames ? FC(e.operatorNames) : NC(),
      Zm(bY(r), sa.coerceToSixDotCells);
  }
  var sa = {
      coerceToSixDotCells: AX,
      toBrailleAscii: B3,
      toExpandedBrailleAscii: IX,
    },
    GX = "1.0.3";
  var z3 = 1,
    q3 = 2,
    H3 = 4,
    K3 = 8,
    zC = 15,
    W3 = 12,
    $3 = 3,
    j3 = 1,
    Y3 = 2,
    X3 = 3,
    J3 = 4,
    lg = 5,
    ef = 6;
  function vu(r, e, t) {
    let o = [], i = r.length;
    if (t === lg) {
      for (let n = 0; n < i; n += 2) {
        let a = e.mapX(r[n]), s = e.mapY(r[n + 1]);
        o.push(a, s);
      }
    } else if (t === ef) {
      for (let n = 0; n < i; n += 2) {
        let a = e.mapX(r[n + 1]), s = e.mapY(r[n]);
        o.push(a, s);
      }
    } else if (t === j3) {
      for (let n = 0; n < r.length; n += 2) {
        let a = r[n],
          s = r[n + 1],
          l = e.mapX(s * Math.cos(a)),
          c = e.mapY(s * Math.sin(a));
        o.push(l, c);
      }
    } else if (t === Y3) {
      for (let n = 0; n < r.length; n += 2) {
        let a = r[n], s = r[n + 1];
        s < 0 && (s = 0);
        let l = e.mapX(s * Math.cos(a)), c = e.mapY(s * Math.sin(a));
        o.push(l, c);
      }
    } else if (t === X3) {
      for (let n = 0; n < r.length; n += 2) {
        let a = r[n] * Math.PI / 180,
          s = r[n + 1],
          l = e.mapX(s * Math.cos(a)),
          c = e.mapY(s * Math.sin(a));
        o.push(l, c);
      }
    } else if (t === J3) {
      for (let n = 0; n < r.length; n += 2) {
        let a = r[n] * Math.PI / 180, s = r[n + 1];
        s < 0 && (s = 0);
        let l = e.mapX(s * Math.cos(a)), c = e.mapY(s * Math.sin(a));
        o.push(l, c);
      }
    }
    return o;
  }
  function Q3(r, e) {
    return yM(r, e, zC, true);
  }
  function Z3(r, e) {
    return LX(r, e, zC, true);
  }
  function BC(r, e, t, o) {
    let i = [], n, a, s, l;
    o
      ? (a = r[0], s = r[1], n = 2, l = e(a, s), l && i.push(a, s))
      : (a = r[r.length - 2], s = r[r.length - 1], n = 0, l = e(a, s));
    for (let c = n; c < r.length; c += 2) {
      let d = a, p = s, h = l;
      a = r[c],
        s = r[c + 1],
        l = e(a, s),
        !(!l && !h) &&
        (l && h && i.push(a, s),
          l && !h && (i.push(...t(a, s, d, p)), i.push(a, s)),
          !l && h && i.push(...t(d, p, a, s)));
    }
    return i;
  }
  function UC(r, e, t, o) {
    let i = [[]], n = 0, a, s, l, c;
    o
      ? (s = r[0], l = r[1], a = 2, c = e(s, l), c && i[n].push(s, l))
      : (s = r[r.length - 2], l = r[r.length - 1], a = 0, c = e(s, l));
    for (let d = a; d < r.length; d += 2) {
      let p = s, h = l, u = c;
      s = r[d],
        l = r[d + 1],
        c = e(s, l),
        !(!c && !u) &&
        (c && u && i[n].push(s, l),
          c && !u && (i[n].push(...t(s, l, p, h)), i[n].push(s, l)),
          !c && u && (i[n].push(...t(p, h, s, l)), n++, i[n] = []));
    }
    return i.filter((d) => d.length > 0);
  }
  var eN = (r) =>
      function (e, t) {
        return e >= r;
      },
    tN = (r) =>
      function (e, t) {
        return e <= r;
      },
    rN = (r) =>
      function (e, t) {
        return t >= r;
      },
    oN = (r) =>
      function (e, t) {
        return t <= r;
      },
    iN = (r) =>
      function (e, t, o, i) {
        let n = i - t;
        return [r, t + n * (r - e) / (o - e)];
      },
    nN = (r) =>
      function (e, t, o, i) {
        let n = i - t;
        return [r, t + n * (r - e) / (o - e)];
      },
    aN = (r) =>
      function (e, t, o, i) {
        let n = o - e;
        return [e + n * (r - t) / (i - t), r];
      },
    sN = (r) =>
      function (e, t, o, i) {
        let n = o - e;
        return [e + n * (r - t) / (i - t), r];
      };
  function yM(r, e, t, o) {
    let i = r;
    return t & H3 && (i = BC(r, eN(e.xmin), iN(e.xmin), o)),
      t & q3 && (i = BC(i, rN(e.ymin), aN(e.ymin), o)),
      t & K3 && (i = BC(i, tN(e.xmax), nN(e.xmax), o)),
      t & z3 && (i = BC(i, oN(e.ymax), sN(e.ymax), o)),
      i;
  }
  function LX(r, e, t, o) {
    let i = [r];
    return t & H3 &&
      (i = __dcg_shared_module_exports__["t"](
        i.map((n) => UC(n, eN(e.xmin), iN(e.xmin), o)),
        true,
      )),
      t & q3 &&
      (i = __dcg_shared_module_exports__["t"](
        i.map((n) => UC(n, rN(e.ymin), aN(e.ymin), o)),
        true,
      )),
      t & K3 &&
      (i = __dcg_shared_module_exports__["t"](
        i.map((n) => UC(n, tN(e.xmax), nN(e.xmax), o)),
        true,
      )),
      t & z3 &&
      (i = __dcg_shared_module_exports__["t"](
        i.map((n) => UC(n, oN(e.ymax), sN(e.ymax), o)),
        true,
      )),
      i;
  }
  function lN(r, e, t) {
    let o = [], i = r[0], n = i + t, a = [];
    o.push(a);
    for (let s = 0; s < r.length; s += 2) {
      let l = r[s], c = r[s + 1];
      if (c < 0 && (c = 0), l >= n) {
        for (a = [], o.push(a), i = r[s - 2], n = i; l >= n;) n += t;
        s -= 4;
      } else a.push(l, c);
    }
    if (e === 0) { for (let s = 0; s < o.length; s++) o[s].push(0, 0); }
    else {
      let s = t / 16, l = e;
      for (let c = 0; c < o.length; c++) {
        let d = o[c];
        i = d[0], n = d[d.length - 2];
        for (let p = n; p > i; p -= s) d.push(p, l);
        d.push(i, l);
      }
    }
    return o;
  }
  function xM(r, e) {
    return r = r.slice(), r.push(r[r.length - 2], e), r.push(r[0], e), [r];
  }
  function Rx(r, e, t) {
    switch (r) {
      case 1:
        return ef;
      case 8:
      case 5:
      case 2:
        return lg;
      case 6:
        return t.degreeMode ? e ? J3 : X3 : e ? Y3 : j3;
    }
  }
  function io(r, e) {
    if (/^\s*(\-|\+)?([0-9]+(\.[0-9]+)?)\s*$/.test(r)) {
      return parseFloat(r);
    }
    let o = __dcg_shared_module_exports__["Nb"](
      __dcg_shared_module_exports__["qc"],
    );
    return o.trigAngleMultiplier =
      new __dcg_shared_module_exports__["Et_Constant"](
        e ? Math.PI / 180 : 1,
      ),
      +__dcg_shared_module_exports__["Wc"](r).tryGetConcreteTree(
        __dcg_shared_module_exports__["Xc"],
        o,
      ).asValue();
  }
  var sS = {};
  __dcg_shared_module_exports__["defineProperties"](sS, {
    CLCalculator: () => ON_CLCalculator,
    Label: () => __dcg_shared_module_exports__["OoLabel"],
    applyDiff: () => FN_applyDiff,
    applyLocalizationMap: () => HN_applyLocalizationMap,
    blankGeometryCalculatorState: () => xQ_blankGeometryCalculatorState,
    blankGraphingCalculatorState: () => yQ_blankGraphingCalculatorState,
    builtInFrame: () => mQ_builtInFrame,
    calculateDiff: () => UN_calculateDiff,
    colorHelpers: () => __dcg_shared_module_exports__["colorHelpers"],
    context: () => gQ_context,
    expressionParser: () => WM_expressionParser,
    extractLocalizationMap: () => qN_extractLocalizationMap,
    formatLatex: () => tB_formatLatex,
    migrateGeoStateToCalcState: () => ug_migrateGeoStateToCalcState,
    migrateToLatest: () => dc_migrateToLatest,
    numberToDecimalString: () => __dcg_shared_module_exports__["ce"],
    numberToLatex: () => __dcg_shared_module_exports__["be"],
    parseNodes: () => oB_parseNodes,
    parser: () => uQ_parser,
    policies: () => bQ_policies,
    replaceIdentifierWithLatex: () => PM_replaceIdentifierWithLatex,
    treeQueries: () => hQ_treeQueries,
    types: () => fQ_types,
  });
  var wM = {
      enabled: false,
      latex: "",
      hoveredImage: "",
      depressedImage: "",
    },
    qC = {
      center: "\\left(0,0\\right)",
      angle: "0",
      width: "10",
      height: "10",
      opacity: "1",
      clickableInfo: wM,
      description: "",
      draggable: false,
    },
    cN = {
      folderId: "",
      hidden: false,
      secret: false,
      readonly: false,
      disableGraphInteractions: false,
      foreground: false,
      name: "",
      ...qC,
    };
  function HC(r) {
    return { ...cN, ...r, clickableInfo: { ...wM, ...r.clickableInfo } };
  }
  function dN(r) {
    let e = __dcg_shared_module_exports__["md"](cN, r),
      t = __dcg_shared_module_exports__["nd"](wM, r.clickableInfo);
    return t === void 0 ? delete e.clickableInfo : e.clickableInfo = t, e;
  }
  function vM(r) {
    return __dcg_shared_module_exports__["td"](r, qC);
  }
  function KC(r) {
    return {
      type: "image",
      id: r.id,
      ...vM(r),
      guid: "",
      index: 0,
      color: "",
      shouldGraph: r.hidden,
      showPoints: false,
    };
  }
  var pN = { folderId: "", secret: false, readonly: false },
    dg = {
      latex: "",
      color: "",
      hidden: false,
      values: [],
      points: true,
      lines: false,
      dragMode: "NONE",
      pointStyle: "POINT",
      lineStyle: "SOLID",
      colorLatex: "",
      lineOpacity: "",
      lineWidth: "",
      pointOpacity: "",
      pointSize: "",
      disableGraphInteractions: false,
    };
  function WC(r) {
    let e = (r.columns || []).map((t) => ({ ...dg, ...t }));
    return { ...pN, ...r, columns: e };
  }
  function uN(r) {
    return r = {
      ...r,
      columns: r.columns.map((e) => __dcg_shared_module_exports__["md"](dg, e)),
    },
      __dcg_shared_module_exports__["md"](pN, r);
  }
  function $C(r) {
    return {
      type: "table",
      id: r.id,
      columns: r.columns.map((t) => ({ ...t, tableId: r.id })),
      regression: r.regression,
    };
  }
  var of = { handlerLatex: "", minStepLatex: "", open: false, playing: false };
  function jC(r) {
    return {
      type: "ticker",
      id: r.id,
      handlerLatex: r.handlerLatex,
      minStepLatex: r.minStepLatex,
      shouldGraph: false,
    };
  }
  function hN(r) {
    return __dcg_shared_module_exports__["nd"](of, r);
  }
  function YC(r) {
    return { ...of, ...r };
  }
  function CM() {
    return {
      type: "folder",
      id: __dcg_shared_module_exports__["xd"],
      title: "geometry",
      secret: true,
    };
  }
  var nf = {
    version: _l,
    randomSeed: "",
    graph: {
      viewport: { xmin: -10, ymin: -13.25, xmax: 10, ymax: 13.25 },
      showGrid: false,
      product: "geometry-calculator",
      showXAxis: false,
      showYAxis: false,
      degreeMode: true,
    },
    expressions: { list: [CM(), { id: "1", type: "expression" }] },
  };
  function FX(r) {
    typeof r.min == "number" && (r.min = "" + r.min),
      typeof r.max == "number" && (r.max = "" + r.max),
      typeof r.step == "number" && (r.step = "" + r.step);
  }
  function NX(r) {
    r.slider && FX(r.slider), typeof r.id != "string" && (r.id = "" + r.id);
  }
  function BX(r, e) {
    let t = UX(r) + 1, o = {}, i, n;
    for (let a of r) {
      if (NX(a), a.type === "folder") {
        i = a.id,
          o[a.id] && (a.id = "" + t, t += 1),
          n = a.id,
          o[a.id] = true,
          a.hasOwnProperty("folderId") && delete a.folderId;
      } else {
        if (
          i !== void 0 && a.folderId === i
            ? a.folderId = n
            : (a.folderId && (a.folderId = ""), i = void 0, n = void 0),
            a.type === "table" && Array.isArray(a.columns)
        ) {
          for (let s of a.columns) {
            o[s.id] && (s.id = "" + t, t += 1), o[s.id] = true;
          }
        }
        o[a.id] && (a.id = "" + t, t += 1), o[a.id] = true;
      }
    }
    e === "geometry-calculator" &&
      !o[__dcg_shared_module_exports__["xd"]] && r.push(CM());
  }
  function gN(r, e) {
    let t = parseFloat(e);
    return t !== Math.floor(t) ? r : Math.max(r, t);
  }
  function UX(r) {
    let e = 0;
    for (let t of r) {
      if (
        e = gN(e, t.id), t.type === "table" && Array.isArray(t.column)
      ) { for (let o of t.columns) gN(e, o.id); }
    }
    return e;
  }
  function XC(r) {
    var i, n;
    let e = __dcg_shared_module_exports__["Jc"](r),
      t = e.graph && e.graph.product,
      o = e.expressions.list;
    return Array.isArray(o) && BX(o, t),
      (i = e.graph) != null && i.complex &&
      ((n = e.graph) != null && n.degreeMode) &&
      (e.graph.degreeMode = false),
      e;
  }
  var SM = { NONE: "NONE", POSITIVE: "POSITIVE", BOTH: "BOTH" },
    zX = {
      expression: true,
      table: true,
      image: true,
      folder: true,
      text: true,
    };
  function qX(r) {
    if (r.type) {
      if (zX.hasOwnProperty(r.type)) return r.type;
      throw new Error("Invalid item type: '" + r.type + "'.");
    }
    return r.text !== void 0
      ? "text"
      : r.columns !== void 0 || r.headings !== void 0
      ? "table"
      : "expression";
  }
  function JC(r) {
    return r.replace(
      /\\(total|length|mean|median|quantile|stdev|stddev|stdDev|stdevp|stddevp|stdDevP|var|variance|cov|corr|ceil|floor|round|abs|mod|lcm|mcm|mcd|nCr|nPr|signum|sign|arcsinh|arccosh|arctanh|arccsch|arcsech|arccoth|arccsc|arcsec|arccot)/g,
      "\\operatorname{$1}",
    );
  }
  function HX(r) {
    let e = {};
    for (let t in r) {
      r.hasOwnProperty(t) &&
        (t === "latex"
          ? e[t] = JC(r[t])
          : t === "values"
          ? e[t] = r[t].map(JC)
          : e[t] = r[t]);
    }
    return e;
  }
  function KX(r) {
    let e = qX(r), t = {}, o;
    switch (e) {
      case "expression":
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "latex" ? t[o] = JC(r[o]) : t[o] = r[o]);
        }
        return t.type = e, t;
      case "table":
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "columns" ? t[o] = r[o].map(HX) : t[o] = r[o]);
        }
        return t.type = e, t;
      case "image":
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "width" || o === "height" || o === "x" || o === "y"
              ? t[o] = JC(r[o])
              : t[o] = r[o]);
        }
        return t.type = e, t;
      case "text":
      case "folder":
        for (o in r) r.hasOwnProperty(o) && (t[o] = r[o]);
        return t.type = e, t;
    }
  }
  var mN = { none: SM.NONE, both: SM.BOTH, positive: SM.POSITIVE };
  function WX(r) {
    let e = {};
    for (let t in r) {
      r.hasOwnProperty(t) &&
        (t === "xAxisArrows" || t === "yAxisArrows" || (e[t] = r[t]));
    }
    return e.xAxisArrowMode = mN[r.xAxisArrows || "none"],
      e.yAxisArrowMode = mN[r.yAxisArrows || "none"],
      e;
  }
  function fN(r) {
    if (r.version) throw new Error("Unexpected version: " + r.version);
    let e = {};
    return e.graph = WX(r.graph),
      e.expressions = { list: r.expressions.list.map(KX) },
      e.version = 0,
      e;
  }
  function QC(r) {
    return r.replace(/\\(sech|csch)/g, "\\operatorname{$1}");
  }
  function $X(r) {
    let e = {};
    for (let t in r) {
      r.hasOwnProperty(t) &&
        (t === "latex"
          ? e[t] = QC(r[t])
          : t === "values"
          ? e[t] = r[t].map(QC)
          : e[t] = r[t]);
    }
    return e;
  }
  function jX(r) {
    let e = r.type, t = {}, o;
    switch (e) {
      case "expression":
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "latex" ? t[o] = QC(r[o]) : t[o] = r[o]);
        }
        return t;
      case "table":
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "columns" ? t[o] = r[o].map($X) : t[o] = r[o]);
        }
        return t;
      case "image":
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "width" || o === "height" || o === "x" || o === "y"
              ? t[o] = QC(r[o])
              : t[o] = r[o]);
        }
        return t;
      case "text":
      case "folder":
        for (o in r) r.hasOwnProperty(o) && (t[o] = r[o]);
        return t;
      default:
        throw new Error("Unexpected expression type: " + e);
    }
  }
  function bN(r) {
    if (r.version) throw new Error("Unexpected version: " + r.version);
    let e = {};
    return e.graph = r.graph,
      e.expressions = { list: r.expressions.list.map(jX) },
      e.version = 1,
      e;
  }
  var YX = 2,
    XX = "#C0504D",
    JX = "#4F81BD",
    QX = "#9BBB59",
    ZX = "#8064A2",
    eJ = "#F79646",
    tJ = "#000000";
  function yN(r) {
    switch (r) {
      case XX:
        return __dcg_shared_module_exports__["Rd"].RED;
      case JX:
        return __dcg_shared_module_exports__["Rd"].BLUE;
      case QX:
        return __dcg_shared_module_exports__["Rd"].GREEN;
      case ZX:
        return __dcg_shared_module_exports__["Rd"].PURPLE;
      case eJ:
        return __dcg_shared_module_exports__["Rd"].ORANGE;
      case tJ:
        return __dcg_shared_module_exports__["Rd"].BLACK;
      default:
        return r;
    }
  }
  function rJ(r) {
    let e = {};
    for (let t in r) {
      r.hasOwnProperty(t) &&
        (t === "color" ? e[t] = yN(r[t]) : e[t] = r[t]);
    }
    return e;
  }
  function oJ(r) {
    let e = r.type, t = {}, o;
    switch (e) {
      case "expression":
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "color" ? t[o] = yN(r[o]) : t[o] = r[o]);
        }
        return t;
      case "table":
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "columns" ? t[o] = r[o].map(rJ) : t[o] = r[o]);
        }
        return t;
      case "image":
      case "text":
      case "folder":
        for (o in r) r.hasOwnProperty(o) && (t[o] = r[o]);
        return t;
      default:
        throw new Error("Unexpected expression type: " + e);
    }
  }
  function xN(r) {
    if (r.version > 1) {
      throw new Error("Unexpected version: " + r.version);
    }
    let e = {};
    return e.graph = r.graph,
      e.expressions = { list: r.expressions.list.map(oJ) },
      e.version = YX,
      e;
  }
  function EM(r) {
    if (typeof r == "string") return r;
    if (r === void 0) return "";
    let e = r + "";
    return e = e.replace(/1e\+?([-\d]+)/, "10^{$1}"),
      e = e.replace(/([-\d\.]+)e\+?([-\d]+)/, "$1\\cdot 10^{$2}"),
      e;
  }
  function iJ(r) {
    let e = r.type, t = {}, o;
    switch (e) {
      case "expression":
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "sliderMax" || o === "sliderMin" ||
                o === "sliderInterval"
              ? t[o] = EM(r[o])
              : o === "domain"
              ? t[o] = { max: EM(r[o].max), min: EM(r[o].min) }
              : t[o] = r[o]);
        }
        return t.hasOwnProperty("sliderMin") &&
          t.sliderInterval === void 0 && (t.sliderInterval = ""),
          t;
      case "image":
      case "table":
      case "text":
      case "folder":
        for (o in r) r.hasOwnProperty(o) && (t[o] = r[o]);
        return t;
      default:
        throw new Error("Unexpected expression type: " + e);
    }
  }
  function wN(r) {
    if (r.version > 2) {
      throw new Error("Unexpected version: " + r.version);
    }
    let e = {};
    return e.graph = r.graph,
      e.expressions = { list: r.expressions.list.map(iJ) },
      e.version = 3,
      e;
  }
  function vN(r) {
    switch (r) {
      case "point":
        return "POINT";
      case "cross":
        return "CROSS";
      case "open":
        return "OPEN";
      case "normal":
        return "SOLID";
      case "dashed":
        return "DASHED";
      case "dotted":
        return "DOTTED";
      default:
        return r;
    }
  }
  function nJ(r) {
    let e = {};
    for (let t in r) {
      r.hasOwnProperty(t) &&
        (t === "style" ? e[t] = vN(r[t]) : e[t] = r[t]);
    }
    return e;
  }
  function aJ(r) {
    let e = r.type, t = {}, o;
    switch (e) {
      case "expression":
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "style" ? t[o] = vN(r[o]) : t[o] = r[o]);
        }
        return t;
      case "table":
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "columns" ? t[o] = r[o].map(nJ) : t[o] = r[o]);
        }
        return t;
      case "image":
      case "text":
      case "folder":
        for (o in r) r.hasOwnProperty(o) && (t[o] = r[o]);
        return t;
      default:
        throw new Error("Unexpected expression type: " + e);
    }
  }
  function CN(r) {
    if (r.version !== 3) {
      throw new Error("Unexpected version: " + r.version);
    }
    let e = {};
    return e.graph = r.graph,
      e.expressions = { list: r.expressions.list.map(aJ) },
      e.version = 4,
      e;
  }
  function sJ(r) {
    let e = {}, t;
    for (let o in r) {
      if (r.hasOwnProperty(o)) {
        switch (t = r[o], o) {
          case "showAxes":
            e.showXAxis = t, e.showYAxis = t;
            break;
          case "showLabels":
            e.xAxisNumbers = t, e.yAxisNumbers = t, e.polarNumbers = t;
            break;
          case "labelXMode":
            e.xAxisStep = t === "pi" ? Math.PI : 0;
            break;
          case "labelYMode":
            e.yAxisStep = t === "pi" ? Math.PI : 0;
            break;
          default:
            e[o] = t;
        }
      }
    }
    return e;
  }
  function lJ(r) {
    let e = {};
    for (let t in r) {
      r.hasOwnProperty(t) &&
        (t === "showPoints" || t === "showLine" || (e[t] = r[t]));
    }
    return (r.showPoints !== void 0 || r.showLine !== void 0) &&
      (r.showPoints && r.showLine
        ? e.columnMode = "POINTS_AND_LINES"
        : r.showPoints
        ? e.columnMode = "POINTS"
        : r.showLine
        ? e.columnMode = "LINES"
        : (e.hidden = true, e.columnMode = "POINTS")),
      e;
  }
  function cJ(r) {
    let e = r.type, t = {}, o;
    switch (e) {
      case "expression":
        r.hidden === void 0
          ? r.hasOwnProperty("graphed")
            ? t.hidden = !r.graphed
            : r.hasOwnProperty("userRequestedGraphing")
            ? t.hidden = r.userRequestedGraphing === "never"
            : t.hidden = false
          : t.hidden = r.hidden;
        for (o in r) {
          if (
            r.hasOwnProperty(o) &&
            !(o === "graphed" || o === "userRequestedGraphing" ||
              o === "hidden") &&
            o !== "slider"
          ) {
            if (o === "color") {
              typeof r.color == "object"
                ? t.color = r.color.value
                : t.color = r.color;
              continue;
            }
            if (o === "style") {
              t.style = r.style === "normal" ? "SOLID" : r.style;
              continue;
            }
            if (o === "sliderInterval") {
              t.sliderInterval = r.sliderInterval === "undefined"
                ? ""
                : r.sliderInterval;
              continue;
            }
            t[o] = r[o];
          }
        }
        return t;
      case "table":
        if (r.headings || r.columns) {
          let i = r.headings ? r.headings : r.columns;
          if (t.columns = i.map(lJ), r.rows) {
            for (let n = 0; n < t.columns.length; n++) {
              let a = t.columns[n];
              a.values = [];
              for (let s = 0; s < r.rows.length; s++) {
                a.values.push(r.rows[s][n]);
              }
            }
          }
        }
        for (o in r) {
          r.hasOwnProperty(o) &&
            (o === "rows" || o === "headings" || o === "columns" ||
              (t[o] = r[o]));
        }
        return t;
      case "image":
      case "text":
      case "folder":
        for (o in r) r.hasOwnProperty(o) && (t[o] = r[o]);
        return t;
      default:
        throw new Error("Unexpected expression type: " + e);
    }
  }
  function SN(r) {
    if (r.version !== 4) {
      throw new Error("Unexpected version: " + r.version);
    }
    return {
      version: 5,
      graph: sJ(r.graph),
      expressions: { list: r.expressions.list.map(cJ) },
    };
  }
  var pJ = 6;
  function uJ(r) {
    return r.length < 2 ? false : r[0] === "`" && r[r.length - 1] === "`";
  }
  function hJ(r) {
    if (uJ(r)) return { raw: r, parts: [r] };
    let t = "({" +
        [
          "[a-zA-Z][0-9]*",
          "[a-zA-Z]_[a-zA-Z0-9]+",
          "[a-zA-Z]_\\{[a-zA-Z0-9]+\\}",
        ].join("})|({") + "})",
      o = new RegExp(t, "g"),
      i = [],
      n = 0,
      a = 0,
      s;
    for (; s = o.exec(r);) {
      a = s.index, a > n && i.push(r.substr(n, a - n));
      let l = s[0],
        c = l.replace(/[{}\$]/g, "").replace(
          /^([a-zA-Z])([0-9]+)$/,
          "$1_$2",
        );
      i.push({ symbol: c, str: l }), n = s.index + l.length;
    }
    return n < r.length && i.push(r.substr(n)), { raw: r, parts: i };
  }
  function gJ(r) {
    let e = {};
    for (let t in r) {
      if (r.hasOwnProperty(t) && t !== "style") {
        if (
          t === "values" && (e[t] = r[t].map((o) => o ? "" + o : "")),
            t === "columnMode" && !r.hasOwnProperty("points") &&
            !r.hasOwnProperty("lines")
        ) {
          switch (r[t]) {
            case "LINES":
              e.points = false, e.lines = true;
              break;
            case "POINTS_AND_LINES":
              e.points = true, e.lines = true;
              break;
            default:
              e.points = true, e.lines = false;
          }
        } else e[t] = r[t];
      }
    }
    return e.hasOwnProperty("pointStyle") || (e.pointStyle = "POINT"),
      e.hasOwnProperty("lineStyle") || (e.lineStyle = "SOLID"),
      e.id = "" + e.id,
      e;
  }
  var EN = {
    sliderMin: "min",
    sliderMax: "max",
    sliderInterval: "step",
    sliderHardMin: "hardMin",
    sliderHardMax: "hardMax",
    sliderAnimationPeriod: "animationPeriod",
    sliderLoopMode: "loopMode",
    sliderPlayDirection: "playDirection",
    sliderIsPlaying: "isPlaying",
  };
  function mJ(r) {
    let e = hJ(r), t = "";
    return __dcg_shared_module_exports__["g"](e.parts, (o) => {
      t += typeof o == "object" && o.str ? "$" + o.str : o;
    }),
      t;
  }
  function fJ(r, e) {
    let t = r.latex.split("=");
    if (t.length !== 2) return;
    let o = io(t[1], e);
    if (!isFinite(o)) return;
    let i = r.slider.hardMin ? io(r.slider.min || "-10", e) : void 0,
      n = r.slider.hardMax ? io(r.slider.max || "10", e) : void 0,
      a = r.slider.step ? io(r.slider.step, e) : void 0,
      s = __dcg_shared_module_exports__["yc"]({
        target: o,
        step: a,
        hardMin: i,
        hardMax: n,
      });
    s.min || (delete r.slider.hardMin, delete r.slider.min),
      s.max || (delete r.slider.hardMax, delete r.slider.max),
      s.step || delete r.slider.step;
  }
  function bJ(r, e, t, o) {
    let i = r.type, n = {}, a;
    switch (i) {
      case "folder":
        for (a in r) {
          r.hasOwnProperty(a) && (a === "memberIds" || (n[a] = r[a]));
        }
        break;
      case "expression":
        for (a in r) {
          if (r.hasOwnProperty(a)) {
            if (
              a === "style" && !r.hasOwnProperty("pointStyle") &&
              !r.hasOwnProperty("lineStyle")
            ) {
              let s = r[a];
              __dcg_shared_module_exports__["l"]([
                  "POINT",
                  "OPEN",
                  "CROSS",
                ], s)
                ? (n.pointStyle = s, n.lineStyle = "SOLID")
                : __dcg_shared_module_exports__["l"]([
                    "SOLID",
                    "DASHED",
                    "DOTTED",
                  ], s)
                ? (n.pointStyle = "POINT", n.lineStyle = s)
                : (n.pointStyle = "POINT", n.lineStyle = "SOLID");
              continue;
            }
            EN.hasOwnProperty(a)
              ? (n.slider = n.slider || {}, n.slider[EN[a]] = r[a])
              : n[a] = r[a], r.label && (n.label = mJ(r.label));
          }
        }
        n.latex && n.slider && !n.slider.isPlaying && fJ(n, o),
          n.hasOwnProperty("fillOpacity") || (n.fillOpacity = .4),
          n.label === false && (n.label = ""),
          n.labelSize || (n.labelSize = "medium"),
          n.labelOrientation || (n.labelOrientation = "default"),
          n.verticalLabel || (n.verticalLabel = false),
          n.interactiveLabel || (n.interactiveLabel = false);
        break;
      case "image":
        for (a in r) {
          !r.hasOwnProperty(a) || a === "x" || a === "y" || (n[a] = r[a]);
        }
        n.center = "\\left(" + (r.x || "0") + "," + (r.y || "0") +
          "\\right)",
          n.angle = r.angle || "0",
          n.foreground = !!n.foreground;
        break;
      case "text":
        for (a in r) r.hasOwnProperty(a) && (n[a] = r[a]);
        break;
      case "table":
        for (a in r) {
          r.hasOwnProperty(a) &&
            (a === "columns" ? n[a] = r[a].map(gJ) : n[a] = r[a]);
        }
        break;
      default:
        throw new Error("Unexpected expression type: " + i);
    }
    if (n.id = "" + n.id, r.type === "folder") {
      e.folderId = n.id, e.memberIds = r.memberIds, n.folderId = "";
    } else {
      let s = t[n.id];
      e.memberIds && e.memberIds[s]
        ? n.folderId = e.folderId
        : (n.folderId = "", e.folderId = void 0, e.memberIds = void 0);
    }
    return n;
  }
  function yJ(r) {
    let e = 0, t = /^[0-9]+$/;
    for (let o = r.length - 1; o >= 0; o--) {
      let i = r[o], n = i.id, a;
      if (
        t.test(n) && (a = parseInt(n, 10), a > e && (e = a)),
          i.type === "table" && i.columns
      ) {
        for (let s = i.columns.length - 1; s >= 0; s--) {
          n = i.columns[s].id,
            t.test(n) && (a = parseInt(n, 10), a > e && (e = a));
        }
      }
    }
    return e + 1;
  }
  function TN(r) {
    if (r.version !== 5) {
      throw new Error("Unexpected version: " + r.version);
    }
    let e = !!(r.graph && r.graph.degreeMode),
      t = r.expressions.list,
      o = -1,
      i = {},
      n = {},
      a = {};
    return {
      version: pJ,
      graph: r.graph,
      expressions: {
        list: t.map((
          l,
        ) => (i[l.id]
          ? (o === -1 && (o = yJ(t)),
            n[o] = l.id,
            l = __dcg_shared_module_exports__["Jc"](l),
            l.id = o + "",
            o += 1)
          : n[l.id] = l.id,
          i[l.id] = true,
          bJ(l, a, n, e))
        ),
      },
    };
  }
  function TM(r) {
    if (r.version !== 6) {
      throw new Error(`Unexpected version: ${r.version}`);
    }
    let e = r.expressions.list.map((t) => {
      if (t.type === "expression" && t.domain) {
        let o = {
          ...t,
          parametricDomain: { min: t.domain.min, max: t.domain.max },
        };
        return delete o.domain, o;
      }
      return t;
    });
    return {
      version: 7,
      randomSeed: r.randomSeed,
      graph: r.graph,
      expressions: { list: e },
    };
  }
  function xJ(r) {
    return r.length === 1 ? `0${r}` : r;
  }
  function rd() {
    let r = new Uint8Array(16);
    if (typeof crypto != "undefined") crypto.getRandomValues(r);
    else if (typeof msCrypto != "undefined") msCrypto.getRandomValues(r);
    else {return __dcg_shared_module_exports__["O"](
        Date.now().toString() + Math.random().toString(),
      );}
    return Array.prototype.slice.call(r).map((t) => xJ(t.toString(16)))
      .join("");
  }
  function DM(r) {
    let e = r.split("_");
    return e.length === 2 && e[1] && e[1].length === 1
      ? e[0] + "_{" + e[1] + "}"
      : r;
  }
  function DN(r) {
    return r = __dcg_shared_module_exports__["Jc"](r),
      !r.rules && (r.assignment || r.expression) &&
      (r.rules = [{
        id: "1",
        assignment: r.assignment || "",
        expression: r.expression || "",
      }]),
      delete r.assignment,
      delete r.expression,
      r;
  }
  function Fx(r) {
    let e =
      /\\operatorname(?:\{stdev\}p|\{stddev\}p|\{stdDev\}P|\{var\}iance)/g;
    return r.replace(e, (t) => {
      switch (t) {
        case "\\operatorname{stdev}p":
          return "\\operatorname{stdevp}";
        case "\\operatorname{stddev}p":
          return "\\operatorname{stddevp}";
        case "\\operatorname{stdDev}P":
          return "\\operatorname{stdDevP}";
        case "\\operatorname{var}iance":
          return "\\operatorname{variance}";
        default:
          return "";
      }
    });
  }
  function wJ(r) {
    return r.columns ? { ...r, columns: r.columns.map(vJ) } : r;
  }
  function vJ(r) {
    let { latex: e, values: t } = r, o = { ...r };
    return e && (o.latex = Fx(e), o.latex = DM(o.latex)),
      t && (o.values = t.map((i) => i ? Fx(i) : "")),
      o;
  }
  function kM(r) {
    if (r.version !== 7) {
      throw new Error(`Unexpected version: ${r.version}`);
    }
    let e = r.expressions.list.map((t) => {
      if (t.type === "image") {
        let o = { ...t, opacity: "" };
        t.hasOwnProperty("stringOpacity")
          ? o.opacity = t.stringOpacity
          : t.hasOwnProperty("opacity")
          ? o.opacity = t.opacity + ""
          : delete o.opacity,
          t.clickableInfo && (o.clickableInfo = DN(t.clickableInfo)),
          delete o.stringOpacity;
        for (let i in t) {
          if (i === "x" || i === "y" || i === "width" || i === "height") {
            let n = t[i];
            n && (o[i] = Fx(n));
          }
        }
        return o;
      } else if (t.type === "expression") {
        let o = { ...t, fillOpacity: "", lineStyle: "SOLID" };
        if (
          t.lineStyle === "SINGLE_PIXEL"
            ? o.lineWidth = "1"
            : t.hasOwnProperty("lineStyle")
            ? o.lineStyle = t.lineStyle
            : delete o.lineStyle,
            o.hasOwnProperty("lineWidth") || (o.lineWidth = ""),
            o.hasOwnProperty("lineOpacity") || (o.lineOpacity = ""),
            o.hasOwnProperty("pointOpacity") || (o.pointOpacity = ""),
            o.hasOwnProperty("pointSize") || (o.pointSize = ""),
            o.hasOwnProperty("colorLatex") || (o.colorLatex = ""),
            typeof t.latex == "string" && (o.latex = Fx(t.latex)),
            t.latex && (o.latex = Fx(t.latex)),
            t.hasOwnProperty("stringFillOpacity")
              ? o.fillOpacity = t.stringFillOpacity
              : t.hasOwnProperty("fillOpacity")
              ? o.fillOpacity = t.fillOpacity + ""
              : delete o.fillOpacity,
            o.slider && t.slider && t.slider.newLoopMode &&
            (o.slider = __dcg_shared_module_exports__["Jc"](o.slider),
              o.slider.loopMode = t.slider.newLoopMode,
              delete o.slider.newLoopMode),
            o.residualVariable &&
            (o.residualVariable = DM(o.residualVariable)),
            o.regressionParameters
        ) {
          o.regressionParameters = {};
          for (let i in t.regressionParameters) {
            let n = DM(i), a = t.regressionParameters[i];
            o.regressionParameters[n] = a;
          }
        }
        return t.clickableInfo && (o.clickableInfo = DN(t.clickableInfo)), o;
      } else if (t.type === "table") return wJ(t);
      return t;
    });
    return {
      version: 8,
      randomSeed: r.randomSeed || rd(),
      graph: r.graph,
      expressions: { list: e },
    };
  }
  function CJ(r, e, t) {
    if (r.verticalLabel) {
      switch (
        delete e.verticalLabel,
          t ? e.labelAngle = "90" : e.labelAngle = "\\frac{\\pi}{2}",
          r.labelOrientation
      ) {
        case "above":
          e.labelOrientation = "right";
          break;
        case "below":
          e.labelOrientation = "left";
          break;
        case "left":
          e.labelOrientation = "above";
          break;
        case "right":
          e.labelOrientation = "below";
          break;
      }
    }
    r.extendedLabelOrientation &&
      (e.labelOrientation = r.extendedLabelOrientation,
        delete e.extendedLabelOrientation);
  }
  function SJ(r, e) {
    if (r.vizProps) {
      switch (r.vizProps.dotplotSize) {
        case "small":
          e.pointSize = "9";
          break;
        case "large":
          e.pointSize = "20";
          break;
      }
    }
    if (r.vizProps) {
      let t = { ...r.vizProps };
      delete t.dotplotSize,
        Object.keys(t).length ? e.vizProps = t : delete e.vizProps;
    }
  }
  function _M(r) {
    return r.filter(({ assignment: e, expression: t }) => !!e && !!t);
  }
  function IM(r) {
    return r.map(({ assignment: e, expression: t }) => `${e}\\to ${t}`)
      .join(",") || "";
  }
  function AM(r) {
    let e = JSON.stringify(r), t = /_(\d)|_\{(\d+)\}/g, o, i = {};
    for (; (o = t.exec(e)) !== null;) {
      let n = o[1] !== void 0 ? o[1] : o[2];
      i[n] = true;
    }
    return i;
  }
  function MM(r, e) {
    for (let t = e + 1;; t++) if (!r[t]) return t;
  }
  function kN(r) {
    let e = JSON.stringify(r), t = /"(\d+)"/g, o, i = {};
    for (; (o = t.exec(e)) !== null;) {
      let n = o[1] !== void 0 ? o[1] : o[2];
      i[n] = true;
    }
    return i;
  }
  function _N(r, e) {
    for (let t = e + 1;; t++) if (!r[t]) return t;
  }
  function EJ(r) {
    if (/^\d+$/.test(r)) {
      let e = parseInt(r, 10);
      return e === 0 ? "\\infty" : "" + Math.round(1e3 / e);
    } else return `\\frac{1000}{${r}}`;
  }
  function TJ(r, e) {
    let t = { handlerLatex: r, playing: true, open: true };
    return e !== void 0 && (t.minStepLatex = EJ(e)), t;
  }
  function GM(r) {
    if (r.version !== 8) {
      throw new Error(`Unexpected version: ${r.version}`);
    }
    let e = false;
    r.graph && r.graph.degreeMode && (e = true);
    let t = r.expressions.ticker || of, o = 0, i, n = 0, a, s = [];
    for (let l of r.expressions.list) {
      switch (l.type) {
        case "expression": {
          let c = { ...l };
          CJ(l, c, e), SJ(l, c);
          let d;
          if (l.clickableInfo && l.clickableInfo.rules) {
            let { rules: p, ...h } = l.clickableInfo,
              u = h,
              f = _M(p),
              y = IM(f);
            if (f.length > 1) {
              i || (i = AM(r)), o = MM(i, o), a || (a = kN(r)), n = _N(a, n);
              let C = `A_{${o}}`;
              u.latex = C,
                d = {
                  type: "expression",
                  id: "" + n,
                  latex: `${C}=${y}`,
                },
                l.folderId !== void 0 && (d.folderId = l.folderId);
            } else u.latex = y;
            c.clickableInfo = u;
          }
          c.clickableInfo && c.clickableInfo.enabled && c.hidden &&
          (c.clickableInfo.enabled = false),
            s.push(c),
            d && s.push(d);
          break;
        }
        case "image": {
          if (l.clickableInfo && l.clickableInfo.rules) {
            let c = { ...l },
              { rules: d, ...p } = l.clickableInfo,
              h = p,
              u = _M(d),
              f = IM(u),
              y;
            if (u.length > 1) {
              i || (i = AM(r)), o = MM(i, o), a || (a = kN(r)), n = _N(a, n);
              let C = `A_{${o}}`;
              h.latex = C,
                y = {
                  type: "expression",
                  id: "" + n,
                  latex: `${C}=${f}`,
                },
                l.folderId !== void 0 && (y.folderId = l.folderId);
            } else h.latex = f;
            c.clickableInfo = h, s.push(c), y && s.push(y);
          } else s.push(l);
          break;
        }
        case "simulation": {
          let c;
          if (l.clickableInfo && l.clickableInfo.rules) {
            let p = _M(l.clickableInfo.rules);
            c = IM(p);
          } else c = "";
          if (l.isPlaying && c !== "") {
            i || (i = AM(r)), o = MM(i, o);
            let p = `A_{${o}}`;
            c = `${p}=${c}`, t = TJ(p, l.fps);
          }
          let d = { type: "expression", id: l.id, latex: c };
          l.folderId !== void 0 && (d.folderId = l.folderId), s.push(d);
          break;
        }
        default:
          s.push(l);
          break;
      }
    }
    return {
      version: 9,
      randomSeed: r.randomSeed || rd(),
      graph: r.graph,
      expressions: { list: s, ticker: t },
    };
  }
  function DJ(r) {
    switch (r.type) {
      case "TokenNode":
      case "Letter":
        return true;
      case "OperatorName": {
        for (let e of r.arg.args) if (e.type !== "Letter") return false;
        return true;
      }
      case "Cmd":
        return __dcg_shared_module_exports__["Kc"](r.val);
      default:
        return false;
    }
  }
  function LM(r) {
    let e;
    try {
      e = __dcg_shared_module_exports__["Vc"](r);
    } catch (i) {
      return;
    }
    if (e.args.length === 0 || e.args.length > 2) return;
    let t = e.args[0];
    if (!DJ(t)) return;
    let o;
    if (e.args.length > 1) {
      let i = e.args[1];
      if (i.type !== "SupSub") return;
      let { sup: n, sub: a } = i;
      if (n !== void 0 || a === void 0) return;
      for (let s of a.args) {
        if (s.type !== "Letter" && s.type !== "Digit") return;
      }
      o = a;
    }
    return { base: t, subscript: o };
  }
  function ya(r) {
    return LM(r) !== void 0;
  }
  function GN(r) {
    let e = __dcg_shared_module_exports__["Vc"](r),
      t = __dcg_shared_module_exports__["Rc"](e);
    switch (t.type) {
      case "Letter":
        return t.val;
      case "Cmd":
        return t.val;
      default:
        return;
    }
  }
  function IN(r) {
    return r.replace(/^(\\? )+|(\\? )+$/g, "");
  }
  function Nx(r) {
    let e = r.indexOf("=");
    if (e === -1) return;
    let t = IN(r.slice(0, e));
    if (ya(t)) return t;
    try {
      let o = __dcg_shared_module_exports__["Vc"](`${t}=0`),
        i = __dcg_shared_module_exports__["Rc"](o);
      if (
        i.type === "Comparator" && i.symbol === "=" &&
        __dcg_shared_module_exports__["Oc"](i.args[0])
      ) {
        let n = r.indexOf("\\left(");
        if (n === -1 && (n = r.indexOf("(")), n === -1) return;
        let a = IN(r.slice(0, n));
        if (ya(a)) return a;
      }
    } catch (o) {}
  }
  function ZC(r, e) {
    let t = LM(e);
    if (t === void 0) return [];
    let o = [], i;
    try {
      i = __dcg_shared_module_exports__["Vc"](r);
    } catch (n) {
      return o;
    }
    return sf(i, t, o, { wrapInBraces: false }), o;
  }
  function Il(r, e) {
    return ZC(r, e).length !== 0;
  }
  function eS(r, e, t) {
    return LM(t) === void 0 ? r : PM_replaceIdentifierWithLatex(r, e, t);
  }
  function PM_replaceIdentifierWithLatex(r, e, t) {
    let o = ZC(r, e);
    if (o.length === 0) return r;
    let i = "", n = 0;
    for (let a of o) {
      if (
        i += r.slice(n, a.base.start),
          /[a-z]$/i.test(i) && e[0] == "\\" && t[0] !== "\\" &&
          (i += " "),
          a.wrapInBraces && (i += "{"),
          i += t,
          n = a.base.end,
          a.subscript
      ) {
        let s = 0, l = 0;
        for (let c = a.subscript.start; c >= 0; c--) {
          if (r[c] === "{" && (s += 1), r[c] === "_") {
            l = c;
            break;
          }
        }
        i += r.slice(n, l), n = a.subscript.end;
        for (let c = a.subscript.end; c < r.length && !(s <= 0); c++) {
          r[c] === "}" && (s -= 1, n = c + 1);
        }
      }
      a.wrapInBraces && (i += "}");
    }
    return i += r.slice(n, r.length), i;
  }
  function AN(r, e) {
    if (r.args.length !== e.args.length) return false;
    for (let t = 0; t < r.args.length; t++) {
      let o = r.args[t], i = e.args[t];
      if (
        !(o.type === "Letter" && i.type === "Letter" &&
          o.val === i.val) &&
        !(o.type === "Digit" && i.type === "Digit" && o.val === i.val)
      ) return false;
    }
    return true;
  }
  function kJ(r, e, t) {
    let o = r.arg.args, i = e.arg.args;
    if (o.length === i.length) {
      for (let n = 0; n < o.length; n++) {
        let a = o[n], s = i[n];
        if (a.type !== "Digit" || a.type !== s.type || a.val !== s.val) {
          return;
        }
      }
      t.push({ base: e.span, wrapInBraces: false });
    }
  }
  function sf(r, e, t, { wrapInBraces: o }) {
    let { base: i, subscript: n } = e;
    for (let a = 0; a < r.args.length; a++) {
      let s = a - 1 >= 0 ? r.args[a - 1] : void 0, l = r.args[a], c;
      if (a + 1 < r.args.length) {
        let d = r.args[a + 1];
        d.type === "SupSub" && d.sub !== void 0 && (c = d.sub);
      }
      switch (l.type) {
        case "Letter":
        case "Cmd":
          if (i.type !== l.type || i.val !== l.val) break;
          if (n && c && AN(n, c)) {
            t.push({ base: l.span, subscript: c.span, wrapInBraces: o });
          } else if (!n && !c) {
            if (
              (s == null ? void 0 : s.type) === "Symbol" &&
              s.val === "." && l.type === "Letter" &&
              (i.val === "x" || i.val === "y" || i.val === "z")
            ) break;
            t.push({ base: l.span, wrapInBraces: o });
          }
          break;
        case "OperatorName": {
          if (
            i.type !== l.type || i.arg.args.length !== l.arg.args.length
          ) break;
          let d = true;
          for (let p = 0; p < i.arg.args.length; p++) {
            let h = i.arg.args[p], u = l.arg.args[p];
            if (
              h.type !== "Letter" || u.type !== "Letter" ||
              h.val !== u.val
            ) {
              d = false;
              break;
            }
          }
          if (!d) break;
          n && c && AN(n, c)
            ? t.push({ base: l.span, subscript: c.span, wrapInBraces: o })
            : !n && !c && t.push({ base: l.span, wrapInBraces: o });
          break;
        }
        case "Digit":
        case "Symbol":
        case "EscapedSymbol":
          break;
        case "LeftRight":
        case "Sqrt":
          sf(l.arg, e, t, { wrapInBraces: false });
          break;
        case "Frac":
          sf(l.num, e, t, { wrapInBraces: false }),
            sf(l.den, e, t, { wrapInBraces: false });
          break;
        case "SupSub":
          (s == null ? void 0 : s.type) === "Cmd" &&
          __dcg_shared_module_exports__["Mc"](s.val) && l.sub &&
          sf(l.sub, e, t, { wrapInBraces: !MN(l.sub, "_") }),
            l.sup && sf(l.sup, e, t, { wrapInBraces: !MN(l.sup, "^") });
          break;
        case "TokenNode":
          {
            if (i.type !== l.type) break;
            kJ(i, l, t);
          }
          break;
        default: {
          let d = l;
          throw new Error("Unexpected token type: " + d.type);
        }
      }
    }
  }
  function MN(r, e) {
    for (let t = r.span.start; t >= 0; t--) {
      let o = r.span.input[t];
      if (o === e) break;
      if (o === "{") return true;
    }
    return false;
  }
  function LN(r) {
    r.clickableInfo &&
      (r.description === void 0 &&
        r.clickableInfo.description !== void 0 &&
        (r.description = r.clickableInfo.description),
        delete r.clickableInfo.description,
        Object.keys(r.clickableInfo).length === 0 &&
        delete r.clickableInfo);
  }
  function _J(r) {
    switch (r.labelSize) {
      case "small":
        r.labelSize = "0.85";
        break;
      case "medium":
        r.labelSize = "1";
        break;
      case "large":
        r.labelSize = "1.35";
        break;
      default:
        break;
    }
  }
  function IJ(r) {
    let e = 0, t = /^[0-9]+$/;
    for (let o = r.length - 1; o >= 0; o--) {
      let i = r[o], n = i.id;
      if (t.test(n)) {
        let a = parseInt(n, 10);
        a > e && (e = a);
      }
      if (i.type === "table" && i.columns) {
        for (let a = i.columns.length - 1; a >= 0; a--) {
          if (n = i.columns[a].id, !!n && t.test(n)) {
            let s = parseInt(n, 10);
            s > e && (e = s);
          }
        }
      }
    }
    return e;
  }
  function VM(r) {
    if (r.version !== 9) {
      throw new Error(`Unexpected version: ${r.version}`);
    }
    let e = [], t = {}, o = IJ(r.expressions.list);
    for (let n of r.expressions.list) {
      switch (n.type) {
        case "expression": {
          let l = { ...n };
          LN(l), _J(l), e.push(l);
          break;
        }
        case "image": {
          let l = { ...n };
          LN(l);
          let c = l.description;
          (c === void 0 || c === "") && l.draggable &&
          l.center !== void 0 && l.center !== "" &&
          (t[l.center] === void 0 ? t[l.center] = [l] : t[l.center].push(l)),
            e.push(l);
          break;
        }
        case "table":
          let a = { ...n };
          if (!a.columns || !ya(a.columns[0].latex)) {
            e.push(a);
            break;
          }
          let s = a.columns[0].latex;
          for (let l = 1; l < a.columns.length; l++) {
            let c = a.columns[l];
            if (!c.lines || !Il(c.latex, s)) continue;
            delete c.lines, o++;
            let d = {
              type: "expression",
              latex: "y=" + eS(c.latex, s, "x"),
              id: `${o}`,
            };
            c.color && (d.color = c.color),
              c.lineStyle && (d.lineStyle = c.lineStyle),
              c.lineWidth && (d.lineWidth = c.lineWidth),
              c.lineOpacity && (d.lineOpacity = c.lineOpacity),
              e.push(d);
          }
          e.push(a);
          break;
        default:
          e.push(n);
          break;
      }
    }
    for (let n of e) {
      if (
        n.type !== "expression" || n.latex === void 0 || n.latex === "" ||
        n.latex.indexOf("=") === -1 || n.dragMode === void 0 ||
        n.dragMode === "NONE" || n.label === void 0 || n.label === ""
      ) continue;
      let a = n.latex.slice(0, n.latex.indexOf("=")), s = t[a];
      if (s !== void 0) { for (let l of s) l.description = n.label; }
    }
    return {
      ...r,
      version: 10,
      expressions: { ...r.expressions, list: e },
    };
  }
  function AJ(r) {
    let e =
      /[ \\]*=[ \\]*\\operatorname\{(dilation|reflection|rotation|translation)\}\\left\(/g;
    return r.type !== "expression" || !r.latex ||
      (r.latex = r.latex.replace(e, (t, o) => {
        switch (o) {
          case "dilation":
            return "\\left(x\\right)=\\operatorname{dilate}\\left(x,";
          case "rotation":
            return "\\left(x\\right)=\\operatorname{rotate}\\left(x,";
          case "reflection":
            return "\\left(x\\right)=\\operatorname{reflect}\\left(x,";
          case "translation":
            return "\\left(x\\right)=\\operatorname{translate}\\left(x,";
          default:
            return "";
        }
      })),
      r;
  }
  function MJ(r, e) {
    var t;
    if (
      r.type === "image" && r.folderId && !r.draggable &&
      !((t = r.clickableInfo) != null && t.enabled) &&
      e.has(r.folderId) && r.disableGraphInteractions !== false
    ) {
      let o = { ...r };
      return o.disableGraphInteractions = true, o;
    } else return r;
  }
  function GJ(r) {
    var a;
    if (r.type !== "expression") return r;
    let e = { ...r },
      t = (a = (r.latex || "").split("=")[0]) == null ? void 0 : a.trim(),
      o = r.parametricDomain3Du,
      i = r.parametricDomain3Dv,
      n = r.parametricDomain;
    return t === "r" ||
      (t === "z"
        ? (o && (e.parametricDomain3Dr = { ...o }),
          i && (e.polarDomain = { ...i }))
        : t === "\\rho"
        ? (o && (e.polarDomain = { ...o }),
          i && (e.parametricDomain3Dphi = { ...i }))
        : r.polarDomain ||
          n &&
            (e.parametricDomain3Du = { ...n },
              e.parametricDomain3Dv = { ...n })),
      e;
  }
  function OM(r) {
    if (r.version !== 10) {
      throw new Error(`Unexpected version: ${r.version}`);
    }
    let e = { ...r.graph };
    delete e.projectorMode;
    let t = { ...r.expressions }, o = [], i = new Set();
    for (let n of t.list) {
      n.type === "folder" && n.collapsed && i.add(n.id);
    }
    for (let n of t.list) {
      switch (n.type) {
        case "expression": {
          if (
            (e == null ? void 0 : e.product) === "geometry-calculator"
          ) {
            let a = { ...n };
            AJ(a), o.push(a);
          } else if ((e == null ? void 0 : e.product) === "graphing-3d") {
            let a = GJ(n);
            o.push(a);
          } else o.push(n);
          break;
        }
        case "image": {
          o.push(MJ(n, i));
          break;
        }
        default:
          o.push(n);
      }
    }
    return t.list = o, { ...r, version: 11, graph: e, expressions: t };
  }
  function RM(r) {
    var i, n;
    if (r.version !== 11) {
      throw new Error(`Unexpected version: ${r.version}`);
    }
    let e = (i = r.includeFunctionParametersInRandomSeed) != null ? i : false,
      t = { ...r.expressions },
      o = [];
    for (let a of t.list) {
      switch (a.type) {
        case "expression": {
          if (
            ((n = r.graph) == null ? void 0 : n.product) ===
              "graphing-3d" && !r.doNotMigrate3dLineWidthZero
          ) {
            let s = LJ(a);
            o.push(s);
          } else o.push(a);
          break;
        }
        default:
          o.push(a);
      }
    }
    return t.list = o, {
      ...r,
      expressions: t,
      includeFunctionParametersInRandomSeed: e,
      version: 12,
    };
  }
  function LJ(r) {
    return r.type !== "expression" || r.lineWidth !== "0"
      ? r
      : { ...r, lineWidth: "0.1" };
  }
  function PN(r) {
    var o, i;
    let e = (o = r.includeFunctionParametersInRandomSeed) != null ? o : true,
      t = ((i = r.graph) == null ? void 0 : i.product) === "graphing-3d"
        ? {
          ...r,
          includeFunctionParametersInRandomSeed: e,
          doNotMigrate3dLineWidthZero: true,
          version: 11,
        }
        : { ...r, includeFunctionParametersInRandomSeed: e, version: 11 };
    return t.includeFunctionParametersInRandomSeed === false &&
      delete t.includeFunctionParametersInRandomSeed,
      t;
  }
  var FM = [fN, bN, xN, wN, CN, SN, TN, TM, kM, GM, VM, OM, RM];
  var _l = 12;
  function dc_migrateToLatest(r) {
    if (r.version > _l) {
      return typeof console != "undefined" && console.warn &&
        console.warn(
          "Loading saved state with version " + r.version +
            " but last known version is " + _l +
            ". States saved in a newer version of the calculator may not load correctly in an older version of the calculator.",
        ),
        XC(r);
    }
    if (r.hasOwnProperty("version") && !FM[r.version]) {
      return typeof console != "undefined" && console.warn &&
        console.warn(
          "State has invalid version " + r.version +
            ". If a version is present, it should be a non-negative integer less than or equal to " +
            _l + ".",
        ),
        XC(r);
    }
    for (r.hasOwnProperty("version") || (r = FM[0](r)); r.version < _l;) {
      r = FM[r.version + 1](r);
    }
    return XC(r);
  }
  function PJ(r) {
    return PN(r);
  }
  function VN(r) {
    return PJ(dc_migrateToLatest(r));
  }
  function ON_CLCalculator(r) {
    let e = dc_migrateToLatest(r),
      t = {},
      o = e.graph.degreeMode,
      i = e.randomSeed,
      n = e.graph.product === "geometry-calculator"
        ? "geometry"
        : e.graph.product === "graphing-3d"
        ? "graphing_3d"
        : "graphing";
    function a(s) {
      switch (s.type) {
        case void 0:
        case "expression":
          {
            let c = __dcg_shared_module_exports__["Hd"](
              __dcg_shared_module_exports__["Dd"](s, {
                is3d: false,
                defaultLogModeRegressions: false,
              }),
            );
            t[c.id] = c;
          }
          break;
        case "table":
          {
            let c = $C(WC(s));
            t[c.id] = c;
          }
          break;
        case "image": {
          let c = KC(HC(s));
          t[c.id] = c;
          break;
        }
        case "folder":
        case "text":
          break;
        default:
          return s;
      }
    }
    for (let s of e.expressions.list) a(s);
    if (e.version >= 10 && e.expressions.ticker) {
      let s = "dcg_ticker_guid_internal",
        l = { ...YC(e.expressions.ticker), id: s };
      t[s] = jC(l);
    }
    return {
      setExpression(s) {
        a(s);
      },
      getChangeSet() {
        return {
          statements: t,
          isCompleteState: true,
          degreeMode: o,
          globalRandomSeed: i,
          evaluationMode: n,
        };
      },
    };
  }
  function FN_applyDiff(r, e) {
    let t = __dcg_shared_module_exports__["Jc"](r);
    return tS(t, e);
  }
  function tS(r, e) {
    for (let t of __dcg_shared_module_exports__["B"](e)) {
      let o = e[t];
      OJ(o)
        ? r[t] = o.s
        : RJ(o)
        ? delete r[t]
        : FJ(o)
        ? r[t] = VJ(r[t], o.l)
        : NJ(o) && (r[t] = tS(r[t], o.e));
    }
    return r;
  }
  function VJ(r, e) {
    let t = [];
    for (let i = 0; i < r.length; i++) {
      let n = e[i];
      n && n.a && t.push(...RN(r, n.a)),
        n && n.e ? t.push(tS(r[i], n.e)) : (!n || !n.d) && t.push(r[i]);
    }
    let o = e[r.length];
    return o && o.a && t.push(...RN(r, o.a)), t;
  }
  function RN(r, e) {
    let t = [];
    for (let o of e) {
      if (BJ(o)) t.push(o.s);
      else if (UJ(o)) {
        let i = r[o.m.f];
        o.m.e ? t.push(tS(i, o.m.e)) : t.push(i);
      }
    }
    return t;
  }
  function OJ(r) {
    return r.hasOwnProperty("s");
  }
  function RJ(r) {
    return r.hasOwnProperty("d");
  }
  function FJ(r) {
    return r.hasOwnProperty("l");
  }
  function NJ(r) {
    return r.hasOwnProperty("e");
  }
  function BJ(r) {
    return r.hasOwnProperty("s");
  }
  function UJ(r) {
    return r.hasOwnProperty("m");
  }
  function NN(r) {
    let e = r.length, t = new Array(e), o = new Array(e + 1), i = 0;
    for (let s = 0; s < e; s++) {
      let l;
      if (r[o[i]] < r[s]) l = i + 1;
      else {
        let c = 1, d = i - 1;
        for (; c <= d;) {
          let p = Math.ceil((c + d) / 2);
          r[o[p]] < r[s] ? c = p + 1 : d = p - 1;
        }
        l = c;
      }
      t[s] = o[l - 1], o[l] = s, l > i && (i = l);
    }
    let n = new Array(i), a = o[i];
    for (let s = i - 1; s >= 0; s--) n[s] = r[a], a = t[a];
    return n;
  }
  function UN_calculateDiff(r, e) {
    return rS(r, e, 0);
  }
  function rS(r, e, t) {
    let o = {};
    for (let i in r) {
      if (!r.hasOwnProperty(i)) continue;
      if (!e.hasOwnProperty(i)) {
        o[i] = { d: 1 };
        continue;
      }
      let n = r[i], a = e[i], s = zJ(n, a, t, i);
      s && (o[i] = s);
    }
    for (let i in e) {
      e.hasOwnProperty(i) && !r.hasOwnProperty(i) && (o[i] = { s: e[i] });
    }
    return o;
  }
  function zJ(r, e, t, o) {
    if (
      __dcg_shared_module_exports__["G"](r) &&
      __dcg_shared_module_exports__["G"](e)
    ) {
      if (t === 1 && o === "list" || t === 2 && o === "columns") {
        return HJ(r, e);
      }
      if (!__dcg_shared_module_exports__["E"](r, e)) return { s: e };
    } else if (
      __dcg_shared_module_exports__["H"](r) &&
      __dcg_shared_module_exports__["H"](e)
    ) {
      let i = rS(r, e, qJ(t, o));
      if (!__dcg_shared_module_exports__["F"](i)) return { e: i };
    } else if (!__dcg_shared_module_exports__["E"](r, e)) return { s: e };
  }
  function qJ(r, e) {
    return r === 0 && e === "expressions" ? 1 : 3;
  }
  function HJ(r, e) {
    let t = {}, o = {};
    for (let s = 0; s < r.length; s++) {
      if (o[r[s].id] !== void 0) return { s: e };
      o[r[s].id] = s;
    }
    let i = {};
    for (let s = 0; s < e.length; s++) {
      if (i[e[s].id] !== void 0) return { s: e };
      i[e[s].id] = s;
    }
    let n = KJ(r, e, o), a = 0;
    for (let s = 0; s < r.length; s++) {
      let l = r[s];
      if (!n[l.id]) t[s] = { d: 1 };
      else {
        let c = i[l.id], d = e[c], p = {};
        if (
          a !== c && (p.a = e.slice(a, c).map((h) => BN(r, o, h))),
            !__dcg_shared_module_exports__["E"](l, d)
        ) {
          let h = l.type === "table" && d.type === "table";
          p.e = rS(l, d, h ? 2 : 3);
        }
        __dcg_shared_module_exports__["F"](p) || (t[s] = p), a = c + 1;
      }
    }
    if (
      a < e.length && (t[r.length] = {
        a: e.slice(a, e.length).map((s) => BN(r, o, s)),
      }), !__dcg_shared_module_exports__["F"](t)
    ) return { l: t };
  }
  function BN(r, e, t) {
    if (e[t.id]) {
      let o = r[e[t.id]], i = { f: e[t.id] };
      return __dcg_shared_module_exports__["E"](o, t) ||
        (i.e = rS(o, t, 3)),
        { m: i };
    }
    return { s: t };
  }
  function KJ(r, e, t) {
    let o = {},
      i = e.filter((a) => t[a.id] !== void 0).map((a) => t[a.id]),
      n = NN(i);
    for (let a of n) o[r[a].id] = true;
    return o;
  }
  function zN(r) {
    return r.location === "expression" || r.location === "object"
      ? `${r.location}:${r.id}:${r.path}`
      : `${r.location}:${r.path}`;
  }
  function NM(r) {
    let e = () => new Error(`Invalid key: ${r}`),
      t = r.split(":"),
      o = t[0];
    if (!o || o != "expression" && o != "settings" && o != "object") {
      throw e();
    }
    if (o == "settings") {
      if (t.length != 2) throw e();
      return { location: o, path: t[1] };
    }
    if (t.length != 3) throw e();
    return { location: o, id: t[1], path: t[2] };
  }
  function oS(r, e, t) {
    if (!r) return;
    let o = e.split("."), i = r;
    for (let n = 0; n < o.length; n++) {
      let a = o[n];
      if (!i[a]) break;
      n == o.length - 1 && typeof i[a] == "string" ? i[a] = t : i = i[a];
    }
  }
  function BM(r, e) {
    return (t, o, i, n) => {
      if (t) {
        let a = zN({ ...e, path: o });
        r[a] = { value: t, type: i, context: n };
      }
    };
  }
  function WJ(r) {
    var o, i;
    let e = {}, t = BM(e, { location: "expression", id: r.id });
    switch (r.type) {
      case "expression":
        t(
          r.label,
          "label",
          "interpolated-string",
          "expression-list-expression-label",
        ),
          t(
            r.description,
            "description",
            "string",
            "expression-list-expression-clickable-description",
          );
        break;
      case "image":
        t(r.image_url, "image_url", "image", "expression-list-image-url"),
          t(
            r.description,
            "description",
            "string",
            "expression-list-image-clickable-description",
          ),
          t(
            (o = r.clickableInfo) == null ? void 0 : o.hoveredImage,
            "clickableInfo.hoveredImage",
            "image",
            "expression-list-image-clickable-hovered",
          ),
          t(
            (i = r.clickableInfo) == null ? void 0 : i.depressedImage,
            "clickableInfo.depressedImage",
            "image",
            "expression-list-image-clickable-depressed",
          );
        break;
      case "text":
        t(r.text, "text", "string", "expression-list-note-text");
        break;
      case "folder":
        t(r.title, "title", "string", "expression-list-folder-title");
        break;
    }
    return e;
  }
  function $J(r) {
    let e = {}, t = BM(e, { location: "settings" });
    return t(
      r.graph.xAxisLabel,
      "xAxisLabel",
      "string",
      "settings-xaxis-label",
    ),
      t(
        r.graph.yAxisLabel,
        "yAxisLabel",
        "string",
        "settings-yaxis-label",
      ),
      e;
  }
  function jJ(r) {
    let e = {}, t = BM(e, { location: "object", id: r.id });
    return t(r.label, "label", "string", "geometry-object-label"),
      r.type === "image" &&
      t(r.url, "url", "image", "geometry-object-image-url"),
      e;
  }
  function qN_extractLocalizationMap(r) {
    let e = {};
    if (r.type == "graph") {
      let t = r.graphState.expressions.list;
      for (let i of t) {
        let n = WJ(i);
        for (let a in n) e[a] = n[a];
      }
      let o = $J(r.graphState);
      for (let i in o) e[i] = o[i];
    } else {
      let t = r.geometryState.objects;
      for (let o in t) {
        let i = jJ(t[o]);
        for (let n in i) e[n] = i[n];
      }
    }
    return e;
  }
  function HN_applyLocalizationMap(r, e, t) {
    var i;
    let o = __dcg_shared_module_exports__["Jc"](r);
    if (t === "graph") {
      let n = {},
        a = (i = o.expressions) == null ? void 0 : i.list,
        s = Array.isArray(a) ? a : [];
      for (let l of s) n[l.id] = l;
      for (let l in e) {
        let c = NM(l);
        c.location == "expression"
          ? oS(n[c.id], c.path, e[l].value)
          : oS(o.graph, c.path, e[l].value);
      }
    } else if (o.objects) {
      for (let n in e) {
        let a = NM(n);
        a.location == "object" && oS(o.objects[a.id], a.path, e[n].value);
      }
    }
    return o;
  }
  function iS(r, e) {
    switch (r.type) {
      case "Mul":
      case "DotMul":
      case "CrossMul":
      case "Div":
      case "Prime":
      case "Call":
      case "ImplicitCall":
      case "Dot":
      case "Pipes":
      case "Sqrt":
      case "Nthroot":
      case "Frac":
      case "Derivative":
      case "Integral":
      case "EmptyIntegral":
      case "Sum":
      case "Product":
      case "Piecewise":
      case "Paren":
      case "Juxt":
      case "Superscript":
      case "Bang":
      case "Index":
      case "Comparator":
      case "ComparatorChain":
      case "Tilde":
      case "Pos":
      case "Neg":
      case "Add":
      case "Sub":
      case "List":
      case "Seq":
      case "Colon":
      case "Ellipsis":
      case "PercentOf":
      case "RightArrow":
      case "For":
      case "With": {
        let o = 0;
        for (let i of r.args) o += iS(i, e);
        return o;
      }
      case "Decimal":
        return e === void 0 || parseFloat(r.val) === e ? 1 : 0;
      case "MixedNumber": {
        if (e === void 0) return 3;
        let o = 0;
        return parseFloat(r.whole) === e && (o += 1),
          parseFloat(r.num) === e && (o += 1),
          parseFloat(r.den) === e && (o += 1),
          o;
      }
      case "Letter":
      case "EmptyPiecewise":
      case "Cmd":
      case "EmptyRangeEnd":
        return 0;
      case "Subscript":
        return iS(r.args[0], e);
      default:
        throw `Unexpected surface node ${r.type}.`;
    }
  }
  var YJ = {
      version: _l,
      randomSeed: "",
      graph: {
        viewport: { xmin: -10, ymin: -13.25, xmax: 10, ymax: 13.25 },
      },
      expressions: { list: [{ id: "1", type: "expression" }] },
    },
    Bx = YJ;
  function XJ(r) {
    return { ...r, version: "0" };
  }
  var KN = XJ;
  var JJ = { centerX: 0, centerY: 0, size: 15 },
    QJ = { scale: 1, unit: "", visible: false, showLegend: false };
  function ZJ(r) {
    let e = r.objects || {}, t = __dcg_shared_module_exports__["Jc"](e);
    for (let o in t) {
      let i = t[o];
      i.label && (i.showLabel = true);
    }
    return {
      version: "1",
      objects: t,
      viewport: r.viewport || JJ,
      customTools: r.customTools || {},
      grid: r.grid || QJ,
    };
  }
  var WN = ZJ;
  function eQ(r) {
    return (r.type === "point" || r.type === "glider") && !r.draggable;
  }
  function tQ(r) {
    let e = r.objects || {},
      t = __dcg_shared_module_exports__["Jc"](e),
      o = __dcg_shared_module_exports__["Jc"](r.grid);
    for (let i in t) {
      let n = t[i];
      eQ(n) && (n.draggable = true),
        n.type === "angle" && n.showLabel && !n.label &&
        (n.label = "{angle}"),
        n.type === "segment" && n.showLabel && !n.label &&
        (n.label = "{length}");
    }
    return o.unit = "", o.scale = 1, {
      version: "2",
      objects: t,
      viewport: r.viewport,
      customTools: r.customTools || {},
      grid: o,
    };
  }
  var $N = tQ;
  function UM(r) {
    return r && (r.type === "circle" || r.type === "compass");
  }
  function rQ(r) {
    let e = __dcg_shared_module_exports__["Jc"](r.objects || {});
    for (let t in e) {
      let o = e[t];
      if (o.type === "point") o.y = -o.y;
      else if (o.type === "glider") {
        let i = e[o.parents.host];
        UM(i) && (o.t = -o.t);
      } else if (o.type === "intersection") {
        let i = e[o.parents.host1], n = e[o.parents.host2];
        UM(i) && UM(n) && (o.negRoot = !o.negRoot);
      }
    }
    return {
      version: "3",
      objects: e,
      viewport: r.viewport,
      customTools: r.customTools || {},
      graphSettings: {
        showGrid: !!(r.grid || {}).visible,
        showAxes: false,
        showAxisNumbers: false,
      },
    };
  }
  var jN = rQ;
  function oQ(r) {
    let e = __dcg_shared_module_exports__["Jc"](r.objects || {});
    for (let t in e) {
      let o = e[t];
      o.draggable === false && (o.locked = true), delete o.draggable;
    }
    return { ...r, version: "4", objects: e };
  }
  var YN = oQ;
  var nS = [KN, WN, $N, jN, YN], iQ = "4";
  function zM(r) {
    let e = parseInt(iQ, 10), t = parseInt(r.version || "0", 10);
    for (
      t > e && typeof console != "undefined" && console.warn &&
      console.warn(
        `Loading saved state with version ${t}, but last known version is ${e}. States saved in a newer version of the geometry tool may not load correctly in older versions of the tool.`,
      ),
        nS[t] ||
        typeof console != "undefined" && console.warn &&
          console.warn(
            `State has invalid version: ${t}. If a version is present, it should be a non-negative integer less than or equal to ${e}.`,
          ),
        t === 0 && (r = nS[0](r));
      t < e;
    ) t += 1, nS[t] && (r = nS[t](r));
    return r;
  }
  var nQ = false;
  function pg(r, e) {
    let t = e[r];
    return t.type === "transformed-object" ? pg(t.parents.object, e) : t.type;
  }
  function XN(r) {
    switch (r) {
      case "circle":
      case "compass":
      case "arc":
        return true;
    }
    return false;
  }
  function aQ(r, e, t) {
    let o = pg(e, t);
    if (o === "circle" || o === "compass") {
      let i = r / (2 * Math.PI);
      return i < 0 ? i + 1 : i;
    }
    return r;
  }
  function JN(r) {
    switch (r) {
      case "scaled-rotation":
      case "vector":
        return true;
    }
    return false;
  }
  function sQ(r) {
    switch (r) {
      case "point":
      case "midpoint":
      case "glider":
      case "intersection":
      case "polygon":
        return "P";
      case "line":
      case "segment":
      case "ray":
      case "vector":
      case "parallel":
      case "perpendicular":
        return "L";
      case "circle":
      case "compass":
        return "C";
      case "arc":
      case "angle":
        return "A";
      case "image":
        return "I";
      case "dilation":
      case "rotation":
      case "translation":
      case "reflection":
      case "scaled-rotation":
        return "T";
      case "transformed-object":
        return "T";
      default:
        return r;
    }
  }
  function ug_migrateGeoStateToCalcState(r) {
    let e = !nQ,
      t = zM(r),
      o = {},
      i = {},
      n = (w) => {
        if (i.hasOwnProperty(w)) return i[w];
        let S = pg(w, t.objects);
        if (e && !JN(S)) {
          let P = o.token || 1;
          o.token = P + 1;
          let O = "\\token{" + P + "}";
          return i[w] = O, O;
        }
        let k = sQ(S), _ = o[k] || 1;
        o[k] = _ + 1;
        let A = k + "_{" + _ + "}";
        return i[w] = A, A;
      };
    function a(w) {
      let S = o[w] || 1;
      return o[w] = S + 1, w + "_{" + S + "}";
    }
    let s = (w, S, k) =>
        n(w) + "=\\operatorname{" + S + "}\\left(" + k.map(n).join(",") +
        "\\right)",
      l = (w) =>
        `\\operatorname{segment}\\left(${w}.\\operatorname{start},${w}.\\operatorname{end}\\right)`,
      { centerX: c, centerY: d, size: p } = t.viewport;
    p *= 1.25;
    let h = 1,
      u = p / (1 + h),
      f = u * h,
      y = {
        version: 11,
        randomSeed: "",
        expressions: { list: [] },
        graph: {
          product: "geometry-calculator",
          viewport: {
            xmin: c - u,
            xmax: c + u,
            ymin: d - f,
            ymax: d + f,
          },
          showGrid: false,
          showXAxis: false,
          showYAxis: false,
          squareAxes: true,
          degreeMode: true,
        },
      };
    t.graphSettings.showGrid &&
      (y.graph.showGrid = true,
        y.graph.xAxisMinorSubdivisions = 1,
        y.graph.yAxisMinorSubdivisions = 1,
        y.graph.xAxisStep = 1,
        y.graph.yAxisStep = 1);
    let C = y.expressions.list, E = [], v = [];
    for (let w in t.objects) {
      let S = t.objects[w],
        k = pg(S.id, t.objects),
        _ = {
          id: S.id,
          type: "expression",
          color: S.color,
          hidden: !!S.hidden,
        };
      if (
        e && !JN(k) && (_.folderId = __dcg_shared_module_exports__["xd"]),
          S.locked && (_.dragMode = "NONE"),
          !S.hidden && S.label && S.showLabel
      ) {
        if (
          _.label = S.label,
            _.showLabel = true,
            k === "segment" && S.label.indexOf("{length}") !== -1
        ) {
          if (S.label === "{length}") _.label = "";
          else {
            let A = a("l"),
              P = A +
                "=\\operatorname{round}\\left(\\operatorname{length}\\left(" +
                n(S.id) + "\\right),2\\right)";
            v.push({ id: "len-" + _.id, type: "expression", latex: P }),
              _.label = _.label.replace(/\{length\}/g, "${" + A + "}");
          }
        }
        if (k === "angle" && S.label.indexOf("{angle}") !== -1) {
          if (S.label === "{angle}") {
            _.label = "";
          } else {
            let A = a("a"),
              P = A + "=\\operatorname{round}\\left(" + n(S.id) +
                "\\right)";
            v.push({ id: "angle-" + _.id, type: "expression", latex: P }),
              _.label = _.label.replace(/\{angle}/g, "${" + A + "}\xB0");
          }
        }
        if (k === "polygon" && S.label.indexOf("{area}") !== -1) {
          if (S.label === "{area}") {
            _.label = "";
          } else {
            let A = a("a"),
              P = A +
                "=\\operatorname{round}\\left(\\operatorname{area}\\left(" +
                n(S.id) + "\\right),2\\right)";
            v.push({ id: "area-" + _.id, type: "expression", latex: P }),
              _.label = _.label.replace(/\{area\}/g, "${" + A + "}");
          }
        }
        if (k === "polygon" && S.label.indexOf("{perimeter}") !== -1) {
          let A = a("p"),
            P = A +
              "=\\operatorname{round}\\left(\\operatorname{perimeter}\\left(" +
              n(S.id) + "\\right),2\\right)";
          v.push({ id: "perim-" + _.id, type: "expression", latex: P }),
            _.label = _.label.replace(/\{perimeter\}/g, "${" + A + "}");
        }
      }
      switch (S.type) {
        case "point": {
          let M = S.x === null ? 0 : S.x, F = S.y === null ? 0 : S.y;
          _.latex = n(S.id) + "=\\left(" +
            __dcg_shared_module_exports__["ce"](M) + "," +
            __dcg_shared_module_exports__["ce"](F) + "\\right)";
          break;
        }
        case "glider": {
          let M = pg(S.parents.host, t.objects), F = n(S.parents.host);
          M === "vector" && (F = l(F)),
            _.latex = n(S.id) + "=\\operatorname{glider}\\left(" + F +
              "," +
              __dcg_shared_module_exports__["ce"](
                aQ(S.t, S.parents.host, t.objects),
              ) + "\\right)";
          break;
        }
        case "intersection":
          let A = pg(S.parents.host1, t.objects),
            P = pg(S.parents.host2, t.objects),
            O = n(S.parents.host1),
            U = n(S.parents.host2);
          A === "vector" && (O = l(O)), P === "vector" && (U = l(U));
          let z = S.negRoot;
          (XN(A) && !XN(P) || P === "arc") && (z = !z);
          let x = z ? [O, U] : [U, O];
          _.latex = n(w) + "=\\operatorname{intersection}\\left(" +
            x.join(",") + "\\right)";
          break;
        case "midpoint":
          _.latex = s(S.id, S.type, [S.parents.straight]);
          break;
        case "circle":
          _.latex = s(S.id, S.type, [S.parents.point1, S.parents.point2]);
          break;
        case "arc":
          _.latex = s(S.id, S.type, [
            S.parents.point1,
            S.parents.point2,
            S.parents.point3,
          ]);
          break;
        case "compass":
          _.latex = s(S.id, "circle", [
            S.parents.center,
            S.parents.straight,
          ]);
          break;
        case "line":
        case "segment":
        case "ray":
        case "vector":
          _.latex = s(S.id, S.type, [S.parents.point1, S.parents.point2]);
          break;
        case "parallel":
        case "perpendicular":
          _.latex = s(S.id, S.type, [
            S.parents.straight,
            S.parents.point,
          ]);
          break;
        case "polygon":
          _.latex = s(S.id, S.type, S.parents.points);
          break;
        case "angle":
          _.latex = s(S.id, S.type, [
            S.parents.point1,
            S.parents.point2,
            S.parents.point3,
          ]);
          break;
        case "transformed-object":
          _.latex = n(S.id) + "=" + n(S.parents.transformation) +
            "\\left(" + n(S.parents.object) + "\\right)";
          break;
        case "dilation":
          _.latex = n(S.id) +
            "\\left(x\\right)=\\operatorname{dilate}\\left(x," +
            n(S.parents.center) + "," + (S.scaleFactor || "0/0") +
            "\\right)";
          break;
        case "reflection":
          _.latex = n(S.id) +
            "\\left(x\\right)=\\operatorname{reflect}\\left(x," +
            n(S.parents.straight) + "\\right)";
          break;
        case "translation":
          _.latex = n(S.id) +
            "\\left(x\\right)=\\operatorname{translate}\\left(x," +
            n(S.parents.from) + "," + n(S.parents.to) + "\\right)";
          break;
        case "rotation":
          _.latex = n(S.id) +
            "\\left(x\\right)=\\operatorname{rotate}\\left(x," +
            n(S.parents.center) + "," + (S.angle || "0/0") + "\\right)";
          break;
        case "scaled-rotation":
          let L = n(S.parents.center),
            V = n(S.parents.from),
            R = n(S.parents.to);
          _.latex = n(S.id) +
            `\\left(x\\right)=\\operatorname{rotate}\\left(\\operatorname{dilate}\\left(x,${L},\\frac{\\left|${R}-${L}\\right|}{\\left|${V}-${L}\\right|}\\right),${L},\\operatorname{directedangle}\\left(${V},${L},${R}\\right)\\right)`;
          break;
        case "image":
          break;
        default:
          return S;
      }
      _.latex &&
        (_.folderId === __dcg_shared_module_exports__["xd"]
          ? E.push(_)
          : v.push(_));
    }
    return C.push({
      type: "folder",
      id: __dcg_shared_module_exports__["xd"],
      title: "geometry",
      secret: true,
    }),
      C.push.apply(C, E),
      C.push.apply(C, v),
      y;
  }
  function QN(r) {
    return r === "<=" ? "\\le " : r === ">=" ? "\\ge " : r;
  }
  function Wr(r) {
    switch (r.type) {
      case "Comparator":
        return Sn(r.args, QN(r.symbol));
      case "ComparatorChain": {
        let n = "";
        for (let a = 0; a < r.symbols.length; a++) {
          n += Wr(r.args[a]) + QN(r.symbols[a]);
        }
        return n += Wr(r.args[r.args.length - 1]), n;
      }
      case "Tilde":
        return Sn(r.args, "~");
      case "Pos":
        return "+" + Wr(r.args[0]);
      case "Neg":
        return "-" + Wr(r.args[0]);
      case "Add":
        return Sn(r.args, "+");
      case "Sub":
        return Sn(r.args, "-");
      case "Mul":
        return Sn(r.args, "*");
      case "DotMul":
        return Sn(r.args, "\\cdot ");
      case "CrossMul":
        return Sn(r.args, "\\times ");
      case "Div":
        return Sn(r.args, "/");
      case "Bang":
        return Wr(r.args[0]) + "!";
      case "Call":
        let e = HM(r.args);
        return e
          ? e.script + "\\left(" + e.arg + "\\right)"
          : Wr(r.args[0]) + "\\left(" + Wr(r.args[1]) + "\\right)";
      case "Paren":
        return "\\left(" + Wr(r.args[0]) + "\\right)";
      case "List":
        return "\\left[" + r.args.map(Wr).join(",") + "\\right]";
      case "Pipes":
        return "\\left|" + Wr(r.args[0]) + "\\right|";
      case "Index":
        return Wr(r.args[0]) + "\\left[" + Wr(r.args[1]) + "\\right]";
      case "Subscript":
        return Sn(r.args, "_", true);
      case "Superscript":
        return Sn(r.args, "^", true);
      case "Prime":
        if (r.args[0].type === "Call") {
          let n = HM(r.args[0].args);
          return n
            ? n.script + qM(r.nprimes) + "\\left(" + n.arg + "\\right)"
            : Wr(r.args[0].args[0]) + qM(r.nprimes) + "\\left(" +
              Wr(r.args[0].args[1]) + "\\right)";
        }
        return Wr(r.args[0]) + qM(r.nprimes);
      case "Seq":
        return r.args.map(Wr).join(",");
      case "Sqrt":
        return "\\sqrt" + Ux(Wr(r.args[0]));
      case "Nthroot":
        return "\\sqrt[" + Wr(r.args[0]) + "]" + Ux(Wr(r.args[1]));
      case "Frac":
        return "\\frac{" + Wr(r.args[0]) + "}{" + Wr(r.args[1]) + "}";
      case "Derivative":
        return "\\frac{d}{d" + Wr(r.args[0]) + "}" + Wr(r.args[1]);
      case "Integral":
      case "EmptyIntegral":
        if (r.args[0].type !== "Cmd") {
          throw new Error(
            "Expected first argument of an integral to be the variable",
          );
        }
        let t = "d" + r.args[0].val;
        if (r.args.length === 3) {
          return zx("int", r.args[1], r.args[2]) + t;
        }
        let o = Wr(r.args[3]);
        return zx("int", r.args[1], r.args[2]) + o + t;
      case "Sum":
        return ZN(r.args, "sum");
      case "Product":
        return ZN(r.args, "prod");
      case "Piecewise":
        return "\\{" + Wr(r.args[0]) + "\\}";
      case "EmptyPiecewise":
        return "\\{\\}";
      case "Colon":
        return Sn(r.args, ":");
      case "Ellipsis":
        return Sn(r.args, "...");
      case "For":
        return Sn(r.args, "\\for ");
      case "With":
        return Sn(r.args, "\\with ");
      case "Dot":
        return Sn(r.args, ".");
      case "PercentOf":
        return Sn(r.args, "\\% \\of ");
      case "RightArrow":
        return Sn(r.args, "->");
      case "Juxt":
        return Sn(r.args, r.args[0].type === "Cmd" ? " " : "");
      case "ImplicitCall": {
        let n = HM(r.args);
        return n ? n.script + n.arg : Sn(r.args, "");
      }
      case "MixedNumber":
        return r.whole + "\\frac{" + r.num + "}{" + r.den + "}";
      case "Letter":
      case "Decimal":
      case "Alphanumeric":
        return r.val;
      case "Cmd":
        return "\\" + r.val;
      case "EmptyRangeEnd":
        return "EmptyRangeEnd";
      case "Err":
        throw r.error;
      default:
        return r;
    }
  }
  function Ux(r) {
    return r.length > 1 ? "{" + r + "}" : r;
  }
  function zx(r, e, t) {
    let o = Ux(Wr(e));
    if (t) {
      let i = Ux(Wr(t));
      return `\\${r}_${o}^${i}`;
    }
    return `\\${r}_${o}`;
  }
  function Sn(r, e, t = false) {
    let o = Wr(r[0]), i = t ? Ux(Wr(r[1])) : Wr(r[1]);
    return o + e + i;
  }
  function ZN(r, e) {
    let t = Wr(r[0]);
    return zx(e, r[1], r[2]) + t;
  }
  function qM(r) {
    let e = "";
    for (let t = 0; t < r; t++) e += "'";
    return e;
  }
  function eB(r) {
    return r.type === "Cmd" && r.val === "logbase";
  }
  function HM(r) {
    let e = r[1], t;
    if (
      r[1].type === "Seq" && r[1].args.length === 2 &&
      (e = r[1].args[1], t = r[1].args[0]),
        r[0].type === "Superscript" && eB(r[0].args[0])
    ) return { script: zx("log", e, r[0].args[1]), arg: t ? Wr(t) : "" };
    if (eB(r[0])) return { script: zx("log", e), arg: t ? Wr(t) : "" };
  }
  function tB_formatLatex(r) {
    let e = WM_expressionParser.parse(r.latex);
    if (e.type == "Err") return;
    let t = on(e);
    for (; t.type === "Paren";) t = t.args[0];
    return od(t) ? { latex: r.latex } : { latex: Wr(t) };
  }
  function lQ(r) {
    return r.isPseudoSurfaceNode;
  }
  function od(r) {
    switch (r.type) {
      case "Letter":
      case "Decimal":
      case "Cmd":
        return r.val === "0";
      case "Paren":
        return od(r.args[0]);
      default:
        return false;
    }
  }
  function Cu(r) {
    switch (r.type) {
      case "Letter":
      case "Decimal":
      case "Cmd":
        return r.val === "1";
      case "Paren":
        return Cu(r.args[0]);
      default:
        return false;
    }
  }
  function rB(r) {
    return r.type === "Neg"
      ? Cu(r.args[0])
      : r.type === "Paren"
      ? rB(r.args[0])
      : false;
  }
  function aS(r) {
    return {
      isPseudoSurfaceNode: true,
      type: "Decimal",
      span: r,
      val: "0",
    };
  }
  function KM(r, e) {
    return { isPseudoSurfaceNode: true, type: "Neg", span: e, args: [r] };
  }
  function cQ(r, e) {
    return { isPseudoSurfaceNode: true, type: "Paren", span: e, args: [r] };
  }
  function Cs(r, e) {
    return { ...r, span: e };
  }
  function on(r, e) {
    let t;
    switch (r.type) {
      case "Add": {
        let n = on(r.args[0]), a = on(r.args[1]);
        if (od(n)) return Cs(a, r.span);
        if (od(a)) return Cs(n, r.span);
        let s;
        if (
          a.type === "Neg"
            ? s = on(a.args[0])
            : a.type === "Paren" && a.args[0].type === "Neg" &&
              (s = on(a.args[0].args[0])), s !== void 0
        ) {
          return {
            isPseudoSurfaceNode: true,
            type: "Sub",
            span: r.span,
            args: [n, s],
          };
        }
        t = [n, a];
        break;
      }
      case "Sub": {
        let n = on(r.args[0]), a = on(r.args[1]);
        if (od(n)) return KM(a, r.span);
        if (od(a)) return Cs(n, r.span);
        let s;
        if (
          a.type === "Neg"
            ? s = a.args[0]
            : a.type === "Paren" && a.args[0].type === "Neg" &&
              (s = a.args[0].args[0]), s
        ) {
          return {
            isPseudoSurfaceNode: true,
            type: "Add",
            span: r.span,
            args: [n, s],
          };
        }
        t = [n, a];
        break;
      }
      case "Mul": {
        let n = on(r.args[0]), a = on(r.args[1]);
        if (Cu(n)) return Cs(a, r.span);
        if (Cu(a)) return Cs(n, r.span);
        if (od(n) || od(a)) return aS(r.span);
        t = [n, a];
        break;
      }
      case "Juxt": {
        let n = on(r.args[0], r), a = on(r.args[1], r);
        if (Cu(n)) return Cs(a, r.span);
        if (Cu(a)) return Cs(n, r.span);
        if (rB(n)) return KM(a, r.span);
        if (od(n) || od(a)) return aS(r.span);
        if (n.type === "Neg") {
          let s = {
            ...r,
            type: "Juxt",
            isPseudoSurfaceNode: true,
            args: [n.args[0], a],
          };
          return KM(s, r.span);
        }
        t = [n, a];
        break;
      }
      case "Frac":
      case "Div": {
        let n = on(r.args[0]), a = on(r.args[1]);
        if (Cu(a)) return Cs(n, r.span);
        t = [n, a];
        break;
      }
      case "Superscript":
        let o = on(r.args[0]), i = on(r.args[1]);
        if (Cu(i)) return Cs(o, r.span);
        (e == null ? void 0 : e.type) === "Juxt" &&
        e.args[0].type === "Decimal" && o.type === "Decimal" &&
        (o = cQ(o, o.span)), t = [o, i];
        break;
      case "Paren": {
        let n = on(r.args[0]);
        if ((e == null ? void 0 : e.type) !== "Juxt") {
          if (__dcg_shared_module_exports__["Nc"](n)) {
            return Cs(n, r.span);
          }
          let a = "args" in n ? n.args : void 0;
          if ((!a || a.length <= 1) && n.type !== "Neg") {
            return Cs(n, r.span);
          }
        }
        t = [n];
        break;
      }
      case "Pos": {
        let n = on(r.args[0]);
        return Cs(n, r.span);
      }
      case "Neg": {
        let n = on(r.args[0]), a = "args" in n ? n.args[0] : void 0;
        if (n.type === "Paren" && a && a.type === "Neg" && a.args[0]) {
          return Cs(on(a.args[0]), r.span);
        }
        if (n.type === "Neg" && a) return Cs(a, r.span);
        t = [n];
        break;
      }
      case "Cmd":
      case "Letter":
      case "Decimal":
      case "MixedNumber":
      case "EmptyRangeEnd":
      case "EmptyPiecewise":
      case "ComparatorChain":
        return { ...r, isPseudoSurfaceNode: true };
      default:
        t = r.args.map((n) =>
          lQ(n)
            ? n
            : n.type === "Alphanumeric"
            ? { ...n, isPseudoSurfaceNode: true }
            : on(n)
        );
    }
    return { ...r, isPseudoSurfaceNode: true, args: t };
  }
  function dQ(r, e) {
    return r == null && (r = ""), __dcg_shared_module_exports__["Wc"](r, e);
  }
  function pQ(r) {
    if (r != null) {
      try {
        let e = __dcg_shared_module_exports__["Vc"](r);
        return __dcg_shared_module_exports__["Rc"](e);
      } catch (e) {
        let t = e instanceof oB_parseNodes.Base ? e.getInputSpan() : void 0;
        t || (t = __dcg_shared_module_exports__["ta"](r, 0, r.length));
        let o = {
          ...__dcg_shared_module_exports__["Qc"](),
          originalError: e,
        };
        return __dcg_shared_module_exports__["Pc"](t, o);
      }
    }
  }
  var uQ_parser = { parse: dQ },
    WM_expressionParser = { parse: pQ },
    hQ_treeQueries = { countNumbers: iS },
    gQ_context = __dcg_shared_module_exports__["pe"],
    mQ_builtInFrame = __dcg_shared_module_exports__["qc"],
    fQ_types = __dcg_shared_module_exports__["Fb"],
    oB_parseNodes = __dcg_shared_module_exports__["C_types"],
    bQ_policies = {
      graphing: new __dcg_shared_module_exports__["ae"]({
        enableGeometry: false,
        enable3d: false,
        scales: void 0,
        includeFunctionParametersInRandomSeed: true,
        isComplexEnabled: false,
        customRegressions: true,
      }),
      scientific: new __dcg_shared_module_exports__["ke"]({
        singleExpression: false,
      }),
      fourFunction: new __dcg_shared_module_exports__["Ib"]({
        singleExpression: false,
      }),
    },
    yQ_blankGraphingCalculatorState = Bx,
    xQ_blankGeometryCalculatorState = nf;
  var zpe = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var el = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    mt = class extends el.Class {
      template() {
        return el.createElement(
          "div",
          {
            role: el.const("checkbox"),
            tabIndex: () =>
              this.props.disabled && this.props.disabled() ? -1 : 0,
            "aria-label": () => {
              var e, t;
              return (t = (e = this.props).ariaLabel) == null
                ? void 0
                : t.call(e);
            },
            "aria-labelledby": () => {
              var e, t;
              return (t = (e = this.props).labelledBy) == null
                ? void 0
                : t.call(e);
            },
            "aria-describedby": () => {
              var e, t;
              return (t = (e = this.props).describedBy) == null
                ? void 0
                : t.call(e);
            },
            "aria-disabled": () =>
              this.props.disabled && this.props.disabled() ? true : void 0,
            "aria-checked": () => this.props.checked(),
            "aria-required": () =>
              this.props.required ? this.props.required() : void 0,
            manageFocus: () => {
              var e, t;
              return (t = (e = this.props).manageFocus) == null
                ? void 0
                : t.call(e);
            },
            class: () => ({
              "dcg-component-checkbox": true,
              "dcg-checked": this.props.checked(),
              "dcg-disabled": this.props.disabled &&
                this.props.disabled(),
              "dcg-small": this.props.small && this.props.small(),
              [this.props.class === void 0 ? "" : this.props.class()]:
                this.props.class !== void 0,
            }),
            style: () => this.props.style ? this.props.style() : {},
            onTap: this.bindFn(this.onChange),
          },
          el.createElement(
            "span",
            { class: el.const("dcg-checkbox") },
            el.createElement("i", {
              class: el.const("dcg-icon-check"),
              "aria-hidden": el.const("true"),
            }),
          ),
          el.createElement("span", {
            class: el.const("dcg-checkbox-children"),
          }, this.props.children),
        );
      }
      onChange(e) {
        let t = e.target;
        t && t.getAttribute("href") ||
          this.props.disabled && this.props.disabled() ||
          this.props.onChange(!this.props.checked());
      }
    };
  qt();
  var tbe = function () {
    {
      let r = "_*_";
      ee.Event.prototype.wasHandled = function (e) {
        e = e || r;
        let t = this.originalEvent, o = t && t.handledBy;
        if (o && o[e]) return true;
        if (e !== r) return false;
        let i = this.target.closest("[handleEvent]");
        return i && i !== this.currentTarget
          ? i.getAttribute("handleEvent") !== "false"
          : false;
      },
        ee.Event.prototype.handle = function (e) {
          e = e || r;
          let t = this.originalEvent;
          if (!t) return;
          let o = t.handledBy;
          o || (o = t.handledBy = {}), o[e] = true;
        };
    }
  }();
  var cl = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  mg();
  var uZ = (r) => XM(r) || r === "localhost",
    hG = (r) => {
      let { search: e, hostname: t } = typeof location != "undefined"
        ? location
        : typeof window != "undefined"
        ? window.location
        : new Location();
      return uZ(t)
        ? new URLSearchParams(r != null ? r : e)
        : new URLSearchParams();
    };
  var Du = (r, e = hG()) => e.get(r) || void 0;
  var $5 = (r, e = hG()) => {
      let t = e.get(r) || void 0;
      return t ? parseInt(t, 10) : void 0;
    },
    ku = (r, e = hG()) => e.has(r) && e.get(r) !== "false";
  var abe = navigator.userAgent.match(/MSIE 8.0/i) !== null,
    sbe = navigator.userAgent.match(/MSIE 9.0/i) !== null,
    Y5 = navigator.userAgent.match(/MSIE/i) !== null ||
      navigator.userAgent.match(/Trident/i) !== null &&
        navigator.userAgent.match(/rv:11/i) !== null,
    lbe = navigator.userAgent.match(/Edge/i) !== null,
    tl = navigator.userAgent.match(/iPad/i) !== null,
    Df = navigator.userAgent.match(/Mobile|Android/i) !== null ||
      ku("forceMobile"),
    Qx = navigator.userAgent.match(/Android/i) !== null,
    Ml = navigator.userAgent.match(/(iPad|iPhone|iPod)/i) !== null ||
      navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1,
    cbe = navigator.userAgent.match(/Chrome/i) !== null,
    FS = navigator.userAgent.match(/Firefox/i) !== null,
    NS = navigator.userAgent.match(/^((?!chrome|android).)*safari/i) !==
      null,
    Zo = navigator.platform.match(/(Mac|iPhone|iPod|iPad)/i) !== null,
    X5 = navigator.platform.match(/(Win32)/i) !== null,
    J5 = navigator.userAgent.match(/Touch/i) !== null,
    dbe = navigator.userAgent.match(/Kindle/i) !== null ||
      navigator.userAgent.match(/Silk/i) !== null,
    pbe = navigator.userAgent.match(/KeyWeb/i) !== null,
    mp = window.parent !== window;
  var Q5 = Ml || Qx || navigator.userAgent.match(/webOS/i) ||
    navigator.userAgent.match(/BlackBerry/i) ||
    navigator.userAgent.match(/Windows Phone/i) || ku("forceTouchDevice");
  var yg = (() => {
      let r = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
      return r
        ? [
          parseInt(r[1], 10),
          parseInt(r[2], 10),
          parseInt(r[3] || "0", 10),
        ]
        : null;
    })(),
    ube = (() => {
      let r = navigator.appVersion.match(/OS X (\d+)_(\d+)_?(\d+)?/);
      return r
        ? [
          parseInt(r[1], 10),
          parseInt(r[2], 10),
          parseInt(r[3] || "0", 10),
        ]
        : null;
    })(),
    hbe = (() => {
      let r = navigator.appVersion.match(
        /Chrom(e|ium)\/([0-9]+)\.([0-9]+)\.?([0-9]+)?/,
      );
      return r
        ? [
          parseInt(r[2], 10),
          parseInt(r[3], 10),
          parseInt(r[4] || "0", 10),
        ]
        : null;
    })(),
    BS = !(!("inputMode" in document.createElement("textarea")) ||
      Ml && yg && yg[0] < 15),
    gbe = (() => {
      let r = document.createElement("canvas");
      return !!(r.getContext && r.getContext("2d"));
    })(),
    Z5 = window.matchMedia("(prefers-reduced-motion: reduce)").matches ||
      document.location.search.indexOf("prefersReducedMotion") >= 0,
    eU = () => document.createElement("video"),
    mbe = (() => {
      let r = eU();
      return r.canPlayType &&
        !!r.canPlayType('video/webm; codecs="vp8, vorbis"');
    })(),
    fbe = (async () => {
      if (Du("autoplay") !== void 0) return ku("autoplay");
      let r = eU();
      r.src =
        "data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAAu1tZGF0AAACrQYF//+p3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE1NSByMjkwMSA3ZDBmZjIyIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxOCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTMgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MzoweDExMyBtZT1oZXggc3VibWU9NyBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0xIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MSA4eDhkY3Q9MSBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTMgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTEgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD00MCByYz1jcmYgbWJ0cmVlPTEgY3JmPTI4LjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IGlwX3JhdGlvPTEuNDAgYXE9MToxLjAwAIAAAAAwZYiEAD//8m+P5OXfBeLGOfKE3xkODvFZuBflHv/+VwJIta6cbpIo4ABLoKBaYTkTAAAC7m1vb3YAAABsbXZoZAAAAAAAAAAAAAAAAAAAA+gAAAPoAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIYdHJhawAAAFx0a2hkAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAPoAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAACgAAAAWgAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABAAAD6AAAAAAAAQAAAAABkG1kaWEAAAAgbWRoZAAAAAAAAAAAAAAAAAAAQAAAAEAAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAATttaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAD7c3RibAAAAJdzdHNkAAAAAAAAAAEAAACHYXZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAACgAFoASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAADFhdmNDAWQACv/hABhnZAAKrNlCjfkhAAADAAEAAAMAAg8SJZYBAAZo6+JLIsAAAAAYc3R0cwAAAAAAAAABAAAAAQAAQAAAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAEAAAABAAAAFHN0c3oAAAAAAAAC5QAAAAEAAAAUc3RjbwAAAAAAAAABAAAAMAAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTguMTIuMTAw",
        r.muted = true,
        r.playsInline = true,
        r.style.display = "none";
      let e = await new Promise((t) => {
        document.readyState !== "loading"
          ? t(document.body)
          : document.addEventListener("DOMContentLoaded", () =>
            t(document.body));
      });
      e.appendChild(r);
      try {
        await r.play();
      } catch (t) {
        return false;
      } finally {
        e.removeChild(r);
      }
      return true;
    })(),
    j5,
    US = (j5 = window.matchMedia("(forced-colors: active)")) == null
      ? void 0
      : j5.matches;
  var sr = {};
  __dcg_shared_module_exports__["defineProperties"](sr, {
    ALT: () => fG,
    BACKSPACE: () => _u,
    CAPSLOCK: () => yG,
    CONTROL: () => mG,
    DELETE: () => sU,
    DOWN: () => Kn,
    END: () => fp,
    ENTER: () => xg,
    ESCAPE: () => kn,
    HOME: () => wg,
    LEFT: () => ld,
    META: () => bG,
    PAGEDOWN: () => Au,
    PAGEUP: () => Iu,
    RIGHT: () => cd,
    SHIFT: () => tw,
    SPACEBAR: () => xG,
    TAB: () => rl,
    UP: () => xa,
    isBacktick: () => gZ,
    isEnterOrSpace: () => kf,
    isHelp: () => mZ,
    isModifierKey: () => rw,
    isRedo: () => ew,
    isSelectAll: () => hZ,
    isSwitchPanes: () => gG,
    isUndo: () => Zx,
    lookup: () => ke,
    lookupChar: () => Ko,
  });
  var Zx = (r) =>
      !r.altKey && !r.shiftKey && (r.ctrlKey || r.metaKey) &&
      (r.key == "z" || r.which == 90),
    ew = (r) =>
      !r.altKey && (r.ctrlKey || r.metaKey) &&
      (r.key === "y" || r.which == 89 ||
        r.shiftKey && (r.key === "Z" || r.key === "z" || r.which === 90)),
    hZ = (r) =>
      !r.altKey && (r.ctrlKey || r.metaKey) &&
      (r.key === "a" || r.key === "A" || r.which == 65),
    gZ = (r) =>
      !r.altKey && !r.ctrlKey && !r.metaKey && !r.shiftKey &&
      (r.key === "`" || r.which == 192),
    mZ = (r) =>
      !r.altKey && (r.ctrlKey || r.metaKey) &&
      (r.key === "/" || r.which == 191),
    gG = (r) =>
      r.key === "F6" || r.key === "f6" || r.which === 117 ||
      r.keyCode === 117,
    _u = "Backspace",
    rl = "Tab",
    xg = "Enter",
    tw = "Shift",
    mG = "Control",
    fG = "Alt",
    bG = "Meta",
    yG = "CapsLock",
    kn = "Esc",
    xG = "Space",
    Iu = "PageUp",
    Au = "PageDown",
    fp = "End",
    wg = "Home",
    ld = "Left",
    xa = "Up",
    cd = "Right",
    Kn = "Down",
    sU = "Del",
    tU = {
      8: "Backspace",
      9: "Tab",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Esc",
      32: "Space",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "Left",
      38: "Up",
      39: "Right",
      40: "Down",
      46: "Del",
      91: "Meta",
      93: "Meta",
    },
    rU = {
      Backspace: _u,
      Tab: rl,
      Enter: xg,
      Shift: tw,
      Control: mG,
      Alt: fG,
      Meta: bG,
      CapsLock: yG,
      Escape: kn,
      " ": xG,
      PageUp: Iu,
      PageDown: Au,
      End: fp,
      Home: wg,
      ArrowLeft: ld,
      ArrowUp: xa,
      ArrowRight: cd,
      ArrowDown: Kn,
      Delete: sU,
    },
    rw = (r) => {
      let e = [tw, fG, mG, yG, bG];
      return !!r.key && e.includes(r.key);
    },
    kf = (r) => ke(r) === xg || ke(r) === xG,
    oU = {
      UIKeyInputUpArrow: xa,
      UIKeyInputDownArrow: Kn,
      UIKeyInputLeftArrow: ld,
      UIKeyInputRightArrow: cd,
      UIKeyInputEscape: kn,
      UIKeyInputPageUp: Iu,
      UIKeyInputPageDown: Au,
    },
    wG = [
      "0123456789abcdefghijklmnopqrstuvwxyz",
      "\xBA\xA1\u2122\xA3\xA2\u221E\xA7\xB6\u2022\xAA\xE5\u222B\xE7\u2202 \u0192\xA9\u02D9 \u2206\u02DA\xAC\xB5 \xF8\u03C0\u0153\xAE\xDF\u2020 \u221A\u2211\u2248\xA5\u03A9",
      "\u201A\u2044\u20AC\u2039\u203A\uFB01\uFB02\u2021\xB0\xB7\xC5\u0131\xC7\xCE\xB4\xCF\u02DD\xD3\u02C6\xD4\uF8FF\xD2\xC2\u02DC\xD8\u220F\u0152\u2030\xCD\u02C7\xA8\u25CA\u201E\u02DB\xC1\xB8",
    ].map((r) => r.split("")),
    iU = wG[0],
    nU = wG[1],
    aU = wG[2],
    lU = {},
    cU = {};
  for (let r = 0; r < iU.length; r++) {
    let e = iU[r];
    nU[r] !== " " && (lU[nU[r]] = e.toUpperCase()),
      aU[r] !== " " && (cU[aU[r]] = e.toUpperCase());
  }
  var ke = (r) => {
      if (r.key && rU[r.key]) return rU[r.key];
      if (r.which && tU[r.which]) return tU[r.which];
      if (r.key && oU[r.key]) return oU[r.key];
    },
    Ko = (r) => {
      if (!r.key) return String.fromCharCode(r.which || -1);
      if (Zo && r.altKey) {
        let e = r.shiftKey ? cU : lU;
        if (e[r.key]) return e[r.key];
      }
      if (r.key.length === 1) return r.key.toUpperCase();
      if (r.key === "Enter") return "\r";
      if (r.key === "Tab") return "	";
    };
  qt();
  var Gl = function (r) {
      if (!r) return;
      let e = r.getBoundingClientRect();
      return {
        top: e.top + window.scrollY,
        left: e.left + window.scrollX,
      };
    },
    Wn = function (r, e) {
      Object.assign(r.style, e);
    };
  function bp(r) {
    return !!(r &&
      (r.offsetWidth || r.offsetHeight || r.getClientRects().length));
  }
  function dU(r) {
    if (document.readyState !== "loading") r();
    else {
      let e = function () {
        document.removeEventListener("DOMContentLoaded", e), r();
      };
      document.addEventListener("DOMContentLoaded", e);
    }
  }
  var fZ = document.location.href.indexOf("dcgDebugTouchTracking=dcgYES") !==
      -1,
    Mu,
    _f;
  window._touchtracking_id_counter == null &&
    (window._touchtracking_id_counter = 0);
  window._touchtracking_id_counter += 1;
  var iw = "touchtracking_id_" + window._touchtracking_id_counter,
    di = function (r) {
      _f && (_f.value = "(" + Date.now() + ") " + r + `
` + _f.value);
    };
  function nw(r) {
    if (
      r.classList.add("dcg-tap-container", iw),
        Ml &&
        r.style.setProperty("--dcg-minimum-input-font-size", "16px"),
        fZ
    ) {
      Mu && Mu.remove(),
        Mu = document.createElement("div"),
        Wn(Mu, { position: "absolute", bottom: "10px", right: "10px" });
      let e = document.createElement("textarea");
      e.setAttribute("rows", "30"), e.setAttribute("cols", "40"), Mu.append(e);
      let t = document.createElement("div");
      t.id = "dcg-touchtracking-debug-copy",
        t.classList.add("dcg-btn-blue"),
        t.innerText = "COPY LOGS",
        Mu.append(t),
        _f = Mu.querySelector("textarea"),
        r.append(Mu),
        t.addEventListener("mousedown", () => {
          _f && (_f.select(), document.execCommand("copy"));
        }, true),
        di("monitor touches");
    }
  }
  var Mf = 0,
    Ll = 1,
    aw = 2,
    If = 3,
    xp = 4,
    vr = Mf,
    vG = {},
    hc = {},
    yp = [],
    CG = 0,
    ow = null,
    qS = null,
    Gu = false,
    zS = null,
    pU = Gu,
    Lu = function (r) {
      let e = document.activeElement;
      r.type.startsWith("key")
        ? rw(r) || (Gu = true)
        : r.type.startsWith("pointer") && (Gu = false);
      let t = !!(e && wp(e));
      e && !e.closest(".dcg-tap-container." + iw) && (e = null),
        e !== zS
          ? (zS && zS.classList.remove("dcg-focus-visible"),
            e && (Gu || t) && e.classList.add("dcg-focus-visible"))
          : pU !== Gu && e && !t &&
            (Gu
              ? e.classList.add("dcg-focus-visible")
              : e.classList.remove("dcg-focus-visible")),
        pU = Gu,
        zS = e;
    };
  document.addEventListener("keydown", Lu, { capture: true });
  document.addEventListener("keydown", Lu);
  document.addEventListener("pointerdown", Lu);
  document.addEventListener("pointerdown", Lu, { capture: true });
  document.addEventListener("focusin", Lu, { capture: true });
  document.addEventListener("focusin", Lu);
  document.addEventListener("focusout", Lu, { capture: true });
  document.addEventListener("focusout", Lu);
  var uU,
    Es = [],
    SG = function (r) {
      if (!(r instanceof Element)) return [];
      let e = r.closest(".dcg-tap-container." + iw);
      if (!e) return [];
      let t = r, o = [];
      for (; t;) {
        if (o.push(t), t === e) return o;
        t = t.parentNode;
      }
      return [];
    },
    HS = function (r, e) {
      qS = null,
        vr = r,
        di("beginMode:" + vr),
        vr === Ll
          ? yp = SG(e.originalEvent.touches[0].target)
          : yp = SG(e.target),
        yp.forEach((t) => {
          t.classList.add("dcg-depressed");
        }),
        yp.forEach((t) => {
          let o = ee(t);
          o.data({
            originalScrollTop: o.scrollTop(),
            originalScrollLeft: o.scrollLeft(),
          });
        }),
        hc = {};
    };
  function wp(r) {
    let e = ["text", "password", "email", "number", "url", "search"];
    return r.matches("input") && e.indexOf(r.type) >= 0 ||
      r.matches('textarea, [role="textbox"], [contenteditable=true]') ||
      r.classList.contains("dcg-mathquill-input-span");
  }
  var Gf = function (r) {
      if (!(r instanceof Element)) return false;
      let e = r.closest(".dcg-tap-container");
      return e ? e.matches(".dcg-tap-container." + iw) : false;
    },
    bZ = function (r) {
      return vr !== If && !wp(r) && Gf(r);
    },
    Lf = function (r, e) {
      qS = null;
      let t = false;
      di("endMode:" + vr),
        document.querySelectorAll(".dcg-depressed").forEach((i) => {
          i.classList.remove("dcg-depressed");
        });
      let o = document.activeElement;
      if (!xU(r.target) && o && bZ(o)) {
        try {
          o.blur();
        } catch (i) {}
      }
      if (
        yp.forEach((i) => {
          let n = ee(i),
            a = n.data("originalScrollTop") - n.scrollTop(),
            s = n.data("originalScrollLeft") - n.scrollLeft();
          (a || s) && (hc.scroll = true);
        }),
          hc["dcg-tapstart"] === 1 && hc["dcg-tapend"] === 1 &&
          !hc["dcg-tapcancel"] && !hc.scroll
      ) {
        di("potential dcg-tap");
        let i = e.changedTouches[0].clientX,
          n = e.changedTouches[0].clientY;
        if (r && !r.device && i === 0 && n === 0) {
          di("event appears to be simulated"), t = true, vr = If;
          let l = r.target.getBoundingClientRect();
          i = (l.left + l.right) / 2, n = (l.top + l.bottom) / 2;
        }
        di("potential dcg-tap coords:" + i + ":" + n);
        let a = false, s = false;
        for (let l of yp) {
          if (a) break;
          let c;
          if (
            typeof l.getBoundingClientRect == "function" &&
            (c = l.getBoundingClientRect()),
              typeof l.getAttribute == "function" &&
              l.getAttribute("tapboundary") === "true" && (a = true),
              !(c &&
                (i < c.left || n < c.top || i > c.right || n > c.bottom))
          ) {
            qS = l,
              s = true,
              Ha("dcg-tap", r, {
                target: qS,
                touches: e.touches,
                changedTouches: e.changedTouches,
              });
            break;
          }
        }
        di("result of dcg-tap:  did_dispatch=" + s + "  did_escape=" + a);
      }
      vr === Ll || vr === xp
        ? ow = setTimeout(() => {
          ow = null, CG = new Date().getTime();
        }, 1e3)
        : t && (ow = setTimeout(() => {
          ow = null, CG = new Date().getTime();
        }, 100)),
        yp = [],
        vr = Mf;
    },
    Af = function () {
      return ow || new Date().getTime() - CG < 500;
    },
    fU = function (r) {
      return r.identifier !== void 0 ? r.identifier : r.pointerId;
    },
    hU = function (r) {
      let e = [];
      for (let t of r) {
        e.push({
          identifier: fU(t),
          x: t.pageX,
          y: t.pageY,
          screenX: t.screenX,
          screenY: t.screenY,
          pageX: t.pageX,
          pageY: t.pageY,
          clientX: t.clientX,
          clientY: t.clientY,
        });
      }
      return e;
    },
    Ha = function (r, e, t) {
      let o = fU(e), i = hU(t.touches), n = hU(t.changedTouches);
      if (di("dispatchEvent:" + r), r === "dcg-tapstart") {
        vG[o] = { type: r, pageX: n[0].pageX, pageY: n[0].pageY };
      } else if (r === "dcg-tapmove") {
        let c = n[0], d = vG[o];
        if (
          d && c.pageX === d.pageX && c.pageY === d.pageY ||
          (vr === Ll || vr === xp) && d && d.type === "dcg-tapstart" &&
            Math.abs(d.pageX - c.pageX) + Math.abs(d.pageY - c.pageY) < 2
        ) return;
        vG[o] = { type: r, pageX: n[0].pageX, pageY: n[0].pageY };
      }
      let a = r.toLowerCase();
      hc[a] === void 0 ? hc[a] = 1 : hc[a] += 1;
      let s = ee.event.fix(e.originalEvent);
      s.type = r,
        s.device = vr === Ll || vr === xp
          ? "touch"
          : vr === If
          ? "keyboard"
          : "mouse",
        s.touches = i,
        s.changedTouches = n,
        s.target = t.target ? t.target : e.target;
      let l = s.device !== "keyboard" && hc["dcg-longhold"] > 0;
      s.wasLongheld = function () {
        return l;
      },
        s.preventTap = function () {
          hc["dcg-tapcancel"] = 1;
        },
        clearTimeout(uU),
        s.type === "dcg-tapstart" && s.device !== "keyboard" &&
        s.touches.length === 1 && (uU = setTimeout(() => {
          Ha("dcg-longhold", e, t);
        }, 500)),
        s.target && s.target.nodeName &&
        s.target.nodeName.toLowerCase() === "a" && s.type === "dcg-tap" &&
        s.device === "keyboard" && s.target.click && s.target.click(),
        di("trigger event:" + s.type),
        ee(s.target).trigger(s);
    },
    KS = function (r) {
      let e = yp,
        t = !!yp.length,
        o = document.querySelectorAll(
          ".dcg-tap-container." + iw + " .dcg-hovered",
        ),
        i = Array.from(o).filter(Gf),
        n = [],
        a = [],
        s = [];
      r && SG(r).forEach((l) => {
        (!t || e.indexOf(l) !== -1) &&
          (i.indexOf(l) === -1 && s.push(l), n.push(l));
      });
      for (let l of i) n.indexOf(l) === -1 && a.push(l);
      a.forEach((l) => {
        l && l.classList.remove("dcg-hovered"), ee(l).trigger("tipsyhide");
      }),
        s.forEach((l) => {
          l && l.classList.add("dcg-hovered"), ee(l).trigger("tipsyshow");
        });
    },
    WS = function (r) {
      for (let e of Es) if (e.pointerId === r) return true;
      return false;
    },
    EG = function (r) {
      for (let e = 0; e < Es.length; e++) {
        Es[e].pointerId === r && Es.splice(e, 1);
      }
    },
    bU = function (r) {
      vr === Mf && HS(xp, r),
        TG(),
        KS(null),
        Es.push(r.originalEvent),
        Ha("dcg-tapstart", r, {
          touches: Es,
          changedTouches: [r.originalEvent],
        });
    },
    gU = function (r) {
      EG(r.originalEvent.pointerId);
      let e = { touches: Es, changedTouches: [r.originalEvent] };
      Ha("dcg-tapcancel", r, e), Es.length === 0 && Lf(r, e);
    },
    mU = function (r) {
      EG(r.originalEvent.pointerId);
      let e = { touches: Es, changedTouches: [r.originalEvent] };
      Ha("dcg-tapend", r, e), Es.length === 0 && Lf(r, e);
    },
    $S = function (r) {
      return r.originalEvent.pointerType === "touch";
    },
    Pf = function (r, e) {
      r.trim().split(/\s+/).forEach((t) => {
        let o = yZ ? { passive: false } : void 0;
        document.addEventListener(t, (i) => {
          di("document.on:" + i.type), e(ee.event.fix(i));
        }, o);
      });
    };
  Pf("pointerdown MSPointerDown", (r) => {
    if (!(vr === aw || vr === Ll || !$S(r))) {
      if (WS(r.originalEvent.pointerId)) {
        di(
          "exit. pointer id already exists: " + r.originalEvent.pointerId,
        );
        return;
      }
      bU(r);
    }
  });
  Pf("pointermove MSPointerMove", (r) => {
    vr === aw || vr === Ll || !$S(r) ||
      (WS(r.originalEvent.pointerId) ||
        (di("pointer id already exists: " + r.originalEvent.pointerId), bU(r)),
        EG(r.originalEvent.pointerId),
        Es.push(r.originalEvent),
        Ha("dcg-tapmove", r, {
          touches: Es,
          changedTouches: [r.originalEvent],
        }));
  });
  ee(document).on("pointercancel MSPointerCancel", (r) => {
    if (
      di("document.on:" + r.type),
        vr !== xp || !$S(r) || !WS(r.originalEvent.pointerId)
    ) return;
    gU(r);
    let e;
    for (; e = Es.pop();) {
      let t = ee.Event(e, { originalEvent: e });
      gU(t);
    }
  });
  ee(document).on("pointerup MSPointerUp", (r) => {
    if (
      di("document.on:" + r.type),
        vr !== xp || !$S(r) || !WS(r.originalEvent.pointerId)
    ) return;
    mU(r);
    let e;
    for (; e = Es.pop();) {
      let t = ee.Event(e, { originalEvent: e });
      mU(t);
    }
  });
  var yZ = function () {
    let r = false;
    try {
      let e = Object.defineProperty({}, "passive", {
        get: function () {
          r = true;
        },
      });
      window.addEventListener("test", () => {}, e),
        window.removeEventListener("test", () => {}, e);
    } catch (e) {}
    return r;
  }();
  Pf("touchstart", (r) => {
    vr === aw || vr === xp ||
      (TG(),
        vr === Mf && HS(Ll, r),
        KS(null),
        Ha("dcg-tapstart", r, {
          touches: r.originalEvent.touches,
          changedTouches: r.originalEvent.changedTouches,
        }));
  });
  Pf("touchmove", (r) => {
    vr === Ll &&
      Ha("dcg-tapmove", r, {
        touches: r.originalEvent.touches,
        changedTouches: r.originalEvent.changedTouches,
      });
  });
  Pf("touchcancel", (r) => {
    if (vr !== Ll) return;
    let e = {
      touches: r.originalEvent.touches,
      changedTouches: r.originalEvent.changedTouches,
    };
    Ha("dcg-tapcancel", r, e), r.originalEvent.touches.length === 0 && Lf(r, e);
  });
  Pf("touchend", (r) => {
    if (vr !== Ll) return;
    let e = {
      touches: r.originalEvent.touches,
      changedTouches: r.originalEvent.changedTouches,
    };
    Ha("dcg-tapend", r, e), r.originalEvent.touches.length === 0 && Lf(r, e);
  });
  function yU() {
    return !!(vr === Ll || vr === xp || Af());
  }
  ee(document).on("mousedown", (r) => {
    if (
      di("document.on:" + r.type), !(r.button === 1 || r.button === 2)
    ) {
      if (yU()) {
        !r.target.matches("input, textarea, select") && Gf(r.target) &&
        r.preventDefault(), di("abort mousedown: " + vr + ":" + Af());
        return;
      }
      HS(aw, r), Ha("dcg-tapstart", r, { touches: [r], changedTouches: [r] });
    }
  });
  var xU = function (r) {
      return !(r instanceof Element) || !Gf(r) ||
          r.closest(".dcg-do-blur") || r.closest(".dcg-text-selectable")
        ? false
        : !!r.closest(".dcg-do-not-blur");
    },
    TG = function () {
      try {
        let r = window.getSelection();
        if ((r == null ? void 0 : r.rangeCount) === 1) {
          let e = r.getRangeAt(0).commonAncestorContainer;
          e.nodeType === Node.TEXT_NODE && (e = e.parentNode),
            e && e.closest(".dcg-text-selectable") && r.removeAllRanges();
        }
      } catch (r) {}
    };
  ee(document).on("mousedown", (r) => {
    di("document.on:" + r.type), xU(r.target) && r.preventDefault(), TG();
  });
  ee(document).on("mouseleave", (r) => {
    if (di("document.on:" + r.type), vr === Mf) {
      if (Af()) {
        di("abort mouseleave: " + vr + ":" + Af());
        return;
      }
      KS(null);
    }
  });
  ee(document).on("mousemove", (r) => {
    if (
      di("document.on:" + r.type),
        !(r.button === 1 || r.button === 2) && !(vr === Ll || vr === xp)
    ) {
      if (Af()) {
        di("abort mousemove: " + vr + ":" + Af());
        return;
      }
      KS(r.target), Ha("dcg-tapmove", r, { touches: [r], changedTouches: [r] });
    }
  });
  ee(document).on("mouseup", (r) => {
    if (
      di("document.on:" + r.type), r.button === 1 || r.button === 2 || vr !== aw
    ) return;
    let e = { touches: [], changedTouches: [r] };
    Ha("dcg-tapend", r, e), Lf(r, e);
  });
  ee(document).on("keydown", (r) => {
    if (
      di("document.on:" + r.type), !(!kf(r) || !Gf(r.target)) && vr !== If
    ) {
      if (
        r.target.matches(
          'a:not([ontap]), button:not([ontap]), input, textarea, select, [role="textbox"], [contenteditable="true"], summary',
        )
      ) return;
      r.preventDefault(),
        HS(If, r),
        Ha("dcg-tapstart", r, { touches: [r], changedTouches: [r] });
    }
  });
  ee(document).on("keyup", (r) => {
    if (
      di("document.on:" + r.type), !kf(r) || !Gf(r.target) || vr !== If
    ) return;
    let e = { touches: [], changedTouches: [r] };
    Ha("dcg-tapend", r, e), Lf(r, e);
  });
  function DG() {
    return vr !== Mf;
  }
  function wU() {
    return Gu;
  }
  var vU = {
    monitor: nw,
    isTapActive: DG,
    elIsTypeable: wp,
    shouldIgnoreMouseDown: yU,
  };
  var Lbe = __dcg_shared_module_exports__["defineDefaultExport"](CU());
  qt();
  var SU = [
      "exp|exponent ln|natural-log log",
      "total length count mean median quantile quartile nCr nPr stats",
      "stdev|standard-deviation stddev|standard-deviation",
      "stdDev|standard-deviation stdevp|standard-deviation-population",
      "stddevp|standard-deviation-population stdDevP|standard-deviation-population mad var|variance",
      "varp|variance-population variance cov|co-variance covp|co-variance-population corr|correlation spearman",
      "lcm mcm gcd mcd gcf mod ceil|ceiling floor round abs|absolute-value min max sign|signum signum sgn",
      "sin|sine cos|cosine tan|tangent csc|co-secant sec|secant cot|co-tangent",
      "sinh|hyperbolic-sine cosh|hyperbolic-cosine tanh|hyperbolic-tangent csch|hyperbolic-co-secant",
      "sech|hyperbolic-secant coth|hyperbolic-co-tangent",
      "arcsin|arc-sine arccos|arc-cosine arctan|arc-tangent arccsc|arc-co-secant arcsec|arc-secant",
      "arccot|arc-co-tangent",
      "arcsinh|hyperbolic-arc-sine arccosh|hyperbolic-arc-cosine arctanh|hyperbolic-arc-co-tangent",
      "arccsch|hyperbolic-arc-co-secant arcsech|hyperbolic-arc-secant",
      "arccoth|hyperbolic-arc-co-tangent",
      "arsinh|hyperbolic-ar-sine arcosh|hyperbolic-ar-cosine artanh|hyperbolic-ar-co-tangent",
      "arcsch|hyperbolic-ar-co-secant arsech|hyperbolic-ar-secant",
      "arcoth|hyperbolic-ar-co-tangent",
      "polygon",
      "distance midpoint",
      "sort shuffle join unique",
      "erf|error-function",
      "TTest|t-test ttest|t-test TScore|t-score tscore|t-score",
      "iTTest|independent-t-test ittest|independent-t-test IndependentTTest",
      "TScore|t-score Tscore|t-score tscore|t-score",
      "normaldist|normal-distribution tdist|t-distribution poissondist|poisson-distribution",
      "binomialdist|binomial-distribution",
      "uniformdist|uniform-distribution",
      "pdf cdf random inverseCdf inversecdf",
      "histogram dotplot boxplot",
      "pdf cdf",
      "rgb hsv",
      "for",
      "width height",
      "with",
      ...__dcg_shared_module_exports__["Hb"],
    ].join(" "),
    xZ = [
      "det|determinant",
      "inv|inverse",
      "transpose",
      "rref|reduced-row-echelon-form",
      "trace",
    ].join(" ");
  SU += " " + xZ;
  var wZ =
    "alpha beta sqrt theta phi rho pi tau nthroot cbrt sum prod integral percent infinity infty cross";
  function Pu(r) {
    r || (r = {});
    let e = [wZ];
    return r.disallowAns || e.push("ans"),
      r.disallowFrac || e.push("frac"),
      r.additionalCommands && (e = e.concat(r.additionalCommands)),
      e.join(" ");
  }
  function kG(r) {
    r || (r = {});
    let e = SU;
    return r.additionalOperators && r.additionalOperators.length &&
      (e = `${e} ${r.additionalOperators.join(" ")}`),
      r.includeGeometryFunctions &&
      (e += " " +
        Object.keys(__dcg_shared_module_exports__["ge"]).join(" ")),
      r.include3DFunctions &&
      (e += " " +
        Object.keys(__dcg_shared_module_exports__["he"]).join(" ")),
      e;
  }
  function vZ() {
    return "for with";
  }
  function CZ() {
    let r = "ln log";
    for (
      let [e, t] of Object.entries(__dcg_shared_module_exports__["Lc"])
    ) t == "Trig" && (r += " " + e.replace(/^\\/, ""));
    return r;
  }
  function Vf(r) {
    return {
      autoOperatorNames: kG(r),
      infixOperatorNames: vZ(),
      prefixOperatorNames: CZ(),
    };
  }
  var EU = window.MathQuill.noConflict().getInterface(3);
  EU.config({
    leftRightIntoCmdGoes: "up",
    sumStartsWithNEquals: true,
    supSubsRequireOperand: true,
    charsThatBreakOutOfSupSub: "+-=<>*",
    autoCommands: Pu(),
    autoSubscriptNumerals: true,
    restrictMismatchedBrackets: true,
    typingPercentWritesPercentOf: true,
    substituteTextarea: function (r) {
      if (!BS && (Ml || Qx)) {
        let t = document.createElement("span");
        return t.classList.add("dcg-mathquill-input-span"),
          t.setAttribute("tabindex", r ? "0" : "-1"),
          t.setAttribute("role", "textbox"),
          Wn(t, { display: "inline-block", height: "1px", width: "1px" }),
          t;
      }
      if (X5 && J5) {
        let t = document.createElement("textarea");
        return t.setAttribute("readonly", ""),
          t.setAttribute("inputmode", "none"),
          t.setAttribute("autocorrect", "off"),
          t.setAttribute("autocapitalize", "none"),
          t.setAttribute("spellcheck", "false"),
          t.setAttribute("autocomplete", "off"),
          t.setAttribute("tabindex", r ? "0" : "-1"),
          ee(t).on("keydown", function () {
            this.readOnly = false, this.select();
          }).on("blur", function () {
            this.readOnly = true;
          }),
          t;
      }
      let e = document.createElement("textarea");
      return e.setAttribute("inputmode", "none"),
        e.setAttribute("autocorrect", "off"),
        e.setAttribute("autocapitalize", "none"),
        e.setAttribute("tabindex", r ? "0" : "-1"),
        e.setAttribute("spellcheck", "false"),
        e.setAttribute("autocomplete", "off"),
        e;
    },
    ...Vf(),
    quietEmptyDelimiters: "( [",
    resetCursorOnBlur: true,
    enableDigitGrouping: true,
    tripleDotsAreEllipsis: true,
    disableAutoSubstitutionInSubscripts: { except: "log" },
    interpretTildeAsSim: true,
  });
  var gc = EU;
  function Of(r) {
    let e = __dcg_shared_module_exports__["Sc"](r), t = 0;
    for (; !__dcg_shared_module_exports__["Uc"](e);) {
      t += 1, e = __dcg_shared_module_exports__["Tc"](e);
    }
    return t;
  }
  var Rf = class {
    constructor(e, t, o) {
      this.mathField = e;
      this.$mathField = t;
      this.props = o;
      this.wasFocusedLastUpdate = false;
      this.$mathField.on(
        "focusin.view focusout.view",
        (i) => this.onFocusEvent(i),
      );
    }
    willUnmount() {
      this.$mathField.off(".view");
    }
    updateMathquillFocused() {
      var o, i, n, a;
      if (!this.mathField) return;
      let e = this.isFocused(), t = this.shouldBeFocused();
      t && t !== this.wasFocusedLastUpdate &&
      (i = (o = this.props).selectOnFocus) != null && i.call(o) &&
      ((a = (n = this.mathField).select) == null || a.call(n)),
        this.wasFocusedLastUpdate = t,
        e !== t && (t ? this.mathField.focus() : this.mathField.blur());
    }
    isFocused() {
      var e;
      return !!(document.activeElement &&
        ((e = this.mathField) != null &&
          e.el().contains(document.activeElement)));
    }
    shouldBeFocused() {
      return this.props.isFocused();
    }
    onFocusEvent(e) {
      let t = this.isFocused();
      t !== this.shouldBeFocused() && this.props.onFocusedChanged(t, e);
    }
  };
  var N8 = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var $i = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var n0e = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var XS = { IS_HOVERED: 1.25, IS_PRESSED: 1.125, IS_GHOSTED: .4 },
    lw = { IS_HOVERED: .5, IS_DEPRESSED: .3 },
    _G = { IS_GHOSTED: .4 },
    JS = { IS_HOVERED: .3, IS_DEPRESSED: .5 },
    QS = { IS_GHOSTED: .4 },
    cw = 1;
  Ss();
  function dw(r) {
    let e = __dcg_shared_module_exports__["Wc"](r);
    if (e.type !== "Assignment") return NaN;
    if (e._expression.type !== "Constant") return NaN;
    if (
      !new __dcg_shared_module_exports__["ae"]({
        enableGeometry: false,
        enable3d: false,
        scales: void 0,
        includeFunctionParametersInRandomSeed: true,
        isComplexEnabled: false,
        customRegressions: true,
      }).validLHS(e._symbol)
    ) return NaN;
    if (__dcg_shared_module_exports__["qc"][e._symbol]) return NaN;
    let o = e._expression.asValue();
    return typeof o == "number" ? o : NaN;
  }
  function EZ(r) {
    return __dcg_shared_module_exports__["ca"](r) !== null;
  }
  var Ff = EZ;
  function ho(r, e) {
    if (!isFinite(r)) return r;
    if (!isFinite(e)) return e;
    let t = __dcg_shared_module_exports__["T"](r, e);
    if (r > 0 != e > 0 || r === 0 || e === 0) return 0;
    let o = r > 0 ? 1 : -1,
      i = Math.abs(r).toExponential().split("e"),
      n = Math.abs(e).toExponential().split("e"),
      a = i[0],
      s = n[0],
      l = i[1],
      c = n[1];
    if (c !== l) {
      return o * Math.pow(10, Math.max(parseFloat(l), parseFloat(c)));
    }
    if (a[0] !== s[0]) return parseFloat(t.toPrecision(1));
    let d = 1;
    for (
      let p = 2;
      p < Math.min(a.length, s.length) && (d++, a[p] === s[p]);
      p++
    );
    return parseFloat(t.toPrecision(d));
  }
  var AG = 1e6;
  function ZS(r) {
    let e = Sg(r);
    if (!e) return false;
    switch (e) {
      case "anonymous-function":
      case "function-reference":
      case "point-list-reference":
      case "recursive-function":
        return true;
      case "point-list":
        return false;
    }
  }
  function Sg(r) {
    if (!r || r.type !== "expression") return;
    let e = r.formula,
      t = r.formula.recursion,
      o = r.formula.function_definition,
      i = IU(r, o);
    if (
      t && t.type === "iterative" && t.signature.argTypes.length === 1 &&
      t.returnType === __dcg_shared_module_exports__["Number"] &&
      r.formula.function_definition && i !== void 0 && isFinite(i) &&
      Math.abs(i) < AG
    ) return "recursive-function";
    if (e.is_tableable && e.table_info) {
      return mc(r)
        ? e.table_info.by_reference ? "point-list-reference" : "point-list"
        : e.table_info.by_reference
        ? "function-reference"
        : "anonymous-function";
    }
  }
  function DU(r) {
    let e = r.formula.table_info;
    if (!e) return;
    let t = [], o = [];
    if (e.values) {
      for (let i = 0; i < e.values.length; i++) {
        let n = e.values[i][0];
        t.push(isNaN(n) ? "" : __dcg_shared_module_exports__["be"](n));
        let a = e.values[i][1];
        o.push(isNaN(a) ? "" : __dcg_shared_module_exports__["be"](a));
      }
    }
    return {
      headers: [e.independent_variable, e.dependent_column],
      values: [t, o],
    };
  }
  function kU(r) {
    let e = r.formula.table_info;
    if (e) {
      return {
        headers: [e.dependent_column + ".x", e.dependent_column + ".y"],
        values: [[], []],
      };
    }
  }
  var IG = ["-2", "-1", "0", "1", "2"];
  function _U(r) {
    let e = r.formula.table_info;
    if (e) {
      return e.dependent_column === e.independent_variable
        ? { headers: ["x", "1x"], values: [IG, []] }
        : {
          headers: [e.independent_variable, e.dependent_column],
          values: [IG, []],
        };
    }
  }
  function IU(r, e) {
    var t, o, i;
    if (e) {
      return (i = (o = (t = r.formula.recursion) == null
            ? void 0
            : t.recursiveStructure) == null
          ? void 0
          : o.baseCaseInfo[e]) == null
        ? void 0
        : i.min;
    }
  }
  function AU(r) {
    let e = r.formula.function_definition, t = r.formula.recursion;
    if (!e || !t) return;
    let o = IU(r, e);
    if (o === void 0) return;
    let i = [];
    for (let n = o; n <= o + 4; n++) i.push(`${n}`);
    return {
      headers: [
        "x",
        `${
          __dcg_shared_module_exports__["identifierToLatex"](e)
        }\\left(x\\right)`,
      ],
      values: [i, []],
    };
  }
  function MU(r) {
    let e = r.formula.function_definition;
    return e
      ? {
        headers: [
          "x",
          `${
            __dcg_shared_module_exports__["identifierToLatex"](e)
          }\\left(x\\right)`,
        ],
        values: [IG, []],
      }
      : void 0;
  }
  var eE = class {
    constructor(e, t) {
      this.cb = e;
      this.document = t;
      this.observedAriaLiveElements = new WeakMap();
      this.destroyed = false;
      this.onAriaLabelFocus = (e) => {
        let t = e.target;
        if (this.isElement(t)) {
          let o = t.getAttribute("aria-label");
          o && this.cb(o, "label");
        }
      };
      this.document.documentElement.addEventListener(
        "focus",
        this.onAriaLabelFocus,
        true,
      ),
        this.ariaLiveContentObserver = new MutationObserver((o) =>
          this.handleAriaLiveContentMutations(o)
        ),
        t.documentElement.querySelectorAll('[aria-live="assertive"]')
          .forEach((o) => this.startObservingAriaLiveElement(o)),
        this.treeObserver = new MutationObserver((o) =>
          this.handleDocumentTreeMutations(o)
        ),
        this.treeObserver.observe(t.documentElement, {
          childList: true,
          subtree: true,
          attributeFilter: ["aria-live"],
        });
    }
    destroy() {
      this.destroyed = true,
        this.document.documentElement.removeEventListener(
          "focus",
          this.onAriaLabelFocus,
          true,
        ),
        this.ariaLiveContentObserver.disconnect();
    }
    isObservingElement(e) {
      return !!this.observedAriaLiveElements.get(e);
    }
    handleAriaLiveContentMutations(e) {
      var o;
      let t = new Map();
      for (let i of e) {
        if (!this.observedAriaLiveElements.get(i.target)) continue;
        let n = t.get(i.target);
        n || (n = [], t.set(i.target, n)), n.push(i);
      }
      for (let [i, n] of t) {
        let a = i.cloneNode(true), s = [a.textContent || ""];
        for (let l = n.length - 1; l >= 0; l--) {
          let c = n[l];
          switch (c.type) {
            case "attributes": {
              c.attributeName !== null &&
              a.setAttribute(c.attributeName, c.oldValue || ""),
                s.push(a.textContent || "");
              break;
            }
            case "characterData": {
              c.oldValue !== null && (a.textContent = c.oldValue),
                a.textContent && a.textContent !== s[s.length - 1] &&
                s.push(a.textContent);
              break;
            }
            case "childList": {
              if (c.addedNodes.length > 1 || c.removedNodes.length > 1) {
                throw new Error(
                  `Expected at most one removed node and one added node, but got ${c.removedNodes.length} removed nodes and ${c.addedNodes.length} added nodes`,
                );
              }
              c.addedNodes.length === 1 &&
              ((o = a.firstChild) == null || o.remove()),
                c.removedNodes.length === 1 &&
                c.removedNodes.forEach((d) => a.appendChild(d.cloneNode(true))),
                a.textContent && a.textContent !== s[s.length - 1] &&
                s.push(a.textContent);
              break;
            }
          }
        }
        for (let l of s.reverse()) this.cb(l, "alert");
      }
    }
    startObservingAriaLiveElement(e) {
      this.destroyed ||
        e.getAttribute("aria-live") === "assertive" &&
          (this.observedAriaLiveElements.get(e) ||
            (this.observedAriaLiveElements.set(e, true),
              e.textContent && this.cb(e.textContent, "alert"),
              this.ariaLiveContentObserver.observe(e, {
                attributes: true,
                characterData: true,
                childList: true,
                attributeOldValue: true,
                characterDataOldValue: true,
              })));
    }
    stopObservingAriaLiveElement(e) {
      this.observedAriaLiveElements.set(e, false);
    }
    handleDocumentTreeMutations(e) {
      for (let t of e) {
        t.addedNodes.forEach((o) => {
          this.isElement(o) &&
            o.getAttribute("aria-live") === "assertive" &&
            this.startObservingAriaLiveElement(o);
        }),
          this.isElement(t.target) && t.attributeName === "aria-live" &&
          (t.target.getAttribute("aria-live") === "assertive"
            ? this.startObservingAriaLiveElement(t.target)
            : this.stopObservingAriaLiveElement(t.target)),
          t.removedNodes.forEach((o) => {
            this.isElement(o) &&
              (this.stopObservingAriaLiveElement(o),
                o.querySelectorAll('[aria-live="assertive"]').forEach(
                  (i) => this.stopObservingAriaLiveElement(i),
                ));
          });
      }
    }
    isElement(e) {
      var o;
      let t = (o = this.document.defaultView) == null ? void 0 : o.Element;
      return t ? e instanceof t : false;
    }
  };
  var dd, tE = [], GU = "", TZ;
  function Si() {
    dd && (dd.textContent = "");
  }
  function yt(r) {
    tE.push(r);
  }
  function xe(r) {
    if (r !== void 0 && yt(r), dd && tE.length > 0) {
      let e = tE.join(" ").replace(/ +(?= )/g, "");
      dd.setAttribute(
        "aria-relevant",
        GU === e && Zo ? "all" : "additions text",
      ),
        dd.textContent = e,
        GU = e;
    }
    tE.length = 0;
  }
  function DZ() {
    dd = document.createElement("p"),
      dd.setAttribute("aria-live", "assertive"),
      dd.setAttribute("aria-atomic", "true"),
      dd.classList.add("dcg-aria-alert"),
      document.body.appendChild(dd),
      ku("logAria") &&
      (TZ = new eE(
        (r, e) => __dcg_shared_module_exports__["qe"].log(`[aria ${e}] ${r}`),
        document,
      ));
  }
  dU(DZ);
  function kZ(r) {
    return r.replace(
      new RegExp("(?<!\\\\left|\\\\sqrt)(\\[|\\(|\\\\\\{)", "g"),
      "\\left$1",
    ).replace(
      new RegExp("(?<!\\\\right)(\\]|\\)|\\\\\\})(?!{)", "g"),
      "\\right$1",
    );
  }
  function _Z(r) {
    return r.replace(/\\ |\\space(?![a-zA-Z])/g, " ");
  }
  function rE(r) {
    if (!r || r.args.length === 0) return;
    let e = r.args[r.args.length - 1];
    switch (e.isTrailing = true, e.type) {
      case "Sqrt":
      case "LeftRight":
        rE(e.arg);
        break;
      case "Frac":
        rE(e.num), rE(e.den);
        break;
      case "TokenNode":
      case "SupSub":
      case "Other":
        break;
      default:
    }
  }
  function MG(r) {
    return { type: "Other", originalType: r.type, val: r.val };
  }
  function IZ(r) {
    switch (r.type) {
      case "Cmd": {
        if (!__dcg_shared_module_exports__["Kc"](r.val)) return MG(r);
        let e = r.val.match(/^\\([a-zA-Z]+)/);
        if (!e) return MG(r);
        let t = e[1], o = [];
        for (let i of t) {
          o.push({ type: "Other", originalType: "Letter", val: i });
        }
        return o;
      }
      case "OperatorName":
        return pd(r.arg).args;
      case "EscapedSymbol":
      case "Letter":
      case "Digit":
      case "Symbol":
        return MG(r);
      case "Sqrt":
        return {
          type: "Sqrt",
          optArg: r.optArg && pd(r.optArg),
          arg: pd(r.arg),
        };
      case "Frac":
        return { type: "Frac", num: pd(r.num), den: pd(r.den) };
      case "TokenNode":
        return { type: "TokenNode", arg: pd(r.arg) };
      case "SupSub":
        return {
          type: "SupSub",
          sup: r.sup && pd(r.sup),
          sub: r.sub && pd(r.sub),
          nprimes: r.nprimes,
        };
      case "LeftRight":
        return {
          type: "LeftRight",
          left: r.left,
          right: r.right,
          arg: pd(r.arg),
        };
      default:
        throw new Error(`Programming Error: Invalid atom type ${r.type}`);
    }
  }
  function pd(r) {
    let e = [];
    for (let t of r.args) {
      let o = IZ(t);
      Array.isArray(o) ? e.push(...o) : e.push(o);
    }
    return { type: "Group", args: e };
  }
  function LU(r) {
    try {
      let e = kZ(_Z(r)), t = __dcg_shared_module_exports__["Vc"](e);
      return pd(t);
    } catch (e) {
      return;
    }
  }
  function VU(r) {
    let e = LU(r);
    if (e === void 0) return () => false;
    let t = e;
    rE(t);
    function o(i) {
      let n = LU(i);
      return n === void 0 ? false : Ou(t, n);
    }
    return o;
  }
  function Ou(r, e) {
    if (!e) return false;
    for (let t = 0; t < e.args.length; t++) {
      if (OU(r, e, t) || AZ(r, e.args[t])) return true;
    }
    return false;
  }
  function AZ(r, e) {
    switch (e.type) {
      case "Sqrt":
        return Ou(r, e.arg) || Ou(r, e.optArg);
      case "Frac":
        return Ou(r, e.num) || Ou(r, e.den);
      case "SupSub":
        return Ou(r, e.sup) || Ou(r, e.sub);
      case "LeftRight":
        return Ou(r, e.arg);
      case "TokenNode":
        return false;
      case "Other":
        return false;
      default:
        throw new Error(`Programming Error: Invalid atom type ${e.type}`);
    }
  }
  function OU(r, e, t) {
    if (r.args.length > e.args.length - t) return false;
    for (let o = 0; o < r.args.length; o++) {
      if (!MZ(r.args[o], e.args[o + t])) return false;
    }
    return true;
  }
  function Vu(r, e, t) {
    return !r && !e
      ? true
      : !r || !e
      ? false
      : r.args.length === 0
      ? true
      : r.args.length > e.args.length ||
          !(t != null && t.allowPrefix) && r.args.length < e.args.length
      ? false
      : OU(r, e, 0);
  }
  function MZ(r, e) {
    let t = !!r.isTrailing;
    switch (r.type) {
      case "Sqrt":
        return e.type === "Sqrt" && Vu(r.optArg, e.optArg) &&
          Vu(r.arg, e.arg);
      case "Frac":
        return e.type === "Frac" && Vu(r.num, e.num) && Vu(r.den, e.den);
      case "SupSub":
        return e.type === "SupSub" && r.nprimes <= e.nprimes &&
          (!r.sup || Vu(r.sup, e.sup)) &&
          Vu(r.sub, e.sub, { allowPrefix: t });
      case "LeftRight":
        return e.type === "LeftRight" && PU(r.left, e.left) &&
          PU(r.right, e.right) && Vu(r.arg, e.arg, { allowPrefix: t });
      case "TokenNode":
        return e.type === "TokenNode" && Vu(r.arg, e.arg);
      case "Other":
        return r.type === e.type && r.val === e.val;
    }
  }
  function PU(r, e) {
    return r.type === e.type && r.val === e.val;
  }
  function GZ(r) {
    return r.replace(/[/\-\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  function RU(r) {
    let e = GZ(r);
    return e = e.replace(/\\\\ /g, "\\\\? "),
      e = e.replace(/\\\\([A-Za-z]+) ?/g, "\\\\?$1 ?"),
      new RegExp(e);
  }
  var FU = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  };
  function LG(r) {
    let e = [], t = r.toLowerCase();
    if (t.slice(0, 3) === "rgb") {
      try {
        e = t.replace(/[^\d,]/g, "").split(",").slice(0, 3).map((o) =>
          parseInt(o, 10)
        );
      } catch (o) {
        GG(r);
      }
    } else if (t[0] === "#") {
      let o = /^#?([a-f\d])([a-f\d])([a-f\d])$/;
      t = t.replace(o, (i, n, a, s) => n + n + a + a + s + s);
      try {
        e = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/.exec(t).slice(1)
          .map((i) => parseInt(i, 16));
      } catch (i) {
        GG(r);
      }
    } else e = FU[t];
    return LZ(e) || GG(r), { R: e[0], G: e[1], B: e[2] };
  }
  function LZ(r) {
    return !__dcg_shared_module_exports__["G"](r) || r.length !== 3
      ? false
      : __dcg_shared_module_exports__["j"](
        r,
        (e) => Number.isInteger(e) && e >= 0 && e <= 255,
      );
  }
  function GG(r) {
    throw new Error("Invalid color string: " + r);
  }
  function NU(r) {
    let e = r.R / 255, t = r.G / 255, o = r.B / 255, i = [];
    return i[0] = .49 * e + .31 * t + .2 * o,
      i[1] = .17697 * e + .8124 * t + .01063 * o,
      i[2] = .01 * t + .99 * o,
      i = __dcg_shared_module_exports__["h"](i, (n) => n / .17697),
      { X: i[0], Y: i[1], Z: i[2] };
  }
  function BU(r) {
    let i = r.X, n = r.Y, a = r.Z, s = [];
    return s[0] = 116 * pw(n / 100) - 16,
      s[1] = 500 * (pw(i / 95.047) - pw(n / 100)),
      s[2] = 200 * (pw(n / 100) - pw(a / 108.883)),
      { L: s[0], a: s[1], b: s[2] };
  }
  function pw(r) {
    let e = .20689655172413793;
    return r > Math.pow(e, 3) ? Math.pow(r, 1 / 3) : r / (3 * e * e) + 4 / 29;
  }
  function PZ(r, e) {
    let l = r.L,
      c = r.a,
      d = r.b,
      p = e.L,
      h = e.a,
      u = e.b,
      f = l - p,
      y = Math.sqrt(c * c + d * d),
      C = Math.sqrt(h * h + u * u),
      E = y - C,
      v = c - h,
      w = d - u,
      S = Math.sqrt(v * v + w * w - E * E),
      k = 1 + .045 * y,
      _ = 1 + .015 * y,
      A = f / (1 * 1),
      P = E / (1 * k),
      O = S / (1 * _);
    return Math.sqrt(A * A + P * P + O * O);
  }
  function VZ(r, e) {
    let t = BU(NU(LG(r))), o = BU(NU(LG(e)));
    return PZ(t, o);
  }
  function UU(r, e) {
    let t = __dcg_shared_module_exports__["h"](e, (i) => VZ(r, i)),
      o = __dcg_shared_module_exports__["o"](t);
    return e[t.indexOf(o)];
  }
  function OZ({ R: r, G: e, B: t }) {
    return .2126729 * (r / 255) ** 2.4 + .7151522 * (e / 255) ** 2.4 +
      .072175 * (t / 255) ** 2.4;
  }
  var PG = .342;
  function VG(r, e = false, t = PG) {
    if (typeof r != "string" || !r) return false;
    try {
      let o = LG(r);
      return OZ(o) > t ? !e : e;
    } catch (o) {
      return false;
    }
  }
  function qU(r, e) {
    let t = __dcg_shared_module_exports__["toFraction"](r),
      o = __dcg_shared_module_exports__["toFraction"](e);
    if (
      !__dcg_shared_module_exports__["Y"](t.n / t.d, r) ||
      !__dcg_shared_module_exports__["Y"](o.n / o.d, e)
    ) return;
    let i = __dcg_shared_module_exports__["lcm"](t.d, o.d),
      n = t.n * (i / t.d),
      s = o.n * (i / o.d) - n;
    return { nstart: n, nstep: s, lcm: i };
  }
  function FZ(r) {
    return isFinite(r)
      ? __dcg_shared_module_exports__["truncatedLatexLabel"](r, {
        digits: 8,
        bigCutoff: 1e6,
        smallCutoff: .001,
      })
      : "\\mathrm{undefined}";
  }
  function NZ(r) {
    return !isFinite(r[0]) || !isFinite(r[1])
      ? "\\mathrm{undefined}"
      : __dcg_shared_module_exports__["complexNumberLabel"](r, {
        digits: 5,
        bigCutoff: 1e6,
        smallCutoff: .001,
      });
  }
  function BZ(r) {
    return Array.isArray(r) ? r[1] !== 0 : false;
  }
  function KU(r) {
    return r.length >= 1 && r.every(BZ);
  }
  function UZ(r, e, t, o) {
    let i = r.columnModels[e];
    i.error = t.error,
      i.computed = t.computed && !!i.latex,
      i.draggable = !t.error && !t.computed,
      i.dependsOnRegression = !!t.depends_on_regression,
      i.dependsOnRecursion = !!t.depends_on_recursive_function,
      i.packedErrors = [],
      i.computedValues = [],
      i.hasNanOrErrorValue = false,
      i.hasComplexValue = false;
    for (let n = t.values.length - 1; n >= 0; n--) {
      let a = t.values[n];
      typeof a == "number"
        ? (i.computedValues[n] = FZ(a),
          isNaN(a) && (i.hasNanOrErrorValue = true))
        : Array.isArray(a)
        ? (i.computedValues[n] = NZ(a),
          (isNaN(a[0]) || isNaN(a[1])) && (i.hasNanOrErrorValue = true),
          a[1] !== 0 && (i.hasComplexValue = true))
        : (i.computedValues[n] = "",
          i.packedErrors[n] = a,
          i.hasNanOrErrorValue = true);
    }
    if (
      i.suppressIcon = o || e > 0 && KU(t.values), t.plotted && !i.suppressIcon
    ) {
      for (let n = 0; n < t.values.length; n++) {
        if (i.packedErrors[n]) continue;
        let a = t.values[n];
        Array.isArray(a) && a[1] !== 0 && !isNaN(a[1]) &&
          (i.packedErrors[n] = __dcg_shared_module_exports__["Lb"]()
            .getError());
      }
    }
  }
  function WU(r) {
    let e = wa(r);
    if (!e) return;
    let t = Eg(r);
    if (!t) {
      r.isExpanded || Nf(r, true);
      return;
    }
    e.row >= t.min && e.row < t.max && Nf(r, true);
  }
  function Eg(r) {
    if (r.isExpanded) return;
    let e = Pl(r);
    if (!(e < 30)) return { min: 8, max: e - 4 };
  }
  function $U(r, e) {
    let t = r.columnModels[e];
    return {
      values: t.values.slice(),
      dragMode: t.dragMode,
      hidden: t.hidden,
      id: t.id,
      color: t.color,
      points: t.points,
      lines: t.lines,
      pointStyle: t.pointStyle,
      lineStyle: t.lineStyle,
      latex: t.latex,
      colorLatex: t.colorLatex,
      lineOpacity: t.lineOpacity,
      lineWidth: t.lineWidth,
      pointSize: t.pointSize,
      pointOpacity: t.pointOpacity,
      disableGraphInteractions: t.disableGraphInteractions,
    };
  }
  var zZ = 0;
  function qZ() {
    return "table_guid_" + zZ++;
  }
  function HZ(r, e, t) {
    r.columnModels[e].values.splice(t, 0, "");
  }
  function KZ(r, e, t) {
    r.columnModels[e].values.splice(t, 1);
  }
  function jU(r, e, t) {
    let { color: o } = t;
    (!o || !Ff(o)) && (o = r.controller.getNextColor());
    let i = {
      ...t,
      type: "table-column",
      guid: qZ(),
      index: e,
      error: void 0,
      table: r,
      color: o,
      packedErrors: [],
      computedValues: [],
      shouldGraph: void 0,
      computed: void 0,
      draggable: void 0,
      hasNanOrErrorValue: false,
      dependsOnRegression: false,
      dependsOnRecursion: false,
      hasComplexValue: false,
      suppressIcon: false,
    };
    return e === 0 && (i.hidden = true), i;
  }
  function hw(r, e) {
    let t = r.table.formula;
    if (!t) return false;
    let o = t.column_data[r.index];
    return o ? !!o[e] : false;
  }
  function YU(r) {
    return hw(r, "color_latex_valid");
  }
  function XU(r) {
    return hw(r, "line_opacity_valid");
  }
  function JU(r) {
    return hw(r, "line_width_valid");
  }
  function QU(r) {
    return hw(r, "point_size_valid");
  }
  function ZU(r) {
    return hw(r, "point_opacity_valid");
  }
  function ez(r) {
    let e = r.table.formula;
    if (!e) return;
    let t = e.column_data[r.index];
    if (t) return t.color_latex_value;
  }
  function tz(r) {
    r.draggingOnGraphpaper
      ? r.preTransientState ||
        (r.preTransientState = {
          columns: Bf(r, { stripDefaults: false }).columns,
        })
      : delete r.preTransientState, hd(r);
    let e = Ca(r), t = e && e.hidden;
    __dcg_shared_module_exports__["g"](r.columnModels, (o) => {
      o.shouldGraph = !t && !o.hidden && !r.controller.is3dProduct();
    }),
      $Z(r),
      jZ(r),
      WZ(r);
  }
  function Pl(r) {
    let e = 2, t, o = wa(r);
    return o && o.row > e && (e = o.row),
      r.columnModels.forEach((i) => {
        t = i.computed ? i.computedValues.length : i.values.length + 1,
          t > e && (e = t);
      }),
      e;
  }
  function gw(r) {
    return r.columnModels.length;
  }
  function rz(r, e) {
    var o;
    r.formula = e;
    let t = r.controller.is3dProduct() || KU(e.column_data[0].values);
    for (let i = 0; i < e.column_data.length && i < gw(r); i++) {
      let n = e.column_data[i];
      UZ(r, i, n, t);
    }
    ((o = e.table_regression) == null ? void 0 : o.status) ===
        "success" &&
      r.regression &&
      (r.regression.residualVariable =
        e.table_regression.result.residualVariable);
  }
  function OG(r, e) {
    for (let t = 0; t < r.columnModels.length; t++) HZ(r, t, e);
  }
  function oz(r, e) {
    let t = Eg(r);
    t && e === t.max - 1 && Nf(r, true);
    for (let o = 0; o < r.columnModels.length; o++) {
      KZ(r, o, e), o > 0 && vz(r.columnModels[o]);
    }
  }
  function oE(r, e) {
    let t = {
        id: r.controller.generateId(),
        latex: e ? e.latex : "",
        color: r.controller.getNextColor(),
      },
      o = e ? e.columnIndex : r.columnModels.length,
      i = { ...dg, ...t, values: [] },
      n = jU(r, o, i);
    r.columnModels.splice(o, 0, n);
    for (let a = o + 1; a < r.columnModels.length; a++) {
      r.columnModels[a].index = a;
    }
  }
  function mw(r, e) {
    var o;
    let [t] = r.columnModels.splice(e, 1);
    for (let i = e; i < r.columnModels.length; i++) {
      r.columnModels[i].index = i;
    }
    t && ((o = r.regression) == null ? void 0 : o.columnIds.y) === t.id &&
      bw(r, void 0);
  }
  function iz(r, e) {
    let t, o = r.columnModels.length, i = [];
    for (t = 0; t < o; t++) i.push("");
    let n = r.columnModels[0].values;
    if (e > 1) {
      let a = r.controller.getDegreeMode(),
        s = io(n[0], a),
        l = io(n[1], a);
      if (isFinite(s) && isFinite(l)) {
        let c = qU(s, l);
        if (c) {
          let d = c.nstart, p = d / c.lcm;
          for (t = 0; t < e; t++) {
            let h = io(n[t], a);
            if (!__dcg_shared_module_exports__["Y"](h, p)) return i;
            d += c.nstep, p = d / c.lcm;
          }
          ("" + s).length < 8 && ("" + l).length < 8
            ? i[0] = "" + p
            : i[0] = "\\frac{" + d + "}{" + c.lcm + "}";
        }
      }
    }
    return i;
  }
  function fw(r, e, t) {
    for (let o = 0; o < r.columnModels.length; o++) {
      let i = r.columnModels[o],
        n = { cellLocation: { column: o, row: 0 } };
      if (e(i.latex, "tableHeader", n), t != null && t.headersOnly) {
        continue;
      }
      e(i.colorLatex, "tableColumnColorLatex", n),
        e(i.pointSize, "tableColumnPointSize", n),
        e(i.pointOpacity, "tableColumnPointOpacity", n),
        e(i.lineWidth, "tableColumnLineWidth", n),
        e(i.lineOpacity, "tableColumnLineOpacity", n);
      let a = r.columnModels[o];
      for (let s = 0; s < a.values.length; s++) {
        a.values[s] &&
          e(a.values[s], "tableCellValue", {
            cellLocation: { column: o, row: s + 1 },
          });
      }
    }
  }
  function WZ(r) {
    let e = $C({
      type: "table",
      id: r.id,
      secret: r.secret,
      readonly: r.readonly,
      folderId: r.folderId,
      columns: r.columnModels.map((o) => $U(r, o.index)),
      regression: __dcg_shared_module_exports__["Jc"](r.regression),
    });
    for (let o = 0; o < e.columns.length; o++) {
      e.columns[o].hidden = !r.columnModels[o].shouldGraph;
    }
    r.cachedParsableState = e;
    let t = r.regression;
    if (e.regression && t) {
      let o = Ca(r);
      o && o.hidden && (e.regression = { ...e.regression, hidden: true });
    }
  }
  function nz(r) {
    return r.slice(0, r.length - 1);
  }
  function Bf(r, e) {
    let t = {
      ...r.cachedViewState,
      columns: nz(r.cachedViewState.columns),
    };
    return e.stripDefaults
      ? uN(t)
      : (t.regression === void 0 && delete t.regression, t);
  }
  function $Z(r) {
    let e = r.columnModels.map((t, o) => $U(r, o));
    r.cachedViewState = {
      id: r.id,
      type: r.type,
      folderId: r.folderId,
      columns: e,
      secret: r.secret,
      readonly: r.readonly,
      regression: __dcg_shared_module_exports__["Jc"](r.regression),
    };
  }
  function RG(r, e) {
    r.draggingOnGraphpaper = e;
  }
  function jZ(r) {
    let e = {
      ...r.cachedViewState,
      columns: nz(r.cachedViewState.columns),
      regression: __dcg_shared_module_exports__["Jc"](r.regression),
    };
    r.cachedUndoRedoFullState = e,
      r.preTransientState && (e = { ...e, ...r.preTransientState }),
      r.cachedUndoRedoDiffState = e;
  }
  var YZ = {
    id: false,
    type: false,
    columns: false,
    regression: true,
    folderId: true,
    secret: true,
    readonly: true,
    disableGraphInteractions: true,
  };
  function az(r, e) {
    __dcg_shared_module_exports__["rd"]({ from: e, to: r, props: YZ }),
      lz(r, e.columns);
  }
  function sz(r, e) {
    let t = __dcg_shared_module_exports__["Jc"](WC(r)),
      o = {
        ...t,
        ...ud(e),
        columnModels: void 0,
        formula: void 0,
        draggingOnGraphpaper: false,
        cachedViewState: {},
        cachedParsableState: {},
        cachedUndoRedoDiffState: {},
        cachedUndoRedoFullState: {},
        isExpanded: false,
      };
    return lz(o, t.columns), o;
  }
  function lz(r, e) {
    r.columnModels = e.map((t, o) => jU(r, o, t)), oE(r);
  }
  var HU = ["x", "y", "z", "u", "v", "w"];
  function FG(r, e, t) {
    let o = [], i = Math.min(e.length, HU.length);
    for (let n = 0; n < i; n++) {
      o.push({
        id: t.generateId(),
        latex: __dcg_shared_module_exports__["identifierToLatex"](
          HU[n] + "_" + r,
        ),
        values: e[n],
        color: t.getNextColor(),
        hidden: false,
        points: true,
        lines: false,
        dragMode: "NONE",
        pointStyle: "POINT",
        lineStyle: "SOLID",
        colorLatex: "",
        lineWidth: "",
        lineOpacity: "",
        pointOpacity: "",
        pointSize: "",
        disableGraphInteractions: false,
      });
    }
    return {
      id: t.generateId(),
      type: "table",
      folderId: "",
      secret: false,
      readonly: false,
      columns: o,
    };
  }
  function cz(r, e) {
    let t = Bf(r, { stripDefaults: false });
    if (!t.columns || !e.columns) return e;
    for (let o = 0; o < e.columns.length; o++) {
      let i = t.columns[o], n = e.columns[o];
      if (i) {
        for (let a in i) {
          i.hasOwnProperty(a) && (n.hasOwnProperty(a) || (n[a] = i[a]));
        }
      }
    }
    return e;
  }
  function wa(r) {
    if (!r) return;
    let e = r.controller.getFocusLocation();
    if (e && e.type === "table" && e.id === r.id) return e.location;
  }
  function Eo(r, e) {
    for (let t = 0; t < r.columnModels.length; t++) {
      let o = r.columnModels[t];
      if (o.id === e) return o;
    }
  }
  function NG(r, e, t) {
    let o = Eo(r, e);
    o && (o.points = t, t || (o.dragMode = "NONE"));
  }
  function dz(r, e, t) {
    let o = Eo(r, e);
    o && (o.pointStyle = t);
  }
  function pz(r, e, t) {
    let o = Eo(r, e);
    o && (o.lines = t);
  }
  function uz(r, e, t) {
    let o = Eo(r, e);
    o && (o.lineStyle = t);
  }
  function iE(r, e, t) {
    let o = Eo(r, e);
    o && (o.lineWidth = t);
  }
  function nE(r, e, t) {
    let o = Eo(r, e);
    o && (o.lineOpacity = t);
  }
  function aE(r, e, t) {
    let o = Eo(r, e);
    o && (o.pointSize = t);
  }
  function sE(r, e, t) {
    let o = Eo(r, e);
    o && (o.pointOpacity = t);
  }
  function hz(r, e, t) {
    let o = Eo(r, e);
    if (o) {
      if (t.type === "inert") {
        o.disableGraphInteractions = t.disableGraphInteractions,
          t.disableGraphInteractions && (o.dragMode = "NONE");
      } else {
        let i = t.dragMode;
        o.dragMode = i,
          i !== "NONE" && !o.points && (o.points = true),
          i !== "NONE" && (o.disableGraphInteractions = false);
      }
    }
  }
  function gz(r, e, t) {
    hz(r, e, { type: "draggable", dragMode: t });
  }
  function mz(r, e, t) {
    let o = Eo(r, e);
    !o || !Ff(t) || (o.color = t, o.colorLatex = "");
  }
  function fz(r, e) {
    r.regression && (r.regression.color = e);
  }
  function bz(r, e) {
    r.regression && (r.regression.isLogMode = e);
  }
  function lE(r, e, t) {
    let o = Eo(r, e);
    o && (o.colorLatex = t);
  }
  function Nf(r, e) {
    r.isExpanded = e;
  }
  function yz(r, e, t) {
    let o = Eo(r, e);
    o && (o.hidden = t, t && wz(r));
  }
  function xz(r, e, t) {
    let o = Eo(r, e);
    o && (o.boundingBoxes = t, wz(r));
  }
  function wz(r) {
    let e = [];
    r.columnModels.forEach((t) => {
      t.boundingBoxes && !t.hidden && (e = e.concat(t.boundingBoxes));
    }), r.boundingBoxes = e;
  }
  function cE(r, e) {
    let t = Eo(r, e);
    return t ? !t.points && !t.lines : true;
  }
  function vp(r, e, t) {
    if (e.row === 0) {
      let i = r.columnModels[e.column].id, n = Eo(r, i);
      if (!n) return;
      n.latex = t, e.column >= r.columnModels.length - 1 && oE(r);
      return;
    }
    let o = r.columnModels[e.column];
    for (let i = o.values.length; i < e.row - 1; i++) o.values[i] = "";
    r.columnModels[o.index].values[e.row - 1] = t,
      e.column > 0 && vz(r.columnModels[o.index]);
  }
  function vz(r) {
    for (; r.values.length > 0 && !r.values[r.values.length - 1];) {
      r.values.pop();
    }
  }
  function Cz(r, e) {
    return !!r.columnModels[e.column] && e.row >= 0;
  }
  function Sz(r) {
    let e;
    if (r.values) { for (e of r.values) if (e !== "") return false; }
    if (r.computedValues) {
      for (e of r.computedValues) if (e !== "") return false;
    }
    return true;
  }
  function Ez(r) {
    return r.computed;
  }
  function Uf(r) {
    return r.computed || r.index === r.table.columnModels.length - 1;
  }
  function Tz(r, e) {
    hz(r.table, r.id, { type: "inert", disableGraphInteractions: e });
  }
  function dE(r, e, t) {
    let o = r.columnModels[t];
    return o.computed ? o.computedValues[e] || "" : o.values[e] || "";
  }
  function Dz(r) {
    let e = Pl(r), t = gw(r);
    for (let o = 0; o < t; o++) if (dE(r, e - 1, o) !== "") return false;
    return true;
  }
  function bw(r, e) {
    var o, i;
    let t = !__dcg_shared_module_exports__["E"](
      (o = r.regression) == null ? void 0 : o.columnIds,
      e == null ? void 0 : e.columnIds,
    ) ||
      ((i = r.regression) == null ? void 0 : i.type) !==
        (e == null ? void 0 : e.type);
    r.regression = e,
      r.regression && t && (r.regression.residualVariable = void 0);
  }
  function Cp(r) {
    return !!r.latex && !r.error && !r.dependsOnRegression &&
      !r.dependsOnRecursion;
  }
  function Ru(r) {
    return r.computedValues.length >= 2 && !r.hasNanOrErrorValue &&
      !r.hasComplexValue;
  }
  function kz(r) {
    var i, n;
    let e = r.regression;
    if (!e) return;
    let t = (i = r.columnModels.find((a) => a.id === e.columnIds.x)) == null
        ? void 0
        : i.latex,
      o = (n = r.columnModels.find((a) => a.id === e.columnIds.y)) == null
        ? void 0
        : n.latex;
    return t && o ? [t, o] : void 0;
  }
  var XZ = 30,
    JZ = 10,
    pE = __dcg_shared_module_exports__["Rd"].RED,
    uE = __dcg_shared_module_exports__["Rd"].BLUE,
    hE = __dcg_shared_module_exports__["Rd"].GREEN,
    gE = __dcg_shared_module_exports__["Rd"].PURPLE,
    mE = __dcg_shared_module_exports__["Rd"].ORANGE,
    zf = __dcg_shared_module_exports__["Rd"].BLACK;
  function md(r, e) {
    switch (e) {
      case __dcg_shared_module_exports__["Rd"].RED:
        return r.s("graphing-calculator-text-color-red");
      case __dcg_shared_module_exports__["Rd"].BLUE:
        return r.s("graphing-calculator-text-color-blue");
      case __dcg_shared_module_exports__["Rd"].GREEN:
        return r.s("graphing-calculator-text-color-green");
      case __dcg_shared_module_exports__["Rd"].PURPLE:
        return r.s("graphing-calculator-text-color-purple");
      case __dcg_shared_module_exports__["Rd"].ORANGE:
        return r.s("graphing-calculator-text-color-orange");
      case __dcg_shared_module_exports__["Rd"].BLACK:
        return r.s("graphing-calculator-text-color-black");
      case __dcg_shared_module_exports__["Rd"].GRAY:
        return r.s("graphing-calculator-text-color-gray");
      default:
        let { r: t, g: o, b: i } = __dcg_shared_module_exports__["Nd"](e),
          n = Math.max(t, o, i),
          a = Math.min(t, o, i),
          s = n / 255,
          l = n === 0 ? 0 : (n - a) / n,
          c = 0;
        n !== a &&
        (n === t
          ? c = (o - i) / (n - a) + (o < i ? 6 : 0)
          : n === o
          ? c = (i - t) / (n - a) + 2
          : c = (t - o) / (n - a) + 4,
          c /= 6),
          c *= 360,
          l *= 100;
        let d = s * 100;
        return d < 10
          ? r.s("graphing-calculator-text-color-black")
          : l < 10
          ? d > 90
            ? r.s("graphing-calculator-text-color-white")
            : d > 75
            ? r.s("graphing-calculator-text-color-light-gray")
            : d > 50
            ? r.s("graphing-calculator-text-color-gray")
            : r.s("graphing-calculator-text-color-dark-gray")
          : c >= 0 && c < 15
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-red")
            : d < 75
            ? r.s("graphing-calculator-text-color-red")
            : r.s("graphing-calculator-text-color-light-red")
          : c >= 15 && c < 45
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-orange")
            : d < 75
            ? r.s("graphing-calculator-text-color-orange")
            : r.s("graphing-calculator-text-color-light-orange")
          : c >= 45 && c < 75
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-yellow")
            : d < 75
            ? r.s("graphing-calculator-text-color-yellow")
            : r.s("graphing-calculator-text-color-light-yellow")
          : c >= 75 && c < 105
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-lime")
            : d < 75
            ? r.s("graphing-calculator-text-color-lime")
            : r.s("graphing-calculator-text-color-light-lime")
          : c >= 105 && c < 135
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-green")
            : d < 75
            ? r.s("graphing-calculator-text-color-green")
            : r.s("graphing-calculator-text-color-light-green")
          : c >= 135 && c < 165
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-cyan")
            : d < 75
            ? r.s("graphing-calculator-text-color-cyan")
            : r.s("graphing-calculator-text-color-light-cyan")
          : c >= 165 && c < 195
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-teal")
            : d < 75
            ? r.s("graphing-calculator-text-color-teal")
            : r.s("graphing-calculator-text-color-light-teal")
          : c >= 195 && c < 225
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-blue")
            : d < 75
            ? r.s("graphing-calculator-text-color-blue")
            : r.s("graphing-calculator-text-color-light-blue")
          : c >= 225 && c < 255
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-indigo")
            : d < 75
            ? r.s("graphing-calculator-text-color-indigo")
            : r.s("graphing-calculator-text-color-light-indigo")
          : c >= 255 && c < 285
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-violet")
            : d < 75
            ? r.s("graphing-calculator-text-color-violet")
            : r.s("graphing-calculator-text-color-light-violet")
          : c >= 285 && c < 315
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-magenta")
            : d < 75
            ? r.s("graphing-calculator-text-color-magenta")
            : r.s("graphing-calculator-text-color-light-magenta")
          : c >= 315 && c < 345
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-pink")
            : d < 75
            ? r.s("graphing-calculator-text-color-pink")
            : r.s("graphing-calculator-text-color-light-pink")
          : c >= 345 && c <= 360
          ? d < 50
            ? r.s("graphing-calculator-text-color-dark-red")
            : d < 75
            ? r.s("graphing-calculator-text-color-red")
            : r.s("graphing-calculator-text-color-light-red")
          : r.s("graphing-calculator-text-color-unknown");
    }
  }
  var BG = (r) => {
    if (!Array.isArray(r)) return [r];
    let e = Array(Math.min(r.length, JZ));
    for (let t = 0; t < e.length; t++) {
      e[t] = r[Math.round(t * r.length / e.length)];
    }
    return e;
  };
  function _z(r, e) {
    switch (r.type) {
      case "single-color":
      case "color-array":
        return BG(r.value).every((o) => VG(o, e));
      case "shader":
      case "image":
        return false;
      default:
        let t = r;
        throw new Error("Unexpected ColorSwatchSpec type: " + t.type);
    }
  }
  function qf(r, e, t = PG) {
    switch (r.type) {
      case "single-color":
      case "color-array":
        return BG(r.value).some((i) => VG(i, e, t));
      case "shader":
      case "image":
        return true;
      default:
        let o = r;
        throw new Error("Unexpected ColorSwatchSpec type: " + o.type);
    }
  }
  var Hf = (r) => {
    switch (r.type) {
      case "single-color":
        return r.value;
      case "color-array":
        let e = BG(r.value);
        if (e.length === 0) {
          return __dcg_shared_module_exports__["Rd"].BLACK;
        }
        if (e.length === 1) return r.value[0];
        let t = XZ / e.length;
        return `linear-gradient(to right${
          e.reduce((i, n, a) =>
            `${i}, ${n} ${a * t}px, ${n} ${(a + 1) * t}px`, "")
        })`;
      case "shader":
        return "#808080";
      case "image":
        return 'url("' + r.value + '")';
      default:
        let o = r;
        throw new Error("Unexpected ColorSwatchSpec type: " + o.type);
    }
  };
  var QZ = 0;
  function ZZ() {
    return "abstract_item_" + QZ++;
  }
  function ud(r) {
    return {
      guid: ZZ(),
      controller: r,
      index: -1,
      displayIndex: "-1",
      secretIndex: "-1",
      isHiddenFromUI: true,
      renderShell: true,
    };
  }
  function fE(r, e) {
    r.secret = e;
  }
  function yw(r, e) {
    r.readonly = e;
  }
  function _n(r, e) {
    r.type !== "folder" && (r.folderId = e);
  }
  function hd(r) {
    r.isHiddenFromUI = UG(r);
  }
  function Az(r) {
    return r.isHiddenFromUI || r.filteredBySearch
      ? "none"
      : r.renderShell
      ? "shell"
      : "render";
  }
  function Fu(r) {
    let e = xw(r),
      t = e.type === "color-array"
        ? { type: "single-color", value: e.value[0] }
        : e;
    return Hf(t);
  }
  function xw(r) {
    if (!r.colorLatex) return { type: "single-color", value: r.color };
    if (/^data:image/.test(r.colorLatex)) {
      return { type: "image", value: r.colorLatex };
    }
    let e, t, o = false;
    return r.type === "expression"
      ? (e = yE(r), t = bE(r), o = r.formula.color_latex_valid === void 0)
      : r.type === "table-column" && (e = ez(r), t = YU(r)),
      t && e
        ? Array.isArray(e)
          ? { type: "color-array", value: e }
          : { type: "single-color", value: e }
        : o
        ? { type: "single-color", value: "#999" }
        : { type: "single-color", value: r.color };
  }
  function Ds(r) {
    return r.type === "expression" || r.type === "image" ||
        r.type === "table-column"
      ? !!r.disableGraphInteractions
      : false;
  }
  var ww = class {
    constructor(e, t) {
      this.exports = new Map();
      if (!t) return;
      let o = eee(e);
      for (
        let i of __dcg_shared_module_exports__["Mb"](t.definitionLevel)
      ) {
        this.exports.set(i, {
          name: i,
          isTableColumnAssignment: t.definitionLevel[i] === 1,
          isRegressionExport: o.has(i),
          isMultiplyDefined: !!t.multiplyDefined[i],
        });
      }
    }
    optimisticallyRegisterColumnName(e) {
      this.cachedLastSubscripts = void 0,
        !this.exports.get(e) &&
        this.exports.set(e, {
          name: e,
          isMultiplyDefined: false,
          isRegressionExport: false,
          isTableColumnAssignment: true,
        });
    }
    isDefined(e, t) {
      let o = this.exports.get(e);
      return t.includeRegressionExports ? !!o : o && !o.isRegressionExport;
    }
    isMultiplyDefined(e, t) {
      var o;
      return this.isDefined(e, t) &&
        !!((o = this.exports.get(e)) != null && o.isMultiplyDefined);
    }
    getLastSubscriptForName(e, t) {
      var o, i;
      if (e.includes("_")) {
        throw new Error(
          `Programming error: ${e} already has a subscript`,
        );
      }
      this.cachedLastSubscripts === void 0 &&
        (this.cachedLastSubscripts = {});
      for (let n of this.exports.values()) {
        if (!t.includeRegressionExports && n.isRegressionExport) continue;
        let [a, s] = n.name.split("_"), l = parseInt(s, 10);
        isNaN(l) ||
          a === e &&
            (this.cachedLastSubscripts[e] = Math.max(
              (o = this.cachedLastSubscripts[e]) != null ? o : 0,
              l,
            ));
      }
      return (i = this.cachedLastSubscripts[e]) != null ? i : -1;
    }
  };
  function eee(r) {
    var t, o, i, n, a;
    let e = new Set();
    for (let s of r) {
      if (
        s.type === "table" &&
        ((o = (t = s.formula) == null ? void 0 : t.table_regression) ==
              null
            ? void 0
            : o.status) === "success"
      ) {
        let l = s.formula.table_regression.result.residualVariable,
          c = __dcg_shared_module_exports__["latexToIdentifier"](l);
        e.add(c);
      } else if (s.type === "expression" && s.formula.is_regression) {
        let l = (i = s.formula.regression) == null
            ? void 0
            : i.residualVariable,
          c = l
            ? __dcg_shared_module_exports__["latexToIdentifier"](l)
            : void 0;
        c && e.add(c);
        for (
          let d
            of (a = (n = s.formula) == null ? void 0 : n.exported_variables) !=
                null
              ? a
              : []
        ) {
          d !== c && e.add(d);
        }
      }
    }
    return e;
  }
  function xE(r, e) {
    let t = r.cachedViewState;
    return e.stripDefaults ? __dcg_shared_module_exports__["wd"](t) : t;
  }
  function tee(r) {
    r.cachedViewState = {
      type: r.type,
      id: r.id,
      title: r.title,
      hidden: r.hidden,
      inFrontOfEverything: r.inFrontOfEverything,
      readonly: r.readonly,
      collapsed: r.collapsed,
      secret: r.secret,
    };
  }
  function ree(r) {
    r.cachedUndoRedoDiffState = r.cachedViewState,
      r.cachedUndoRedoFullState = r.cachedViewState;
  }
  function Mz(r, e) {
    return {
      ...__dcg_shared_module_exports__["Jc"](
        __dcg_shared_module_exports__["vd"](r),
      ),
      ...ud(e),
      cachedUndoRedoDiffState: {},
      cachedUndoRedoFullState: {},
      cachedViewState: {},
    };
  }
  function Gz(r) {
    oee(r), hd(r), tee(r), ree(r);
  }
  function oee(r) {
    let t = r.controller.getAllSelectedItems();
    r.collapsedChildIsSelected = r.collapsed &&
      __dcg_shared_module_exports__["k"](
        t,
        (o) => o.type !== "folder" && o.folderId === r.id,
      );
  }
  var iee = {
    id: false,
    type: false,
    hidden: true,
    secret: true,
    inFrontOfEverything: true,
    collapsed: true,
    title: true,
    readonly: true,
    disableGraphInteractions: true,
  };
  function Lz(r, e) {
    __dcg_shared_module_exports__["rd"]({ from: e, to: r, props: iee });
  }
  function Kf(r, e) {
    r.collapsed = e;
  }
  function Pz(r, e) {
    r.title = e;
  }
  function Vz(r, e) {
    r.hidden = e;
  }
  function Oz(r) {
    return r.hidden;
  }
  function Rz(r, e) {
    r.inFrontOfEverything = e;
  }
  var Wf = "dcg_geometry_toolbar_",
    Nz = {
      selection: { visible: true },
      "box-selection": { visible: true },
      "expression-edit": { visible: true },
      point: { visible: false },
      line: { visible: false },
      segment: { visible: false },
      ray: { visible: false },
      vector: { visible: false },
      circle: { visible: false },
      arc: { visible: false },
      parallel: { visible: false },
      perpendicular: { visible: false },
      anglebisector: { visible: false },
      midpoint: { visible: false },
      polygon: { visible: false },
      compass: { visible: false },
      angle: { visible: false },
      directedangle: { visible: false },
      reflect: { visible: false },
      translate: { visible: false },
      rotate: { visible: false },
      dilate: { visible: false },
    };
  function Bz(r) {
    if (r.toolbar !== "all") {
      if (r.toolbar === "custom") {
        let e = __dcg_shared_module_exports__["nd"](Nz, r.toolbarState),
          t = { toolbar: "custom" };
        return e !== void 0 && (t.toolbarState = e), t;
      }
      return r;
    }
  }
  function Uz(r) {
    return r === void 0 ? { toolbar: "all" } : r.toolbar === "custom"
      ? {
        toolbar: "custom",
        toolbarState: __dcg_shared_module_exports__["od"](
          Nz,
          r.toolbarState,
        ),
      }
      : r;
  }
  function zz(r, e) {
    return e.stripDefaults ? Bz(r.cachedViewState) : r.cachedViewState;
  }
  function zG(r) {
    return r.cachedUndoRedoDiffState;
  }
  function nee(r) {
    r.toolbar === "custom"
      ? r.cachedViewState = {
        toolbar: "custom",
        toolbarState: __dcg_shared_module_exports__["Jc"](r.toolbarState),
      }
      : r.cachedViewState = { toolbar: r.toolbar };
  }
  function qz(r) {
    nee(r), aee(r), r.__cachedToolbarState = void 0;
  }
  function Hz(r) {
    let e = [];
    for (let t in r.toolbarState) {
      let o = t, i = r.toolbarState[o];
      i.visible && i.disabledLatex &&
        e.push({
          type: "geometry-toolbar-predicate",
          id: `${Wf}${o}`,
          latex: i.disabledLatex,
        });
    }
    return e;
  }
  function Kz(r, e) {
    if (!r.toolbarState[e].disabledLatex) return;
    let t = r.formulas[e];
    if (t != null && t.error) {
      return {
        key: "shared-calculator-error-custom-toolbar-not-condition",
        vars: {},
      };
    }
  }
  function Wz(r, e, t) {
    let o = e.replace(Wf, "");
    o in r.toolbarState && (r.formulas[o] = t);
  }
  function aee(r) {
    let e = r.cachedViewState;
    r.cachedUndoRedoDiffState = e, r.cachedUndoRedoFullState = e;
  }
  function wE(r) {
    let e = Uz(r);
    return {
      toolbar: e.toolbar,
      toolbarState: e.toolbar === "custom" ? e.toolbarState : see(),
      formulas: {},
      selectedToolForGroup: {},
      __cachedToolbarState: void 0,
      cachedViewState: e,
      cachedUndoRedoDiffState: e,
      cachedUndoRedoFullState: e,
    };
  }
  function $z() {
    return wE(void 0);
  }
  function see() {
    return {
      selection: { visible: true },
      "box-selection": { visible: true },
      "expression-edit": { visible: true },
      point: { visible: true },
      line: { visible: true },
      segment: { visible: true },
      ray: { visible: true },
      vector: { visible: false },
      circle: { visible: true },
      arc: { visible: false },
      parallel: { visible: false },
      perpendicular: { visible: false },
      anglebisector: { visible: false },
      midpoint: { visible: false },
      polygon: { visible: false },
      compass: { visible: false },
      angle: { visible: false },
      directedangle: { visible: false },
      reflect: { visible: false },
      translate: { visible: false },
      rotate: { visible: false },
      dilate: { visible: false },
    };
  }
  function jz(r, e) {
    r.toolbar = e, r.__cachedToolbarState = void 0;
  }
  function Yz(r, e, t) {
    let { groups: o, items: i } = vw(r, t);
    for (let n of o) {
      let a = i[n];
      a != null && a.dropdown && a.dropdown.indexOf(e) !== -1 &&
      (r.selectedToolForGroup[a.group] = e),
        e !== "box-selection" &&
        (a == null ? void 0 : a.group) === "selection" &&
        (a != null && a.dropdown) &&
        (r.selectedToolForGroup.selection = a.dropdown[0]);
    }
    r.__cachedToolbarState = void 0;
  }
  function vE(r, e, t) {
    r.toolbarState[e] = {
      visible: t.visible,
      disabledLatex: t.disabledLatex,
    }, r.__cachedToolbarState = void 0;
  }
  function Tg(r, e) {
    return r.toolbar === "all"
      ? true
      : r.toolbar === "none"
      ? false
      : r.toolbarState[e].visible;
  }
  function $f(r, e) {
    var o;
    if (r.toolbar === "all") return true;
    let t = Tg(r, e);
    if (t && r.formulas[e]) {
      let i = r.formulas[e],
        n = (o = i == null ? void 0 : i.typed_constant_value) == null
          ? void 0
          : o.value;
      return typeof n == "number" ? !n : true;
    }
    return t || e === "selection";
  }
  function vw(r, e) {
    var i;
    if (
      ((i = r.__cachedToolbarState) == null ? void 0 : i.authorMode) === e
    ) return r.__cachedToolbarState.state;
    let t = {};
    for (let n of qG()) {
      if (n.dropdown) {
        let a = n.dropdown.filter((s) => e || Tg(r, s));
        if (
          a.sort((s, l) => {
            let c = $f(r, s), d = $f(r, l), p = Tg(r, s), h = Tg(r, l);
            return (c ? 0 : p ? 1 : 2) - (d ? 0 : h ? 1 : 2);
          }), a.length > 0
        ) {
          let s = r.selectedToolForGroup[n.group];
          (!s || a.indexOf(s) === -1) && (s = a[0]),
            !e && !$f(r, s) && (s = a.find((l) => $f(r, l)) || a[0]),
            t[n.group] = {
              group: n.group,
              current: s,
              dropdown: a.length > 1 ? a : void 0,
            };
        }
      } else (e || Tg(r, n.current)) && (t[n.group] = n);
    }
    let o = Object.keys(t);
    r.__cachedToolbarState = {
      authorMode: e,
      state: { groups: o, items: t },
    };
    for (let n of o) {
      let a = t[n];
      r.selectedToolForGroup[n] = a == null ? void 0 : a.current;
    }
    return { groups: o, items: t };
  }
  function qG() {
    return [{
      group: "selection",
      current: "selection",
      dropdown: ["selection", "box-selection"],
    }, {
      group: "point",
      current: "point",
      dropdown: ["point", "midpoint"],
    }, {
      group: "line",
      current: "segment",
      dropdown: [
        "segment",
        "line",
        "ray",
        "vector",
        "parallel",
        "perpendicular",
        "anglebisector",
      ],
    }, {
      group: "circle",
      current: "circle",
      dropdown: ["circle", "compass", "arc"],
    }, {
      group: "angle",
      current: "angle",
      dropdown: ["angle", "directedangle"],
    }, { group: "polygon", current: "polygon" }];
  }
  var lee = 0;
  function cee() {
    return "helper_item_" + lee++;
  }
  function Xz(r) {
    return {
      ...r,
      formula: __dcg_shared_module_exports__["ee"](),
      guid: cee(),
      cachedParsableState: {
        type: "statement",
        id: r.id,
        latex: r.latex,
        shouldGraph: false,
      },
    };
  }
  function Jz(r, e, t) {
    var c;
    e.formula = t;
    let { proxy: o } = e,
      i = (c = t.typed_constant_value) == null ? void 0 : c.value,
      n = __dcg_shared_module_exports__["I"](i) ? i : NaN,
      a = __dcg_shared_module_exports__["G"](i) &&
          __dcg_shared_module_exports__["j"](
            i,
            __dcg_shared_module_exports__["I"],
          )
        ? i.slice(0)
        : void 0,
      s = o.listValue,
      l = o.numericValue;
    o.setPropertyWithoutNotifying("numericValue", n),
      o.setPropertyWithoutNotifying("listValue", a),
      __dcg_shared_module_exports__["E"](n, l) ||
      r.runAfterDispatch(() => {
        o.notifyPropertyChange("numericValue");
      }),
      __dcg_shared_module_exports__["E"](a, s) ||
      r.runAfterDispatch(() => {
        o.notifyPropertyChange("listValue");
      });
  }
  qt();
  function Qz(r, e) {
    r.hidden = e;
  }
  function ks(r, e, t) {
    r[e] = t;
  }
  function Zz(r, e) {
    return r[e];
  }
  function e4(r, e) {
    r.description = e;
  }
  function t4(r, e) {
    r.name = e;
  }
  function SE(r, e) {
    e.type === "inert"
      ? (r.disableGraphInteractions = e.disableGraphInteractions,
        e.disableGraphInteractions &&
        (r.draggable = false,
          r.clickableInfo = { ...r.clickableInfo, enabled: false }))
      : e.type === "draggable"
      ? (r.draggable = e.draggable,
        e.draggable && (r.disableGraphInteractions = false))
      : e.type === "clickable" &&
        (r.clickableInfo = e.clickableInfo,
          e.clickableInfo.enabled && (r.disableGraphInteractions = false));
  }
  function KG(r, e) {
    SE(r, { type: "draggable", draggable: e });
  }
  function jf(r) {
    if (!r.formula) return;
    let e = r.formula.center_reference_id,
      t = r.formula.center_reference_symbol;
    if (!e || !t) return;
    let o = r.controller.getItemModel(e);
    if (
      !(!o || o.type !== "expression") && o.formula.assignment === t &&
      Ea(o)
    ) return o;
  }
  function pee(r) {
    let e = jf(r);
    if (!e) return false;
    let t = Ro(e);
    return !(!t || t === "NONE");
  }
  function fc(r) {
    return !r.draggable || Ds(r) ? false : pee(r);
  }
  function r4(r) {
    if (!r.formula || !r.formula.center_is_point_literal) return false;
    let e = r.formula.move_strategy;
    if (!e) return false;
    let t = e[2],
      o = e[3],
      i = t && t.type !== "none",
      n = o && o.type !== "none";
    return !!(i || n);
  }
  function o4(r, e) {
    r.opacity = e;
  }
  function WG(r, e) {
    r.foreground = e;
  }
  function i4(r, e) {
    r.image_url = e;
  }
  function EE(r, e) {
    e(r.opacity, "imageOpacity"),
      e(r.center, "imageCenter"),
      e(r.height, "imageHeight"),
      e(r.width, "imageWidth"),
      e(r.angle, "imageAngle");
  }
  function uee(r) {
    let e = KC(r);
    e.color = r.color,
      e.index = r.index,
      e.guid = r.guid,
      e.shouldGraph = r.shouldGraph,
      e.showPoints = r.showPoints,
      r.cachedParsableState = e;
  }
  function n4(r) {
    r.draggingOnGraphpaper
      ? r.preTransientState ||
        (r.preTransientState = {
          center: r.center,
          width: r.width,
          height: r.height,
        })
      : delete r.preTransientState, hd(r);
    let e = Ca(r);
    r.shouldGraph = e && e.hidden ? false : !r.hidden,
      r.showPoints = r.shouldGraph && Sa(r) &&
        r.loadStatus === "loaded" && !fc(r) &&
        r.controller.isTraceEnabled(),
      gee(r),
      mee(r),
      uee(r);
  }
  function a4(r, e) {
    r.formula = e, r.error = hee(r);
  }
  function TE(r) {
    return r.formula
      ? r.formula.variables.map((t) =>
        __dcg_shared_module_exports__["identifierToLatex"](t)
      ) || []
      : [];
  }
  function hee(r) {
    let e = {
      scale: r.controller.s("graphing-calculator-error-log-axes-image"),
      center: r.controller.s(
        "graphing-calculator-error-image-invalid-center",
      ),
      angle: r.controller.s(
        "graphing-calculator-error-image-invalid-angle",
      ),
      width: r.controller.s(
        "graphing-calculator-error-image-invalid-width",
      ),
      height: r.controller.s(
        "graphing-calculator-error-image-invalid-height",
      ),
      opacity: r.controller.s(
        "graphing-calculator-error-image-invalid-opacity",
      ),
    };
    for (let t in r.formula.errorMap) {
      if (r.formula.errorMap[t]) return e[t];
    }
  }
  function s4(r, e) {
    return !r.formula || !r.formula.errorMap ? false : !!r.formula.errorMap[e];
  }
  function DE(r, e) {
    let t = r.cachedViewState;
    return e.stripDefaults ? dN(t) : t;
  }
  function gee(r) {
    let e = r.cachedViewState.clickableInfo, t = true, o = true;
    if (
      e &&
      (e.depressedImage === r.clickableInfo.depressedImage && (o = false),
        e.hoveredImage === r.clickableInfo.hoveredImage && (t = false)),
        t &&
        (r.hoveredImageObj &&
          (ee(r.hoveredImageObj).off("load"), delete r.hoveredImageObj),
          r.clickableInfo.hoveredImage)
    ) {
      r.hoveredImageObj = new Image();
      let i = function () {
          r.controller.requestRedrawGraph();
        },
        n = function () {};
      CE(r.hoveredImageObj, r.clickableInfo.hoveredImage, i, n);
    }
    if (
      o &&
      (r.depressedImageObj &&
        (ee(r.depressedImageObj).off("load"), delete r.depressedImageObj),
        r.clickableInfo.depressedImage)
    ) {
      r.depressedImageObj = new Image();
      let i = function () {
          r.controller.requestRedrawGraph();
        },
        n = function () {};
      CE(r.depressedImageObj, r.clickableInfo.depressedImage, i, n);
    }
    if (r.cachedViewState.image_url !== r.image_url) {
      ee(r.imageObj).off("load"), r.imageObj = new Image();
      let i = function () {
          r.controller.dispatch({ type: "image-load-success", id: r.id });
        },
        n = function () {
          r.controller.dispatch({ type: "image-load-error", id: r.id });
        },
        s = r.controller.getGraphSettings().config.cacheRenderedSvgs
          ? { fetchMimeType: { imageModel: r } }
          : void 0;
      CE(r.imageObj, r.image_url, i, n, s);
    }
    r.cachedViewState = {
      type: r.type,
      id: r.id,
      folderId: r.folderId,
      image_url: r.image_url,
      name: r.name,
      hidden: r.hidden,
      foreground: r.foreground,
      secret: r.secret,
      readonly: r.readonly,
      disableGraphInteractions: r.disableGraphInteractions,
      ...vM(r),
    };
  }
  function $G(r, e) {
    r.draggingOnGraphpaper = e;
  }
  function mee(r) {
    let e = r.cachedViewState;
    r.cachedUndoRedoFullState = r.cachedViewState,
      r.preTransientState && (e = { ...e, ...r.preTransientState }),
      r.cachedUndoRedoDiffState = e;
  }
  function fee(r) {
    let e = document.createElement("canvas");
    return e.width = 2,
      e.height = 2,
      e.getContext("2d").drawImage(r, 0, 0, 2, 2),
      e.toDataURL();
  }
  function CE(r, e, t, o, i = {}) {
    ee(r).on("load.initial-image-load", () => {
      let s = r.width, l = r.height;
      s === 1 && l === 1
        ? (ee(r).off(".initial-image-load"),
          ee(r).on("load", t),
          r.src = fee(r))
        : t();
    }).on("error", o);
    let n = /^data:/.test(e);
    n || (r.crossOrigin = "anonymous");
    let { fetchMimeType: a } = i;
    a
      ? n
        ? (r.src = e, a.imageModel.mimeType = e.substring(5, e.indexOf(";")))
        : fetch(e).then((s) => {
          let l = s.headers.get("Content-type");
          return l && (a.imageModel.mimeType = l), s.blob();
        }).then((s) => {
          let l = URL.createObjectURL(s);
          r.src = l;
        })
      : r.src = e;
  }
  function l4(r, e) {
    return {
      ...__dcg_shared_module_exports__["Jc"](HC(r)),
      ...ud(e),
      color: __dcg_shared_module_exports__["Rd"].BLUE,
      loadStatus: "loading",
      failures: 0,
      imageObj: new Image(),
      hoveredImageObj: void 0,
      depressedImageObj: void 0,
      mimeType: void 0,
      shouldGraph: void 0,
      showPoints: void 0,
      error: void 0,
      formula: void 0,
      draggingOnGraphpaper: false,
      cachedViewState: {},
      cachedParsableState: {},
      cachedUndoRedoDiffState: {},
      cachedUndoRedoFullState: {},
    };
  }
  var bee = {
    id: false,
    type: false,
    image_url: true,
    name: true,
    folderId: true,
    hidden: true,
    secret: true,
    readonly: true,
    disableGraphInteractions: true,
    foreground: true,
    ...__dcg_shared_module_exports__["ud"](qC),
  };
  function c4(r, e) {
    __dcg_shared_module_exports__["rd"]({ from: e, to: r, props: bee });
  }
  function d4(r) {
    let { controller: e, files: t, id: o } = r,
      i = { errors: [], tokens: [] };
    for (let n = 0; n < t.length; n++) {
      let a = t[n];
      if (!a.type.match("image/*")) {
        i.errors.push(
          e.s("graphing-calculator-error-image-invalid-file", {
            file: a.name,
          }),
        );
        continue;
      }
      i.tokens.push(xee({ controller: e, file: a, id: o }));
    }
    return i;
  }
  var yee = 0;
  function xee(r) {
    let { controller: e, file: t, id: o } = r, i = "" + yee++;
    return e.getGraphSettings().config.imageUploadCallback(t, (n, a) => {
      setTimeout(() => {
        if (n) {
          e.dispatch({ type: "image-upload-error", token: i, error: n });
        } else {
          let s = new Image();
          CE(s, a, function () {
            let d = s.width,
              p = s.height,
              h = Math.max(d, p) / Math.min(d, p);
            d < p
              ? (p = 10, d = Math.round(10 * p / h) / 10)
              : (d = 10, p = Math.round(10 * d / h) / 10),
              e.dispatch({
                type: "image-upload-success",
                token: i,
                url: a,
                width: d + "",
                height: p + "",
                name: t.name,
                id: o,
              });
          }, function () {
            e.dispatch({
              type: "image-upload-error",
              token: i,
              error: true,
            });
          });
        }
      });
    }),
      i;
  }
  function kE(r, e) {
    r.loadStatus = e,
      e === "loaded" && (r.failures = 0),
      e === "failed" && (r.failures += 1);
  }
  function jG(r) {
    r.imageObj.src = r.imageObj.src, kE(r, "loading");
  }
  function _E(r, e, t) {
    SE(r, {
      type: "clickable",
      clickableInfo: { ...r.clickableInfo, [e]: t },
    });
  }
  function p4(r, e) {
    SE(r, {
      type: "clickable",
      clickableInfo: { ...r.clickableInfo, latex: e },
    });
  }
  function Dg(r) {
    var e;
    return !!(r.clickableInfo.enabled && r.formula &&
      ((e = r.formula.click_handler) == null ? void 0 : e.status) ===
        "maybe-valid");
  }
  function YG(r, e) {
    SE(r, { type: "inert", disableGraphInteractions: e });
  }
  var IE = class {
    invalidate() {
      this.suggestedIdentifierRename = void 0;
    }
    suggestionForId(e) {
      if (
        this.suggestedIdentifierRename &&
        this.suggestedIdentifierRename.id === e
      ) return this.suggestedIdentifierRename;
    }
    updateForSelectedItem(e, t) {
      function o(c) {
        return Nu(e, c).length;
      }
      function i(c, d) {
        return Nu(e, c).filter((p) => p.folderId === d).length;
      }
      if (!t || t.type !== "expression") {
        this.invalidate();
        return;
      }
      this.suggestedIdentifierRename &&
      this.suggestedIdentifierRename.id !== t.id &&
      (this.suggestedIdentifierRename = void 0),
        this.suggestedIdentifierRename &&
        Cw(e, this.suggestedIdentifierRename.from) === 0 &&
        (this.suggestedIdentifierRename = void 0);
      let n = t.formula.defined_name || "",
        a = n ? __dcg_shared_module_exports__["identifierToLatex"](n) : "";
      if (!this.suggestedIdentifierRename) {
        a &&
          (this.suggestedIdentifierRename = {
            id: t.id,
            from: a,
            to: a,
            countOfChanges: 0,
            folderId: void 0,
          });
        return;
      }
      if (a === this.suggestedIdentifierRename.to) return;
      if (
        this.suggestedIdentifierRename.to = a,
          this.suggestedIdentifierRename.from ===
            this.suggestedIdentifierRename.to ||
          !this.suggestedIdentifierRename.from ||
          !this.suggestedIdentifierRename.to
      ) {
        this.suggestedIdentifierRename.countOfChanges = 0;
        return;
      }
      if (o(n) > 1) {
        this.suggestedIdentifierRename.countOfChanges = 0;
        return;
      }
      let s = __dcg_shared_module_exports__["latexToIdentifier"](
        this.suggestedIdentifierRename.from,
      );
      if (this.suggestedIdentifierRename.folderId = void 0, o(s) > 0) {
        let c;
        if (t.folderId && (c = i(s, t.folderId)) === 0) {
          this.suggestedIdentifierRename.folderId = t.folderId,
            this.suggestedIdentifierRename.countOfChanges = c;
        } else {
          this.suggestedIdentifierRename.countOfChanges = 0;
          return;
        }
      }
      let l = Cw(
        e,
        this.suggestedIdentifierRename.from,
        this.suggestedIdentifierRename.folderId,
      );
      this.suggestedIdentifierRename.countOfChanges = l;
    }
  };
  var u4 = { folderId: "", text: "", secret: false, readonly: false };
  function h4(r) {
    return { ...u4, ...r };
  }
  function g4(r) {
    return __dcg_shared_module_exports__["md"](u4, r);
  }
  function XG(r, e) {
    r.text = e;
  }
  function m4(r, e) {
    return {
      ...__dcg_shared_module_exports__["Jc"](h4(r)),
      ...ud(e),
      cachedUndoRedoDiffState: {},
      cachedUndoRedoFullState: {},
      cachedViewState: {},
    };
  }
  function f4(r) {
    hd(r), vee(r), Cee(r);
  }
  var wee = {
    id: false,
    type: false,
    folderId: true,
    text: true,
    secret: true,
    readonly: true,
  };
  function b4(r, e) {
    __dcg_shared_module_exports__["rd"]({ from: e, to: r, props: wee });
  }
  function AE(r, e) {
    let t = r.cachedViewState;
    return e.stripDefaults ? g4(t) : t;
  }
  function vee(r) {
    r.cachedViewState = {
      type: r.type,
      id: r.id,
      folderId: r.folderId,
      text: r.text,
      secret: r.secret,
      readonly: r.readonly,
    };
  }
  function Cee(r) {
    r.cachedUndoRedoDiffState = r.cachedViewState,
      r.cachedUndoRedoFullState = r.cachedViewState;
  }
  var x4 = "dcg_ticker_guid_internal", See = x4;
  function w4() {
    return JG(of);
  }
  function Eee(r) {
    r.cachedParsableState = jC(r);
  }
  function v4(r, e) {
    return e.stripDefaults ? hN(r.cachedViewState) : r.cachedViewState;
  }
  function C4(r) {
    return r.cachedUndoRedoDiffState;
  }
  function S4(r) {
    return r.cachedUndoRedoFullState;
  }
  function Tee(r) {
    r.cachedViewState = {
      handlerLatex: r.handlerLatex,
      minStepLatex: r.minStepLatex,
      playing: r.playing,
      open: r.open,
    };
  }
  function Dee(r) {
    let e = r.cachedViewState;
    r.cachedUndoRedoDiffState = e, r.cachedUndoRedoFullState = e;
  }
  function JG(r) {
    return {
      ...YC(r),
      type: "ticker",
      guid: x4,
      id: See,
      avgDelta: 0,
      lastTickTime: void 0,
      cachedViewState: {},
      cachedParsableState: {},
      cachedUndoRedoDiffState: {},
      cachedUndoRedoFullState: {},
      filteredBySearch: false,
    };
  }
  function E4(r, e) {
    __dcg_shared_module_exports__["sd"](e, r);
  }
  function T4(r, e) {
    r.formula = e;
  }
  function D4(r) {
    Tee(r), Dee(r), Eee(r);
  }
  function k4(r, { currentFrameTime: e, previousFrameTime: t }) {
    var a, s;
    if (
      !r.playing ||
      ((a = r.formula) == null ? void 0 : a.handler.status) !==
        "maybe-valid"
    ) return false;
    if (r.lastTickTime == null || t == null) return true;
    if (
      ((s = r.formula) == null ? void 0 : s.minStep.status) !== "valid"
    ) return false;
    let o = r.formula.minStep.value, i = r.lastTickTime + o;
    if (e >= i) return true;
    let n = e - t;
    return i - e < n / 2;
  }
  function _4(r, e) {
    r.lastTickTime = e;
  }
  function I4(r) {
    if (r.formula) {
      return r.formula.handler.status === "error"
        ? r.formula.handler.error
        : void 0;
    }
  }
  function A4(r) {
    if (r.formula) {
      return r.formula.minStep.status === "error"
        ? r.formula.minStep.error
        : void 0;
    }
  }
  function Sw(r) {
    var e;
    return (((e = r.formula) == null ? void 0 : e.variables) || []).map(
      (t) => __dcg_shared_module_exports__["identifierToLatex"](t),
    );
  }
  function ME(r, e) {
    e(r.handlerLatex, "tickerHandler"), e(r.minStepLatex, "tickerMinStep");
  }
  var Zf = "**dcg_geo_expression_edit_tool_preview**";
  function M4(r) {
    return {
      controller: r,
      __itemModelArray: [],
      __itemIdToModel: {},
      __helperIdToModel: {},
      __toolPreviewIdToModel: {},
      __anyDependsOnRandomSeed: false,
      __anyFunctionDefinitionsDependOnRandomSeed: false,
      __anyUnmutedTones: false,
      __anyTones: false,
      __anyIsAction: false,
      selectedItemMap: {},
      tabOrder: [],
      drawLayers: [],
      colorIdx: 0,
      expressionAnalysis: {},
      nextDisplayIndex: "1",
      ticker: w4(),
      renamePrompt: new IE(),
      __exportedVariables: new ww([], void 0),
    };
  }
  function G4(r) {
    for (let e = 0; e < r.__itemModelArray.length; e++) {
      let t = r.__itemModelArray[e];
      if (t.type === "image" && t.loadStatus === "loading") return true;
    }
    return false;
  }
  function L4(r) {
    let e = __dcg_shared_module_exports__["i"](
        __dcg_shared_module_exports__["C"](r.controller.getColors()),
        (o) => o != __dcg_shared_module_exports__["Rd"].ORANGE,
      ),
      t = e[r.colorIdx];
    return r.colorIdx = (r.colorIdx + 1) % e.length, t;
  }
  function kg(r, e) {
    return r.__itemModelArray[e];
  }
  function eb(r) {
    for (let e = 0; e < r.__itemModelArray.length; e++) {
      let t = r.__itemModelArray[e];
      if (tb(t)) return t;
    }
  }
  function PE(r) {
    for (let e = r.__itemModelArray.length - 1; e >= 0; e--) {
      let t = r.__itemModelArray[e];
      if (tb(t)) return t;
    }
  }
  function Ew(r, e) {
    let t;
    do {
      if (e--, e === -1) return;
      t = kg(r, e);
    } while (t && !tb(t));
    return t;
  }
  function Tw(r, e) {
    let t, o = kw(r);
    do {
      if (e++, e === o) return;
      t = kg(r, e);
    } while (t && !tb(t));
    return t;
  }
  function Ca(r) {
    if (r.type !== "folder" && r.folderId) {
      let e = r.controller.getListModel(), t = bd(e, r.folderId);
      if (t && t.type === "folder") return t;
    }
  }
  function P4(r, e) {
    let t = bd(r, e);
    if (!t || t.type !== "folder") return 0;
    let o = 0, i = r.__itemModelArray.length;
    for (let n = t.index + 1; n < i; n++) {
      let a = r.__itemModelArray[n];
      if (a.type === "folder" || a.folderId !== e) break;
      o += 1;
    }
    return o;
  }
  function V4(r, e) {
    let t = bd(r, e);
    if (!t || t.type !== "folder") return [];
    let o = [], i = r.__itemModelArray.length;
    for (let n = t.index + 1; n < i; n++) {
      let a = r.__itemModelArray[n];
      if (a.type === "folder" || a.folderId !== e) break;
      o.push(a.id);
    }
    return o;
  }
  function O4(r, e) {
    let t = [], o = bd(r, e);
    if (!o || o.type !== "folder") return t;
    let i = r.__itemModelArray.length;
    for (let n = o.index + 1; n < i; n++) {
      let a = r.__itemModelArray[n];
      if (a.type === "folder" || a.folderId !== e) break;
      t.push(a);
    }
    return t;
  }
  function R4(r) {
    return !!(r && r.readonly);
  }
  function Xf(r) {
    if (!r) return false;
    if (r.secret) return true;
    let e = Ca(r);
    return !!(e && e.secret &&
      e.id !== __dcg_shared_module_exports__["xd"]);
  }
  function tb(r) {
    return !UG(r);
  }
  function F4(r) {
    return r.id === __dcg_shared_module_exports__["xd"] ||
      r.type !== "folder" &&
        r.folderId === __dcg_shared_module_exports__["xd"];
  }
  function UG(r) {
    if (!r || r.filteredBySearch || F4(r)) return true;
    if (r.controller.isItemBeingDragged(r.id)) {
      return !!r.controller.shouldRenderDraggedItemAsToken();
    }
    if (!r.controller.shouldShowAuthorFeatures() && Xf(r)) return true;
    let t = Ca(r);
    return !!(t && t.collapsed && !r.controller.getExpressionSearchStr());
  }
  function VE(r) {
    return r.__itemModelArray;
  }
  function N4(r) {
    return __dcg_shared_module_exports__["C"](r.__helperIdToModel);
  }
  function rb(r) {
    return __dcg_shared_module_exports__["C"](r.__toolPreviewIdToModel);
  }
  function ob(r, e) {
    for (let t = 0; t < r.__itemModelArray.length; t++) {
      let o = r.__itemModelArray[t];
      Jf(o, e);
    }
    for (let t in r.__toolPreviewIdToModel) {
      Jf(r.__toolPreviewIdToModel[t], e);
    }
    if (
      r.ticker.open &&
      (e(r.ticker.handlerLatex, {
        type: "item",
        location: "tickerHandler",
        item: r.ticker,
      }),
        e(r.ticker.minStepLatex, {
          type: "item",
          location: "tickerMinStep",
          item: r.ticker,
        })), r.controller.isGeometry()
    ) {
      let o = r.controller.getGeometryToolbarModel().toolbarState;
      for (let i in o) {
        let n = i, a = o[n];
        a.visible && a.disabledLatex &&
          e(a.disabledLatex, { type: "geometry-toolbar", tool: n });
      }
    }
  }
  function Jf(r, e) {
    switch (r.type) {
      case "expression":
        qE(r, (o, i) => e(o, { type: "item", location: i, item: r }));
        break;
      case "table":
        fw(
          r,
          (o, i, n) => e(o, { type: "item", location: i, item: r, ...n }),
        );
        break;
      case "image":
        EE(r, (o, i) => e(o, { type: "item", location: i, item: r }));
        break;
      case "ticker":
        ME(r, (o, i) => e(o, { type: "item", location: i, item: r }));
        break;
      case "folder":
      case "text":
        break;
      default:
        return r;
    }
  }
  function B4(r, e) {
    if (!ya(e)) return false;
    let o = false;
    return ob(r, (i) => {
      Il(i, e) && (o = true);
    }),
      o;
  }
  function U4(r, e) {
    let t = false;
    for (let o of r.__itemModelArray) {
      if (
        o.type === "table" && (fw(o, (i) => {
          Il(i, e) && (t = true);
        }, { headersOnly: true }),
          t)
      ) return true;
    }
    return false;
  }
  function z4(r, e) {
    let t = 0, o = ya(e);
    r.ticker.filteredBySearch = r.ticker.open &&
      !Il(r.ticker.handlerLatex, e) && !Il(r.ticker.minStepLatex, e);
    for (let i of r.__itemModelArray) {
      if (!o) {
        i.filteredBySearch = false, t++;
        continue;
      }
      switch (i.filteredBySearch = true, i.type) {
        case "expression":
          qE(i, (s) => {
            Il(s, e) && (i.filteredBySearch = false, t++);
          });
          let n = ja(i);
          i.label && n && i.label.match(LE(e)) &&
            (i.filteredBySearch = false, t++);
          break;
        case "table":
          fw(i, (s) => {
            Il(s, e) && (i.filteredBySearch = false, t++);
          });
          break;
        case "image":
          EE(i, (s) => {
            Il(s, e) && (i.filteredBySearch = false, t++);
          });
          break;
        case "folder":
        case "text":
          break;
        default:
          return i;
      }
      !i.filteredBySearch && i.type !== "folder" && i.folderId &&
        (r.__itemIdToModel[i.folderId].filteredBySearch = false, t++);
    }
    return t;
  }
  function q4(r, e) {
    let t = 0, o = VU(e), i = RU(e);
    r.ticker.filteredBySearch = !!e && r.ticker.open &&
      !o(r.ticker.handlerLatex) && !o(r.ticker.minStepLatex);
    for (let n = 0; n < r.__itemModelArray.length; n++) {
      if (!e) {
        r.__itemModelArray[n].filteredBySearch = false;
        continue;
      }
      let a = r.__itemModelArray[n];
      switch (a.filteredBySearch = true, a.type) {
        case "expression":
          qE(a, (c) => {
            o(c) && (a.filteredBySearch = false, t++);
          });
          let s = ja(a);
          ub(a) && (a.label || s) &&
            (e === "\\operatorname{label}" ||
              e.length > 1 && "label".indexOf(e) === 0 || o(a.label)) &&
            (a.filteredBySearch = false, t++);
          break;
        case "table":
          fw(a, (c) => {
            o(c) && (a.filteredBySearch = false, t++);
          });
          break;
        case "image":
          e === "\\operatorname{image}" ||
            e.length > 1 && "image".indexOf(e) === 0
            ? (a.filteredBySearch = false, t++)
            : EE(a, (c) => {
              o(c) && (a.filteredBySearch = false, t++);
            });
          break;
        case "folder":
          a.title && a.title.indexOf(e) >= 0 &&
            (a.filteredBySearch = false, t++);
          break;
        case "text":
          i.test(a.text) && (a.filteredBySearch = false, t++);
          break;
        default:
          return a;
      }
      !a.filteredBySearch && a.type !== "folder" && a.folderId &&
        (r.__itemIdToModel[a.folderId].filteredBySearch = false, t++);
    }
    return t;
  }
  function LE(r, e) {
    return new RegExp(
      "\\$\\{" +
        r.replace("{", "\\{?").replace("}", "\\}?").replace("_", "\\_?") +
        "\\}",
      e,
    );
  }
  function Cw(r, e, t) {
    let o = 0;
    for (let i = 0; i < r.__itemModelArray.length; i++) {
      let n = r.__itemModelArray[i];
      if (n.type !== "expression" || t && n.folderId !== t) continue;
      if (ja(n) && n.label) {
        let s = n.label.match(LE(e, "g"));
        s && (o += s.length);
      }
    }
    return ob(r, (i, n) => {
      t &&
          (n.type !== "item" || n.item.type === "ticker" ||
            n.item.type === "folder" || n.item.folderId !== t) ||
        (o += ZC(i, e).length);
    }),
      o;
  }
  function fd(r, e, t, o) {
    r.renamePrompt.invalidate(),
      t = t.trim().replace(/_\{([a-zA-Z0-9])\}/g, "_$1");
    for (let i = 0; i < r.__itemModelArray.length; i++) {
      let n = r.__itemModelArray[i];
      if (n.type === "expression") {
        if (
          (o == null ? void 0 : o.limitToFolder) !== void 0 &&
          o.limitToFolder !== n.folderId
        ) continue;
        let a = ja(n);
        n.label && a && n.label.match(LE(e)) &&
          yd(n, n.label.replace(LE(e, "g"), "${" + t.trim() + "}"));
      }
    }
    ob(r, (i, n) => {
      if (
        o && o.limitToItem !== void 0 &&
          (n.type !== "item" || o.limitToItem !== n.item.id) ||
        o && o.limitToFolder !== void 0 &&
          (n.type !== "item" || n.item.type === "ticker" ||
            n.item.type === "folder" ||
            o.limitToFolder !== n.item.folderId)
      ) return;
      let a = eS(i, e, t);
      if (n.type === "geometry-toolbar") {
        let l = r.controller.getGeometryToolbarModel();
        vE(l, n.tool, { visible: true, disabledLatex: a });
        return;
      }
      let s = n.item;
      if (a !== i) {
        let l;
        switch (
          n.cellLocation !== void 0 && s.columnModels &&
          (l = s.columnModels[n.cellLocation.column].id), n.location
        ) {
          case "latex": {
            $a(s, a);
            break;
          }
          case "cdfMin": {
            WE(s, a);
            break;
          }
          case "cdfMax": {
            $E(s, a);
            break;
          }
          case "colorLatex": {
            Rw(s, a);
            break;
          }
          case "lineWidth": {
            db(s, a);
            break;
          }
          case "resolution": {
            HE(s, a);
            break;
          }
          case "clickableInfoLatex": {
            UE(s, a);
            break;
          }
          case "fillOpacity": {
            Lw(s, a);
            break;
          }
          case "surfaceOpacity": {
            Pw(s, a);
            break;
          }
          case "lineOpacity": {
            cb(s, a);
            break;
          }
          case "pointOpacity": {
            Vw(s, a);
            break;
          }
          case "pointSize":
          case "movablePointSize":
            Ow(s, a);
            break;
          case "labelAngle": {
            KE(s, a);
            break;
          }
          case "labelSize": {
            Fw(s, a);
            break;
          }
          case "polarDomainMin": {
            Ka(s, a, "theta");
            break;
          }
          case "polarDomainMax": {
            Wa(s, a, "theta");
            break;
          }
          case "parametricDomainMin": {
            Ka(s, a, "t");
            break;
          }
          case "parametricDomainMax": {
            Wa(s, a, "t");
            break;
          }
          case "parametricDomain3DuMin": {
            Ka(s, a, "u");
            break;
          }
          case "parametricDomain3DuMax": {
            Wa(s, a, "u");
            break;
          }
          case "parametricDomain3DvMin": {
            Ka(s, a, "v");
            break;
          }
          case "parametricDomain3DvMax": {
            Wa(s, a, "v");
            break;
          }
          case "parametricDomain3DrMin": {
            Ka(s, a, "r");
            break;
          }
          case "parametricDomain3DrMax": {
            Wa(s, a, "r");
            break;
          }
          case "parametricDomain3DphiMin": {
            Ka(s, a, "phi");
            break;
          }
          case "parametricDomain3DphiMax": {
            Wa(s, a, "phi");
            break;
          }
          case "sliderMin": {
            sb(s, a);
            break;
          }
          case "sliderMax": {
            lb(s, a);
            break;
          }
          case "sliderStep": {
            Gw(s, a);
            break;
          }
          case "imageOpacity": {
            ks(s, "opacity", a);
            break;
          }
          case "imageCenter": {
            ks(s, "center", a);
            break;
          }
          case "imageHeight": {
            ks(s, "height", a);
            break;
          }
          case "imageWidth": {
            ks(s, "width", a);
            break;
          }
          case "imageAngle": {
            ks(s, "angle", a);
            break;
          }
          case "tickerHandler": {
            s.handlerLatex = a;
            break;
          }
          case "tickerMinStep": {
            s.minStepLatex = a;
            break;
          }
          case "tableHeader":
          case "tableCellValue":
            if (!n.cellLocation || s.type !== "table") break;
            vp(s, n.cellLocation, a);
            break;
          case "tableColumnColorLatex": {
            l && lE(s, l, a);
            break;
          }
          case "tableColumnPointSize": {
            l && aE(s, l, a);
            break;
          }
          case "tableColumnPointOpacity": {
            l && sE(s, l, a);
            break;
          }
          case "tableColumnLineWidth": {
            l && iE(s, l, a);
            break;
          }
          case "tableColumnLineOpacity": {
            l && nE(s, l, a);
            break;
          }
          case "residualVariable":
            break;
          default: {
            let c = n.location;
            throw new Error(`Unexpected latex location ${c}`);
          }
        }
      }
    });
  }
  function OE(r) {
    let e = [];
    ob(r, (o) => {
      if (o.indexOf("~") !== -1 || o.indexOf("\\sim") !== -1) return;
      let i = /_(\d)|_\{(?:\s|\\space)*(\d+)(?:\s|\\space)*\}/g;
      for (;;) {
        let n = i.exec(o);
        if (!n) break;
        e.push(parseInt(n[1] || n[2], 10));
      }
    }), e.sort((o, i) => o - i);
    let t = 1;
    for (let o = 0; o < e.length; o++) e[o] === t && t++;
    return t;
  }
  function H4(r) {
    let e = 0;
    return ob(r, (t) => {
      let o = /\\token\{(\d+)\}/g;
      for (;;) {
        let i = o.exec(t);
        if (!i) break;
        let n = parseInt(i[1], 10);
        n > e && (e = n);
      }
    }),
      e;
  }
  function K4(r) {
    let e = {};
    return ob(r, (t) => {
      if (t.indexOf("~") !== -1 || t.indexOf("\\sim") !== -1) return;
      let o =
        /(\\?[a-zA-Z]+)_(\d)|(\\?[a-zA-Z]+)_\{(?:\s|\\space)*(\d+)(?:\s|\\space)*\}/g;
      for (;;) {
        let i = o.exec(t);
        if (!i) break;
        let n = i[1] || i[3], a = i[2] || i[4];
        n[0] !== "\\" && (n = n[n.length - 1]);
        let s = parseInt(a, 10);
        e[n] || (e[n] = 0), s > e[n] && (e[n] = s);
      }
    }),
      e;
  }
  function W4(r, e) {
    let t = [],
      o = [],
      i = [],
      n = [],
      a = { points: [], angles: [], polygons: [], other: [] };
    function s(c) {
      if (Mee(r, c.id) && e !== "actual") return;
      if (c.id === Zf && e !== "preview") return;
      if (
        c.type === "expression" &&
        c.folderId === __dcg_shared_module_exports__["xd"]
      ) {
        mc(c)
          ? a.points.push(c.id)
          : zu(c)
          ? a.angles.push(c.id)
          : pb(c)
          ? a.polygons.push(c.id)
          : a.other.push(c.id);
        return;
      }
      let d = false;
      if (c.type !== "folder" && c.folderId) {
        let h = r.__itemIdToModel[c.folderId];
        h && h.type === "folder" && h.inFrontOfEverything && (d = true);
      }
      let p = i;
      d ? p = n : c.type === "image" && !c.foreground && (p = o),
        c.type === "table"
          ? (c.regression &&
            (t.push(c.regression.id), p.push(c.regression.id)),
            __dcg_shared_module_exports__["g"](c.columnModels, (h) => {
              t.push(h.id), p.push(h.id);
            }))
          : (t.push(c.id), p.push(c.id));
    }
    r.__itemModelArray.forEach(s), rb(r).forEach(s);
    let l = [...a.polygons, ...a.other, ...a.angles, ...a.points];
    t.push(...l),
      i.push(...l),
      r.tabOrder = t,
      r.drawLayers = [],
      o.length &&
      r.drawLayers.push({ layer: -1, drawOrder: o, drawSet: new Set(o) }),
      r.drawLayers.push({ layer: 0, drawOrder: i, drawSet: new Set(i) }),
      n.length &&
      r.drawLayers.push({ layer: 1, drawOrder: n, drawSet: new Set(n) });
  }
  function bd(r, e, t) {
    let o = r.__itemIdToModel[e];
    if (o) return o;
    if (t && t.includePreviewItems) return r.__toolPreviewIdToModel[e];
  }
  function $4(r, e) {
    return !!r.__toolPreviewIdToModel[e];
  }
  function Nu(r, e) {
    var o;
    let t = [];
    for (let i = 0; i < r.__itemModelArray.length; i++) {
      let n = r.__itemModelArray[i];
      n.type === "expression" &&
        ((o = pi(n)) == null ? void 0 : o.identifier) === e && t.push(n);
    }
    return t;
  }
  function kee(r, e) {
    return r.__helperIdToModel[e];
  }
  function j4(r) {
    return __dcg_shared_module_exports__["C"](r.__helperIdToModel);
  }
  function Y4(r, e) {
    let t = Xz(e);
    r.__helperIdToModel[t.id] = t,
      Object.defineProperty(e.proxy, "isActive", {
        get: () => {
          var o;
          return ((o = r.__helperIdToModel[t.id]) == null
            ? void 0
            : o.proxy) === t.proxy;
        },
      });
  }
  function Dw(r) {
    r.__anyUnmutedTones = r.__itemModelArray.some((e) => Aw(e)),
      r.__anyTones = r.__anyUnmutedTones ||
        r.__itemModelArray.some((e) => Is(e));
  }
  function X4(r, e) {
    r.__exportedVariables = new ww(VE(r), e);
  }
  function ZG(r) {
    r.__anyDependsOnRandomSeed = false,
      r.__anyFunctionDefinitionsDependOnRandomSeed = false;
    for (let e = 0; e < r.__itemModelArray.length; e++) {
      let t = r.__itemModelArray[e];
      t && "formula" in t && t.formula &&
        t.formula.depends_on_random_seed &&
        (r.__anyDependsOnRandomSeed = true,
          t.type === "expression" && t.formula.function_definition &&
          (r.__anyFunctionDefinitionsDependOnRandomSeed = true));
    }
  }
  function J4(r) {
    r.__anyIsAction = false;
  }
  function RE(r) {
    if (!r.__anyIsAction) {
      if (r.ticker.open) {
        r.__anyIsAction = true;
        return;
      }
      for (let e = 0; e < r.__itemModelArray.length; e++) {
        let t = r.__itemModelArray[e];
        if (t && "formula" in t && t.formula) {
          if (t.type !== "expression" && t.type !== "image") continue;
          let { formula: o } = t;
          if (
            o.hasOwnProperty("action_value") ||
            o.hasOwnProperty("click_handler")
          ) {
            r.__anyIsAction = true;
            return;
          }
        }
      }
    }
  }
  function _g(r) {
    ku("showIDs") ? Iee(r) : _ee(r);
    for (let e in r.selectedItemMap) {
      r.__itemIdToModel[e] || delete r.selectedItemMap[e];
    }
  }
  function _ee(r) {
    let e = !r.controller.shouldShowAuthorFeatures(), t = 1, o = 1;
    for (let i = 0; i < r.__itemModelArray.length; i++) {
      let n = r.__itemModelArray[i];
      n.index = i,
        n.displayIndex = "" + t,
        Xf(n) && (n.secretIndex = "" + o, o += 1),
        !F4(n) && (!e || !Xf(n)) && (t += 1);
    }
    r.nextDisplayIndex = "" + t;
  }
  function Iee(r) {
    for (let e = 0; e < r.__itemModelArray.length; e++) {
      let t = r.__itemModelArray[e];
      t.index = e;
      let o = t.id.length <= 6 ? t.id : t.id.substring(0, 4) + "\u2026";
      t.displayIndex = o, Xf(t) && (t.secretIndex = o);
    }
    r.nextDisplayIndex = "";
  }
  function Aee(r) {
    r.renamePrompt.invalidate(),
      r.__itemModelArray = [],
      r.__itemIdToModel = {},
      r.__helperIdToModel = {},
      r.__toolPreviewIdToModel = {},
      r.__anyDependsOnRandomSeed = false,
      r.__anyFunctionDefinitionsDependOnRandomSeed = false,
      r.__anyUnmutedTones = false,
      r.__anyTones = false;
  }
  function kw(r) {
    return r.__itemModelArray.length;
  }
  function Q4(r) {
    return r.__itemModelArray.filter((e) =>
      e.type === "expression" &&
      e.folderId === __dcg_shared_module_exports__["xd"] && !!Hi(e)
    ).length;
  }
  function Z4(r) {
    return r.nextDisplayIndex === "1";
  }
  function eq(r) {
    let e = [];
    for (let t = 0; t < r.__itemModelArray.length; t++) {
      let o = r.__itemModelArray[t];
      o.type === "expression" && o.sliderExists && e.push(o);
    }
    return e;
  }
  function Ig(r) {
    let e;
    for (let t in r.selectedItemMap) {
      if (e !== void 0) return;
      e = t;
    }
    if (e !== void 0) return r.__itemIdToModel[e];
  }
  function Mee(r, e) {
    return !!r.selectedItemMap[e];
  }
  function tq(r) {
    return Object.keys(r.selectedItemMap);
  }
  function FE(r) {
    let e = [];
    for (let t in r.selectedItemMap) e.push(r.__itemIdToModel[t]);
    return e;
  }
  function rq(r) {
    return {
      list: r.__itemModelArray.map((e) => e.cachedUndoRedoDiffState),
      ticker: C4(r.ticker),
    };
  }
  function eL(r) {
    return {
      list: r.__itemModelArray.map((e) => e.cachedUndoRedoFullState),
      ticker: S4(r.ticker),
    };
  }
  function oq(r, e) {
    let t = {
        list: r.__itemModelArray.map((i) => {
          switch (i.type) {
            case "expression":
              return Mw(i, e);
            case "image":
              return DE(i, e);
            case "table":
              return Bf(i, e);
            case "folder":
              return xE(i, e);
            case "text":
              return AE(i, e);
            default:
              return i;
          }
        }),
      },
      o = v4(r.ticker, e);
    return o && (t.ticker = o), t;
  }
  function* Gee(r) {
    for (let e = r.list.length - 1; e >= 0; e--) {
      let t = r.list[e];
      if (yield t.id, t.type === "table" && t.columns) {
        for (let o = t.columns.length - 1; o >= 0; o--) {
          yield t.columns[o].id;
        }
      }
      t.type === "table" && t.regression && (yield t.regression.id);
    }
  }
  function iq(r) {
    let e = 0, t = /^[0-9]+$/;
    for (let o of Gee(r)) {
      if (t.test(o)) {
        let i = parseInt(o, 10);
        i > e && (e = i);
      }
    }
    return e;
  }
  function nq(r, e, t) {
    t || (t = {});
    let o, i;
    for (
      r.colorIdx = 0, Aee(r), r.expressionAnalysis = {}, o = 0;
      o < e.list.length;
      o++
    ) {
      if (
        i = Qf(r, e.list[o]), t.remapColors && "color" in i && i.color
      ) {
        let n = __dcg_shared_module_exports__["C"](
          r.controller.getColors(),
        );
        __dcg_shared_module_exports__["l"](n, i.color) ||
          (i.color = UU(i.color, n));
      }
      r.__itemModelArray.push(i), r.__itemIdToModel[i.id] = i;
    }
    if (r.ticker = JG(e.ticker), _g(r), r.nextDisplayIndex === "1") {
      let n = Qf(r, {
        type: "expression",
        id: r.controller.generateId(),
        color: r.controller.getNextColor(),
      });
      _s(r, n, r.__itemModelArray.length);
    }
  }
  function Qf(r, e) {
    switch (e.type) {
      case "expression":
        return zE(e, r.controller);
      case "table":
        return sz(e, r.controller);
      case "image":
        return l4(e, r.controller);
      case "folder":
        return Mz(e, r.controller);
      case "text":
        return m4(e, r.controller);
      default:
        return e;
    }
  }
  function aq(r, e) {
    let t, o, i = r.__itemIdToModel;
    for (
      r.__itemModelArray = [],
        r.__itemIdToModel = {},
        r.renamePrompt.invalidate(),
        t = 0;
      t < e.list.length;
      t++
    ) {
      let n = e.list[t];
      if (o = i[n.id], o && o.type === n.type) {
        switch (o.type) {
          case "expression":
            if (n.type !== o.type) throw new Error("invalid restoration");
            wq(o, n);
            break;
          case "table":
            if (n.type !== o.type) throw new Error("invalid restoration");
            az(o, n);
            break;
          case "image":
            if (n.type !== o.type) throw new Error("invalid restoration");
            c4(o, n);
            break;
          case "folder":
            {
              if (n.type !== o.type) {
                throw new Error("invalid restoration");
              }
              Lz(o, n);
            }
            break;
          case "text":
            if (n.type !== o.type) throw new Error("invalid restoration");
            b4(o, n);
            break;
          default:
            return o;
        }
      } else o = Qf(r, n);
      r.__itemModelArray.push(o), r.__itemIdToModel[o.id] = o;
    }
    e.ticker && E4(r.ticker, e.ticker),
      ZG(r),
      RE(r),
      Dw(r),
      X4(r, void 0),
      _g(r);
  }
  function sq(r, e, t) {
    let o = t[0] && t[0].tableId, i = bd(r, o || e);
    if (!i) return;
    let n;
    switch (i.type) {
      case "expression":
        let a = false, s = false, l;
        i.__workerNeedsDotplotXMode = false;
        for (let p = 0; p < t.length; p++) {
          let h = t[p];
          if (
            "recursionTerminationStatus" in h &&
            h.recursionTerminationStatus === 1 && (s = true),
              "nanBlame" in h && h.nanBlame !== void 0 &&
              (l = h.nanBlame),
              h.graphMode === 15
          ) {
            i.error = h.error;
            continue;
          }
          "resolved" in h && !h.resolved && (a = true),
            "boundingBox" in h && h.boundingBox &&
            (n || (n = []), n.push(h.boundingBox)),
            h.needsDotplotXMode && (i.__workerNeedsDotplotXMode = true);
        }
        i.unresolved = a,
          i.boundingBoxes = n,
          i.recursiveDepthPlottingError = s,
          i.nanBlame = l;
        let c = 1 / 0, d = -1 / 0;
        for (let p of t) {
          if (p.graphMode !== 6) continue;
          let h = p.sampledDomain;
          h && (c = Math.min(c, h.min), d = Math.max(d, h.max));
        }
        isFinite(c) && (i.__workerSampledDomainMin = c),
          isFinite(d) && (i.__workerSampledDomainMax = d);
        return;
      case "table":
        for (let p = 0; p < t.length; p++) {
          let h = t[p];
          "boundingBox" in h && h.boundingBox &&
            (n || (n = []), n.push(h.boundingBox));
        }
        n && xz(i, e, n);
        return;
      default:
        return;
    }
  }
  function lq(r, e, t) {
    var s;
    let o,
      i,
      n,
      a = __dcg_shared_module_exports__["Jc"](r.expressionAnalysis);
    for (o in e) {
      if (!e.hasOwnProperty(o)) continue;
      n = e[o], i = bd(r, o);
      let l = {
        isGraphable: !!n.is_graphable,
        isError: !!n.error,
        errorMessage: n.error ? r.controller.unpack(n.error) : void 0,
      };
      if (i) {
        switch (i.type) {
          case "expression":
            QG(i, n);
            let { value: d, valueType: p } =
              (s = n.typed_constant_value) != null ? s : {};
            d !== void 0 &&
              (p === __dcg_shared_module_exports__["ListOfNumber"]
                ? l.evaluation = {
                  type: "ListOfNumber",
                  value: d.slice(),
                }
                : __dcg_shared_module_exports__["isSubTypeOrCoercible"](
                  p,
                  __dcg_shared_module_exports__["Number"],
                ) && (l.evaluation = { type: "Number", value: d }),
                l.evaluationDisplayed = !!n.is_evaluable);
            break;
          case "image":
            a4(i, n);
            break;
          case "table":
            rz(i, n);
            break;
          case "folder":
          case "text":
            break;
          default:
            return i;
        }
      } else o === r.ticker.id && T4(r.ticker, n);
      let c = kee(r, o);
      if (c) Jz(r.controller, c, n);
      else {
        let d = r.__toolPreviewIdToModel[o];
        d && QG(d, n);
      }
      o.startsWith(Wf) &&
      Wz(r.controller.getGeometryToolbarModel(), o, n),
        o !== r.ticker.id && !o.startsWith(Wf) && (a[o] = l);
    }
    ZG(r), Dw(r), RE(r), X4(r, t), r.expressionAnalysis = a;
  }
  function Nr(r, e) {
    r.selectedItemMap = {}, e && (r.selectedItemMap[e.id] = "selected");
  }
  function cq(r) {
    return Object.values(r.selectedItemMap).some((e) =>
      e === "tentatively-selected"
    );
  }
  function dq(r, e) {
    r.selectedItemMap = {},
      e && (r.selectedItemMap[e.id] = "tentatively-selected");
  }
  function pq(r) {
    for (let e in r.selectedItemMap) {
      r.selectedItemMap[e] === "tentatively-selected" &&
        (r.selectedItemMap[e] = "selected");
    }
  }
  function uq(r) {
    for (let e in r.selectedItemMap) {
      r.selectedItemMap[e] === "tentatively-selected" &&
        delete r.selectedItemMap[e];
    }
  }
  function tL(r, e, t) {
    r.selectedItemMap[e]
      ? delete r.selectedItemMap[e]
      : r.selectedItemMap[e] = t;
  }
  function rL(r, e) {
    r.selectedItemMap = {};
    for (let t in e) r.selectedItemMap[t] = "selected";
  }
  function Uu(r, e, t, o) {
    if (e === t) return;
    let i = r.__itemModelArray.splice(e, o);
    e < t && (t = t - o + 1),
      r.__itemModelArray.splice.apply(r.__itemModelArray, [t, 0, ...i]),
      _g(r);
  }
  function _s(r, e, t) {
    let o = String(e.id);
    if (r.__itemIdToModel.hasOwnProperty(o)) {
      throw Error("Item with id '" + o + "' is already in list");
    }
    r.__itemIdToModel[o] = e, r.__itemModelArray.splice(t, 0, e), _g(r);
  }
  function ol(r, e) {
    _s(r, e, kw(r));
  }
  function ib(r, e) {
    let t = [], o = r.__itemModelArray[e];
    if (o.type === "folder") {
      let i = 0, n = e + 1;
      for (let a = n; a < r.__itemModelArray.length; a++) {
        let s = r.__itemModelArray[a];
        if (s.type === "folder" || s.folderId !== o.id) break;
        Sa(s) && Nr(r, void 0),
          s.readonly
            ? (a > n &&
              (r.__itemModelArray[a] = r.__itemModelArray[n],
                r.__itemModelArray[n] = s),
              _n(s, ""),
              n += 1)
            : (delete r.__itemIdToModel[s.id],
              delete r.expressionAnalysis[o.id],
              i += 1);
      }
      i > 0 && t.push(...r.__itemModelArray.splice(n, i));
    }
    return Sa(o) && Nr(r, void 0),
      t.push(...r.__itemModelArray.splice(e, 1)),
      delete r.__itemIdToModel[o.id],
      delete r.expressionAnalysis[o.id],
      ZG(r),
      t.some((i) => Is(i)) && Dw(r),
      _g(r),
      t;
  }
  function hq(r) {
    return r.__anyDependsOnRandomSeed;
  }
  function gq(r) {
    return r.__anyFunctionDefinitionsDependOnRandomSeed;
  }
  function mq(r) {
    return r.__anyIsAction;
  }
  function fq(r) {
    return r.__anyUnmutedTones;
  }
  function Ag(r, e) {
    let t = bd(r, e);
    return t ? ib(r, t.index) : [];
  }
  function NE(r) {
    let e = Ig(r);
    if (!e) return false;
    let t = Ew(r, e.index);
    return t
      ? (Nr(r, t),
        t.index === kw(r) - 1 && e.type === "expression" && Vl(e) &&
        ib(r, t.index),
        true)
      : false;
  }
  function BE(r) {
    let e = Ig(r);
    if (!e) return false;
    let t = Tw(r, e.index);
    return t ? (Nr(r, t), true) : false;
  }
  function bq(r, e) {
    let t = r.selectedItemMap;
    return e in t ? t[e] : void 0;
  }
  function Sa(r) {
    return !!r.controller.getListModel().selectedItemMap[r.id];
  }
  function yq(r) {
    if (!r.controller.shouldShowAuthorFeatures()) {
      r.renamePrompt.invalidate();
      return;
    }
    let e = Ig(r);
    r.renamePrompt.updateForSelectedItem(r, e);
  }
  function _w(r, e) {
    r.dragState = e;
  }
  function Iw(r) {
    switch (r.type) {
      case "expression":
        return ab(r);
      case "image":
        return TE(r);
      case "table":
        return [];
      case "text":
        return [];
      case "folder":
        return [];
      default:
        return r;
    }
  }
  function xq(r, e) {
    for (let t of VE(r)) t.type === "folder" && Kf(t, e);
  }
  function nb(r) {
    return r
      ? r.type === "image" && Dg(r) || r.type === "expression" && $n(r)
      : false;
  }
  function oL(r) {
    return r.__exportedVariables;
  }
  Ss();
  var hb = class {
    suspend() {
      return new Promise((e, t) => {
        if (this.audioContext) {
          this.audioContext.suspend().then(() => {
            e();
          }).catch((o) => {
            So(o), t(o);
          });
        } else {
          e();
          return;
        }
      });
    }
    getResumedAudioContext() {
      return new Promise((e, t) => {
        if (!this.audioContext) {
          let o = window.AudioContext || window.webkitAudioContext;
          if (!o) {
            t();
            return;
          }
          try {
            this.audioContext = new o({
              latencyHint: "interactive",
              sampleRate: 44100,
            });
          } catch (i) {
            t(i);
          }
        }
        this.audioContext &&
          (this.audioContext.state !== "running"
            ? this.audioContext.resume().then(() => {
              e({
                audioContext: this.audioContext,
                poiBuffer: this.poiBuffer,
              });
            }).catch((o) => {
              So(o), t(o);
            })
            : this.audioContext.resume().then(() => {
              e({
                audioContext: this.audioContext,
                poiBuffer: this.poiBuffer,
              });
            }).catch((o) => {
              So(o), t(o);
            }));
      });
    }
  };
  var Lee = .25;
  function vq(r, e) {
    return Lee * __dcg_shared_module_exports__["$"](r, 0, Pee(e));
  }
  function Pee(r) {
    return r <= 0 || !isFinite(r)
      ? 0
      : __dcg_shared_module_exports__["$"](660 / r, 0, 10);
  }
  var jn,
    Vee = "data:audio/mpeg;base64,//uQx" + "A".repeat(23) +
      "WGluZwAAAA8AAAACAAACcQCA" + "gICA".repeat(16) + "/".repeat(66) +
      "8AAABhTEFNRTMuMTAwA8MAAAAAAAAAABQgJAUHQQAB9AAAAnGMHkkI" +
      "A".repeat(320) + "//sQxAADgnABGiAAQBCqgCRMAAgEAH" +
      "/".repeat(15) +
      "7+n/9FTuQsQH//////2NG0jWUGlio5gLQTOtIoeR2WX////X4s9Atb/JRVCbBUpeRUq" +
      "/".repeat(18) +
      "9RUi0f2jn/+xDECgPCjAEQAABN4AAANIAAAAQVTEFNRTMuMTAw" +
      "V".repeat(97) + "Q==";
  function Oee() {
    jn && (jn.src = "about:blank", jn.load(), jn = void 0);
  }
  function jE() {
    if (!(!tl && !Ml)) {
      if (!jn) {
        let r = document.createElement("div");
        jn = document.createElement("audio"),
          r.appendChild(jn),
          jn.setAttribute("x-webkit-airplay", "deny"),
          jn.controls = false,
          jn.disableRemotePlayback = true,
          jn.preload = "auto",
          jn.loop = true,
          jn.src = Vee,
          jn.load();
      }
      jn.paused && jn.play().catch(Oee);
    }
  }
  function YE() {
    jn && jn.pause();
  }
  var Cq = 44100,
    xd = FS ? .02 : 0,
    Nw = class {
      constructor(e) {
        this.expressionSynthMap = new Map();
        this.useOfflineContext = false;
        this.globalUnmuteState = false;
        this.hasEverInteractedWithMute = false;
        this.maxGain = .5;
        this.handleVisibilityChange = () => {
          !this.audioContext || this.isGlobalMuted() ||
            document.visibilityState === "hidden" &&
              this.controller.dispatch({ type: "mute-global" });
        };
        this.handleBeforeUnload = () => {
          if (!this.audioContext || this.isGlobalMuted()) return;
          let e = this.audioContext;
          e instanceof AudioContext && setTimeout(() => {
            if (e.state !== "closed") {
              try {
                e.close();
              } catch (t) {}
            }
          }, 100),
            this.controller.dispatch({ type: "mute-global" }),
            this.controller.runAfterDispatch(() => this.clearAudioContext());
        };
        this.audioContextManager = new hb(),
          this.controller = e,
          document.addEventListener(
            "visibilitychange",
            this.handleVisibilityChange,
          ),
          window.addEventListener(
            "beforeunload",
            this.handleBeforeUnload,
          );
      }
      unload() {
        this.handleBeforeUnload();
      }
      setOfflineAudio() {
        this.useOfflineContext = true;
      }
      prepareToRenderAudio(e) {
        this.useOfflineContext &&
          (this.offlineBuffer = void 0,
            this.audioContext = new OfflineAudioContext(1, e * Cq, Cq),
            this.audioContext.addEventListener("complete", async (t) => {
              this.offlineBuffer = t.renderedBuffer, this.clearAudioContext();
            }),
            this.createMainNodes(),
            this.recomputeAudio());
      }
      getHasEverInteractedWithMute() {
        return this.hasEverInteractedWithMute;
      }
      registerMuteInteraction() {
        this.hasEverInteractedWithMute = true;
      }
      async startRendering() {
        return this.audioContext.startRendering();
      }
      getRenderedBuffer() {
        return this.offlineBuffer;
      }
      clearAudioContext() {
        for (let e of this.expressionSynthMap.values()) e.tearDown();
        this.audioContext = void 0, this.expressionSynthMap = new Map();
      }
      async spinUpAudioContext() {
        if (!this.useOfflineContext) {
          if (this.audioContext) {
            this.audioContext.state === "suspended" &&
              !this.useOfflineContext && await this.audioContext.resume();
          } else {
            let e = await this.audioContextManager
              .getResumedAudioContext();
            this.audioContext = e.audioContext;
          }
          this.gainNode || this.createMainNodes();
        }
      }
      createMainNodes() {
        this.audioContext &&
          (this.gainNode = this.audioContext.createGain(),
            this.gainNode.gain.value = 0,
            this.compressor = this.audioContext
              .createDynamicsCompressor(),
            this.compressor.threshold.value = -10,
            this.compressor.knee.value = 4,
            this.compressor.ratio.value = 20,
            this.compressor.attack.value = .01,
            this.compressor.release.value = .01,
            this.gainNode.connect(this.compressor),
            this.compressor.connect(this.audioContext.destination));
      }
      async _recomputeAudio(e) {
        var t, o, i, n, a, s, l;
        if (
          e.length !== 0 &&
          !(this.nothingShouldSound() &&
            ((t = this.audioContext) == null ? void 0 : t.state) !==
              "running")
        ) {
          if (this.useOfflineContext) { if (!this.audioContext) return; }
          else await this.spinUpAudioContext();
          if (this.nothingShouldSound()) {
            if (this.expressionSynthMap.size > 0) {
              for (let c of this.expressionSynthMap.values()) {
                c.tearDown();
              }
              this.expressionSynthMap.clear();
            }
          } else {for (let c of e) {
              let d = c.type === "expression"
                  ? c.formula.typed_constant_value
                  : void 0,
                p = c.id;
              d && !this.expressionSynthMap.has(p) &&
              this.expressionSynthMap.set(p, new XE(this, this.gainNode)),
                (o = this.expressionSynthMap.get(p)) == null ||
                o.updateFromValues(d),
                c.type === "remove" && this.expressionSynthMap.has(p)
                  ? ((i = this.expressionSynthMap.get(p)) == null ||
                    i.tearDown(),
                    this.expressionSynthMap.delete(p))
                  : c.type === "expression" &&
                    (Bw(c)
                      ? (a = this.expressionSynthMap.get(p)) == null ||
                        a.setGain(0)
                      : (n = this.expressionSynthMap.get(p)) == null ||
                        n.setGain(this.maxGain));
            }}
          this.audioContext &&
            (this.expressionSynthMap.size > 0 && !this.isGlobalMuted()
              ? (s = this.gainNode) == null ||
                s.gain.setTargetAtTime(
                  1,
                  this.audioContext.currentTime + xd,
                  Sp,
                )
              : (l = this.gainNode) == null ||
                l.gain.setTargetAtTime(
                  0,
                  this.audioContext.currentTime + xd,
                  Sp,
                ));
        }
      }
      nothingShouldSound() {
        return !this.globalUnmuteState || !this.hasAnyUnmutedTones();
      }
      recomputeAudio() {
        Dw(this.controller.getListModel());
        let t = this.controller.getAllItemModels().filter((n) => Aw(n)),
          o = [],
          i = new Set(t.map((n) => n.id));
        for (let n of this.expressionSynthMap.keys()) {
          i.has(n) || o.push({ id: n, type: "remove" });
        }
        this._recomputeAudio([...t, ...o]);
      }
      isGlobalMuted() {
        return !this.globalUnmuteState;
      }
      someExpressionsShouldPlayTones() {
        var e, t;
        return (t = (e = this.controller) == null
            ? void 0
            : e.getAllItemModels()) == null
          ? void 0
          : t.some((o) => Aw(o));
      }
      hasAnyUnmutedTones() {
        return fq(this.controller.getListModel());
      }
      handleAction(e) {
        var t, o, i, n;
        switch (e.type) {
          case "mute-global": {
            YE(),
              this.globalUnmuteState = false,
              (o = (t = this.controller).logEvent) == null ||
              o.call(t, { category: "tone", action: "mute-global" });
            break;
          }
          case "unmute-global": {
            jE(),
              this.globalUnmuteState = true,
              this.hasEverInteractedWithMute = true,
              (n = (i = this.controller).logEvent) == null ||
              n.call(i, { category: "tone", action: "unmute-global" });
            break;
          }
          default:
            return e;
        }
        this.recomputeAudio();
      }
      handleMuteKeyShortcut() {
        this.controller.toneItemsExist()
          ? this.isGlobalMuted()
            ? (this.controller.dispatch({ type: "unmute-global" }),
              yt(
                this.controller.s(
                  "graphing-calculator-narration-unmuted",
                ),
              ),
              this.someExpressionsShouldPlayTones() ||
              yt(
                this.controller.s(
                  "graphing-calculator-narration-no-playing-tones",
                ),
              ))
            : (this.controller.dispatch({ type: "mute-global" }),
              yt(
                this.controller.s("graphing-calculator-narration-muted"),
              ))
          : yt(
            this.controller.s(
              "graphing-calculator-narration-no-tone-expressions",
            ),
          ), xe();
      }
    };
  var Sp = .005,
    Ree = 15e-5,
    gb = 20,
    mb = 2e4,
    iL = class {
      constructor(e, t) {
        e.audioContext &&
          (this.audioContext = e.audioContext,
            this.oscillator = this.audioContext.createOscillator(),
            this.oscillator.type = "sine",
            this.gain = this.audioContext.createGain(),
            this.gain.gain.value = 0,
            this.oscillator.connect(this.gain),
            this.gain.connect(t),
            this.oscillator.start());
      }
      stop(e = 0) {
        this.gain.gain.setTargetAtTime(
          0,
          this.audioContext.currentTime + e + xd,
          Sp,
        ),
          setTimeout(() => {
            this.oscillator.stop();
          }, 1e3 * (2 * Sp + e + xd) + 1);
      }
      setFrequencyAndGain(e, t) {
        (!isFinite(e) || !isFinite(t) || e > mb || e < gb) && (t = 0);
        let o = vq(t, e);
        o > 0 &&
        this.oscillator.frequency.setTargetAtTime(
          __dcg_shared_module_exports__["$"](e, gb, mb),
          this.audioContext.currentTime + xd,
          Ree,
        ),
          this.gain.gain.setTargetAtTime(
            o,
            this.audioContext.currentTime + xd,
            Sp,
          );
      }
    },
    XE = class {
      constructor(e, t) {
        e.audioContext &&
          (this.audioContext = e.audioContext,
            this.gain = this.audioContext.createGain(),
            this.gain.gain.value = 0,
            this.gain.connect(t),
            this.synthesizers = []);
      }
      updateFromValues(e) {
        var t, o, i;
        if (e && e.valueType === __dcg_shared_module_exports__["Tone"]) {
          this.synthesizers.length > 1
            ? (this.tearDownSynthesizers(this.synthesizers.slice(1)),
              this.synthesizers.length = 1)
            : this.synthesizers.length === 0 &&
              (this.synthesizers = [this.makeSynth()]),
            (t = this.synthesizers[0]) == null ||
            t.setFrequencyAndGain(e.value[0], e.value[1]);
        } else if (
          e && e.valueType === __dcg_shared_module_exports__["ListOfTone"]
        ) {
          if (
            this.synthesizers.length > e.value.length &&
            (this.tearDownSynthesizers(
              this.synthesizers.slice(e.value.length),
            ),
              this.synthesizers.length = e.value.length),
              e.value.length > this.synthesizers.length
          ) {
            for (
              let n = this.synthesizers.length;
              n < e.value.length;
              n++
            ) this.synthesizers.push(this.makeSynth());
          }
          for (let n = 0; n < e.value.length; n++) {
            this.synthesizers[n].setFrequencyAndGain(
              e.value[n][0],
              e.value[n][1],
            );
          }
        } else {this.tearDownSynthesizers(this.synthesizers),
            this.synthesizers = [];}
        this.synthesizers.length > 0
          ? (o = this.gain) == null ||
            o.gain.setTargetAtTime(
              1,
              this.audioContext.currentTime + xd,
              Sp,
            )
          : (i = this.gain) == null ||
            i.gain.setTargetAtTime(
              0,
              this.audioContext.currentTime + xd,
              Sp,
            );
      }
      makeSynth() {
        return new iL(this, this.gain);
      }
      tearDownSynthesizers(e) {
        if (e) { for (let t of e) t.stop(); }
      }
      setGain(e) {
        this.gain.gain.setTargetAtTime(
          e,
          this.audioContext.currentTime + xd,
          Sp,
        );
      }
      tearDown() {
        this.tearDownSynthesizers(this.synthesizers), this.synthesizers = [];
      }
    };
  var zw = 4;
  function sL(r) {
    return r === void 0 ? NaN : +r;
  }
  function il(r) {
    return !!r && r.type === "expression" && !!r.formula &&
      !!r.formula.typed_constant_value && !!r.formula.geometry;
  }
  function Eq(r) {
    var t, o;
    let e = r.formula;
    return e
      ? r.controller.isDecimalToFractionEnabled() &&
        ((t = e.typed_constant_value) == null ? void 0 : t.valueType) ===
          __dcg_shared_module_exports__["Number"] &&
        __dcg_shared_module_exports__["canDisplayAsFraction"](
          sL((o = e.typed_constant_value) == null ? void 0 : o.value),
        )
      : false;
  }
  function qw(r) {
    return !!(r.formula && r.formula.is_graphable);
  }
  function JE(r) {
    return !(!vd(r) || !fT(r) || !mT(r));
  }
  function lL(r) {
    var a, s;
    let e = r.formula;
    if (!e) return false;
    if (e.warning) {
      let l = (a = r.formula.typed_constant_value) == null ? void 0 : a.value;
      if (l === void 0 || Number.isNaN(l)) return false;
    }
    let o = !(e.operator === "=" && r.controller.isThreeDMode() &&
        (e.assignment === "x" || e.assignment === "y" ||
          e.assignment === "z" || e.assignment === "r")) &&
        e.is_evaluable &&
        ((s = e.typed_constant_value) == null ? void 0 : s.value) !==
          void 0 &&
        e.typed_constant_value.valueType !==
          __dcg_shared_module_exports__["Bool"] &&
        !(__dcg_shared_module_exports__["Wc"](r.latex) instanceof
          __dcg_shared_module_exports__["Nu_Equation"]),
      i = Eq(r) && Hu(r),
      n = !!e.rgb_value && r.formula.assignment;
    return !!(o || i || n);
  }
  function Ep(r) {
    var a, s, l;
    let e = (a = r.formula) == null ? void 0 : a.recursion;
    if (!e || e.type === "iterative" || !e.recursiveStructure) return [];
    if (e.recursionGroup.length > 1) return [];
    let {
        maxRecursiveCallOffsets: t,
        parameterSymbols: o,
        baseCaseInfo: i,
      } = e.recursiveStructure,
      n = [];
    for (let c in t) {
      if (((s = o[c]) == null ? void 0 : s.length) !== 1) continue;
      let d = i[c];
      if (d && Math.abs(d.min) > AG) continue;
      let p = t[c], h, u;
      d ? (h = d.min + p - 1, u = d.min + d.consecutiveCount) : (h = p, u = 1);
      for (let f = u; f <= h; f++) {
        if (
          !((l = d == null ? void 0 : d.additional) != null &&
            l.includes(f)) &&
          (n.push(
            `${
              __dcg_shared_module_exports__["identifierToLatex"](c)
            }\\left(${f}\\right)`,
          ),
            n.length > zw)
        ) return [];
      }
    }
    return n;
  }
  function cL(r) {
    var t;
    let e = (t = r.formula.typed_constant_value) == null ? void 0 : t.value;
    return r.formula.rgb_value ? r.formula.rgb_value : lL(r) || Eq(r) ? e : NaN;
  }
  function Hw(r) {
    let e = r.formula.ttest_results;
    if (!(!e || !isFinite(e.lessThan))) {
      return {
        lessThan: e.lessThan,
        greaterThan: e.greaterThan,
        notEqual: e.notEqual,
      };
    }
  }
  function Tq(r) {
    let e = r.formula.stats_results;
    if (!(!e || !isFinite(e.min))) {
      return {
        min: e.min,
        q1: e.q1,
        median: e.median,
        q3: e.q3,
        max: e.max,
      };
    }
  }
  function qu(r, e) {
    if (!isFinite(e)) return r;
    let t = r.indexOf("=") + 1;
    return io(r.slice(t), false) === e
      ? r
      : r.slice(0, t) + __dcg_shared_module_exports__["ce"](e);
  }
  function Vl(r) {
    let e = r.latex || "", t = r.label || "";
    return (e + t).split(" ").join("") === "";
  }
  function Ro(r, e = { isReverseDrag: false }) {
    let t = r.dragMode === "AUTO" && r.formula.default_drag_mode !== void 0
      ? r.formula.default_drag_mode
      : r.dragMode;
    return r.controller.isThreeDMode() && (t = "NONE"),
      r.dragMode === "AUTO" && !e.isReverseDrag && Hi(r) && (t = "NONE"),
      __dcg_shared_module_exports__["Gb"](t, r.formula.move_strategy);
  }
  function Bee(r) {
    let e = Ro(r);
    r.interactiveLabel && e !== "NONE" && $w(r, false);
  }
  function Ol(r, e, t) {
    if (!r.sliderExists) return NaN;
    let o = nl(r), i = bc(r), n = Rl(r);
    if (
      t && t.overwriteStep !== void 0 && (n = t.overwriteStep),
        e = __dcg_shared_module_exports__["zc"]({
          target: e,
          hardMin: r.slider.hardMin ? o : void 0,
          hardMax: r.slider.hardMax ? i : void 0,
          step: n,
        }),
        !t || !t.ignoreSoftLimits
    ) {
      if (!r.slider.hardMin && e < o) return o;
      if (!r.slider.hardMax && e > i) return i;
    }
    return e;
  }
  function dL(r, e, t = {}) {
    if (!r.sliderExists) return NaN;
    let o = al(r), i = nl(r), n = bc(r), a = Rl(r);
    t.overwriteStep === void 0 && (t.overwriteStep = a || (n - i) / 20);
    let s = 0;
    switch (e) {
      case "min":
        return Ol(r, i);
      case "max":
        return Ol(r, n);
      case "up":
        s = 1;
        break;
      case "down":
        s = -1;
        break;
      case "bigup":
        s = 5;
        break;
      case "bigdown":
        s = -5;
        break;
      default:
        return e;
    }
    let l = o;
    for (let c = 0; c < 20; c++) {
      let d = c / 3 * t.overwriteStep, p = o;
      if (s > 0) o = Ol(r, l + d, t), o > p && (s -= 1);
      else if (s < 0) o = Ol(r, l - d, t), o < p && (s += 1);
      else break;
    }
    return o;
  }
  function QE(r, e) {
    if (!r.sliderExists) return;
    r.slider.isPlaying && As(r, false);
    let t = Ol(r, e, { ignoreSoftLimits: true });
    r.latex = qu(r.latex, t);
  }
  function Dq(r, e, t) {
    if (!r.sliderExists) return;
    r.slider.isPlaying && As(r, false), yb(r);
    let o = dL(r, e, t);
    r.latex = qu(r.latex, o);
  }
  function kq(r, e) {
    if (!r.sliderExists) return;
    r.slider.isPlaying && As(r, false);
    let t = Ol(r, e);
    r.latex = qu(r.latex, t);
  }
  function _q(r, e) {
    if (!r.sliderExists || r.resetSliderAnimationTargetValue) return;
    let t = r.sliderLastTickTime;
    if (r.sliderLastTickTime = e, t === void 0) return;
    let o = e - t,
      i = nl(r),
      n = bc(r),
      a = Rl(r),
      s = r.slider.animationPeriod,
      l = r.slider.loopMode;
    if (isNaN(r.sliderAnimationTargetValue)) {
      let h = al(r);
      isNaN(h) || (r.sliderAnimationTargetValue = h);
    }
    let c = a ? a / 2 : 0;
    if (l === "LOOP_FORWARD_REVERSE") {
      r.sliderAnimationTargetValue >= n
        ? In(r, { playDirection: -1 })
        : r.sliderAnimationTargetValue <= i &&
          In(r, { playDirection: 1 });
    } else if (l === "LOOP_FORWARD") {
      In(r, { playDirection: 1 }),
        r.sliderAnimationTargetValue >= n + c &&
        (r.sliderAnimationTargetValue = i - c);
    } else if (l === "PLAY_ONCE") In(r, { playDirection: 1 });
    else if (l === "PLAY_INDEFINITELY") In(r, { playDirection: 1 });
    else throw new Error("Unexpected slider loop mode: " + l);
    isFinite(o) || (o = 0);
    let d, p;
    if (l === "PLAY_INDEFINITELY") {
      d = o / (s / 4),
        a && (d *= a),
        r.sliderAnimationTargetValue += d,
        p = r.sliderAnimationTargetValue,
        a || (p = ho(p - d * .1, p + d * .1)),
        p = Ol(r, p, { ignoreSoftLimits: true }),
        r.latex = qu(r.latex, p);
    } else {
      if (
        o = Math.min(o, s / 10),
          d = (n - i) * o / s,
          r.sliderAnimationTargetValue += d * r.slider.playDirection,
          r.sliderAnimationTargetValue = Math.max(
            i - c,
            Math.min(n + c, r.sliderAnimationTargetValue),
          ),
          p = r.sliderAnimationTargetValue,
          !a
      ) {
        let h = d / o * 16.666666666666668;
        p = ho(p - h * .1, p + h * .1);
      }
      p = Ol(r, p), r.latex = qu(r.latex, p);
    }
  }
  function ab(r) {
    let e = r.formula;
    return e
      ? e.is_single_identifier
        ? []
        : e.variables.map((t) =>
          __dcg_shared_module_exports__["identifierToLatex"](t)
        ) || []
      : [];
  }
  function QG(r, e) {
    r.formula = e,
      r.error = e.error,
      r.unresolved = false,
      r.expressionTooComplex = false,
      r.recursiveDepthPlottingError = false,
      r.nanBlame = __dcg_shared_module_exports__["Zd"].None,
      e.is_slider
        ? (!r.sliderExists || r.resetSliderAnimationTargetValue) &&
          (r.sliderAnimationTargetValue = al(r),
            r.sliderDragging = false,
            r.sliderExists = true)
        : r.sliderExists = false,
      r.resetSliderAnimationTargetValue = false;
    let t = {};
    e.is_regression &&
    (t = e.regression.parameters,
      r.residualVariable = e.regression.residualVariable,
      r.controller.areLogModeRegressionsForced() &&
      (r.isLogModeRegression = true)),
      __dcg_shared_module_exports__["E"](r.regressionParameters, t) ||
      (r.regressionParameters = t);
  }
  function Is(r) {
    var e, t;
    return r.type === "expression" &&
      (((e = r.formula.typed_constant_value) == null ? void 0 : e.valueType) ===
          __dcg_shared_module_exports__["Tone"] ||
        ((t = r.formula.typed_constant_value) == null
            ? void 0
            : t.valueType) === __dcg_shared_module_exports__["ListOfTone"]);
  }
  function Iq(r) {
    var t, o, i, n;
    if (
      !Is(r) ||
      ((t = r.formula.typed_constant_value) == null ? void 0 : t.valueType) ===
        __dcg_shared_module_exports__["ListOfTone"] ||
      ((o = r.formula.typed_constant_value) == null ? void 0 : o.valueType) ===
            __dcg_shared_module_exports__["Tone"] &&
        ((i = r.formula.typed_constant_value) == null ? void 0 : i.value[0]) >=
          gb &&
        ((n = r.formula.typed_constant_value) == null ? void 0 : n.value[0]) <=
          mb
    ) return false;
    let e = __dcg_shared_module_exports__["Wc"](r.latex);
    return !!(e && e._dependencies && e._dependencies.length === 1);
  }
  function Bw(r) {
    var e;
    return !!r.hidden || !!((e = Ca(r)) != null && e.hidden);
  }
  function Aw(r) {
    return !Is(r) || Bw(r)
      ? false
      : r.formula.typed_constant_value.valueType ===
          __dcg_shared_module_exports__["Tone"]
      ? r.formula.typed_constant_value.value[1] > 0
      : r.formula.typed_constant_value.valueType ===
          __dcg_shared_module_exports__["ListOfTone"]
      ? r.formula.typed_constant_value.value.some((e) => e[1] > 0)
      : false;
  }
  function Uee(r) {
    if (
      r.shouldGraph = !Hi(r), r.folderId === __dcg_shared_module_exports__["xd"]
    ) {
      let e = r.controller.getExpressionIdForIdentifier(
          r.controller.getHoveredOrFocusedTokenIdentifier(),
        ) === r.id,
        t = r.controller.isItemSelected(r.id);
      (e || t || r.controller.getGhostMode()) && (r.shouldGraph = true);
    }
  }
  function Hi(r) {
    var t;
    if (!r) return false;
    if (r.hidden) return true;
    if (
      (t = r == null ? void 0 : r.formula) != null && t.expression_type &&
      wb(r)
    ) return true;
    let e = Ca(r);
    return !!(e && e.hidden);
  }
  function zee(r) {
    let e = r.formula && r.formula.raw_slider_latex;
    if (!r.sliderExists || r.latex !== e) {
      r.cachedDisplayLatex = {
        storedLatex: r.latex,
        valueLatex: r.latex,
      };
      return;
    }
    let { latex: t } = r;
    if (r.cachedDisplayLatex.storedLatex !== t) {
      r.cachedDisplayLatex = {
        storedLatex: r.latex,
        valueLatex: r.latex,
      };
      return;
    }
    let o = Mq(r);
    if (isFinite(o)) {
      let i = r.controller.getFocusLocation();
      i && i.type === "expression" && i.id === r.id ||
        (r.cachedDisplayLatex.valueLatex = qu(r.latex, o));
    }
  }
  function Kw(r) {
    return r.cachedDisplayLatex.valueLatex;
  }
  function Aq(r) {
    return __dcg_shared_module_exports__["value"](r).latex;
  }
  function pL(r) {
    return r.slider.hardMin ? r.slider.min : Aq(nl(r));
  }
  function uL(r) {
    return r.slider.hardMax ? r.slider.max : Aq(bc(r));
  }
  function nl(r) {
    if (r.slider.hardMin) {
      let e = r.formula.slider_min_number;
      return isFinite(e) ? e : NaN;
    } else {
      let e = r.controller.getDegreeMode(),
        t = io(r.slider.min, e),
        o = al(r),
        i = Rl(r),
        n = r.slider.hardMax ? r.formula.slider_max_number : void 0,
        s = r.controller.is3dProduct()
          ? __dcg_shared_module_exports__["xc"].xmin
          : -10;
      if (t < s && (s = t), o < s && (s = o), n < s && (s = n), i) {
        let l = __dcg_shared_module_exports__["zc"]({
          target: s,
          hardMin: void 0,
          hardMax: n,
          step: i,
        });
        l <= s ? s = l : s = l - i;
      }
      return s;
    }
  }
  function bc(r) {
    if (r.slider.hardMax) {
      let e = r.formula.slider_max_number;
      return isFinite(e) ? e : NaN;
    } else {
      let e = r.controller.getDegreeMode(),
        t = io(r.slider.max, e),
        o = al(r),
        i = Rl(r),
        n = r.slider.hardMin ? r.formula.slider_min_number : void 0;
      return __dcg_shared_module_exports__["Ac"]({
        storedMax: t,
        sliderValue: o,
        step: i,
        hardMin: n,
        is3d: r.controller.is3dProduct(),
      });
    }
  }
  function Rl(r) {
    return r.formula.slider_step_number;
  }
  function Mq(r) {
    var t;
    if (!r.formula || !r.formula.is_slider) return;
    let e = (t = r.formula.typed_constant_value) == null ? void 0 : t.value;
    if (e !== void 0) return +e;
  }
  function al(r) {
    let e = r.formula && r.formula.raw_slider_latex;
    if (r.latex !== e) return dw(r.latex);
    let t = Mq(r);
    return isFinite(t) ? t : NaN;
  }
  function hL(r) {
    return r.slider.loopMode !== "PLAY_ONCE" ? false : al(r) >= bc(r);
  }
  function Gq(r, e) {
    return r.formula.viz_valids ? !!r.formula.viz_valids[e] : false;
  }
  function Tp(r, e) {
    return r.vizProps[e];
  }
  function Lq(r, e, t) {
    r.vizProps = { ...r.vizProps, [e]: t };
  }
  function fb(r, e) {
    if (e.type === "inert") {
      r.disableGraphInteractions = e.disableGraphInteractions,
        e.disableGraphInteractions &&
        (r.dragMode = "NONE",
          r.clickableInfo = { ...r.clickableInfo, enabled: false },
          r.editableLabelMode = "NONE",
          r.interactiveLabel = false);
    } else if (e.type === "drag-mode") {
      let t = e.dragMode;
      r.dragMode = t,
        t !== "NONE" && (r.disableGraphInteractions = false),
        r.movablePointSize !== r.pointSize &&
        (t === "NONE"
          ? r.pointSize = r.movablePointSize
          : r.movablePointSize = r.pointSize);
    } else {e.type === "clickable"
        ? (r.clickableInfo = e.clickableInfo,
          e.clickableInfo.enabled && (r.disableGraphInteractions = false))
        : e.type === "editable-label"
        ? (r.editableLabelMode = e.editable,
          e.editable !== "NONE" && (r.disableGraphInteractions = false))
        : e.type === "interactive-label" &&
          (r.interactiveLabel = e.interactive,
            e.interactive && (r.disableGraphInteractions = false));}
  }
  function Pq(r, e, t) {
    fb(r, {
      type: "clickable",
      clickableInfo: { ...r.clickableInfo, [e]: t },
    });
  }
  function UE(r, e) {
    fb(r, {
      type: "clickable",
      clickableInfo: { ...r.clickableInfo, latex: e },
    });
  }
  function $n(r) {
    var e;
    return !!(r.clickableInfo.enabled && OL(r) &&
      ((e = r.formula.click_handler) == null ? void 0 : e.status) ===
        "maybe-valid");
  }
  function bb(r) {
    return !!(r && r.type === "expression" && $n(r));
  }
  function Vq(r) {
    return !!r.__workerNeedsDotplotXMode;
  }
  function ZE(r) {
    return !!(r.formula && r.formula.slider_min_valid);
  }
  function eT(r) {
    return !!(r.formula && r.formula.slider_max_valid);
  }
  function tT(r) {
    return !!(r.formula && r.formula.slider_step_valid);
  }
  function rT(r, e) {
    var t;
    if (!e) {
      throw new Error("Programming Error in test. Pass domain variable");
    }
    return (t = r.formula.domains) == null
      ? void 0
      : t.find((o) => o.variable === e);
  }
  function Oq(r, e) {
    if (!r.formula) return NaN;
    if (Sb(r) && isFinite(r.__workerSampledDomainMin)) {
      return r.__workerSampledDomainMin;
    }
    let t = rT(r, e), o = t == null ? void 0 : t.minNumber;
    return o !== void 0 && isFinite(o) ? o : NaN;
  }
  function Rq(r, e) {
    if (!r.formula) return NaN;
    if (Sb(r) && isFinite(r.__workerSampledDomainMax)) {
      return r.__workerSampledDomainMax;
    }
    let t = rT(r, e), o = t == null ? void 0 : t.maxNumber;
    return o !== void 0 && isFinite(o) ? o : NaN;
  }
  function Fq(r, e) {
    let t = rT(r, e);
    return t ? t.minValid : false;
  }
  function Nq(r, e) {
    let t = rT(r, e);
    return t ? t.maxValid : false;
  }
  function Mw(r, e) {
    let t = r.cachedViewState;
    if (
      (!e.stripDefaults || r.parametricDomain.min !== "" ||
        r.parametricDomain.max !== "") &&
      (t = {
        ...t,
        domain: {
          min: r.parametricDomain.min === "" ? "0" : r.parametricDomain.min,
          max: r.parametricDomain.max === "" ? "1" : r.parametricDomain.max,
        },
      }), e.stripDefaults
    ) {
      return __dcg_shared_module_exports__["Ed"](t, {
        is3d: r.controller.is3dProduct(),
      });
    }
    if (t.points === void 0 || t.lines === void 0 || t.fill === void 0) {
      let o = __dcg_shared_module_exports__["Jc"](t);
      return o.points === void 0 && delete o.points,
        o.lines === void 0 && delete o.lines,
        o.fill === void 0 && delete o.fill,
        o;
    }
    return t;
  }
  function qee(r) {
    let e = r.cachedViewState;
    e && __dcg_shared_module_exports__["Gd"](e, r) &&
        e.folderId === r.folderId && e.color === r.color &&
        e.latex === r.latex && e.showLabel === r.showLabel &&
        e.showAngleLabel === r.showAngleLabel && e.label === r.label &&
        e.hidden === r.hidden && e.secret === r.secret &&
        e.readonly === r.readonly &&
        e.disableGraphInteractions === r.disableGraphInteractions &&
        e.fill === r.fill && e.points === r.points &&
        e.lines === r.lines && e.extendTo3D === r.extendTo3D &&
        e.lineStyle === r.lineStyle && e.arrowMode === r.arrowMode &&
        e.pointStyle === r.pointStyle && e.dragMode === r.dragMode &&
        e.labelSize === r.labelSize &&
        e.labelOrientation === r.labelOrientation &&
        e.suppressTextOutline === r.suppressTextOutline &&
        e.interactiveLabel === r.interactiveLabel &&
        e.editableLabelMode === r.editableLabelMode &&
        e.residualVariable === r.residualVariable &&
        e.regressionParameters === r.regressionParameters &&
        e.isLogModeRegression === r.isLogModeRegression &&
        e.displayEvaluationAsFraction === r.displayEvaluationAsFraction &&
        e.slider === r.slider &&
        e.strictIntersection === r.strictIntersection ||
      (r.cachedViewState = {
        type: r.type,
        id: r.id,
        folderId: r.folderId,
        color: r.color,
        latex: r.latex,
        showLabel: r.showLabel,
        showAngleLabel: r.showAngleLabel,
        label: r.label,
        hidden: r.hidden,
        secret: r.secret,
        readonly: r.readonly,
        disableGraphInteractions: r.disableGraphInteractions,
        points: r.points,
        lines: r.lines,
        extendTo3D: r.extendTo3D,
        lineStyle: r.lineStyle,
        arrowMode: r.arrowMode,
        pointStyle: r.pointStyle,
        fill: r.fill,
        dragMode: r.dragMode,
        labelSize: r.labelSize,
        labelOrientation: r.labelOrientation,
        suppressTextOutline: r.suppressTextOutline,
        interactiveLabel: r.interactiveLabel,
        editableLabelMode: r.editableLabelMode,
        residualVariable: r.residualVariable,
        regressionParameters: r.regressionParameters,
        isLogModeRegression: r.isLogModeRegression,
        displayEvaluationAsFraction: r.displayEvaluationAsFraction,
        slider: r.slider,
        strictIntersection: r.strictIntersection,
        ...__dcg_shared_module_exports__["Fd"](r),
      });
  }
  function gL(r, e) {
    e && yb(r), r.draggingOnGraphpaper = e;
  }
  function Hee(r) {
    let e = r.memoizedUndoRedoStateParams,
      t = r.cachedViewState,
      o = r.preTransientState;
    if (
      r.cachedUndoRedoFullState = t,
        e && e.viewState === t && e.preTransientState === o
    ) return;
    r.memoizedUndoRedoStateParams = {
      viewState: t,
      preTransientState: o,
    };
    let i;
    o
      ? i = { ...t, latex: o.latex, slider: { ...t.slider, ...o.slider } }
      : i = { ...t },
      delete i.regressionParameters,
      delete i.residualVariable,
      r.cachedUndoRedoDiffState = i;
  }
  function zE(r, e) {
    let t = __dcg_shared_module_exports__["Jc"](
        __dcg_shared_module_exports__["Dd"](r, {
          is3d: e.is3dProduct(),
          defaultLogModeRegressions: e.areLogModeRegressionsDefault(),
        }),
      ),
      { color: o } = t;
    return (!o || !Ff(o)) && (o = e.getNextColor()), {
      ...t,
      ...ud(e),
      labelDropdownOpen: false,
      formula: { error: void 0, operator: "=", variables: [] },
      error: void 0,
      unresolved: false,
      expressionTooComplex: false,
      color: o,
      pointStyle: t.pointStyle,
      lineStyle: t.lineStyle,
      arrowMode: t.arrowMode,
      displayEvaluationAsFraction: t.displayEvaluationAsFraction,
      shouldGraph: void 0,
      sliderDragging: void 0,
      sliderAnimationTargetValue: void 0,
      resetSliderAnimationTargetValue: false,
      sliderLastTickTime: void 0,
      draggingOnGraphpaper: false,
      cachedUndoRedoDiffState: void 0,
      cachedUndoRedoFullState: void 0,
      cachedParsableState: void 0,
      cachedViewState: void 0,
      cachedDisplayLatex: { storedLatex: "", valueLatex: "" },
    };
  }
  function Kee(r) {
    let e = Ca(r),
      t = !!(e && e.hidden),
      o = r.cachedViewState,
      i = r.index,
      n = r.showLabel && !t,
      a = r.showAngleLabel,
      s = r.shouldGraph,
      l = r.memoizedParsableStateParams;
    if (
      l && l.viewState === o && l.index === i && l.showLabel === n &&
      l.showAngleLabel === a && l.shouldGraph === s
    ) return;
    r.memoizedParsableStateParams = {
      viewState: o,
      index: i,
      showLabel: n,
      showAngleLabel: a,
      shouldGraph: s,
    };
    let c = __dcg_shared_module_exports__["Hd"](o);
    c.index = i,
      c.showLabel = n,
      c.showAngleLabel = a,
      c.shouldGraph = s,
      c.isInConstructionsFolder =
        r.folderId === __dcg_shared_module_exports__["xd"],
      r.cachedParsableState = c;
  }
  function qE(r, e) {
    e(r.latex, "latex"),
      e(r.clickableInfo.latex, "clickableInfoLatex"),
      e(r.lineWidth, "lineWidth"),
      e(r.fillOpacity, "fillOpacity"),
      e(r.surfaceOpacity, "surfaceOpacity"),
      e(r.lineOpacity, "lineOpacity"),
      e(r.pointOpacity, "pointOpacity"),
      e(r.pointSize, "pointSize"),
      e(r.movablePointSize, "movablePointSize"),
      e(r.labelSize, "labelSize"),
      e(r.labelAngle, "labelAngle"),
      e(r.colorLatex, "colorLatex"),
      Gg(r) &&
      (e(r.parametricDomain.min, "parametricDomainMin"),
        e(r.parametricDomain.max, "parametricDomainMax")),
      (pH(r) || dH(r)) &&
      (e(r.parametricDomain3Du.min, "parametricDomain3DuMin"),
        e(r.parametricDomain3Du.max, "parametricDomain3DuMax"),
        e(r.parametricDomain3Dv.min, "parametricDomain3DvMin"),
        e(r.parametricDomain3Dv.max, "parametricDomain3DvMax")),
      (Sb(r) || dT(r)) &&
      (e(r.polarDomain.min, "polarDomainMin"),
        e(r.polarDomain.max, "polarDomainMax")),
      (TL(r) || EL(r)) && e(r.resolution, "resolution"),
      vd(r) && (e(r.cdf.min, "cdfMin"), e(r.cdf.max, "cdfMax")),
      r.sliderExists &&
      (e(r.slider.min, "sliderMin"),
        e(r.slider.max, "sliderMax"),
        e(r.slider.step, "sliderStep")),
      r.residualVariable && e(r.residualVariable, "residualVariable");
  }
  function Ya(r) {
    return r.formula && r.formula.assignment;
  }
  function mL(r) {
    return r.formula && r.formula.shader;
  }
  function pi(r) {
    let e = r.cachedAssignmentOrFunctionName;
    if (e && e.latex === r.latex) return e.result;
    let t = Nx(r.latex),
      o = t
        ? {
          latex: t,
          identifier: __dcg_shared_module_exports__["latexToIdentifier"](t),
        }
        : void 0;
    return r.cachedAssignmentOrFunctionName = {
      latex: r.latex,
      result: o,
    },
      o;
  }
  function Bq(r) {
    var t, o;
    let e = (o = (t = r.formula) == null ? void 0 : t.typed_constant_value) ==
        null
      ? void 0
      : o.valueType;
    return e == null ? false : __dcg_shared_module_exports__["isList"](e);
  }
  function oT(r) {
    var o;
    let e = (o = pi(r)) == null ? void 0 : o.latex,
      t = e == null ? void 0 : e.match(/^(\\token\{\d+\})$/);
    if (t) return t[1];
  }
  function Uq(r) {
    var o, i;
    let e = (i = (o = r.formula) == null ? void 0 : o.typed_constant_value) ==
          null
        ? void 0
        : i.valueType,
      t = false;
    if (
      e && __dcg_shared_module_exports__["isList"](e) &&
      (t = true, e = __dcg_shared_module_exports__["elementType"](e)),
        e == null || !__dcg_shared_module_exports__["isGeometryType"](e)
    ) return "U";
    switch (e) {
      case __dcg_shared_module_exports__["Point"]:
        return t ? "P" : "p";
      case __dcg_shared_module_exports__["Segment"]:
      case __dcg_shared_module_exports__["Ray"]:
      case __dcg_shared_module_exports__["Line"]:
        return t ? "L" : "l";
      case __dcg_shared_module_exports__["Vector"]:
        return t ? "V" : "v";
      case __dcg_shared_module_exports__["Arc"]:
      case __dcg_shared_module_exports__["Circle"]:
        return t ? "C" : "c";
      case __dcg_shared_module_exports__["AngleMarker"]:
      case __dcg_shared_module_exports__["DirectedAngleMarker"]:
        return t ? "A" : "a";
      case __dcg_shared_module_exports__["Polygon"]:
        return "P";
      case __dcg_shared_module_exports__["Transformation"]:
        return "T";
      default:
        return e;
    }
  }
  function Wee(r) {
    var t, o;
    let e = (o = (t = r.formula) == null ? void 0 : t.typed_constant_value) ==
        null
      ? void 0
      : o.valueType;
    if (
      e == null ||
      (__dcg_shared_module_exports__["isList"](e) &&
        (e = __dcg_shared_module_exports__["elementType"](e)),
        !__dcg_shared_module_exports__["isGeometryType"](e))
    ) return "unknown";
    switch (e) {
      case __dcg_shared_module_exports__["Point"]:
        return "point";
      case __dcg_shared_module_exports__["Segment"]:
        return "segment";
      case __dcg_shared_module_exports__["Ray"]:
        return "ray";
      case __dcg_shared_module_exports__["Line"]:
        return "line";
      case __dcg_shared_module_exports__["Vector"]:
        return "vector";
      case __dcg_shared_module_exports__["Arc"]:
        return "arc";
      case __dcg_shared_module_exports__["Circle"]:
        return "circle";
      case __dcg_shared_module_exports__["AngleMarker"]:
        return "angle";
      case __dcg_shared_module_exports__["DirectedAngleMarker"]:
        return "directedangle";
      case __dcg_shared_module_exports__["Polygon"]:
        return "polygon";
      case __dcg_shared_module_exports__["Transformation"]:
        return "transformation";
      default:
        return e;
    }
  }
  function fL(r) {
    var t, o;
    let e = (o = (t = r.formula) == null ? void 0 : t.typed_constant_value) ==
        null
      ? void 0
      : o.valueType;
    if (
      e == null ||
      (__dcg_shared_module_exports__["isList"](e) &&
        (e = __dcg_shared_module_exports__["elementType"](e)),
        !__dcg_shared_module_exports__["isGeometryType"](e))
    ) return "unknown";
    switch (e) {
      case __dcg_shared_module_exports__["Point"]:
        return "point";
      case __dcg_shared_module_exports__["Segment"]:
      case __dcg_shared_module_exports__["Ray"]:
      case __dcg_shared_module_exports__["Line"]:
      case __dcg_shared_module_exports__["Vector"]:
        return "line";
      case __dcg_shared_module_exports__["Arc"]:
        return "arc";
      case __dcg_shared_module_exports__["Circle"]:
        return "circle";
      case __dcg_shared_module_exports__["AngleMarker"]:
        return "angle";
      case __dcg_shared_module_exports__["DirectedAngleMarker"]:
        return "directedangle";
      case __dcg_shared_module_exports__["Polygon"]:
        return "polygon";
      case __dcg_shared_module_exports__["Transformation"]:
        return "transformation";
      default:
        return e;
    }
  }
  function zq(r) {
    return r.indexOf("\\token{") !== -1;
  }
  function qq(r) {
    var o, i, n, a;
    let e = (i = (o = r.formula.geometry) == null ? void 0 : o.call) == null
        ? void 0
        : i.symbol,
      t = (a = (n = r.formula) == null ? void 0 : n.typed_constant_value) ==
          null
        ? void 0
        : a.valueType;
    return !e || e === "apply" ||
        __dcg_shared_module_exports__["Dc"](e) && t !== void 0 &&
          !__dcg_shared_module_exports__["isTypeOrListOfType"](
            t,
            __dcg_shared_module_exports__["Transformation"],
          )
      ? Wee(r)
      : e === "segments"
      ? "segment"
      : e;
  }
  function $ee(r) {
    return !!(r.sliderExists &&
        (r.slider.isPlaying || r.sliderDragging) ||
      r.draggingOnGraphpaper);
  }
  function Hq(r) {
    return !!(r.sliderExists && r.sliderDragging ||
      r.draggingOnGraphpaper);
  }
  function bL(r) {
    $ee(r)
      ? r.preTransientState ||
        (r.preTransientState = {
          latex: r.latex,
          slider: {
            min: r.slider.min,
            max: r.slider.max,
            playDirection: r.slider.playDirection,
          },
        })
      : delete r.preTransientState,
      (!r.sliderExists || !r.slider.isPlaying) &&
      (r.sliderLastTickTime = void 0),
      hd(r),
      Uee(r),
      Bee(r),
      qee(r),
      Hee(r),
      Kee(r),
      zee(r);
  }
  var jee = {
    id: false,
    type: false,
    color: true,
    folderId: true,
    latex: true,
    showLabel: true,
    showAngleLabel: true,
    label: true,
    hidden: true,
    secret: true,
    readonly: true,
    disableGraphInteractions: true,
    points: true,
    lines: true,
    lineStyle: true,
    arrowMode: true,
    pointStyle: true,
    fill: true,
    dragMode: true,
    labelSize: true,
    labelOrientation: true,
    suppressTextOutline: true,
    interactiveLabel: true,
    editableLabelMode: true,
    residualVariable: true,
    regressionParameters: true,
    isLogModeRegression: true,
    displayEvaluationAsFraction: true,
    slider: true,
    strictIntersection: true,
    angleType: true,
    showAngleDirection: true,
    extendTo3D: false,
    ...__dcg_shared_module_exports__["ud"](
      __dcg_shared_module_exports__["zd"],
    ),
  };
  function wq(r, e) {
    __dcg_shared_module_exports__["rd"]({ from: e, to: r, props: jee }),
      r.resetSliderAnimationTargetValue = true,
      r.sliderAnimationTargetValue = void 0;
  }
  function sb(r, e) {
    e ? In(r, { hardMin: true, min: e }) : In(r, {
      hardMin: false,
      min: r.controller.is3dProduct()
        ? `${__dcg_shared_module_exports__["xc"].xmin}`
        : "-10",
    });
  }
  function lb(r, e) {
    e ? In(r, { hardMax: true, max: e }) : In(r, {
      hardMax: false,
      max: r.controller.is3dProduct()
        ? `${__dcg_shared_module_exports__["xc"].xmax}`
        : "10",
    });
  }
  function In(r, e) {
    r.slider = { ...r.slider, ...e };
  }
  function As(r, e) {
    !r || r.slider.isPlaying === e ||
      (In(r, { isPlaying: e }),
        e && (yb(r), r.sliderAnimationTargetValue = al(r)));
  }
  function yb(r) {
    if (!r.slider.hardMin) {
      let e = __dcg_shared_module_exports__["be"](nl(r));
      e !== r.slider.min && In(r, { min: e });
    }
    if (!r.slider.hardMax) {
      let e = __dcg_shared_module_exports__["be"](bc(r));
      e !== r.slider.max && In(r, { max: e });
    }
  }
  function $a(r, e) {
    let t = dw(e);
    if (isFinite(t)) {
      let o = __dcg_shared_module_exports__["yc"]({
        target: t,
        step: Rl(r),
        hardMin: r.slider.hardMin ? nl(r) : void 0,
        hardMax: r.slider.hardMax ? bc(r) : void 0,
      });
      o.min || In(r, { hardMin: false, min: "-10" }),
        o.max || In(r, { hardMax: false, max: "10" }),
        o.step || In(r, { step: "" });
    }
    r.latex = e;
  }
  function Kq(r, e) {
    In(r, { loopMode: e, playDirection: 1 }),
      e === "PLAY_INDEFINITELY" &&
      In(r, { hardMin: false, hardMax: false, min: "", max: "" }),
      r.sliderAnimationTargetValue = nl(r);
  }
  function Ww(r, e) {
    e && yb(r), r.sliderDragging = e;
  }
  function Gw(r, e) {
    In(r, { step: e });
  }
  function Wq(r, e) {
    In(r, { animationPeriod: e });
  }
  function Hu(r) {
    var e;
    return ((e = r.formula.typed_constant_value) == null
        ? void 0
        : e.valueType) === __dcg_shared_module_exports__["Complex"]
      ? false
      : r.displayEvaluationAsFraction;
  }
  function $q(r, e) {
    r.displayEvaluationAsFraction = e;
  }
  function yd(r, e) {
    r.label = e;
  }
  function Ku(r, e) {
    zu(r) ? r.showAngleLabel = e : r.showLabel = e;
  }
  function jq(r, e) {
    r.description = e;
  }
  function Ka(r, e, t) {
    switch (t) {
      case "theta":
        r.polarDomain = { ...r.polarDomain, min: e };
        break;
      case "t":
        r.parametricDomain = { ...r.parametricDomain, min: e };
        break;
      case "u":
        r.parametricDomain3Du = { ...r.parametricDomain3Du, min: e };
        break;
      case "v":
        r.parametricDomain3Dv = { ...r.parametricDomain3Dv, min: e };
        break;
      case "r":
        r.parametricDomain3Dr = { ...r.parametricDomain3Dr, min: e };
        break;
      case "phi":
        r.parametricDomain3Dphi = { ...r.parametricDomain3Dphi, min: e };
        break;
      default:
        return t;
    }
  }
  function Wa(r, e, t) {
    switch (t) {
      case "theta":
        r.polarDomain = { ...r.polarDomain, max: e };
        break;
      case "t":
        r.parametricDomain = { ...r.parametricDomain, max: e };
        break;
      case "u":
        r.parametricDomain3Du = { ...r.parametricDomain3Du, max: e };
        break;
      case "v":
        r.parametricDomain3Dv = { ...r.parametricDomain3Dv, max: e };
        break;
      case "r":
        r.parametricDomain3Dr = { ...r.parametricDomain3Dr, max: e };
        break;
      case "phi":
        r.parametricDomain3Dphi = { ...r.parametricDomain3Dphi, max: e };
        break;
      default:
        return t;
    }
  }
  function yL(r, e) {
    r.isLogModeRegression = e;
  }
  function iT(r, e) {
    Ff(e) && (r.color = e, r.colorLatex = "");
  }
  function xL(r, e) {
    r.fill = e;
  }
  function Lw(r, e) {
    r.fillOpacity !== e && (r.fillOpacity = e);
  }
  function Pw(r, e) {
    r.surfaceOpacity !== e && (r.surfaceOpacity = e);
  }
  function cb(r, e) {
    r.lineOpacity !== e && (r.lineOpacity = e);
  }
  function Vw(r, e) {
    r.pointOpacity !== e && (r.pointOpacity = e);
  }
  function Ow(r, e) {
    r.pointSize === e && r.movablePointSize === e ||
      (r.pointSize = e, r.movablePointSize = e);
  }
  function db(r, e) {
    r.lineWidth !== e && (r.lineWidth = e);
  }
  function HE(r, e) {
    r.resolution !== e && (r.resolution = e);
  }
  function Rw(r, e) {
    r.colorLatex !== e && (r.colorLatex = e);
  }
  function Yq(r, e) {
    r.labelDropdownOpen = e;
  }
  function Mg(r, e) {
    fb(r, { type: "drag-mode", dragMode: e });
  }
  function wL(r, e) {
    r.points = e;
  }
  function vL(r, e) {
    r.pointStyle !== e &&
      (r.pointStyle = e, e !== "POINT" && (r.dragMode = "NONE"));
  }
  function CL(r, e) {
    r.lines = e;
  }
  function Xq(r, e) {
    r.extendTo3D = e;
  }
  function nT(r, e) {
    r.lineStyle !== e && (r.lineStyle = e);
  }
  function Jq(r, e) {
    r.arrowMode = e === Yee(r) ? "DEFAULT" : e;
  }
  function Yee(r) {
    return "NONE";
  }
  function Fw(r, e) {
    r.labelSize = e;
  }
  function KE(r, e) {
    r.labelAngle = e;
  }
  function SL(r, e) {
    r.labelOrientation = e;
  }
  function Qq(r, e) {
    r.suppressTextOutline = e;
  }
  function $w(r, e) {
    fb(r, { type: "interactive-label", interactive: e });
  }
  function aT(r, e) {
    fb(r, { type: "editable-label", editable: e });
  }
  function Zq(r) {
    return r.editableLabelMode;
  }
  function xb(r) {
    let { editableLabelMode: e } = r;
    return e === "MATH" || e === "TEXT";
  }
  function eH(r, e) {
    r.strictIntersection = e;
  }
  function tH(r) {
    return !!(Ro(r) !== "NONE" && Hi(r));
  }
  function rH(r, e) {
    r.hidden = e, !e && wb(r) && (r.lines = r.points = r.fill = void 0);
  }
  function wb(r) {
    if (wd(r) && !r.controller.isThreeDMode()) return false;
    let { points: e, lines: t, fill: o } = r,
      i = __dcg_shared_module_exports__["Zc"](r.formula.expression_type, {
        points: e,
        lines: t,
        fill: o,
      }, (n) => {
        So("getReconciledExpressionProps [Chrome Switch Bug]", {
          metaData: { method: "areAllVisibilityPropsOff", type: n },
        });
      });
    return !i.points && !i.lines && !i.fill;
  }
  function Wu(r) {
    return r.formula.map_type !== void 0 ? false : Gg(r) || Sb(r) || dT(r);
  }
  function Dp(r) {
    return r.formula.map_type !== void 0 ? false : pH(r) || dH(r) || DL(r);
  }
  function oH(r, e) {
    switch (e) {
      case "theta":
        return r.polarDomain.min;
      case "t":
        return r.parametricDomain.min;
      case "u":
        return r.parametricDomain3Du.min;
      case "v":
        return r.parametricDomain3Dv.min;
      case "r":
        return r.parametricDomain3Dr.min;
      case "phi":
        return r.parametricDomain3Dphi.min;
      default:
        return e;
    }
  }
  function iH(r, e) {
    switch (e) {
      case "theta":
        return r.polarDomain.max;
      case "t":
        return r.parametricDomain.max;
      case "u":
        return r.parametricDomain3Du.max;
      case "v":
        return r.parametricDomain3Dv.max;
      case "r":
        return r.parametricDomain3Dr.max;
      case "phi":
        return r.parametricDomain3Dphi.max;
      default:
        return e;
    }
  }
  function vb(r) {
    return !!r.formula.action_value &&
      Object.keys(r.formula.action_value).length > 0;
  }
  function nH(r) {
    return !!r.sliderExists;
  }
  function pb(r) {
    return r.formula.expression_type === "POLYGON";
  }
  function wd(r) {
    return !!r.formula.is_inequality;
  }
  function sT(r) {
    return !!r.formula.is_regression;
  }
  function Gg(r) {
    return r.formula.expression_type === "PARAMETRIC" ||
      r.formula.expression_type === "CURVE3D_xyz_t" && !kL(r) && !_L(r);
  }
  function Cb(r) {
    return r.formula.expression_type === "POINT3D";
  }
  function EL(r) {
    return r.formula.expression_type === "CURVE3D_xyz_t" ||
      r.formula.expression_type === "SLICE" ||
      r.formula.expression_type === "SLICE_r\u03B8z_at_z" ||
      r.formula.expression_type === "SLICE_zr\u03B8_at_r" ||
      r.formula.expression_type === "SLICE_zr\u03B8_at_\u03B8" ||
      r.formula.expression_type === "SLICE_zr\u03B8_at_xyz" ||
      r.formula.expression_type === "SLICE_r\u03B8\u03C6_at_\u03B8" ||
      r.formula.expression_type === "SLICE_r\u03B8\u03C6_at_\u03C6" ||
      r.formula.expression_type === "SLICE_r\u03B8\u03C6_at_xyz" ||
      r.formula.expression_type === "SLICE_xyz_uv";
  }
  function aH(r) {
    return r.formula.expression_type === "SLICE_zr\u03B8_at_r" ||
      r.formula.expression_type === "SLICE_r\u03B8\u03C6_at_\u03B8";
  }
  function sH(r) {
    return r.formula.expression_type === "SLICE_zr\u03B8_at_\u03B8" ||
      r.formula.expression_type === "SLICE_r\u03B8\u03C6_at_\u03C6";
  }
  function TL(r) {
    switch (r.formula.expression_type) {
      case "SURFACE_xyz_uv":
      case "SURFACE_z_r\u03B8":
      case "SURFACE_r_\u03B8z":
      case "SURFACE_r_\u03B8z_AMBIGUOUS":
      case "SURFACE_r_\u03B8\u03C6":
      case "SURFACE":
      case "SURFACE_AMBIGUOUS":
      case "SURFACE_CONSTANT_AMBIGUOUS":
      case "IMPLICIT_SURFACE":
      case "IMPLICIT_SURFACE_AMBIGUOUS":
      case "TRIANGLE3D":
      case "SPHERE3D":
        return true;
      default:
        return false;
    }
  }
  function lT(r) {
    return r.formula.expression_type === "TRIANGLE3D";
  }
  function lH(r) {
    return r.formula.expression_type === "SPHERE3D";
  }
  function cH(r) {
    return r.formula.expression_type === "IMPLICIT_SURFACE" ||
      r.formula.expression_type === "IMPLICIT_SURFACE_AMBIGUOUS";
  }
  function cT(r) {
    return Xee(r) || Jee(r);
  }
  function Xee(r) {
    return r.formula.expression_type === "X_OR_Y" ||
      r.formula.expression_type === "IMPLICIT" ||
      r.formula.expression_type === "SURFACE_AMBIGUOUS" ||
      r.formula.expression_type === "SURFACE_CONSTANT_AMBIGUOUS" ||
      r.formula.expression_type === "IMPLICIT_SURFACE_AMBIGUOUS";
  }
  function Jee(r) {
    return !r.formula.is_inequality &&
      (r.formula.expression_type === "POLAR" ||
        r.formula.expression_type === "SURFACE_r_\u03B8z_AMBIGUOUS");
  }
  function Sb(r) {
    return r.formula.expression_type === "POLAR";
  }
  function dT(r) {
    return __dcg_shared_module_exports__["bd"](r.formula.expression_type);
  }
  function DL(r) {
    return __dcg_shared_module_exports__["ad"](r.formula.expression_type);
  }
  function dH(r) {
    return __dcg_shared_module_exports__["$c"](r.formula.expression_type);
  }
  function pH(r) {
    return r.formula.expression_type === "SURFACE_xyz_uv" ||
      r.formula.expression_type === "SLICE_xyz_uv";
  }
  function zu(r) {
    let e = r.formula.typed_constant_value;
    if (!e) return false;
    let t = e.valueType;
    return t === __dcg_shared_module_exports__["AngleMarker"] ||
      t === __dcg_shared_module_exports__["ListOfAngleMarker"] ||
      t === __dcg_shared_module_exports__["DirectedAngleMarker"] ||
      t === __dcg_shared_module_exports__["ListOfDirectedAngleMarker"];
  }
  function ja(r) {
    let e = zu(r);
    return e && r.showAngleLabel || !e && r.showLabel;
  }
  function ub(r) {
    if (mc(r)) return true;
    let e = r.formula.typed_constant_value;
    if (!e) return false;
    let t = e.valueType;
    return t === __dcg_shared_module_exports__["Segment"] ||
      t === __dcg_shared_module_exports__["ListOfSegment"] ||
      t === __dcg_shared_module_exports__["AngleMarker"] ||
      t === __dcg_shared_module_exports__["ListOfAngleMarker"] ||
      t === __dcg_shared_module_exports__["DirectedAngleMarker"] ||
      t === __dcg_shared_module_exports__["ListOfDirectedAngleMarker"];
  }
  function kL(r) {
    return r.formula.expression_type === "SEGMENT3D";
  }
  function _L(r) {
    return r.formula.expression_type === "VECTOR3D";
  }
  function Ea(r) {
    return r.formula.expression_type === "SINGLE_POINT";
  }
  function Lg(r) {
    return r.formula.expression_type === "POINT_LIST";
  }
  function mc(r) {
    return r.formula.expression_type === "POINT_LIST" ||
      r.formula.expression_type === "SINGLE_POINT";
  }
  function $u(r) {
    return r.formula.expression_type === "POINT3D_LIST";
  }
  function ju(r) {
    let e = sl(r);
    return !!(e && e.type === "visualization" && e.symbol === "boxplot");
  }
  function kp(r) {
    let e = sl(r);
    return !!(e && e.type === "visualization" && e.symbol === "dotplot");
  }
  function Pg(r) {
    let e = sl(r);
    return !!(e && e.type === "visualization" &&
      e.symbol === "histogram");
  }
  function pT(r) {
    return ju(r) || kp(r) || Pg(r);
  }
  function jw(r) {
    return r.formula.expression_type === "TTEST";
  }
  function uT(r) {
    return r.formula.expression_type === "STATS";
  }
  function _p(r) {
    let e = sl(r);
    return !!(e && e.type === "distribution");
  }
  function uH(r) {
    let { formula: e } = r;
    return e ? !!e.is_discrete_distribution : false;
  }
  function hH(r) {
    var t, o;
    let e = (o = (t = r.formula) == null ? void 0 : t.geometry) == null
      ? void 0
      : o.valueType;
    if (e !== void 0) {
      return __dcg_shared_module_exports__["isTypeOrListOfType"](
        e,
        __dcg_shared_module_exports__["Segment"],
      );
    }
  }
  function sl(r) {
    if (r.controller.areDistributionsEnabled() && r.latex) {
      return (!r.cachedParseToplevelFunction ||
        r.cachedParseToplevelFunction.latex !== r.latex) &&
        (r.cachedParseToplevelFunction = {
          latex: r.latex,
          spec: __dcg_shared_module_exports__["Yc"](r.latex),
        }),
        r.cachedParseToplevelFunction.spec;
    }
  }
  function IL(r) {
    return Yw(r) && _p(r);
  }
  function Yw(r) {
    return !!r.formula.expression_type;
  }
  function AL(r) {
    return !!r.formula.is_concrete_list;
  }
  function vd(r) {
    return !IL(r) || AL(r) ? false : r.cdf.show;
  }
  function hT(r) {
    return r.cdf.min;
  }
  function gT(r) {
    return r.cdf.max;
  }
  function gH(r) {
    let e = sL(r.formula.cdf_min_default);
    return e === -1 / 0 ? "-\\infty" : isFinite(e) ? e + "" : "-\\infty";
  }
  function mH(r) {
    let e = sL(r.formula.cdf_max_default);
    return e === 1 / 0 ? "\\infty" : isFinite(e) ? e + "" : "\\infty";
  }
  function fH(r, e) {
    r.cdf = { ...r.cdf, show: e };
  }
  function WE(r, e) {
    r.cdf = { ...r.cdf, min: e };
  }
  function $E(r, e) {
    r.cdf = { ...r.cdf, max: e };
  }
  function mT(r) {
    return !!r.formula && r.formula.cdf_min_valid !== false;
  }
  function fT(r) {
    return !!r.formula && r.formula.cdf_max_valid !== false;
  }
  function ML(r) {
    return !!r.formula && r.formula.fill_opacity_valid !== false;
  }
  function GL(r) {
    return !!r.formula && r.formula.surface_opacity_valid !== false;
  }
  function bH(r) {
    return !!r.formula && r.formula.line_opacity_valid !== false;
  }
  function yH(r) {
    return !!r.formula && r.formula.point_opacity_valid !== false;
  }
  function LL(r) {
    return !!r.formula && r.formula.label_size_valid !== false;
  }
  function PL(r) {
    return !!r.formula && r.formula.label_angle_valid !== false;
  }
  function xH(r) {
    return !!r.formula && r.formula.movable_point_size_valid !== false;
  }
  function bT(r) {
    return !!r.formula && r.formula.point_size_valid !== false;
  }
  function yT(r) {
    return !!r.formula && r.formula.line_width_valid !== false;
  }
  function wH(r) {
    return !!r.formula && r.formula.resolution_valid !== false;
  }
  function bE(r) {
    return !!r.formula && r.formula.color_latex_valid !== false;
  }
  function yE(r) {
    return r.formula && r.formula.color_latex_value;
  }
  function vH(r) {
    return r.formula && r.formula.label_angle_value;
  }
  function VL(r) {
    let e = r.formula && r.formula.cdf_evaluation;
    return isFinite(e) ? e : 0;
  }
  function OL(r) {
    if (
      !r ||
      !__dcg_shared_module_exports__["_c"](r.formula.expression_type)
    ) return false;
    let e = Ro(r);
    return !(e && e !== "NONE");
  }
  function CH(r) {
    r.showLabel = __dcg_shared_module_exports__["Ad"].showLabel,
      r.showAngleLabel = __dcg_shared_module_exports__["Ad"].showAngleLabel,
      r.label = __dcg_shared_module_exports__["Ad"].label,
      r.hidden = __dcg_shared_module_exports__["Ad"].hidden,
      r.dragMode = __dcg_shared_module_exports__["Ad"].dragMode,
      r.fill = __dcg_shared_module_exports__["Ad"].fill,
      r.points = __dcg_shared_module_exports__["Ad"].points,
      r.pointStyle = __dcg_shared_module_exports__["Ad"].pointStyle,
      r.lines = __dcg_shared_module_exports__["Ad"].lines,
      r.lineStyle = __dcg_shared_module_exports__["Ad"].lineStyle,
      r.slider = r.controller.is3dProduct()
        ? __dcg_shared_module_exports__["Cd"]
        : __dcg_shared_module_exports__["Bd"],
      r.latex = "",
      r.labelSize = "",
      r.labelOrientation = "default",
      r.displayEvaluationAsFraction =
        __dcg_shared_module_exports__["Ad"].displayEvaluationAsFraction,
      r.strictIntersection =
        __dcg_shared_module_exports__["Ad"].strictIntersection,
      r.suppressTextOutline = false,
      r.interactiveLabel = false,
      r.editableLabelMode =
        __dcg_shared_module_exports__["Ad"].editableLabelMode,
      __dcg_shared_module_exports__["sd"](
        __dcg_shared_module_exports__["zd"],
        r,
      );
  }
  function xT(r) {
    return !!r.formula.move_strategy;
  }
  function RL(r, e) {
    fb(r, { type: "inert", disableGraphInteractions: e });
  }
  function SH(r) {
    if (
      (r == null ? void 0 : r.type) !== "expression" ||
      !r.formula.typed_constant_value
    ) return;
    let { value: e, valueType: t } = r.formula.typed_constant_value;
    switch (t) {
      case __dcg_shared_module_exports__["Point"]:
      case __dcg_shared_module_exports__["Complex"]:
        return { x: e[0], y: e[1] };
    }
  }
  function FL(r, e) {
    var t;
    if (!(r.type !== "expression" && r.type !== "image")) {
      return (t = r.formula.computed_description) == null ? void 0 : t[e || 0];
    }
  }
  function Cd(r, e, t) {
    let o = Intl.ListFormat;
    if (typeof o == "function") {
      try {
        return new o(r, t).format(e);
      } catch (i) {}
    }
    return e.join(", ");
  }
  var wT = { cb20221031: "1" };
  qt();
  var Qee = "";
  var Zee = [];
  function ete(r) {
    if (r.status === 401) { for (let e of Zee) e(); }
  }
  async function tte(r) {
    if (r && r.routeDeprecated) throw r.js && new Function(r.js)(), r;
  }
  function rte(r) {
    let e = new URLSearchParams();
    return Object.entries(r).forEach(([t, o]) => {
      Array.isArray(o)
        ? o.forEach((i) => e.append(t, String(i)))
        : e.set(t, String(o));
    }),
      e;
  }
  function ote() {
    throw {
      status: 0,
      responseJSON: {
        errors: [{
          key: "connection_failed",
          message: "Connection failed. Check your internet connection?",
        }],
      },
    };
  }
  async function ite(r) {
    let e = await r.catch(ote);
    if (ete(e), !e.ok) {
      let o;
      try {
        o = await e.json();
      } catch (i) {}
      throw {
        status: e.status,
        statusText: e.statusText,
        responseJSON: o,
      };
    }
    let t = await e.json();
    return await tte(t), t;
  }
  async function EH(r, e) {
    let t = {
        method: "GET",
        credentials: "include",
        headers: {
          Accept: "application/json, text/javascript, */*; q=0.01",
        },
      },
      o = /\?/.test(String(r)) ? "&" : "?";
    return await ite(fetch(`${Qee}${r}${o}${rte({ ...e, ...wT })}`, t));
  }
  function Xw(r) {
    let e = [];
    for (let t of r) {
      if (!t || typeof t != "string") continue;
      let o = t.split("-")[0];
      e.push(t), e.push(o);
      for (let i in Vg) {
        let n = Vg[i];
        i.split("-")[0] === o && n.useAsRoot && e.push(i);
      }
    }
    return e;
  }
  var Vg = {
    en: {
      displayName: "English (US)",
      userGuideURL:
        "https://docs.google.com/document/d/1gV-WgDjgR9hKKb32ffeUpjwggNAgfqxl0Gsg6xocbok/preview",
      useAsRoot: false,
    },
    es: {
      displayName: "Espa\xF1ol (LATAM)",
      userGuideURL:
        "https://desmos.s3.amazonaws.com/Desmos_User_Guide_ES-ES.pdf",
      useAsRoot: true,
    },
    et: {
      displayName: "Eesti",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    ru: {
      displayName: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide_RU.pdf",
      useAsRoot: false,
    },
    da: {
      displayName: "Dansk",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    de: {
      displayName: "Deutsch",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide_DE.pdf",
      useAsRoot: false,
    },
    "pt-BR": {
      displayName: "Portugu\xEAs (Brasil)",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: true,
    },
    "pt-PT": {
      displayName: "Portugu\xEAs (Portugal)",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    ca: {
      displayName: "Catal\xE0",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    fr: {
      displayName: "Fran\xE7ais",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide_FR.pdf",
      useAsRoot: true,
    },
    "fr-CA": {
      displayName: "Fran\xE7ais (Canada)",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide_FR.pdf",
      useAsRoot: true,
    },
    it: {
      displayName: "Italiano",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide_IT.pdf",
      useAsRoot: false,
    },
    is: {
      displayName: "\xCDslenska",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    nl: {
      displayName: "Nederlands",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    no: {
      displayName: "Norsk",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    "sv-SE": {
      displayName: "Svenska",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: true,
    },
    hu: {
      displayName: "Magyar",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    cs: {
      displayName: "\u010Ce\u0161tina",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    pl: {
      displayName: "Polski",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide_PL.pdf",
      useAsRoot: false,
    },
    id: {
      displayName: "Bahasa Indonesia",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    vi: {
      displayName: "Ti\u1EBFng Vi\u1EC7t",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide_VI.pdf",
      useAsRoot: false,
    },
    el: {
      displayName: "\u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide_EL.pdf",
      useAsRoot: false,
    },
    uk: {
      displayName:
        "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    ka: {
      displayName: "\u10E5\u10D0\u10E0\u10D7\u10E3\u10DA\u10D8",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    th: {
      displayName: "\u0E20\u0E32\u0E29\u0E32\u0E44\u0E17\u0E22",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    tr: {
      displayName: "T\xFCrk\xE7e",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide_TR.pdf",
      useAsRoot: false,
    },
    "zh-CN": {
      displayName: "\u7B80\u4F53\u4E2D\u6587",
      useAsRoot: true,
      userGuideURL:
        "https://desmos.s3.amazonaws.com/Desmos_User_Guide_ZH-CN.pdf",
    },
    "zh-TW": {
      displayName: "\u7E41\u9AD4\u4E2D\u6587",
      userGuideURL:
        "https://desmos.s3.amazonaws.com/Desmos_User_Guide_ZH-TW.pdf",
      useAsRoot: false,
    },
    ko: {
      displayName: "\uD55C\uAD6D\uC5B4",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf",
      useAsRoot: false,
    },
    ja: {
      displayName: "\u65E5\u672C\u8A9E",
      userGuideURL: "https://desmos.s3.amazonaws.com/Desmos_User_Guide_JA.pdf",
      useAsRoot: false,
    },
  };
  var TH = `account-shell-button-cancel = Cancel
account-shell-button-mygraphs-cancel = Cancel
account-shell-link-help = Help
shared-button-back = Back
shared-button-close-dialog = Close Dialog
shared-button-learn-more-capitalized = Learn More
shared-calculator-button-braille-mode-nemeth = Nemeth
shared-calculator-button-braille-mode-ueb = UEB
shared-calculator-button-go = Go
shared-calculator-button-hide-options = Hide Options
shared-calculator-button-show-options = Show Options
shared-calculator-error-3d-bad-equality-slice = We don't support this type of equality restriction.
shared-calculator-error-3d-length-type-error = Function '{ $fn }' cannot be applied to { $arg } in the 3d calculator. Use '{ $alternativeFn }' to find the number of elements in a list.
shared-calculator-error-3d-mixed-restriction-equation = Cannot apply both an inequality restriction and an equality restriction to this expression.
shared-calculator-error-3d-multiple-equality-restrictions = Cannot apply more than one equality restriction.
shared-calculator-error-action-merge-free-variable = Cannot combine an action that depends on free variable '{ $symbol }'.
shared-calculator-error-add-arguments-to-definition-many = Try including '{ $symbols }' and '{ $lastSymbol }' as arguments by defining the function as '{ $newSignature }'.
shared-calculator-error-add-arguments-to-definition-one = Try including '{ $lastSymbol }' as an argument by defining the function as '{ $newSignature }'.
shared-calculator-error-add-type-error = Cannot add { $symbol1 } and { $symbol2 }.
shared-calculator-error-adjacent-mixed-number = Sorry, I don't know what to do with mixed number '{ $mixedNumber }'. Try using a '*' symbol around it.
shared-calculator-error-adjacent-numbers = Sorry, I don't know what to do with adjacent numbers '{ $left }' and '{ $right }'. Try using parentheses or a '*' symbol.
shared-calculator-error-ans-undefined = The previous expression didn't define any value for ans.
shared-calculator-error-assignments-unsupported = This calculator does not support defining variables.
shared-calculator-error-bad-for-input-list-dependency = A definition on the right-hand side of 'for' can't depend on input variable '{ $symbol }'.
shared-calculator-error-bad-for-interval-dependency = Parameter bounds on the right-hand side of 'for' can't depend on input variable '{ $symbol }'.
shared-calculator-error-bad-implicit-call = Use parentheses around the argument of '{ $symbol }'.
shared-calculator-error-bad-integral-bound-dependency = Integration bounds can't depend on integration variable '{ $symbol }'.
shared-calculator-error-bad-interval-comprehension-arity =
{ $count ->
[one] You can't use 'for' to parameterize { $type } using 1 parameter.
*[other] You can't use 'for' to parameterize { $type } using { $count } parameters.
}
shared-calculator-error-bad-log-exponent = Only { $form } is supported. Otherwise, use parens.
shared-calculator-error-bad-product-bound-dependency = Product bounds can't depend on product index '{ $symbol }'.
shared-calculator-error-bad-sample-size = Sample size must be a finite, non-negative number.
shared-calculator-error-bad-sum-bound-dependency = Summation bounds can't depend on summation index '{ $symbol }'.
shared-calculator-error-bad-symbol-context = You can't use '{ $symbol }' in this context.
shared-calculator-error-bad-trig-exponent = Only { $form1 } and { $form2 } are supported. Otherwise, use parens.
shared-calculator-error-bad-tuple-dimensions = Points may only have { $symbol } coordinates.
shared-calculator-error-binary-operator-missing-operand = You need something on both sides of the '{ $symbol }' symbol.
shared-calculator-error-blank-expression = You haven't written anything yet.
shared-calculator-error-boxplot-breadth-invalid = Invalid height. Try using any number.
shared-calculator-error-boxplot-offset-invalid = Invalid offset. Try using any number.
shared-calculator-error-cannot-assign-color = Cannot assign a color to '{ $variable }'.
shared-calculator-error-cannot-redefine = You can't redefine '{ $symbol }' because it's already defined.
shared-calculator-error-cannot-redefine-root = You can't define '{ $symbol }' because '{ $symbolRoot }' is already defined.
shared-calculator-error-cannot-restrict = Cannot create a restriction based on '{ $variable }' in this type of expression.
shared-calculator-error-cannot-restrict-with-equality = Cannot create an equality restriction based on '{ $variable }' in this type of expression.
shared-calculator-error-cannot-subscript = '{ $symbol }' cannot have a subscript.
shared-calculator-error-cant-combine-spherical-and-cylindrical = Can't combine spherical and cylindrical coordinates.
shared-calculator-error-cdf-max-invalid = Invalid cdf max. Try using any number.
shared-calculator-error-cdf-max-less-than-min = Invalid cdf limits. Min should be less than max.
shared-calculator-error-cdf-min-invalid = Invalid cdf min. Try using any number.
shared-calculator-error-cdf-too-many-arguments = 'cdf' should be called on a distribution with at most two numbers. { $recommendation }
shared-calculator-error-cdf-too-many-arguments-recommendation = For example, try typing: D.cdf(-1,1) where D=normaldist().
shared-calculator-error-cdf-wrong-arity = 'cdf' should be called on a distribution with at least one number. { $recommendation }
shared-calculator-error-cdf-wrong-arity-recommendation = For example, try typing: D.cdf(x) where D=normaldist().
shared-calculator-error-clickable-object-assignment-not-defined = "{ $symbol }" is not defined. Try using a different variable or adding a slider.
shared-calculator-error-clickable-object-assignment-not-identifier = Invalid symbol. Try using a single letter.
shared-calculator-error-clickable-object-invalid-expression = Can't evaluate this. Try a number or simple expression.
shared-calculator-error-colon-missing-condition = The left side of a ':' must be a condition, like 'x>1'.
shared-calculator-error-color-arity = '{ $symbol }' should be called with 3 arguments. { $recommendation }
shared-calculator-error-color-arity-recommendation = For example, try typing: { $recommendation }.
shared-calculator-error-color-not-assigned = To use a color, you must assign it to a variable.
shared-calculator-error-combine-type-error = Cannot combine { $symbol1 } and { $symbol2 }.
shared-calculator-error-comparator-type-error = Cannot compare { $symbol1 } to { $symbol2 }.
shared-calculator-error-complex-list-access = Indexing a list with a complex number is not well-defined.
shared-calculator-error-complex-operation-undefined = Note: '{ $symbol }' isn't well-defined for complex numbers.
shared-calculator-error-complex-operation-unimplemented = Note: '{ $symbol }' is not yet implemented for complex numbers.
shared-calculator-error-complex-point-coordinate = Points with complex coordinates are not supported.
shared-calculator-error-complex-round = Note: '{ $symbol }' with complex precision is not well-defined.
shared-calculator-error-complex-sort = Note: '{ $symbol }' uses lexicographic ordering for complex numbers.
shared-calculator-error-complex-table-point-coordinate = Only real-valued coordinate pairs can be plotted.
shared-calculator-error-complicated-double-inequality = We only support solved double inequalities. Try deleting one side of the inequality.
shared-calculator-error-complicated-polar-implicit = Polar equations must be linear in r.
shared-calculator-error-constant-unsupported = This calculator does not support the constant '{ $symbol }'.
shared-calculator-error-coordinate-access-type-error = Cannot access coordinate '{ $coordinate }' of { $symbol }.
shared-calculator-error-custom-regressions-unsupported = This calculator does not support custom regressions.
shared-calculator-error-custom-toolbar-not-condition = Please write a valid condition and make sure every referenced variable is defined.
shared-calculator-error-deeply-nested = Definitions are nested too deeply.
shared-calculator-error-dependency-cycle = '{ $symbols }' and '{ $lastSymbol }' can't be defined in terms of each other.
shared-calculator-error-depends-on-deleted-geo-object = This depends on a geometric object that's no longer defined.
shared-calculator-error-derivative-missing-body = What do you want to take the derivative of?
shared-calculator-error-derivative-type-error = Cannot take the derivative of { $symbol }.
shared-calculator-error-derivative-type-error-respect = Cannot take the derivative of { $symbol1 } with respect to { $symbol2 }.
shared-calculator-error-derivative-variable-type-error = Cannot take derivative with respect to '{ $symbol1 }' because it is { $symbol2 }.
shared-calculator-error-differential-with-superscript = Integration variable cannot have a superscript.
shared-calculator-error-distribution-as-function = Cannot call distribution '{ $symbol }' as a function. Try '{ $symbol }.pdf(x)'.
shared-calculator-error-divide-type-error = Cannot divide { $symbol1 } by { $symbol2 }.
shared-calculator-error-domain-max-invalid = Invalid domain max. Try using any number.
shared-calculator-error-domain-max-less-than-min = Invalid domain limits. Min should be less than max.
shared-calculator-error-domain-min-invalid = Invalid domain min. Try using any number.
shared-calculator-error-dot-lhs-constant-number = Sorry, I don't understand this use of '.' after a constant number.
shared-calculator-error-dot-lhs-type-error = Cannot call '.{ $symbol }' on { $type }.
shared-calculator-error-dot-rhs-property-error = '.{ $symbol }' cannot be followed by parentheses.
shared-calculator-error-duplicate-function-parameter = Cannot use '{ $dependency }' for multiple parameters of this function.
shared-calculator-error-duplicate-update-rules = An action cannot specify multiple update rules for '{ $symbol }'.
shared-calculator-error-empty-paren = Parentheses cannot be empty.
shared-calculator-error-empty-pipe = Absolute value symbol cannot be empty.
shared-calculator-error-empty-radical = Radical cannot be empty.
shared-calculator-error-empty-radical-index = Radical index cannot be empty.
shared-calculator-error-empty-square-bracket = Square brackets cannot be empty.
shared-calculator-error-empty-subscript = Subscripts cannot be empty.
shared-calculator-error-empty-superscript = Superscripts cannot be empty.
shared-calculator-error-equation-required = Try adding an equals sign to turn this into an equation.
shared-calculator-error-equation-required-symbol = Try adding '{ $lhs }' to the beginning of this equation.
shared-calculator-error-equations-unsupported = This calculator does not support this type of equation.
shared-calculator-error-event-handler-type-error = This should be an action. Try '{ $example }'.
shared-calculator-error-exponent-type-error = Cannot raise { $symbol1 } to { $symbol2 }.
shared-calculator-error-feature-unavailable = This feature is not available in the current calculator.
shared-calculator-error-fraction-empty = You need a numerator and denominator for your fraction.
shared-calculator-error-fraction-missing-denominator = You need a denominator for the bottom of your fraction.
shared-calculator-error-fraction-missing-numerator = You need a numerator for the top of your fraction.
shared-calculator-error-function-definition-unsupported = This calculator does not support function definitions.
shared-calculator-error-function-name-as-parameter = Cannot use function name '{ $dependency }' as a function parameter.
shared-calculator-error-function-not-defined = Function '{ $dependency }' is not defined.
shared-calculator-error-function-only-works-in-complex = The '{ $symbol }' function is only available in complex mode.
shared-calculator-error-function-type-error-1 = Function '{ $fn }' cannot be applied to { $arg }.
shared-calculator-error-function-type-error-2 = Function '{ $fn }' cannot be applied to { $arg1 } and { $arg2 }.
shared-calculator-error-function-type-error-many = Function '{ $fn }' cannot be applied to these arguments.
shared-calculator-error-function-unsupported = This calculator does not support the '{ $symbol }' function.
shared-calculator-error-geometry-length-type-error = Function '{ $fn }' cannot be applied to { $arg } in the geometry calculator. Use '{ $alternativeFn }' to find the number of elements in a list.
shared-calculator-error-gpu-expression-too-complex = We encountered a GPU error while plotting this expression.
shared-calculator-error-gpu-function-unsupported = Cannot use the '{ $symbol }' function here.
shared-calculator-error-gpu-integral-unsupported = Cannot use integrals here.
shared-calculator-error-gpu-long-product = Products may not have more than { $maxTermCount } terms here.
shared-calculator-error-gpu-long-sum = Sums may not have more than { $maxTermCount } terms here.
shared-calculator-error-gpu-max-list-size = Lists may not have more than { $maxListSize } elements here.
shared-calculator-error-gpu-variable-list-length = List length cannot depend on variable '{ $symbol }' here.
shared-calculator-error-gpu-variable-product = Product bound cannot depend on variable '{ $symbol }' here.
shared-calculator-error-gpu-variable-sum = Sum bound cannot depend on variable '{ $symbol }' here.
shared-calculator-error-heterogeneous-list = All elements of a list must have the same type.
shared-calculator-error-identifier-as-function = '{ $symbol }' is a function. Try using parentheses.
shared-calculator-error-identifier-is-not-function = '{ $symbol }' is not a function. Try defining it as '{ $symbol }(x) = x^2' instead.
shared-calculator-error-illegal-bin-width = The second argument to '{ $symbol }' must be a positive number.
shared-calculator-error-illegal-dot-call = Function '{ $symbol }' cannot be called with dot notation.
shared-calculator-error-implicits-disabled = Plotting implicit equations and inequalities is disabled.
shared-calculator-error-incorrect-list-comprehension-input = Definitions on the right-hand side of 'for' must set a variable equal to a list. Try i=[1...10].
shared-calculator-error-incorrect-product-lower-bound = Lower bound of a product must set a variable equal to a number. Try n=1.
shared-calculator-error-incorrect-sum-lower-bound = Lower bound of a sum must set a variable equal to a number. Try n=1.
shared-calculator-error-index-type-error = Cannot index { $symbol1 } with { $symbol2 }.
shared-calculator-error-inequalities-disabled = Plotting inequalities is disabled.
shared-calculator-error-inequalities-unsupported = This calculator does not support inequalities.
shared-calculator-error-integral-argument-type-error = Cannot take the integral of { $symbol }.
shared-calculator-error-integral-lower-bound-type-error = Lower bound of an integral cannot be { $symbol }.
shared-calculator-error-integral-missing-body = What do you want to take the integral of?
shared-calculator-error-integral-missing-bound = Integrals must have upper and lower bounds.
shared-calculator-error-integral-missing-differential = Integrand must end with an integration variable, like dx.
shared-calculator-error-integral-upper-bound-type-error = Upper bound of an integral cannot be { $symbol }.
shared-calculator-error-internal-error = [internal] { $msg }
shared-calculator-error-invalid-dependent-first-table-column = This column header can't be defined elsewhere in the calculator.
shared-calculator-error-invalid-double-equality-3d = Sorry, we only plot double equalities that contain z. Try adding 0*z to one side.
shared-calculator-error-invalid-double-inequality-3d = We only plot double inequalities of x, y, and z.
shared-calculator-error-invalid-double-inequality-variables = We only plot double inequalities of x and y.
shared-calculator-error-invalid-first-table-column = First column may not be { $most } or { $last }.
shared-calculator-error-invalid-half-empty-range = Range must have an upper and lower bound.
shared-calculator-error-invalid-implicit-variables = We only support implicit equations of x and y.
shared-calculator-error-invalid-implicit-variables-3d = We only support implicit equations of x, y, and z.
shared-calculator-error-invalid-inequality-variables = We only plot inequalities of x and y, or r and \u03B8.
shared-calculator-error-invalid-interval-comprehension-invalid-bound = Parameter bounds on the right-hand side of 'for' must be of the form '0<{ $identifier }<1'.
shared-calculator-error-invalid-interval-comprehension-return-type = You can't use 'for' to parameterize { $type }.
shared-calculator-error-invalid-lhs = Sorry, you can't graph { $symbol } as a function of anything yet.
shared-calculator-error-invalid-operator-name = Operator names may only contain letters.
shared-calculator-error-invalid-regression-parameter = '{ $symbol }' may not be used as a regression parameter. Try using a different variable name.
shared-calculator-error-invalid-subscript = Subscripts may only contain letters and digits. '{ $symbol }' is not allowed.
shared-calculator-error-invalid-table-entry = Table entries must be simple expressions. { $supplement }
shared-calculator-error-invalid-table-header = Table headers must be simple expressions. { $supplement }
shared-calculator-error-list-comprehension-input-type-error = A definition on the right-hand side of 'for' must be a list, but { $identifier } is { $actual }. Try { $identifier }={ $example }.
shared-calculator-error-list-type-error = Cannot store { $symbol1 } in a list.
shared-calculator-error-log-scale-box-plot = Cannot plot a box plot on a log scale.
shared-calculator-error-log-scale-dot-plot = Cannot plot a dot plot on a log scale.
shared-calculator-error-log-scale-histogram = Cannot plot a histogram on a log scale.
shared-calculator-error-log-scale-type-error = Cannot plot { $symbol } on a log scale.
shared-calculator-error-logbase-unsupported = This calculator does not support specifying the base of a logarithm. Try 'log' or 'ln'.
shared-calculator-error-malformed-list = Lists are written like this: [1, 2, 3].
shared-calculator-error-malformed-point = Points are written like this: (1, 2).
shared-calculator-error-matrix-add-dimensions = Cannot add matrices with different dimensions.
shared-calculator-error-matrix-assignment = This calculator does not support this type of variable definition. Try using 'New Matrix'.
shared-calculator-error-matrix-element-type-error = Cannot use { $arg } as an element of a matrix.
shared-calculator-error-matrix-fractional-power = A matrix can only be raised to integer powers.
shared-calculator-error-matrix-invalid-variable = Cannot use '{ $symbol }' as a variable.
shared-calculator-error-matrix-multiply-dimensions = Cannot multiply matrices with incompatible dimensions.
shared-calculator-error-matrix-power-dimensions = Only square matrices can be raised to a power.
shared-calculator-error-matrix-subtract-dimensions = Cannot subtract matrices with different dimensions.
shared-calculator-error-max-list-size = Lists may not have more than { $maxListSize } elements.
shared-calculator-error-method-requires-list = '{ $symbol }' requires a list. For example, try typing: { $recommendation }.
shared-calculator-error-mismatched-braces = Expected '{ $symbol1 }' to match '{ $symbol2 }'.
shared-calculator-error-mismatched-double-inequality = Double inequalities must both go the same way, e.g. { $example }.
shared-calculator-error-mixed-comparator-chain = Cannot mix inequalities and equations in a chain of comparisons.
shared-calculator-error-multiply-defined = You've defined '{ $dependency }' in more than one place. Try deleting some of the definitions of '{ $dependency }'.
shared-calculator-error-multiply-type-error = Cannot multiply { $symbol1 } by { $symbol2 }.
shared-calculator-error-multiply-type-error-2d = Ambiguous multiplication of { $symbol1 } by { $symbol2 }. Try typing: (1, 2) * (2, 1).
shared-calculator-error-multiply-type-error-3d = Ambiguous multiplication of { $symbol1 } by { $symbol2 }. Try typing: (1, 2, 3) cross (2, 1, 0).
shared-calculator-error-multiply-type-error-cross = Cannot take the cross product of { $symbol1 } and { $symbol2 }.
shared-calculator-error-negative-type-error = Cannot negate { $symbol }.
shared-calculator-error-nested-interval-comprehension = You can't yet use 'for' to introduce a new parameter to an already parameterized point.
shared-calculator-error-non-arithmetic-range = Ranges must be arithmetic sequences.
shared-calculator-error-non-list-double-reducer = Both arguments of '{ $symbol }' must be lists. For example, try typing: { $recommendation }.
shared-calculator-error-non-list-parameterized-reducer = The first argument of '{ $symbol }' must be a list. For example, try typing: { $recommendation }.
shared-calculator-error-non-singular-inverse = Singular matrices do not have an inverse.
shared-calculator-error-non-square-determinant = Only square matrices have a determinant.
shared-calculator-error-non-square-inverse = Only square matrices have an inverse.
shared-calculator-error-non-square-trace = Only square matrices have a trace.
shared-calculator-error-operator-type-error = Cannot apply { $symbol } to { $symbol1 } and { $symbol2 }.
shared-calculator-error-optimization-error = We couldn't find any region where this model is defined.
shared-calculator-error-parameter-already-defined = You can't use '{ $dependency }' as a parameter of this function because '{ $dependency }' is already defined.
shared-calculator-error-parse-error = Sorry, I don't understand this.
shared-calculator-error-pdf-wrong-arity = 'pdf' should be called on a distribution with a number. { $recommendation }
shared-calculator-error-pdf-wrong-arity-recommendation = For example, try typing: D.pdf(x) where D=normaldist().
shared-calculator-error-percent-missing-of = '%' must be used with 'of'. Try '25% of 12'.
shared-calculator-error-piecewise-branch-type-error = Cannot use { $symbol1 } and { $symbol2 } as the branches in a piecewise. Every branch must have the same type.
shared-calculator-error-piecewise-condition-type-error = The condition in a piecewise expression must be { $symbol1 } but was { $symbol2 }.
shared-calculator-error-piecewise-missing-condition = A piecewise expression must have at least one condition.
shared-calculator-error-piecewise-part-missing-condition = Every part of a piecewise expression must have a condition except the last.
shared-calculator-error-point-type-error = Cannot use { $symbol1 } as a coordinate of { $symbol2 }.
shared-calculator-error-points-unsupported = This calculator does not support points.
shared-calculator-error-polygon-unsupported-in-3d = This calculator does not support the 'polygon' function. Try 'triangle' instead.
shared-calculator-error-prime-variable-type-error = Cannot take derivative of '{ $symbol1 }' with respect to { $symbol2 }.
shared-calculator-error-prime-without-paren = Primed function calls must use parentheses.
shared-calculator-error-primed-function-arity = Prime notation can only be used for functions of a single argument.
shared-calculator-error-product-argument-type-error = Cannot take the product of { $symbol }.
shared-calculator-error-product-infinite-bound-type-error = Product bounds must be finite numbers.
shared-calculator-error-product-lower-bound-type-error = Lower bound of a product cannot be { $symbol }.
shared-calculator-error-product-missing-body = What do you want to take the product of?
shared-calculator-error-product-missing-bound = Products must have upper and lower bounds.
shared-calculator-error-product-upper-bound-type-error = Upper bound of a product cannot be { $symbol }.
shared-calculator-error-random-arity = 'random' should be called with no arguments, or an optional number of samples. For example, try random() or random(10).
shared-calculator-error-random-from-broadcast-distribution = Cannot sample from a list of distributions
shared-calculator-error-recursion-argument-type = Expected argument { $index } to be { $expectedType } but found { $foundType }.
shared-calculator-error-recursion-base-case-argument-non-number = Base case arguments must be simple numbers. Try using piecewise syntax.
shared-calculator-error-recursion-base-case-free-variable = This recursion's base case can't depend on variable '{ $freeVariable }'.
shared-calculator-error-recursion-base-case-same-type = Base cases must all have the same return type.
shared-calculator-error-recursion-base-case-too-complicated = For a recursion with multiple parameters, try using piecewise syntax.
shared-calculator-error-recursion-depth-limit-exceeded = Recursive depth limit exceeded without reaching a base case.
shared-calculator-error-recursion-does-not-terminate = This recursion doesn't reach a base case.
shared-calculator-error-recursion-missing-base-case =
{ $count ->
[one] The definition of function '{ $lastSymbol }' depends on itself. If '{ $lastSymbol }' is meant to be a recursive function, try adding a valid base case.
*[other] The definitions of functions '{ $symbols }' and '{ $lastSymbol }' depend on each other. If they are meant to be mutually recursive functions, try adding a valid base case.
}
shared-calculator-error-recursion-wrong-arity =
{ $count ->
[one] Function '{ $fnSymbol }' requires 1 argument.
*[other] Function '{ $fnSymbol }' requires { $count } arguments.
}
shared-calculator-error-regression-recursion = Recursive functions may not be used inside regressions.
shared-calculator-error-regression-type-error = Cannot regress { $symbol1 } against { $symbol2 }.
shared-calculator-error-regressions-unsupported = This calculator does not support regressions.
shared-calculator-error-required-arguments-area = Function '{ $symbol }' requires a polygon.
shared-calculator-error-required-arguments-circle = Function 'circle' requires a center point and another point, segment, or radius value.
shared-calculator-error-required-arguments-coterminal = Function '{ $symbol }' requires an angle.
shared-calculator-error-required-arguments-dilate = Function '{ $symbol }' requires an object, then a point and a number.
shared-calculator-error-required-arguments-glider = Function 'glider' requires an object, then a number.
shared-calculator-error-required-arguments-intersection = Function 'intersection' requires 2 objects (lines, circles, or arcs).
shared-calculator-error-required-arguments-length = Function 'length' requires a segment.
shared-calculator-error-required-arguments-midpoint = Function 'midpoint' requires a segment or 2 points.
shared-calculator-error-required-arguments-perpendicular = Function '{ $symbol }' requires a line and a point.
shared-calculator-error-required-arguments-points = Function '{ $symbol }' requires { $count } points.
shared-calculator-error-required-arguments-polygon = Function 'polygon' requires several points.
shared-calculator-error-required-arguments-radius = Function '{ $symbol }' requires a circle or arc.
shared-calculator-error-required-arguments-reflect = Function 'reflect' requires an object, then a line, segment, ray, or vector.
shared-calculator-error-required-arguments-sphere = Function 'sphere' requires a center point and a radius value.
shared-calculator-error-required-arguments-start = Function '{ $symbol }' requires a vector.
shared-calculator-error-required-arguments-supplement = Function 'supplement' requires a directed angle.
shared-calculator-error-required-arguments-translate = Function 'translate' requires an object, then 2 points or a vector.
shared-calculator-error-required-arguments-triangle = Function 'triangle' requires three 3d points.
shared-calculator-error-required-arguments-vector = Function 'vector' requires a start point and end point.
shared-calculator-error-self-referential-base-case = A base case for recursive function '{ $symbol }' cannot depend on '{ $symbol }'.
shared-calculator-error-self-referential-functions =
{ $count ->
[one] The definition of function '{ $lastSymbol }' depends on itself.
*[other] The definitions of functions '{ $symbols }' and '{ $lastSymbol }' depend on each other.
}
shared-calculator-error-self-referential-suggest-alternative = '{ $symbol }' cannot be defined recursively. Try renaming this function.
shared-calculator-error-shadowed-index = You can't use '{ $symbol }' as an index because it's already defined.
shared-calculator-error-shadowed-integration-variable = You can't use '{ $symbol }' as an integration variable because it's already defined.
shared-calculator-error-shadowed-list-comprehension-input = You can't define '{ $symbol }' more than once on the right-hand side of 'for'.
shared-calculator-error-single-variable-implicit-equations-disabled = Plotting single-variable implicit equations is disabled.
shared-calculator-error-slider-limit-references-export = Slider limits cannot depend on the slider variable '{ $symbol }'.
shared-calculator-error-slider-max-invalid = Invalid slider max. Try using any number.
shared-calculator-error-slider-max-less-than-min = Invalid slider limits. Min should be less than max.
shared-calculator-error-slider-min-invalid = Invalid slider min. Try using any number.
shared-calculator-error-slider-step-invalid = Invalid slider step. Try using any number.
shared-calculator-error-slow-evaluation = This is taking a long time to evaluate. Try editing or deleting this expression.
shared-calculator-error-substitution-ambiguous-comma = Ambiguous use of ',' and '{ $operation }'. Add parentheses around the '{ $operation }' expression.
shared-calculator-error-substitution-body-action = The left hand side of a 'with' substitution cannot be an action.
shared-calculator-error-substitution-body-regression-parameter-dependency = Can't use '{ $operator }' to substitute for the existing variable '{ $globalVariable }' because the expression on the left-hand side depends on '{ $regressionParameter }', which is a regression parameter.
shared-calculator-error-substitution-duplicate-assignment = A 'with' expression cannot make multiple substitutions for '{ $symbol }'.
shared-calculator-error-substitution-function-lhs = Substituting for '{ $symbol }' is not allowed because it is a function.
shared-calculator-error-substitution-illegal-lhs = Substituting for '{ $symbol }' is not allowed.
shared-calculator-error-substitution-invalid-assignments = 'with' must be followed by one or more variable definitions.
shared-calculator-error-substitution-local-lhs = Substituting for variable '{ $symbol }' is not allowed because it is locally defined.
shared-calculator-error-substitution-nested = Using one 'with' expression inside another 'with' expression is not allowed.
shared-calculator-error-substitution-recursive-call-lhs = Can't use '{ $operator }' to substitute for the existing variable '{ $globalVariable }' because the expression on the left-hand side depends on a recursive function call to '{ $fnSymbol }'.
shared-calculator-error-substitution-type-error = Cannot substitute { $actual } for { $expected }.
shared-calculator-error-substitution-unsupported-interval = Intervals are not allowed on the right-hand side of 'with'. You might want to try using 'for' instead.
shared-calculator-error-subtract-type-error = Cannot subtract { $symbol2 } from { $symbol1 }.
shared-calculator-error-sum-argument-type-error = Cannot take the sum of { $symbol }.
shared-calculator-error-sum-infinite-bound-type-error = Summation bounds must be finite numbers.
shared-calculator-error-sum-lower-bound-type-error = Lower bound of a sum cannot be { $symbol }.
shared-calculator-error-sum-missing-body = What do you want to take the sum of?
shared-calculator-error-sum-missing-bound = Sums must have upper and lower bounds.
shared-calculator-error-sum-upper-bound-type-error = Upper bound of a sum cannot be { $symbol }.
shared-calculator-error-superscript-with-prime = Superscripts and primes cannot be combined.
shared-calculator-error-table-entry-type-error = Table entry cannot be { $symbol }.
shared-calculator-error-table-equation-supplement = Equations are not allowed.
shared-calculator-error-table-function-definition-supplement = Function definitions are not allowed.
shared-calculator-error-table-generic-supplement = This type of expression is not allowed.
shared-calculator-error-table-header-type-error = Table header cannot be { $symbol }.
shared-calculator-error-table-inequality-supplement = Inequalities are not allowed.
shared-calculator-error-table-list-supplement = Lists are not allowed.
shared-calculator-error-table-regression-invalid-data = There's an error in the provided data.
shared-calculator-error-table-regression-invalid-export-identifier = The headers need to be simple identifiers to export. Try assigning { $latex } to a variable and then referencing it in the table header.
shared-calculator-error-table-regression-log-with-negative = Logarithmic regressions only work if the first column is all positive numbers.
shared-calculator-error-table-regression-supplement = Regressions are not allowed.
shared-calculator-error-table-regression-type-error = The data contains { $symbol }.
shared-calculator-error-tdist-wrong-arity = 'tdist' requires 1 argument. For example, try typing: tdist(1).
shared-calculator-error-ticker-min-step-nonnegative = Min step must evaluate to a non-negative number.
shared-calculator-error-token-with-subscript = Tokens may not have subscripts.
shared-calculator-error-too-many-arguments = '{ $symbol }' accepts at most { $max } arguments.
shared-calculator-error-too-many-variables-many-symbols = Too many variables. Try defining '{ $variables }' or '{ $lastVariable }'.
shared-calculator-error-too-many-variables-no-symbols = Too many variables, I don't know what to do with this.
shared-calculator-error-too-many-variables-one-symbol = Too many variables. Try defining '{ $variable }'.
shared-calculator-error-transformation-definition-expected-types-1 = Try using { $arg }.
shared-calculator-error-transformation-definition-expected-types-2 = Try using { $arg1 } and { $arg2 }.
shared-calculator-error-transformation-definition-expected-types-use-fewer-1 = Try using just { $arg }.
shared-calculator-error-transformation-definition-expected-types-use-fewer-2 = Try using just { $arg1 } and { $arg2 }.
shared-calculator-error-transformation-definition-type-error-1 = A { $fn } cannot be defined using { $arg }. { $expectedTypeMessage }
shared-calculator-error-transformation-definition-type-error-2 = A { $fn } cannot be defined using { $arg1 } and { $arg2 }. { $expectedTypeMessage }
shared-calculator-error-transformation-definition-type-error-many = A '{ $fn }' cannot be defined with these arguments.
shared-calculator-error-transformation-definition-type-error-use-more-1 = A { $fn } cannot be defined using just { $arg }. { $expectedTypeMessage }
shared-calculator-error-transformation-definition-type-error-use-more-2 = A { $fn } cannot be defined using just { $arg1 } and { $arg2 }. { $expectedTypeMessage }
shared-calculator-error-transformation-type-error-1 = Transformation '{ $fn }' cannot be applied to { $arg }.
shared-calculator-error-transformation-type-error-2 = Transformation '{ $fn }' cannot be applied to { $arg1 } and { $arg2 }.
shared-calculator-error-transformation-type-error-many = Transformation '{ $fn }' cannot be applied to these arguments.
shared-calculator-error-ttest-list-too-short = Lists for '{ $symbol }' must have at least 2 elements.
shared-calculator-error-two-numbers-error = Cannot make a polygon from two numbers.
shared-calculator-error-unary-operator-missing-left = You need something before the '{ $symbol }' symbol.
shared-calculator-error-unary-operator-missing-right = You need something after the '{ $symbol }' symbol.
shared-calculator-error-unexpected-equality = Cannot use an equality here.
shared-calculator-error-unexpected-inequality = Cannot use an inequality here.
shared-calculator-error-unexpected-prime = Sorry, I don't understand this use of prime notation.
shared-calculator-error-unexpected-subscript = Only functions and variables may have subscripts.
shared-calculator-error-unexpected-symbol = Sorry, I don't understand the way that '{ $symbol }' is used here.
shared-calculator-error-unplottable-chained-equality = This calculator cannot plot chained equations.
shared-calculator-error-unplottable-long-inequality-chain = This calculator cannot plot chains of more than 2 inequalities.
shared-calculator-error-unplottable-polar-function = We can't plot \u03B8 as a function of r. Try plotting r(\u03B8) instead.
shared-calculator-error-unrecognized-symbol = Sorry, I don't understand the '{ $symbol }' symbol.
shared-calculator-error-update-rule-function-lhs = '{ $symbol }' cannot be updated because it is a function.
shared-calculator-error-update-rule-illegal-lhs = Variable '{ $symbol }' cannot be updated.
shared-calculator-error-update-rule-local-lhs = Variable '{ $symbol }' cannot be updated because it is locally defined.
shared-calculator-error-update-rule-non-identifier-lhs = The left hand side of '{ $arrow }' should be a variable name like '{ $example }'.
shared-calculator-error-update-rule-type-error = Cannot update a variable to { $symbol }.
shared-calculator-error-update-rule-undefined-lhs = Variable '{ $symbol }' must be defined to be updated.
shared-calculator-error-use-r-for-cylindrical-coordinates = Can't combine '\u03C1' and 'z'. Try 'r' for cylindrical coordinates.
shared-calculator-error-use-rho-for-spherical-coordinates = Can't combine 'r' and '\u03C6'. Try '\u03C1' (rho) for spherical coordinates.
shared-calculator-error-variable-as-function = Variable '{ $dependency }' can't be used as a function.
shared-calculator-error-variable-invalid-function-name = This calculator can not use '{ $symbol }' as a function name.
shared-calculator-error-variable-length-distribution-list = The length of a list of distributions can't depend on free variable '{ $symbol }'.
shared-calculator-error-variable-length-integral-depends-on-integration-var = Can't integrate a list whose length depends on integration variable '{ $symbol }'.
shared-calculator-error-variable-length-product-body-depends-on-index = Can't take the product of a list whose length depends on product index '{ $symbol }'.
shared-calculator-error-variable-length-sum-body-depends-on-index = Can't sum a list whose length depends on summation index '{ $symbol }'.
shared-calculator-error-variable-length-top-level-list = Can't plot a list whose length depends on free variable '{ $symbol }'.
shared-calculator-error-variable-seed = Random seed cannot depend on free variable '{ $symbol }'.
shared-calculator-error-variable-unsupported = This calculator does not support the '{ $symbol }' variable.
shared-calculator-error-variables-unsupported = This calculator does not support variables like '{ $variable }'.
shared-calculator-error-write-integral = Type '{ $command }' for { $symbol }.
shared-calculator-error-wrong-arity-many-arg = Function '{ $dependency }' requires { $assignment_arity } arguments. { $supplement }
shared-calculator-error-wrong-arity-single-arg-too-few = Function '{ $dependency }' requires an argument. { $supplement }
shared-calculator-error-wrong-arity-single-arg-too-many = Function '{ $dependency }' requires only 1 argument. { $supplement }
shared-calculator-error-wrong-arity-supplement = For example, try typing: { $recommendation }.
shared-calculator-error-wrong-two-arg-arity = Function '{ $symbol }' requires 2 arguments. For example, try typing: { $recommendation }.
shared-calculator-error-zero-arg-reducer = Function '{ $symbol }' requires at least one argument. For example, try typing: { $symbol }(1, 2).
shared-calculator-label-for = for
shared-calculator-label-hide-custom-colors = Hide custom colors from geo toolbar
shared-calculator-label-list-of-count-items-suffix =
{ $count ->
[0] empty
[one] 1 item
*[other] { $count } items
}
shared-calculator-label-slow-plotting = This expression is currently being plotted and may take a long time
shared-calculator-label-toast-learn-more = Learn more
shared-calculator-label-toast-undo = Undo
shared-calculator-label-value-type-action = an action
shared-calculator-label-value-type-angle = an angle
shared-calculator-label-value-type-any = an unknown object
shared-calculator-label-value-type-arc = an arc
shared-calculator-label-value-type-bool = a true/false value
shared-calculator-label-value-type-circle = a circle
shared-calculator-label-value-type-color = a color
shared-calculator-label-value-type-complex = a complex number
shared-calculator-label-value-type-directed-angle = a directed angle
shared-calculator-label-value-type-distribution = a distribution
shared-calculator-label-value-type-empty-list = an empty list
shared-calculator-label-value-type-error = an error object
shared-calculator-label-value-type-lambda-complex = a parameterized complex number
shared-calculator-label-value-type-lambda-point = a parameterized point
shared-calculator-label-value-type-lambda-point3d = a parameterized 3d point
shared-calculator-label-value-type-line = a line
shared-calculator-label-value-type-list-of-2d-points = a list of 2d points
shared-calculator-label-value-type-list-of-3d-points = a list of 3d points
shared-calculator-label-value-type-list-of-angles = a list of angles
shared-calculator-label-value-type-list-of-any = a list of unknown objects
shared-calculator-label-value-type-list-of-arcs = a list of arcs
shared-calculator-label-value-type-list-of-bool = a list of true/false values
shared-calculator-label-value-type-list-of-circles = a list of circles
shared-calculator-label-value-type-list-of-colors = a list of colors
shared-calculator-label-value-type-list-of-complex = a list of complex numbers
shared-calculator-label-value-type-list-of-directed-angles = a list of directed angles
shared-calculator-label-value-type-list-of-distributions = a list of distributions
shared-calculator-label-value-type-list-of-lambda-complex = a list of parameterized complex numbers
shared-calculator-label-value-type-list-of-lambda-point = a list of parameterized points
shared-calculator-label-value-type-list-of-lambda-point3d = a list of parameterized 3d points
shared-calculator-label-value-type-list-of-lines = a list of lines
shared-calculator-label-value-type-list-of-numbers = a list of numbers
shared-calculator-label-value-type-list-of-points = a list of points
shared-calculator-label-value-type-list-of-polygons = a list of polygons
shared-calculator-label-value-type-list-of-rays = a list of rays
shared-calculator-label-value-type-list-of-restrictions = a list of restrictions
shared-calculator-label-value-type-list-of-segment3d = a list of 3d segments
shared-calculator-label-value-type-list-of-segments = a list of segments
shared-calculator-label-value-type-list-of-sphere3d = a list of 3d sphere
shared-calculator-label-value-type-list-of-tone = a list of tones
shared-calculator-label-value-type-list-of-transformations = a list of transformations
shared-calculator-label-value-type-list-of-triangle3d = a list of 3d triangles
shared-calculator-label-value-type-list-of-vector3d = a list of 3d vectors
shared-calculator-label-value-type-list-of-vectors = a list of vectors
shared-calculator-label-value-type-number = a number
shared-calculator-label-value-type-point = a point
shared-calculator-label-value-type-point2d = a 2d point
shared-calculator-label-value-type-point3d = a 3d point
shared-calculator-label-value-type-polygon = a polygon
shared-calculator-label-value-type-ray = a ray
shared-calculator-label-value-type-restriction = a restriction
shared-calculator-label-value-type-seed = a string
shared-calculator-label-value-type-segment = a segment
shared-calculator-label-value-type-segment3d = a 3d segment
shared-calculator-label-value-type-sphere3d = a 3d sphere
shared-calculator-label-value-type-tone = a tone
shared-calculator-label-value-type-transformation = a transformation
shared-calculator-label-value-type-triangle3d = a 3d triangle
shared-calculator-label-value-type-vector = a vector
shared-calculator-label-value-type-vector3d = a 3d vector
shared-calculator-narration-author-mode = Author Mode
shared-calculator-narration-author-mode-off = Author mode off
shared-calculator-narration-author-mode-on = Author mode on
shared-calculator-narration-braille-mode = Braille Mode
shared-calculator-narration-disable-tool = Disable { $tool } when this condition is true
shared-calculator-narration-display-as-decimal = Displaying as fraction. Press Enter to display as Decimal
shared-calculator-narration-display-as-fraction = Displaying as decimal. Press Enter to display as Fraction
shared-calculator-narration-expression-index = Expression { $index }
shared-calculator-narration-expression-list = Expression List
shared-calculator-narration-hotkey-braille-mode-nemeth = Braille mode Nemeth
shared-calculator-narration-hotkey-braille-mode-off = Braille mode off
shared-calculator-narration-hotkey-braille-mode-ueb = Braille mode UEB
shared-calculator-narration-input-error = input has an error
shared-calculator-narration-item-clickable = { $item } clickable
shared-calculator-narration-item-selected = { $item } selected
shared-calculator-narration-item-unknown = Unknown
shared-calculator-narration-item-unselected = { $item } unselected
shared-calculator-narration-keypad = keypad
shared-calculator-narration-keypad-controlbar = Control Bar
shared-calculator-narration-keypad-key-10-n = Times ten to the power of
shared-calculator-narration-keypad-key-abs = Absolute Value
shared-calculator-narration-keypad-key-action-to = Set Value To
shared-calculator-narration-keypad-key-action-with = Substitute With
shared-calculator-narration-keypad-key-alpha = Alpha
shared-calculator-narration-keypad-key-angle = Angle
shared-calculator-narration-keypad-key-angles = Angles
shared-calculator-narration-keypad-key-ans = Answer
shared-calculator-narration-keypad-key-arc = Arc
shared-calculator-narration-keypad-key-arccos = Inverse Cosine
shared-calculator-narration-keypad-key-arccot = Inverse Cotangent
shared-calculator-narration-keypad-key-arccsc = Inverse Cosecant
shared-calculator-narration-keypad-key-arcsec = Inverse Secant
shared-calculator-narration-keypad-key-arcsin = Inverse Sine
shared-calculator-narration-keypad-key-arctan = Inverse Tangent
shared-calculator-narration-keypad-key-area = Area
shared-calculator-narration-keypad-key-arg = Argument
shared-calculator-narration-keypad-key-backspace = Backspace
shared-calculator-narration-keypad-key-beta = Beta
shared-calculator-narration-keypad-key-binomialdist = Binomial Distribution
shared-calculator-narration-keypad-key-boxplot = Box Plot
shared-calculator-narration-keypad-key-ceil = Ceiling
shared-calculator-narration-keypad-key-center = Center
shared-calculator-narration-keypad-key-circle = Circle
shared-calculator-narration-keypad-key-conj = Complex conjugate
shared-calculator-narration-keypad-key-corr = Correlation
shared-calculator-narration-keypad-key-cos = Cosine
shared-calculator-narration-keypad-key-cosh = Hyperbolic Cosine
shared-calculator-narration-keypad-key-cot = Cotangent
shared-calculator-narration-keypad-key-coterminal = Coterminal
shared-calculator-narration-keypad-key-coth = Hyperbolic Cotangent
shared-calculator-narration-keypad-key-cov = Co Variance
shared-calculator-narration-keypad-key-covp = Population Co Variance
shared-calculator-narration-keypad-key-csc = Cosecant
shared-calculator-narration-keypad-key-csch = Hyperbolic Cosecant
shared-calculator-narration-keypad-key-cubed = Cubed
shared-calculator-narration-keypad-key-decimal = Decimal
shared-calculator-narration-keypad-key-dilate = Dilate
shared-calculator-narration-keypad-key-directed-angle = Directed Angle
shared-calculator-narration-keypad-key-directed-angles = Directed Angles
shared-calculator-narration-keypad-key-distance = Distance
shared-calculator-narration-keypad-key-divide = Divide
shared-calculator-narration-keypad-key-dotplot = Dot Plot
shared-calculator-narration-keypad-key-enter = Enter
shared-calculator-narration-keypad-key-erf = Error Function
shared-calculator-narration-keypad-key-exp = Exponent
shared-calculator-narration-keypad-key-factorial = Factorial
shared-calculator-narration-keypad-key-floor = Floor
shared-calculator-narration-keypad-key-fraction = A over B
shared-calculator-narration-keypad-key-glider = Glider
shared-calculator-narration-keypad-key-histogram = Histogram
shared-calculator-narration-keypad-key-imag = Imaginary
shared-calculator-narration-keypad-key-int = Integral
shared-calculator-narration-keypad-key-intersection = Intersection
shared-calculator-narration-keypad-key-inversecdf = Inverse CDF function
shared-calculator-narration-keypad-key-ittest = Independent T Test
shared-calculator-narration-keypad-key-left-arrow = Left Arrow
shared-calculator-narration-keypad-key-left-bracket = Left Bracket
shared-calculator-narration-keypad-key-left-paren = Left Parenthesis
shared-calculator-narration-keypad-key-line = Line
shared-calculator-narration-keypad-key-ln = Natural Log
shared-calculator-narration-keypad-key-log = Log
shared-calculator-narration-keypad-key-loga = Log A
shared-calculator-narration-keypad-key-mean = Mean
shared-calculator-narration-keypad-key-median = Median
shared-calculator-narration-keypad-key-midpoint = Midpoint
shared-calculator-narration-keypad-key-minus = Minus
shared-calculator-narration-keypad-key-normaldist = Normal Distribution
shared-calculator-narration-keypad-key-nthroot = Nth Root
shared-calculator-narration-keypad-key-parallel = Parallel
shared-calculator-narration-keypad-key-pdf = Probability Density Function
shared-calculator-narration-keypad-key-percent-of = Percent Of
shared-calculator-narration-keypad-key-perimeter = Perimeter
shared-calculator-narration-keypad-key-perpendicular = Perpendicular
shared-calculator-narration-keypad-key-phi = Phi
shared-calculator-narration-keypad-key-pi = Pi
shared-calculator-narration-keypad-key-plus = Plus
shared-calculator-narration-keypad-key-poissondist = Poisson Distribution
shared-calculator-narration-keypad-key-polygon = Polygon
shared-calculator-narration-keypad-key-prime = Function derivative
shared-calculator-narration-keypad-key-product = Product
shared-calculator-narration-keypad-key-quantile = Quantile
shared-calculator-narration-keypad-key-quartile = Quartile
shared-calculator-narration-keypad-key-radius = Radius
shared-calculator-narration-keypad-key-random = Random Number
shared-calculator-narration-keypad-key-ray = Ray
shared-calculator-narration-keypad-key-real = Real
shared-calculator-narration-keypad-key-reciprocal = Reciprocal
shared-calculator-narration-keypad-key-reflect = Reflect
shared-calculator-narration-keypad-key-rho = Rho
shared-calculator-narration-keypad-key-right-arrow = Right Arrow
shared-calculator-narration-keypad-key-right-bracket = Right Bracket
shared-calculator-narration-keypad-key-right-paren = Right Parenthesis
shared-calculator-narration-keypad-key-rotate = Rotate
shared-calculator-narration-keypad-key-round = Round
shared-calculator-narration-keypad-key-sec = Secant
shared-calculator-narration-keypad-key-segment = Segment
shared-calculator-narration-keypad-key-segments = Segments
shared-calculator-narration-keypad-key-shift = Shift
shared-calculator-narration-keypad-key-sin = Sine
shared-calculator-narration-keypad-key-sinh = Hyperbolic Sine
shared-calculator-narration-keypad-key-spearman = Spearman Rank Correlation
shared-calculator-narration-keypad-key-sphere = Sphere
shared-calculator-narration-keypad-key-sqrt = Square Root
shared-calculator-narration-keypad-key-squared = Squared
shared-calculator-narration-keypad-key-stats = Summary statistics
shared-calculator-narration-keypad-key-stdev = Standard Deviation
shared-calculator-narration-keypad-key-stdevp = Standard Deviation of Population
shared-calculator-narration-keypad-key-subscript = Subscript
shared-calculator-narration-keypad-key-sum = Sum
shared-calculator-narration-keypad-key-superscript = Superscript
shared-calculator-narration-keypad-key-supplement = Supplement
shared-calculator-narration-keypad-key-tan = Tangent
shared-calculator-narration-keypad-key-tanh = Hyperbolic Tangent
shared-calculator-narration-keypad-key-tau = Tau
shared-calculator-narration-keypad-key-tdist = Student-t Distribution
shared-calculator-narration-keypad-key-theta = Theta
shared-calculator-narration-keypad-key-times = Times
shared-calculator-narration-keypad-key-toggle-audio-trace = Toggle Audio Trace
shared-calculator-narration-keypad-key-toggle-letters = Toggle Letters
shared-calculator-narration-keypad-key-toggle-numbers = Toggle Numbers
shared-calculator-narration-keypad-key-tone = Tone
shared-calculator-narration-keypad-key-translate = Translate
shared-calculator-narration-keypad-key-triangle = Triangle
shared-calculator-narration-keypad-key-tscore = T Score
shared-calculator-narration-keypad-key-ttest = T Test
shared-calculator-narration-keypad-key-uniformdist = Uniform Distribution
shared-calculator-narration-keypad-key-vector = Vector
shared-calculator-narration-keypad-key-vertices = Vertices
shared-calculator-narration-keypad-key-ythroot = Yth Root
shared-calculator-narration-keypad-plus-minus = Plus-Minus
shared-calculator-narration-math-input-error-message = expression has error
shared-calculator-narration-settings-display-size = Display Size
shared-calculator-narration-settings-display-size-default = Display size: default
shared-calculator-narration-settings-display-size-large = Display size: large
shared-calculator-narration-show-as-decimal = Show as Decimal
shared-calculator-narration-show-as-fraction = Show as Fraction
shared-calculator-narration-six-key-mode-off = Six Key Braille Input off
shared-calculator-narration-six-key-mode-on = Six Key Braille Input on
shared-calculator-text-complex-enabled-note = Hint: try writing { $eq1 } or { $eq2 }.
shared-calculator-text-complex-radian-mode = Complex mode uses radians
shared-calculator-text-customize-toolbar = Customize the Toolbar
shared-calculator-text-search-results =
{ $count ->
[0] No results.
[one] 1 result.
*[other] { $count } results.
}
shared-label-to = to
basic-calculator-button-controlbar-abc = abc
basic-calculator-button-controlbar-clear = clear
basic-calculator-button-controlbar-clear-all = clear all
basic-calculator-button-controlbar-func = func
basic-calculator-button-controlbar-main = main
basic-calculator-button-turn-braille-mode-off = Turn { $mode } off
basic-calculator-error-fractions-unavailable = Fractions are not available in the current calculator.
basic-calculator-error-parentheses-unavailable = Parentheses are not available in this calculator.
basic-calculator-heading-braille-table-type-this = Type this
basic-calculator-heading-braille-table-typeset = Typeset
basic-calculator-label-answer-hint = Your answers show up on this side.
basic-calculator-label-controlbar-deg = deg
basic-calculator-label-controlbar-rad = rad
basic-calculator-label-convert-to-decimal = Convert to decimal.
basic-calculator-label-convert-to-fraction = Convert to fraction.
basic-calculator-label-reverse-contrast = Reverse Contrast
basic-calculator-link-download-braille-equations = Download Braille Equations
basic-calculator-link-view-braille-examples = View more examples
basic-calculator-narration-calc-description-fourfunction = Desmos Four-Function Calculator
basic-calculator-narration-calc-description-scientific = Desmos Scientific Calculator
basic-calculator-narration-controlbar-abc = A B C
basic-calculator-narration-controlbar-backspace = backspace
basic-calculator-narration-controlbar-clear = clear
basic-calculator-narration-controlbar-clear-all = clear all
basic-calculator-narration-controlbar-degrees = Degrees
basic-calculator-narration-controlbar-functions = Functions
basic-calculator-narration-controlbar-main = main
basic-calculator-narration-controlbar-radians = Radians
basic-calculator-narration-controlbar-redo = Redo
basic-calculator-narration-controlbar-settings = settings
basic-calculator-narration-controlbar-undo = Undo
basic-calculator-narration-convert-to-decimal = Displaying as fraction. Press Enter to display as Decimal
basic-calculator-narration-convert-to-fraction = Displaying as decimal. Press Enter to display as Fraction
basic-calculator-narration-hotkey-six-key-input-off = Six Key Braille Input off
basic-calculator-narration-hotkey-six-key-input-on = Six Key Braille Input on
basic-calculator-text-braille-mode-is-on = { $mode } is on!
basic-calculator-text-how-to-type-braille = Use a Refreshable Braille display, or just type Braille with a keyboard.
geometry-label-construct-instruction = Click down here to construct
geometry-label-pick-tool-instruction = Pick a tool to get started
graphing-calculator-button-add-table-regression = Add Regression
graphing-calculator-button-audio-trace-hear-graph = Hear Graph
graphing-calculator-button-audio-trace-stop-graph = Stop Graph
graphing-calculator-button-change-image = Change Image
graphing-calculator-button-clear-graph = Delete All
graphing-calculator-button-copy-poi-coordinates = Export point to expression list
graphing-calculator-button-copy-table-regression-model-to-expression-list = Export as custom regression
graphing-calculator-button-delete-table-regression = Delete regression
graphing-calculator-button-done = Done
graphing-calculator-button-draggable = Draggable
graphing-calculator-button-draggable-points = Draggable Points
graphing-calculator-button-edit-graph-on-desmos-logo = edit graph on
graphing-calculator-button-editable-math = Editable Math
graphing-calculator-button-editable-text = Editable Text
graphing-calculator-button-find-cdf = Find Cumulative Probability (CDF)
graphing-calculator-button-funcs = funcs
graphing-calculator-button-functions = functions
graphing-calculator-button-functions-menu-custom-colors = Custom Colors
graphing-calculator-button-functions-menu-number-theory = Number Theory
graphing-calculator-button-geometry-label-points = Label Points
graphing-calculator-button-hide-folder-from-students-2 = Hide this folder from students.
graphing-calculator-button-in-front-of-everything = In front of everything
graphing-calculator-button-keypad-audio-trace-off = Audio Trace Off
graphing-calculator-button-keypad-describe-axes = Describe Axes
graphing-calculator-button-keypad-describe-curve = Describe Curve
graphing-calculator-button-keypad-describe-curve-short = Curve
graphing-calculator-button-keypad-describe-point = Describe Point
graphing-calculator-button-keypad-describe-point-short = Point
graphing-calculator-button-label = Label
graphing-calculator-button-label-editable = Editable
graphing-calculator-button-label-show-on-hover = Show on hover
graphing-calculator-button-label-text-outline = Text outline
graphing-calculator-button-load-image-retry = Retry.
graphing-calculator-button-move-to-expression-list-action = Move
graphing-calculator-button-place-image-behind-graphs = Place behind graphs
graphing-calculator-button-regression-log-mode = Log Mode
graphing-calculator-button-regression-plot-residuals = plot
graphing-calculator-button-replace = Replace
graphing-calculator-button-reset-graph = Reset
graphing-calculator-button-settings-degrees = Degrees
graphing-calculator-button-settings-radians = Radians
graphing-calculator-button-settings-zoom-square = Zoom Square
graphing-calculator-button-show-all-table-rows = Show all
graphing-calculator-button-slider-add-all-variables = all
graphing-calculator-button-visual-parameters-binned = Binned
graphing-calculator-button-visual-parameters-center = Center
graphing-calculator-button-visual-parameters-count = Count
graphing-calculator-button-visual-parameters-density = Density
graphing-calculator-button-visual-parameters-exact = Exact
graphing-calculator-button-visual-parameters-exclude-outliers = Exclude Outliers
graphing-calculator-button-visual-parameters-left = Left
graphing-calculator-button-visual-parameters-relative = Relative
graphing-calculator-error-equation-contains-unresolved-details = This plot contains fine detail that has not been fully resolved.
graphing-calculator-error-expression-replacement = Replacement must be a valid function or variable name.
graphing-calculator-error-expression-search = Can only rename a valid function or variable name.
graphing-calculator-error-failed-to-load-image = Failed to load image.
graphing-calculator-error-image-invalid-angle = Invalid angle. Try using any number.
graphing-calculator-error-image-invalid-center = Invalid center. Try, for example, (0,0).
graphing-calculator-error-image-invalid-file = The file "{ $file }" is not an image
graphing-calculator-error-image-invalid-height = Invalid height. Try using any number.
graphing-calculator-error-image-invalid-opacity = Invalid opacity. Try using any number.
graphing-calculator-error-image-invalid-width = Invalid width. Try using any number.
graphing-calculator-error-legacy-random-seed-behavior = This graph uses legacy randomization behavior.
graphing-calculator-error-log-axes-image = Cannot plot images on a log scale.
graphing-calculator-error-nan-blame-complex-coercion = Plotted values are non-real at all input points. Try using absolute value to convert complex numbers to real.
graphing-calculator-error-reached-maximum-recursion-depth = Reached maximum recursion depth while plotting this expression.
graphing-calculator-error-table-regression-unexportable-reserved-variable-single = Column { $variable } can't be referenced outside of the table. To create a standalone regression, first try renaming that column.
graphing-calculator-error-table-regression-unexportable-reserved-variables-many = These columns can't be referenced outside of the table. To export the regression model, first try renaming the columns.
graphing-calculator-error-tone-frequency-out-of-range = Tones can only play for frequencies between { $min }Hz and { $max }Hz.
graphing-calculator-heading-advanced = Advanced
graphing-calculator-heading-audio-trace-describe = Describe
graphing-calculator-heading-audio-trace-navigation = Navigation
graphing-calculator-heading-audio-trace-screen-reader = Screen Reader
graphing-calculator-heading-calculus = Calculus
graphing-calculator-heading-clickable = Clickable
graphing-calculator-heading-dist-tab-distributions = Distributions
graphing-calculator-heading-dist-tab-visualizations = Visualizations
graphing-calculator-heading-drag = Drag
graphing-calculator-heading-fill = Fill
graphing-calculator-heading-functions-menu-advanced = Advanced
graphing-calculator-heading-functions-menu-complex = Complex
graphing-calculator-heading-functions-menu-polar = Polar Coordinates
graphing-calculator-heading-functions-menu-sound = Sound
graphing-calculator-heading-geometry = Geometry
graphing-calculator-heading-geometry-measurements = Properties & Measurements
graphing-calculator-heading-geometry-tools = Geometry Tools
graphing-calculator-heading-geometry-transformations = Transformations
graphing-calculator-heading-hyperbolic-trig = Hyperbolic Trig Functions
graphing-calculator-heading-image-opacity = Opacity
graphing-calculator-heading-inverse-trig = Inverse Trig Functions
graphing-calculator-heading-keypad-audio-trace-point-of-interest = <1>Point</1><2>of Interest</2>
graphing-calculator-heading-label = Label
graphing-calculator-heading-label-orientation = Orientation
graphing-calculator-heading-lines = Lines
graphing-calculator-heading-lists = List Operations
graphing-calculator-heading-points = Points
graphing-calculator-heading-regression-equation = Equation
graphing-calculator-heading-regression-parameters = Regression Parameters
graphing-calculator-heading-regression-residuals = Residuals
graphing-calculator-heading-regression-statistics = Statistics
graphing-calculator-heading-slider-animation-mode = Animation Mode
graphing-calculator-heading-slider-speed = Speed
graphing-calculator-heading-stat-tests = Statistical Tests
graphing-calculator-heading-stats = Statistics
graphing-calculator-heading-style = Style
graphing-calculator-heading-surfaces = Surfaces
graphing-calculator-heading-table-regression-model-structure = Regression model structure
graphing-calculator-heading-trig = Trig Functions
graphing-calculator-heading-visual-parameters-bar-heights = Bar Heights
graphing-calculator-heading-visual-parameters-bin-alignment = Bin Alignment
graphing-calculator-heading-visual-parameters-display-properties = Display Properties
graphing-calculator-heading-visual-parameters-x-values = X Values
graphing-calculator-label-adaptive-peel-warning = This graph has many transparent layers, which may result in degraded performance or visual innacuracies.
graphing-calculator-label-add-base-case = add base case:
graphing-calculator-label-add-depressed-image-tooltip = Add Depressed Image
graphing-calculator-label-add-hovered-image-tooltip = Add Hovered Image
graphing-calculator-label-add-item-tooltip = Add Item
graphing-calculator-label-add-slider = add slider:
graphing-calculator-label-angle-tooltip = Angle
graphing-calculator-label-animation-properties-tooltip = Animation Properties
graphing-calculator-label-audio-trace-curve = Curve
graphing-calculator-label-audio-trace-need-screen-reader = Your Screen Reader needs to be on to hear these.
graphing-calculator-label-audio-trace-point = Point
graphing-calculator-label-audio-trace-speed = Speed
graphing-calculator-label-audio-trace-volume = Volume
graphing-calculator-label-axes = Axes
graphing-calculator-label-cdf-maximum = Max:
graphing-calculator-label-cdf-minimum = Min:
graphing-calculator-label-change-depressed-image-tooltip = Change Depressed Image
graphing-calculator-label-change-hovered-image-tooltip = Change Hovered Image
graphing-calculator-label-convert-to-table-tooltip = Convert to Table
graphing-calculator-label-create-table = Create Table
graphing-calculator-label-depressed = Depressed
graphing-calculator-label-disable-graph-interactions = Disable Graph Interactions
graphing-calculator-label-disable-zoom = Disable zooming
graphing-calculator-label-display-properties = Local Display Preferences
graphing-calculator-label-drop-image-here = Drop Image Here
graphing-calculator-label-duplicate-expression-tooltip = Duplicate
graphing-calculator-label-edit-graph-bounds = Graph Bounds
graphing-calculator-label-edit-list-tooltip = Edit List
graphing-calculator-label-evaluation-list = { $count } element list
graphing-calculator-label-expression-delete-tooltip = Delete
graphing-calculator-label-expression-lowercase = expression
graphing-calculator-label-extend-to-3d = Extend to 3D
graphing-calculator-label-folder-lowercase = folder
graphing-calculator-label-geometry-dilation-by-point = Dilate at <parent1/> by <parent2/>
graphing-calculator-label-geometry-move-to-folder-placeholder = Folder name
graphing-calculator-label-geometry-reflection-over-point = Reflect over <parent1/>
graphing-calculator-label-geometry-rotation-around-point-by-angle = Rotate around <parent1/> by <parent2/>
graphing-calculator-label-geometry-tools = Geometry Tools
graphing-calculator-label-geometry-tools-dropdown-menu-angle = Angle tools
graphing-calculator-label-geometry-tools-dropdown-menu-circle = Circle tools
graphing-calculator-label-geometry-tools-dropdown-menu-line = Line tools
graphing-calculator-label-geometry-tools-dropdown-menu-point = Point tools
graphing-calculator-label-geometry-tools-dropdown-menu-polygon = Polygon tools
graphing-calculator-label-geometry-tools-dropdown-menu-selection = Selection tools
graphing-calculator-label-geometry-tools-dropdown-menu-transformation = Transformation tools
graphing-calculator-label-geometry-tools-open-dropdown-menu-transformation = Open { $item } menu
graphing-calculator-label-geometry-translation-by-two-points = Translate from <parent1/> to <parent2/>
graphing-calculator-label-geometry-translation-by-vector = Translate by <parent1/>
graphing-calculator-label-hide-expression-list-tooltip = Hide Expression List
graphing-calculator-label-hide-keypad = Hide Keypad
graphing-calculator-label-hovered = Hovered
graphing-calculator-label-image-angle = Angle:
graphing-calculator-label-image-center = Center:
graphing-calculator-label-image-height = Height:
graphing-calculator-label-image-lowercase = image
graphing-calculator-label-image-opacity = Opacity:
graphing-calculator-label-image-width = Width:
graphing-calculator-label-label-size-tooltip = Label Scale Factor
graphing-calculator-label-line-thickness-3d-tooltip = Line Thickness
graphing-calculator-label-line-thickness-tooltip = Line Thickness (px)
graphing-calculator-label-list-index = Use <1>index</1> to reference the clicked index in the list.
graphing-calculator-label-lock-expression-tooltip = Prevent Editing
graphing-calculator-label-more-viewport-options = More Options
graphing-calculator-label-note-lowercase = note
graphing-calculator-label-opacity-tooltip = Opacity (0 to 1)
graphing-calculator-label-open-graph-tooltip = Open Graph
graphing-calculator-label-open-graph-with-shortcut-tooltip = Open Graph (CTRL+O)
graphing-calculator-label-poi-unknown-coordinates = unknown coordinates
graphing-calculator-label-point-size-3d-tooltip = Point Size
graphing-calculator-label-point-size-tooltip = Point Size (px)
graphing-calculator-label-powered-by = powered by
graphing-calculator-label-randomize-tooltip = Randomize
graphing-calculator-label-recent-transformations = Recent Transformations
graphing-calculator-label-recenter = Center Origin
graphing-calculator-label-redo-tooltip = Redo
graphing-calculator-label-redo-with-shortcut-tooltip = Redo (CTRL+Y)
graphing-calculator-label-reference-count =
{ $count ->
[one] (1 reference)
*[other] ({ $count } references)
}
graphing-calculator-label-reference-count-in-folder =
{ $count ->
[one] (1 reference in folder)
*[other] ({ $count } references in folder)
}
graphing-calculator-label-regression-log-mode-help-tooltip = Log mode help
graphing-calculator-label-regression-parameters-not-exact = Parameters might not be exact. Click to learn more.
graphing-calculator-label-regression-what-is-rmse-tooltip = What is RMSE? Click to learn more.
graphing-calculator-label-regression-why-is-negative-tooltip = Why is this negative? Click to learn more.
graphing-calculator-label-remove-depressed-image = Remove depressed image
graphing-calculator-label-remove-hovered-image = Remove hovered image
graphing-calculator-label-rename = rename
graphing-calculator-label-resolution-tooltip = 3D Grid Sample Resolution
graphing-calculator-label-search-expressions = Search this graph
graphing-calculator-label-settings-3d-perspective-distortion-ratio = Perspective Distortion Ratio
graphing-calculator-label-settings-3d-perspective-max = Most distortion (Perspective view)
graphing-calculator-label-settings-3d-perspective-min = No distortion (Orthographic view)
graphing-calculator-label-settings-all-axes = All axes:
graphing-calculator-label-settings-arrows = Arrows
graphing-calculator-label-settings-axis-labels-3d = Labels
graphing-calculator-label-settings-axis-numbers = Axis Numbers
graphing-calculator-label-settings-complex-mode = Complex Mode
graphing-calculator-label-settings-domain-plane = XY plane
graphing-calculator-label-settings-grid = Grid
graphing-calculator-label-settings-hidden-objects = Reveal { $count } hidden objects
graphing-calculator-label-settings-lock-viewport = Lock Viewport
graphing-calculator-label-settings-minor-gridlines = Minor Gridlines
graphing-calculator-label-settings-numbers-3d = Numbers
graphing-calculator-label-settings-one-quadrant = One Quadrant
graphing-calculator-label-settings-reverse-contrast = Reverse contrast
graphing-calculator-label-settings-six-key-braille = Six Key Braille Input
graphing-calculator-label-settings-step = Step:
graphing-calculator-label-settings-translucent-surfaces = Translucent surfaces
graphing-calculator-label-settings-x-axis = X-Axis
graphing-calculator-label-settings-y-axis = Y-Axis
graphing-calculator-label-show-keypad = Show Keypad
graphing-calculator-label-slider-disabled-while-ticker-playing = Sliders are disabled while the ticker is running.
graphing-calculator-label-slider-step = Step:
graphing-calculator-label-stats-first-quartile = Q1
graphing-calculator-label-stats-maximum = Max
graphing-calculator-label-stats-median = Median
graphing-calculator-label-stats-minimum = Min
graphing-calculator-label-stats-third-quartile = Q3
graphing-calculator-label-table-lowercase = table
graphing-calculator-label-table-regression-type-cubic = Cubic Regression
graphing-calculator-label-table-regression-type-exponential = Exponential Regression
graphing-calculator-label-table-regression-type-linear = Linear Regression
graphing-calculator-label-table-regression-type-logarithmic = Logarithmic Regression
graphing-calculator-label-table-regression-type-logistic = Logistic Regression
graphing-calculator-label-table-regression-type-power = Power Regression
graphing-calculator-label-table-regression-type-quadratic = Quadratic Regression
graphing-calculator-label-table-regression-type-quartic = Quartic Regression
graphing-calculator-label-table-regression-type-sinusoidal = Sinusoidal Regression
graphing-calculator-label-ticker-close = cancel
graphing-calculator-label-ticker-help-tooltip = On slow computers, this might run slower. Use local variable "dt" to capture the actual update speed.
graphing-calculator-label-ticker-lowercase = ticker
graphing-calculator-label-ticker-min-step = Min Step Time
graphing-calculator-label-ticker-pause = pause
graphing-calculator-label-ticker-play = play
graphing-calculator-label-tooltip-geometry-settings = Geometry Settings
graphing-calculator-label-tooltip-graph-settings = Graph Settings
graphing-calculator-label-tooltip-open-graph = Open Graph
graphing-calculator-label-tooltip-reset = Reset
graphing-calculator-label-tooltip-show-list = Show List
graphing-calculator-label-tooltip-viewport-default = Default Viewport
graphing-calculator-label-tooltip-zoom-default-orientation = Default Orientation
graphing-calculator-label-tooltip-zoom-in = Zoom In
graphing-calculator-label-tooltip-zoom-out = Zoom Out
graphing-calculator-label-tooltip-zoom-xy-orientation = XY Orientation
graphing-calculator-label-undo-tooltip = Undo
graphing-calculator-label-undo-with-shortcut-tooltip = Undo (CTRL+Z)
graphing-calculator-label-unlock-expression-tooltip = Allow Editing
graphing-calculator-label-update-on-click = On click:
graphing-calculator-label-update-to-new-behavior = Update to new behavior
graphing-calculator-link-edit-on-desmos = edit graph on
graphing-calculator-link-learn-more = Learn more.
graphing-calculator-link-view-braille-examples = View examples
graphing-calculator-narration-3d-graphpaper-label = three-dimensional graph paper
graphing-calculator-narration-3d-orientation-options-label = Orientation
graphing-calculator-narration-3d-rotate-down = Tilt forward.
graphing-calculator-narration-3d-rotate-left = Rotate left.
graphing-calculator-narration-3d-rotate-right = Rotate right.
graphing-calculator-narration-3d-rotate-up = Tilt backward.
graphing-calculator-narration-3d-rotation-speed = Speed { $speed } \xB0 per second
graphing-calculator-narration-3d-rotation-stopped = Stopped.
graphing-calculator-narration-add-base-case-prompt =
{ $count ->
[one] Add 1 base case
*[other] Add { $count } base cases
}
graphing-calculator-narration-add-expression = Add expression
graphing-calculator-narration-add-folder = Add folder
graphing-calculator-narration-add-image = Add image
graphing-calculator-narration-add-item-menu = Add Item Menu
graphing-calculator-narration-add-note = Add note
graphing-calculator-narration-add-slider-prompt = Add slider for { $vars }
graphing-calculator-narration-add-table = Add table
graphing-calculator-narration-add-ticker = Add Ticker
graphing-calculator-narration-all-folders-collapsed = all folders collapsed
graphing-calculator-narration-all-folders-expanded = all folders expanded
graphing-calculator-narration-audio-instructions-enter-audio-trace-mac = Press OPTION+T for audio trace.
graphing-calculator-narration-audio-instructions-enter-audio-trace-windows = Press ALT+T for audio trace.
graphing-calculator-narration-audio-trace-branch-not-found = Branch { $branch } does not exist.
graphing-calculator-narration-audio-trace-cannot-change-slider-value = Unable to adjust slider
graphing-calculator-narration-audio-trace-description-branch-count = Branches: { $branches }.
graphing-calculator-narration-audio-trace-description-color = Color: { $color }.
graphing-calculator-narration-audio-trace-description-multiple-extrema = { $count } extrema.
graphing-calculator-narration-audio-trace-description-multiple-intercepts = { $count } intercepts.
graphing-calculator-narration-audio-trace-description-multiple-intersections = { $count } intersections.
graphing-calculator-narration-audio-trace-description-multiple-labels = { $count } point labels.
graphing-calculator-narration-audio-trace-description-multiple-roots = { $count } zero crossings.
graphing-calculator-narration-audio-trace-description-no-curve-selected = No curve selected.
graphing-calculator-narration-audio-trace-description-one-extremum = 1 extremum.
graphing-calculator-narration-audio-trace-description-one-intercept = 1 intercept.
graphing-calculator-narration-audio-trace-description-one-intersection = 1 intersection.
graphing-calculator-narration-audio-trace-description-one-label = 1 point label.
graphing-calculator-narration-audio-trace-description-one-root = 1 zero crossing.
graphing-calculator-narration-audio-trace-description-shading-above = Shading above.
graphing-calculator-narration-audio-trace-description-shading-below = Shading below.
graphing-calculator-narration-audio-trace-description-shading-in-regions = Shading in regions.
graphing-calculator-narration-audio-trace-description-shading-left = Shading on the left.
graphing-calculator-narration-audio-trace-description-shading-right = Shading on the right.
graphing-calculator-narration-audio-trace-description-visible-grid = Grid lines are visible.
graphing-calculator-narration-audio-trace-description-visible-x-axis = X axis visible.
graphing-calculator-narration-audio-trace-description-visible-x-axis-and-label = X axis visible and is labeled { $label }.
graphing-calculator-narration-audio-trace-description-visible-x-axis-range = X axis visible from { $xmin } to { $xmax }.
graphing-calculator-narration-audio-trace-description-visible-x-axis-range-and-label = X axis visible from { $xmin } to { $xmax } and is labeled { $label }.
graphing-calculator-narration-audio-trace-description-visible-xyz-axis-range = X Y and Z axes visible from { $xmin } to { $xmax }.
graphing-calculator-narration-audio-trace-description-visible-y-axis = Y axis visible.
graphing-calculator-narration-audio-trace-description-visible-y-axis-and-label = Y axis visible and is labeled { $label }.
graphing-calculator-narration-audio-trace-description-visible-y-axis-range = Y axis visible from { $ymin } to { $ymax }.
graphing-calculator-narration-audio-trace-description-visible-y-axis-range-and-label = Y axis visible from { $ymin } to { $ymax } and is labeled { $label }.
graphing-calculator-narration-audio-trace-description-visible-z-axis = Z axis visible.
graphing-calculator-narration-audio-trace-description-visible-z-axis-and-label = Z axis visible and is labeled { $label }.
graphing-calculator-narration-audio-trace-description-visible-z-axis-range = Z axis visible from { $zmin } to { $zmax }.
graphing-calculator-narration-audio-trace-description-visible-z-axis-range-and-label = Z axis visible from { $zmin } to { $zmax } and is labeled { $label }.
graphing-calculator-narration-audio-trace-expression-with-column = Expression { $index } column { $column }
graphing-calculator-narration-audio-trace-first-point = First point
graphing-calculator-narration-audio-trace-first-slider = First slider.
graphing-calculator-narration-audio-trace-instructions-disable-mac = To disable audio trace, press OPTION+T.
graphing-calculator-narration-audio-trace-instructions-disable-windows = To disable audio trace, press ALT+T.
graphing-calculator-narration-audio-trace-instructions-expression-navigation-mac = To move between expressions, press COMMAND+Up-Arrow or COMMAND+Down-Arrow.
graphing-calculator-narration-audio-trace-instructions-expression-navigation-windows = To move between expressions, press ALT+Up-Arrow or ALT+Down-Arrow.
graphing-calculator-narration-audio-trace-instructions-hear-graph = To hear the graph, press H.
graphing-calculator-narration-audio-trace-instructions-use-arrow-keys = Use Arrow keys to navigate.
graphing-calculator-narration-audio-trace-last-point = Last point
graphing-calculator-narration-audio-trace-last-slider = Last slider.
graphing-calculator-narration-audio-trace-multiple-sliders-paused = { $sliders } animating sliders were paused.
graphing-calculator-narration-audio-trace-no-more-pois = No more points of interest
graphing-calculator-narration-audio-trace-no-sliders-paused = No animating sliders were paused.
graphing-calculator-narration-audio-trace-one-slider-paused = One animating slider was paused.
graphing-calculator-narration-audio-trace-playback-speed = Graph playback speed { $speed }
graphing-calculator-narration-audio-trace-poi-count = Points of interest, { $x }.
graphing-calculator-narration-audio-trace-point-type-definition = Definition
graphing-calculator-narration-audio-trace-point-type-extremum = Extremum
graphing-calculator-narration-audio-trace-point-type-intercept = Intercept
graphing-calculator-narration-audio-trace-point-type-intersection = Intersection
graphing-calculator-narration-audio-trace-point-type-intersection-with-curves = Intersection with { $curves }
graphing-calculator-narration-audio-trace-point-type-label = Label
graphing-calculator-narration-audio-trace-point-type-not-a-poi = Not a P O I
graphing-calculator-narration-audio-trace-point-type-root = Zero
graphing-calculator-narration-audio-trace-point-type-trace = Trace
graphing-calculator-narration-audio-trace-property-branch-number = Branch { $branch }.
graphing-calculator-narration-audio-trace-property-type-before-coordinates = { $type } at
graphing-calculator-narration-audio-trace-property-x = X: { $x }.
graphing-calculator-narration-audio-trace-property-y = Y: { $y }.
graphing-calculator-narration-audio-trace-slider-value-unknown = Unable to determine slider value
graphing-calculator-narration-audio-trace-sound-effects-disabled = Sound effects have been disabled.
graphing-calculator-narration-audio-trace-traceable-curves =
{ $sketchCount ->
[one] 1 audio traceable curve.
*[other] { $sketchCount } audio traceable curves.
}
graphing-calculator-narration-audio-trace-tracing-different-expression = Tracing { $expression }.
graphing-calculator-narration-audio-trace-unable-to-play = Unable to play audio.
graphing-calculator-narration-audio-trace-unable-to-trace-this-expression = Unable to audio trace this expression.
graphing-calculator-narration-audio-trace-unsupported-expression = { $expression } cannot be audio traced.
graphing-calculator-narration-audio-trace-volume = Volume { $volume } percent
graphing-calculator-narration-cdf-maximum = Max
graphing-calculator-narration-cdf-minimum = Min
graphing-calculator-narration-click-action = Click Action
graphing-calculator-narration-clickable-image-options = Clickable Image Options
graphing-calculator-narration-collapse = Collapse
graphing-calculator-narration-collapse-folder-index = Collapse Folder { $index }
graphing-calculator-narration-collapse-folder-title = Collapse { $folder } folder
graphing-calculator-narration-color-picker-custom-colors-label = Custom
graphing-calculator-narration-color-picker-label = Color Picker
graphing-calculator-narration-color-picker-standard-colors-label = Standard
graphing-calculator-narration-color-unknown = unknown
graphing-calculator-narration-computed-cell-role-description = computed cell
graphing-calculator-narration-configure-toolbar = Geometry Toolbar Configuration
graphing-calculator-narration-create-table = Create Table
graphing-calculator-narration-create-table-expression = Create Table from Expression { $index }
graphing-calculator-narration-create-table-secret-expression = Create Table from Secret Expression { $index }
graphing-calculator-narration-delete = Delete
graphing-calculator-narration-delete-expression = Delete Expression { $index }
graphing-calculator-narration-delete-folder-index = Delete Folder { $index }
graphing-calculator-narration-delete-folder-title = Delete { $folder } folder
graphing-calculator-narration-delete-image = Delete Image { $index }
graphing-calculator-narration-delete-secret-expression = Delete Secret Expression { $index }
graphing-calculator-narration-delete-table = Delete Table { $index }
graphing-calculator-narration-delete-text = Delete Note { $index }
graphing-calculator-narration-describe = Unknown object
graphing-calculator-narration-describe-expression = Expression { $index }
graphing-calculator-narration-describe-folder-index = Folder { $index }
graphing-calculator-narration-describe-folder-title = { $folder } folder
graphing-calculator-narration-describe-image = Image { $index }
graphing-calculator-narration-describe-secret-expression = Secret expression { $index }
graphing-calculator-narration-describe-table = Table { $index }
graphing-calculator-narration-describe-text = Note { $index }
graphing-calculator-narration-description-collapsed-folder = Collapsed Folder
graphing-calculator-narration-description-collapsed-readonly-folder = Collapsed Locked Folder
graphing-calculator-narration-description-collapsed-secret-folder = Collapsed Secret Folder
graphing-calculator-narration-description-collapsed-secret-readonly-folder = Collapsed Secret Locked Folder
graphing-calculator-narration-description-folder = Folder
graphing-calculator-narration-description-hidden-collapsed-folder = Hidden Collapsed Folder
graphing-calculator-narration-description-hidden-collapsed-readonly-folder = Hidden Collapsed Locked Folder
graphing-calculator-narration-description-hidden-collapsed-secret-folder = Hidden Collapsed Secret Folder
graphing-calculator-narration-description-hidden-collapsed-secret-readonly-folder = Hidden Collapsed Secret Locked Folder
graphing-calculator-narration-description-hidden-folder = Hidden Folder
graphing-calculator-narration-description-hidden-readonly-folder = Hidden Locked Folder
graphing-calculator-narration-description-hidden-secret-folder = Hidden Secret Folder
graphing-calculator-narration-description-hidden-secret-readonly-folder = Hidden Secret Locked Folder
graphing-calculator-narration-description-readonly-folder = Locked Folder
graphing-calculator-narration-description-secret-folder = Secret Folder
graphing-calculator-narration-description-secret-readonly-folder = Secret Locked Folder
graphing-calculator-narration-dist-tab-distributions = Distributions
graphing-calculator-narration-dist-tab-visualizations = Visualizations
graphing-calculator-narration-domain3d-maximum = domain { $term } Maximum:
graphing-calculator-narration-domain3d-minimum = domain { $term } Minimum:
graphing-calculator-narration-drag-mode-x = X
graphing-calculator-narration-drag-mode-xy = X and Y
graphing-calculator-narration-drag-mode-y = Y
graphing-calculator-narration-draggable-image-off-screen-prompt = { " " }not completely visible on screen
graphing-calculator-narration-duplicate = Duplicate
graphing-calculator-narration-duplicate-expression = Duplicate Expression { $index }
graphing-calculator-narration-duplicate-folder-index = Duplicate Folder { $index }
graphing-calculator-narration-duplicate-folder-title = Duplicate { $folder } folder
graphing-calculator-narration-duplicate-image = Duplicate Image { $index }
graphing-calculator-narration-duplicate-secret-expression = Duplicate Secret Expression { $index }
graphing-calculator-narration-duplicate-table = Duplicate Table { $index }
graphing-calculator-narration-duplicate-text = Duplicate Note { $index }
graphing-calculator-narration-edit-action = Edit Action
graphing-calculator-narration-edit-expression-list = Edit Expression List
graphing-calculator-narration-edit-folder-title = Edit Folder { $index } Title
graphing-calculator-narration-edit-graph-on-desmos = Edit graph on Desmos
graphing-calculator-narration-edit-image-title = Edit Image { $index } Title
graphing-calculator-narration-edit-list-mode-off = Edit list mode off.
graphing-calculator-narration-edit-list-mode-on = Edit list mode on.
graphing-calculator-narration-edit-on-desmos = Edit graph on Desmos
graphing-calculator-narration-edit-slider-variable-limits = Edit { $variable } Limits
graphing-calculator-narration-edit-text-title = Note { $index }
graphing-calculator-narration-edit-title = Edit Title
graphing-calculator-narration-editable-label-mode = Editable label mode
graphing-calculator-narration-editable-point-label = Editable point label
graphing-calculator-narration-expand = Expand
graphing-calculator-narration-expand-folder-index = Expand Folder { $index }
graphing-calculator-narration-expand-folder-title = Expand { $folder } folder
graphing-calculator-narration-expression-audio-trace-mac = To audio trace, press OPTION+T.
graphing-calculator-narration-expression-audio-trace-windows = To audio trace, press ALT+T.
graphing-calculator-narration-expression-bar = Expression Bar
graphing-calculator-narration-expression-evaluation-has-graph = Has graph.
graphing-calculator-narration-expression-evaluation-has-graph-and-regression = Has graph and regression. To access statistics, press Tab.
graphing-calculator-narration-expression-evaluation-has-regression = Has regression. To access statistics, press Tab.
graphing-calculator-narration-expression-evaluation-is-distribution = is distribution.
graphing-calculator-narration-expression-evaluation-is-t-test = is T test. To access statistics, press Tab.
graphing-calculator-narration-expression-hidden-label = Hidden { $label }
graphing-calculator-narration-expression-index-table = Expression { $index } table
graphing-calculator-narration-expression-label = Label
graphing-calculator-narration-expression-tone-muted = Muted tone.
graphing-calculator-narration-expression-tone-unmuted = Unmuted tone.
graphing-calculator-narration-fill-opacity = Fill Opacity:
graphing-calculator-narration-fill-visible = Fill visible
graphing-calculator-narration-folder-collapsed = folder collapsed
graphing-calculator-narration-folder-expanded = folder expanded
graphing-calculator-narration-folder-has-items = { $folder } has { $count } items
graphing-calculator-narration-functions = Functions
graphing-calculator-narration-geometry-added-object-type = Added { $type }.
graphing-calculator-narration-geometry-added-object-type-and-point = Added { $type } and 1 point.
graphing-calculator-narration-geometry-added-object-type-and-points = Added { $type } and { $points } points.
graphing-calculator-narration-geometry-added-points = Added { $points } points.
graphing-calculator-narration-geometry-angle-of-polygon = { $itemDescription } of { $parent }
graphing-calculator-narration-geometry-angle-through-points = { $itemDescription } through { $parent1 }, { $parent2 }, and { $parent3 }
graphing-calculator-narration-geometry-anglebisector-of-item = { $bisectorDescription }, bisector of { $item }
graphing-calculator-narration-geometry-arc-through-points = Arc { $index } starting at { $start }. Middle at { $middle }. End at { $end }.
graphing-calculator-narration-geometry-circle-with-center-and-radius = Circle { $index } with center at { $center } and radius { $radius }.
graphing-calculator-narration-geometry-construct-menu = Construct
graphing-calculator-narration-geometry-construction-icon-label = Token Count
graphing-calculator-narration-geometry-construction-role-description = construction
graphing-calculator-narration-geometry-dilated-item = dilated { $item }
graphing-calculator-narration-geometry-edge-of-polygon = Edge { $polygonEdge } of { $item }
graphing-calculator-narration-geometry-glider-on-item = { $gliderDescription } on { $item }
graphing-calculator-narration-geometry-glider-with-assignment = Glider { $assignment }
graphing-calculator-narration-geometry-hidden-construction-description = Hidden { $description }
graphing-calculator-narration-geometry-hidden-line = Hidden line
graphing-calculator-narration-geometry-hidden-parallel = Hidden parrallel
graphing-calculator-narration-geometry-hidden-perpendicular = Hidden perpendicular
graphing-calculator-narration-geometry-hidden-ray = Hidden ray
graphing-calculator-narration-geometry-hidden-segment = Hidden segment
graphing-calculator-narration-geometry-hidden-vector = Hidden vector
graphing-calculator-narration-geometry-intersection-of-items = { $intersectionDescription } of { $item1 } and { $item2 }
graphing-calculator-narration-geometry-intersection-with-assignment = Intersection { $assignment }
graphing-calculator-narration-geometry-item-at-coordinates-to-coordinates = { $itemDescription } from { $x1 } { $y1 } to { $x2 } { $y2 }
graphing-calculator-narration-geometry-label-options = Label Options
graphing-calculator-narration-geometry-labeled-angle = Angle { $label }
graphing-calculator-narration-geometry-labeled-directed-angle = Directed Angle { $label }
graphing-calculator-narration-geometry-list-of-angles = List of { $count } angles
graphing-calculator-narration-geometry-list-of-any = List of { $count } unknown objects
graphing-calculator-narration-geometry-list-of-arcs = List of { $count } arcs
graphing-calculator-narration-geometry-list-of-circles = List of { $count } circles
graphing-calculator-narration-geometry-list-of-directed-angles = List of { $count } directed angles
graphing-calculator-narration-geometry-list-of-lines = List of { $count } lines
graphing-calculator-narration-geometry-list-of-points = List of { $count } points
graphing-calculator-narration-geometry-list-of-polygons = List of { $count } polygons
graphing-calculator-narration-geometry-list-of-rays = List of { $count } rays
graphing-calculator-narration-geometry-list-of-segments = List of { $count } segments
graphing-calculator-narration-geometry-midpoint-of-item = { $midpointDescription } of { $item }
graphing-calculator-narration-geometry-midpoint-with-assignment = Midpoint { $assignment }
graphing-calculator-narration-geometry-moved-to-coordinates = Moved to x: { $x }, y: { $y }.
graphing-calculator-narration-geometry-near-item = Near { $item }.
graphing-calculator-narration-geometry-no-tool-inputs = No inputs exist
graphing-calculator-narration-geometry-nothing-selected = Nothing selected.
graphing-calculator-narration-geometry-parallel-to-line-through-point = Parallel line { $index } to { $line }, passing through { $point }
graphing-calculator-narration-geometry-perpendicular-to-line-through-point = Perpedicular line { $index } to { $line }, passing through { $point }
graphing-calculator-narration-geometry-point-with-assignment = Point { $assignment }
graphing-calculator-narration-geometry-polygon-through-vertices = { $itemDescription } through vertices { $vertices }
graphing-calculator-narration-geometry-reflected-item = reflected { $item }
graphing-calculator-narration-geometry-rotated-item = rotated { $item }
graphing-calculator-narration-geometry-segment-length = { $segmentDescription } with length { $length }
graphing-calculator-narration-geometry-segment-with-assignment = Segment { $assignment }
graphing-calculator-narration-geometry-straight-from-item-to-item = { $straightType } from { $start } to { $end }
graphing-calculator-narration-geometry-straight-index-of-item = { $straightType } { $index } of { $item }
graphing-calculator-narration-geometry-style-menu = Style
graphing-calculator-narration-geometry-token-navigator-depth = Depth: { $depth }
graphing-calculator-narration-geometry-token-navigator-label = Token Navigator
graphing-calculator-narration-geometry-tool-cancelled = Cancelled.
graphing-calculator-narration-geometry-tool-disabled = The { $tool } tool is disabled.
graphing-calculator-narration-geometry-transformed-item = transformed { $item }
graphing-calculator-narration-geometry-translated-item = translated { $item }
graphing-calculator-narration-geometry-unable-to-move = Unable to move.
graphing-calculator-narration-geometry-unlabeled-angle = Angle { $index }
graphing-calculator-narration-geometry-unlabeled-angle-with-measurement = { $measurementText } Angle { $index }
graphing-calculator-narration-geometry-unlabeled-arc = Arc { $index }
graphing-calculator-narration-geometry-unlabeled-circle = Circle { $index }
graphing-calculator-narration-geometry-unlabeled-decagon = Decagon { $index }
graphing-calculator-narration-geometry-unlabeled-directed-angle = Directed Angle { $index }
graphing-calculator-narration-geometry-unlabeled-directed-angle-with-measurement = { $measurementText } Directed Angle { $index }
graphing-calculator-narration-geometry-unlabeled-glider = Glider { $index }
graphing-calculator-narration-geometry-unlabeled-heptagon = Heptagon { $index }
graphing-calculator-narration-geometry-unlabeled-hexagon = Hexagon { $index }
graphing-calculator-narration-geometry-unlabeled-intersection = Intersection { $index }
graphing-calculator-narration-geometry-unlabeled-line = Line
graphing-calculator-narration-geometry-unlabeled-line-with-index = Line { $index }
graphing-calculator-narration-geometry-unlabeled-midpoint = Midpoint { $index }
graphing-calculator-narration-geometry-unlabeled-nonagon = Nonagon { $index }
graphing-calculator-narration-geometry-unlabeled-octagon = Octagon { $index }
graphing-calculator-narration-geometry-unlabeled-parallel = Parallel line
graphing-calculator-narration-geometry-unlabeled-parallel-with-index = Parallel line { $index }
graphing-calculator-narration-geometry-unlabeled-pentagon = Pentagon { $index }
graphing-calculator-narration-geometry-unlabeled-perpendicular = Perpendicular line
graphing-calculator-narration-geometry-unlabeled-perpendicular-with-index = Perpendicular line { $index }
graphing-calculator-narration-geometry-unlabeled-point = Point { $index }
graphing-calculator-narration-geometry-unlabeled-polygon = Polygon { $index } with { $sideCount } sides
graphing-calculator-narration-geometry-unlabeled-quadrilateral = Quadrilateral { $index }
graphing-calculator-narration-geometry-unlabeled-ray = Ray
graphing-calculator-narration-geometry-unlabeled-ray-with-index = Ray { $index }
graphing-calculator-narration-geometry-unlabeled-segment = Segment
graphing-calculator-narration-geometry-unlabeled-segment-with-index = Segment { $index }
graphing-calculator-narration-geometry-unlabeled-triangle = Triangle { $index }
graphing-calculator-narration-geometry-unlabeled-vector = Vector
graphing-calculator-narration-geometry-unlabeled-vector-with-index = Vector { $index }
graphing-calculator-narration-graph-settings-controls = Graph Settings Controls
graphing-calculator-narration-graphpaper-label = graph paper
graphing-calculator-narration-hide = Hide
graphing-calculator-narration-hide-animation-properties = Hide Animation Properties
graphing-calculator-narration-hide-expression = Hide Expression { $index }
graphing-calculator-narration-hide-expression-list = Hide expression list
graphing-calculator-narration-hide-folder-index = Hide Folder { $index }
graphing-calculator-narration-hide-folder-title = Hide { $folder } folder
graphing-calculator-narration-hide-image = Hide Image { $index }
graphing-calculator-narration-hide-options = Hide Options
graphing-calculator-narration-hide-options-expression = Hide Options for Expression { $index }
graphing-calculator-narration-hide-options-image = Hide Options for Image { $index }
graphing-calculator-narration-hide-options-secret-expression = Hide Options for Secret Expression { $index }
graphing-calculator-narration-hide-secret-expression = Hide Secret Expression { $index }
graphing-calculator-narration-hide-table = Hide Table { $index }
graphing-calculator-narration-hide-table-column = Hide Column
graphing-calculator-narration-hide-table-regression = Hide Regression
graphing-calculator-narration-hide-text = Hide Note { $index }
graphing-calculator-narration-image-styles = Styles
graphing-calculator-narration-item-at-coordinates = { $itemDescription } at { $coordinates }
graphing-calculator-narration-item-hidden = Item hidden.
graphing-calculator-narration-item-visible = Item visible.
graphing-calculator-narration-item-with-list-index = index { $listIndex } of { $item }
graphing-calculator-narration-items-deleted =
{ $count ->
[one] { $count } item deleted.
*[other] { $count } items deleted.
}
graphing-calculator-narration-keypad-hidden = Keypad hidden
graphing-calculator-narration-keypad-key-next-curve = Next Curve
graphing-calculator-narration-keypad-key-next-poi = Next Point of Interest
graphing-calculator-narration-keypad-key-next-point = Next Point
graphing-calculator-narration-keypad-key-previous-curve = Previous Curve
graphing-calculator-narration-keypad-key-previous-poi = Previous Point of Interest
graphing-calculator-narration-keypad-key-previous-point = Previous Point
graphing-calculator-narration-keypad-key-speed-down = Speed Down
graphing-calculator-narration-keypad-key-speed-up = Speed Up
graphing-calculator-narration-keypad-key-volume-down = Volume Down
graphing-calculator-narration-keypad-key-volume-up = Volume Up
graphing-calculator-narration-keypad-visible = Keypad visible
graphing-calculator-narration-label-angle = Label Angle:
graphing-calculator-narration-label-menu = Label
graphing-calculator-narration-label-size = Label Size:
graphing-calculator-narration-label-text = Label Text
graphing-calculator-narration-label-visible = Label visible
graphing-calculator-narration-line-opacity = Line Opacity:
graphing-calculator-narration-line-style-dashed = Dashed
graphing-calculator-narration-line-style-dotted = Dotted
graphing-calculator-narration-line-style-solid = Solid
graphing-calculator-narration-lines-visible = Lines visible
graphing-calculator-narration-locked-items-not-deleted =
{ $count ->
[one] { $count } locked item could not be deleted.
*[other] { $count } locked items could not be deleted.
}
graphing-calculator-narration-main-desmos-geometry = Desmos Geometry
graphing-calculator-narration-main-desmos-graphing-calculator = Desmos Graphing Calculator
graphing-calculator-narration-make-clickable = make clickable
graphing-calculator-narration-menu-drag-enabled = Drag Enabled
graphing-calculator-narration-movable-point-off-screen-prompt = { " " }not visible on screen
graphing-calculator-narration-movable-point-prefix = Point
graphing-calculator-narration-movable-point-suffix-usage-instructions = { " " }is movable. Press Arrows or Shift+Arrows to adjust.
graphing-calculator-narration-mute = Mute
graphing-calculator-narration-mute-all = Mute all
graphing-calculator-narration-mute-expression = Mute Expression { $index }
graphing-calculator-narration-mute-secret-expression = Mute Secret Expression { $index }
graphing-calculator-narration-muted = Muted
graphing-calculator-narration-no-geometry-tools-available = No geometry tools available.
graphing-calculator-narration-no-playing-tones = No currently playing tones
graphing-calculator-narration-no-tone-expressions = No tones in this graph
graphing-calculator-narration-options-menu = Options Menu
graphing-calculator-narration-options-menu-closed = Options menu closed.
graphing-calculator-narration-options-menu-open = Options menu open.
graphing-calculator-narration-pause-variable-animation = Pause { $variable } Animation
graphing-calculator-narration-play-variable-animation = Play { $variable } Animation
graphing-calculator-narration-poi-graph-point = Point
graphing-calculator-narration-point-size = Point Size:
graphing-calculator-narration-point-style-cross = Cross
graphing-calculator-narration-point-style-open = Open
graphing-calculator-narration-point-style-point = Point
graphing-calculator-narration-points-visible = Points visible
graphing-calculator-narration-powered-by-desmos = Powered by Desmos
graphing-calculator-narration-redo = Redo
graphing-calculator-narration-rename = Rename
graphing-calculator-narration-rename-expression = Rename in Expression { $index }
graphing-calculator-narration-rename-secret-expression = Rename in Secret Expression { $index }
graphing-calculator-narration-rename-table = Rename in Table { $index }
graphing-calculator-narration-run-action-icon = Run Action
graphing-calculator-narration-settings-all-axes-max = Max for x, y, and z
graphing-calculator-narration-settings-all-axes-min = Min for x, y, and z
graphing-calculator-narration-settings-angle = Angle Settings
graphing-calculator-narration-settings-cartesian-grid = Cartesian Grid
graphing-calculator-narration-settings-polar-grid = Polar Grid
graphing-calculator-narration-settings-show-both = Show Both
graphing-calculator-narration-settings-show-positive = Show Positive
graphing-calculator-narration-settings-x-axis-label-placeholder = e.g. \u201Cx\u201D
graphing-calculator-narration-settings-x-axis-max = X Axis Maximum:{ " " }
graphing-calculator-narration-settings-x-axis-min = X Axis Minimum:{ " " }
graphing-calculator-narration-settings-x-axis-step = X Axis Step Size:{ " " }
graphing-calculator-narration-settings-y-axis-label-placeholder = e.g. \u201Cy\u201D
graphing-calculator-narration-settings-y-axis-max = Y Axis Maximum:{ " " }
graphing-calculator-narration-settings-y-axis-min = Y Axis Minimum:{ " " }
graphing-calculator-narration-settings-y-axis-step = Y Axis Step Size:{ " " }
graphing-calculator-narration-settings-z-axis-max = Z Axis Maximum:{ " " }
graphing-calculator-narration-settings-z-axis-min = Z Axis Minimum:{ " " }
graphing-calculator-narration-show = Show
graphing-calculator-narration-show-animation-properties = Show Animation Properties
graphing-calculator-narration-show-expression = Show Expression { $index }
graphing-calculator-narration-show-folder-index = Show Folder { $index }
graphing-calculator-narration-show-folder-title = Show { $folder } folder
graphing-calculator-narration-show-image = Show Image { $index }
graphing-calculator-narration-show-options = Show Options
graphing-calculator-narration-show-options-expression = Show Options for Expression { $index }
graphing-calculator-narration-show-options-image = Show Options for Image { $index }
graphing-calculator-narration-show-options-secret-expression = Show Options for Secret Expression { $index }
graphing-calculator-narration-show-secret-expression = Show Secret Expression { $index }
graphing-calculator-narration-show-table = Show Table { $index }
graphing-calculator-narration-show-table-column = Show Column
graphing-calculator-narration-show-table-regression = Show Regression
graphing-calculator-narration-show-text = Show Note { $index }
graphing-calculator-narration-slider-animate-faster = Animate Faster
graphing-calculator-narration-slider-animate-slower = Animate Slower
graphing-calculator-narration-slider-animating-at-speed = Animating at { $speed }x
graphing-calculator-narration-slider-loop-forwards-and-backwards = Loop forwards and backwards
graphing-calculator-narration-slider-maximum = Slider Maximum:
graphing-calculator-narration-slider-minimum = Slider Minimum:
graphing-calculator-narration-slider-play-indefinitely = Play indefinitely
graphing-calculator-narration-slider-play-once = Play once
graphing-calculator-narration-slider-repeat-one-direction = Repeat in one direction
graphing-calculator-narration-slider-step = Slider Step Size:
graphing-calculator-narration-slider-trace-no-sliders = No sliders to trace.
graphing-calculator-narration-slider-trace-off = Slider trace off.
graphing-calculator-narration-slider-trace-on = Slider trace on.
graphing-calculator-narration-slider-variable-paused = { $variable } paused
graphing-calculator-narration-slider-variable-playing = { $variable } playing
graphing-calculator-narration-slider-variable-restarted = { $variable } restarted
graphing-calculator-narration-slow-compute = Is taking a long time to compute.
graphing-calculator-narration-slow-evaluation = Is taking a long time to evaluate.
graphing-calculator-narration-style-menu = Style Menu
graphing-calculator-narration-surface-opacity = Surface Opacity:
graphing-calculator-narration-surfaces-visible = Surfaces visible
graphing-calculator-narration-table-no-column-header = No column header
graphing-calculator-narration-table-regression-equation = Regression Equation
graphing-calculator-narration-tick-action = Tick Action
graphing-calculator-narration-toggle-audio-trace = Toggle Audio Trace
graphing-calculator-narration-toggle-letters = Toggle Letters
graphing-calculator-narration-unable-to-add-expression = Unable to add expression
graphing-calculator-narration-unable-to-add-note = Unable to add note
graphing-calculator-narration-unable-to-add-table = Unable to add table
graphing-calculator-narration-unable-to-add-table-regression = Unable to add regression
graphing-calculator-narration-undo = Undo
graphing-calculator-narration-unmute = Unmute
graphing-calculator-narration-unmute-all = Unmute all
graphing-calculator-narration-unmute-expression = Unmute Expression { $index }
graphing-calculator-narration-unmute-secret-expression = Unmute Secret Expression { $index }
graphing-calculator-narration-unmuted = Unmuted
graphing-calculator-narration-viewport-default = Graph viewport default
graphing-calculator-narration-viewport-pan-down = Graph pan down
graphing-calculator-narration-viewport-pan-left = Graph pan left
graphing-calculator-narration-viewport-pan-right = Graph pan right
graphing-calculator-narration-viewport-pan-up = Graph pan up
graphing-calculator-narration-viewport-updated = Graph viewport updated.
graphing-calculator-narration-viewport-zoom-3d-default = Graph set to default orientation
graphing-calculator-narration-viewport-zoom-3d-xy = Graph set to X Y orientation
graphing-calculator-narration-viewport-zoom-in = Graph zoom in
graphing-calculator-narration-viewport-zoom-out = Graph zoom out
graphing-calculator-narration-viewport-zoom-recenter = Graph recenter
graphing-calculator-narration-viewport-zoom-square = Graph zoom square
graphing-calculator-narration-visual-parameters-height = Height
graphing-calculator-narration-visual-parameters-offset = Offset
graphing-calculator-narration-visual-parameters-width = Width
graphing-calculator-narration-x-percentage-coordinate = { $x } percent from left.
graphing-calculator-narration-y-percentage-coordinate = { $y } percent from top.
graphing-calculator-narration-zoom-options-label = Zoom
graphing-calculator-text-add-screen-reader-label-placeholder = Add screen reader label
graphing-calculator-text-arrow-mode-both = Both
graphing-calculator-text-arrow-mode-default = Default
graphing-calculator-text-arrow-mode-none = None
graphing-calculator-text-arrow-mode-positive = Positive
graphing-calculator-text-audio-trace-no-implicit-support = Sorry, but I can't trace implicit curves yet.
graphing-calculator-text-audio-trace-no-parametric-support = Sorry, but I can't trace parametric curves yet.
graphing-calculator-text-audio-trace-no-polar-support = Sorry, but I can't trace polar curves yet.
graphing-calculator-text-audio-trace-off = Audio trace off.
graphing-calculator-text-audio-trace-on = Audio trace on.
graphing-calculator-text-color-black = black
graphing-calculator-text-color-blue = blue
graphing-calculator-text-color-cyan = cyan
graphing-calculator-text-color-dark-blue = dark blue
graphing-calculator-text-color-dark-cyan = dark cyan
graphing-calculator-text-color-dark-gray = dark gray
graphing-calculator-text-color-dark-green = dark green
graphing-calculator-text-color-dark-indigo = dark indigo
graphing-calculator-text-color-dark-lime = dark lime
graphing-calculator-text-color-dark-magenta = dark magenta
graphing-calculator-text-color-dark-orange = dark orange
graphing-calculator-text-color-dark-pink = dark pink
graphing-calculator-text-color-dark-red = dark red
graphing-calculator-text-color-dark-teal = dark teal
graphing-calculator-text-color-dark-violet = dark violet
graphing-calculator-text-color-dark-yellow = dark yellow
graphing-calculator-text-color-gray = gray
graphing-calculator-text-color-green = green
graphing-calculator-text-color-indigo = indigo
graphing-calculator-text-color-light-blue = light blue
graphing-calculator-text-color-light-cyan = light cyan
graphing-calculator-text-color-light-gray = light gray
graphing-calculator-text-color-light-green = light green
graphing-calculator-text-color-light-indigo = light indigo
graphing-calculator-text-color-light-lime = light lime
graphing-calculator-text-color-light-magenta = light magenta
graphing-calculator-text-color-light-orange = light orange
graphing-calculator-text-color-light-pink = light pink
graphing-calculator-text-color-light-red = light red
graphing-calculator-text-color-light-teal = light teal
graphing-calculator-text-color-light-violet = light violet
graphing-calculator-text-color-light-yellow = light yellow
graphing-calculator-text-color-lime = lime
graphing-calculator-text-color-magenta = magenta
graphing-calculator-text-color-orange = orange
graphing-calculator-text-color-pink = pink
graphing-calculator-text-color-purple = purple
graphing-calculator-text-color-red = red
graphing-calculator-text-color-teal = teal
graphing-calculator-text-color-unknown = color unknown
graphing-calculator-text-color-violet = violet
graphing-calculator-text-color-white = white
graphing-calculator-text-color-yellow = yellow
graphing-calculator-text-complex-plotting-note = Note: complex values will be plotted as (real, imag)
graphing-calculator-text-enter-pareneter = Enter the { $param }.
graphing-calculator-text-export-snapshot = Export a snapshot to the expression list
graphing-calculator-text-folder-placeholder = Untitled folder
graphing-calculator-text-geometry-arrow-mode = Arrow Mode: { $mode }
graphing-calculator-text-geometry-delete-selected-objects =
{ $count ->
[one] Delete 1 object
*[other] Delete { $count } objects
}
graphing-calculator-text-geometry-delete-selected-unlocked-objects =
{ $count ->
[one] Delete 1 unlocked object
*[other] Delete { $count } unlocked objects
}
graphing-calculator-text-geometry-glider = glider
graphing-calculator-text-geometry-hide-objects = Hide
graphing-calculator-text-geometry-intersection = intersection
graphing-calculator-text-geometry-move-to-expression-list-message = Move to expression list
graphing-calculator-text-geometry-multi-select-more-dropdown = More
graphing-calculator-text-geometry-no-constructed-objects = No constructed objects yet.
graphing-calculator-text-geometry-select-hint = Select a { $type }
graphing-calculator-text-geometry-selected-objects =
{ $count ->
[one] 1 object selected
*[other] { $count } objects selected
}
graphing-calculator-text-geometry-show-objects = Show
graphing-calculator-text-geometry-tool-angle-bisector-display-name = Angle bisector
graphing-calculator-text-geometry-tool-angle-bisector-hint-angle = Choose an angle to bisect
graphing-calculator-text-geometry-tool-angle-display-name = Angle
graphing-calculator-text-geometry-tool-angle-hint-1 = Choose a starting point
graphing-calculator-text-geometry-tool-angle-hint-2 = Choose a vertex point
graphing-calculator-text-geometry-tool-angle-hint-3 = Choose an endpoint
graphing-calculator-text-geometry-tool-angles-hint-1 = Choose a starting point or a polygon
graphing-calculator-text-geometry-tool-arc-display-name = Arc
graphing-calculator-text-geometry-tool-arc-hint-1 = Choose a point (start)
graphing-calculator-text-geometry-tool-arc-hint-2 = Choose a point (middle)
graphing-calculator-text-geometry-tool-arc-hint-3 = Choose a point (end)
graphing-calculator-text-geometry-tool-box-selection-display-name = Box Select
graphing-calculator-text-geometry-tool-circle-by-length-display-name = Circle by length
graphing-calculator-text-geometry-tool-circle-display-name = Circle
graphing-calculator-text-geometry-tool-circle-hint-center = Choose a point (center)
graphing-calculator-text-geometry-tool-circle-hint-radius = Choose a point (radius)
graphing-calculator-text-geometry-tool-compass-hint-center = Choose a center point
graphing-calculator-text-geometry-tool-compass-hint-segment = Choose a segment to set the radius
graphing-calculator-text-geometry-tool-dilate-display-name = Dilate
graphing-calculator-text-geometry-tool-dilation-hint-center = Choose point (center)
graphing-calculator-text-geometry-tool-dilation-hint-scale-factor = Scale factor
graphing-calculator-text-geometry-tool-directed-angle-display-name = Directed Angle
graphing-calculator-text-geometry-tool-directedangle-display-name = Directed angle
graphing-calculator-text-geometry-tool-expression-edit-display-name = Insert into current expression.
graphing-calculator-text-geometry-tool-expression-edit-generic-hint-0 = No valid inputs
graphing-calculator-text-geometry-tool-expression-edit-generic-hint-1 = Choose { $type }
graphing-calculator-text-geometry-tool-expression-edit-generic-hint-2 = Choose { $type1 } or { $type2 }
graphing-calculator-text-geometry-tool-expression-edit-generic-hint-any-object = Choose any object
graphing-calculator-text-geometry-tool-expression-edit-generic-hint-many = Choose one of the following: { $types }
graphing-calculator-text-geometry-tool-expression-edit-starting-transformation-hint = Choose an object to transform
graphing-calculator-text-geometry-tool-line-display-name = Line
graphing-calculator-text-geometry-tool-line-hint-end = Choose a 2nd point
graphing-calculator-text-geometry-tool-line-hint-start = Choose a 1st point
graphing-calculator-text-geometry-tool-midpoint-display-name = Midpoint
graphing-calculator-text-geometry-tool-midpoint-hint = Choose a segment
graphing-calculator-text-geometry-tool-parallel-display-name = Parallel
graphing-calculator-text-geometry-tool-parallel-hint-point = Choose a point to pass through
graphing-calculator-text-geometry-tool-parallel-hint-straight-line = Choose a line to be parallel to
graphing-calculator-text-geometry-tool-perpendicular-display-name = Perpendicular
graphing-calculator-text-geometry-tool-perpendicular-hint-point = Choose a point to pass through
graphing-calculator-text-geometry-tool-perpendicular-hint-straight-line = Choose a line to be perpendicular to
graphing-calculator-text-geometry-tool-point-display-name = Point
graphing-calculator-text-geometry-tool-point-hint = Select or create a point
graphing-calculator-text-geometry-tool-polygon-display-name = Polygon
graphing-calculator-text-geometry-tool-polygon-hint-finish-point = Choose another point, or click an existing point to finish
graphing-calculator-text-geometry-tool-polygon-hint-first-point = Choose a point
graphing-calculator-text-geometry-tool-polygon-hint-next-point = Choose another point
graphing-calculator-text-geometry-tool-ray-display-name = Ray
graphing-calculator-text-geometry-tool-ray-hint-end = Choose a point (direction)
graphing-calculator-text-geometry-tool-ray-hint-start = Choose a point (vertex)
graphing-calculator-text-geometry-tool-reflect-display-name = Reflect
graphing-calculator-text-geometry-tool-reflection-hint-choose-line = Choose line of reflection
graphing-calculator-text-geometry-tool-rotate-display-name = Rotate
graphing-calculator-text-geometry-tool-rotation-hint-angle = Choose angle
graphing-calculator-text-geometry-tool-rotation-hint-angle-end = Choose angle end point
graphing-calculator-text-geometry-tool-rotation-hint-angle-start = Construct or choose angle
graphing-calculator-text-geometry-tool-rotation-hint-center = Choose point (center)
graphing-calculator-text-geometry-tool-segment-display-name = Segment
graphing-calculator-text-geometry-tool-segment-hint-end = Choose another point
graphing-calculator-text-geometry-tool-segment-hint-start = Choose a point
graphing-calculator-text-geometry-tool-selection-display-name = Select
graphing-calculator-text-geometry-tool-translate-display-name = Translate
graphing-calculator-text-geometry-tool-translation-hint-from-with-vector = Choose start point or a vector
graphing-calculator-text-geometry-tool-translation-hint-to = Choose end point
graphing-calculator-text-geometry-tool-vector-copy-display-name = Copy of Vector
graphing-calculator-text-geometry-tool-vector-copy-hint-end = Choose new start point for copy
graphing-calculator-text-geometry-tool-vector-display-name = Vector
graphing-calculator-text-geometry-tool-vector-end-point-display-name = Vector End Point
graphing-calculator-text-geometry-tool-vector-hint-end = Choose end point
graphing-calculator-text-geometry-tool-vector-hint-start = Choose start point or a vector to copy
graphing-calculator-text-geometry-tool-vector-start-point-display-name = Vector Start Point
graphing-calculator-text-image-placeholder = Unnamed image
graphing-calculator-text-label-orientation-above = Above
graphing-calculator-text-label-orientation-above-left = Above Left
graphing-calculator-text-label-orientation-above-right = Above Right
graphing-calculator-text-label-orientation-below = Below
graphing-calculator-text-label-orientation-below-left = Below Left
graphing-calculator-text-label-orientation-below-right = Below Right
graphing-calculator-text-label-orientation-default = Default
graphing-calculator-text-label-orientation-left = Left
graphing-calculator-text-label-orientation-right = Right
graphing-calculator-text-loading-image = Loading image...
graphing-calculator-text-make-custom-regression = Make a custom regression model in a new line using <1>~</1>. <2>Learn how</2>.
graphing-calculator-text-note-placeholder = Empty note
graphing-calculator-text-parameter-name-binwidth = Bin Width
graphing-calculator-text-parameter-name-data = Data Set
graphing-calculator-text-parameter-name-dof = Degrees of Freedom
graphing-calculator-text-parameter-name-height = Height
graphing-calculator-text-parameter-name-max = Maximum
graphing-calculator-text-parameter-name-mean = Mean
graphing-calculator-text-parameter-name-min = Minimum
graphing-calculator-text-parameter-name-offset = Offset
graphing-calculator-text-parameter-name-probsuccess = Success Probability
graphing-calculator-text-parameter-name-stddev = Standard Deviation
graphing-calculator-text-parameter-name-trials = Trials
graphing-calculator-text-refreshable-braille-display-note = Use a refreshable Braille display, or just type Braille with a keyboard.
graphing-calculator-text-regression-potentially-inaccurate-parameters = Some parameters may be too large or small to represent accurately.
graphing-calculator-text-table-created = Table created.
graphing-calculator-text-table-creation-error = Error creating table.
graphing-calculator-text-table-more-rows = { $rowCount } more rows
graphing-calculator-text-toast-choose-one-file = You can only choose one file as a replacement
graphing-calculator-text-toast-error-importing-graph = Error importing graph. Check the URL?
graphing-calculator-text-toast-error-no-folders = Only graphs without folders can be inserted into a folder.
graphing-calculator-text-toast-expression-size-limit = Maximum expression size reached.
graphing-calculator-text-toast-graph-cleared = Graph cleared.
graphing-calculator-text-toast-graph-reset = Graph reset.
graphing-calculator-text-toast-image-upload-failed = Image upload failed.
graphing-calculator-text-toast-imported-graph = Graph imported!
graphing-calculator-text-toast-importing-graph = Importing graph...
graphing-calculator-text-toast-no-file-selected = You did not select a file
graphing-calculator-text-toast-uploading-images = Uploading images...
graphing-calculator-text-toast-zoom-to-fit = We zoomed to fit your data.
graphing-calculator-text-undefined-parameter = { $parameter } is undefined
graphing-calculator-text-view-regression-options = Regression options
graphing-calculator-text-zoom-fit = Zoom Fit
matrix-calculator-narration-keypad-key-det = Determinant
matrix-calculator-narration-keypad-key-inverse = Inverse
matrix-calculator-narration-keypad-key-rref = Reduced row echelon form
matrix-calculator-narration-keypad-key-trace = Trace
matrix-calculator-narration-keypad-key-transpose = Transpose
`;
  var Yu = class {
      constructor(e) {
        this.value = e;
      }
      valueOf() {
        return this.value;
      }
    },
    Wo = class extends Yu {
      constructor(e = "???") {
        super(e);
      }
      toString(e) {
        return `{${this.value}}`;
      }
    },
    Ms = class extends Yu {
      constructor(e, t = {}) {
        super(e), this.opts = t;
      }
      toString(e) {
        try {
          return e.memoizeIntlObject(Intl.NumberFormat, this.opts).format(
            this.value,
          );
        } catch (t) {
          return e.reportError(t), this.value.toString(10);
        }
      }
    },
    Sd = class extends Yu {
      constructor(e, t = {}) {
        super(e), this.opts = t;
      }
      toString(e) {
        try {
          return e.memoizeIntlObject(Intl.DateTimeFormat, this.opts)
            .format(this.value);
        } catch (t) {
          return e.reportError(t), new Date(this.value).toISOString();
        }
      }
    };
  var DH = 100, ate = "\u2068", ste = "\u2069";
  function lte(r, e, t) {
    if (
      t === e || t instanceof Ms && e instanceof Ms && t.value === e.value
    ) return true;
    if (e instanceof Ms && typeof t == "string") {
      let o = r.memoizeIntlObject(Intl.PluralRules, e.opts).select(
        e.value,
      );
      if (t === o) return true;
    }
    return false;
  }
  function kH(r, e, t) {
    return e[t]
      ? Eb(r, e[t].value)
      : (r.reportError(new RangeError("No default")), new Wo());
  }
  function NL(r, e) {
    let t = [], o = Object.create(null);
    for (let i of e) {
      i.type === "narg" ? o[i.name] = Jw(r, i.value) : t.push(Jw(r, i));
    }
    return { positional: t, named: o };
  }
  function Jw(r, e) {
    switch (e.type) {
      case "str":
        return e.value;
      case "num":
        return new Ms(e.value, { minimumFractionDigits: e.precision });
      case "var":
        return cte(r, e);
      case "mesg":
        return dte(r, e);
      case "term":
        return pte(r, e);
      case "func":
        return ute(r, e);
      case "select":
        return hte(r, e);
      default:
        return new Wo();
    }
  }
  function cte(r, { name: e }) {
    let t;
    if (r.params) {
      if (Object.prototype.hasOwnProperty.call(r.params, e)) {
        t = r.params[e];
      } else return new Wo(`$${e}`);
    } else if (
      r.args && Object.prototype.hasOwnProperty.call(r.args, e)
    ) t = r.args[e];
    else {return r.reportError(
        new ReferenceError(`Unknown variable: $${e}`),
      ),
        new Wo(`$${e}`);}
    if (t instanceof Yu) return t;
    switch (typeof t) {
      case "string":
        return t;
      case "number":
        return new Ms(t);
      case "object":
        if (t instanceof Date) return new Sd(t.getTime());
      default:
        return r.reportError(
          new TypeError(
            `Variable type not supported: $${e}, ${typeof t}`,
          ),
        ),
          new Wo(`$${e}`);
    }
  }
  function dte(r, { name: e, attr: t }) {
    let o = r.bundle._messages.get(e);
    if (!o) {
      return r.reportError(new ReferenceError(`Unknown message: ${e}`)),
        new Wo(e);
    }
    if (t) {
      let i = o.attributes[t];
      return i
        ? Eb(r, i)
        : (r.reportError(new ReferenceError(`Unknown attribute: ${t}`)),
          new Wo(`${e}.${t}`));
    }
    return o.value
      ? Eb(r, o.value)
      : (r.reportError(new ReferenceError(`No value: ${e}`)), new Wo(e));
  }
  function pte(r, { name: e, attr: t, args: o }) {
    let i = `-${e}`, n = r.bundle._terms.get(i);
    if (!n) {
      return r.reportError(new ReferenceError(`Unknown term: ${i}`)), new Wo(i);
    }
    if (t) {
      let s = n.attributes[t];
      if (s) {
        r.params = NL(r, o).named;
        let l = Eb(r, s);
        return r.params = null, l;
      }
      return r.reportError(new ReferenceError(`Unknown attribute: ${t}`)),
        new Wo(`${i}.${t}`);
    }
    r.params = NL(r, o).named;
    let a = Eb(r, n.value);
    return r.params = null, a;
  }
  function ute(r, { name: e, args: t }) {
    let o = r.bundle._functions[e];
    if (!o) {
      return r.reportError(
        new ReferenceError(`Unknown function: ${e}()`),
      ),
        new Wo(`${e}()`);
    }
    if (typeof o != "function") {
      return r.reportError(
        new TypeError(`Function ${e}() is not callable`),
      ),
        new Wo(`${e}()`);
    }
    try {
      let i = NL(r, t);
      return o(i.positional, i.named);
    } catch (i) {
      return r.reportError(i), new Wo(`${e}()`);
    }
  }
  function hte(r, { selector: e, variants: t, star: o }) {
    let i = Jw(r, e);
    if (i instanceof Wo) return kH(r, t, o);
    for (let n of t) {
      let a = Jw(r, n.key);
      if (lte(r, i, a)) return Eb(r, n.value);
    }
    return kH(r, t, o);
  }
  function BL(r, e) {
    if (r.dirty.has(e)) {
      return r.reportError(new RangeError("Cyclic reference")), new Wo();
    }
    r.dirty.add(e);
    let t = [], o = r.bundle._useIsolating && e.length > 1;
    for (let i of e) {
      if (typeof i == "string") {
        t.push(r.bundle._transform(i));
        continue;
      }
      if (r.placeables++, r.placeables > DH) {
        throw r.dirty.delete(e),
          new RangeError(
            `Too many placeables expanded: ${r.placeables}, max allowed is ${DH}`,
          );
      }
      o && t.push(ate), t.push(Jw(r, i).toString(r)), o && t.push(ste);
    }
    return r.dirty.delete(e), t.join("");
  }
  function Eb(r, e) {
    return typeof e == "string" ? r.bundle._transform(e) : BL(r, e);
  }
  var vT = class {
    constructor(e, t, o) {
      this.dirty = new WeakSet(),
        this.params = null,
        this.placeables = 0,
        this.bundle = e,
        this.errors = t,
        this.args = o;
    }
    reportError(e) {
      if (!this.errors || !(e instanceof Error)) throw e;
      this.errors.push(e);
    }
    memoizeIntlObject(e, t) {
      let o = this.bundle._intls.get(e);
      o || (o = {}, this.bundle._intls.set(e, o));
      let i = JSON.stringify(t);
      return o[i] || (o[i] = new e(this.bundle.locales, t)), o[i];
    }
  };
  function CT(r, e) {
    let t = Object.create(null);
    for (let [o, i] of Object.entries(r)) {
      e.includes(o) && (t[o] = i.valueOf());
    }
    return t;
  }
  var _H = [
    "unitDisplay",
    "currencyDisplay",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
  ];
  function AH(r, e) {
    let t = r[0];
    if (t instanceof Wo) return new Wo(`NUMBER(${t.valueOf()})`);
    if (t instanceof Ms) {
      return new Ms(t.valueOf(), { ...t.opts, ...CT(e, _H) });
    }
    if (t instanceof Sd) return new Ms(t.valueOf(), { ...CT(e, _H) });
    throw new TypeError("Invalid argument to NUMBER");
  }
  var IH = [
    "dateStyle",
    "timeStyle",
    "fractionalSecondDigits",
    "dayPeriod",
    "hour12",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
  ];
  function MH(r, e) {
    let t = r[0];
    if (t instanceof Wo) return new Wo(`DATETIME(${t.valueOf()})`);
    if (t instanceof Sd) {
      return new Sd(t.valueOf(), { ...t.opts, ...CT(e, IH) });
    }
    if (t instanceof Ms) return new Sd(t.valueOf(), { ...CT(e, IH) });
    throw new TypeError("Invalid argument to DATETIME");
  }
  var GH = new Map();
  function LH(r) {
    let e = Array.isArray(r) ? r.join(" ") : r, t = GH.get(e);
    return t === void 0 && (t = new Map(), GH.set(e, t)), t;
  }
  var Qw = class {
    constructor(
      e,
      { functions: t, useIsolating: o = true, transform: i = (n) => n } = {},
    ) {
      this._terms = new Map(),
        this._messages = new Map(),
        this.locales = Array.isArray(e) ? e : [e],
        this._functions = { NUMBER: AH, DATETIME: MH, ...t },
        this._useIsolating = o,
        this._transform = i,
        this._intls = LH(e);
    }
    hasMessage(e) {
      return this._messages.has(e);
    }
    getMessage(e) {
      return this._messages.get(e);
    }
    addResource(e, { allowOverrides: t = false } = {}) {
      let o = [];
      for (let i = 0; i < e.body.length; i++) {
        let n = e.body[i];
        if (n.id.startsWith("-")) {
          if (t === false && this._terms.has(n.id)) {
            o.push(
              new Error(
                `Attempt to override an existing term: "${n.id}"`,
              ),
            );
            continue;
          }
          this._terms.set(n.id, n);
        } else {
          if (t === false && this._messages.has(n.id)) {
            o.push(
              new Error(
                `Attempt to override an existing message: "${n.id}"`,
              ),
            );
            continue;
          }
          this._messages.set(n.id, n);
        }
      }
      return o;
    }
    formatPattern(e, t = null, o = null) {
      if (typeof e == "string") return this._transform(e);
      let i = new vT(this, o, t);
      try {
        return BL(i, e).toString(i);
      } catch (n) {
        if (i.errors && n instanceof Error) {
          return i.errors.push(n), new Wo().toString(i);
        }
        throw n;
      }
    }
  };
  var UL = /^(-?[a-zA-Z][\w-]*) *= */gm,
    PH = /\.([a-zA-Z][\w-]*) *= */y,
    gte = /\*?\[/y,
    zL = /(-?[0-9]+(?:\.([0-9]+))?)/y,
    mte = /([a-zA-Z][\w-]*)/y,
    VH = /([$-])?([a-zA-Z][\w-]*)(?:\.([a-zA-Z][\w-]*))?/y,
    fte = /^[A-Z][A-Z0-9_-]*$/,
    ST = /([^{}\n\r]+)/y,
    bte = /([^\\"\n\r]*)/y,
    OH = /\\([\\"])/y,
    RH = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{6})/y,
    yte = /^\n+/,
    FH = / +$/,
    xte = / *\r?\n/g,
    wte = /( *)$/,
    vte = /{\s*/y,
    NH = /\s*}/y,
    Cte = /\[\s*/y,
    Ste = /\s*] */y,
    Ete = /\s*\(\s*/y,
    Tte = /\s*->\s*/y,
    Dte = /\s*:\s*/y,
    kte = /\s*,?\s*/y,
    _te = /\s+/y,
    Tb = class {
      constructor(e) {
        this.body = [], UL.lastIndex = 0;
        let t = 0;
        for (;;) {
          let O = UL.exec(e);
          if (O === null) break;
          t = UL.lastIndex;
          try {
            this.body.push(l(O[1]));
          } catch (U) {
            if (U instanceof SyntaxError) continue;
            throw U;
          }
        }
        function o(O) {
          return O.lastIndex = t, O.test(e);
        }
        function i(O, U) {
          if (e[t] === O) return t++, true;
          if (U) throw new U(`Expected ${O}`);
          return false;
        }
        function n(O, U) {
          if (o(O)) return t = O.lastIndex, true;
          if (U) throw new U(`Expected ${O.toString()}`);
          return false;
        }
        function a(O) {
          O.lastIndex = t;
          let U = O.exec(e);
          if (U === null) {
            throw new SyntaxError(`Expected ${O.toString()}`);
          }
          return t = O.lastIndex, U;
        }
        function s(O) {
          return a(O)[1];
        }
        function l(O) {
          let U = d(), z = c();
          if (U === null && Object.keys(z).length === 0) {
            throw new SyntaxError("Expected message value or attributes");
          }
          return { id: O, value: U, attributes: z };
        }
        function c() {
          let O = Object.create(null);
          for (; o(PH);) {
            let U = s(PH), z = d();
            if (z === null) {
              throw new SyntaxError("Expected attribute value");
            }
            O[U] = z;
          }
          return O;
        }
        function d() {
          let O;
          if (o(ST) && (O = s(ST)), e[t] === "{" || e[t] === "}") {
            return p(O ? [O] : [], 1 / 0);
          }
          let U = _();
          return U
            ? O
              ? p([O, U], U.length)
              : (U.value = A(U.value, yte), p([U], U.length))
            : O
            ? A(O, FH)
            : null;
        }
        function p(O = [], U) {
          for (;;) {
            if (o(ST)) {
              O.push(s(ST));
              continue;
            }
            if (e[t] === "{") {
              O.push(h());
              continue;
            }
            if (e[t] === "}") {
              throw new SyntaxError("Unbalanced closing brace");
            }
            let V = _();
            if (V) {
              O.push(V), U = Math.min(U, V.length);
              continue;
            }
            break;
          }
          let z = O.length - 1, x = O[z];
          typeof x == "string" && (O[z] = A(x, FH));
          let L = [];
          for (let V of O) {
            V instanceof ET && (V = V.value.slice(0, V.value.length - U)),
              V && L.push(V);
          }
          return L;
        }
        function h() {
          n(vte, SyntaxError);
          let O = u();
          if (n(NH)) return O;
          if (n(Tte)) {
            let U = C();
            return n(NH, SyntaxError), { type: "select", selector: O, ...U };
          }
          throw new SyntaxError("Unclosed placeable");
        }
        function u() {
          if (e[t] === "{") return h();
          if (o(VH)) {
            let [, O, U, z = null] = a(VH);
            if (O === "$") return { type: "var", name: U };
            if (n(Ete)) {
              let x = f();
              if (O === "-") {
                return { type: "term", name: U, attr: z, args: x };
              }
              if (fte.test(U)) return { type: "func", name: U, args: x };
              throw new SyntaxError(
                "Function names must be all upper-case",
              );
            }
            return O === "-"
              ? { type: "term", name: U, attr: z, args: [] }
              : { type: "mesg", name: U, attr: z };
          }
          return v();
        }
        function f() {
          let O = [];
          for (;;) {
            switch (e[t]) {
              case ")":
                return t++, O;
              case void 0:
                throw new SyntaxError("Unclosed argument list");
            }
            O.push(y()), n(kte);
          }
        }
        function y() {
          let O = u();
          return O.type !== "mesg"
            ? O
            : n(Dte)
            ? { type: "narg", name: O.name, value: v() }
            : O;
        }
        function C() {
          let O = [], U = 0, z;
          for (; o(gte);) {
            i("*") && (z = U);
            let x = E(), L = d();
            if (L === null) {
              throw new SyntaxError("Expected variant value");
            }
            O[U++] = { key: x, value: L };
          }
          if (U === 0) return null;
          if (z === void 0) {
            throw new SyntaxError("Expected default variant");
          }
          return { variants: O, star: z };
        }
        function E() {
          n(Cte, SyntaxError);
          let O;
          return o(zL) ? O = w() : O = { type: "str", value: s(mte) },
            n(Ste, SyntaxError),
            O;
        }
        function v() {
          if (o(zL)) return w();
          if (e[t] === '"') return S();
          throw new SyntaxError("Invalid expression");
        }
        function w() {
          let [, O, U = ""] = a(zL), z = U.length;
          return { type: "num", value: parseFloat(O), precision: z };
        }
        function S() {
          i('"', SyntaxError);
          let O = "";
          for (;;) {
            if (O += s(bte), e[t] === "\\") {
              O += k();
              continue;
            }
            if (i('"')) return { type: "str", value: O };
            throw new SyntaxError("Unclosed string literal");
          }
        }
        function k() {
          if (o(OH)) return s(OH);
          if (o(RH)) {
            let [, O, U] = a(RH), z = parseInt(O || U, 16);
            return z <= 55295 || 57344 <= z
              ? String.fromCodePoint(z)
              : "\uFFFD";
          }
          throw new SyntaxError("Unknown escape sequence");
        }
        function _() {
          let O = t;
          switch (n(_te), e[t]) {
            case ".":
            case "[":
            case "*":
            case "}":
            case void 0:
              return false;
            case "{":
              return P(e.slice(O, t));
          }
          return e[t - 1] === " " ? P(e.slice(O, t)) : false;
        }
        function A(O, U) {
          return O.replace(U, "");
        }
        function P(O) {
          let U = O.replace(
              xte,
              `
`,
            ),
            z = wte.exec(O)[1].length;
          return new ET(U, z);
        }
      }
    },
    ET = class {
      constructor(e, t) {
        this.value = e, this.length = t;
      }
    };
  var Ate = [
      "ae",
      "ar",
      "arc",
      "bcc",
      "bqi",
      "ckb",
      "dv",
      "fa",
      "glk",
      "he",
      "ku",
      "mzn",
      "nqo",
      "pnb",
      "ps",
      "sd",
      "ug",
      "ur",
      "yi",
    ],
    TT = class r {
      constructor(e, t) {
        this.bundles = e;
        this.onError = t;
      }
      static fromSources(e, t, o) {
        let i = [];
        for (let { lang: n, source: a } of e) {
          let s = n.split("-")[0],
            l = new Qw(n, { ...o, useIsolating: Ate.indexOf(s) >= 0 });
          l.addResource(new Tb(a), { allowOverrides: false }),
            l.addResource(
              new Tb(`
l10n-internal-date-day-month-year = {DATETIME($d, month: "short", day: "numeric", year: "numeric")}
l10n-internal-date-day-month = {DATETIME($d, month: "short", day: "numeric")}
l10n-internal-time = {DATETIME($d, minute: "numeric", hour: "numeric")}
`),
              { allowOverrides: false },
            ),
            i.push(l);
        }
        return new r(i, t);
      }
      format(e, t) {
        for (let o of this.bundles) {
          if (!o.hasMessage(e)) continue;
          let i = o.getMessage(e);
          if (!(i != null && i.value)) return;
          let n = [],
            a = o.formatPattern(
              i.value,
              this.coerceNumericVariables(t),
              n,
            );
          for (let s of n) {
            this.onError(
              `Error formatting ${e} for locale ${o.locales.join(",")}: ${s}`,
            );
          }
          return a;
        }
        this.onError(
          `Couldn't find message for key ${e} for locales ${
            this.getLocales().join(",")
          }`,
        );
      }
      formatDate(e, t) {
        return t.showYear
          ? this.format("l10n-internal-date-day-month-year", { d: e })
          : this.format("l10n-internal-date-day-month", { d: e });
      }
      formatTime(e) {
        let t = this.format("l10n-internal-time", { d: e });
        return this.getLocales()[0] === "en"
          ? t == null ? void 0 : t.toLowerCase()
          : t;
      }
      hasTranslation(e, t) {
        for (let o of this.bundles) {
          if (o.locales.indexOf(t) >= 0) return o.hasMessage(e);
        }
        return false;
      }
      coerceNumericVariables(e) {
        let t = {};
        for (let o in e) {
          let i = e[o];
          __dcg_shared_module_exports__["sa"](i)
            ? t[o] = i.value
            : typeof i == "number"
            ? t[o] = `${i}`
            : t[o] = i;
        }
        return t;
      }
      getLocales() {
        return this.bundles.reduce((e, t) => e.concat(t.locales), []);
      }
    };
  var DT = "",
    qL = {},
    BH = {},
    HL = {},
    Mte = ["ar", "hy-AM", "hi", "tr", "xx-XX"];
  function kT(r) {
    DT = r || "";
  }
  function KL(r) {
    for (let e in r) delete HL[e], BH[e] = r[e];
  }
  function WL(r, e) {
    let t = e != null ? e : DT;
    return zH(t).hasTranslation(r, t);
  }
  function Gs(r, e) {
    if (e) {
      for (let t in e) {
        e.hasOwnProperty(t) && (r = r.split("__" + t + "__").join(e[t]));
      }
    }
    return r;
  }
  function Ls(r, e, t) {
    return UH(r, e != null ? e : {}, t != null ? t : DT);
  }
  function Ip(r) {
    return function (t, o) {
      return UH(t, o != null ? o : {}, r());
    };
  }
  function Gte(r) {
    let e = {};
    for (let t in r) {
      let o = r[t];
      o !== void 0 && (e[t] = o);
    }
    return e;
  }
  function UH(r, e, t) {
    let i = zH(t).format(r, Gte(e));
    return i == null
      ? (__dcg_shared_module_exports__["qe"].warn(
        `Could not format string ${r}`,
      ),
        "")
      : i;
  }
  function zH(r) {
    let e = HL[r];
    if (!e) {
      qL[r] || (qL[r] = Xw([r]));
      let t = [];
      for (let i of qL[r]) {
        let n = BH[i];
        n && t.push({ lang: i, source: n });
      }
      let o = {};
      r === "xx-XX" &&
      (o.transform = (i) => i.replace(/[a-z]/gi, "\u2666")),
        e = HL[r] = TT.fromSources(
          [...t, { lang: "en", source: TH }],
          (i) => {
            __dcg_shared_module_exports__["qe"].warn(i);
          },
          o,
        );
    }
    return e;
  }
  function Zw() {
    return DT;
  }
  function $L(r) {
    return Vg.hasOwnProperty(r) ||
      __dcg_shared_module_exports__["l"](Mte, r);
  }
  function Fl(r, e) {
    if (r == null) return "";
    if (typeof r == "string") return r;
    if (typeof r == "number") return "" + r;
    let t = r.vars, o;
    if (t) {
      o = {};
      for (let i in t) {
        if (!t.hasOwnProperty(i)) continue;
        let n = t[i];
        __dcg_shared_module_exports__["sa"](n) ? o[i] = n : o[i] = Fl(n, e);
      }
    }
    return Ls(r.key, o, e);
  }
  var Db = typeof desmosLocaleData == "object" ? desmosLocaleData : {};
  function jL() {
    let r = Xw([Du("lang"), navigator.userLanguage, navigator.language]);
    for (let e = 0; e < r.length; e++) {
      let t = r[e];
      if ($L(t)) return t;
    }
    return "en";
  }
  async function qH(r) {
    if (Db[r] || r === "en" || r === "xx-XX") return kT(r), true;
    if (!$L(r)) {
      let e = r.indexOf("-") !== -1 ? r.split("-")[0] : r;
      for (let t in Vg) {
        if (e === t.split("-")[0] && Vg[t].useAsRoot) {
          r = t;
          break;
        }
      }
    }
    try {
      let e = await EH(`/api/v1/calculator/language/${r}.ftl`);
      return Db[r] = e[r], KL(Db), kT(r), true;
    } catch (e) {
      throw e.status === 404 &&
        __dcg_shared_module_exports__["qe"].warn(
          r + " is not an available language.",
        ),
        e;
    }
  }
  function _T(r) {
    if (Db[r]) return true;
    let e = Xw([r]);
    for (let t of e) if (Db[t]) return true;
    return false;
  }
  KL(Db);
  kT(jL());
  var Lte = /`[^`]*`/g,
    Pte = /^[\+\-]?[\d]*(\.\d+)?$/,
    Vte = (r) => {
      if (r != null) {
        let e = r.match(/`/g);
        return (e != null && e.length || 0) % 2 == 0;
      }
      return true;
    },
    Ote = (r) => {
      let e = [];
      if (r == null || r.length == 0) return e;
      let t = 0, o;
      for (; o = Lte.exec(r);) {
        let n = r.slice(t, o.index);
        n.length > 0 &&
        e.push({ from: t, to: o.index, type: "text", text: n }),
          t = o.index + o[0].length,
          e.push({
            from: o.index,
            to: t,
            type: "math",
            text: o[0].slice(1, -1),
          });
      }
      let i = r.slice(t);
      return i.length > 0 &&
        e.push({ from: t, to: r.length, type: "text", text: i }),
        e;
    },
    HH = gc.StaticMath(document.createElement("span"));
  function ei(r) {
    let e = "", t = [];
    Vte(r)
      ? t = Ote(r)
      : t = [{ from: 0, to: r.length, type: "text", text: r }];
    for (let o of t) e += o.type === "text" ? o.text : Ao(o.text);
    return e;
  }
  function Ao(r) {
    let e = "";
    return Pte.test(r)
      ? (/^\+/.test(r)
        ? (e = "positive ", r = r.slice(1))
        : /^\-/.test(r) && (e = "negative ", r = r.slice(1)),
        e += r.replace(
          /(\.)([0-9]+)/g,
          (t, o, i) => o + i.split("").join(" ").trim(),
        ))
      : (HH.latex(r), e = HH.mathspeak().trim()),
      e;
  }
  function IT(r, e, t) {
    let o = r.formula.typed_constant_value;
    if (o != null && o.value) {
      if (__dcg_shared_module_exports__["Ob"](o)) {
        return `${
          Fl(
            __dcg_shared_module_exports__["prettyPrint"](o.valueType),
            e.getLanguage(),
          )
        }. ${
          e.s("shared-calculator-label-list-of-count-items-suffix", {
            count: o.value.length,
          })
        }`;
      }
      if (__dcg_shared_module_exports__["isGeometryType"](o.valueType)) {
        return Fl(
          __dcg_shared_module_exports__["prettyPrint"](o.valueType),
          e.getLanguage(),
        );
      }
      switch (o.valueType) {
        case __dcg_shared_module_exports__["Number"]:
          return Ao(
            __dcg_shared_module_exports__["truncatedLatexLabel"](+o.value, t),
          );
        case __dcg_shared_module_exports__["Complex"]:
          return Ao(
            __dcg_shared_module_exports__["complexNumberLabel"](o.value, t),
          );
        case __dcg_shared_module_exports__["RGBColor"]:
          return md(e, r.formula.rgb_value);
        case __dcg_shared_module_exports__["Bool"]:
        case __dcg_shared_module_exports__["Restriction"]:
        case __dcg_shared_module_exports__["SeedType"]:
        case __dcg_shared_module_exports__["Point3D"]:
        case __dcg_shared_module_exports__["Segment3D"]:
        case __dcg_shared_module_exports__["Triangle3D"]:
        case __dcg_shared_module_exports__["Sphere3D"]:
        case __dcg_shared_module_exports__["Vector3D"]:
        case __dcg_shared_module_exports__["Tone"]:
        case __dcg_shared_module_exports__["Action"]:
        case __dcg_shared_module_exports__["ErrorType"]:
        case __dcg_shared_module_exports__["EmptyList"]:
          return Fl(
            __dcg_shared_module_exports__["prettyPrint"](o.valueType),
            e.getLanguage(),
          );
        default:
          let i = o.valueType;
          throw new Error(`Unexpected valueType ${i}`);
      }
    }
  }
  var an = 1;
  function kb(r, e) {
    let t = [], o = r.formula.geometry && r.formula.geometry.call;
    if (!o || !o.parents) return [];
    for (let i of o.parents) {
      if (i.type === "arbitrary-expression") t.push(void 0);
      else {
        let n = __dcg_shared_module_exports__["Cc"](i),
          a = e.getGeoTokenInfoFromIdentifier(n);
        t.push(a ? e.getItemModel(a.calcId) : void 0);
      }
    }
    return t;
  }
  function Ap(r, e = {}) {
    let t = r.formula.typed_constant_value.value,
      o = r.formula.typed_constant_value.valueType;
    return e.listIndex !== void 0 &&
      __dcg_shared_module_exports__["isList"](o) &&
      (o = __dcg_shared_module_exports__["elementType"](o), t = t[e.listIndex]),
      { value: t, valueType: o };
  }
  function AT(r, e, t) {
    var y, C;
    let o = t.depth ? t.depth : 0,
      i,
      n = [],
      a = (y = r.formula.geometry.call) == null ? void 0 : y.symbol,
      s = kb(r, e),
      [l, c] = s,
      { value: d } = Ap(r, t),
      [p, h] = d,
      u = (C = t.poi) == null ? void 0 : C.ariaLabel,
      f = u !== void 0 && u !== "" ? u : r.label;
    if (
      r.hidden && o >= an && typeof p == "number" && typeof h == "number"
    ) return [ll(e, p, h)];
    switch (a) {
      case "intersection":
        f
          ? i = e.s(
            "graphing-calculator-narration-geometry-intersection-with-assignment",
            { assignment: ei(f) },
          )
          : i = e.s(
            "graphing-calculator-narration-geometry-unlabeled-intersection",
            { index: r.id },
          ),
          o < an && l !== void 0 && c !== void 0
            ? n.push(
              e.s(
                "graphing-calculator-narration-geometry-intersection-of-items",
                {
                  intersectionDescription: i,
                  item1: Fo(l, e, { includeDetails: false, depth: o + 1 }),
                  item2: Fo(c, e, { includeDetails: false, depth: o + 1 }),
                },
              ),
            )
            : n.push(i);
        break;
      case "midpoint":
        f
          ? i = e.s(
            "graphing-calculator-narration-geometry-midpoint-with-assignment",
            { assignment: ei(f) },
          )
          : i = e.s(
            "graphing-calculator-narration-geometry-unlabeled-midpoint",
            { index: r.id },
          ),
          o < an && l !== void 0
            ? n.push(
              e.s(
                "graphing-calculator-narration-geometry-midpoint-of-item",
                {
                  midpointDescription: i,
                  item: Fo(l, e, { includeDetails: false, depth: o + 1 }),
                },
              ),
            )
            : n.push(i);
        break;
      case "glider":
        f
          ? i = e.s(
            "graphing-calculator-narration-geometry-glider-with-assignment",
            { assignment: ei(f) },
          )
          : i = e.s(
            "graphing-calculator-narration-geometry-unlabeled-glider",
            { index: r.id },
          ),
          o < an && l !== void 0
            ? n.push(
              e.s(
                "graphing-calculator-narration-geometry-glider-on-item",
                {
                  gliderDescription: i,
                  item: Fo(l, e, { includeDetails: false, depth: o + 1 }),
                },
              ),
            )
            : n.push(i);
        break;
      default:
        f
          ? i = e.s(
            "graphing-calculator-narration-geometry-point-with-assignment",
            { assignment: ei(f) },
          )
          : i = e.s(
            "graphing-calculator-narration-geometry-unlabeled-point",
            { index: r.id },
          ),
          t.includeDetails && typeof p == "number" && typeof h == "number"
            ? n.push(
              e.s("graphing-calculator-narration-item-at-coordinates", {
                itemDescription: i,
                coordinates: ll(e, p, h),
              }),
            )
            : n.push(i);
    }
    return n;
  }
  function KH(r, e, t) {
    var p, h;
    let o = t.depth ? t.depth : 0,
      i = [],
      n = kb(r, e),
      [a] = n,
      { value: s } = Ap(r, t),
      l = s[1],
      c = e.get2dProjection(),
      d = c && c.viewport;
    return o < an && a !== void 0 && il(a) &&
        !__dcg_shared_module_exports__["Dc"](
          (h = (p = a.formula.geometry) == null ? void 0 : p.call) == null
            ? void 0
            : h.symbol,
        ) && typeof l == "number" && d !== void 0
      ? i.push(
        e.s(
          "graphing-calculator-narration-geometry-circle-with-center-and-radius",
          {
            index: r.id,
            center: Fo(a, e, { includeDetails: false, depth: o + 1 }),
            radius: Ao(
              __dcg_shared_module_exports__["value"](l, d.xmax - d.xmin)
                .latex,
            ),
          },
        ),
      )
      : i.push(
        e.s("graphing-calculator-narration-geometry-unlabeled-circle", {
          index: r.id,
        }),
      ),
      i;
  }
  function WH(r, e, t) {
    let o = t.depth ? t.depth : 0, i = [], n = kb(r, e), [a, s, l] = n;
    return o < an && a !== void 0 && s !== void 0 && l !== void 0
      ? i.push(
        e.s("graphing-calculator-narration-geometry-arc-through-points", {
          index: r.id,
          start: Fo(a, e, { includeDetails: false, depth: o + 1 }),
          middle: Fo(s, e, { includeDetails: false, depth: o + 1 }),
          end: Fo(l, e, { includeDetails: false, depth: o + 1 }),
        }),
      )
      : i.push(
        e.s("graphing-calculator-narration-geometry-unlabeled-arc", {
          index: r.id,
        }),
      ),
      i;
  }
  function $H(r, e, t) {
    let o = t.depth ? t.depth : 0, { value: i } = Ap(r, t), n = i.length;
    if (t.polygonEdge !== void 0) {
      if (t.polygonEdge >= 0 && t.polygonEdge < i.length) {
        let l = i[t.polygonEdge], c = i[(t.polygonEdge + 1) % i.length];
        i = [l, c];
      } else return [e.s("shared-calculator-narration-item-unknown")];
    }
    let a, s = [];
    if (
      n === 3
        ? a = e.s(
          "graphing-calculator-narration-geometry-unlabeled-triangle",
          { index: r.id },
        )
        : n === 4
        ? a = e.s(
          "graphing-calculator-narration-geometry-unlabeled-quadrilateral",
          { index: r.id },
        )
        : n === 5
        ? a = e.s(
          "graphing-calculator-narration-geometry-unlabeled-pentagon",
          { index: r.id },
        )
        : n === 6
        ? a = e.s(
          "graphing-calculator-narration-geometry-unlabeled-hexagon",
          { index: r.id },
        )
        : n === 7
        ? a = e.s(
          "graphing-calculator-narration-geometry-unlabeled-heptagon",
          { index: r.id },
        )
        : n === 8
        ? a = e.s(
          "graphing-calculator-narration-geometry-unlabeled-octagon",
          { index: r.id },
        )
        : n === 9
        ? a = e.s(
          "graphing-calculator-narration-geometry-unlabeled-nonagon",
          { index: r.id },
        )
        : n === 10
        ? a = e.s(
          "graphing-calculator-narration-geometry-unlabeled-decagon",
          { index: r.id },
        )
        : a = e.s(
          "graphing-calculator-narration-geometry-unlabeled-polygon",
          { index: r.id, sideCount: n },
        ), t.polygonEdge !== void 0
    ) {
      let l = i.length > 0 ? i[0][0] : void 0,
        c = i.length > 0 ? i[0][1] : void 0,
        d = i.length > 1 ? i[1][0] : void 0,
        p = i.length > 1 ? i[1][1] : void 0;
      t.includeDetails && o < an && typeof l == "number" &&
        typeof c == "number" && typeof d == "number" &&
        typeof p == "number"
        ? s.push(
          e.s(
            "graphing-calculator-narration-geometry-item-at-coordinates-to-coordinates",
            {
              itemDescription: a,
              x1: Bl(e, l),
              y1: Ul(e, c),
              x2: Bl(e, d),
              y2: Ul(e, p),
            },
          ),
        )
        : s.push(a);
    } else if (t.includeDetails && o < an) {
      let l = [];
      if (n <= 10) {
        let c = kb(r, e).filter((d) =>
          il(d) && d.type === "expression" && !d.hidden &&
          Ap(d, t).valueType === __dcg_shared_module_exports__["Point"]
        );
        c.length === n && c.forEach((d) => {
          l.push(Fo(d, e, { includeDetails: false, depth: o + 1 }));
        });
      }
      l.length
        ? s.push(
          e.s(
            "graphing-calculator-narration-geometry-polygon-through-vertices",
            { itemDescription: a, vertices: Cd(e.getLanguage(), l) },
          ),
        )
        : s.push(a);
    } else s.push(a);
    return s;
  }
  function jH(r, e, t) {
    var _, A, P;
    let o = t.depth ? t.depth : 0,
      i = "",
      n = [],
      a = (_ = r.formula.geometry.call) == null ? void 0 : _.symbol,
      s = r.formula.geometry.listAccess,
      { value: l, valueType: c } = Ap(r, t),
      [d, p] = l[0],
      [h, u] = l[1],
      f = kb(r, e),
      y = t.listIndex || 0,
      C = FL(r, y) || r.label,
      [E, v] = f,
      w = e.get2dProjection(),
      S = w && w.viewport,
      k = E !== void 0 && v === void 0 && s !== void 0;
    if (a === "parallel") {
      o < an && E !== void 0 && v !== void 0
        ? n.push(
          e.s(
            "graphing-calculator-narration-geometry-parallel-to-line-through-point",
            {
              index: r.id,
              line: Fo(E, e, { includeDetails: false, depth: o + 1 }),
              point: Fo(v, e, { includeDetails: false, depth: o + 1 }),
            },
          ),
        )
        : r.hidden && o >= an
        ? n.push(
          e.s("graphing-calculator-narration-geometry-hidden-parallel"),
        )
        : k
        ? i = e.s(
          "graphing-calculator-narration-geometry-unlabeled-parallel",
        )
        : n.push(
          e.s(
            "graphing-calculator-narration-geometry-unlabeled-parallel-with-index",
            { index: r.id },
          ),
        );
    } else if (a === "perpendicular") {
      o < an && E !== void 0 && v !== void 0
        ? n.push(
          e.s(
            "graphing-calculator-narration-geometry-perpendicular-to-line-through-point",
            {
              index: r.id,
              line: Fo(E, e, { includeDetails: false, depth: o + 1 }),
              point: Fo(v, e, { includeDetails: false, depth: o + 1 }),
            },
          ),
        )
        : r.hidden && o >= an
        ? n.push(
          e.s(
            "graphing-calculator-narration-geometry-hidden-perpendicular",
          ),
        )
        : k
        ? i = e.s(
          "graphing-calculator-narration-geometry-unlabeled-perpendicular",
        )
        : n.push(
          e.s(
            "graphing-calculator-narration-geometry-unlabeled-perpendicular-with-index",
            { index: r.id },
          ),
        );
    } else if (c === __dcg_shared_module_exports__["Line"]) {
      r.hidden && o >= an
        ? n.push(
          e.s("graphing-calculator-narration-geometry-hidden-line"),
        )
        : k
        ? i = e.s("graphing-calculator-narration-geometry-unlabeled-line")
        : i = e.s(
          "graphing-calculator-narration-geometry-unlabeled-line-with-index",
          { index: r.id },
        );
    } else if (c === __dcg_shared_module_exports__["Ray"]) {
      if (
        r.hidden && o >= an
          ? n.push(
            e.s("graphing-calculator-narration-geometry-hidden-ray"),
          )
          : k
          ? i = e.s(
            "graphing-calculator-narration-geometry-unlabeled-ray",
          )
          : i = e.s(
            "graphing-calculator-narration-geometry-unlabeled-ray-with-index",
            { index: r.id },
          ),
          f.length === 1 &&
          (E == null ? void 0 : E.type) === "expression" &&
          (((A = E == null ? void 0 : E.formula.geometry) == null
                ? void 0
                : A.valueType) ===
              __dcg_shared_module_exports__["AngleMarker"] ||
            ((P = E == null ? void 0 : E.formula.geometry) == null
                ? void 0
                : P.valueType) ===
              __dcg_shared_module_exports__["DirectedAngleMarker"])
      ) {
        let O = Fo(E, e, { includeDetails: false, depth: o + 1 });
        i = e.s(
          "graphing-calculator-narration-geometry-anglebisector-of-item",
          { bisectorDescription: i, item: O },
        );
      }
    } else if (c === __dcg_shared_module_exports__["Segment"]) {
      if (
        r.hidden && o >= an
          ? n.push(
            e.s("graphing-calculator-narration-geometry-hidden-segment"),
          )
          : C
          ? i = e.s(
            "graphing-calculator-narration-geometry-segment-with-assignment",
            { assignment: ei(C) },
          )
          : k
          ? i = e.s(
            "graphing-calculator-narration-geometry-unlabeled-segment",
          )
          : i = e.s(
            "graphing-calculator-narration-geometry-unlabeled-segment-with-index",
            { index: r.id },
          ),
          t.includeDetails && o < an && C === "" && s === void 0 &&
          S !== void 0 && typeof d == "number" && typeof p == "number" &&
          typeof h == "number" && typeof u == "number"
      ) {
        let O = h - d, U = u - p, z = Math.sqrt(O * O + U * U);
        isNaN(z) ||
          (i = e.s(
            "graphing-calculator-narration-geometry-segment-length",
            {
              segmentDescription: i,
              length: Ao(
                __dcg_shared_module_exports__["value"](z, S.xmax - S.xmin)
                  .latex,
              ),
            },
          ));
      }
    } else {c === __dcg_shared_module_exports__["Vector"] &&
        (r.hidden && o >= an
          ? n.push(
            e.s("graphing-calculator-narration-geometry-hidden-vector"),
          )
          : k
          ? i = e.s(
            "graphing-calculator-narration-geometry-unlabeled-vector",
          )
          : i = e.s(
            "graphing-calculator-narration-geometry-unlabeled-vector-with-index",
            { index: r.id },
          ));}
    return i !== "" && o < an &&
      (E !== void 0 && v !== void 0
        ? n.push(
          e.s(
            "graphing-calculator-narration-geometry-straight-from-item-to-item",
            {
              straightType: i,
              start: Fo(E, e, { includeDetails: false, depth: o + 1 }),
              end: Fo(v, e, { includeDetails: false, depth: o + 1 }),
            },
          ),
        )
        : k &&
          n.push(
            e.s(
              "graphing-calculator-narration-geometry-straight-index-of-item",
              {
                straightType: i,
                index: s,
                item: Fo(E, e, { includeDetails: false, depth: o + 1 }),
              },
            ),
          )),
      !n.length && i && n.push(i),
      n;
  }
  function YH(r, e, t) {
    var y;
    let o = t.depth ? t.depth : 0,
      i = t.listIndex ? t.listIndex : 0,
      n = "",
      a = [],
      { valueType: s } = Ap(r, t),
      l = FL(r, i) || r.label,
      c = "",
      d = (y = e.getGrapher()) == null ? void 0 : y.getGraphSketch(r.id);
    if (d && "labels" in d) {
      let E = d.labels[i];
      E && "text" in E && (c = ei(E.text));
    }
    s === __dcg_shared_module_exports__["AngleMarker"]
      ? l
        ? n = e.s(
          "graphing-calculator-narration-geometry-labeled-angle",
          { label: ei(l) },
        )
        : c
        ? n = e.s(
          "graphing-calculator-narration-geometry-unlabeled-angle-with-measurement",
          { index: r.id, measurementText: c },
        )
        : n = e.s(
          "graphing-calculator-narration-geometry-unlabeled-angle",
          { index: r.id },
        )
      : s === __dcg_shared_module_exports__["DirectedAngleMarker"] &&
        (l
          ? n = e.s(
            "graphing-calculator-narration-geometry-labeled-directed-angle",
            { label: ei(l) },
          )
          : c
          ? n = e.s(
            "graphing-calculator-narration-geometry-unlabeled-directed-angle-with-measurement",
            { index: r.id, measurementText: c },
          )
          : n = e.s(
            "graphing-calculator-narration-geometry-unlabeled-directed-angle",
            { index: r.id },
          ));
    let p = kb(r, e), [h, u, f] = p;
    return o < an && h !== void 0 && "hidden" in h && !h.hidden &&
        u !== void 0 && "hidden" in u && !u.hidden && f !== void 0 &&
        "hidden" in f && !f.hidden
      ? a.push(
        e.s(
          "graphing-calculator-narration-geometry-angle-through-points",
          {
            itemDescription: n,
            parent1: Fo(h, e, { includeDetails: false, depth: o + 1 }),
            parent2: Fo(u, e, { includeDetails: false, depth: o + 1 }),
            parent3: Fo(f, e, { includeDetails: false, depth: o + 1 }),
          },
        ),
      )
      : o < an && h !== void 0 && "hidden" in h && !h.hidden &&
          u === void 0 && f === void 0
      ? a.push(
        e.s("graphing-calculator-narration-geometry-angle-of-polygon", {
          itemDescription: n,
          parent: Fo(h, e, { includeDetails: false, depth: o + 1 }),
        }),
      )
      : a.push(n),
      a;
  }
  function XH(r, e, t) {
    let { value: o, valueType: i } = Ap(r, t), n = [], a = o.length;
    switch (__dcg_shared_module_exports__["elementType"](i)) {
      case __dcg_shared_module_exports__["Point"]:
        n.push(
          e.s("graphing-calculator-narration-geometry-list-of-points", {
            count: a,
          }),
        );
        break;
      case __dcg_shared_module_exports__["Circle"]:
        n.push(
          e.s("graphing-calculator-narration-geometry-list-of-circles", {
            count: a,
          }),
        );
        break;
      case __dcg_shared_module_exports__["Arc"]:
        n.push(
          e.s("graphing-calculator-narration-geometry-list-of-arcs", {
            count: a,
          }),
        );
        break;
      case __dcg_shared_module_exports__["Polygon"]:
        n.push(
          e.s("graphing-calculator-narration-geometry-list-of-polygons", {
            count: a,
          }),
        );
        break;
      case __dcg_shared_module_exports__["Line"]:
        n.push(
          e.s("graphing-calculator-narration-geometry-list-of-lines", {
            count: a,
          }),
        );
        break;
      case __dcg_shared_module_exports__["Ray"]:
        n.push(
          e.s("graphing-calculator-narration-geometry-list-of-rays", {
            count: a,
          }),
        );
        break;
      case __dcg_shared_module_exports__["Segment"]:
        n.push(
          e.s("graphing-calculator-narration-geometry-list-of-segments", {
            count: a,
          }),
        );
        break;
      case __dcg_shared_module_exports__["AngleMarker"]:
        n.push(
          e.s("graphing-calculator-narration-geometry-list-of-angles", {
            count: a,
          }),
        );
        break;
      case __dcg_shared_module_exports__["DirectedAngleMarker"]:
        n.push(
          e.s(
            "graphing-calculator-narration-geometry-list-of-directed-angles",
            { count: a },
          ),
        );
        break;
      default:
        n.push(
          e.s("graphing-calculator-narration-geometry-list-of-any", {
            count: a,
          }),
        );
        break;
    }
    return n[0] = `${n[0]}.`, n;
  }
  function Rg(r, e, t, o = 3) {
    let [i, n, a, s] = r,
      { x: l, y: c } = e.mathToPixels.mapPoint({ x: i, y: n }),
      { x: d, y: p } = e.mathToPixels.mapPoint({ x: a, y: s }),
      h = Math.min(o, Math.max(e.screen.width, e.screen.height)),
      u = {
        xmin: -h,
        ymin: -h,
        xmax: e.screen.width + h,
        ymax: e.screen.height + h,
      },
      f = l - d,
      y = c - p,
      C = -f,
      E = -y,
      v = l - u.xmin,
      w = u.xmax - l,
      S = c - u.ymin,
      k = u.ymax - c,
      _ = [],
      A = [];
    if (f !== 0) {
      let V = v / f, R = w / C;
      f < 0 ? (_.push(V), A.push(R)) : (_.push(R), A.push(V));
    }
    if (y !== 0) {
      let V = S / y, R = k / E;
      y < 0 ? (_.push(V), A.push(R)) : (_.push(R), A.push(V));
    }
    (t === 17 || t === 24) && (_.push(0), A.push(1)), t === 19 && _.push(0);
    let P = Math.max(..._), O = Math.min(...A);
    if (P > O) return { mapped: [l, c, d, p], clipped: [] };
    let U = l + C * P, z = c + E * P, x = l + C * O, L = c + E * O;
    return U < u.xmin && x < u.xmin || U > u.xmax && x > u.xmax ||
        z < u.ymin && L < u.ymin || z > u.ymax && L > u.ymax
      ? { mapped: [l, c, d, p], clipped: [] }
      : { mapped: [l, c, d, p], clipped: [U, z, x, L] };
  }
  var ca = class {
    constructor(e, t, o) {
      this.pattern = o,
        this.replen = this.pattern[0] + this.pattern[1],
        t / this.replen > 1e3 &&
        (this.pattern[0] = t * this.pattern[0] / this.replen / 1e3,
          this.pattern[1] = t * this.pattern[1] / this.replen / 1e3),
        this.pstate = 0,
        this.dstaccum = 0,
        this.px = null,
        this.py = null,
        this.ctx = e;
    }
    static getDashedPattern(e, t) {
      let o = e.lineWidth * 11 / (t ? 3.5 : 2.5), i = o * 7 / 11;
      return [o, i];
    }
    static getDottedPattern(e, t, o) {
      let i = .5 * e.lineWidth * .1 / (o ? 3.5 : 2.5), n = i * 8 / .1;
      return t && (n *= 2), [i, n];
    }
    static getTotalSegmentLength(e) {
      if (e.length < 4) return 0;
      let t = 0, o = 0, i = e[0], n = e[1];
      for (; isNaN(i) || isNaN(n);) {
        if (o += 2, o >= e.length) return 0;
        i = e[o], n = e[o + 1];
      }
      let a, s;
      for (o += 2; o < e.length; o += 2) {
        a = e[o],
          s = e[o + 1],
          !(isNaN(a) || isNaN(s)) &&
          (t += __dcg_shared_module_exports__["MathHypot"](a - i, s - n),
            i = a,
            n = s);
      }
      return t;
    }
    start(e, t) {
      this.px = e, this.py = t;
    }
    next(e, t) {
      if (this.px === null || this.py === null) {
        throw new Error("Must call start before calling next");
      }
      let o = this.pattern[this.pstate],
        i = Math.sqrt(
          Math.pow(e - this.px, 2) + Math.pow(t - this.py, 2),
        );
      if (i > 1e-5) {
        for (; i + this.dstaccum >= o;) {
          let n = e - this.px, a = t - this.py, s = o - this.dstaccum;
          n *= s / i,
            a *= s / i,
            this.pstate === 0 &&
            (this.ctx.moveTo(this.px, this.py),
              this.ctx.lineTo(this.px + n, this.py + a)),
            this.dstaccum = 0,
            this.px += n,
            this.py += a,
            this.pstate = this.pstate === 0 ? 1 : 0,
            o = this.pattern[this.pstate],
            i -= s;
        }
        this.pstate === 0 &&
          (this.ctx.moveTo(this.px, this.py), this.ctx.lineTo(e, t));
      }
      this.px = e, this.py = t, this.dstaccum += i;
    }
    close() {
      this.pstate = 0, this.dstaccum = 0, this.px = null, this.py = null;
    }
    drawSegment(e) {
      let t = 0, o = e[0], i = e[1];
      for (; isNaN(o) || isNaN(i);) {
        if (t += 2, t >= e.length) return;
        o = e[t], i = e[t + 1];
      }
      this.start(o, i);
      let n, a;
      for (t += 2; t < e.length; t += 2) {
        n = e[t], a = e[t + 1], !(isNaN(n) || isNaN(a)) && this.next(n, a);
      }
      this.close();
    }
  };
  function No(r, e) {
    let t = r;
    t._dcgSaveClassName && t._dcgSaveClassName(e);
  }
  function To(r) {
    let e = r;
    e._dcgRestoreClassName && e._dcgRestoreClassName();
  }
  var Mp, Fg = new Map(), MT = 0;
  function JH(r, e, t) {
    let o = r.imageObj;
    if (Mp && Mp.color === e && Mp.img === o) return Mp.canvas;
    Mp ? (Mp.color = e, Mp.img = o) : Mp = {
      color: e,
      img: o,
      canvas: document.createElement("canvas"),
    };
    let i = Mp.canvas, n = r.mimeType === "image/svg+xml";
    i.width = 0,
      i.width = n ? t.width : o.width,
      i.height = n ? t.height : o.height;
    let a = i.getContext("2d");
    return a.drawImage(o, 0, 0, i.width, i.height),
      a.fillStyle = e,
      a.globalCompositeOperation = "source-atop",
      a.fillRect(0, 0, i.width, i.height),
      i;
  }
  function Rte(r, e) {
    if (
      e.width * e.height >
        1e3 * 1e3 * window.devicePixelRatio * window.devicePixelRatio
    ) return r.imageObj;
    let t = r.image_url, o = Fg.get(t), i;
    if (!o || e.width !== o.size.width || e.height !== o.size.height) {
      o && (Fg.delete(t), MT -= o.canvas.width * o.canvas.height);
      let n = r.imageObj, a = document.createElement("canvas");
      a.width = e.width,
        a.height = e.height,
        a.getContext("2d").drawImage(n, 0, 0, a.width, a.height);
      let l = 20 * 1e3 * 1e3;
      if (a.width * a.height > l) return r.imageObj;
      for (MT += a.width * a.height; MT > l;) {
        let [c, d] = Array.from(Fg)[0];
        Fg.delete(c), MT -= d.canvas.width * d.canvas.height;
      }
      Fg.set(t, { canvas: a, size: e }), i = a;
    } else Fg.delete(t), Fg.set(t, o), i = o.canvas;
    return i;
  }
  function QH(r, e, t, o = { cacheRenderedSvgs: false }) {
    let { ctx: i, projection: n } = r, a = e.formula;
    if (!a || !a.dimensions.x) return;
    let s = a.dimensions;
    for (let l = 0; l < s.x.length; l++) {
      let c = s.x[l],
        d = s.y[l],
        p = s.width[l],
        h = s.height[l],
        u = s.radianAngle[l];
      if (
        !isFinite(c) || !isFinite(d) || !isFinite(p) || !isFinite(h) ||
        !isFinite(u)
      ) continue;
      No(i, "dcg-svg-image"), i.save(), To(i), i.globalAlpha = s.opacity[l];
      let f = n.mapy(h) - n.mapy(0),
        y = n.mapx(p) - n.mapx(0),
        C = u === 0 ? 1 : Math.abs(y / p * (h / f)),
        E = n.mapx(c),
        v = n.mapy(d),
        w = E - y / 2,
        S = v + f * C / 2,
        k = h < 0 ? -1 : 1,
        _ = p < 0 ? -1 : 1,
        A = w * _,
        P = S * k,
        O = Math.abs(y),
        U = Math.abs(f);
      u !== 0 &&
      (i.translate(E, v), i.scale(1, 1 / C), i.rotate(u), i.translate(-E, -v)),
        i.scale(_, k);
      let z = t.shouldDrawHovered(r, e.id, l),
        x = t.shouldDrawPressed(e.id, l),
        L = o.currentKeyboardAttention &&
          o.currentKeyboardAttention.calcId === e.id &&
          (o.currentKeyboardAttention.listIndex === void 0 ||
            o.currentKeyboardAttention.listIndex === l),
        R = e.imageObj,
        N = window.devicePixelRatio * (n.screen.width / n.screen.height),
        M = { width: Math.floor(O * N), height: Math.floor(U * N) };
      x
        ? e.depressedImageObj
          ? R = e.depressedImageObj
          : R = JH(e, "rgba(50,50,50,0.2)", M)
        : z
        ? e.hoveredImageObj
          ? R = e.hoveredImageObj
          : R = JH(e, "rgba(200,200,200,0.2)", M)
        : o.cacheRenderedSvgs && e.mimeType === "image/svg+xml" &&
          M.width > 0 && M.height > 0 && (R = Rte(e, M)),
        i.drawImage(R, A, P, O, U * C);
      let F = 0, Z = 3;
      if (
        Sa(e) && e.controller.isTraceEnabled() &&
        (i.beginPath(),
          i.rect(A - F, P - F, O + 2 * F, U * C + 2 * F),
          i.restore(),
          i.save(),
          i.strokeStyle = "#6993C7",
          i.lineWidth = Z,
          i.stroke()), L
      ) {
        let te = i.globalAlpha;
        F = 5,
          i.beginPath(),
          i.roundRect
            ? i.roundRect(A - F, P - F, O + 2 * F, U * C + 2 * F, F)
            : i.rect(A - F, P - F, O + 2 * F, U * C + 2 * F),
          i.restore(),
          i.save(),
          i.strokeStyle = __dcg_shared_module_exports__["Rd"].FOCUS_OUTLINE,
          i.globalAlpha = 1,
          i.lineWidth = Z,
          i.stroke(),
          i.globalAlpha = te;
      }
      i.restore();
    }
  }
  function ZH(r) {
    return r.uncommitted
      ? "#ccc"
      : !r.selected && !r.hovered && e8(r) === 1
      ? __dcg_shared_module_exports__["Kd"](r.color, .2)
      : r.color;
  }
  function e8(r) {
    let e = .6;
    return r.hidden
      ? r.selected ? e = .4 : e = .25
      : r.selected || r.isPoint
      ? e = 1
      : r.hovered && (e = .8),
      r.isTransparentObject && (e *= .3),
      e;
  }
  function Fte(r) {
    return r.hidden
      ? r.isPoint ? 0 : r.selected ? .3 : .2
      : r.selected || r.isPoint || r.hovered
      ? 1
      : .7;
  }
  function t8(r, e) {
    r = r.replace(/#/, "");
    let t, o, i;
    return r.length === 3
      ? (t = parseInt(r.slice(0, 1) + r.slice(0, 1), 16),
        o = parseInt(r.slice(1, 2) + r.slice(1, 2), 16),
        i = parseInt(r.slice(2, 3) + r.slice(2, 3), 16))
      : r.length === 6
      ? (t = parseInt(r.slice(0, 2), 16),
        o = parseInt(r.slice(2, 4), 16),
        i = parseInt(r.slice(4, 6), 16))
      : (t = 0, o = 0, i = 0),
      `rgba(${t}, ${o}, ${i}, ${e})`;
  }
  function tv(r) {
    return t8(ZH(r), Fte(r));
  }
  function GT(r) {
    return t8(ZH(r), e8(r));
  }
  function LT(r) {
    return Math.abs(Math.abs(r) - Math.PI / 2) < 1e-6;
  }
  function Ja(r, e) {
    let t = r;
    t._dcgStartNamedGroup && t._dcgStartNamedGroup(e);
  }
  function rv(r, e) {
    let t = r;
    t._dcgSetTitle && t._dcgSetTitle(e);
  }
  function Qa(r) {
    let e = r;
    e._dcgEndNamedGroup && e._dcgEndNamedGroup();
  }
  var Xu = 10, Ju = 3;
  function VT(r, e) {
    return r + 1e-8 * (e - r) > r && e - r > 1e-300 && e - r < 1e300;
  }
  function r8(r, e) {
    return r > 1e-300 && VT(r, e);
  }
  var Br = class r {
    constructor(e = -10, t = 10, o = -10, i = 10, n = -2, a = 2) {
      this.xmin = e,
        this.xmax = t,
        this.ymin = o,
        this.ymax = i,
        this.zmin = n,
        this.zmax = a;
    }
    static fromObject(
      { xmin: e, xmax: t, ymin: o, ymax: i, zmin: n, zmax: a },
    ) {
      return new r(e, t, o, i, n, a);
    }
    toObject() {
      return {
        xmin: this.xmin,
        ymin: this.ymin,
        zmin: this.zmin,
        xmax: this.xmax,
        ymax: this.ymax,
        zmax: this.zmax,
      };
    }
    equals(e) {
      return !(this.xmin !== e.xmin || this.ymin !== e.ymin ||
        this.zmin !== e.zmin || this.xmax !== e.xmax ||
        this.ymax !== e.ymax || this.zmax !== e.zmax);
    }
    isXValid(e) {
      return e === "linear"
        ? VT(this.xmin, this.xmax)
        : r8(this.xmin, this.xmax);
    }
    isYValid(e) {
      return e === "linear"
        ? VT(this.ymin, this.ymax)
        : r8(this.ymin, this.ymax);
    }
    isZValid() {
      return this.zmin === void 0 || this.zmax === void 0
        ? false
        : VT(this.zmin, this.zmax);
    }
    isValid(e) {
      return this.isXValid(e.xAxisScale) && this.isYValid(e.yAxisScale);
    }
    isSquare(e, t) {
      return Math.abs(e.height - e.width * this.aspectRatio(t)) < 1;
    }
    isSquare3D() {
      let { xmin: e, xmax: t, ymin: o, ymax: i, zmin: n, zmax: a } = this;
      if (n === void 0 || a === void 0) return false;
      let s = [t - e, i - o, a - n];
      return Math.min(...s) / Math.max(...s) > .99999;
    }
    aspectRatio(e) {
      let t = Xu / Ju,
        o = e.yAxisScale === "linear"
          ? this.ymax - this.ymin
          : Math.log10(this.ymax / this.ymin) * t,
        i = e.xAxisScale === "linear"
          ? this.xmax - this.xmin
          : Math.log10(this.xmax / this.xmin) * t;
      return o / i;
    }
    getSquaredAxisLimits({ axis: e, screen: t, settings: o }) {
      let [i, n, a, s, l] = e === "y"
        ? [
          { min: this.ymin, max: this.ymax },
          { min: this.xmin, max: this.xmax },
          t.height / t.width,
          o.yAxisScale,
          o.xAxisScale,
        ]
        : [
          { min: this.xmin, max: this.xmax },
          { min: this.ymin, max: this.ymax },
          t.width / t.height,
          o.xAxisScale,
          o.yAxisScale,
        ];
      if (s === "logarithmic") {
        let d = l === "logarithmic"
            ? Math.log(n.max) - Math.log(n.min)
            : (n.max - n.min) * Ju / (Xu * Math.LOG10E),
          { min: p, max: h } = o8({
            min: Math.log(i.min),
            max: Math.log(i.max),
          }, a * d);
        return { min: Math.exp(p), max: Math.exp(h) };
      }
      let c = l === "logarithmic"
        ? (Math.log10(n.max) - Math.log10(n.min)) * Xu / Ju
        : n.max - n.min;
      return o8(i, c * a);
    }
    squareXAxis(e, t) {
      let { min: o, max: i } = this.getSquaredAxisLimits({
          axis: "x",
          screen: e,
          settings: t,
        }),
        n = new r(o, i, this.ymin, this.ymax);
      return n.isXValid(t.xAxisScale) ? n : this;
    }
    squareYAxis(e, t) {
      let { min: o, max: i } = this.getSquaredAxisLimits({
          axis: "y",
          screen: e,
          settings: t,
        }),
        n = new r(this.xmin, this.xmax, o, i);
      return n.isYValid(t.yAxisScale) ? n : this;
    }
    squareCrop(e, t) {
      return this.aspectRatio({
          xAxisScale: t.xAxisScale,
          yAxisScale: t.yAxisScale,
        }) > e.height / e.width
        ? this.squareYAxis(e, t)
        : this.squareXAxis(e, t);
    }
    polarDiameter() {
      let e = Math.abs(this.xmax),
        t = Math.abs(this.xmin),
        o = Math.abs(this.ymax),
        i = Math.abs(this.ymin);
      return 1.5 * Math.max(e, t, o, i);
    }
    largestR() {
      return Math.sqrt(
        Math.pow(Math.max(-this.xmin, this.xmax), 2) +
          Math.pow(Math.max(-this.ymin, this.ymax), 2),
      );
    }
    smallestR() {
      return this.xmin <= 0 && this.xmax >= 0 && this.ymin <= 0 &&
          this.ymax >= 0
        ? 0
        : this.xmin <= 0 && this.xmax >= 0
        ? Math.min(Math.abs(this.ymin), Math.abs(this.ymax))
        : this.ymin <= 0 && this.ymax >= 0
        ? Math.min(Math.abs(this.xmin), Math.abs(this.xmax))
        : Math.sqrt(
          Math.pow(Math.max(this.xmin, -this.xmax), 2) +
            Math.pow(Math.max(this.ymin, -this.ymax), 2),
        );
    }
  };
  function o8(r, e) {
    let t = .5 * (r.min + r.max), [o, i] = [t - .5 * e, t + .5 * e];
    return Math.abs((i - o) / e - 1) > .1
      ? { min: -.5 * e, max: .5 * e }
      : { min: o, max: i };
  }
  var OT = 1.4, n8 = 1.5, FT = {};
  function d8(r = {}) {
    return Object.keys(r).length;
  }
  function RT(r, e = {}) {
    return d8(e) === 0 ? r : r.filter((t, o) => !e[o]);
  }
  function a8(r, e) {
    let t = [];
    for (let o = 0; o < r; o++) t.push(e);
    return t;
  }
  function zte() {
    return !!Object.keys(FT).length;
  }
  var p8 = function (r, e) {
    let t = 3;
    return e && (t += e), new Br(-t, r.width + t, -t, r.height + t);
  };
  function s8(r, e) {
    let {
      displayAsRightAngle: t,
      rx: o,
      ry: i,
      startAngle: n,
      deltaAngle: a,
      yscreen: s,
      xscreen: l,
    } = r;
    if (t) {
      let c = o * Math.cos(-n),
        d = o * Math.cos(-n - a),
        p = i * Math.sin(-n),
        h = i * Math.sin(-n - a);
      e.moveTo(l + c, s + p),
        e.lineTo(l + c + d, s + p + h),
        e.lineTo(l + d, s + h);
    } else e.ellipse(l, s, o, i, 0, -n, -n - a, a > 0);
  }
  var Td = class r {
    constructor(e, t, o) {
      if (
        this.controller = e, this.getExpressionAriaLabel = o, t.config.plaidMode
      ) {
        let i = ["RED", "BLUE", "GREEN", "PURPLE", "ORANGE", "BLACK"];
        for (let n of i) {
          FT[__dcg_shared_module_exports__["Rd"][n]] = document
            .createElement("img"),
            FT[__dcg_shared_module_exports__["Rd"][n]].setAttribute(
              "src",
              "/assets/img/april-fools/" + n.toLowerCase() + ".png",
            );
        }
      }
    }
    redrawToCtx(e, t, o, i, n, a) {
      let { ctx: s, projection: l } = e;
      Ja(s, "expressions");
      let c = l.settings.highlight, d = this.controller.isGeometry();
      i.forEach((p) => {
        let h = t[p], u = o[p];
        h !== void 0 &&
        (d && l.settings.setProperty("highlight", h.showHighlight),
          Ja(s, "sketch"),
          l.settings.takingScreenshot &&
          rv(s, this.getExpressionAriaLabel(p)),
          r.drawSketchToCtx({
            sketch: t[p],
            drawContext: e,
            poiLabelsLayer: n,
            clickableObjectsLayer: a,
            geometryContext: this.controller.getGeoModel(),
          }),
          Qa(s)),
          u && u.shouldGraph && QH(e, u, a, {
            currentKeyboardAttention: this.controller.get2dPOIController()
              .keyboardAttentionManager.getKeyboardAttention(),
            cacheRenderedSvgs:
              this.controller.getGraphSettings().config.cacheRenderedSvgs,
          });
      }),
        Qa(s),
        l.settings.setProperty("highlight", c);
    }
    static eachSegment(e, t) {
      for (let o of e.branches) {
        if (o.graphMode !== 15) {
          for (let i of o.segments) t(o, i);
        }
      }
    }
    static drawSketchToCtx(
      {
        sketch: e,
        drawContext: t,
        poiLabelsLayer: o,
        clickableObjectsLayer: i,
        geometryContext: n,
      },
    ) {
      var u, f, y, C, E;
      if (!e.branches || !e.branches.length) return;
      let { ctx: a, projection: s } = t,
        l = a.lineWidth,
        c = a.globalAlpha,
        d = s.settings.globalCurveColor ? s.settings.globalCurveColor : e.color,
        p = FT[d],
        h;
      p && p.complete && p.naturalWidth > 0
        ? h = a.createPattern(p, "repeat")
        : h = d,
        a.lineJoin = "round",
        a.lineCap = "round";
      for (let v of e.branches) {
        if (
          __dcg_shared_module_exports__["_d"](v) || v.graphMode === 15 ||
          v.graphMode === 22
        ) continue;
        let w = 1;
        i.shouldDrawHovered(t, e.id, v.listIndex) && (w = XS.IS_HOVERED),
          i.shouldDrawPressed(e.id, v.listIndex) && (w = XS.IS_PRESSED),
          i.shouldDrawGhosted(e.id) && (w = XS.IS_GHOSTED),
          w *= (u = n == null ? void 0 : n.getToolFadeOpacity(e.id)) != null
            ? u
            : 1,
          w *= s.settings.getFillOpacityMultiplier(),
          a.strokeStyle = d,
          a.fillStyle = v.color && !s.settings.globalCurveColor && !zte()
            ? v.color
            : h,
          v.graphMode !== 6 && (a.desmos_batching = true, a.beginPath());
        let S = v.graphMode === 6 ? .2 : (f = v.fillOpacity) != null ? f : NaN;
        a.globalAlpha = r._clampedOpacity(S * w, .4);
        let k = JL(s, v);
        for (let _ of k) r.fillPolygonFillToCtx(a, _);
        v.graphMode !== 6 && (a.fill(), a.desmos_batching = false),
          a.globalAlpha = 1;
        for (let _ of v.segments) {
          let A = 2;
          v.graphMode && (A = v.graphMode);
          let P = _,
            O = v.lineWidth !== void 0,
            U = v.lineWidth,
            z = 2.5,
            x = (y = v.arrowMode) != null ? y : "DEFAULT";
          if (
            a.strokeStyle = v.color,
              a.fillStyle = v.color,
              O && (U <= 0 || !isFinite(U))
          ) continue;
          a.lineWidth = O ? U : z;
          let L = s.settings.graphLineWidth / z, V = 1.3;
          s.settings.highlight && (V *= 5 / 7),
            e.tokenSelected
              ? (L *= n8, V /= n8)
              : e.tokenHovered && (L *= OT, V /= OT),
            a.lineWidth *= L,
            a.globalAlpha *= s.settings.curveOpacity,
            a.globalAlpha = r._clampedOpacity(
              s.settings.curveOpacity === 1 ? 1 : v.lineOpacity,
              1,
            );
          let R = v.operator, N = "default";
          R === "<" || R === ">" || R === "!="
            ? N = "DASHED"
            : R === "<=" || R === ">="
            ? N = "SOLID"
            : e.style === "DASHED" || v.style === "DASHED"
            ? N = "DASHED"
            : (e.style === "DOTTED" || v.style === "DOTTED") &&
              (N = "DOTTED", O && (a.lineWidth *= 2)),
            a.globalAlpha *=
              (C = n == null ? void 0 : n.getToolFadeOpacity(e.id)) !=
                  null
                ? C
                : 1;
          let M = !v.isIntersectionExtension &&
              i.shouldDrawHovered(t, e.id, v.listIndex),
            F = !v.isIntersectionExtension &&
              i.shouldDrawPressed(e.id, v.listIndex),
            Z = i.shouldDrawGhosted(e.id);
          Z ? a.globalAlpha *= _G.IS_GHOSTED : (F || M) &&
            (a.save(),
              a.lineWidth += 4.5,
              a.globalAlpha *= F ? lw.IS_DEPRESSED : lw.IS_HOVERED,
              r.drawGraphStrokeToCtx(a, s, P, {
                type: N,
                graphMode: A,
                op: R,
                arrowMode: x,
                arrowHeadBaseWidth: (a.lineWidth - 4.5) * V,
                opacityMultiplier: F ? lw.IS_DEPRESSED : lw.IS_HOVERED,
              }),
              a.restore()),
            r.drawGraphStrokeToCtx(a, s, P, {
              type: N,
              graphMode: A,
              op: R,
              arrowMode: x,
              arrowHeadBaseWidth: a.lineWidth * V,
              opacityMultiplier:
                ((E = n == null ? void 0 : n.getToolFadeOpacity(e.id)) !=
                    null
                  ? E
                  : 1) * (Z ? _G.IS_GHOSTED : cw),
            });
        }
      }
      a.lineWidth = l,
        a.globalAlpha = c,
        a.strokeStyle = d,
        r.eachSegment(e, (v, w) => {
          var S;
          if ((v.graphMode === 3 || v.graphMode === 25) && v.showPoint) {
            let k = w, _ = [], A;
            if (v.interactiveLabel && e.labels) {
              for (let N = 0, M = e.labels.length; N < M; N++) {
                let F = e.labels[N];
                if (F.type === "poi") {
                  let Z = o.isOpenPOI(F.poi),
                    te = o.getHoveredPOI() === F.poi;
                  _.push(Z || te), !Z && te && (A = N);
                }
              }
            }
            let P = 1;
            typeof v.pointSize == "number"
              ? P = v.pointSize / 8
              : Array.isArray(v.pointSize) &&
                (P = v.pointSize.map((N) => N / 8));
            let O;
            Array.isArray(v.color) && (O = v.color);
            let U = i.getHoveredObjectById(e.id),
              z = i.shouldDrawHovered(t, e.id, void 0),
              x = i.getPressedObject(),
              L = i.shouldDrawPressed(
                e.id,
                x == null ? void 0 : x.listIndex,
              ),
              V = i.shouldDrawGhosted(e.id),
              R = v.droppedIndices;
            if ((z || L) && !V) {
              let N = k.length;
              R && (N += d8(R));
              let M = a8(N, 0),
                F = Array.isArray(P) ? P.slice() : a8(N, P);
              L && x
                ? x.listIndex === void 0
                  ? (M = M.map(() => JS.IS_DEPRESSED),
                    F = F.map((Z) => Z * 1.5))
                  : (M[x.listIndex] = JS.IS_DEPRESSED, F[x.listIndex] *= 1.5)
                : z && U &&
                  (M = M.map((Z, te) =>
                    U.listIndexes === void 0 || U.listIndexes[te]
                      ? JS.IS_HOVERED
                      : Z
                  ),
                    F = F.map((Z, te) =>
                      U.listIndexes === void 0 || U.listIndexes[te]
                        ? Z * 1.5
                        : Z
                    )),
                r.drawPointsToCtx({
                  ctx: a,
                  projection: s,
                  segment: k,
                  style: v.style,
                  sizeOverrideIdxs: _,
                  opacityOverrideIdx: A,
                  sizeFactor: F,
                  opacityFactor: M,
                  colorOverrides: O,
                  baseOpacity: v.pointOpacity,
                  droppedIndices: R,
                  sketch: e,
                  isKeyboardFocused: i.isKeyboardFocused(e.id, void 0),
                }),
                a.restore();
            }
            r.drawPointsToCtx({
              ctx: a,
              projection: s,
              segment: k,
              style: v.style,
              sizeOverrideIdxs: _,
              opacityOverrideIdx: A,
              sizeFactor: P,
              opacityFactor:
                ((S = n == null ? void 0 : n.getToolFadeOpacity(e.id)) !=
                    null
                  ? S
                  : 1) * (V ? QS.IS_GHOSTED : cw),
              colorOverrides: O,
              baseOpacity: v.pointOpacity,
              droppedIndices: R,
              sketch: e,
            });
          }
        });
    }
    static drawGraphStrokeToCtx(e, t, o, i) {
      let n = { arrowHeadBaseWidth: e.lineWidth },
        {
          type: a,
          graphMode: s,
          op: l,
          arrowMode: c,
          arrowHeadBaseWidth: d,
        } = Object.assign({}, n, i);
      if (s === 20 || s === 21) {
        let [y, C, E] = o,
          v = t.mathToPixels.mapX(y),
          w = t.mathToPixels.mapY(C),
          S = t.mathToPixels.dangerouslyGetXScaleFactor(),
          k = t.mathToPixels.dangerouslyGetYScaleFactor(),
          _ = Math.abs(E * S),
          A = Math.abs(E * k),
          P,
          O;
        if (
          s === 21 ? (P = -o[3], O = -o[4]) : (P = 0, O = 2 * Math.PI),
            e.save(),
            No(e, "dcg-svg-curve"),
            e.desmos_batching || e.beginPath(),
            a === "DASHED"
        ) {
          let U = ca.getDashedPattern(e, !!t.settings.highlight);
          e.setLineDash(U);
        } else if (a === "DOTTED") {
          let U = ca.getDottedPattern(
            e,
            !!t.settings.config.projectorMode,
            !!t.settings.highlight,
          );
          e.setLineDash(U);
        }
        e.ellipse(v, w, _, A, 0, P, O, P > O),
          e.desmos_batching || e.stroke(),
          To(e),
          e.restore();
        return;
      } else if (s === 23) {
        let [y, C, E, v, w] = o,
          S = !w && LT(v),
          k = Zu(v, t),
          _ = t.mathToPixels.mapX(y),
          A = t.mathToPixels.mapY(C),
          P = t.mathToPixels.dangerouslyGetXScaleFactor(),
          O = t.mathToPixels.dangerouslyGetYScaleFactor(),
          U = P > O ? P / O : 1,
          z = P > O ? 1 : O / P,
          x = Math.abs(U * k),
          L = Math.abs(z * k);
        if (
          e.save(),
            No(e, "dcg-svg-curve"),
            e.globalAlpha = .4 * i.opacityMultiplier,
            e.desmos_batching || e.beginPath(),
            e.moveTo(_, A),
            e.lineTo(_ + x * Math.cos(-E), A + L * Math.sin(-E)),
            s8({
              displayAsRightAngle: S,
              rx: x,
              ry: L,
              startAngle: E,
              deltaAngle: v,
              yscreen: A,
              xscreen: _,
            }, e),
            e.lineTo(_, A),
            !e.desmos_batching && !w && e.fill(),
            e.globalAlpha = i.opacityMultiplier,
            e.desmos_batching || e.beginPath(),
            s8({
              displayAsRightAngle: S,
              rx: x,
              ry: L,
              startAngle: E,
              deltaAngle: v,
              yscreen: A,
              xscreen: _,
            }, e),
            w
        ) {
          let V = -E - v,
            R = _ + x * Math.cos(V),
            N = A + L * Math.sin(V);
          QL(e, R, N, -E, -v, 10, x);
        }
        e.globalAlpha = i.opacityMultiplier,
          e.desmos_batching || e.stroke(),
          e.lineWidth = 1.5,
          e.globalAlpha = .2 * i.opacityMultiplier,
          e.moveTo(
            _ + 1.5 * x * Math.cos(-E),
            A + 1.5 * L * Math.sin(-E),
          ),
          e.lineTo(_, A),
          e.lineTo(
            _ + 1.5 * x * Math.cos(-E - v),
            A + 1.5 * L * Math.sin(-E - v),
          ),
          e.stroke(),
          To(e),
          e.restore();
      } else if (s === 17 || s === 18 || s === 19 || s === 24) {
        let { clipped: y, mapped: C } = Rg(o, t, s, e.lineWidth);
        if (y.length === 0) return;
        let [E, v, w, S] = y, [k, _, A, P] = C;
        e.save(), No(e, "dcg-svg-curve");
        let O;
        if (
          e.desmos_batching || e.beginPath(),
            a == "DASHED"
              ? (O = new ca(
                e,
                ca.getTotalSegmentLength(y),
                ca.getDashedPattern(e, !!t.settings.highlight),
              ),
                O.drawSegment(y))
              : a == "DOTTED"
              ? (O = new ca(
                e,
                ca.getTotalSegmentLength(y),
                ca.getDottedPattern(
                  e,
                  !!t.settings.config.projectorMode,
                  !!t.settings.highlight,
                ),
              ),
                O.drawSegment(y))
              : (e.moveTo(E, v), e.lineTo(w, S)),
            s === 17
        ) {
          let U = l8(a) * d,
            { startArrow: z, endArrow: x } = Wte(Kte(s, c));
          z && xc(e, A, P, k, _, U), x && xc(e, k, _, A, P, U);
        } else if (s === 24 && (k !== A || _ !== P)) {
          let U = l8(a) * d;
          xc(e, k, _, A, P, U);
        }
        e.desmos_batching || e.stroke(), To(e), e.restore();
        return;
      }
      let p = Rx(s, l !== "=", t.settings),
        h = vu(o, t.mathToPixels, p),
        u = Q3(h, p8(t.screen, e.lineWidth));
      if (u.length === 0) return;
      e.save(), No(e, "dcg-svg-curve");
      let f;
      if (e.desmos_batching || e.beginPath(), a == "DASHED") {
        f = new ca(
          e,
          ca.getTotalSegmentLength(u),
          ca.getDashedPattern(e, !!t.settings.highlight),
        ), f.drawSegment(u);
      } else if (a == "DOTTED") {
        f = new ca(
          e,
          ca.getTotalSegmentLength(u),
          ca.getDottedPattern(
            e,
            !!t.settings.config.projectorMode,
            !!t.settings.highlight,
          ),
        ), f.drawSegment(u);
      } else if (
        (a === "SOLID" || a === "default") && e.lineWidth === 1
      ) {
        if (u.length > 4 || u[0] !== u[2] && u[1] !== u[3]) {
          e.moveTo(u[0], u[1]);
          for (let C = 0; C < u.length; C += 2) e.lineTo(u[C], u[C + 1]);
        } else {
          e.moveTo(
            __dcg_shared_module_exports__["Z"](u[0]),
            __dcg_shared_module_exports__["Z"](u[1]),
          );
          for (let C = 0; C < u.length; C += 2) {
            e.lineTo(
              __dcg_shared_module_exports__["Z"](u[C]),
              __dcg_shared_module_exports__["Z"](u[C + 1]),
            );
          }
        }
      } else {
        e.moveTo(u[0], u[1]);
        for (let y = 0; y < u.length; y += 2) e.lineTo(u[y], u[y + 1]);
      }
      e.desmos_batching || e.stroke(), To(e), e.restore();
    }
    static mapPointToScreen(e, t, o) {
      let n = e.mapx(t);
      if (n < -20 || n > e.screen.width + 20) return null;
      let a = e.mapy(o);
      return a < -20 || a > e.screen.height + 20 ? null : { x: n, y: a };
    }
    static drawPointToCtx(e) {
      let { ctx: t, projection: o, sketch: i, x: n, y: a } = e,
        { sizeFactor: s } = e,
        l = t.lineWidth,
        c = t.fillStyle,
        d = t.strokeStyle,
        p = r.mapPointToScreen(o, n, a);
      if (
        !p ||
        e.sizeFactor !== void 0 &&
          (e.sizeFactor <= 0 || !isFinite(e.sizeFactor))
      ) return false;
      No(t, "dcg-svg-point"),
        e.alpha !== void 0 ? t.globalAlpha = e.alpha : t.globalAlpha = .9,
        e.opacityFactor !== void 0 && (t.globalAlpha *= e.opacityFactor),
        t.desmos_batching || t.beginPath();
      let h = o.settings.pointLineWidth;
      if (
        e.overrideSize &&
        (h = o.settings.config.projectorMode ? 17 : 11, t.lineWidth = h),
          i.tokenSelected
            ? s ? s *= 1.5 : s = 1.5
            : i.tokenHovered && (s ? s *= OT : s = OT),
          s !== void 0 && (h *= s, t.lineWidth = h),
          e.colorOverride &&
          (t.fillStyle = e.colorOverride, t.strokeStyle = e.colorOverride),
          e.finalHardcodedSize !== void 0 &&
          (h = e.finalHardcodedSize, t.lineWidth = h),
          e.style === "CROSS"
      ) {
        let u = h * .4;
        t.moveTo(p.x - u, p.y - u),
          t.lineTo(p.x + u, p.y + u),
          t.moveTo(p.x + u, p.y - u),
          t.lineTo(p.x - u, p.y + u),
          t.lineWidth = h * .3;
      } else if (e.style === "OPEN") {
        let u = h * .42;
        t.moveTo(p.x + u, p.y),
          t.arc(p.x, p.y, u, 0, Math.PI * 2, true),
          t.closePath(),
          t.fillStyle = "white",
          t.lineWidth = h * .25,
          t.fill();
      } else {t.moveTo(p.x - .1, p.y - .1),
          t.lineTo(p.x - .1, p.y + .1),
          t.lineTo(p.x + .1, p.y + .1),
          t.lineTo(p.x + .1, p.y - .1);}
      if (
        t.desmos_batching || t.stroke(), t.globalAlpha = 1, e.isKeyboardFocused
      ) {
        let u = h / 2 + 6;
        t.lineWidth = 2,
          t.strokeStyle = "#6A93D2",
          t.beginPath(),
          t.moveTo(p.x + u, p.y),
          t.arc(p.x, p.y, u, 0, Math.PI * 2, true),
          t.stroke(),
          t.closePath();
      }
      return t.lineWidth = l, t.fillStyle = c, t.strokeStyle = d, To(t), true;
    }
    static drawPointsToCtx(e) {
      let {
          ctx: t,
          projection: o,
          segment: i,
          style: n,
          sizeOverrideIdxs: a,
          opacityOverrideIdx: s,
          sizeFactor: l,
          opacityFactor: c,
          colorOverrides: d,
          baseOpacity: p,
          droppedIndices: h,
        } = e,
        u = t.lineWidth;
      t.lineWidth = o.settings.pointLineWidth;
      let f;
      Array.isArray(p)
        ? (f = p.map((y) => r._clampedOpacity(y, .9)), f = RT(f, h))
        : f = r._clampedOpacity(p, .9),
        Array.isArray(l) && (l = RT(l, h)),
        Array.isArray(c) && (c = RT(c, h)),
        d && (d = RT(d, h));
      for (let y = 0; y < i.length; y++) {
        r.drawPointToCtx({
          ctx: t,
          projection: o,
          sketch: e.sketch,
          x: i[y][0],
          y: i[y][1],
          alpha: s === y ? .6 : Array.isArray(f) ? f[y] : f,
          style: n,
          overrideSize: a[y],
          sizeFactor: Array.isArray(l) ? l[y] : l,
          opacityFactor: Array.isArray(c) ? c[y] : c,
          colorOverride: d && d[y],
          isKeyboardFocused: e.isKeyboardFocused,
        });
      }
      t.lineWidth = u;
    }
    static fillPolygonFillToCtx(e, t) {
      if (t.length >= 6) {
        No(e, "dcg-svg-region"),
          e.desmos_batching || e.beginPath(),
          e.moveTo(t[0], t[1]);
        for (let o = 2; o < t.length; o += 2) e.lineTo(t[o], t[o + 1]);
        e.lineTo(t[0], t[1]), e.desmos_batching || e.fill(), To(e);
      }
    }
    static _clampedOpacity(e, t) {
      return typeof e != "number"
        ? t
        : e < 0
        ? 0
        : e > 1
        ? 1
        : isFinite(e)
        ? e
        : t;
    }
  };
  function* qte(r, e) {
    let t = e.graphMode,
      o = e.operator,
      i = o == "<" || o == ">" || o == "<=" || o == ">=",
      n = !r.settings.disableFill && (t === 7 || i),
      a = o == "<=" || o == "<";
    if (n) {
      for (let s of e.segments) {
        switch (t) {
          case 6: {
            let l = a ? 0 : r.viewport.polarDiameter(),
              c = r.settings.degreeMode ? 180 : 2 * Math.PI;
            yield* lN(s, l, c);
            break;
          }
          case 2: {
            let l = a ? r.viewport.ymin : r.viewport.ymax;
            yield* xM(s, l);
            break;
          }
          case 1: {
            let l = a ? r.viewport.xmin : r.viewport.xmax;
            yield* xM(s, l);
            break;
          }
          case 7:
            yield s;
        }
      }
    }
  }
  function Hte(r) {
    switch (r) {
      case 2:
        return $3;
      case 1:
        return W3;
      case 6:
      case 7:
      default:
        return zC;
    }
  }
  function* JL(r, e) {
    let t = e.graphMode;
    if (t !== 1 && t !== 2 && t !== 6 && t !== 7) return;
    let o = p8(r.screen);
    for (let i of qte(r, e)) {
      let n = t === 7 ? lg : Rx(t, true, r.settings),
        a = vu(i, r.mathToPixels, n);
      yield yM(a, o, Hte(e.graphMode), false);
    }
  }
  function Kte(r, e) {
    return r === 17 ? e === "DEFAULT" ? "NONE" : e : "NONE";
  }
  function Wte(r) {
    switch (r) {
      case "NONE":
        return { startArrow: false, endArrow: false };
      case "POSITIVE":
        return { startArrow: false, endArrow: true };
      case "BOTH":
        return { startArrow: true, endArrow: true };
      default:
        let e = r;
        throw new Error("Unexpected arrowMode: " + e);
    }
  }
  function l8(r) {
    switch (r) {
      case "default":
      case "SOLID":
      case "DASHED":
        return 4;
      case "DOTTED":
        return 2;
      default:
        let e = r;
        throw new Error("Unexpected line style " + e);
    }
  }
  function xc(r, e, t, o, i, n) {
    let a = Math.atan2(i - t, o - e),
      s = o - n * Math.cos(a - Math.PI / 9),
      l = i - n * Math.sin(a - Math.PI / 9),
      c = o - n * Math.cos(a + Math.PI / 9),
      d = i - n * Math.sin(a + Math.PI / 9),
      p = o - (n - 2) * Math.cos(a - Math.PI / 18),
      h = i - (n - 2) * Math.sin(a - Math.PI / 18),
      u = o - (n - 2) * Math.cos(a + Math.PI / 18),
      f = i - (n - 2) * Math.sin(a + Math.PI / 18);
    r.moveTo(o, i),
      r.lineTo(s, l),
      r.lineTo(c, d),
      r.lineTo(o, i),
      r.lineTo(p, h),
      r.lineTo(u, f),
      r.lineTo(o, i);
  }
  function QL(r, e, t, o, i, n, a) {
    let s = o + i,
      l = n * Math.min(1, Math.max(.5, Math.abs(i) / .8)),
      c = i <= 0,
      d = Math.PI / 2;
    a < 25 ? d += .25 : d += .1, c || (d *= -1);
    let p = e + Math.cos(s + d), h = t + Math.sin(s + d);
    xc(r, p, h, e, t, l);
  }
  function Zu(r, e) {
    let t = 20;
    return e.settings.config.projectorMode && (t *= 1.4), t;
  }
  var Pr = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  function $te(r, e) {
    let t = document.createRange();
    t.selectNode(r);
    let o = t.getBoundingClientRect();
    if (!(o.width > 0 && o.height > 0)) return;
    let n = window.getComputedStyle(r.parentElement),
      a = r.nodeValue || "";
    if (!a) return;
    let l = -.228 * parseFloat(n.fontSize),
      c = n.fontStyle + " " + n.fontWeight + " " + n.fontSize + " " +
        n.fontFamily,
      d = o.left - e.originX,
      p = o.top - e.originY,
      h;
    if (n.transform !== "none") {
      let u = n.transform.match(
        /^matrix\(([\d.-]+), *([\d.-]+), *([\d.-]+), *([\d.-]+), *([\d.-]+), *([\d.-]+)\)$/,
      );
      if (u) {
        let f = n.transformOrigin.match(/^([\d.-]+)px ([\d.-]+)px$/);
        f &&
          (h = {
            matrix: [
              parseFloat(u[1]),
              parseFloat(u[2]),
              parseFloat(u[3]),
              parseFloat(u[4]),
              parseFloat(u[5]),
              parseFloat(u[6]),
            ],
            origin: { x: parseFloat(f[1]), y: parseFloat(f[2]) },
          });
      }
    }
    return {
      type: "text",
      text: a,
      color: n.color || "#000",
      font: c,
      x: d,
      y: p + o.height + l,
      hasOutline: e.hasOutline,
      transform: h,
    };
  }
  function h8(r, e) {
    r.beginPath();
    for (let t of e.instructions) {
      switch (t.type) {
        case "moveTo":
          r.moveTo(t.x, t.y);
          break;
        case "lineTo":
          r.lineTo(t.x, t.y);
          break;
        case "arcTo":
          r.arcTo(t.cx, t.cy, t.x, t.y, t.radius);
          break;
        case "ellipse":
          r.ellipse(
            t.centerX,
            t.centerY,
            t.radiusX,
            t.radiusY,
            t.rotation,
            t.startAngle,
            t.endAngle,
            t.anticlockwise,
          );
          break;
      }
    }
    r.closePath();
  }
  function jte(r, e) {
    let t = r.getBoundingClientRect();
    if (!(t.width > 0 && t.height > 0)) return;
    let i = 5,
      n = 3,
      a = t.left - e.originX,
      s = t.top - e.originY,
      l = -i + a,
      c = t.width + i + a,
      d = -i + s,
      p = t.height + i + s;
    return {
      type: "path",
      hasOutline: false,
      instructions: [
        { type: "moveTo", x: l + n, y: d },
        { type: "lineTo", x: c - n, y: d },
        { type: "arcTo", cx: c, cy: d, x: c, y: d + n, radius: n },
        { type: "lineTo", x: c, y: p - n },
        { type: "arcTo", cx: c, cy: p, x: c - n, y: p, radius: n },
        { type: "lineTo", x: l + n, y: p },
        { type: "arcTo", cx: l, cy: p, x: l, y: p - n, radius: n },
        { type: "lineTo", x: l, y: d + n },
        { type: "arcTo", cx: l, cy: d, x: l + n, y: d, radius: n },
      ],
      strokeColor: "#C2C2C2",
      fillColor: "rgba(255,255,255,.75)",
    };
  }
  function Yte(r, e) {
    let t = r.getBoundingClientRect();
    if (!(t.width > 0 && t.height > 0)) return;
    let i = 15,
      n = 5,
      a = 2,
      s = "#5a87cd",
      l = 3,
      c = t.left - e.originX - i,
      d = t.top - e.originY - n,
      p = c + t.width + 2 * i,
      h = d + t.height + 2 * n,
      u = c + l,
      f = p - l,
      y = d + l,
      C = h - l,
      E = [
        { type: "moveTo", x: u, y: d },
        { type: "lineTo", x: f, y: d },
        { type: "arcTo", x: p, y, radius: l, cx: p, cy: d },
        { type: "lineTo", x: p, y: C },
        { type: "arcTo", x: f, y: h, radius: l, cx: p, cy: h },
        { type: "lineTo", x: u, y: h },
        { type: "arcTo", x: c, y: C, radius: l, cx: c, cy: h },
        { type: "lineTo", x: c, y },
        { type: "arcTo", x: u, y: d, radius: l, cx: c, cy: d },
      ];
    l -= a,
      c += a,
      d += a,
      p -= a,
      h -= a,
      u = c + l,
      f = p - l,
      y = d + l,
      C = h - l;
    let v = [
      { type: "moveTo", x: u, y: d },
      { type: "arcTo", x: c, y, radius: l, cx: c, cy: d },
      { type: "lineTo", x: c, y: C },
      { type: "arcTo", x: u, y: h, radius: l, cx: c, cy: h },
      { type: "lineTo", x: f, y: h },
      { type: "arcTo", x: p, y: C, radius: l, cx: p, cy: h },
      { type: "lineTo", x: p, y },
      { type: "arcTo", x: f, y: d, radius: l, cx: p, cy: d },
      { type: "lineTo", x: u, y: d },
    ];
    return {
      type: "path",
      instructions: E.concat(v),
      fillColor: s,
      hasOutline: false,
    };
  }
  function g8(r, e) {
    if (r === "0px 0px") return;
    let t = r.match(/^([^ ]+) +(.+)$/);
    if (!t) return;
    let o = t[1], i = t[2], n = parseFloat(o), a = parseFloat(i);
    if (
      o.endsWith("%") && (n *= e.width / 100),
        o.endsWith("%") && (a *= e.height / 100),
        !(n === 0 || a === 0)
    ) return [n, a];
  }
  function Xte(r, e, t) {
    if (e.borderTopWidth === "0px") return;
    let o = r.getBoundingClientRect();
    if (!(o.width > 0 && o.height > 0)) return;
    let n = o.left - t.originX,
      a = o.top - t.originY,
      s = o.width,
      l = parseFloat(e.borderTopWidth || "1px"),
      c = e.borderTopColor || "#000",
      d,
      p = g8(e.borderTopLeftRadius, o),
      h = g8(e.borderTopRightRadius, o);
    return p && h
      ? d = [
        {
          type: "ellipse",
          centerX: n + p[0],
          centerY: a + p[1],
          radiusX: p[0],
          radiusY: p[1],
          rotation: 0,
          startAngle: Math.PI,
          endAngle: 3 * Math.PI / 2,
          anticlockwise: false,
        },
        { type: "lineTo", x: n + o.width - h[0], y: a },
        {
          type: "ellipse",
          centerX: n + o.width - h[0],
          centerY: a + h[1],
          radiusX: h[0],
          radiusY: h[1],
          rotation: 0,
          startAngle: 3 * Math.PI / 2,
          endAngle: 0,
          anticlockwise: false,
        },
        { type: "lineTo", x: n + o.width, y: a + h[1] + l },
        {
          type: "ellipse",
          centerX: n + h[0],
          centerY: a + h[1] + l,
          radiusX: h[0],
          radiusY: h[1],
          rotation: 0,
          startAngle: 0,
          endAngle: 3 * Math.PI / 2,
          anticlockwise: true,
        },
        { type: "lineTo", x: n + p[0], y: a + l },
        {
          type: "ellipse",
          centerX: n + p[0],
          centerY: a + p[1] + l,
          radiusX: p[0],
          radiusY: p[1],
          rotation: 0,
          startAngle: 3 * Math.PI / 2,
          endAngle: Math.PI,
          anticlockwise: true,
        },
      ]
      : d = [
        { type: "moveTo", x: n, y: a },
        { type: "lineTo", x: s + n, y: a },
        { type: "lineTo", x: s + n, y: l + a },
        { type: "lineTo", x: n, y: l + a },
      ],
      {
        type: "path",
        instructions: d,
        fillColor: c,
        hasOutline: t.hasOutline,
      };
  }
  function m8(r, e) {
    let t = Math.sqrt(r[0] * r[0] + r[1] * r[1]),
      o = Math.sqrt(e[0] * e[0] + e[1] * e[1]),
      i = r[0] * e[0] + r[1] * e[1],
      n = Math.acos(i / (t * o));
    return r[0] * e[1] - r[1] * e[0] < 0 && (n *= -1), n;
  }
  function Jte(r, e, t, o, i, n, a, s, l) {
    let c = Math.cos(i),
      d = Math.sin(i),
      p = (r - s) / 2,
      h = (e - l) / 2,
      u = c * p + d * h,
      f = -d * p + c * h,
      y = t * t,
      C = o * o,
      E = u * u,
      v = f * f,
      w = Math.sqrt((y * C - y * v - C * E) / (y * v + C * E));
    n === a && (w *= -1);
    let S = w * t * f / o,
      k = -w * o * u / t,
      _ = (r + s) / 2,
      A = (e + l) / 2,
      P = c * S - d * k + _,
      O = d * S + c * k + A,
      U = [1, 0],
      z = [(u - S) / t, (f - k) / o],
      x = [(-u - S) / t, (-f - k) / o],
      L = m8(U, z),
      V = m8(U, x);
    return {
      centerX: P,
      centerY: O,
      radiusX: t,
      radiusY: o,
      startAngle: L,
      endAngle: V,
      rotation: i,
      anticlockwise: a === 0,
    };
  }
  var f8 = {};
  function Qte(r, e) {
    let t = r + "-" + e, o = f8[t];
    if (o) return o;
    o = [], f8[t] = o;
    let i = e.split(" ");
    if (i.length !== 4) return o;
    let n = parseFloat(i[0]),
      a = parseFloat(i[2]),
      s = parseFloat(i[1]),
      l = parseFloat(i[3]),
      c = a - n,
      d = l - s;
    function p(k) {
      return (k - n) / c;
    }
    function h(k) {
      return (k - s) / d;
    }
    let u = "[0-9-.]+",
      f = "(M" + u + " " + u + ")",
      y = "(L" + u + " " + u + ")",
      C = "(A" + u + " " + u + " " + u + " " + u + " " + u + " " + u +
        " " + u + ")",
      E = new RegExp(f + "|" + y + "|" + C, "g"),
      v = r.match(E);
    if (!v || !v.length) return o;
    let w = NaN, S = NaN;
    for (let k of v) {
      let _ = k.substr(1).split(" ").map(parseFloat);
      switch (k[0]) {
        case "M":
          w = p(_[0]), S = h(_[1]), o.push({ type: "moveTo", x: w, y: S });
          break;
        case "L":
          w = p(_[0]), S = h(_[1]), o.push({ type: "lineTo", x: w, y: S });
          break;
        case "A":
          let A = _[0] / c,
            P = _[1] / d,
            O = _[2],
            U = _[3],
            z = _[4],
            x = p(_[5]),
            L = h(_[6]),
            V = Jte(w, S, A, P, O, U, z, x, L);
          w = x, S = L, o.push({ type: "ellipse", ...V });
          break;
      }
    }
    return o;
  }
  function Zte(r, e) {
    let t = r.childNodes[0];
    if (!t || t.nodeName !== "path") return;
    let o = r.getBoundingClientRect();
    if (!(o.width > 0 && o.height > 0)) return;
    let n = t.getAttribute("d") || "",
      a = r.getAttribute("viewBox") || "",
      s = Qte(n, a),
      l = window.getComputedStyle(r),
      c = o.width,
      d = o.height,
      p = o.left - e.originX,
      h = o.top - e.originY;
    s = __dcg_shared_module_exports__["Jc"](s);
    for (let u of s) {
      switch (u.type) {
        case "moveTo":
        case "lineTo":
          u.x = u.x * c + p, u.y = u.y * d + h;
          break;
        case "arcTo":
          u.x = u.x * c + p,
            u.y = u.y * d + h,
            u.cx = u.x * c + p,
            u.cy = u.y * d + h,
            u.radius *= c;
          break;
        case "ellipse":
          u.centerX = u.centerX * c + p,
            u.centerY = u.centerY * d + h,
            u.radiusX *= c,
            u.radiusY *= d;
          break;
        default:
          return u;
      }
    }
    return {
      type: "path",
      fillColor: l.color || "#000",
      instructions: s,
      hasOutline: e.hasOutline,
    };
  }
  function y8(r, e, t) {
    if (r.classList.contains("dcg-mq-mathspeak")) return;
    let o = window.getComputedStyle(r), i = Xte(r, o, e);
    i && t.push(i);
    let n = r.childNodes;
    for (let a = 0; a < n.length; a++) {
      let s = n[a];
      if (s.nodeType === 3) {
        let l = $te(s, e);
        l && t.push(l);
      } else if (s.nodeName === "svg") {
        let l = Zte(s, e);
        l && t.push(l);
      } else s.nodeType === 1 && y8(s, e, t);
    }
  }
  function UT(r, e) {
    let t = [];
    if (e.hasBorder) {
      let o = jte(r, e);
      o && t.push(o);
    }
    if (e.hasFocus) {
      let o = Yte(r, e);
      o && t.push(o);
    }
    return y8(r, e, t), t;
  }
  function zT(r, e) {
    No(e, "dcg-svg-label"), e.save(), To(e);
    for (let t of r) {
      switch (t.type) {
        case "path":
          t.hasOutline &&
            (e.strokeStyle = "#FFF",
              e.lineWidth = 3,
              e.miterLimit = 10,
              h8(e, t),
              e.stroke());
          break;
        case "text":
          t.hasOutline &&
            (e.font = t.font,
              e.strokeStyle = "#FFF",
              e.lineWidth = 3,
              e.miterLimit = 2,
              t.transform
                ? (e.save(), b8(e, t), e.strokeText(t.text, 0, 0), e.restore())
                : e.strokeText(t.text, t.x, t.y));
          break;
        default:
          return t;
      }
    }
    for (let t of r) {
      switch (t.type) {
        case "path":
          h8(e, t),
            t.strokeColor &&
            (e.strokeStyle = t.strokeColor,
              e.lineWidth = 1,
              e.miterLimit = 10,
              e.stroke()),
            t.fillColor && (e.fillStyle = t.fillColor, e.fill());
          break;
        case "text":
          e.font = t.font,
            e.fillStyle = t.color,
            t.transform
              ? (e.save(), b8(e, t), e.fillText(t.text, 0, 0), e.restore())
              : e.fillText(t.text, t.x, t.y);
          break;
        default:
          return t;
      }
    }
    e.restore();
  }
  function b8(r, e) {
    if (!e.transform) return;
    let t = Math.abs(e.transform.matrix[0]),
      o = Math.abs(e.transform.matrix[3]);
    r.translate(e.x + e.transform.origin.x, e.y + e.transform.origin.y),
      r.transform.apply(r, e.transform.matrix),
      r.translate(-e.transform.origin.x / t, -e.transform.origin.y / o);
  }
  var zl = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var qT = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var nt = class extends qT.Class {
    template() {
      return this.props.children
        ? this.props.children
        : qT.createElement("div", {
          onMount: (e) => this.onMountMathquill(e),
        });
    }
    onMount() {
      if (this.props.children) {
        let e = this.findAllRootDOMNodes();
        if (e.length !== 1) {
          throw new Error(
            `StaticMathquillView expects exactly 1 child DOM Node. Got: ${e.length}`,
          );
        }
        let t = e[0];
        if (t instanceof HTMLElement) this.onMountMathquill(t);
        else {throw new Error(
            "StaticMathquillView expects an HTMLElement as child DOM node",
          );}
      }
    }
    onMountMathquill(e) {
      var t, o;
      this.props.tokenController &&
      (this.mathquillTokenHelper = new Mb(
        this.props.tokenController(),
        e,
        true,
      )),
        this.staticMath = gc.StaticMath(e, {
          ...this.props.config(),
          overrideKeystroke: (i, n) => {
            var a, s;
            (s = (a = this.props).onUserPressedKey) != null &&
              s.call(a, i, n) && n.stopPropagation();
          },
        }),
        (o = (t = this.props).didMountMathquill) == null ||
        o.call(t, this.staticMath),
        e.classList.add("dcg-static-mathquill-view"),
        this.updateMathquill();
    }
    didUpdate() {
      this.updateMathquill();
    }
    updateMathquill() {
      var e;
      this.updateMathquillAria(),
        this.updateMathquillLatex(),
        (e = this.mathquillTokenHelper) == null ||
        e.updateTokens(this.props.latex());
    }
    updateMathquillLatex() {
      if (!this.staticMath) return;
      let e = this.props.latex();
      this.lastLatex !== e &&
        (this.staticMath.latex(e),
          this.lastLatex = e,
          this.props.onReflow && this.props.onReflow());
    }
    updateMathquillAria() {
      if (!this.staticMath || !this.props.getAriaLabel) return;
      let e = this.props.getAriaLabel();
      e !== this.staticMath.getAriaLabel() &&
        this.staticMath.setAriaLabel(e);
    }
  };
  var { For: ere, IfElse: tre } = zl.Components,
    es = class extends zl.Class {
      template() {
        return zl.createElement(
          "span",
          { class: zl.const("dcg-mixed-text-math") },
          zl.createElement(
            ere,
            {
              each: () =>
                __dcg_shared_module_exports__["je"](this.props.content()),
              key: (e, t) => `${e}|${t}`,
            },
            (e) =>
              tre(
                () => __dcg_shared_module_exports__["ie"](e) === "latex",
                {
                  true: () =>
                    zl.createElement(nt, {
                      latex: () => e.substring(1, e.length - 1),
                      config: this.props.mqConfig,
                    }),
                  false: () =>
                    zl.createElement("span", {
                      class: zl.const("dcg-label-raw-text"),
                    }, () => e),
                },
              ),
          ),
        );
      }
    };
  var sn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  qt();
  function HT(r) {
    return Array.from(
      r.querySelectorAll(
        'input:enabled, button:enabled, select:enabled, textarea:enabled, [tabindex="0"], a[href]',
      ),
    ).filter((e) =>
      !e.matches(
        '[aria-hidden="true"], [aria-hidden="true"] *, [aria-disabled="true"], [aria-disabled="true"] *',
      ) && bp(e)
    );
  }
  function x8(r) {
    return function (t) {
      if (ke(t) == rl && r) {
        let o = HT(r);
        if (o.length === 0) return;
        let i = o[0], n = o[o.length - 1];
        t.shiftKey && document.activeElement === i
          ? (t.preventDefault(), ee(n).trigger("focus"))
          : !t.shiftKey && document.activeElement === n
          ? (t.preventDefault(), ee(i).trigger("focus"))
          : document.activeElement &&
            !r.contains(document.activeElement) &&
            (t.preventDefault(), ee(i).trigger("focus"));
      }
    };
  }
  function Dd() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      (r) => {
        let e = Math.random() * 16 | 0;
        return (r == "x" ? e : e & 3 | 8).toString(16);
      },
    );
  }
  var { IfElse: rre } = sn.Components,
    ore = 500,
    kd = 5,
    iv = 2,
    ZL = class extends sn.Class {
      constructor() {
        super(...arguments), this.offsetLeft = 0;
      }
      init() {
        this.uuid = this.props.uuid();
      }
      gravity() {
        var e, t;
        return ((t = (e = this.props).gravity) == null ? void 0 : t.call(e)) ||
          "s";
      }
      template() {
        return sn.createElement(
          "div",
          {
            class: () => {
              var e, t, o, i;
              return {
                "dcg-tooltip-positioning-container": true,
                "dcg-tooltip-gravity-n-s": this.gravity() === "n" ||
                  this.gravity() === "s",
                "dcg-tooltip-gravity-e-w": this.gravity() === "e" ||
                  this.gravity() === "w",
                "dcg-tooltip-theme-light":
                  ((t = (e = this.props).theme) == null
                    ? void 0
                    : t.call(e)) === "light",
                "dcg-tooltip-theme-dark":
                  ((i = (o = this.props).theme) == null
                    ? void 0
                    : i.call(o)) !== "light",
              };
            },
            style: () => {
              var e, t, o, i;
              return {
                top: `${
                  this.props.hitAreaRect().top +
                  (((t = (e = this.props).offset) == null
                    ? void 0
                    : t.call(e).top) || 0)
                }px`,
                left: `${
                  this.props.hitAreaRect().left +
                  (((i = (o = this.props).offset) == null
                    ? void 0
                    : i.call(o).left) || 0)
                }px`,
                width: `${this.props.hitAreaRect().width}px`,
                height: `${this.props.hitAreaRect().height}px`,
              };
            },
          },
          sn.createElement(
            "div",
            {
              class: sn.const("dcg-tooltip-message-container"),
              style: this.bindFn(this.getMessageStyle),
            },
            sn.createElement(
              "div",
              {
                role: sn.const("tooltip"),
                id: this.const(this.uuid),
                class: () => {
                  var e, t;
                  return {
                    "dcg-tooltip-message": true,
                    "dcg-text-selectable": (t = (e = this.props).sticky) == null
                      ? void 0
                      : t.call(e),
                    "dcg-sticky-not-stuck": this.props
                      .isStickyAndNotStuck(),
                  };
                },
                onMount: (e) => this.tooltipMessage = e,
                style: () => ({
                  left: `${Math.round(this.offsetLeft)}px`,
                }),
              },
              rre(() => !!this.props.customTooltipView, {
                true: () => this.props.customTooltipView(),
                false: () => sn.createElement("span", null, this.props.tooltip),
              }),
            ),
          ),
          sn.createElement("div", {
            class: () => ({
              "dcg-tooltip-arrow": true,
              [this.getTooltipGravityClass()]: true,
            }),
            style: () => {
              var e, t;
              return ((t = (e = this.props).theme) == null
                  ? void 0
                  : t.call(e)) === "light"
                ? this.getArrowWithBorderStyle()
                : this.getSolidArrowStyle();
            },
          }),
        );
      }
      updatePositionIfNecessary() {
        if (this.gravity() !== "s" && this.gravity() !== "n") return;
        let e = this.tooltipMessage.getBoundingClientRect(),
          t = this.tooltipMessage.closest(".dcg-tap-container");
        if (!t) return;
        let o = t.getBoundingClientRect();
        e.right + iv > o.right
          ? this.offsetLeft = o.right - e.right - iv
          : e.left - iv < o.left &&
            (this.offsetLeft = o.left - e.left + iv),
          this.offsetLeft !== 0 && this.update();
      }
      didMount() {
        this.updatePositionIfNecessary();
      }
      getTooltipGravityClass() {
        switch (this.gravity()) {
          case "n":
            return "dcg-tooltip-gravity-n";
          case "s":
            return "dcg-tooltip-gravity-s";
          case "e":
            return "dcg-tooltip-gravity-e";
          case "w":
            return "dcg-tooltip-gravity-w";
        }
      }
      getArrowWithBorderStyle() {
        let e = this.gravity(),
          t = this.getBackgroundColor(),
          o = "#bbb",
          i = "8px",
          n = {
            width: i,
            height: i,
            border: `1px solid ${o}`,
            background: t,
          };
        switch (e) {
          case "s":
            return {
              ...n,
              top: "100%",
              left: "50%",
              "margin-top": "1px",
              "border-right": "0",
              "border-bottom": "0",
            };
          case "n":
            return {
              ...n,
              bottom: "100%",
              left: "50%",
              "margin-bottom": "1px",
              "border-left": "0",
              "border-top": "0",
            };
          case "e":
            return {
              ...n,
              top: "50%",
              left: "100%",
              "margin-left": "1px",
              "border-right": "0",
              "border-top": "0",
            };
          case "w":
            return {
              ...n,
              top: "50%",
              right: "100%",
              "margin-right": "1px",
              "border-left": "0",
              "border-bottom": "0",
            };
          default:
            return e;
        }
      }
      getSolidArrowStyle() {
        let e = this.gravity(),
          t = this.getBackgroundColor(),
          o = `transparent transparent ${t} transparent`,
          i = `${t} transparent transparent transparent`,
          n = `transparent ${t} transparent transparent`,
          a = `transparent transparent transparent ${t}`,
          s = `-${kd}px`;
        switch (e) {
          case "s":
            return {
              top: "100%",
              left: "50%",
              border: `${kd}px solid transparent`,
              "border-color": o,
              "margin-top": s,
              "margin-left": s,
            };
          case "n":
            return {
              bottom: "100%",
              left: "50%",
              border: `${kd}px solid transparent`,
              "border-color": i,
              "margin-bottom": s,
              "margin-left": s,
            };
          case "e":
            return {
              top: "50%",
              left: "100%",
              border: `${kd}px solid transparent`,
              "border-color": n,
              "margin-left": `-${kd}px`,
              "margin-top": s,
            };
          case "w":
            return {
              top: "50%",
              right: "100%",
              border: `${kd}px solid transparent`,
              "border-color": a,
              "margin-right": s,
              "margin-top": s,
            };
          default:
            return e;
        }
      }
      getBackgroundColor() {
        var e, t;
        return ((t = (e = this.props).theme) == null ? void 0 : t.call(e)) ===
            "light"
          ? "#fff"
          : this.props.isStickyAndNotStuck()
          ? "#666"
          : "#000";
      }
      getMessageStyle() {
        let e = this.props.hitAreaRect(),
          t = this.gravity(),
          o = this.props.maxWidth();
        switch (t) {
          case "s":
            return {
              top: "100%",
              width: `${o}px`,
              transform: "translate(-50%, 0)",
              left: `${.5 * e.width}px`,
              "margin-top": `${kd}px`,
              "text-align": "center",
            };
          case "n":
            return {
              bottom: "100%",
              width: `${o}px`,
              transform: "translate(-50%, 0)",
              left: `${.5 * e.width}px`,
              "margin-bottom": `${kd}px`,
              "text-align": "center",
            };
          case "e":
            return {
              transform: "translate(0, -50%)",
              left: "100%",
              width: `${o}px`,
              top: `${.5 * e.height}px`,
              "margin-left": `${kd}px`,
              "text-align": "left",
            };
          case "w":
            return {
              transform: "translate(0, -50%)",
              right: "100%",
              width: `${o}px`,
              top: `${.5 * e.height}px`,
              "margin-right": `${kd}px`,
              "text-align": "right",
            };
          default:
            return t;
        }
      }
    };
  function ire() {
    return document.fullscreenElement || document.mozFullScreenElement ||
      document.msFullscreenElement || document.webkitFullscreenElement;
  }
  var Le = class extends sn.Class {
    init() {
      this.uuid = `dcg-tooltip-${Dd()}`;
    }
    template() {
      return sn.createElement("div", {
        class: () => {
          var e, t, o, i;
          return {
            "dcg-tooltip-hit-area-container": true,
            "dcg-display-block": (t = (e = this.props).displayBlock) == null
              ? void 0
              : t.call(e),
            "dcg-do-not-blur": true,
            "dcg-sticky-tooltip": this.isSticky(),
            "dcg-tooltip-disabled": this.props.disabled &&
              this.props.disabled(),
            "dcg-cursor-default": !this.isSticky(),
            [
              ((i = (o = this.props).additionalClass) == null
                ? void 0
                : i.call(o)) || ""
            ]: !!this.props.additionalClass,
          };
        },
        handleEvent: sn.const("true"),
        didMount: (e) => {
          this.isMounted = true,
            this.hitAreaNode = e,
            this.setupEventListeners(this.hitAreaNode);
        },
        tabIndex: () => this.isSticky() ? "0" : "-1",
        "aria-label": () => this.isSticky() ? this.props.tooltip() : void 0,
        role: () => this.isSticky() ? "note" : void 0,
        onFocus: () => {
          this.isSticky() && (this.showTooltip(), this.stickTooltip());
        },
        onTap: (e) => {
          var t, o, i, n, a;
          if (this.isSticky()) {
            if (e.stopPropagation(), this.isStuck) {
              this.hideTooltipImmediately();
            } else {
              if (
                (o = (t = this.props).disabled) != null && o.call(t)
              ) return;
              this.showTooltip(),
                this.stickTooltip(),
                (i = this.hitAreaNode) == null || i.focus();
            }
          } else if (this.shouldShowOnTapstart()) {
            if ((a = (n = this.props).disabled) != null && a.call(n)) {
              return;
            }
            this.showTooltip(), this.setUpHideOnExternalMousedown();
          } else this.hideTooltipImmediately();
        },
      }, this.props.children);
    }
    isSticky() {
      var e, t, o, i;
      return !!((t = (e = this.props).sticky) != null && t.call(e)) &&
        !((i = (o = this.props).disabled) != null && i.call(o));
    }
    shouldShowOnTapstart() {
      var e, t;
      return !!((t = (e = this.props).showOnTapstart) != null &&
        t.call(e));
    }
    didUpdate() {
      this.updateTooltip();
    }
    updateTooltip() {
      if (!this.wrapperRef) return;
      if (!this.props.tooltip()) {
        this.hideTooltip();
        return;
      }
      let e = this.hitAreaNode.getBoundingClientRect(),
        t = this.wrapperRef.elt.getBoundingClientRect(),
        { originalTop: o, originalLeft: i } = this.wrapperRef,
        n = e.top - t.top,
        a = e.left - t.left;
      Math.abs(n - o) > 3 || Math.abs(a - i) > 3
        ? this.hideTooltip()
        : this.wrapperRef.view.update();
    }
    handleShowEvent(e) {
      var o, i;
      if ((i = (o = this.props).disabled) != null && i.call(o)) return;
      let t = this.props.delay ? this.props.delay() : ore;
      this.clearTimeouts(), this.showTooltipTimeout = setTimeout(e, t);
    }
    hideTooltipImmediately() {
      this.clearTimeouts(), this.hideTooltip();
    }
    handleHideEvent() {
      this.clearTimeouts(),
        this.hideTooltipTimeout = setTimeout(
          this.bindFn(this.hideTooltip),
          150,
        );
    }
    setupEventListeners(e) {
      ee(e).on("tipsyshow", (t) => {
        t.target === e && this.handleShowEvent(() => {
          this.showTooltip();
        });
      }).on("tipsyhide", (t) => {
        t.target !== e || this.isStuck || this.handleHideEvent();
      }).on("keydown", (t) => {
        !rw(t) && !kf(t) && this.isStuck && this.hideTooltipImmediately();
      });
    }
    willUnmount() {
      this.clearTimeouts(), this.isMounted = false, this.hideTooltip();
    }
    setUpHideOnExternalMousedown() {
      ee(document).on(
        `mousedown.dcg-tooltip-${this.uuid} touchstart.dcg-tooltip-${this.uuid} pointerdown.dcg-tooltip-${this.uuid}`,
        (e) => {
          this.wrapperRef &&
            (this.hitAreaNode.contains(e.target) ||
              this.wrapperRef.elt.contains(e.target) ||
              this.hideTooltip());
        },
      );
    }
    stickTooltip() {
      this.isMounted && this.wrapperRef &&
        (this.isStuck ||
          (this.setUpHideOnExternalMousedown(),
            this.isStuck = true,
            this.updateTooltip()));
    }
    clearTimeouts() {
      clearTimeout(this.showTooltipTimeout),
        clearTimeout(this.hideTooltipTimeout);
    }
    showTooltip() {
      var u, f, y;
      if (!this.isMounted || this.wrapperRef || !this.props.tooltip()) {
        return;
      }
      let e = this.hitAreaNode.getBoundingClientRect(),
        t = document.createElement("div");
      t.className = "dcg-tooltip-mount-pt";
      let o = this.hitAreaNode.closest(".dcg-tap-container"), i = ire();
      (!!i && i.contains(this.hitAreaNode) &&
          i.closest(".dcg-tap-container")
        ? i
        : o).appendChild(t);
      let a = t.getBoundingClientRect(),
        s = e.left - a.left,
        l = e.top - a.top,
        c = 200;
      if ((f = (u = this.props).noWrap) != null && f.call(u)) {
        let C = (y = t.closest(".dcg-tap-container")) == null
          ? void 0
          : y.getBoundingClientRect();
        C && (c = C.width - 2 * iv);
      }
      let d = {
        ...this.props,
        isStickyAndNotStuck: () => this.isSticky() && !this.isStuck,
        maxWidth: () => c,
        hitAreaRect: () => ({
          top: l || 0,
          left: s || 0,
          width: e.width || 0,
          height: e.height || 0,
        }),
        uuid: () => this.uuid,
      };
      this.setupEventListeners(t),
        ee(t).on("dcg-tap", () => {
          this.isSticky() && this.stickTooltip();
        });
      let p = sn.mountToNode(ZL, t, d);
      ee(document).on(`keydown.dcg-tooltip-${this.uuid}`, (C) => {
        ke(C) === kn && this.hideTooltip();
      });
      let h = () => this.updateTooltip();
      window.addEventListener("scroll", h, true),
        this.wrapperRef = {
          elt: t,
          view: p,
          originalLeft: s,
          originalTop: l,
          onScroll: h,
        },
        this.assignAriaDescribedBy();
    }
    hideTooltip() {
      this.clearTimeouts(),
        this.wrapperRef &&
        (this.isStuck = false,
          ee(document).off(`.dcg-tooltip-${this.uuid}`),
          window.removeEventListener(
            "scroll",
            this.wrapperRef.onScroll,
            true,
          ),
          this.restoreAriaDescribedBy(),
          sn.unmountFromNode(this.wrapperRef.elt),
          this.wrapperRef.elt.parentNode &&
          this.wrapperRef.elt.parentNode.removeChild(this.wrapperRef.elt),
          this.wrapperRef = void 0);
    }
    assignAriaDescribedBy() {
      var t, o;
      if ((o = (t = this.props).sticky) != null && o.call(t)) return;
      let e = HT(this.hitAreaNode)[0] || this.hitAreaNode;
      this.originalDescribedBy = e.getAttribute("aria-describedby"),
        e.setAttribute("aria-describedby", this.uuid);
    }
    restoreAriaDescribedBy() {
      var t, o;
      if ((o = (t = this.props).sticky) != null && o.call(t)) return;
      let e = HT(this.hitAreaNode)[0] || this.hitAreaNode;
      this.originalDescribedBy
        ? e.setAttribute("aria-describedby", this.originalDescribedBy)
        : e.removeAttribute("aria-describedby");
    }
  };
  function KT(r, e, t) {
    return Math.max(e, Math.min(t, r));
  }
  var Gb = class {
    constructor(e) {
      let t = e.data, o = e.width, i = e.height;
      this.imageData = e;
      for (let s = 1; s < o; s++) t[s] += t[s - 1];
      for (let s = 1; s < i; s++) t[s * o] += t[s * o - o];
      let n = o * i - o - i + 1, a = o - 1;
      for (let s = 0; s < n; s++) {
        let l = 1 + s % a,
          d = (1 + Math.floor(s / a)) * o,
          p = l - 1 + d,
          h = l + d - o,
          u = l - 1 + d - o;
        t[d + l] += t[p] + t[h] - t[u];
      }
    }
    getSumForValidRect(e) {
      let t = e.left - 1,
        o = e.right - 1,
        i = e.top - 1,
        n = e.bottom - 1,
        a = this.imageData.width,
        s = this.imageData.data,
        l = s[t + i * a],
        c = s[o + i * a],
        d = s[t + n * a],
        p = s[o + n * a];
      return t >= 0 && i >= 0
        ? p - c - d + l
        : t >= 0
        ? p - d
        : i >= 0
        ? p - c
        : p;
    }
    getSum(e) {
      let t = {
        left: KT(Math.floor(e.left), 0, this.imageData.width),
        right: KT(Math.ceil(e.right), 0, this.imageData.width),
        top: KT(Math.floor(e.top), 0, this.imageData.height),
        bottom: KT(Math.ceil(e.bottom), 0, this.imageData.height),
      };
      return t.left >= t.right || t.top >= t.bottom
        ? 0
        : this.getSumForValidRect(t);
    }
  };
  var th = 1 / 2, eh = document.createElement("canvas"), eP = [];
  function nre(r, e) {
    if (!(e.width * e.height > 0)) {
      return new Gb({ width: 0, height: 0, data: [] });
    }
    eh.width = 0,
      eh.width = Math.round(e.width * th),
      eh.height = Math.round(e.height * th);
    let o = eh.getContext("2d");
    o.save(),
      o.scale(eh.width / r.canvas.width, eh.height / r.canvas.height),
      o.drawImage(r.canvas, 0, 0),
      o.restore();
    let i = o.getImageData(0, 0, eh.width, eh.height), n = i.data;
    n.length / 4, eP.length, eP = new Array(n.length / 4);
    let a = eP;
    for (let l = 0; l < a.length; l++) a[l] = n[l * 4 + 3];
    return new Gb({ width: i.width, height: i.height, data: a });
  }
  function w8(r) {
    for (let e = 0; e < r.length; e++) {
      let t = are(e, r);
      r[e] = [t];
    }
    return r.map((e) => e[0]);
  }
  function are(r, e) {
    let t = 1 / 0, o = -1, i = e[r];
    if (i.length === 1) return i[0];
    for (let n = 0; n < i.length; n++) {
      let a = e[r][n].staticScore, s = sre(r, n, e), l = a + s;
      (o === -1 || l < t) && (t = l, o = n);
    }
    return i[o];
  }
  function sre(r, e, t) {
    let o = 0, i = t[r][e];
    for (let n = 0; n < t.length; n++) {
      if (n === r) continue;
      let a = 0, s = t[n];
      for (let l = s.length - 1; l >= 0; l--) {
        let c = s[l],
          d = Math.max(
            0,
            Math.min(i.right, c.right) - Math.max(i.left, c.left),
          ),
          p = Math.max(
            0,
            Math.min(i.bottom, c.bottom) - Math.max(i.top, c.top),
          );
        a += d * p;
      }
      o += a / s.length;
    }
    return o;
  }
  function lre(r, e) {
    let t = e.getSum({
      left: r.left * th,
      right: r.right * th,
      top: r.top * th,
      bottom: r.bottom * th,
    });
    return t /= 200, t /= th * th, t;
  }
  function cre(r, e) {
    let t = dre(r, e);
    return 10 * (r.width * r.height - t);
  }
  function dre(r, e) {
    let t = Math.max(
        0,
        Math.min(r.right, e.right) - Math.max(r.left, e.left),
      ),
      o = Math.max(
        0,
        Math.min(r.bottom, e.bottom) - Math.max(r.top, e.top),
      );
    return t * o;
  }
  function v8(r, e) {
    let t;
    return () => (t ||
      (t = {
        viewport: { left: 0, right: e.width, top: 0, bottom: e.height },
        integralImage: nre(r(), e),
      }),
      t);
  }
  function WT(r, e) {
    if (e.length <= 1) return;
    let t = r();
    for (let o of e) {
      o.staticScore += cre(o, t.viewport),
        o.staticScore += lre(o, t.integralImage);
    }
  }
  function C8(r, e) {
    let t = e.nakedLabel ? 0 : e.pt_radius,
      o = Math.round(t / Math.sqrt(2)),
      i = [],
      n = e.pt_x,
      a = e.pt_y,
      s = e.width,
      l = e.height,
      c = 400;
    i.push({
      cx_s: 0,
      cy_s: 0,
      cx_a: 0,
      cy_a: 0,
      staticScore: c,
      orientation: "center",
      matches: { default: 1, center: 1, center_auto: 1, auto_center: 1 },
    }),
      i.push({
        cx_s: .5,
        cx_a: t + 3,
        cy_s: 0,
        cy_a: 0,
        staticScore: c,
        orientation: "right",
        matches: { default: 1, right: 1, center_auto: 1, auto_right: 1 },
      }),
      i.push({
        cx_s: -.5,
        cx_a: -t - 3,
        cy_s: 0,
        cy_a: 0,
        staticScore: c,
        orientation: "left",
        matches: { default: 1, left: 1, center_auto: 1, auto_left: 1 },
      }),
      i.push({
        cx_s: 0,
        cx_a: 0,
        cy_s: -.5,
        cy_a: -t,
        staticScore: c,
        orientation: "above",
        matches: { default: 1, above: 1, auto_center: 1, above_auto: 1 },
      }),
      i.push({
        cx_s: -.5,
        cx_a: -o,
        cy_s: -.5,
        cy_a: -o,
        staticScore: c,
        orientation: "tl",
        matches: {
          default: 1,
          above_left: 1,
          above_auto: 1,
          auto_left: 1,
        },
      }),
      i.push({
        cx_s: .5,
        cx_a: o,
        cy_s: -.5,
        cy_a: -o,
        staticScore: c,
        orientation: "tr",
        matches: {
          default: 1,
          above_right: 1,
          above_auto: 1,
          auto_right: 1,
        },
      }),
      i.push({
        cx_s: 0,
        cx_a: 0,
        cy_s: .5,
        cy_a: t,
        staticScore: c,
        orientation: "below",
        matches: { default: 1, below: 1, auto_center: 1, below_auto: 1 },
      }),
      i.push({
        cx_s: -.5,
        cx_a: -o,
        cy_s: .5,
        cy_a: o,
        staticScore: c,
        orientation: "bl",
        matches: {
          default: 1,
          below_left: 1,
          below_auto: 1,
          auto_left: 1,
        },
      }),
      i.push({
        cx_s: .5,
        cx_a: o,
        cy_s: .5,
        cy_a: o,
        staticScore: c,
        orientation: "br",
        matches: {
          default: 1,
          below_right: 1,
          below_auto: 1,
          auto_right: 1,
        },
      });
    let d = Math.cos(e.rotation),
      p = Math.sin(e.rotation),
      h = i.map((u) => {
        let f = u.cx_s * s + u.cx_a,
          y = u.cy_s * l + u.cy_a,
          C = f * d - y * p,
          E = y * d + f * p,
          v = {
            multiplyWidth: u.cx_s - .5,
            multiplyHeight: u.cy_s - .5,
            addX: u.cx_a,
            addY: u.cy_a,
          },
          w = -s / 2,
          S = s / 2,
          k = -l / 2,
          _ = l / 2;
        if (e.rotation) {
          let A = pre([
            { x: w * d - k * p, y: k * d + w * p },
            { x: w * d - _ * p, y: _ * d + w * p },
            { x: S * d - k * p, y: k * d + S * p },
            { x: S * d - _ * p, y: _ * d + S * p },
          ]);
          w = A.left, S = A.right, k = A.top, _ = A.bottom;
        }
        return w = Math.round(n + C + w),
          S = Math.round(n + C + S),
          k = Math.round(a + E + k),
          _ = Math.round(a + E + _),
          {
            pt_x: Math.round(n),
            pt_y: Math.round(a),
            left: w,
            right: S,
            top: k,
            bottom: _,
            width: S - w,
            height: _ - k,
            translate: v,
            staticScore: e.priorOrientation === u.orientation
              ? u.staticScore - 20
              : u.staticScore,
            orientation: u.orientation,
            matches: u.matches,
          };
      });
    return e.enforceOrientation && e.enforceOrientation !== "default"
      ? h = __dcg_shared_module_exports__["i"](
        h,
        (u) => !!u.matches[e.enforceOrientation],
      )
      : e.nakedLabel
      ? h = __dcg_shared_module_exports__["i"](
        h,
        (u) => u.orientation === "center",
      )
      : e.keepOrientation && e.priorOrientation
      ? h = __dcg_shared_module_exports__["i"](
        h,
        (u) => u.orientation === e.priorOrientation,
      )
      : h = __dcg_shared_module_exports__["i"](
        h,
        (u) => u.orientation !== "center",
      ),
      WT(r, h),
      h;
  }
  function S8(r, e) {
    let t = [],
      o = e.width,
      i = e.height,
      n = o / 2,
      a = i / 2,
      s = e.pt_x1,
      l = e.pt_y1,
      c = e.pt_x2,
      d = e.pt_y2,
      p = 5,
      h = (d - l) / (c - s),
      u = Math.atan2(d - l, c - s) + Math.PI / 2,
      f = p * Math.cos(u),
      y = p * Math.sin(u),
      C = Math.min(l, d) - Math.abs(y) - i,
      E = Math.max(l, d) + Math.abs(y),
      v = [.5, .4, .6, .2, .8],
      w = [0, 20, 20, 40, 40],
      S = [];
    for (let _ of v) {
      S.push({ x: s * (1 - _) + c * _, y: l * (1 - _) + d * _ });
    }
    for (let _ = 0; _ < S.length; _++) {
      let A = S[_], P, O, U, z;
      if (h >= 2 || h <= -2) {
        U = z = A.y - a;
        let R = Math.abs((c - s) / (d - l) * a) + Math.abs(f);
        P = A.x + R, O = A.x - R - o;
      } else if (h <= .05 && h >= -.05) {
        P = O = A.x - n;
        let R = Math.abs(h * n) + Math.abs(y);
        U = A.y - R - i, z = A.y + R;
      } else {f > 0
          ? (P = A.x + f, O = A.x - f - o)
          : (P = A.x + f - o, O = A.x - f),
          y > 0
            ? (U = A.y + y, z = A.y - y - i)
            : (U = A.y + y - i, z = A.y - y);}
      U < C ? U = C : U > E && (U = E), z < C ? z = C : z > E && (z = E);
      let x = (c - s) * (U - l) - (d - l) * (P - s) > 0,
        L = _.toString() + (x ? "-a" : "-b");
      t.push({
        pt_x: A.x,
        pt_y: A.y,
        left: P,
        top: U,
        staticScore: w[_],
        orientation: L,
        matches: { [L]: 1 },
      });
      let V = _.toString() + (x ? "-b" : "-a");
      t.push({
        pt_x: A.x,
        pt_y: A.y,
        left: O,
        top: z,
        staticScore: w[_],
        orientation: V,
        matches: { [V]: 1 },
      });
    }
    let k = t.map((_) => {
      let A = Math.round(_.left),
        P = Math.round(_.left + o),
        O = Math.round(_.top),
        U = Math.round(_.top + i);
      return {
        pt_x: Math.round(_.pt_x),
        pt_y: Math.round(_.pt_y),
        translate: {
          multiplyWidth: 0,
          multiplyHeight: 0,
          addX: _.left - _.pt_x,
          addY: _.top - _.pt_y,
        },
        left: A,
        right: P,
        top: O,
        bottom: U,
        width: P - A,
        height: U - O,
        staticScore: e.priorOrientation === _.orientation
          ? _.staticScore - 20
          : _.staticScore,
        orientation: _.orientation,
        matches: _.matches,
      };
    });
    return e.keepOrientation && e.priorOrientation &&
      (k = __dcg_shared_module_exports__["i"](
        k,
        (_) => _.orientation === e.priorOrientation,
      )),
      WT(r, k),
      k;
  }
  function E8(r, e) {
    let t = [],
      o = e.pt_x,
      i = e.pt_y,
      n = e.width,
      a = e.height,
      s = -(e.startAngle + e.deltaAngle / 2),
      l = e.isRightAngle ? e.radius * Math.sqrt(2) - 1 : e.radius + 4,
      c = l + Math.sqrt(e.width * e.width / 4 + e.height * e.height / 4),
      d = [],
      p = c * Math.sin(s);
    p > l + 1 / 2 * a && (p = l + 1 / 2 * a),
      p < -l - 1 / 2 * a && (p = -l - 1 / 2 * a),
      d.push({ x: o + c * Math.cos(s) - n / 2, y: i + p - a / 2 });
    for (let u = 0; u < d.length; u++) {
      let f = d[u], y = u.toString() + "-a";
      t.push({
        pt_x: f.x,
        pt_y: f.y,
        left: f.x,
        top: f.y,
        staticScore: 0,
        orientation: y,
        matches: { [y]: 1 },
      });
    }
    let h = t.map((u) => {
      let f = Math.round(u.left),
        y = Math.round(u.left + n),
        C = Math.round(u.top),
        E = Math.round(u.top + a);
      return {
        pt_x: Math.round(u.pt_x),
        pt_y: Math.round(u.pt_y),
        translate: {
          multiplyWidth: 0,
          multiplyHeight: 0,
          addX: u.left - u.pt_x,
          addY: u.top - u.pt_y,
        },
        left: f,
        right: y,
        top: C,
        bottom: E,
        width: y - f,
        height: E - C,
        staticScore: e.priorOrientation === u.orientation
          ? u.staticScore - 20
          : u.staticScore,
        orientation: u.orientation,
        matches: u.matches,
      };
    });
    return e.keepOrientation && e.priorOrientation &&
      (h = __dcg_shared_module_exports__["i"](
        h,
        (u) => u.orientation === e.priorOrientation,
      )),
      WT(r, h),
      h;
  }
  function T8(r, e) {
    let t = [],
      o = e.width,
      i = e.height,
      n = 10,
      a = Math.round(n / Math.sqrt(2)),
      s = 0,
      l = 50,
      c = 0,
      d = 0,
      p = 0;
    for (let y = 0; y < e.path.length - 2; y += 2) {
      p += 1, c += e.path[y], d += e.path[y + 1];
    }
    let h = c / p, u = d / p;
    t.push({
      left: h - o / 2,
      top: u - i / 2,
      staticScore: s,
      orientation: "center",
      matches: { center: 1 },
    }),
      t.push({
        left: h + n + 3,
        top: u - i / 2,
        staticScore: l,
        orientation: "right",
        matches: { right: 1 },
      }),
      t.push({
        left: h - (n + o) - 3,
        top: u - i / 2,
        staticScore: l,
        orientation: "left",
        matches: { left: 1 },
      }),
      t.push({
        left: h - o / 2,
        top: u - (i + n),
        staticScore: l,
        orientation: "top",
        matches: { top: 1 },
      }),
      t.push({
        left: h - (o + a),
        top: u - (i + a),
        staticScore: l,
        orientation: "tl",
        matches: { tl: 1 },
      }),
      t.push({
        left: h + a,
        top: u - (i + a),
        staticScore: l,
        orientation: "tr",
        matches: { tr: 1 },
      }),
      t.push({
        left: h - o / 2,
        top: u + n,
        staticScore: l,
        orientation: "bottom",
        matches: { bottom: 1 },
      }),
      t.push({
        left: h - (o + a),
        top: u + a,
        staticScore: l,
        orientation: "bl",
        matches: { bl: 1 },
      }),
      t.push({
        left: h + a,
        top: u + a,
        staticScore: l,
        orientation: "br",
        matches: { br: 1 },
      });
    let f = t.map((y) => {
      let C = Math.round(y.left),
        E = Math.round(y.left + o),
        v = Math.round(y.top),
        w = Math.round(y.top + i);
      return {
        pt_x: Math.round(h),
        pt_y: Math.round(u),
        translate: {
          multiplyWidth: 0,
          multiplyHeight: 0,
          addX: y.left - h,
          addY: y.top - u,
        },
        left: C,
        right: E,
        top: v,
        bottom: w,
        width: E - C,
        height: w - v,
        staticScore: e.priorOrientation === y.orientation
          ? y.staticScore - 20
          : y.staticScore,
        orientation: y.orientation,
        matches: y.matches,
      };
    });
    return e.keepOrientation && e.priorOrientation &&
      (f = __dcg_shared_module_exports__["i"](
        f,
        (y) => y.orientation === e.priorOrientation,
      )),
      WT(r, f),
      f;
  }
  function pre(r) {
    let e = r[0].x, t = r[0].x, o = r[0].y, i = r[0].y;
    for (let n = r.length - 1; n >= 1; n--) {
      let { x: a, y: s } = r[n];
      a < e && (e = a), a > t && (t = a), s < o && (o = s), s > i && (i = s);
    }
    return { left: e, right: t, top: o, bottom: i };
  }
  var hre = 1,
    Lp = class {
      constructor(e, t, o, i, n, a, s) {
        this.x = e,
          this.y = t,
          this.type = o,
          this.sketch = i,
          this.branch = n,
          this.pointIdxOnBranch = a,
          this.bareLabel = s === void 0 ? false : s,
          this.id = hre++;
      }
      getLabel() {
        let e = this.sketch && this.sketch.branches[this.branch];
        return e && "labels" in e && e.labels &&
            e.labels[this.pointIdxOnBranch] || "";
      }
      getGraphMode() {
        return this.sketch.branches[this.branch].graphMode;
      }
      getCompiledFunction() {
        let e = this.sketch.branches[this.branch];
        if (!(!("compiled" in e) || !e.compiled)) return e.compiled.fn;
      }
      isAttachedToPlottedPoint() {
        return this.type === 1006 || this.type === 1008;
      }
      isMovable() {
        return __dcg_shared_module_exports__["M"](this.getGraphMode());
      }
      isPersistent() {
        return this.type === 1008;
      }
      getLabelSize() {
        let e = this.sketch && this.sketch.branches[this.branch];
        return this.type === 1008 && e && "labelSize" in e
          ? e.labelSize === void 0 ? 1 : e.labelSize
          : 1;
      }
      getLabelRotation() {
        let e = this.sketch && this.sketch.branches[this.branch];
        return this.type === 1008 && e && "labelAngle" in e
          ? e.labelAngle === void 0 ? 0 : e.labelAngle
          : 0;
      }
      getPointOpacity() {
        let e = this.sketch && this.sketch.branches[this.branch];
        if (e && "pointOpacity" in e) {
          let t = e.pointOpacity;
          if (t !== void 0) {
            let o;
            return Array.isArray(t) ? o = t[this.pointIdxOnBranch] : o = t,
              isFinite(o) ? Math.max(0, Math.min(1, o)) : 1;
          }
        }
        return 1;
      }
      getPointSize() {
        let e = this.sketch && this.sketch.branches[this.branch];
        if (e && "pointSize" in e) {
          let t = e.pointSize;
          if (t !== void 0) {
            let o;
            Array.isArray(t) ? o = t[this.pointIdxOnBranch] : o = t;
            let i = isFinite(o) ? Math.max(0, o) : 8;
            return this.isMovable()
              ? __dcg_shared_module_exports__["Ud"](i)
              : i;
          }
        }
        return this.isMovable() ? __dcg_shared_module_exports__["Vd"](8) : 8;
      }
      getTextOutline() {
        if (this.hasEditableLabel()) return false;
        let e = this.sketch && this.sketch.branches[this.branch];
        return this.type === 1008 && e && "suppressTextOutline" in e
          ? !e.suppressTextOutline
          : true;
      }
      hasInteractiveLabel() {
        let e = this.sketch && this.sketch.branches[this.branch];
        return e && "interactiveLabel" in e ? !!e.interactiveLabel : false;
      }
      hasEditableLabel() {
        let e = this.sketch && this.sketch.branches[this.branch];
        return e && "editableLabel" in e ? !!e.editableLabel : false;
      }
      isBareLabel() {
        return this.bareLabel;
      }
      getMovablePoint() {
        return this.sketch.getMovablePointByIndex(this.pointIdxOnBranch);
      }
      isSelected() {
        return this.sketch.showHighlight;
      }
    };
  var { If: D8, Input: gre, For: mre, Switch: fre } = Pr.Components,
    bre = 300,
    k8 = {
      id: true,
      sketchId: true,
      rotatedWidth: true,
      rotatedHeight: true,
      alignedWidth: true,
      alignedHeight: true,
      content: true,
      focused: true,
      isNakedLabel: true,
      isClickable: true,
      hasOutline: true,
      hasBorder: true,
      classes: true,
      styles: true,
      dotStyles: true,
      poi: false,
      objectSpec: false,
      x: false,
      y: false,
      screenX: false,
      screenY: false,
      left: false,
      top: false,
      rotation: false,
      opacity: false,
      forcedOrientation: false,
      orientation: false,
      labelDOM: false,
      containerDOM: false,
      willCopyToCanvas: false,
      layerFilter: false,
      cachedDrawingCommands: false,
      animation: false,
      layerNumber: false,
      isComplex: false,
    };
  function _8(r, e) {
    return e ? e.getPOIById(r) : null;
  }
  function Ng(r, e) {
    return 1e3 *
      (r.pixelsToMath.mapX(r.mathToPixels.mapX(e) + .5) -
        r.pixelsToMath.mapX(r.mathToPixels.mapX(e) - .5));
  }
  function jT(r, e) {
    return 1e3 *
      (r.pixelsToMath.mapY(r.mathToPixels.mapY(e) + .5) -
        r.pixelsToMath.mapY(r.mathToPixels.mapY(e) - .5));
  }
  function yre(r, { x: e, y: t }) {
    let o = Ng(r, e), i = jT(r, t);
    return { xscale: o, yscale: i };
  }
  function I8(r, e) {
    return e ? [r[1], r[0]] : r;
  }
  function iP(r, e) {
    let t, o = false, i = "", n = "", { poi: a } = r, s = a.getGraphMode();
    if (r.type === "poi") {
      let { xscale: c, yscale: d } = yre(e, a);
      t = a.getLabel();
      let p, h = a.type === 1007 && a.getCompiledFunction();
      if (h) {
        let u = s === 1, f = u ? a.y : a.x, [y, C] = I8([c, d], u);
        p = __dcg_shared_module_exports__["point"](f, y, C, h), p = I8(p, u);
      } else {p = [
          __dcg_shared_module_exports__["value"](a.x, c),
          __dcg_shared_module_exports__["value"](a.y, d),
        ];}
      o = !isFinite(p[1].value),
        i = p[0].latex,
        n = p[1].latex,
        i === "undefined" && (i = "\\mathrm{undefined}"),
        n === "undefined" && (n = "\\mathrm{undefined}");
    } else t = r.text;
    let l = t && __dcg_shared_module_exports__["ie"](t);
    return t
      ? l === "latex"
        ? {
          is_hole: o,
          type: "latex",
          text: t.substring(1, t.length - 1),
        }
        : l === "text"
        ? { is_hole: o, type: "text", text: t }
        : { is_hole: o, type: "mixed", text: t }
      : r.type === "poi"
      ? r.poi.hasEditableLabel()
        ? { is_hole: o, type: "text", text: "" }
        : s === 25 || s === 26
        ? {
          is_hole: o,
          type: "latex",
          text: __dcg_shared_module_exports__["complexNumberLabel"](
            [a.x, a.y],
            __dcg_shared_module_exports__[
              "DEFAULT_COMPLEX_EVALUATION_LABEL_OPTIONS"
            ],
          ),
        }
        : {
          is_hole: o,
          type: "latex",
          text: "\\left(" + i + ",\\ " + n + "\\right)",
        }
      : { is_hole: o, type: "text", text: "?" };
  }
  var A8 = 4,
    rP = class extends Pr.Class {
      getClassName() {
        var e;
        return ((e = this.props.point()) == null ? void 0 : e.y) !==
            void 0
          ? "dcg-audio-trace-line dcg-audio-trace-line--horizontal"
          : "dcg-audio-trace-line";
      }
      getTraceCoord() {
        var i, n;
        let e = (i = this.props.point()) == null ? void 0 : i.x,
          t = (n = this.props.point()) == null ? void 0 : n.y,
          o = this.props.projection();
        if (e !== void 0) {
          return `${Math.round(10 * o.mapx(e)) / 10 - A8 / 2}px`;
        }
        if (t !== void 0) {
          return `${Math.round(10 * o.mapy(t)) / 10 - A8 / 2}px`;
        }
      }
      getStyle() {
        var o;
        let e = this.getTraceCoord(),
          t = (o = this.props.point()) == null ? void 0 : o.color;
        return { "--dcg-trace-coord": e, "--dcg-trace-color": t };
      }
      template() {
        return Pr.createElement("div", {
          class: this.bindFn(this.getClassName),
          style: this.bindFn(this.getStyle),
        });
      }
    },
    Pb = class extends Pr.Class {
      constructor() {
        super(...arguments),
          this.labelsDirty = false,
          this.traceLinePt = void 0;
      }
      init() {
        this.grapher = this.props.grapher(),
          this.controller = this.grapher.controller,
          this.cachedLabelDict = {},
          this.cachedLabelOrder = [],
          this.hoveredPOI = void 0,
          this.openedPOI2Sketch = {};
      }
      template() {
        return Pr.createElement(
          "div",
          {
            class: Pr.const("dcg-graph-outer"),
            style: this.const({ "z-index": "0" }),
            didMount: this.bindFn(this.didMountRoot),
          },
          Pr.createElement(
            "div",
            null,
            Pr.createElement(
              mre,
              { each: () => this.cachedLabelOrder },
              (e) =>
                Pr.createElement(
                  "div",
                  {
                    class: () => this.getLabelClasses(e),
                    style: () => this.getLabelStyles(e),
                    didMount: (t) => this.linkLabelContainerNode(e, t),
                  },
                  Pr.createElement("div", {
                    class: Pr.const("dcg-pt"),
                    style: () => this.getDotStyles(e),
                  }),
                  Pr.createElement(
                    "div",
                    {
                      class: Pr.const("dcg-label"),
                      didMount: (t) => this.linkLabelDOMNode(e, t),
                    },
                    this.renderLabelContent(e),
                    Pr.createElement(D8, {
                      predicate: () => this.showPOIbutton(e),
                    }, () =>
                      Pr.createElement(
                        Le,
                        {
                          tooltip: () =>
                            this.controller.s(
                              "graphing-calculator-button-copy-poi-coordinates",
                            ),
                          offset: this.const({ top: 4 }),
                        },
                        Pr.createElement(
                          "button",
                          {
                            class: Pr.const(
                              "dcg-unstyled-button dcg-poi-copy-button",
                            ),
                            onTap: () => this.copyPOI(e),
                            "aria-label": () =>
                              this.controller.s(
                                "graphing-calculator-button-copy-poi-coordinates",
                              ),
                          },
                          Pr.createElement("i", {
                            class: Pr.const("dcg-icon-insert"),
                          }),
                        ),
                      )),
                  ),
                ),
            ),
          ),
          Pr.createElement(
            D8,
            { predicate: () => true },
            () =>
              Pr.createElement(rP, {
                point: () => this.traceLinePt,
                projection: () => this.grapher.getProjection(),
              }),
          ),
        );
      }
      copyPOI(e) {
        delete this.openedPOI2Sketch[e],
          this.setHoveredPOI(void 0),
          this.controller.dispatch({
            type: "add-poi-expression",
            latex: this.getLabelContent(e).text,
          });
      }
      showPOIbutton(e) {
        if (
          !this.controller.isListEnabled() ||
          !this.controller.isListVisible()
        ) return false;
        let t = this.getHoveredPOI();
        (t == null ? void 0 : t.id) !== parseInt(e) && (t = void 0);
        let o = _8(e, this.grapher.graphSketches[this.openedPOI2Sketch[e]]) ||
          t;
        switch (o == null ? void 0 : o.type) {
          case 1001:
          case 1002:
          case 1003:
          case 1004:
            return true;
          default:
            return false;
        }
      }
      setTraceLine(e) {
        __dcg_shared_module_exports__["E"](e, this.traceLinePt) ||
          (this.traceLinePt = e, this.update());
      }
      getAriaLabelForId(e) {
        let t = this.cachedLabelDict[e], o;
        t
          ? t.isComplex
            ? o = Ao(
              __dcg_shared_module_exports__["complexNumberLabel"]([t.x, t.y]),
            )
            : o = ll(this.controller, t.x, t.y)
          : o = this.controller.s(
            "graphing-calculator-label-poi-unknown-coordinates",
          );
        let i = this.controller.s(
          "graphing-calculator-narration-editable-point-label",
        );
        return this.controller.s(
          "graphing-calculator-narration-item-at-coordinates",
          { itemDescription: i, coordinates: o },
        );
      }
      renderLabelContent(e) {
        return Pr.createElement(
          fre,
          { key: () => this.getLabelContent(e).type },
          (t) =>
            t === "text"
              ? Pr.createElement("span", {
                class: Pr.const("dcg-label-raw-text"),
              }, () => this.getLabelContent(e).text)
              : t === "latex"
              ? Pr.createElement(nt, {
                latex: () => this.getLabelContent(e).text,
                config: this.bindFn(this.getMQConfig),
              })
              : t === "mixed"
              ? Pr.createElement(es, {
                content: () => this.getLabelContent(e).text,
                mqConfig: () => this.controller.getMathquillConfig({}),
              })
              : t === "MATH"
              ? Pr.createElement(
                "div",
                {
                  class: () => ({
                    "dcg-editable-label-border": true,
                    "dcg-do-not-blur": true,
                    "dcg-focus": this.shouldEditableLabelBeFocused(e),
                    "dcg-empty-label":
                      this.getEditableLabelText(e).trim().length === 0,
                  }),
                  style: () => ({
                    "border-color": __dcg_shared_module_exports__["Kd"](
                      this.getEditableLabelTextColor(e),
                      .3,
                    ),
                  }),
                },
                Pr.createElement(Fe, {
                  latex: () => this.getEditableLabelText(e),
                  placeholder: () => "",
                  isFocused: () => this.shouldEditableLabelBeFocused(e),
                  capExpressionSize: () =>
                    this.controller.getGraphSettings().config
                      .capExpressionSize,
                  selectOnFocus: Pr.const(false),
                  config: this.bindFn(this.getMQConfig),
                  getAriaLabel: () => this.getAriaLabelForId(e),
                  getAriaPostLabel: this.const(""),
                  onUserChangedLatex: (o) => this.onLabelInput(o, e),
                  onExpressionSizeExceeded: () =>
                    this.controller.dispatch({
                      type: "expression-size-exceeded",
                    }),
                  onFocusedChanged: (o) =>
                    this.onEditableLabelFocusChange(o, e),
                  hasError: this.const(false),
                  noFadeout: this.const(true),
                  needsSystemKeypad: () => !this.controller.isKeypadEnabled(),
                }),
              )
              : Pr.createElement(
                "div",
                {
                  class: () => ({
                    "dcg-resizing-text-input-container": true,
                    "dcg-editable-label-border": true,
                    "dcg-focus": this.shouldEditableLabelBeFocused(e),
                    "dcg-empty-label":
                      this.getEditableLabelText(e).trim().length === 0,
                  }),
                  style: () => ({
                    "border-color": __dcg_shared_module_exports__["Kd"](
                      this.getEditableLabelTextColor(e),
                      .3,
                    ),
                  }),
                  onScroll: (o) => {
                    o.target && (o.target.scrollLeft = 0);
                  },
                },
                Pr.createElement(gre, {
                  "aria-label": () => this.getAriaLabelForId(e),
                  onInput: (o) => this.onLabelInput(o, e),
                  value: () => this.getEditableLabelText(e),
                  onFocus: () => this.onEditableLabelFocusChange(true, e),
                  onBlur: () => this.onEditableLabelFocusChange(false, e),
                }),
                Pr.createElement("span", {
                  class: Pr.const("dcg-text-input-content"),
                }, () => this.getEditableLabelText(e) || " "),
              ),
        );
      }
      getSketchIdFromLabelId(e) {
        let t = this.cachedLabelDict[e];
        if (t) return t.sketchId;
      }
      getEditableLabelTextColor(e) {
        let t = this.getSketchIdFromLabelId(e);
        if (!t) return "#000";
        let o = this.controller.getItemModel(t);
        return !o || o.type !== "expression" ? "#000" : Fu(o);
      }
      onEditableLabelFocusChange(e, t) {
        let o = this.getSketchIdFromLabelId(t);
        o &&
          (e
            ? this.controller.dispatch({
              type: "set-focus-location",
              location: { type: "editable-label", id: o },
            })
            : this.controller.dispatch({
              type: "blur-focus-location",
              location: { type: "editable-label", id: o },
            }),
            this.update());
      }
      shouldEditableLabelBeFocused(e) {
        let t = this.getSketchIdFromLabelId(e),
          o = this.controller.getFocusLocation();
        return !(!o || o.type !== "editable-label" || !t || o.id !== t);
      }
      onLabelInput(e, t) {
        let o = this.getSketchIdFromLabelId(t);
        if (!o) return;
        let i = this.controller.getItemModel(o);
        if (!i || i.type !== "expression") return;
        let n = e;
        this.controller.getItemEditableLabelMode(o) === "MATH" &&
        n.length > 0 && (n = "`" + n + "`"),
          this.controller.dispatch({
            type: "set-item-label",
            id: o,
            label: n,
          });
      }
      getEditableLabelText(e) {
        let t = this.getSketchIdFromLabelId(e);
        if (!t) return "";
        let o = this.controller.getItemModel(t);
        return !o || o.type !== "expression"
          ? ""
          : this.controller.getItemEditableLabelMode(t) === "MATH"
          ? o.label.substring(1, o.label.length - 1)
          : o.label;
      }
      linkLabelDOMNode(e, t) {
        let o = this.cachedLabelDict[e];
        o && (o.labelDOM = t);
      }
      linkLabelContainerNode(e, t) {
        let o = this.cachedLabelDict[e];
        o && (o.containerDOM = t);
      }
      getLabelClasses(e) {
        let t = this.cachedLabelDict[e];
        return t ? t.classes : {};
      }
      getLabelStyles(e) {
        let t = this.cachedLabelDict[e];
        return t ? t.styles : {};
      }
      getDotStyles(e) {
        let t = this.cachedLabelDict[e];
        return t ? t.dotStyles : {};
      }
      getLabelContent(e) {
        let t = this.cachedLabelDict[e];
        if (t) {
          let o = this.getSketchIdFromLabelId(e);
          if (!o) return { is_hole: false, type: "text", text: "" };
          let i = this.controller.getItemEditableLabelMode(o);
          return t.classes["dcg-editable-label"] && i !== void 0 &&
              i !== "NONE"
            ? { is_hole: false, type: i, text: "" }
            : t.content;
        }
        return { is_hole: false, type: "text", text: "" };
      }
      didMountRoot(e) {
        this.node = e;
      }
      computeHoveredLabel(e, t) {
        let o;
        this.hoveredPOI
          ? this.isOpenPOI(this.hoveredPOI)
            ? this.grapher.setLayerClass(
              "hoveredPOI",
              "dcg-mouse-over-opened-poi",
            )
            : (o = this.computeLabel(
              e,
              { poi: this.hoveredPOI, type: "poi" },
              t,
              "hovered",
              1 / 0,
            ),
              this.grapher.setLayerClass(
                "hoveredPOI",
                "dcg-mouse-over-closed-poi",
              ))
          : this.grapher.setLayerClass("hoveredPOI", void 0);
        let i = this.getHoveredInteractiveLabel();
        i && !i.bareLabel
          ? this.grapher.setLayerClass(
            "interactiveLabel",
            "dcg-mouse-over-opened-poi",
          )
          : this.grapher.setLayerClass("interactiveLabel", void 0),
          o && this.saveLabelToCache(o);
      }
      computeTraceLabel(e, t) {
        if (!this.traceInfo) return;
        let o = this.traceInfo.pt;
        if (!o) return;
        let i = new Lp(
            o.x,
            o.y,
            1007,
            this.traceInfo.branchInfo.sketch,
            this.traceInfo.branchInfo.branch,
            0,
          ),
          n = this.computeLabel(
            e,
            { poi: i, type: "poi" },
            t,
            "trace",
            1 / 0,
          );
        n && this.saveLabelToCache(n);
      }
      computeLabel(e, t, o, i, n) {
        var me, we;
        let { projection: a } = e,
          s = t.type === "poi" ? t.poi.id + "" : t.id;
        i === "trace" && (s = "*trace*");
        let l = t.poi, c = a.mapx(l.x), d = a.mapy(l.y), p = c, h = d;
        if (
          t.type !== "poi" && (c = 0, d = 0),
            !a.coordsAreOnscreen(c, d, 20) ||
            this.isHiddenInteractiveLabel(l)
        ) return;
        let u = false, f, y = l.sketch, C = y && y.branches[0];
        C &&
          (u = !!("nakedLabel" in C && C.nakedLabel),
            f = "labelOrientation" in C ? C.labelOrientation : void 0);
        let E = y.id, v = this.controller.getItemModel(E);
        if (
          l.hasEditableLabel() && v && v.type === "expression" && !Ea(v)
        ) return;
        let w = (v == null ? void 0 : v.type) === "expression" &&
            __dcg_shared_module_exports__["isTypeOrListOfType"](
              (we = (me = v.formula) == null
                  ? void 0
                  : me.typed_constant_value) == null
                ? void 0
                : we.valueType,
              __dcg_shared_module_exports__["Complex"],
            ),
          S = iP(t, a),
          k = l.pointIdxOnBranch,
          _ = l.getLabelSize();
        this.grapher.settings.config.projectorMode && (_ *= 1.2),
          Array.isArray(_) && (_ = _[k]);
        let A = l.getLabelRotation();
        Array.isArray(A) && (A = A[k]);
        let P = l.getPointOpacity() *
            this.controller.getGeoModel().getToolFadeOpacity(E),
          O = l.getTextOutline(),
          U = l.isPersistent(),
          z = l.isAttachedToPlottedPoint(),
          x = l.hasInteractiveLabel(),
          L = l.hasEditableLabel(),
          V = (v == null ? void 0 : v.type) === "expression" && $n(v),
          R = this.grapher.clickableObjectsLayer.shouldDrawPressed(
            E,
            l.pointIdxOnBranch,
          ),
          N = this.grapher.clickableObjectsLayer.shouldDrawHovered(
            e,
            E,
            l.pointIdxOnBranch,
          ),
          M = this.grapher.clickableObjectsLayer.isKeyboardFocused(
            E,
            l.pointIdxOnBranch,
          ),
          F = y.color;
        if (R) {
          let Ce = __dcg_shared_module_exports__["da"](F);
          Ce.l > .2 ? Ce.l -= .2 : Ce.l += .1, F = Ce.toString();
        } else if (N) {
          let Ce = __dcg_shared_module_exports__["da"](F);
          Ce.l > .2 ? Ce.l -= .1 : Ce.l += .2, F = Ce.toString();
        }
        let Z = !U, te = z;
        x && (te = true, Z = true), i === "trace" && (te = false, Z = true);
        let Y = o[s],
          he = Y && Y.orientation,
          se = {
            "dcg-poi-label": true,
            "dcg-tracept": i === "trace",
            "dcg-opened": i === "opened",
            "dcg-hole": S.is_hole,
            "dcg-show-border": Z,
            "dcg-hide-dot": te,
            "dcg-naked-label": u,
            "dcg-editable-label": L && !this.takingScreenshot,
            "dcg-has-outline": O && !Z,
            "dcg-focus": M,
          };
        isFinite(_) || (_ = 1);
        let q = { "font-size": Math.round(_ * 1100) / 10 + "%" },
          oe = !se["dcg-editable-label"] && !se["dcg-tracept"] &&
            !se["dcg-show-border"] && !x,
          K = L ? "above-canvas" : oe ? "canvas-labels" : "not-drawn";
        oe
          ? q.visibility = "hidden"
          : (q.left = c + "px",
            q.top = d + "px",
            A && (q.transform = `rotate(${A}rad)`),
            delete q.opacity), U && F && (q.color = F);
        let fe = {};
        return i === "trace" &&
          (fe["background-color"] = F, fe["border-color"] = F),
          {
            id: s,
            sketchId: E,
            poi: l,
            x: l.x,
            y: l.y,
            screenX: c,
            screenY: d,
            top: h,
            left: p,
            rotatedWidth: Y == null ? void 0 : Y.rotatedWidth,
            rotatedHeight: Y == null ? void 0 : Y.rotatedHeight,
            alignedWidth: Y == null ? void 0 : Y.alignedWidth,
            alignedHeight: Y == null ? void 0 : Y.alignedHeight,
            labelDOM: Y == null ? void 0 : Y.labelDOM,
            containerDOM: Y == null ? void 0 : Y.containerDOM,
            cachedDrawingCommands: Y == null ? void 0 : Y.cachedDrawingCommands,
            animation: Y == null ? void 0 : Y.animation,
            forcedOrientation: f,
            focused: M,
            isNakedLabel: u,
            isClickable: V,
            orientation: he,
            rotation: A,
            classes: se,
            styles: q,
            dotStyles: fe,
            content: S,
            hasBorder: l.hasEditableLabel(),
            willCopyToCanvas: oe,
            layerFilter: K,
            opacity: P,
            layerNumber: n,
            isComplex: w,
            hasOutline: O || l.hasEditableLabel(),
            objectSpec: t.type !== "poi"
              ? t.type === "angle"
                ? {
                  type: t.type,
                  segments: [
                    a.mapx(t.segments[0]),
                    a.mapy(t.segments[1]),
                    t.segments[2],
                    t.segments[3],
                  ],
                }
                : { type: t.type, segments: a.map_xy_pairs(t.segments) }
              : void 0,
          };
      }
      computeAllLabels(e, t) {
        let o = {}, i, n, a = this.grapher.graphSketches;
        for (let l of this.grapher.getDrawLayers()) {
          for (let c of l.drawOrder) {
            let d = a[c];
            if (!d) {
              continue;
            }
            let p = d.labels;
            if (p.length) {
              for (let h = 0; h < p.length; h++) {
                let u = p[h],
                  f = this.computeLabel(e, u, t, "opened", l.layer);
                f &&
                  (Array.isArray(d.color) &&
                    (f.styles.color = d.color[h]),
                    this.saveLabelToCache(f));
              }
            }
          }
        }
        let s = {};
        for (i in this.openedPOI2Sketch) {
          let l = _8(i, a[this.openedPOI2Sketch[i]]);
          l &&
            (s[i] = l.sketch.id,
              n = this.computeLabel(
                e,
                { poi: l, type: "poi" },
                t,
                "opened",
                1 / 0,
              ),
              n && this.saveLabelToCache(n));
        }
        return this.openedPOI2Sketch = s, o;
      }
      saveLabelToCache(e) {
        let t = e.id;
        this.cachedLabelDict[t] || this.cachedLabelOrder.push(t),
          this.cachedLabelDict[t] = e;
      }
      markLabelsDirty() {
        this.labelsDirty = true;
      }
      getInteractiveLabelUnderPoint(e) {
        let t;
        for (let o = this.cachedLabelOrder.length - 1; o >= 0; o--) {
          let i = this.cachedLabelOrder[o], n = this.cachedLabelDict[i];
          if (!n || !n.rotatedWidth || !n.rotatedHeight) continue;
          let a = n.screenX,
            s = n.screenY,
            { left: l, top: c, rotatedWidth: d, rotatedHeight: p } = n;
          if (
            d > 0 && p > 0 && e.x > a + l && e.x < a + l + d &&
            e.y > s + c && e.y < s + c + p
          ) {
            let h = this.getSketchIdFromLabelId(i);
            if (h === void 0) continue;
            let u = this.controller.getItemModel(h);
            if (!u || u.type !== "expression") continue;
            if (xb(u)) {
              return {
                type: "editable",
                model: u,
                layerNumber: n.layerNumber,
              };
            }
            !t && tH(u)
              ? t = {
                type: "draggable",
                model: u,
                layerNumber: n.layerNumber,
                label: { x: n.x, y: n.y },
              }
              : !t && n.isClickable &&
                (t = {
                  type: "clickable",
                  model: u,
                  layerNumber: n.layerNumber,
                  poi: n.poi,
                });
          }
        }
        return t;
      }
      positionLabels(e, t, o, i) {
        let n = !this.labelsDirty;
        this.labelsDirty = false;
        let a = [];
        e.forEach((d) => {
          let p = t[d];
          if (!p || !p.labelDOM) return;
          let h, u, f = this.getSketchIdFromLabelId(d);
          if (f !== void 0) {
            let A = this.grapher.getGraphSketch(f);
            A && A.branches &&
              (h = A.branches[0].pointSize,
                u = __dcg_shared_module_exports__["M"](
                  A.branches[0].graphMode,
                ));
          }
          (h === void 0 || typeof h != "number" || h < 0) && (h = 8);
          let y = this.grapher.settings.config.projectorMode ? 1.3 : 1;
          u && (h = __dcg_shared_module_exports__["Ud"](h));
          let C = .5 * h * y + 3,
            E = p.screenX,
            v = p.screenY,
            w = p.classes["dcg-show-border"] ? 2 : 0,
            S = p.labelDOM.clientWidth + w,
            k = p.labelDOM.clientHeight + w;
          if (!(S > 0 && k > 0)) return;
          let _ = 0;
          this.takingScreenshot && p.hasBorder && (_ = 5),
            a.push({
              renderedLabel: p,
              pt_x: E,
              pt_y: v,
              pt_radius: C + _,
              rotation: p.rotation,
              nakedLabel: p.isNakedLabel,
              width: S,
              height: k,
              keepOrientation: n,
              priorOrientation: p.orientation,
              enforceOrientation: p.forcedOrientation,
            });
        });
        let s = v8(i, o),
          l = a.map((d) => {
            if (d.renderedLabel.objectSpec) {
              if (d.renderedLabel.objectSpec.type === "segment") {
                return S8(s, {
                  pt_x1: d.renderedLabel.objectSpec.segments[0],
                  pt_y1: d.renderedLabel.objectSpec.segments[1],
                  pt_x2: d.renderedLabel.objectSpec.segments[2],
                  pt_y2: d.renderedLabel.objectSpec.segments[3],
                  pt_radius: 10,
                  width: d.width,
                  height: d.height,
                  keepOrientation: d.keepOrientation,
                  priorOrientation: d.priorOrientation || "",
                });
              }
              if (d.renderedLabel.objectSpec.type === "polygon") {
                return T8(s, {
                  path: d.renderedLabel.objectSpec.segments,
                  pt_radius: 10,
                  width: d.width,
                  height: d.height,
                  keepOrientation: d.keepOrientation,
                  priorOrientation: d.priorOrientation || "",
                });
              }
              if (d.renderedLabel.objectSpec.type === "angle") {
                let p = d.renderedLabel.objectSpec.segments,
                  h = this.grapher.settings.config.projectorMode ? 30 : 20;
                return E8(s, {
                  pt_x: p[0],
                  pt_y: p[1],
                  startAngle: p[2],
                  deltaAngle: p[3],
                  isRightAngle: LT(p[3]),
                  radius: h,
                  pt_radius: 10,
                  width: d.width,
                  height: d.height,
                  keepOrientation: d.keepOrientation,
                  priorOrientation: d.priorOrientation || "",
                });
              }
            } else return C8(s, d);
            return [];
          });
        w8(l).forEach((d, p) => {
          let h = a[p].renderedLabel;
          h.orientation = d.orientation;
          let u = d.left - d.pt_x, f = d.top - d.pt_y;
          h.left = u,
            h.top = f,
            h.rotatedWidth = d.width,
            h.rotatedHeight = d.height,
            h.alignedWidth = a[p].width,
            h.alignedHeight = a[p].height;
          let y = d.translate.multiplyWidth * h.alignedWidth +
              d.translate.addX,
            C = d.translate.multiplyHeight * h.alignedHeight +
              d.translate.addY;
          h.screenX = d.pt_x, h.screenY = d.pt_y;
          let E = h.animation;
          E ||
          (E = {
            from_dx: y,
            from_dy: C,
            to_dx: y,
            to_dy: C,
            now_dx: y,
            now_dy: C,
            positionChangeTime: 0,
            orientation: d.orientation,
          },
            h.animation = E),
            E.orientation === d.orientation && (E.to_dx = y, E.to_dy = C);
          let v, w, S = (Date.now() - E.positionChangeTime) / bre;
          if (S < 1) {
            let _ = .3 * S + 2.4 * S * S - 1.7 * S * S * S;
            v = E.from_dx * (1 - _) + E.to_dx * _,
              w = E.from_dy * (1 - _) + E.to_dy * _;
          } else v = E.to_dx, w = E.to_dy;
          E.now_dx = v,
            E.now_dy = w,
            E.to_dx = y,
            E.to_dy = C,
            E.orientation !== d.orientation &&
            (E.positionChangeTime = Date.now(),
              E.from_dx = v,
              E.from_dy = w,
              E.orientation = d.orientation);
          let k = h.labelDOM;
          if (k && !h.willCopyToCanvas) {
            k.style.transform = `translate(${E.now_dx}px,${E.now_dy}px)`;
            let _ = h.containerDOM;
            _ &&
              (_.style.left = d.pt_x + "px", _.style.top = d.pt_y + "px");
          }
        });
      }
      copyToCtx(e, t) {
        Ja(e, "labels");
        let o = this.node.getBoundingClientRect();
        this.cachedLabelOrder.forEach((i) => {
          var p, h;
          let n = this.cachedLabelDict[i];
          if (!n || !n.willCopyToCanvas) return;
          let a = n.labelDOM;
          if (
            !a || t.filter !== n.layerFilter ||
            !t.allowedSketches.has(n.sketchId)
          ) return;
          let s = (p = n.cachedDrawingCommands) == null ? void 0 : p.commands,
            l = {};
          for (let u in k8) {
            if (k8[u] === true) {
              let f = n[u],
                y = (h = n.cachedDrawingCommands) == null
                  ? void 0
                  : h.cacheKeys[u];
              l[u] = f,
                __dcg_shared_module_exports__["E"](y, f) || (s = void 0);
            }
          }
          if (!s) {
            let u = {
              originX: o.x,
              originY: o.y,
              hasOutline: !!n.hasOutline,
              hasBorder: !!n.hasBorder,
              hasFocus: !!n.focused && n.isNakedLabel,
            };
            s = UT(a, u),
              n.cachedDrawingCommands = { cacheKeys: l, commands: s };
          }
          let c = this.computeRotatedCenter(
              n.screenX,
              n.screenY,
              n.rotation,
            ),
            d = { x: 0, y: 0 };
          n.animation &&
          (d.x = n.animation.now_dx, d.y = n.animation.now_dy),
            e.save(),
            e.globalAlpha = n.opacity,
            e.rotate(n.rotation),
            e.translate(c.x + d.x, c.y + d.y),
            zT(s, e),
            e.restore();
        }), Qa(e);
      }
      areAnyLabelsAnimating() {
        var e;
        for (let t in this.cachedLabelDict) {
          let o = (e = this.cachedLabelDict[t]) == null ? void 0 : e.animation;
          if (o && (o.now_dx !== o.to_dx || o.now_dy !== o.to_dy)) {
            return true;
          }
        }
        return false;
      }
      computeRotatedCenter(e, t, o) {
        let i = Math.cos(-o),
          n = Math.sin(-o),
          a = e * i - t * n,
          s = t * i + e * n;
        return { x: a, y: s };
      }
      recomputeLabels(e, t, o) {
        let i = this.cachedLabelDict;
        this.cachedLabelDict = {},
          this.cachedLabelOrder = [],
          this.computeAllLabels(e, i),
          this.computeHoveredLabel(e, i),
          this.computeTraceLabel(e, i),
          this.update(),
          this.positionLabels(
            this.cachedLabelOrder,
            this.cachedLabelDict,
            t,
            o,
          );
      }
      clearOpenedPOI() {
        this.openedPOI2Sketch = {};
      }
      closePOI(e) {
        delete this.openedPOI2Sketch[e.id];
      }
      openPOI(e) {
        this.openedPOI2Sketch[e.id] = e.sketch.id;
      }
      isOpenPOI(e) {
        return this.openedPOI2Sketch.hasOwnProperty(e.id);
      }
      isHiddenInteractiveLabel(e) {
        return !e || !e.hasInteractiveLabel()
          ? false
          : !this.isOpenPOI(e) && this.getHoveredPOI() !== e;
      }
      setHoveredPOI(e) {
        this.hoveredPOI = e;
      }
      getHoveredPOI() {
        return this.hoveredPOI;
      }
      getHoveredInteractiveLabel() {
        let e = this.getHoveredPOI();
        if (e && e.hasInteractiveLabel()) return e;
      }
      setTraceInfo(e) {
        this.traceInfo = e;
      }
      isTracing() {
        return !!this.traceInfo;
      }
      getTraceInfo() {
        return this.traceInfo;
      }
      getMQConfig() {
        return this.controller.getMathquillConfig({});
      }
    };
  function Nb(r, e) {
    let t = r[e];
    return Array.isArray(t) && r.tableInfo ? t[r.tableInfo.rowIndex] : t;
  }
  var nv = class {
    constructor(e) {
      this.geoHoveredObjects = {},
        this.grapher = e,
        this.renderedPointsIdOrder = [],
        this.renderedPoints = {},
        this.speakThrottledAlert = __dcg_shared_module_exports__["z"](
          () => {
            let t = this.getPOIUnderAttention();
            if (!t) {
              this.lastAriaAlert = void 0;
              return;
            }
            let o = this.getAriaAlert({
              id: t.id,
              lastAriaAlert: this.lastAriaAlert,
              includeUsageInstructions: false,
            });
            o != null && o.updated &&
              (xe(o.completeMessage), this.lastAriaAlert = o);
          },
          1e3,
          { leading: false, trailing: true },
        );
    }
    recomputeMovablePoints(e) {
      let { projection: t } = e,
        o = this.grapher.graphSketches,
        i = this.renderedPoints;
      this.renderedPoints = {}, this.renderedPointsIdOrder = [];
      let n = this.grapher.poiController.keyboardAttentionManager
          .getKeyboardAttention(),
        a = n == null ? void 0 : n.calcId,
        s = (n == null ? void 0 : n.listIndex) || 0,
        l = (E) => {
          let v = !!n && a === E.sketch.id && s === E.listIndex,
            w = this.processPOI(t, E, i[E.id], v);
          w &&
            (this.renderedPoints[E.id] = w,
              this.renderedPoints[E.id].poi = E,
              this.renderedPointsIdOrder.push(E.id));
        };
      for (let E of this.grapher.generateMergeDrawOrder()) {
        let v = o[E];
        v &&
          (v.getMovablePoints().forEach(l),
            v.getStaticLabeledPoints().forEach(l));
      }
      let c = this.renderedPoints[this.hoveredPointId],
        d = this.renderedPoints[this.pressedPointId],
        p = c && c.poi,
        h = d && d.poi;
      p || this.setHoveredPointId(void 0), h || this.setPressedPointId(void 0);
      let u = h || p, f, y;
      if (
        u
          ? (f = u.type === "movable-point" && u.tableInfo &&
            u.tableInfo.dragX,
            y = u.type === "movable-point" && u.tableInfo &&
              u.tableInfo.dragY,
            f && y || !f && !y
              ? this.grapher.setLayerClass(
                "movablePoints",
                "dcg-mouse-over-movable-point",
              )
              : f
              ? this.grapher.setLayerClass(
                "movablePoints",
                "dcg-mouse-over-movable-point-ew",
              )
              : this.grapher.setLayerClass(
                "movablePoints",
                "dcg-mouse-over-movable-point-ns",
              ))
          : this.grapher.setLayerClass("movablePoints", void 0),
          !this.getPOIUnderAttention()
      ) {
        this.lastAriaAlert = void 0;
        return;
      }
      this.speakThrottledAlert();
    }
    _clampedOpacity(e) {
      return e < 0
        ? 0
        : e > 1
        ? 1
        : __dcg_shared_module_exports__["J"](e)
        ? e
        : 1;
    }
    getAllRenderedObjects(e) {
      return this.renderedPointsIdOrder.filter((t) =>
        e ? this.renderedPoints[t].type === e : true
      ).map((t) => this.renderedPoints[t]);
    }
    getOrderedTabTargets(e) {
      let t = [];
      return this.renderedPointsIdOrder.forEach((o) => {
        let i = this.renderedPoints[o];
        if (e && i.type !== e || this.getTabIndex(o) === -1) return;
        let n = i.poi;
        t.push({
          calcId: n.sketch.id,
          listIndex: n.listIndex,
          polygonEdge: void 0,
          description: this.getAriaLabel(o),
        });
      }),
        t;
    }
    redrawToCtx(e, t, o, i) {
      let n = this.grapher.graphSketches;
      for (let a of o) {
        let s = n[a];
        if (!s) continue;
        let l = s.branches[0], c, d;
        __dcg_shared_module_exports__["$d"](l) &&
        (c = l.pointOpacity, d = l.pointSize !== void 0 ? l.pointSize : 8),
          s.getMovablePoints().forEach((p) => {
            let h;
            if (i.renderForScreenshot) {
              h = {
                screenX: t.mapx(p.x),
                screenY: t.mapy(p.y),
                color: p.color,
                pointOpacity: c,
                pointSize: d,
                animationPercent: 0,
              };
            } else if (
              h = this.renderedPoints[p.id], !h || h.type !== "movable"
            ) return;
            i.showMovablePoints
              ? this.drawMovablePointOnCtx(e, p.sketch, h)
              : Td.drawPointToCtx({
                ctx: e,
                projection: t,
                x: p.x,
                y: p.y,
                alpha: c,
                sketch: p.sketch,
                sizeFactor: 1,
                opacityFactor: 1,
                colorOverride: p.color,
                finalHardcodedSize: d,
              });
          });
      }
    }
    processPOI(e, t, o, i) {
      let n = t.id,
        a = t.x,
        s = t.y,
        l = e.mapx(a),
        c = e.mapy(s),
        d = e.coordsAreOnscreen(l, c, 20);
      if (!d && !i) return;
      let p = t.sketch
          ? this.grapher.controller.getItemModel(t.sketch.id)
          : void 0,
        h = !!(p && Sa(p));
      if (
        !(p && this.grapher.controller.shouldIgnoreGraphInteractions(p))
      ) {
        return o || (t.type === "movable-point"
          ? o = {
            type: "movable",
            id: n,
            pointOnScreen: d,
            poi: t,
            projection: e,
            screenX,
            screenY,
            color: Nb(t, "color"),
            pointOpacity: Nb(t, "pointOpacity"),
            pointSize: Nb(t, "pointSize"),
            pointIsHovered: false,
            pointIsPressed: false,
            selected: h,
            lastHoverActionTime: 0,
            animationPercent: 0,
          }
          : p && p.type === "expression" && p.label !== void 0 &&
              p.showLabel && Ro(p) !== "NONE"
          ? o = {
            type: "draggable-label",
            id: n,
            pointOnScreen: d,
            selected: h,
            poi: t,
            projection: e,
            screenX,
            screenY,
          }
          : o = {
            type: "static",
            id: n,
            pointOnScreen: d,
            poi: t,
            projection: e,
            screenX,
            screenY,
            selected: h,
          }),
          o.pointOnScreen = d,
          o.poi = t,
          o.projection = e,
          o.screenX = l,
          o.screenY = c,
          o.type === "movable" &&
          (o.color = Nb(o.poi, "color"),
            o.pointOpacity = Nb(o.poi, "pointOpacity"),
            o.pointSize = Nb(o.poi, "pointSize"),
            o.selected = h,
            this.updateMovablePointAnimation(o, i)),
          o;
      }
    }
    drawMovablePointOnCtx(e, t, o) {
      var f;
      let i = o.pointSize / 2 *
        (this.grapher.settings.config.projectorMode ? 1.3 : 1);
      i < 0 && (i = 0), t.showHighlight && (i *= 1.15);
      let n = Array.isArray(o.color) ? o.color[0] : o.color,
        a = o.screenX,
        s = o.screenY,
        l = o.animationPercent || 0;
      e.save();
      let c = e.globalAlpha,
        d = this.shouldDrawGhosted(t.id) ? QS.IS_GHOSTED : cw,
        p = this._clampedOpacity(d * o.pointOpacity);
      p *= (f = this.grapher.controller.getGeoModel().getToolFadeOpacity(
          t.id,
        )) != null
        ? f
        : 1;
      let h = __dcg_shared_module_exports__["Vd"](i);
      e.fillStyle = n,
        e.globalAlpha = .35 * p,
        e.beginPath(),
        e.moveTo(a + h, s),
        e.arc(a, s, h, 0, Math.PI * 2, true),
        e.closePath(),
        e.fill(),
        e.globalAlpha = p,
        (t.tokenHovered || !!this.geoHoveredObjects[t.id]) &&
        (i = .7 * i + .3 * h),
        i = i + (h - i) * l,
        e.beginPath(),
        e.moveTo(a + i, s),
        e.arc(a, s, i, 0, Math.PI * 2, true),
        e.closePath(),
        e.fill(),
        e.globalAlpha = c,
        e.restore();
    }
    updateMovablePointAnimation(e, t) {
      let o = Date.now(),
        i = e.id,
        n = this.hoveredPointId === i || t,
        a = this.pressedPointId === i;
      e.pointIsPressed = a,
        n !== e.pointIsHovered &&
        (e.pointIsHovered = n, e.lastHoverActionTime = o);
      let s = e.animationPercent || 0,
        c = .004 * (o - e.lastHoverActionTime);
      a
        ? s = 1
        : n
        ? (s += c, s >= 1 ? s = 1 : this.requestRedrawNextFrame())
        : (s -= c, s <= 0 ? s = 0 : this.requestRedrawNextFrame()),
        e.animationPercent = s;
    }
    shouldDrawGhosted(e) {
      if (!e) return false;
      let t = this.grapher.controller.getItemModel(e);
      return !t || t.type !== "expression" ? false : Hi(t);
    }
    getTabIndex(e) {
      if (this.grapher.controller.getActiveTool() !== "selection") {
        return -1;
      }
      let t = this.renderedPoints[e];
      if (!t) return -1;
      let o = t.poi,
        i = this.grapher.controller.getItemEditableLabelMode(o.sketch.id),
        n = this.grapher.controller.getItemModel(o.sketch.id),
        a = n && n.type === "expression" && !$n(n) &&
          (t.type === "movable" || i === void 0 || i === "NONE"),
        s = this.grapher.settings,
        l = s.config.graphpaper && s.config.enableTabindex;
      return a && l ? 0 : -1;
    }
    getAriaHidden() {
      return !this.grapher.settings.config.graphpaper;
    }
    getAriaLabel(e) {
      let t = this.getAriaAlert({ id: e, includeUsageInstructions: false });
      return t && t.completeMessage;
    }
    speakAriaAlert() {
      var i;
      let e = (i = this.getPOIUnderAttention()) == null ? void 0 : i.id;
      if (e) {
        let n = this.renderedPoints[e];
        if (!n || n.type === "static") {
          return this.lastAriaAlert = void 0, false;
        }
      }
      let t = this.getAriaAlert({
          id: e,
          lastAriaAlert: this.lastAriaAlert,
          includeUsageInstructions: true,
        }),
        o = !this.lastAriaAlert || this.lastAriaAlert.id !== e ||
          !!(t != null && t.updated);
      return this.lastAriaAlert = t,
        t != null && t.completeMessage
          ? (o && xe(t.completeMessage), true)
          : false;
    }
    getAriaAlert(e) {
      var U, z;
      let { id: t, lastAriaAlert: o, includeUsageInstructions: i } = e;
      if (!t) return;
      let n = this.renderedPoints[t];
      if (!n) return;
      let { controller: a } = this.grapher,
        s = n.poi.sketch ? a.getItemModel(n.poi.sketch.id) : void 0;
      if (!s || s.type !== "expression") return;
      o && o.id !== t && (o = void 0);
      let l = n.poi,
        c = n.pointOnScreen,
        d = n.projection,
        p = ((U = s == null ? void 0 : s.formula.typed_constant_value) ==
              null
            ? void 0
            : U.valueType) === __dcg_shared_module_exports__["Complex"]
          ? (z = s == null ? void 0 : s.formula.typed_constant_value) ==
              null
            ? void 0
            : z.value
          : void 0;
      if (!l || !d || !d.viewport) return;
      let u = o == null ? void 0 : o.label, f = l.ariaLabel;
      a.isGeometry() && il(s) &&
        (f = AT(s, a, { poi: l, includeDetails: false }).join(" "));
      let y = u !== f,
        C = n.selected,
        E = !!(o != null && o.selected) !== C,
        v = l.x,
        w = l.y,
        S = v !== (o == null ? void 0 : o.coordX) ||
          w !== (o == null ? void 0 : o.coordY),
        k = o && (y || E || S),
        _ = f ||
          a.s("graphing-calculator-narration-movable-point-prefix"),
        A = !a.isGeometry() &&
            (n.type === "movable" || n.type === "draggable-label") && i
          ? a.s(
            "graphing-calculator-narration-movable-point-suffix-usage-instructions",
          )
          : "",
        P = c ? "" : a.s(
          "graphing-calculator-narration-movable-point-off-screen-prompt",
        ),
        O;
      if (
        o
          ? y || !S && E
            ? O = _ + P
            : S
            ? p
              ? O = `${
                Ao(__dcg_shared_module_exports__["complexNumberLabel"](p))
              }${P}`
              : O = `${Bl(a, v)} ${Ul(a, w)}${P}`
            : E
            ? O = _
            : O = o.completeMessage
          : O = `${
            a.s("graphing-calculator-narration-item-at-coordinates", {
              itemDescription: _,
              coordinates: p
                ? Ao(__dcg_shared_module_exports__["complexNumberLabel"](p))
                : ll(a, v, w),
            })
          }${A}${P}`,
          (!o || k) && a.isGeometry() &&
          (n.type === "movable" || n.type === "draggable-label")
      ) {
        let x = a.getActiveTool();
        (x === "selection" || x === "box-selection") &&
          (O = nP(O || f || "", s, a));
      }
      return {
        id: t,
        coordX: v,
        coordY: w,
        label: f,
        selected: C,
        completeMessage: O,
        updated: k,
      };
    }
    setHoveredPointId(e) {
      e !== this.hoveredPointId &&
        (this.hoveredPointId = e, this.requestRedrawNextFrame());
    }
    isMovingPoint() {
      return !!this.pressedPointId;
    }
    setPressedPointId(e) {
      e !== this.pressedPointId &&
        (this.pressedPointId = e, this.requestRedrawNextFrame());
    }
    getPOIUnderAttention() {
      let e = this.grapher.poiController.keyboardAttentionManager
        .getKeyboardAttention();
      if (!e) return;
      let t = e.listIndex || 0;
      for (let o in this.renderedPoints) {
        let n = this.renderedPoints[o].poi;
        if (n.sketch.id === e.calcId && n.listIndex === t) return n;
      }
    }
    setGeoHoveredObjects(e) {
      __dcg_shared_module_exports__["E"](e, this.geoHoveredObjects) ||
        (this.geoHoveredObjects = e, this.requestRedrawNextFrame());
    }
    requestRedrawNextFrame() {
      this.grapher.controller.requestRedrawGraph();
    }
  };
  function ll(r, e, t) {
    return Bl(r, e) + " " + Ul(r, t);
  }
  function Bl(r, e) {
    let t = r.getGraphSettings().showXAxis, o = r.get2dProjection();
    if (!o) return "";
    let { width: i } = o.screen;
    return t
      ? r.s("graphing-calculator-narration-audio-trace-property-x", {
        x: Ao(__dcg_shared_module_exports__["value"](e, Ng(o, e)).latex),
      })
      : r.s("graphing-calculator-narration-x-percentage-coordinate", {
        x: Math.round(o.mathToPixels.mapX(e) / i * 1e3) / 10,
      });
  }
  function Ul(r, e) {
    let t = r.getGraphSettings().showYAxis, o = r.get2dProjection();
    if (!o) return "";
    let { height: i } = o.screen;
    return t
      ? r.s("graphing-calculator-narration-audio-trace-property-y", {
        y: Ao(__dcg_shared_module_exports__["value"](e, Ng(o, e)).latex),
      })
      : r.s("graphing-calculator-narration-y-percentage-coordinate", {
        y: Math.round(o.mathToPixels.mapY(e) / i * 1e3) / 10,
      });
  }
  function Xr(r, e) {
    if (!r) return "";
    let { controller: t } = r;
    if (r.type === "expression") {
      let o = t.isItemSecret(r.id);
      switch (e) {
        case "describe":
          return o
            ? t.s(
              "graphing-calculator-narration-describe-secret-expression",
              { index: r.secretIndex },
            )
            : t.s("graphing-calculator-narration-describe-expression", {
              index: r.displayIndex,
            });
        case "delete":
          return o
            ? t.s(
              "graphing-calculator-narration-delete-secret-expression",
              { index: r.secretIndex },
            )
            : t.s("graphing-calculator-narration-delete-expression", {
              index: r.displayIndex,
            });
        case "duplicate":
          return o
            ? t.s(
              "graphing-calculator-narration-duplicate-secret-expression",
              { index: r.secretIndex },
            )
            : t.s("graphing-calculator-narration-duplicate-expression", {
              index: r.displayIndex,
            });
        case "show":
          return o
            ? t.s(
              "graphing-calculator-narration-show-secret-expression",
              { index: r.secretIndex },
            )
            : t.s("graphing-calculator-narration-show-expression", {
              index: r.displayIndex,
            });
        case "hide":
          return o
            ? t.s(
              "graphing-calculator-narration-hide-secret-expression",
              { index: r.secretIndex },
            )
            : t.s("graphing-calculator-narration-hide-expression", {
              index: r.displayIndex,
            });
        case "show-options":
          return o
            ? t.s(
              "graphing-calculator-narration-show-options-secret-expression",
              { index: r.secretIndex },
            )
            : t.s(
              "graphing-calculator-narration-show-options-expression",
              { index: r.displayIndex },
            );
        case "hide-options":
          return o
            ? t.s(
              "graphing-calculator-narration-hide-options-secret-expression",
              { index: r.secretIndex },
            )
            : t.s(
              "graphing-calculator-narration-hide-options-expression",
              { index: r.displayIndex },
            );
        case "create_table":
          return o
            ? t.s(
              "graphing-calculator-narration-create-table-secret-expression",
              { index: r.secretIndex },
            )
            : t.s(
              "graphing-calculator-narration-create-table-expression",
              { index: r.displayIndex },
            );
        case "rename":
          return o
            ? t.s(
              "graphing-calculator-narration-rename-secret-expression",
              { index: r.secretIndex },
            )
            : t.s("graphing-calculator-narration-rename-expression", {
              index: r.displayIndex,
            });
        case "mute":
          return o
            ? t.s(
              "graphing-calculator-narration-mute-secret-expression",
              { index: r.secretIndex },
            )
            : t.s("graphing-calculator-narration-mute-expression", {
              index: r.displayIndex,
            });
        case "unmute":
          return o
            ? t.s(
              "graphing-calculator-narration-unmute-secret-expression",
              { index: r.secretIndex },
            )
            : t.s("graphing-calculator-narration-unmute-expression", {
              index: r.displayIndex,
            });
      }
    }
    if (r.type === "image") {
      switch (e) {
        case "describe":
          return t.s("graphing-calculator-narration-describe-image", {
            index: r.displayIndex,
          });
        case "delete":
          return t.s("graphing-calculator-narration-delete-image", {
            index: r.displayIndex,
          });
        case "duplicate":
          return t.s("graphing-calculator-narration-duplicate-image", {
            index: r.displayIndex,
          });
        case "show":
          return t.s("graphing-calculator-narration-show-image", {
            index: r.displayIndex,
          });
        case "hide":
          return t.s("graphing-calculator-narration-hide-image", {
            index: r.displayIndex,
          });
        case "show-options":
          return t.s("graphing-calculator-narration-show-options-image", {
            index: r.displayIndex,
          });
        case "hide-options":
          return t.s("graphing-calculator-narration-hide-options-image", {
            index: r.displayIndex,
          });
        case "edit_title":
          return t.s("graphing-calculator-narration-edit-image-title", {
            index: r.displayIndex,
          });
      }
    }
    if (r.type === "text") {
      switch (e) {
        case "describe":
          return t.s("graphing-calculator-narration-describe-text", {
            index: r.displayIndex,
          });
        case "delete":
          return t.s("graphing-calculator-narration-delete-text", {
            index: r.displayIndex,
          });
        case "duplicate":
          return t.s("graphing-calculator-narration-duplicate-text", {
            index: r.displayIndex,
          });
        case "show":
          return t.s("graphing-calculator-narration-show-text", {
            index: r.displayIndex,
          });
        case "hide":
          return t.s("graphing-calculator-narration-hide-text", {
            index: r.displayIndex,
          });
        case "edit_title":
          return t.s("graphing-calculator-narration-edit-text-title", {
            index: r.displayIndex,
          });
      }
    }
    if (r.type === "table") {
      switch (e) {
        case "describe":
          return t.s("graphing-calculator-narration-describe-table", {
            index: r.displayIndex,
          });
        case "delete":
          return t.s("graphing-calculator-narration-delete-table", {
            index: r.displayIndex,
          });
        case "duplicate":
          return t.s("graphing-calculator-narration-duplicate-table", {
            index: r.displayIndex,
          });
        case "show":
          return t.s("graphing-calculator-narration-show-table", {
            index: r.displayIndex,
          });
        case "hide":
          return t.s("graphing-calculator-narration-hide-table", {
            index: r.displayIndex,
          });
        case "rename":
          return t.s("graphing-calculator-narration-rename-table", {
            index: r.displayIndex,
          });
      }
    }
    if (r.type === "folder") {
      let o = !!r.title;
      switch (e) {
        case "describe":
          return o
            ? t.s("graphing-calculator-narration-describe-folder-title", {
              folder: r.title,
            })
            : t.s("graphing-calculator-narration-describe-folder-index", {
              index: r.displayIndex,
            });
        case "collapse":
          return o
            ? t.s("graphing-calculator-narration-collapse-folder-title", {
              folder: r.title,
            })
            : t.s("graphing-calculator-narration-collapse-folder-index", {
              index: r.displayIndex,
            });
        case "expand":
          return o
            ? t.s("graphing-calculator-narration-expand-folder-title", {
              folder: r.title,
            })
            : t.s("graphing-calculator-narration-expand-folder-index", {
              index: r.displayIndex,
            });
        case "show":
          return o
            ? t.s("graphing-calculator-narration-show-folder-title", {
              folder: r.title,
            })
            : t.s("graphing-calculator-narration-show-folder-index", {
              index: r.displayIndex,
            });
        case "hide":
          return o
            ? t.s("graphing-calculator-narration-hide-folder-title", {
              folder: r.title,
            })
            : t.s("graphing-calculator-narration-hide-folder-index", {
              index: r.displayIndex,
            });
        case "duplicate":
          return o
            ? t.s(
              "graphing-calculator-narration-duplicate-folder-title",
              { folder: r.title },
            )
            : t.s(
              "graphing-calculator-narration-duplicate-folder-index",
              { index: r.displayIndex },
            );
        case "delete":
          return o
            ? t.s("graphing-calculator-narration-delete-folder-title", {
              folder: r.title,
            })
            : t.s("graphing-calculator-narration-delete-folder-index", {
              index: r.displayIndex,
            });
        case "edit_title":
          return t.s("graphing-calculator-narration-edit-folder-title", {
            index: r.displayIndex,
          });
      }
    }
    switch (e) {
      case "describe":
        return t.s("graphing-calculator-narration-describe");
      case "delete":
        return t.s("graphing-calculator-narration-delete");
      case "duplicate":
        return t.s("graphing-calculator-narration-duplicate");
      case "expand":
        return t.s("graphing-calculator-narration-expand");
      case "collapse":
        return t.s("graphing-calculator-narration-collapse");
      case "show":
        return t.s("graphing-calculator-narration-show");
      case "hide":
        return t.s("graphing-calculator-narration-hide");
      case "show-options":
        return t.s("graphing-calculator-narration-show-options");
      case "hide-options":
        return t.s("graphing-calculator-narration-hide-options");
      case "create_table":
        return t.s("graphing-calculator-narration-create-table");
      case "rename":
        return t.s("graphing-calculator-narration-rename");
      case "edit_title":
        return t.s("graphing-calculator-narration-edit-title");
      case "mute":
        return t.s("graphing-calculator-narration-mute");
      case "unmute":
        return t.s("graphing-calculator-narration-unmute");
      default:
        return e;
    }
  }
  function Fo(r, e, t = { includeDetails: true }) {
    var s, l, c;
    if (!r) {
      return e.s(
        "graphing-calculator-narration-geometry-nothing-selected",
      );
    }
    let o = t.description ? t.description : "";
    if (r.type !== "expression") {
      if (r.type === "image") {
        let d = o !== "" ? o : Xr(r, "describe"),
          p = t.listIndex || 0,
          { x: h, y: u } = r.formula.dimensions;
        h && u && typeof h[p] == "number" && typeof u[p] == "number"
          ? o = e.s("graphing-calculator-narration-item-at-coordinates", {
            itemDescription: d,
            coordinates: ll(e, h[p], u[p]),
          })
          : o = d;
      }
    } else {(!r.latex ||
        !((s = r.formula) != null && s.typed_constant_value)) &&
        (o = o !== "" ? o : Xr(r, "describe"));}
    let i = t.poi && t.poi.sketch.showPOI &&
        t.poi.type === "static-labeled-point",
      n = r.type === "expression" &&
          ((l = r.formula.typed_constant_value) == null
              ? void 0
              : l.valueType) === __dcg_shared_module_exports__["Complex"]
        ? (c = r.formula.typed_constant_value) == null ? void 0 : c.value
        : void 0;
    !o && il(r)
      ? (o = xre(r, e, t), o = vre(o, r, e, t))
      : t.includeDetails && t.poi && !i &&
        (o = n ? o : e.s("graphing-calculator-narration-item-at-coordinates", {
          itemDescription: o,
          coordinates: ll(e, t.poi.x, t.poi.y),
        }));
    let a = o;
    return t.includeSelectionState && !nb(r) && !i && (a = nP(a, r, e)),
      nb(r) &&
      (a = e.s("shared-calculator-narration-item-clickable", {
        item: a,
      })),
      a;
  }
  function xre(r, e, t = { includeDetails: true }) {
    var l;
    let { value: o, valueType: i } = Ap(r, t);
    if (!o) return e.s("shared-calculator-narration-item-unknown");
    let n = [];
    if (__dcg_shared_module_exports__["isList"](i)) n = XH(r, e, t);
    else {switch (i) {
        case __dcg_shared_module_exports__["Point"]:
          n = AT(r, e, t);
          break;
        case __dcg_shared_module_exports__["Circle"]:
          n = KH(r, e, t);
          break;
        case __dcg_shared_module_exports__["Arc"]:
          n = WH(r, e, t);
          break;
        case __dcg_shared_module_exports__["Polygon"]:
          n = $H(r, e, t);
          break;
        case __dcg_shared_module_exports__["Line"]:
        case __dcg_shared_module_exports__["Ray"]:
        case __dcg_shared_module_exports__["Segment"]:
        case __dcg_shared_module_exports__["Vector"]:
          n = jH(r, e, t);
          break;
        case __dcg_shared_module_exports__["AngleMarker"]:
        case __dcg_shared_module_exports__["DirectedAngleMarker"]:
          n = YH(r, e, t);
          break;
        default:
          n.push(e.s("shared-calculator-narration-item-unknown"));
      }}
    let a = n.join(" "),
      s = (l = r.formula.geometry) == null ? void 0 : l.call;
    return s && (a = wre(a, s, e)), a;
  }
  function wre(r, e, t) {
    let o, i = e.parents;
    if (e.symbol === "apply") {
      let n = i[0].type !== "arbitrary-expression"
          ? __dcg_shared_module_exports__["Cc"](i[0])
          : void 0,
        a = n ? t.getItemsByIdentifier(n) : [];
      if (n && a.length === 0) o = n;
      else {for (let s of a) {
          if (s.type !== "expression") continue;
          let l = s.formula.geometry;
          if (!(!l || !l.call)) {
            o = l.call.symbol;
            break;
          }
        }}
    } else if (__dcg_shared_module_exports__["Dc"](e.symbol)) {
      o = e.symbol;
    } else return r;
    switch (o) {
      case "coterminal":
      case "supplement":
        return r;
      case "dilate":
        return t.s(
          "graphing-calculator-narration-geometry-dilated-item",
          { item: r },
        );
      case "rotate":
        return t.s(
          "graphing-calculator-narration-geometry-rotated-item",
          { item: r },
        );
      case "translate":
        return t.s(
          "graphing-calculator-narration-geometry-translated-item",
          { item: r },
        );
      case "reflect":
        return t.s(
          "graphing-calculator-narration-geometry-reflected-item",
          { item: r },
        );
      default:
        return t.s(
          "graphing-calculator-narration-geometry-transformed-item",
          { item: r },
        );
    }
  }
  function vre(r, e, t, o) {
    var i, n;
    return o.listIndex !== void 0 &&
        ((n = (i = e.formula) == null ? void 0 : i.geometry) != null &&
          n.valueType) &&
        __dcg_shared_module_exports__["isList"](e.formula.geometry.valueType)
      ? t.s("graphing-calculator-narration-item-with-list-index", {
        listIndex: o.listIndex + 1,
        item: r,
      })
      : o.polygonEdge !== void 0
      ? t.s("graphing-calculator-narration-geometry-edge-of-polygon", {
        polygonEdge: o.polygonEdge + 1,
        item: r,
      })
      : r;
  }
  function nP(r, e, t) {
    return (e && Sa(e)
      ? t.s("shared-calculator-narration-item-selected", { item: r })
      : t.s("shared-calculator-narration-item-unselected", { item: r }))
      .trim();
  }
  function rt(r) {
    return {
      shouldBeFocused: () => Bg(r),
      onFocusedChanged: (e) => {
        aP(r, e);
      },
    };
  }
  function Bg(r) {
    let e = r.predicate;
    if (e && !e()) return false;
    let t = r.controller.getFocusLocation();
    return t && __dcg_shared_module_exports__["E"](t, r.location);
  }
  function aP(r, e) {
    let t = r.predicate;
    t && !t() ||
      (e
        ? r.controller.dispatch({
          type: "set-focus-location",
          location: r.location,
        })
        : r.controller.dispatch({
          type: "blur-focus-location",
          location: r.location,
        }));
  }
  var {
      cos: An,
      sin: Yn,
      max: rh,
      min: Bb,
      abs: ql,
      sign: M8,
      hypot: G8,
      PI: da,
    } = Math,
    av = 22,
    Ki = av / 2,
    Wi = av / 2,
    Ze = (r) => r.toFixed(1),
    lP = {
      type: "arc",
      center: [0, 0],
      radius: 1,
      startAngle: da / 4,
      endAngle: da / 4 + da,
    },
    L8 = [[-1, 0], [0, 1], [1, -1]],
    cP = { start: 0, delta: da / 4 },
    sP = da / 4,
    dP = { angle: da / 8, side: 1 },
    Cre = [
      "dcg-token-perpendicular",
      "dcg-token-parallel",
      "dcg-token-translate",
      "dcg-token-vector",
      "dcg-token-segment",
      "dcg-token-line",
      "dcg-token-ray",
      "dcg-token-angle",
      "dcg-token-angles",
      "dcg-token-directedangle",
      "dcg-token-directedangles",
      "dcg-token-arc",
      "dcg-token-polygon",
    ];
  function P8(r) {
    return Cre.includes(r);
  }
  function V8(r) {
    switch (r.type) {
      case "angle":
      case "angles":
        return Ire(r.start, r.delta);
      case "directedangle":
      case "directedangles":
        return Are(r.start, r.delta);
      case "arc":
        return Mre(r.arcDetails);
      case "polygon":
        return Gre(r.points);
      case "segment":
        return Lre(r.angle);
      case "line":
        return Pre(r.angle);
      case "anglebisector":
      case "ray":
        return Vre(r.angle);
      case "vector":
      case "translate":
        return Ore(r.angle);
      case "parallel":
        return Rre(r.angle, r.side);
      case "perpendicular":
        return Fre(r.angle);
    }
  }
  function O8(r, e, t) {
    var o, i, n, a, s, l, c;
    switch (r) {
      case "angle":
      case "angles":
      case "directedangle":
      case "directedangles": {
        let d = (o = Sre(r, e)) != null ? o : cP,
          { start: p, delta: h } = d;
        return { type: r, start: p, delta: h };
      }
      case "arc": {
        let d = (i = Ere(e)) != null ? i : lP;
        return { type: r, arcDetails: d };
      }
      case "polygon": {
        let d = (n = Tre(e)) != null ? n : L8;
        return { type: r, points: d };
      }
      case "perpendicular":
      case "anglebisector":
      case "ray":
      case "line":
      case "segment": {
        let d = (a = R8(e)) != null ? a : sP;
        return { type: r, angle: d };
      }
      case "translate": {
        let d = (s = kre(e)) != null ? s : sP;
        return { type: r, angle: d };
      }
      case "vector": {
        let d = (l = Dre(e)) != null ? l : sP;
        return { type: r, angle: d };
      }
      case "parallel": {
        let { angle: d, side: p } = (c = _re(e, t)) != null ? c : dP;
        return { type: r, angle: d, side: p };
      }
    }
  }
  function Sre(r, e) {
    if (
      (e == null ? void 0 : e.valueType) !==
        __dcg_shared_module_exports__["AngleMarker"] &&
      (e == null ? void 0 : e.valueType) !==
        __dcg_shared_module_exports__["DirectedAngleMarker"]
    ) return;
    let [t, o, i] = e.value;
    return { type: r, start: o, delta: i };
  }
  function Ere(r) {
    return (r == null ? void 0 : r.valueType) ===
        __dcg_shared_module_exports__["Arc"]
      ? __dcg_shared_module_exports__["getArcDetails"](r.value)
      : void 0;
  }
  function Tre(r) {
    return (r == null ? void 0 : r.valueType) ===
        __dcg_shared_module_exports__["Polygon"]
      ? r.value
      : void 0;
  }
  function R8(r) {
    let e = r == null ? void 0 : r.valueType;
    if (
      e !== __dcg_shared_module_exports__["Segment"] &&
      e !== __dcg_shared_module_exports__["Line"] &&
      e !== __dcg_shared_module_exports__["Ray"]
    ) return;
    let [[t, o], [i, n]] = r.value;
    return __dcg_shared_module_exports__["R"](i - t, n - o);
  }
  function Dre(r) {
    if (
      (r == null ? void 0 : r.valueType) !==
        __dcg_shared_module_exports__["Vector"]
    ) return;
    let [e, t] = r.value[0];
    return __dcg_shared_module_exports__["R"](e, t);
  }
  function kre(r) {
    if (
      (r == null ? void 0 : r.valueType) !==
        __dcg_shared_module_exports__["Transformation"]
    ) return;
    let [e, t] = r.value[1];
    return __dcg_shared_module_exports__["R"](e, t);
  }
  function _re(r, e) {
    var i;
    if (
      (r == null ? void 0 : r.valueType) !==
        __dcg_shared_module_exports__["Line"]
    ) return dP;
    let t = (i = R8(r)) != null ? i : dP.angle, o = 1;
    if (e.length === 2) {
      let n = e[0], a = e[1], s = n == null ? void 0 : n.valueType;
      if (
        (s === __dcg_shared_module_exports__["Segment"] ||
          s === __dcg_shared_module_exports__["Line"] ||
          s === __dcg_shared_module_exports__["Ray"]) &&
        (a == null ? void 0 : a.valueType) ===
          __dcg_shared_module_exports__["Point"]
      ) {
        let [l, c] = n.value[0],
          [d, p] = n.value[1],
          [h, u] = a.value,
          f = d - l,
          C = -(p - c),
          E = f,
          v = d - h,
          w = p - u;
        o = C * v + E * w > 0 ? 1 : -1;
      }
    }
    return { angle: t, side: o };
  }
  function F8(r, e) {
    (!isFinite(r) || !isFinite(e)) && (r = cP.start, e = cP.delta);
    let t = An(r),
      o = -Yn(r),
      i = An(r + e),
      n = -Yn(r + e),
      a = rh(0, t, i) - Bb(0, t, i),
      s = rh(0, o, n) - Bb(0, o, n),
      l = ql(e) > da,
      c = l ? 2 : rh(a, s),
      d = .73 * av / c,
      p = d * t,
      h = d * o,
      u = d * i,
      f = d * n,
      y = l ? 0 : (Bb(0, p, u) + rh(0, p, u)) / 2,
      C = l ? 0 : (Bb(0, h, f) + rh(0, h, f)) / 2,
      E = Ki - y,
      v = Wi - C;
    return { x1: p, y1: h, x2: u, y2: f, tx: E, ty: v, r: d };
  }
  function Ire(r, e) {
    let { x1: t, y1: o, x2: i, y2: n, tx: a, ty: s, r: l } = F8(r, e),
      c = .6,
      d = c * t,
      p = c * o,
      h = c * i,
      u = c * n,
      f = ql(e) > da ? 1 : 0,
      y = e > 0 ? 0 : 1,
      C = `M ${Ze(d)} ${Ze(p)} A ${Ze(c * l)} ${Ze(c * l)} 0 ${f} ${y} ${
        Ze(h)
      } ${Ze(u)}`;
    return `<g transform="translate(${a} ${s})"><polyline points="${Ze(t)},${
      Ze(o)
    },0,0,${Ze(i)},${
      Ze(n)
    }" /><path d = "${C}" class="dcg-token-angle-arc"/><path d = "${C} L 0 0" class="dcg-token-angle-fill"/></g>`;
  }
  function Are(r, e) {
    let { x1: t, y1: o, x2: i, y2: n, tx: a, ty: s, r: l } = F8(r, e),
      c = .8,
      d = c * t,
      p = c * o,
      h = __dcg_shared_module_exports__["clamp"](1 / (c * l), 0, 2),
      u = (ql(e) - h) * M8(e),
      f = (e + u) / 2,
      y = c * l * An(r + u),
      C = -c * l * Yn(r + u),
      E = M8(e),
      v = E * 3.5,
      w = E * (60 * da) / 180,
      S = .7,
      k = r + f,
      _ = y + v * Yn(k + w * (1 - S)),
      A = C + v * An(k + w * (1 - S)),
      P = y + v * Yn(k - w * S),
      O = C + v * An(k - w * S),
      U = ql(e) > da ? 1 : 0,
      z = e > 0 ? 0 : 1,
      x = `M ${Ze(d)} ${Ze(p)} A ${Ze(c * l)} ${Ze(c * l)} 0 ${U} ${z} ${
        Ze(y)
      } ${Ze(C)}`,
      L = `M ${Ze(_)} ${Ze(A)} L ${Ze(y)} ${Ze(C)} L ${Ze(P)} ${Ze(O)}`;
    return `<g transform="translate(${a} ${s})"><polyline points="${Ze(t)},${
      Ze(o)
    },0,0,${Ze(i)},${Ze(n)}" />` +
      (ql(e) < .05
        ? ""
        : `<path d = "${x}" class="dcg-token-directedangle-arc"/>`) +
      (ql(e) < .29
        ? ""
        : `<path d = "${L}" class="dcg-token-directedangle-arrowhead"/>`) +
      "</g>";
  }
  function Mre(r) {
    if (r === void 0) return "";
    switch (r.type) {
      case "arc": {
        let { startAngle: e, endAngle: t } = r;
        (!isFinite(e) || !isFinite(t)) &&
          (e = lP.startAngle, t = lP.endAngle);
        let o = t - e, i = .386 * av;
        if (ql(o) > 6.16) {
          return `<circle cx="${Ze(Ki)}" cy="${Ze(Wi)}" r="${Ze(i)}">`;
        }
        if (ql(o) < da / 6) {
          let v = (e + t) / 2, w = i * Yn(v), S = i * An(v);
          return `<path d = "M ${Ze(Ki - w)} ${Ze(Wi - S)} l ${Ze(2 * w)} ${
            Ze(2 * S)
          }" />`;
        }
        let n = .66 * da;
        ql(o) < n && (i /= ql(o) / 2);
        let a = i * An(e),
          s = -i * Yn(e),
          l = i * An(t),
          c = -i * Yn(t),
          d = i * An((e + t) / 2),
          p = -i * Yn((e + t) / 2),
          h = __dcg_shared_module_exports__["clamp"](2 * (da - ql(o)), 0, 1),
          u = h * (Bb(a, l, d) + rh(a, l, d)) / 2,
          f = h * (Bb(s, c, p) + rh(s, c, p)) / 2,
          y = Ki - u,
          C = Wi - f;
        return `<path d = "${`M ${Ze(a + y)} ${Ze(s + C)} A ${Ze(i)} ${
          Ze(i)
        } 0 ${ql(o) > da ? 1 : 0} ${o > 0 ? 0 : 1} ${Ze(l + y)} ${
          Ze(c + C)
        }`}" />`;
      }
      case "rays": {
        let { start1: e, end1: t } = r, o = t[0] - e[0], i = t[1] - e[1];
        (!isFinite(o) || !isFinite(o)) && (o = 1, i = 1);
        let n = G8(o, i), a = 3, s = a * o / n, l = -a * i / n;
        return `<path d = "M ${Ze(Ki - s)} ${Ze(Wi - l)} l ${Ze(-5 * s)} ${
          Ze(-5 * l)
        }" /><path d = "M ${Ze(Ki + s)} ${Ze(Wi + l)} l ${Ze(5 * s)} ${
          Ze(5 * l)
        }" />`;
      }
      case "segment": {
        let { start: e, end: t } = r, o = t[0] - e[0], i = t[1] - e[1];
        (!isFinite(o) || !isFinite(o)) && (o = 1, i = 1);
        let n = G8(o, i), a = 7, s = a * o / n, l = a * i / n;
        return `<path d = "M ${Ze(Ki - s)} ${Ze(Wi - l)} l ${Ze(2 * s)} ${
          Ze(2 * l)
        }" />`;
      }
    }
  }
  function Gre(r) {
    if (r.length < 2) return "";
    r.some((E) => !isFinite(E[0]) || !isFinite(E[1])) && (r = L8);
    let e = r[0];
    r = r.slice(1);
    let t = e[0], o = t, i = e[1], n = i;
    for (let E = 0; E < r.length; E++) {
      let v = r[E][0], w = r[E][1];
      v < t && (t = v), v > o && (o = v), w < i && (i = w), w > n && (n = w);
    }
    let a = (t + o) / 2,
      s = (i + n) / 2,
      l = rh(o - t, n - i),
      c = .8 * av,
      d = (E) => Ki + c * (E - a) / l,
      p = (E) => Wi - c * (E - s) / l,
      h = (E) => `${E[0].toFixed(1)} ${E[1].toFixed(1)}`,
      u = d(e[0]),
      f = p(e[1]);
    if (!isFinite(u) || !isFinite(f)) return "";
    let y = [];
    for (let E of r) {
      let v = d(E[0]), w = p(E[1]);
      if (!isFinite(v) || !isFinite(w)) return "";
      y.push(h([v, w]));
    }
    return `<path d = ${`"M ${h([u, f])} ${
      y.map((E) => `L ${E} `).join(" ")
    } Z"`} />`;
  }
  function pP(r, e, t) {
    let i = 7 * An(r), n = 7 * Yn(-r);
    return `<path d = "M ${Ze(Ki - e * i)} ${Ze(Wi - e * n)} L ${
      Ze(Ki + t * i)
    } ${Ze(Wi + t * n)}" />`;
  }
  function Lre(r) {
    return pP(r, 1, 1);
  }
  function Pre(r) {
    return pP(r, 2, 2);
  }
  function Vre(r) {
    return pP(r, 1, 2);
  }
  function Ore(r) {
    let o = 48 * (da / 180),
      i = 8.5 - 1,
      n = 8.5 - 7 * An(o),
      a = Ki - i * An(r),
      s = Wi + i * Yn(r),
      l = Ki + n * An(r),
      c = Wi - n * Yn(r),
      d = `M ${Ze(a)} ${Ze(s)} L ${Ze(l)} ${Ze(c)}`,
      p = Ki + 8.5 * An(r),
      h = Wi + 8.5 * Yn(-r),
      u = p - 7 * An(r + o / 2),
      f = h + 7 * Yn(r + o / 2),
      y = p - 7 * An(r - o / 2),
      C = h + 7 * Yn(r - o / 2),
      E = `M ${Ze(u)} ${Ze(f)} L ${Ze(p)} ${Ze(h)} L ${Ze(y)} ${Ze(C)}`;
    return `<path d = "${d}"/><path d = "${E}" class="dcg-token-vector-arrowhead"/>`;
  }
  function Rre(r, e) {
    let o = 14 * An(r),
      i = 14 * -Yn(r),
      n = 4 * An(r + e * da / 2),
      a = 4 * -Yn(r + e * da / 2);
    return `<path d = "M ${Ze(Ki - o)} ${Ze(Wi - i)} L ${Ze(Ki + o)} ${
      Ze(Wi + i)
    }" /><path d = "M ${Ze(Ki + n - o)} ${Ze(Wi + a - i)} L ${Ze(Ki + n + o)} ${
      Ze(Wi + a + i)
    }" class="dcg-token-parallel-parent"/>`;
  }
  function Fre(r) {
    let t = 14 * An(r), o = 14 * -Yn(r);
    return `<path d = "M ${Ze(Ki - t)} ${Ze(Wi - o)} L ${Ze(Ki + t)} ${
      Ze(Wi + o)
    }" /><path d = "M ${Ze(Ki + o)} ${Ze(Wi - t)} L ${Ze(Ki - o)} ${
      Ze(Wi + t)
    }" class="dcg-token-parallel-parent"/>`;
  }
  var { If: sv } = $i.Components,
    Nre = .8,
    Ad = class extends $i.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return $i.createElement(
          "span",
          {
            class: () => {
              var t, o;
              let e = this.parentOrChildHovered();
              return {
                "dcg-geo-token-view": true,
                "dcg-static-token": (o = (t = this.props).isStatic) == null
                  ? void 0
                  : o.call(t),
                "dcg-selected-token": this.isTokenSelected(),
                "dcg-hidden-token": this.isHidden(),
                "dcg-token-has-label": this.showLabel(),
                "dcg-child-of-hovered-token": e === "child",
                "dcg-parent-of-hovered-token": e === "parent",
                "dcg-assignment-token": !!this.getAssignment(),
                "dcg-graph-interactions-disabled": this
                  .isGraphInteractionDisabled(),
                "dcg-light-color": this.isLightColor(),
              };
            },
            style: () => ({ color: this.getColor() }),
            role: this.bindFn(this.getAriaRole),
            "dcg-token-type": () => this.getTokenInfo().iconType,
            "aria-roledescription": () =>
              this.props.insideGroup() ? void 0 : this.controller.s(
                "graphing-calculator-narration-geometry-construction-role-description",
              ),
            "aria-label": this.bindFn(this.getAriaLabel),
            "aria-selected": this.bindFn(this.isTokenSelected),
            tabIndex: () => this.props.putInTabOrder() ? 0 : -1,
            manageFocus: () =>
              this.props.focusLocation
                ? rt({
                  controller: this.controller,
                  location: this.props.focusLocation(),
                })
                : void 0,
            onTapStart: this.bindFn(this.onTapStart),
            onTap: this.bindFn(this.onTap),
            onPointerOver: this.bindFn(this.onPointerOver),
            onPointerOut: this.bindFn(this.onPointerOut),
          },
          $i.createElement("span", {
            class: $i.const("dcg-token-background"),
          }),
          $i.createElement(
            "span",
            {
              class: () => ({
                "dcg-token-icon": true,
                [this.getAdditionalTokenClass()]: !!this
                  .getAdditionalTokenClass(),
                "dcg-token-is-list": this.getIsList() &&
                  !this.getAssignment(),
              }),
            },
            $i.createElement(
              sv,
              { predicate: () => !!this.getIcon() },
              () =>
                $i.createElement("i", {
                  class: this.bindFn(this.getIcon),
                }),
            ),
            $i.createElement(
              sv,
              { predicate: () => P8(this.getAdditionalTokenClass()) },
              () =>
                $i.createElement("div", {
                  willUnmount: () => this.willUnmountSVG(),
                  didMount: (e) => this.didMountSVG(e),
                }),
            ),
          ),
          $i.createElement(
            sv,
            { predicate: () => !!this.getAssignment() },
            () =>
              $i.createElement(nt, {
                latex: this.bindFn(this.getAssignment),
                config: this.const({}),
              }),
          ),
          $i.createElement(
            sv,
            { predicate: () => this.showLabel() },
            () =>
              $i.createElement("span", {
                class: () => ({ "dcg-token-label": true }),
              }, () => this.getLabel()),
          ),
          $i.createElement(
            sv,
            { predicate: this.bindFn(this.isGraphInteractionDisabled) },
            () => $i.createElement("i", { class: $i.const("dcg-icon-lock") }),
          ),
        );
      }
      isLightColor() {
        let e = this.getColor();
        return !e || this.isTransformation() || this.isHidden() ? false : qf(
          { type: "single-color", value: e },
          this.controller.invertSwatches(),
          Nre,
        );
      }
      didMountSVG(e) {
        this.svgElement = e, this.renderSVGElement();
      }
      willUnmountSVG() {
        this.svgElement = void 0, this.lastSVGInputs = void 0;
      }
      getTypedValue(e) {
        var i;
        if (e === void 0) return;
        let t = this.controller.getItemsByIdentifier(e);
        if (!t || t.length !== 1) return;
        let o = t[0];
        return (i = o == null ? void 0 : o.formula) == null
          ? void 0
          : i.typed_constant_value;
      }
      getParentValues(e) {
        var n, a, s;
        let t = this.controller.getItemsByIdentifier(e);
        if (!t || t.length !== 1) return [];
        let o = t[0],
          i =
            (s = (a = (n = o == null ? void 0 : o.formula) == null
                  ? void 0
                  : n.geometry) == null
                ? void 0
                : a.call) == null
              ? void 0
              : s.parents;
        return i === void 0 ? [] : i.map((l) => {
          if (l.type === "arbitrary-expression") return;
          let c = __dcg_shared_module_exports__["Cc"](l);
          return this.getTypedValue(c);
        });
      }
      renderSVGElement() {
        if (!this.svgElement) return;
        let e = this.props.identifier(),
          t = this.getIconType(),
          o = this.getTypedValue(e),
          i = this.getParentValues(e),
          n = O8(t, o, i);
        n !== void 0 &&
          (__dcg_shared_module_exports__["E"](n, this.lastSVGInputs) ||
            (this.lastSVGInputs = n,
              this.svgElement.innerHTML = `<svg>${V8(n)}</svg>`));
      }
      getAdditionalTokenClass() {
        if (this.getAssignment() || this.hasError()) return "";
        switch (this.getIconType()) {
          case "glider":
            return "dcg-token-glider";
          case "line":
            return "dcg-token-line";
          case "segment":
            return "dcg-token-segment";
          case "ray":
            return "dcg-token-ray";
          case "intersection":
            return "dcg-token-intersection";
          case "midpoint":
            return "dcg-token-midpoint";
          case "parallel":
            return "dcg-token-parallel";
          case "perpendicular":
            return "dcg-token-perpendicular";
          case "anglebisector":
            return "dcg-token-ray";
          case "rotate":
            return "dcg-token-rotate";
          case "circle":
            return "dcg-token-circle";
          case "arc":
            return "dcg-token-arc";
          case "vector":
            return "dcg-token-vector";
          case "dilate":
            return "dcg-token-dilate";
          case "reflect":
            return "dcg-token-reflect";
          case "translate":
            return "dcg-token-translate";
          case "transformation":
            return "dcg-token-transformation";
          case "point":
          case "start":
          case "end":
            return "dcg-token-point";
          case "polygon":
            return "dcg-token-polygon";
          case "angle":
            return "dcg-token-angle";
          case "angles":
            return "dcg-token-angles";
          case "directedangle":
          case "directedangles":
            return "dcg-token-directedangle";
        }
        return "";
      }
      getIdFromParentRef(e) {
        if (e.type === "arbitrary-expression") return;
        let t = __dcg_shared_module_exports__["Cc"](e);
        return this.controller.getExpressionIdForIdentifier(t);
      }
      isGraphInteractionDisabled() {
        let e = this.props.controller().getExpressionIdForIdentifier(
            this.props.identifier(),
          ) || "",
          t = this.controller.getItemModel(e);
        return !!t && (t.type === "expression" || t.type === "image") &&
          !!t.disableGraphInteractions;
      }
      parentOrChildHovered() {
        var c, d, p, h, u, f;
        if (
          !this.props.showParentChildrenHover ||
          !this.props.showParentChildrenHover()
        ) return false;
        let e = this.controller.getHoveredOrFocusedTokenIdentifier(),
          t = this.controller.getExpressionIdForIdentifier(e),
          o = this.props.identifier(),
          i = this.props.controller().getExpressionIdForIdentifier(o) ||
            "";
        if (!t) return false;
        let n = this.controller.getItemModel(t),
          a = this.controller.getItemModel(i);
        if (
          !n || n.type !== "expression" || !a || a.type !== "expression"
        ) return false;
        let s = ((p = (d = (c = n.formula) == null ? void 0 : c.geometry) ==
                null
              ? void 0
              : d.call) == null
            ? void 0
            : p.parents) || [],
          l = ((f = (u = (h = a.formula) == null ? void 0 : h.geometry) ==
                null
              ? void 0
              : u.call) == null
            ? void 0
            : f.parents) || [];
        for (let y = 0; y < s.length; y++) {
          if (this.getIdFromParentRef(s[y]) === i) return "parent";
        }
        for (let y = 0; y < l.length; y++) {
          if (this.getIdFromParentRef(l[y]) === t) return "child";
        }
        return false;
      }
      willUnmount() {
        this.implicitMouseOut();
      }
      didUpdate() {
        this.renderSVGElement();
        let e = this.props.identifier();
        this.currentlyActiveIdentifier &&
          e !== this.currentlyActiveIdentifier && this.implicitMouseOut();
      }
      implicitMouseOut() {
        this.currentlyActiveIdentifier &&
          this.controller.runAfterDispatch(() => {
            let e = this.currentlyActiveIdentifier;
            e &&
              (this.currentlyActiveIdentifier = void 0,
                this.controller.dispatch({
                  type: "unset-active-token",
                  identifier: e,
                  style: "hovered",
                }));
          });
      }
      isHidden() {
        return this.getTokenInfo().isHidden;
      }
      hasError() {
        let e = this.getTokenInfo();
        return !e || e.hasError;
      }
      getIcon() {
        if (this.getAssignment()) return;
        let e = this.getTokenInfo();
        if (this.hasError()) return "dcg-icon-error";
        switch (e.iconType) {
          case "point":
          case "glider":
          case "intersection":
          case "strictintersection":
          case "midpoint":
          case "start":
          case "end":
            return "dcg-icon-point";
          case "dilate":
            return "dcg-icon-dilation";
          case "rotate":
            return "dcg-icon-rotation";
          case "reflect":
            return "dcg-icon-reflection";
          case "transformation":
            return "dcg-icon-title";
          case "angle":
          case "angles":
          case "directedangle":
          case "directedangles":
          case "polygon":
          case "vector":
          case "translate":
          case "apply":
          case "arc":
          case "circle":
          case "clockwise":
          case "counterclockwise":
          case "error":
          case "line":
          case "parallel":
          case "perpendicular":
          case "anglebisector":
          case "ray":
          case "reflex":
          case "segment":
          case "segments":
          case "unknown":
          case "vertices":
            return;
          default:
            return e.iconType;
        }
      }
      showLabel() {
        return !!this.getLabel();
      }
      getLabel() {
        if (this.getAssignment()) return "";
        if (
          this.getIconType() !== "point" &&
          this.getIconType() !== "midpoint"
        ) return false;
        let e = this.getTokenInfo().label.trim();
        return e.length <= 2 ? e : "";
      }
      getAssignment() {
        let e = this.props.identifier();
        return e[0] !== "$"
          ? __dcg_shared_module_exports__["identifierToLatex"](e)
          : "";
      }
      getAriaLabel() {
        let e = this.getTokenInfo(),
          t = Fo(
            this.controller.getItemModel(e == null ? void 0 : e.calcId),
            this.controller,
            { includeDetails: false, depth: 1 },
          );
        return this.isHidden()
          ? this.controller.s(
            "graphing-calculator-narration-geometry-hidden-construction-description",
            { description: t },
          )
          : t;
      }
      isTransformation() {
        var e;
        return ((e = this.getTokenInfo()) == null ? void 0 : e.groupType) ===
          "transformation";
      }
      getColor() {
        if (this.getAssignment()) return;
        let e = this.getTokenInfo();
        if (this.hasError()) return "#fa824c";
        if (!(this.getIconType() === "translate" && !this.isHidden())) {
          return this.isTransformation() || this.isHidden() ? "#aaa" : e.color;
        }
      }
      getIconType() {
        return this.getTokenInfo().iconType;
      }
      getIsList() {
        return this.getTokenInfo().isList;
      }
      getTokenInfo() {
        let e = this.props.identifier();
        return this.controller.getTokenRenderInfoByIdentifier(e);
      }
      onPointerOver(e) {
        var t, o;
        (o = (t = this.props).isStatic) != null && o.call(t) ||
          e.pointerType === "mouse" &&
            (this.currentlyActiveIdentifier = this.props.identifier(),
              this.controller.dispatch({
                type: "set-active-token",
                identifier: this.currentlyActiveIdentifier,
                style: "hovered",
              }));
      }
      onPointerOut(e) {
        var t, o;
        (o = (t = this.props).isStatic) != null && o.call(t) ||
          e.pointerType === "mouse" && this.currentlyActiveIdentifier &&
            (this.controller.dispatch({
              type: "unset-active-token",
              identifier: this.currentlyActiveIdentifier,
              style: "hovered",
            }),
              this.currentlyActiveIdentifier = void 0);
      }
      onTapStart(e) {
        var t, o;
        (o = (t = this.props).isStatic) != null && o.call(t) ||
          e.handle();
      }
      onTap(e) {
        var t, o;
        (o = (t = this.props).isStatic) != null && o.call(t) ||
          (e.handle(),
            this.props.focusLocation &&
            this.controller.dispatch({
              type: "set-focus-location",
              location: this.props.focusLocation(),
            }),
            this.controller.dispatch({
              type: "select-expression-that-defines-token",
              identifier: this.props.identifier(),
              toggle: this.isTokenSelected(),
              multiSelectMode: this.controller.isMultiSelectEnabled() &&
                !!e.shiftKey,
            }));
      }
      isTokenSelected() {
        let e = this.getTokenInfo();
        return !!(e && e.isSelected);
      }
      getAriaRole() {
        var e, t;
        if (!((t = (e = this.props).isStatic) != null && t.call(e))) {
          return this.props.insideGroup() ? "option" : "button";
        }
      }
    };
  var Ub = (r) => {
      let e = function () {
        return r;
      };
      return e.isDcgViewConst = true, e;
    },
    Mb = class {
      constructor(e, t, o) {
        this.tokenController = e, this.mathNode = t, this.isStatic = o;
      }
      updateTokens(e) {
        if (!this.mathNode) return;
        if (!this.lastTokenInfo || this.lastTokenInfo.latex !== e) {
          if (!this.tokenController.doesLatexContainToken(e)) {
            this.lastTokenInfo = { latex: e, tokens: [] };
          } else {
            let o = [];
            this.mathNode.querySelectorAll(".dcg-mq-token").forEach(
              (i) => {
                o.push(i);
              },
            ), this.lastTokenInfo = { latex: e, tokens: o };
          }
        }
        let t = this.lastTokenInfo.tokens;
        for (let o of t) {
          let i = o.dcgTokenView;
          if (i) i.update();
          else {
            let n = o.getAttribute("data-dcg-mq-token") || "",
              a = N8.mountToNode(Ad, o, {
                controller: Ub(this.tokenController),
                identifier: Ub("$" + n),
                insideMQ: Ub(true),
                insideGroup: Ub(false),
                putInTabOrder: Ub(false),
                isStatic: Ub(this.isStatic),
              });
            o.dcgTokenView = a;
          }
        }
      }
    };
  var { If: Bre } = cl.Components,
    zb = 500,
    Ure = 30,
    Fe = class r extends cl.Class {
      constructor() {
        super(...arguments), this.lastLatexProp = "";
      }
      template() {
        return cl.createElement(
          "div",
          { class: cl.const("dcg-mq-container") },
          cl.createElement(
            Bre,
            { predicate: () => this.getPlaceholder().trim().length > 0 },
            () =>
              cl.createElement(
                "span",
                { class: cl.const("dcg-mq-placeholder") },
                cl.createElement(nt, {
                  config: () => this.props.config(),
                  latex: () => this.getPlaceholder(),
                }),
              ),
          ),
          cl.createElement("div", {
            class: () => ({
              "dcg-math-field": true,
              "dcg-no-fadeout": this.props.noFadeout &&
                this.props.noFadeout(),
              "dcg-invalid": this.props.hasError(),
              "dcg-focus": this.props.isFocused(),
            }),
            didMount: (e) => this.didMountMathquill(e),
            "data-dcg-label": () =>
              this.props.dataLabelAttributeValue
                ? this.props.dataLabelAttributeValue()
                : void 0,
          }),
        );
      }
      willUnmount() {
        var e;
        (e = this.mathquillFocus) == null || e.willUnmount(),
          this.mathField = void 0;
      }
      getPlaceholder() {
        return !this.props.placeholder || this.props.isFocused() ||
            this.props.latex()
          ? ""
          : this.props.placeholder();
      }
      didMountMathquill(e) {
        this.cachedConfig = this.getCacheableMQConfig();
        let t = {
          ...this.cachedConfig,
          restrictMismatchedBrackets: "none",
          handlers: {
            reflow: (i) => {
              this.props.onReflow && this.mathField &&
                this.props.onReflow(i);
            },
          },
          onCut: () => {
            this.mathField &&
              this.props.onUserChangedLatex(this.mathField.latex());
          },
          onPaste: () => {
            this.mathField &&
              this.props.onUserChangedLatex(this.mathField.latex());
          },
          overrideTypedText: (i) => {
            this.mathField && this.viewCanAcceptText(i) &&
              (this.props.onUserTypedText
                ? this.props.onUserTypedText(i)
                : (this.mathField.typedText(i),
                  this.props.onUserChangedLatex(this.mathField.latex())));
          },
          overrideKeystroke: (i, n) => {
            if (
              i === "Backspace" && n.preventDefault(), !this.mathField
            ) return;
            if (
              i === "Spacebar" && this.props.disableSpace &&
              this.props.disableSpace()
            ) return n.preventDefault();
            let a = ke(n);
            if (
              a === "Up" || a === "Down" || a === "Left" ||
              a === "Right" || a === "Esc"
            ) {
              let s = [];
              n.ctrlKey && s.push("Ctrl"),
                n.metaKey && s.push("Meta"),
                n.altKey && s.push("Alt"),
                n.shiftKey && s.push("Shift"),
                s.length ? (s.push(a), i = s.join("-")) : i = a;
            }
            this.props.onUserPressedKey
              ? this.props.onUserPressedKey(i, n)
              : (this.mathField.keystroke(i, n),
                this.props.onUserChangedLatex(this.mathField.latex())),
              this.maybeTriggerOnSelectionChange();
          },
        };
        this.props.needsSystemKeypad && this.props.needsSystemKeypad() &&
        (t.substituteTextarea = () => {
          let i = document.createElement("textarea");
          return i.setAttribute("autocorrect", "off"),
            i.setAttribute("autocapitalize", "none"),
            i.setAttribute("spellcheck", "false"),
            i.setAttribute("autocomplete", "off"),
            i;
        }),
          this.props.tokenController &&
          (this.mathquillTokenHelper = new Mb(
            this.props.tokenController(),
            e,
            false,
          )),
          this.$mathField = ee(e);
        let o = gc.MathField(e, t);
        this.mathField = o,
          e._mqMathFieldInstance = this.mathField,
          e._mqViewInstance = this,
          this.mathquillFocus = new Rf(o, this.$mathField, this.props),
          this.$mathField.on("paste.view", (i) => this.onPasteEvent(i)),
          !BS && (Ml || Qx) &&
          this.$mathField.on("keypress.view", (i) => this.onKeypressEvent(i)),
          this.hookupMQTapTouch(o),
          this.updateMathquill();
      }
      getCacheableMQConfig() {
        let e = { ...this.props.config() };
        return this.props.capExpressionSize() && (e.maxDepth = Ure), e;
      }
      didUpdate() {
        this.updateMathquill();
      }
      updateMathquill() {
        var e, t;
        this.updateMathquillConfig(),
          this.updateMathquillAria(),
          this.updateMathquillLatex(),
          (e = this.mathquillFocus) == null || e.updateMathquillFocused(),
          this.updateMathquillPostLabel(),
          (t = this.mathquillTokenHelper) == null ||
          t.updateTokens(this.props.latex());
      }
      onPasteEvent(e) {
        let t = "", o = window.clipboardData, i = e.originalEvent;
        o && o.getData
          ? t = o.getData("Text")
          : i && i.clipboardData && i.clipboardData.getData &&
            (t = i.clipboardData.getData("text/plain"));
        let n = this.viewCanAcceptText(t);
        return !n && this.props.onExpressionSizeExceeded &&
          this.props.onExpressionSizeExceeded(),
          n;
      }
      viewCanAcceptText(e) {
        return r.canAcceptText(
          this.mathField,
          this.props.capExpressionSize(),
          e,
        );
      }
      static canAcceptText(e, t, o) {
        if (!e) return false;
        if (!t) return true;
        let i = e.latex();
        return Of(i) + Of(o) <= zb;
      }
      onKeypressEvent(e) {
        if (e.stopPropagation(), e.preventDefault(), !this.mathField) {
          return;
        }
        let t = e.key && e.key.length === 1 ? e.key : void 0;
        t && this.viewCanAcceptText(t) &&
          (this.props.onUserTypedText
            ? this.props.onUserTypedText(t)
            : (this.mathField.typedText(t),
              this.props.onUserChangedLatex(this.mathField.latex())));
      }
      hookupMQTapTouch(e) {
        this.$mathField.on("dcg-tapstart.view", () => {
          let t = "dcg-tapend.mathquill-selection-change";
          ee(document).on(t, () => {
            this.maybeTriggerOnSelectionChange(), ee(document).off(t);
          });
        }),
          e.ignoreNextMousedown(() => vU.shouldIgnoreMouseDown()),
          this.$mathField.on("dcg-tap.view", (t) => {
            var n;
            let o = t;
            if (
              o.device !== "touch" ||
              o.target.closest(".dcg-mq-ignore-mousedown")
            ) return;
            let i = o.changedTouches[0];
            e.clickAt(i.clientX, i.clientY, i.target),
              (n = this.mathquillFocus) != null && n.isFocused() ||
              e.focus();
          });
      }
      updateMathquillConfig(e = {}) {
        if (!this.mathField) return;
        let t = { ...this.getCacheableMQConfig(), ...e };
        __dcg_shared_module_exports__["E"](t, this.cachedConfig) ||
          (this.cachedConfig = t, this.mathField.config(t));
      }
      updateMathquillAria() {
        if (!this.mathField) return;
        let e = this.props.getAriaLabel();
        e !== this.mathField.getAriaLabel() &&
          this.mathField.setAriaLabel(e);
      }
      updateMathquillPostLabel() {
        this.mathField &&
          this.mathField.setAriaPostLabel(
            this.props.getAriaPostLabel(),
            this.props.hasError() ? 5e3 : 1e3,
          );
      }
      updateMathquillLatex() {
        let e = this.props.latex();
        this.mathField && this.lastLatexProp !== e &&
          (this.props.capExpressionSize() && Of(e) > zb ||
            (this.lastLatexProp = e,
              this.mathField.latex() !== e && this.mathField.latex(e)));
      }
      maybeTriggerOnSelectionChange() {
        let e = this.props.onSelectionChanged;
        if (!e || !this.mathField) return;
        let t = this.mathField.selection();
        __dcg_shared_module_exports__["E"](t, this.lastSelection) ||
          (this.lastSelection = t, e(t));
      }
      static getFocusedMathquill() {
        if (!document.activeElement) return;
        let e = document.activeElement.closest(".dcg-mq-editable-field");
        if (e) return e._mqMathFieldInstance;
      }
      static getMQViewInstance(e) {
        let t = e.el();
        if (t) return t._mqViewInstance;
      }
      static applyArrowKeyAndReturnIfWasAtBounds(e, t, o) {
        let i = e.selection(),
          n = i.startIndex === 0 && i.endIndex === i.latex.length;
        if ((t === "Up" || t === "Down") && n) {
          return e.keystroke(t, o), true;
        }
        e.keystroke(t, o);
        let a = e.selection();
        return !(a.latex !== i.latex || a.startIndex !== i.startIndex ||
          a.endIndex !== i.endIndex);
      }
      static temporarilyOverrideLeftRightIntoCommandGoes(e, t) {
        var n;
        let o = r.getMQViewInstance(e);
        if (!o) return () => {};
        let i = (n = o.getCacheableMQConfig().leftRightIntoCmdGoes) != null
          ? n
          : "up";
        return o.updateMathquillConfig({ leftRightIntoCmdGoes: t }),
          () => o.updateMathquillConfig({ leftRightIntoCmdGoes: i });
      }
      static simulateKeypressFromKeypad(e, t) {
        var n;
        let o = r.getMQViewInstance(e);
        if (!o) return;
        let i = (n = o.getCacheableMQConfig().leftRightIntoCmdGoes) != null
          ? n
          : "up";
        if (
          (t === "Left" || t === "Right") &&
          o.updateMathquillConfig({ leftRightIntoCmdGoes: void 0 }),
            o.props.onUserPressedKey
        ) o.props.onUserPressedKey(t);
        else {
          e.keystroke(t);
          let a = e.latex();
          o.props.onUserChangedLatex(a);
        }
        o.maybeTriggerOnSelectionChange(),
          (t === "Left" || t === "Right") &&
          o.updateMathquillConfig({ leftRightIntoCmdGoes: i });
      }
      static simulateUserChangedLatex(e) {
        let t = r.getMQViewInstance(e);
        if (t && t.mathField) {
          let o = t.mathField.latex();
          t.props.onUserChangedLatex(o);
        }
      }
      static handleKeystrokeAndDecideIfSpecialEvent(e, t, o) {
        return t === "Enter" || t === "Delete" && e.latex() === "" ||
            t === "Backspace" && e.latex() === ""
          ? true
          : t === "Up" || t === "Down" || t === "Left" || t === "Right"
          ? r.applyArrowKeyAndReturnIfWasAtBounds(e, t, o)
          : (e.keystroke(t, o), false);
      }
      static normalizeLatex(e, t) {
        let o = document.createElement("div"), i = gc.MathField(o, t);
        return i.latex(e), i.latex();
      }
    };
  var rs = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { For: zre, If: qre } = rs.Components,
    vo = class extends rs.Class {
      constructor() {
        super(...arguments), this.btnViews = {};
      }
      init() {
        this.config = this.props.staticConfig();
      }
      template() {
        return rs.createElement(
          "div",
          {
            class: rs.const("dcg-segmented-control-container"),
            role: () => {
              var e, t;
              return (t = (e = this.props).treatAsMultiSelect) != null &&
                  t.call(e)
                ? "listbox"
                : "radiogroup";
            },
            "aria-multiselectable": () => {
              var e, t;
              return (t = (e = this.props).treatAsMultiSelect) != null &&
                  t.call(e)
                ? true
                : void 0;
            },
            onKeyDown: this.bindFn(this.handleRadioKeydown),
            "aria-label": this.props.ariaGroupLabel,
          },
          rs.createElement(zre, {
            each: () => this.config,
            key: (e) => e.key,
          }, (e, t) =>
            rs.createElement(
              "div",
              {
                class: () => ({
                  "dcg-segmented-control-btn": true,
                  "dcg-selected": e.selected(),
                  "dcg-theme-mini": this.getTheme() === "mini",
                  "dcg-theme-default": this.getTheme() === "default",
                  "dcg-disabled": this.isDisabled(),
                  [e.class ? e.class() : ""]: !!e.class,
                }),
                role: () => {
                  var o, i;
                  return (i = (o = this.props).treatAsMultiSelect) !=
                        null && i.call(o)
                    ? "option"
                    : "radio";
                },
                tabIndex: () => this.getTabIndexForOption(e),
                "aria-label": () => this.getAriaLabel(e),
                style: () => ({
                  "min-width": this.props.minButtonWidth
                    ? this.props.minButtonWidth() + "px"
                    : void 0,
                }),
                "aria-checked": () => {
                  var o, i;
                  return (i = (o = this.props).treatAsMultiSelect) !=
                        null && i.call(o)
                    ? void 0
                    : e.selected();
                },
                "aria-selected": () => {
                  var o, i;
                  return (i = (o = this.props).treatAsMultiSelect) !=
                        null && i.call(o)
                    ? e.selected()
                    : void 0;
                },
                onTap: (o) => {
                  this.isDisabled() || e.onSelect(o.device);
                },
                didMount: (o) => this.btnViews[t] = o,
                manageFocus: () => {
                  if (e.focusHelperOptions) {
                    return rt(e.focusHelperOptions);
                  }
                },
              },
              rs.createElement(
                Le,
                {
                  tooltip: () => {
                    var o;
                    return ((o = e.tooltip) == null ? void 0 : o.call(e)) || "";
                  },
                  gravity: () => {
                    var o;
                    return ((o = e.tooltipGravity) == null
                      ? void 0
                      : o.call(e)) || "s";
                  },
                  disabled: () => !(e.tooltip && e.tooltip()),
                },
                rs.createElement(
                  "div",
                  { class: rs.const("dcg-segmented-control-interior") },
                  () => e.label ? e.label() : "",
                  rs.createElement(qre, {
                    predicate: () => !!e.icon,
                  }, () =>
                    rs.createElement("i", {
                      class: () => e.icon ? e.icon() : "",
                    })),
                ),
              ),
            )),
        );
      }
      getAriaLabel(e) {
        return e.ariaLabel
          ? e.ariaLabel()
          : e.label
          ? e.label()
          : e.tooltip
          ? e.tooltip()
          : "";
      }
      isDisabled() {
        var e, t;
        return !!((t = (e = this.props).disabled) != null && t.call(e));
      }
      getTheme() {
        return this.props.theme ? this.props.theme() : "default";
      }
      handleRadioKeydown(e) {
        var s, l, c;
        let t = ke(e);
        if (
          t !== "Up" && t !== "Down" && t !== "Left" && t !== "Right" &&
            t !== "Home" && t !== "End" ||
          e.altKey || e.ctrlKey || e.metaKey || e.shiftKey
        ) return;
        e.preventDefault(), e.stopPropagation();
        let o = __dcg_shared_module_exports__["w"](
            this.config,
            (d) => this.btnViews[d.key] === document.activeElement,
          ),
          i = this.config.length,
          n = o;
        t === "Home" && (n = 0),
          t === "End" && (n = this.config.length - 1),
          (t === "Up" || t === "Left") && (n = (o - 1 + i) % i),
          (t === "Down" || t === "Right") && (n = (o + 1) % i);
        let a = this.config[n];
        a &&
          ((s = this.btnViews[a.key]) == null || s.focus(),
            !((c = (l = this.props).treatAsMultiSelect) != null &&
              c.call(l)) && a.onSelect("keyboard"));
      }
      getTabIndexForOption(e) {
        if (this.isDisabled()) return -1;
        let t = e.key === this.config[0].key,
          o = this.config.find((i) => i.selected());
        return e.key === (o == null ? void 0 : o.key) || t && !o ? 0 : -1;
      }
    };
  var Ur = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  function Jr() {
    document.activeElement && wp(document.activeElement) &&
      ee(document.activeElement).trigger("blur");
  }
  var Xn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  function B8(r) {
    if (!r) return;
    let e = [];
    for (let t of r.split(" ")) {
      let o = t.indexOf("|"), i = o !== -1 ? t.slice(0, o) : t;
      e.push(i);
    }
    return e;
  }
  function qb(r, e, t) {
    let o = B8(t);
    return e === "nemeth"
      ? lp(r, { operatorNames: o })
      : e === "ueb"
      ? cp(r, { operatorNames: o })
      : {
        isError: true,
        error: "Braille mode should be 'nemeth' or 'ueb'",
      };
  }
  function YT(r, e, t) {
    let o = B8(t);
    return e === "nemeth"
      ? fM(r, { operatorNames: o })
      : e === "ueb"
      ? bM(r, { operatorNames: o })
      : {
        isError: true,
        error: "Braille mode should be 'nemeth' or 'ueb'",
      };
  }
  var Hb = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var { Input: Hre } = Hb.Components,
    Ug = class extends Hb.Class {
      init() {
        this.ASCIICharacters =
          ` A1B'K2L@CIF/MSP"E3H9O6R^DJG>NTQ,*5<-U8V.%[$+X!&;:4\\0Z7(_?W]#Y)=`,
          this.ASCIITable = [],
          this.HomeRowCharacters = "FDSJKL",
          this.charCodes = [],
          this.sixKeyModel = { keysDown: 0, stickyKeysDown: 0 };
        let e;
        for (e = 0; e < this.ASCIICharacters.length; e++) {
          this.ASCIITable.push(this.ASCIICharacters.charCodeAt(e));
        }
        for (e = 0; e < this.HomeRowCharacters.length; e++) {
          this.charCodes.push(this.HomeRowCharacters.charCodeAt(e));
        }
      }
      template() {
        return Hb.createElement(Hre, {
          class: this.const("dcg-braille-input dcg-do-blur"),
          tabIndex: () => this.props.tabIndex ? this.props.tabIndex() : 0,
          readOnly: () => this.props.isStatic() ? true : void 0,
          autocomplete: this.const("off"),
          autocorrect: this.const("off"),
          autocapitalize: this.const("off"),
          spellcheck: this.const("false"),
          onKeyDown: this.bindFn(this.onKeydown),
          onKeyUp: this.bindFn(this.onKeyUp),
          onInput: this.bindFn(this.props.onInput),
          value: () => this.props.value(),
          "aria-label": () => this.props.ariaLabel() || Gs(""),
          didMount: this.bindFn(this.didMount),
          didUnmount: this.bindFn(this.props.didUnmount),
          placeholder: () =>
            this.props.placeholder ? this.props.placeholder() : "",
          size: () => this.props.size && this.props.size(),
        });
      }
      didMount(e) {
        this.rootNode = e,
          ee(this.rootNode).on("focus", (t) => {
            this.props.shouldFocus() ||
              this.props.onFocusedChanged(true, t.originalEvent || t);
          }).on("blur", (t) => {
            this.props.shouldFocus() &&
              this.props.onFocusedChanged(false, t.originalEvent || t);
          }),
          this.props.didMount(e),
          this.updateFocus();
      }
      didUpdate() {
        this.updateFocus();
      }
      updateFocus() {
        this.rootNode &&
          (this.props.shouldFocus() &&
            document.activeElement !== this.rootNode &&
            this.rootNode.focus(),
            !this.props.shouldFocus() &&
            document.activeElement === this.rootNode &&
            this.rootNode.blur());
      }
      onKeydown(e) {
        let t = this.charCodes.indexOf(e.which);
        !this.props.isStatic() && this.isSixKeyInput() && !e.altKey &&
          !e.ctrlKey && !e.metaKey && !e.shiftKey && t !== -1
          ? (this.sixKeyModel = {
            ...this.sixKeyModel,
            keysDown: this.addKey(this.sixKeyModel.keysDown, t),
            stickyKeysDown: this.addKey(
              this.sixKeyModel.stickyKeysDown,
              t,
            ),
          },
            e.preventDefault())
          : this.props.onKeyDown && this.props.onKeyDown(e);
      }
      onKeyUp(e) {
        let t = this.charCodes.indexOf(e.which), o = false;
        return !this.props.isStatic() && this.isSixKeyInput() &&
            !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey &&
            t !== -1
          ? (this.sixKeyModel = {
            ...this.sixKeyModel,
            keysDown: this.removeKey(this.sixKeyModel.keysDown, t),
          },
            this.sixKeyModel.keysDown === 0 &&
            (this.addCharacter(
              this.bitsToASCII(this.sixKeyModel.stickyKeysDown),
            ),
              this.sixKeyModel = {
                ...this.sixKeyModel,
                stickyKeysDown: 0,
              }))
          : o = true,
          o || e.preventDefault(),
          o;
      }
      addKey(e, t) {
        return e | 1 << t;
      }
      removeKey(e, t) {
        return e & ~(1 << t);
      }
      bitsToASCII(e) {
        return String.fromCharCode(this.ASCIITable[e]);
      }
      addCharacter(e) {
        this.rootNode && !this.props.isStatic() &&
          (this.rootNode.setRangeText(
            e,
            this.rootNode.selectionStart,
            this.rootNode.selectionEnd,
            "end",
          ),
            this.props.onInput(this.rootNode.value));
      }
      isSixKeyInput() {
        return typeof this.props.sixKeyInput == "function" &&
          this.props.sixKeyInput();
      }
    };
  var lv = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Kb = class extends lv.Class {
    template() {
      return lv.createElement(Le, {
        ...this.props,
        customTooltipView: () =>
          lv.createElement(nt, {
            latex: this.props.tooltip,
            config: this.const({}),
          }),
        theme: this.const("light"),
        noWrap: this.const(true),
      }, this.props.children);
    }
  };
  var { If: uP } = Xn.Components,
    Mo = class extends Xn.Class {
      init() {
        this.currentBrailleValue = this.getBrailleFromLatex(
          this.props.latex(),
        ),
          this.currentBrailleMode = this.props.mode(),
          this.hasTranslationError = false,
          this.currentLatex = this.props.latex();
      }
      isFocused() {
        return this.brailleInput !== void 0 &&
          document.activeElement == this.brailleInput;
      }
      getBrailleShouldFocus() {
        return this.props.mode() !== "none" &&
          this.props.brailleShouldFocus &&
          this.props.brailleShouldFocus();
      }
      isStatic() {
        return !!this.props.isStatic && this.props.isStatic();
      }
      isInline() {
        return !!this.props.isInline && this.props.isInline();
      }
      hasError() {
        return !!this.props.hasError && this.props.hasError();
      }
      willUpdate() {
        let e = this.currentLatex !== this.props.latex(),
          t = this.props.mode(),
          o = t !== this.currentBrailleMode && t !== "none";
        this.isFocused() && !e && !o ||
          (this.currentLatex = this.props.latex(),
            (o || !this.hasTranslationError || e || this.isStatic()) &&
            (this.currentBrailleValue = this.getBrailleFromLatex(
              this.props.latex(),
            ),
              this.hasTranslationError = false),
            this.currentBrailleMode = t);
      }
      onBrailleInput(e) {
        if (!this.props.onBrailleInput) return;
        let t = this.getLatexFromBraille(e);
        this.hasTranslationError = t.isError;
        let o = this.props.capExpressionSize &&
          this.props.capExpressionSize();
        if (!t.isError && o && o.exceedsLimit(t.value)) {
          o.onExpressionSizeExceeded();
          return;
        }
        this.currentBrailleValue = e,
          t.isError ||
          (this.currentLatex = t.value, this.props.onBrailleInput(t.value));
      }
      getBrailleFromLatex(e, t = false) {
        let o = qb(
          e,
          this.props.mode(),
          this.props.operatorNames && this.props.operatorNames(),
        );
        return o.isError
          ? ""
          : t
          ? o.value
          : sa.toExpandedBrailleAscii(o.value);
      }
      getLatexFromBraille(e) {
        return YT(
          sa.coerceToSixDotCells(e),
          this.props.mode(),
          this.props.operatorNames && this.props.operatorNames(),
        );
      }
      getBrailleLabel(e) {
        return this.getBrailleFromLatex(e.replace(/\s/, "\\ "));
      }
      shouldShowBraille() {
        let e = this.props.mode();
        return e === "nemeth" || e === "ueb";
      }
      isOverflowingLeft() {
        return this.brailleInput ? this.brailleInput.scrollLeft > 0 : false;
      }
      isOverflowingRight() {
        if (!this.brailleInput) return false;
        let e = this.brailleInput.getBoundingClientRect().width,
          t = this.brailleInput.scrollWidth,
          o = this.brailleInput.scrollLeft;
        return t > e + o + 2;
      }
      didMountBrailleInput(e) {
        this.brailleInput = e;
      }
      didUnmountBrailleInput() {
        this.brailleInput = void 0;
      }
      handleBrailleFocusChanged(e, t) {
        this.props.onBrailleFocusedChanged &&
        this.props.onBrailleFocusedChanged(e, t),
          this.brailleInput &&
          (e && this.props.selectOnFocus && this.props.selectOnFocus() &&
            this.brailleInput.select(),
            this.isStatic() && this.brailleInput.scrollTo(0, 0));
      }
      getTooltipText() {
        let e = this.props.placeholder && !this.isFocused()
          ? this.props.placeholder()
          : "";
        return Gs(this.props.latex() || e);
      }
      template() {
        return Xn.createElement(
          "div",
          { class: Xn.const("dcg-mathquill-wrapper") },
          Xn.createElement(uP, {
            predicate: () => this.shouldShowBraille(),
          }, () =>
            Xn.createElement(
              "div",
              {
                class: () => ({
                  "dcg-mathquill-braille": true,
                  "dcg-text-selectable": this.isStatic(),
                  "dcg-focus": this.getBrailleShouldFocus(),
                  "dcg-invalid": this.hasError(),
                  "dcg-mathquill-static-braille": this.isStatic(),
                  "dcg-mathquill-braille-overflow-left": this
                    .isOverflowingLeft(),
                  "dcg-mathquill-braille-overflow-right": this
                    .isOverflowingRight(),
                }),
                "data-dcg-label": () =>
                  this.props.dataLabelAttributeValue
                    ? this.props.dataLabelAttributeValue()
                    : void 0,
              },
              Xn.createElement(
                Kb,
                {
                  tooltip: () => this.getTooltipText(),
                  gravity: this.const("s"),
                  delay: this.const(0),
                  showOnTapstart: this.const(true),
                },
                Xn.createElement(
                  uP,
                  { predicate: () => this.isInline() },
                  () =>
                    Xn.createElement("span", {
                      class: Xn.const("dcg-inline-braille"),
                    }, () =>
                      Gs(
                        this.getBrailleFromLatex(this.props.latex(), true),
                      )),
                ),
                Xn.createElement(uP, {
                  predicate: () => !this.isInline(),
                }, () =>
                  Xn.createElement(Ug, {
                    ariaLabel: () =>
                      Gs(
                        this.props.ariaLabel
                          ? this.getBrailleLabel(this.props.ariaLabel())
                          : "",
                      ),
                    didMount: this.bindFn(this.didMountBrailleInput),
                    didUnmount: this.bindFn(this.didUnmountBrailleInput),
                    onFocusedChanged: this.bindFn(
                      this.handleBrailleFocusChanged,
                    ),
                    shouldFocus: this.bindFn(this.getBrailleShouldFocus),
                    onKeyDown: this.props.onBrailleKeydown,
                    onInput: this.bindFn(this.onBrailleInput),
                    sixKeyInput: this.props.sixKeyInput,
                    value: () => this.currentBrailleValue,
                    placeholder: () =>
                      Gs(
                        this.props.placeholder
                          ? this.getBrailleFromLatex(
                            this.props.placeholder(),
                          )
                          : "",
                      ),
                    tabIndex: () =>
                      this.props.tabIndex ? this.props.tabIndex() : 0,
                    isStatic: this.bindFn(this.isStatic),
                    size: () =>
                      this.currentBrailleValue &&
                        this.currentBrailleValue.length || 1,
                  })),
              ),
            )),
          Xn.createElement("div", {
            class: Xn.const("dcg-typeset-math"),
            style: () => ({
              display: this.shouldShowBraille() && !this.isInline()
                ? "none"
                : void 0,
            }),
            "aria-hidden": () => this.shouldShowBraille(),
          }, this.props.children),
        );
      }
    };
  function os() {
    if (
      !(!document.activeElement ||
        !document.activeElement.classList.contains("dcg-braille-input"))
    ) return document.activeElement;
  }
  function Wb(r) {
    return !r || r.value === "";
  }
  var U8 = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  function Kre(r) {
    let e = r.target;
    return e.classList.contains("dcg-exp-action-button") ||
      e.classList.contains("dcg-icon-duplicate") ||
      e.classList.contains("dcg-icon-remove") ||
      e.classList.contains("dcg-icon-lock") ||
      e.classList.contains("dcg-icon-pencil");
  }
  var is = class extends U8.Class {
    init() {
      this.controller = this.props.controller(),
        this.model = this.props.model(),
        this.id = this.model.id,
        this._isFirstRender = true,
        this._isDragCopy = this.props.isDragCopy();
    }
    onItemViewMounted(e) {
      this._isDragCopy || (this.model.rootViewNode = e),
        this._isFirstRender = false;
    }
    onItemViewUnmounted() {
      this._isDragCopy || (this.model.rootViewNode = void 0);
    }
    isFirstRender() {
      return this._isFirstRender;
    }
    onMouseSelect(e) {
      if (this.controller.isInEditListMode() && !Kre(e)) {
        this.exitEditListMode();
        return;
      }
      this.controller.isItemReadonly(this.id) ||
        e.type === "dcg-tap" && e.device === "mouse" ||
        e.type === "dcg-tapstart" && e.device === "touch" ||
        e.wasHandled() ||
        (e.handle(),
          this.controller.dispatch({
            type: "set-selected-id",
            id: this.id,
            state: "selected",
          }));
    }
    onDragPending(e) {
      this.controller.isItemReadonly(this.model.id) ||
        this.props.onDragPending(e);
    }
    exitEditListMode() {
      this.controller.dispatch({
        type: "set-edit-list-mode",
        isEditListMode: false,
        focusExpressionList: true,
      });
    }
  };
  var Ht = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: hP } = Ht.Components,
    Hl = class extends Ht.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Ht.createElement(hP, {
          predicate: this.bindFn(this.shouldShowOptions),
        }, () =>
          Ht.createElement(
            "span",
            {
              class: () => ({
                "dcg-expression-edit-actions": true,
                "dcg-limited-height": this.limitedHeight(),
              }),
              didMount: () => {
                this.controller.isInEditListMode() &&
                  xe(
                    this.controller.s(
                      "graphing-calculator-narration-edit-list-mode-on",
                    ),
                  );
              },
              didUnmount: () => {
                this.controller.isInEditListMode() ||
                  xe(
                    this.controller.s(
                      "graphing-calculator-narration-edit-list-mode-off",
                    ),
                  );
              },
            },
            Ht.createElement("span", {
              class: Ht.const("dcg-graphic"),
              handleEvent: Ht.const("true"),
            }),
            Ht.createElement(hP, {
              predicate: () => Sg(this.model()) !== void 0,
            }, () =>
              Ht.createElement(
                Le,
                {
                  tooltip: this.bindFn(this.getConvertTooltip),
                  gravity: this.const("s"),
                },
                Ht.createElement(
                  "span",
                  {
                    class: Ht.const(
                      "dcg-action-createtable dcg-exp-action-button",
                    ),
                    handleEvent: Ht.const("true"),
                    role: Ht.const("button"),
                    tabIndex: Ht.const("0"),
                    "aria-label": () => Xr(this.model(), "create_table"),
                    onTap: this.bindFn(this.onCreateTable),
                  },
                  Ht.createElement("i", {
                    class: Ht.const("dcg-icon-table"),
                    "aria-hidden": Ht.const("true"),
                  }),
                ),
              )),
            Ht.createElement(hP, {
              predicate: () => this.controller.shouldShowAuthorFeatures(),
            }, () =>
              Ht.createElement(
                Le,
                {
                  tooltip: this.bindFn(this.getReadonlyToggleLabel),
                  gravity: this.const("s"),
                },
                Ht.createElement(
                  "span",
                  {
                    class: () => ({
                      "dcg-action-lock": true,
                      "dcg-exp-action-button": true,
                      "dcg-selected": this.isReadonly(),
                    }),
                    handleEvent: Ht.const("true"),
                    role: Ht.const("button"),
                    tabIndex: Ht.const("0"),
                    "aria-label": this.bindFn(
                      this.getReadonlyToggleLabel,
                    ),
                    onTap: this.bindFn(this.onToggleReadonly),
                  },
                  Ht.createElement("i", {
                    class: Ht.const("dcg-icon-lock"),
                    "aria-hidden": Ht.const("true"),
                  }),
                ),
              )),
            Ht.createElement(
              Le,
              {
                tooltip: () =>
                  this.controller.s(
                    "graphing-calculator-label-duplicate-expression-tooltip",
                  ),
                gravity: this.const("s"),
              },
              Ht.createElement(
                "span",
                {
                  class: Ht.const(
                    "dcg-duplicate-btn dcg-exp-action-button",
                  ),
                  handleEvent: Ht.const("true"),
                  role: Ht.const("button"),
                  tabIndex: Ht.const("0"),
                  "aria-label": () => Xr(this.model(), "duplicate"),
                  onTap: this.bindFn(this.onDuplicateWithoutFocus),
                },
                Ht.createElement("i", {
                  class: Ht.const("dcg-icon-duplicate"),
                  "aria-hidden": Ht.const("true"),
                }),
              ),
            ),
            Ht.createElement(
              Le,
              {
                tooltip: () =>
                  this.controller.s(
                    "graphing-calculator-label-expression-delete-tooltip",
                  ),
                gravity: this.const("s"),
              },
              Ht.createElement(
                "span",
                {
                  class: Ht.const("dcg-delete-btn dcg-exp-action-button"),
                  handleEvent: Ht.const("true"),
                  role: Ht.const("button"),
                  tabIndex: Ht.const("0"),
                  "aria-label": () => Xr(this.model(), "delete"),
                  onTap: this.bindFn(this.onDelete),
                },
                Ht.createElement("i", {
                  class: Ht.const("dcg-icon-remove"),
                  "aria-hidden": Ht.const("true"),
                }),
              ),
            ),
          ));
      }
      shouldShowOptions() {
        return this.controller.isInEditListMode() &&
          (this.controller.shouldShowAuthorFeatures() ||
            !this.controller.isItemReadonly(this.props.id()));
      }
      model() {
        return this.controller.getItemModel(this.props.id());
      }
      getConvertTooltip() {
        return ZS(this.model())
          ? this.controller.s("graphing-calculator-label-create-table")
          : this.controller.s(
            "graphing-calculator-label-convert-to-table-tooltip",
          );
      }
      limitedHeight() {
        let e = this.model();
        return e && (e.type === "image" || this.isSlider());
      }
      isSlider() {
        let e = this.model();
        return e && e.type === "expression" && e.sliderExists;
      }
      onCreateTable() {
        let e = this.model();
        e &&
          this.controller.dispatch({
            type: "convert-or-create-table",
            index: e.index,
          });
      }
      onDelete(e) {
        this.controller.dispatch({
          type: "delete-item-and-animate-out",
          id: this.props.id(),
          setFocusAfterDelete: e.device === "keyboard",
        });
      }
      onDuplicateWithoutFocus() {
        let e = this.model();
        e &&
          (e.type === "folder"
            ? this.controller.dispatch({
              type: "duplicate-folder",
              id: this.props.id(),
            })
            : this.controller.dispatch({
              type: "duplicate-expression",
              id: this.props.id(),
            }));
      }
      isReadonly() {
        return this.controller.isItemMarkedReadonly(this.props.id());
      }
      onToggleReadonly() {
        let e = this.model();
        e &&
          this.controller.dispatch({
            type: "set-item-readonly",
            id: this.props.id(),
            readonly: !e.readonly,
          });
      }
      getReadonlyIcon() {
        return this.isReadonly() ? "dcg-icon-lock" : "dcg-icon-pencil";
      }
      getReadonlyToggleLabel() {
        return this.isReadonly()
          ? this.controller.s(
            "graphing-calculator-label-unlock-expression-tooltip",
          )
          : this.controller.s(
            "graphing-calculator-label-lock-expression-tooltip",
          );
      }
    };
  var no = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var ti = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: Wre } = ti.Components,
    zg = class extends ti.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return ti.createElement(
          "div",
          {
            class: ti.const("dcg-action-info"),
            handleEvent: ti.const("true"),
          },
          ti.createElement("span", {
            class: ti.const("dcg-action-label"),
          }, ti.const("Run ")),
          ti.createElement(
            Mo,
            {
              isStatic: this.const(true),
              latex: () => this.model.clickableInfo.latex,
              operatorNames: () => this.getMQConfig().autoOperatorNames,
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-label-ticker-min-step",
                ),
              brailleShouldFocus: this.const(false),
              ...ui(this.controller),
            },
            ti.createElement(nt, {
              latex: () => this.model.clickableInfo.latex,
              config: this.bindFn(this.getMQConfig),
              tokenController: this.props.controller,
            }),
          ),
          ti.createElement("span", {
            class: ti.const("dcg-action-label"),
          }, ti.const(" on click")),
          ti.createElement(Wre, {
            predicate: () => !this.controller.isItemReadonly(this.model.id),
          }, () =>
            ti.createElement(
              "span",
              {
                class: ti.const("dcg-click-edit"),
                role: ti.const("button"),
                tabIndex: ti.const("0"),
                "aria-label": () =>
                  this.controller.s(
                    "graphing-calculator-narration-edit-action",
                  ),
                onTap: this.bindFn(this.editAction),
              },
              ti.createElement("i", {
                class: ti.const("dcg-icon-pencil"),
                "aria-hidden": ti.const("true"),
              }),
            )),
        );
      }
      editAction() {
        this.model.type === "expression"
          ? this.controller.dispatch({
            type: "toggle-item-settings-menu",
            menu: {
              type: "expression",
              model: this.model,
              guid: this.getMenuGUID(),
              focusFirstOption: false,
            },
          })
          : this.controller.dispatch({
            type: "toggle-item-settings-menu",
            menu: {
              type: "image",
              model: this.model,
              guid: this.getMenuGUID(),
              focusFirstOption: false,
            },
          }),
          this.controller.dispatch({
            type: "set-focus-location",
            location: {
              type: "expression-menu",
              id: this.model.id,
              location: "updaterule",
            },
          });
      }
      getMenuGUID() {
        return this.model.guid;
      }
      getMQConfig() {
        return this.controller.getMathquillConfig({
          additionalOperators: ["index"],
        });
      }
    };
  var dl = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Ti = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Do = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var XT = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var $b = class extends XT.Class {
    template() {
      return XT.createElement(nt, {
        latex: this.props.latex,
        config: this.props.config,
        getAriaLabel: this.props.getAriaLabel,
        tokenController: this.props.tokenController,
        onUserPressedKey: this.props.onUserPressedKey,
        didMountMathquill: (e) => this.didMountMathquill(e),
      });
    }
    didMountMathquill(e) {
      var t, o;
      this.mathquillFocus = new Rf(e, ee(e.el()), this.props),
        this.didUpdate(),
        (o = (t = this.props).didMountMathquill) == null || o.call(t, e);
    }
    willUnmount() {
      var e;
      (e = this.mathquillFocus) == null || e.willUnmount();
    }
    didUpdate() {
      var e;
      (e = this.mathquillFocus) == null || e.updateMathquillFocused();
    }
  };
  var JT = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var $re = .9,
    Pp = class extends JT.Class {
      template() {
        return JT.createElement("div", {
          class: () => {
            var e, t;
            return {
              "dcg-color-swatch": true,
              "dcg-forced-color-none": true,
              "dcg-color-evaluation":
                (t = (e = this.props).isEvaluation) == null
                  ? void 0
                  : t.call(e),
              "dcg-light-color": qf(
                this.props.color(),
                this.props.invertSwatches(),
                $re,
              ),
            };
          },
          style: () => ({ background: Hf(this.props.color()) }),
          "aria-label": () => {
            var e, t;
            return (t = (e = this.props).ariaLabel) == null
              ? void 0
              : t.call(e);
          },
        });
      }
    };
  var { If: z8, SwitchUnion: jre } = Do.Components,
    qg = class extends Do.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Do.createElement(
          "div",
          { class: Do.const("dcg-evaluation-container") },
          Do.createElement(
            z8,
            { predicate: this.bindFn(this.displaySlowEvaluation) },
            () =>
              Do.createElement(
                Le,
                {
                  tooltip: () =>
                    this.controller.s(
                      "shared-calculator-error-slow-evaluation",
                    ),
                  sticky: this.const(true),
                  gravity: this.const("n"),
                },
                Do.createElement("span", {
                  class: Do.const("dcg-spinner"),
                  "aria-hidden": Do.const("true"),
                }),
              ),
          ),
          Do.createElement(
            "div",
            {
              class: () => ({
                "dcg-evaluation": true,
                "dcg-do-blur": true,
                "dcg-hidden": this.props.controller().isInEditListMode(),
                "dcg-slow-evaluation": this.displaySlowEvaluation(),
              }),
              handleEvent: Do.const("true"),
              onTap: this.bindFn(this.selectMQIfNothingSelected),
              tabIndex: () =>
                this.controller.getBrailleMode() === "none" &&
                  this.getEvaluationRHS().type !== "number"
                  ? "0"
                  : "-1",
            },
            Do.createElement(
              Mo,
              {
                latex: this.bindFn(this.getBrailleEvaluation),
                ariaLabel: this.const(""),
                brailleShouldFocus: () => this.isFocused(),
                onBrailleInput: () => {},
                onBrailleKeydown: (e) => {
                  e.stopPropagation();
                  let t = ke(e);
                  t && this.handlePressedKey(t);
                },
                isStatic: this.const(true),
                onBrailleFocusedChanged: (e) => this.handleMQFocusedChanged(e),
                ...ui(this.controller),
              },
              Do.createElement(
                "div",
                { class: Do.const("dcg-evaluation-label-container") },
                Do.createElement(z8, {
                  predicate: this.bindFn(this.shouldShowEquals),
                }, () =>
                  Do.createElement(
                    "span",
                    { class: Do.const("dcg-equals") },
                    Do.createElement(nt, {
                      latex: this.const("="),
                      config: this.const({}),
                    }),
                  )),
              ),
              Do.createElement(
                "span",
                {
                  class: () => ({
                    "dcg-evaluation-html": true,
                    "dcg-color-evaluation":
                      this.getEvaluationRHS().type === "rgbcolor",
                  }),
                  didMount: (e) => {
                    this.firstLineEvalNode = e;
                  },
                },
                jre("type", () => this.getEvaluationRHS())({
                  list: (e) =>
                    Do.createElement("span", {
                      class: Do.const("dcg-evaluation-list"),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-label-evaluation-list",
                        { count: e().count },
                      )),
                  number: (e) =>
                    Do.createElement($b, {
                      latex: () => e().valueLatex,
                      config: this.const({ tabbable: true }),
                      didMountMathquill: (t) => this.staticMQ = t,
                      isFocused: () => this.isFocused(),
                      onFocusedChanged: (t) => this.handleMQFocusedChanged(t),
                      onUserPressedKey: this.bindFn(
                        this.handlePressedKey,
                      ),
                    }),
                  undefined: () =>
                    Do.createElement("span", null, Do.const("undefined")),
                  rgbcolor: (e) =>
                    Do.createElement(Pp, {
                      color: () => e().colorValue,
                      isEvaluation: this.const(true),
                      invertSwatches: () => this.controller.invertSwatches(),
                      ariaLabel: () => e().ariaLabel,
                    }),
                }),
              ),
            ),
          ),
        );
      }
      selectMQIfNothingSelected() {
        var t, o;
        if (this.getEvaluationRHS().type !== "number" || !this.staticMQ) {
          return;
        }
        let e = this.staticMQ.selection();
        e.startIndex === e.endIndex &&
          ((t = this.staticMQ) == null || t.blur(),
            (o = this.staticMQ) == null || o.focus());
      }
      handlePressedKey(e) {
        switch (e) {
          case "Up":
            return this.controller.dispatch({
              type: "set-focus-location",
              location: { type: "expression", id: this.props.id() },
            }),
              true;
          case "PageUp":
          case "PageDown":
          case "Down":
          case "Enter":
            return this.controller.dispatch({
              type: "on-special-key-pressed",
              key: e,
            }),
              true;
          case "Esc":
            return Jr(), true;
        }
        return false;
      }
      shouldShowEquals() {
        return this.getEvaluationRHS().type === "number";
      }
      getColorLabel() {
        let e = this.controller.getItemModel(this.props.id());
        if (!(!e || e.type !== "expression")) {
          return IT(e, this.controller);
        }
      }
      getEvaluationRHS() {
        var i, n, a;
        let e = (n = (i = this.props).val) == null ? void 0 : n.call(i),
          t = this.props.valueType();
        if (e === void 0 || t === void 0) return { type: "undefined" };
        let o = { valueType: t, value: e };
        switch (o.valueType) {
          case __dcg_shared_module_exports__["Complex"]:
            let s = __dcg_shared_module_exports__["complexNumberLabel"](
              o.value,
              {
                ...__dcg_shared_module_exports__[
                  "DEFAULT_COMPLEX_EVALUATION_LABEL_OPTIONS"
                ],
                displayAsFraction: this.shouldDisplayAsFraction(),
              },
            );
            return s === "undefined"
              ? { type: "undefined" }
              : { type: "number", valueLatex: s };
          case __dcg_shared_module_exports__["RGBColor"]:
          case __dcg_shared_module_exports__["ListOfColor"]:
            return {
              type: "rgbcolor",
              colorValue: Array.isArray(o.value)
                ? { type: "color-array", value: o.value }
                : { type: "single-color", value: o.value },
              val: o.value,
              ariaLabel: this.getColorLabel(),
            };
          case __dcg_shared_module_exports__["Number"]:
            return __dcg_shared_module_exports__["numericLabel"](o.value, {
                ...__dcg_shared_module_exports__[
                  "DEFAULT_EVALUATION_LABEL_OPTIONS"
                ],
                displayAsFraction: this.shouldDisplayAsFraction(),
              }).type === "undefined"
              ? { type: "undefined" }
              : {
                type: "number",
                valueLatex:
                  (a = __dcg_shared_module_exports__["truncatedLatexLabel"](
                      o.value,
                      {
                        ...__dcg_shared_module_exports__[
                          "DEFAULT_EVALUATION_LABEL_OPTIONS"
                        ],
                        displayAsFraction: this.shouldDisplayAsFraction(),
                      },
                    )) != null
                    ? a
                    : "",
              };
          default:
            return Array.isArray(o.value)
              ? { type: "list", count: o.value.length }
              : { type: "undefined" };
        }
      }
      shouldDisplayAsFraction() {
        return this.props.controller()
          .shouldEvaluationForItemDisplayAsFraction(this.props.id());
      }
      getBrailleEvaluation() {
        let e = "";
        this.shouldShowEquals() && (e += "=");
        let t = this.getEvaluationRHS();
        switch (t.type) {
          case "list":
            e += this.controller.s(
              "graphing-calculator-label-evaluation-list",
              { count: t.count },
            );
            break;
          case "number":
            e += t.valueLatex;
            break;
          case "undefined":
            e = "undefined";
            break;
          case "rgbcolor":
            e += t.val;
            break;
          default:
            return t;
        }
        return e;
      }
      displaySlowEvaluation() {
        return this.controller.shouldShowProgressUpdateIcons() &&
          this.controller.isItemSlowInEvaluator(this.props.id());
      }
      isFocused() {
        let e = this.controller.getFocusLocation();
        return (e == null ? void 0 : e.type) ===
            "expression-evaluation" && e.id === this.props.id();
      }
      handleMQFocusedChanged(e) {
        let t = { type: "expression-evaluation", id: this.props.id() };
        e
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: t,
          })
          : this.controller.dispatch({
            type: "blur-focus-location",
            location: t,
          });
      }
    };
  var Ps = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { SwitchUnion: Yre } = Ps.Components,
    lr = class extends Ps.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Ps.createElement(
          "div",
          { class: this.bindFn(this.getContainerClass) },
          Yre(() => String(this.props.readonly()), {
            true: () =>
              Ps.createElement(
                Mo,
                {
                  latex: this.bindFn(this.getStaticLatex),
                  operatorNames: () => this.getMQConfig().autoOperatorNames,
                  brailleShouldFocus: this.props.isFocused,
                  isStatic: this.const(true),
                  onBrailleFocusedChanged: this.props.handleFocusChanged,
                  ariaLabel: this.bindFn(this.getBrailleLabel),
                  dataLabelAttributeValue: this.props.dataLabelAttributeValue,
                  ...ui(this.props.controller()),
                },
                Ps.createElement(
                  nt,
                  {
                    latex: this.bindFn(this.getStaticLatex),
                    config: this.bindFn(this.getMQConfig),
                    getAriaLabel: this.props.ariaLabel,
                    tokenController: this.props.controller,
                  },
                  Ps.createElement("span", {
                    class: Ps.const("dcg-math-field"),
                    "data-dcg-label": () =>
                      this.props.dataLabelAttributeValue
                        ? this.props.dataLabelAttributeValue()
                        : void 0,
                    manageFocus: this.const({
                      shouldBeFocused: () =>
                        this.props.isFocused() &&
                        this.controller.getBrailleMode() === "none",
                      onFocusedChanged: (e, t) =>
                        this.props.handleFocusChanged(e, t),
                    }),
                    tabIndex: Ps.const("0"),
                  }),
                ),
              ),
            false: () =>
              Ps.createElement(
                Mo,
                {
                  latex: this.props.latex,
                  operatorNames: () =>
                    this.getMQConfig().autoOperatorNames || "",
                  brailleShouldFocus: this.props.isFocused,
                  selectOnFocus: this.const(true),
                  onBrailleInput: this.props.handleLatexChanged,
                  onBrailleFocusedChanged: this.props.handleFocusChanged,
                  onBrailleKeydown: this.bindFn(this.onBrailleKeydown),
                  hasError: this.props.hasError,
                  placeholder: this.props.placeholder,
                  ariaLabel: this.bindFn(this.getBrailleLabel),
                  dataLabelAttributeValue: this.props.dataLabelAttributeValue,
                  ...ui(this.props.controller()),
                },
                Ps.createElement(Fe, {
                  latex: this.props.latex,
                  getAriaPostLabel: () => {
                    var t, o;
                    let e = ((o = (t = this.props).ariaPostLabel) == null
                      ? void 0
                      : o.call(t)) || "";
                    return this.props.hasError() && e === "" &&
                      (e = this.controller.s(
                        "shared-calculator-narration-math-input-error-message",
                      )),
                      e;
                  },
                  tokenController: this.props.controller,
                  isFocused: () =>
                    this.props.isFocused() &&
                    this.controller.getBrailleMode() === "none",
                  placeholder: this.props.placeholder,
                  capExpressionSize: () =>
                    this.controller.getCapExpressionSize(),
                  selectOnFocus: this.const(true),
                  config: this.bindFn(this.getMQConfig),
                  getAriaLabel: this.props.ariaLabel,
                  hasError: this.props.hasError,
                  dataLabelAttributeValue: this.props.dataLabelAttributeValue,
                  onUserPressedKey: this.props.handlePressedKey,
                  onUserChangedLatex: this.props.handleLatexChanged,
                  onSelectionChanged: this.props.handleSelectionChanged,
                  onExpressionSizeExceeded: () =>
                    this.controller.dispatch({
                      type: "expression-size-exceeded",
                    }),
                  onFocusedChanged: this.props.handleFocusChanged,
                  needsSystemKeypad: () => !this.controller.isKeypadEnabled(),
                }),
              ),
          }),
        );
      }
      getStaticLatex() {
        return this.props.latex()
          ? this.props.latex()
          : this.props.placeholder
          ? this.props.placeholder()
          : "";
      }
      getContainerClass() {
        let e = this.props.containerClass ? this.props.containerClass() : {};
        return e["dcg-inline-math-input-view"] = true,
          this.props.fullWidth && this.props.fullWidth() &&
          (e["dcg-full-width-inline-math-input"] = true),
          this.props.fontSize && this.props.fontSize() === "large" &&
          (e["dcg-large-font-inline-math-input"] = true),
          this.props.noBorder && this.props.noBorder() &&
          (e["dcg-no-border-inline-math-input"] = true),
          e;
      }
      onBrailleKeydown(e) {
        if (!this.props.handlePressedKey) return;
        let t = ke(e);
        t && this.props.handlePressedKey(t, e);
      }
      getMQConfig() {
        return this.controller.getMathquillConfig({});
      }
      getBrailleLabel() {
        return this.props.brailleLabel
          ? this.props.brailleLabel()
          : this.props.ariaLabel();
      }
    };
  var { If: q8 } = Ti.Components,
    cv = class extends Ti.Class {
      constructor() {
        super(...arguments), this.focusedValues = {};
      }
      template() {
        return this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.id = this.model.id,
          Ti.createElement(
            "div",
            {
              class: Ti.const("dcg-cdf-footer-container dcg-do-blur"),
              tapboundary: Ti.const("true"),
              handleEvent: Ti.const("true"),
            },
            Ti.createElement(mt, {
              checked: () => vd(this.model),
              disabled: () =>
                AL(this.model) ||
                this.controller.isItemReadonly(this.model.id),
              onChange: (e) => {
                this.controller.dispatch({
                  type: "set-show-cdf",
                  id: this.model.id,
                  showCDF: e,
                });
              },
            }, () => this.controller.s("graphing-calculator-button-find-cdf")),
            Ti.createElement(q8, {
              predicate: () => vd(this.model),
            }, () =>
              Ti.createElement(
                "div",
                null,
                Ti.createElement("span", {
                  class: Ti.const("dcg-cdf-limit-name"),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-label-cdf-minimum",
                  )),
                Ti.createElement(lr, {
                  handleFocusChanged: (e) =>
                    this.handleFocusedChanged("min", e),
                  latex: () => hT(this.model),
                  hasError: () => !mT(this.model),
                  isFocused: () => this.isInputFocused("min"),
                  ariaLabel: () =>
                    this.controller.s(
                      "graphing-calculator-narration-cdf-minimum",
                    ),
                  placeholder: () => gH(this.model),
                  handlePressedKey: (e, t) =>
                    this.handlePressedKey(e, t, "min"),
                  controller: this.props.controller,
                  handleLatexChanged: this.bindFn(this.updateCDFMin),
                  readonly: () => this.controller.isItemReadonly(this.model.id),
                }),
                Ti.createElement("span", {
                  class: Ti.const("dcg-cdf-limit-name"),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-label-cdf-maximum",
                  )),
                Ti.createElement(lr, {
                  handleFocusChanged: (e) =>
                    this.handleFocusedChanged("max", e),
                  latex: () => gT(this.model),
                  hasError: () => !fT(this.model),
                  isFocused: () => this.isInputFocused("max"),
                  ariaLabel: () =>
                    this.controller.s(
                      "graphing-calculator-narration-cdf-maximum",
                    ),
                  placeholder: () => mH(this.model),
                  handlePressedKey: (e, t) =>
                    this.handlePressedKey(e, t, "max"),
                  controller: this.props.controller,
                  handleLatexChanged: this.bindFn(this.updateCDFMax),
                  readonly: () => this.controller.isItemReadonly(this.model.id),
                }),
                Ti.createElement(q8, {
                  predicate: this.bindFn(this.showEvaluation),
                }, () =>
                  Ti.createElement(
                    "div",
                    { class: Ti.const("dcg-cdf-evaluation-container") },
                    Ti.createElement(qg, {
                      val: () => VL(this.model),
                      controller: this.props.controller,
                      id: () => this.model.id,
                      valueType: this.const(
                        __dcg_shared_module_exports__["Number"],
                      ),
                    }),
                  )),
              )),
          );
      }
      handlePressedKey(e, t, o) {
        if (e === "Esc") {
          this.controller.dispatch({
            type: "set-focus-location",
            location: void 0,
          });
          return;
        }
        if (e === "Enter") {
          return this.controller.dispatch({
            type: "on-special-key-pressed",
            key: "Enter",
          });
        }
        let i = Fe.getFocusedMathquill();
        i &&
          (i.keystroke(e, t),
            o === "min" && hT(this.model) !== i.latex() &&
            this.updateCDFMin(i.latex()),
            o === "max" && gT(this.model) !== i.latex() &&
            this.updateCDFMax(i.latex()));
      }
      updateCDFMax(e) {
        this.controller.dispatch({
          type: "set-cdf-max",
          id: this.model.id,
          latex: e,
        });
      }
      updateCDFMin(e) {
        this.controller.dispatch({
          type: "set-cdf-min",
          id: this.model.id,
          latex: e,
        });
      }
      showEvaluation() {
        return JE(this.model);
      }
      isInputFocused(e) {
        let t = this.controller.getFocusLocation();
        return !t || t.type !== "cdf-limit" || t.id !== this.id
          ? false
          : t.location === e;
      }
      handleFocusedChanged(e, t) {
        t
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "cdf-limit", id: this.id, location: e },
          })
          : this.controller.dispatch({
            type: "blur-focus-location",
            location: { type: "cdf-limit", id: this.id, location: e },
          });
      }
    };
  var Mn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: Xre, For: H8, SwitchUnion: Jre } = Mn.Components,
    jb = class extends Mn.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.id = this.model.id;
      }
      template() {
        return Jre(this.bindFn(this.getSuggestionType), {
          list: () =>
            Mn.createElement(
              "div",
              {
                class: () => ({
                  "dcg-parameter-suggestion-container": true,
                  "dcg-parameter-suggestion-braille":
                    this.controller.getBrailleMode() !== "none",
                }),
              },
              Mn.createElement(H8, {
                each: this.bindFn(this.getListOfParameters),
              }, (e) =>
                Mn.createElement("span", {
                  class: Mn.const("dcg-parameter-name"),
                }, () => this.getParamName(e))),
            ),
          listWithDefault: () =>
            Mn.createElement(
              "div",
              {
                class: () => ({
                  "dcg-parameter-suggestion-container": true,
                  "dcg-parameter-suggestion-braille":
                    this.controller.getBrailleMode() !== "none",
                }),
                onTap: this.bindFn(this.fillInDefaults),
              },
              Mn.createElement(H8, {
                each: this.bindFn(this.getListOfParameters),
              }, (e) =>
                Mn.createElement(
                  "span",
                  { class: Mn.const("dcg-parameter-name") },
                  () => this.getParamName(e),
                  Mn.createElement(Xre, {
                    predicate: () => this.shouldShowDefaultValue(e),
                  }, () =>
                    Mn.createElement(
                      "span",
                      { class: Mn.const("dcg-default-marker") },
                      Mn.const("= "),
                      () => this.getDefaultValue(e),
                    )),
                )),
            ),
          individual: () =>
            Mn.createElement("div", {
              class: () => ({
                "dcg-parameter-suggestion-container": true,
                "dcg-parameter-suggestion-braille":
                  this.controller.getBrailleMode() !== "none",
              }),
            }, this.bindFn(this.getMissingRequiredParamText)),
          none: () => {},
        });
      }
      getExtractedAndDefaultArgString(e) {
        let { params: t, values: o, defaults: i } = e;
        return t.map((a, s) => {
          let l = o[a], c = i[s];
          return l || c || "";
        }).join(",");
      }
      fillInDefaults() {
        let e = sl(this.model);
        if (!e) return;
        let { symbol: t, span: o } = e,
          { input: i, start: n, end: a } = o,
          s = this.getExtractedAndDefaultArgString(e),
          l = `\\operatorname{${t}}\\left(${s}\\right)`,
          c = `${i.slice(0, n)}${l}${i.slice(a)}`;
        this.controller.dispatch({
          type: "set-item-latex",
          id: this.id,
          latex: c,
        }),
          this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "expression", id: this.id },
          }),
          this.controller.dispatch({
            type: "keypad/press-key",
            key: "Left",
          });
      }
      isMissingDefault() {
        if (!Yw(this.model)) return false;
        let e = sl(this.model);
        if (!e) return false;
        for (let t = 0; t < e.params.length; t++) {
          if (this.shouldShowDefaultValue(e.params[t])) return true;
        }
        return false;
      }
      getSuggestionType() {
        return this.getListOfParameters().length > 1
          ? this.isMissingDefault() ? "listWithDefault" : "list"
          : this.missingRequiredParam()
          ? "individual"
          : "none";
      }
      missingRequiredParam() {
        let e = sl(this.model);
        if (!e || e.params.length !== 1) return;
        let t = e.params[0];
        if (
          !this.getDefaultValue(t) && !this.getParameterExtractedValue(t)
        ) return t;
      }
      getMissingRequiredParamText() {
        let e = this.missingRequiredParam();
        return e
          ? this.controller.s(
            "graphing-calculator-text-enter-pareneter",
            { param: this.getParamName(e) },
          )
          : "";
      }
      getDefaultValue(e) {
        let t = sl(this.model);
        if (!t || !t.params) return "";
        for (let o = 0; o < t.params.length; o++) {
          if (t.params[o] === e) return t.defaults[o] || "";
        }
        return "";
      }
      getParameterExtractedValue(e) {
        let t = sl(this.model);
        return t && t.values[e] || "";
      }
      shouldShowDefaultValue(e) {
        return !this.getParameterExtractedValue(e) &&
          !!this.getDefaultValue(e);
      }
      getListOfParameters() {
        let e = sl(this.model);
        return e ? e.params : [];
      }
      getParamName(e) {
        switch (e) {
          case "mean":
            return this.controller.s(
              "graphing-calculator-text-parameter-name-mean",
            );
          case "stdev":
            return this.controller.s(
              "graphing-calculator-text-parameter-name-stddev",
            );
          case "dof":
            return this.controller.s(
              "graphing-calculator-text-parameter-name-dof",
            );
          case "probsuccess":
            return this.controller.s(
              "graphing-calculator-text-parameter-name-probsuccess",
            );
          case "trials":
            return this.controller.s(
              "graphing-calculator-text-parameter-name-trials",
            );
          case "data":
            return this.controller.s(
              "graphing-calculator-text-parameter-name-data",
            );
          case "binwidth":
            return this.controller.s(
              "graphing-calculator-text-parameter-name-binwidth",
            );
          case "min":
            return this.controller.s(
              "graphing-calculator-text-parameter-name-min",
            );
          case "max":
            return this.controller.s(
              "graphing-calculator-text-parameter-name-max",
            );
          case "height":
            return this.controller.s(
              "graphing-calculator-text-parameter-name-height",
            );
          case "offset":
            return this.controller.s(
              "graphing-calculator-text-parameter-name-offset",
            );
          default:
            return e;
        }
      }
    };
  var { If: Qre } = dl.Components,
    dv = class extends dl.Class {
      template() {
        return this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.id = this.model.id,
          dl.createElement(
            "div",
            {
              class: dl.const(
                "dcg-distribution-parameters-container dcg-do-blur",
              ),
              tapboundary: dl.const("true"),
              handleEvent: dl.const("true"),
            },
            dl.createElement(jb, {
              model: this.props.model,
              controller: this.props.controller,
            }),
            dl.createElement(
              Qre,
              { predicate: () => IL(this.model) },
              () =>
                dl.createElement(cv, {
                  model: this.props.model,
                  controller: this.props.controller,
                }),
            ),
          );
      }
    };
  var ri = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Sc = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Md = class extends Sc.Class {
    template() {
      return Sc.createElement(
        Le,
        {
          tooltip: () =>
            this.props.controller().s(
              "shared-calculator-label-toast-learn-more",
            ),
        },
        Sc.createElement(
          "a",
          {
            "aria-label": () =>
              this.props.controller().s(
                "shared-calculator-label-toast-learn-more",
              ),
            class: Sc.const("dcg-learn-more-link"),
            href: this.props.href,
            target: Sc.const("_blank"),
          },
          Sc.createElement("i", {
            class: Sc.const("dcg-icon-question-sign"),
            "aria-hidden": Sc.const("true"),
          }),
        ),
      );
    }
  };
  var { If: gP } = ri.Components,
    QT = class extends ri.Class {
      constructor() {
        super(...arguments),
          this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.id = this.model.id;
      }
      handlePressedKey(e, t, o) {
        if (!this.controller.isInEditListMode()) {
          if (t === "Esc") {
            this.controller.dispatch({
              type: "set-focus-location",
              location: void 0,
            });
            return;
          }
          if (t === "Enter") {
            return this.controller.dispatch({
              type: "on-special-key-pressed",
              key: "Enter",
            });
          }
        }
        let i = Fe.getFocusedMathquill(), n = os();
        if (t === "Left" || t === "Right" || t === "Down" || t === "Up") {
          let a;
          i ? a = Fe.applyArrowKeyAndReturnIfWasAtBounds(i, t, o) : n &&
              (n.selectionStart === 0 && t === "Left" ||
                n.selectionStart === n.value.length && t === "Right" ||
                t === "Up" || t === "Down")
            ? a = true
            : a = false,
            a &&
            (o && o.preventDefault(),
              t === "Left"
                ? e === "max" + this.getDomainVariableString() &&
                  this.controller.dispatch({
                    type: "set-focus-location",
                    location: {
                      type: "domain-limit",
                      id: this.model.id,
                      location: "min" + this.getDomainVariableString(),
                    },
                  })
                : t === "Right"
                ? e === "min" + this.getDomainVariableString() &&
                  this.controller.dispatch({
                    type: "set-focus-location",
                    location: {
                      type: "domain-limit",
                      id: this.model.id,
                      location: "max" + this.getDomainVariableString(),
                    },
                  })
                : t === "Down"
                ? this.controller.dispatch({
                  type: "on-special-key-pressed",
                  key: "Down",
                })
                : t === "Up" &&
                  this.controller.dispatch({
                    type: "set-focus-location",
                    location: { type: "expression", id: this.model.id },
                  }));
          return;
        }
        i &&
          (i.keystroke(t, o),
            e === "min" + this.getDomainVariableString()
              ? this.dispatchMinLatexIfChanged(i.latex())
              : e === "max" + this.getDomainVariableString() &&
                this.dispatchMaxLatexIfChanged(i.latex()));
      }
      getDomainVariable() {
        var o, i;
        let e = this.props.domainIndex(),
          t = (i = (o = this.model.formula.domains) == null ? void 0 : o[e]) ==
              null
            ? void 0
            : i.variable;
        if (!t) {
          throw new Error(
            "Programming Error: could not find domain variable in index " +
              e,
          );
        }
        return t;
      }
      handleFocusedChanged(e, t) {
        t
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "domain-limit", id: this.id, location: e },
          })
          : this.controller.dispatch({
            type: "blur-focus-location",
            location: { type: "domain-limit", id: this.id, location: e },
          });
      }
      dispatchMinLatexIfChanged(e) {
        this.getMinLatex() !== e &&
          this.controller.dispatch({
            type: "set-domain-minlatex",
            variable: this.getDomainVariable(),
            id: this.id,
            latex: e,
          });
      }
      dispatchMaxLatexIfChanged(e) {
        this.getMaxLatex() !== e &&
          this.controller.dispatch({
            type: "set-domain-maxlatex",
            variable: this.getDomainVariable(),
            id: this.id,
            latex: e,
          });
      }
      getFocusedInput() {
        let e = this.controller.getFocusLocation();
        if (!(!e || e.type !== "domain-limit" || e.id !== this.id)) {
          return e.location;
        }
      }
      getMinLatex() {
        return oH(this.model, this.getDomainVariable());
      }
      getMaxLatex() {
        return iH(this.model, this.getDomainVariable());
      }
      getDomainVariableString() {
        let e = this.getDomainVariable();
        return e === "theta" ? e = "\\theta" : e === "phi" && (e = "\\phi"), e;
      }
      getDomainVariableDisplayLatex() {
        return "\\le " + this.getDomainVariableString() + " \\le";
      }
      getPlaceholder(e) {
        return __dcg_shared_module_exports__["value"](e).string.replace(
          "\u03C0",
          "\\pi",
        );
      }
      template() {
        return ri.createElement(
          "div",
          {
            class: ri.const("dcg-domain dcg-do-blur"),
            handleEvent: ri.const("true"),
          },
          ri.createElement(
            "div",
            {
              class: ri.const("dcg-display-domain dcg-do-blur"),
              handleEvent: ri.const("true"),
            },
            ri.createElement(lr, {
              readonly: () => this.controller.isItemReadonly(this.id),
              latex: () => this.getMinLatex(),
              isFocused: () =>
                this.getFocusedInput() ===
                  "min" + this.getDomainVariableString(),
              placeholder: () =>
                this.getPlaceholder(
                  Oq(this.model, this.getDomainVariable()),
                ),
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-domain3d-minimum",
                  { term: this.getDomainVariableString() },
                ),
              brailleLabel: () => this.controller.raw("dmin"),
              handleFocusChanged: (e) =>
                this.handleFocusedChanged(
                  "min" + this.getDomainVariableString(),
                  e,
                ),
              hasError: () => !Fq(this.model, this.getDomainVariable()),
              controller: this.props.controller,
              handlePressedKey: (e, t) =>
                this.handlePressedKey(
                  "min" + this.getDomainVariableString(),
                  e,
                  t,
                ),
              handleLatexChanged: (e) => this.dispatchMinLatexIfChanged(e),
              dataLabelAttributeValue: this.const("domain-min"),
            }),
            ri.createElement(
              "span",
              { class: ri.const("dcg-interval-interior") },
              ri.createElement(nt, {
                latex: () => this.getDomainVariableDisplayLatex(),
                config: this.const({}),
              }),
            ),
            ri.createElement(lr, {
              readonly: () => this.controller.isItemReadonly(this.id),
              latex: () => this.getMaxLatex(),
              isFocused: () =>
                this.getFocusedInput() ===
                  "max" + this.getDomainVariableString(),
              placeholder: () =>
                this.getPlaceholder(
                  Rq(this.model, this.getDomainVariable()),
                ),
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-domain3d-maximum",
                  { term: this.getDomainVariableString() },
                ),
              brailleLabel: () => this.controller.raw("dmax"),
              handleFocusChanged: (e) =>
                this.handleFocusedChanged(
                  "max" + this.getDomainVariableString(),
                  e,
                ),
              hasError: () => !Nq(this.model, this.getDomainVariable()),
              controller: this.props.controller,
              handlePressedKey: (e, t) =>
                this.handlePressedKey(
                  "max" + this.getDomainVariableString(),
                  e,
                  t,
                ),
              handleLatexChanged: (e) => this.dispatchMaxLatexIfChanged(e),
              dataLabelAttributeValue: this.const("domain-max"),
            }),
            ri.createElement(gP, {
              predicate: () => this.getDomainVariableString() === "\\phi",
            }, () =>
              ri.createElement(Md, {
                href: this.const(
                  "https://help.desmos.com/hc/en-us/articles/15824510769805",
                ),
                controller: this.props.controller,
              })),
          ),
        );
      }
    },
    pv = class extends ri.Class {
      constructor() {
        super(...arguments), this.model = this.props.model();
      }
      hasFirstDomainIndex() {
        return Wu(this.model) || Dp(this.model) && !aH(this.model);
      }
      hasSecondDomainIndex() {
        return Dp(this.model) ? !sH(this.model) : false;
      }
      template() {
        return ri.createElement(
          "div",
          null,
          ri.createElement(gP, {
            predicate: this.bindFn(this.hasFirstDomainIndex),
          }, () =>
            ri.createElement(QT, {
              controller: this.props.controller,
              model: this.props.model,
              domainIndex: this.const(0),
            })),
          ri.createElement(
            gP,
            { predicate: this.bindFn(this.hasSecondDomainIndex) },
            () =>
              ri.createElement(QT, {
                controller: this.props.controller,
                model: this.props.model,
                domainIndex: this.const(1),
              }),
          ),
        );
      }
    };
  var eo = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { Switch: Zre } = eo.Components,
    uv = class extends eo.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return eo.createElement(
          "div",
          {
            class: eo.const("dcg-expression-warning dcg-text-selectable"),
            handleEvent: eo.const("true"),
            role: eo.const("note"),
          },
          eo.createElement("i", {
            class: eo.const("dcg-icon-error"),
            "aria-hidden": eo.const("true"),
          }),
          eo.createElement(
            Zre,
            { key: () => this.props.warning() },
            (e) => {
              switch (e == null ? void 0 : e.type) {
                case "unresolved":
                  return eo.createElement(
                    "span",
                    null,
                    () =>
                      this.controller.s(
                        "graphing-calculator-error-equation-contains-unresolved-details",
                      ),
                    eo.createElement(
                      "a",
                      {
                        href: eo.const(
                          "https://help.desmos.com/hc/en-us/articles/202529079-Unresolved-Detail-In-Plotted-Functions",
                        ),
                        target: eo.const("_blank"),
                      },
                      () =>
                        this.controller.s(
                          "graphing-calculator-link-learn-more",
                        ),
                    ),
                  );
                case "expressionTooComplex":
                  return eo.createElement(
                    "span",
                    null,
                    () =>
                      this.controller.s(
                        "shared-calculator-error-gpu-expression-too-complex",
                      ),
                    eo.createElement(
                      "a",
                      {
                        href: eo.const(
                          "https://help.desmos.com/hc/en-us/articles/26801641850893-GPU-Error-while-Plotting-an-Expression",
                        ),
                        target: eo.const("_blank"),
                      },
                      () =>
                        this.controller.s(
                          "graphing-calculator-link-learn-more",
                        ),
                    ),
                  );
                case "tone-out-of-range":
                  return eo.createElement(
                    "span",
                    null,
                    () =>
                      this.controller.s(
                        "graphing-calculator-error-tone-frequency-out-of-range",
                        { min: gb, max: mb },
                      ),
                  );
                case "recursive-depth-plotting-error":
                  return eo.createElement(
                    "span",
                    null,
                    () =>
                      this.controller.s(
                        "graphing-calculator-error-reached-maximum-recursion-depth",
                      ),
                  );
                case "nan-blame-complex-coercion":
                  return eo.createElement(
                    "span",
                    null,
                    () =>
                      this.controller.s(
                        "graphing-calculator-error-nan-blame-complex-coercion",
                      ),
                  );
                case "legacy-random-seed-behavior":
                  return eo.createElement(
                    "span",
                    null,
                    () =>
                      this.controller.s(
                        "graphing-calculator-error-legacy-random-seed-behavior",
                      ),
                    eo.createElement("a", {
                      href: eo.const(
                        "https://help.desmos.com/hc/en-us/articles/25261997911181-Change-to-Random-Seeds-in-Function-Definitions",
                      ),
                      target: eo.const("_blank"),
                      class: eo.const("dcg-warning-footer-learn-more"),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-link-learn-more",
                      )),
                    eo.createElement("button", {
                      onTap: () => {
                        this.controller.dispatch({
                          type: "update-legacy-random-seed-behavior",
                        });
                      },
                      class: eo.const(
                        "dcg-btn-light-gray dcg-update-behavior-btn dcg-unstyled-button",
                      ),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-label-update-to-new-behavior",
                      )),
                  );
                case "evaluation":
                  return eo.createElement("span", null, () => e.message);
                case void 0:
                  return;
              }
            },
          ),
        );
      }
    };
  var ln = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { Input: eoe, IfElse: mP, IfDefined: toe, If: K8 } = ln.Components,
    Hg = class extends ln.Class {
      template() {
        return this.controller = this.props.controller(),
          ln.createElement(
            "div",
            {
              class: () => ({
                "dcg-label-visible": this.getShowLabel(),
                "dcg-label-input-visible": !this.getIsDisabled(),
                "dcg-label-container": true,
                "dcg-do-blur": true,
              }),
              tapboundary: ln.const("true"),
              handleEvent: ln.const("true"),
            },
            mP(() => {
              var e, t;
              return !!((t = (e = this.props).forceEnabled) != null &&
                t.call(e));
            }, {
              true: () =>
                ln.createElement(
                  "span",
                  null,
                  () =>
                    this.controller.s(
                      "graphing-calculator-button-label",
                    ) +
                    ":",
                ),
              false: () =>
                ln.createElement(mt, {
                  onChange: this.bindFn(this.onCheckboxInput),
                  checked: this.bindFn(this.getShowLabel),
                }, () =>
                  this.controller.s("graphing-calculator-button-label") +
                  (this.getIsDisabled() ? "" : ":")),
            }),
            mP(this.bindFn(this.hasEditableLabel), {
              true: () =>
                ln.createElement(
                  "div",
                  { class: ln.const("dcg-editable-mode-toggle") },
                  ln.createElement(vo, {
                    theme: this.const("mini"),
                    staticConfig: this.bindFn(
                      this.getEditableLabelOptions,
                    ),
                    ariaGroupLabel: () =>
                      this.controller.s(
                        "graphing-calculator-narration-editable-label-mode",
                      ),
                  }),
                ),
              false: () =>
                mP(() => {
                  var e, t;
                  return !!((t = (e = this.props).displayComputedValue) !=
                      null && t.call(e));
                }, {
                  false: () =>
                    ln.createElement(K8, {
                      predicate: () => {
                        var e, t;
                        return !((t = (e = this.props).suppressInput) !=
                            null && t.call(e));
                      },
                    }, () =>
                      ln.createElement(K8, {
                        predicate: () => !this.getIsDisabled(),
                      }, () => {
                        var e;
                        return ln.createElement(eoe, {
                          class: () => ({
                            "dcg-label-input": true,
                            "dcg-readonly": this.getIsReadonly(),
                            "dcg-disabled-editable-input": this
                              .hasEditableLabel(),
                          }),
                          disabled: this.bindFn(this.getIsReadonly),
                          "aria-label": () =>
                            this.controller.s(
                              "graphing-calculator-narration-label-text",
                            ),
                          manageFocus: (e = this.props.manageInputFocus) != null
                            ? e
                            : () => {},
                          didMount: (t) => {
                            var o, i;
                            this.inputNode = t,
                              (i = (o = this.props).selectInputOnMount) !=
                                null && i.call(o) && t.select();
                          },
                          "aria-disabled": () =>
                            this.getIsDisabled() ||
                            this.hasEditableLabel() ||
                            this.getIsReadonly(),
                          value: this.bindFn(this.getLabel),
                          onInput: this.bindFn(this.onLabelInput),
                        });
                      })),
                  true: () =>
                    toe(() => {
                      var e, t;
                      return (t = (e = this.props).displayComputedValue) == null
                        ? void 0
                        : t.call(e);
                    }, (e) =>
                      ln.createElement(
                        "div",
                        { class: ln.const("dcg-computed-label-value") },
                        ln.createElement(nt, {
                          latex: e,
                          config: () => this.controller.getMathquillConfig({}),
                        }),
                      )),
                }),
            }),
          );
      }
      getEditableLabelOptions() {
        return [{
          key: "math",
          label: () =>
            this.controller.s("graphing-calculator-button-editable-math"),
          selected: () => this.model().editableLabelMode === "MATH",
          onSelect: () => this.setEditableLabelMode("MATH"),
        }, {
          key: "text",
          label: () =>
            this.controller.s("graphing-calculator-button-editable-text"),
          selected: () => this.model().editableLabelMode === "TEXT",
          onSelect: () => this.setEditableLabelMode("TEXT"),
        }];
      }
      setEditableLabelMode(e) {
        this.controller.dispatch({
          type: "set-item-editable-label-mode",
          id: this.id(),
          editableLabelMode: e,
        });
      }
      getIsReadonly() {
        return this.controller.isItemReadonly(this.model().id);
      }
      model() {
        return this.props.model();
      }
      id() {
        return this.model().id;
      }
      getLabel() {
        return this.model().label || "";
      }
      hasEditableLabel() {
        return xb(this.model());
      }
      getShowLabel() {
        var e, t;
        return ja(this.model()) &&
          !((t = (e = this.props).displayComputedValue) != null &&
            t.call(e));
      }
      getIsDisabled() {
        var e, t;
        return (t = (e = this.props).forceEnabled) != null && t.call(e) ||
            document.activeElement === this.inputNode
          ? false
          : this.getLabel().length === 0 && !this.getShowLabel();
      }
      onLabelInput(e) {
        let t = e;
        this.controller.dispatch({
          type: "set-item-label",
          id: this.id(),
          label: t,
        }),
          this.controller.dispatch({
            type: "set-item-showlabel",
            id: this.id(),
            showLabel: !!t,
          });
      }
      onCheckboxInput() {
        this.controller.dispatch({
          type: "set-item-showlabel",
          id: this.id(),
          showLabel: !this.getShowLabel(),
        });
      }
    };
  var Ta = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var hv = class extends Ta.Class {
    constructor() {
      super(...arguments),
        this.controller = this.props.controller(),
        this.id = this.props.id();
    }
    template() {
      return Ta.createElement(
        "div",
        {
          class: Ta.const("dcg-prompt-rename"),
          handleEvent: Ta.const("true"),
        },
        () => Ls("graphing-calculator-label-rename"),
        Ta.createElement(
          "span",
          {
            class: Ta.const("dcg-btn-light-gray"),
            onTap: this.bindFn(this.handleRename),
            tabIndex: Ta.const(0),
            role: Ta.const("button"),
          },
          Ta.createElement(
            nt,
            {
              latex: () =>
                `${this.getRenameIdentifierFrom()} \\to ${this.getRenameIdentifierTo()}`,
              config: this.const({}),
            },
            Ta.createElement("span", {
              style: Ta.const("pointer-events:none"),
            }),
          ),
        ),
        Ta.createElement("span", {
          class: Ta.const("dcg-reference-count"),
        }, () =>
          Ls(
            this.getRenameIdentifierFolderId() !== void 0
              ? "graphing-calculator-label-reference-count-in-folder"
              : "graphing-calculator-label-reference-count",
            {
              count: __dcg_shared_module_exports__["ra"](
                this.getRenameCountOfChanges(),
              ),
            },
          )),
      );
    }
    getRenameIdentifierFrom() {
      let e = this.controller.getSuggestedIdentifierRenameInfo(this.id);
      return e && e.from || "";
    }
    getRenameIdentifierTo() {
      let e = this.controller.getSuggestedIdentifierRenameInfo(this.id);
      return e && e.to || "";
    }
    getRenameCountOfChanges() {
      let e = this.controller.getSuggestedIdentifierRenameInfo(this.id);
      return e && e.countOfChanges || 0;
    }
    getRenameIdentifierFolderId() {
      let e = this.controller.getSuggestedIdentifierRenameInfo(this.id);
      return e == null ? void 0 : e.folderId;
    }
    handleRename() {
      let e = {
          search: this.getRenameIdentifierFrom(),
          replace: this.getRenameIdentifierTo(),
        },
        t = this.getRenameIdentifierFolderId();
      t === void 0
        ? this.controller.dispatch({
          type: "rename-identifier-global",
          ...e,
        })
        : this.controller.dispatch({
          type: "rename-identifier-in-item",
          id: t,
          ...e,
        });
    }
  };
  var oi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { For: roe, If: ooe } = oi.Components,
    Ec = class extends oi.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.promptGroupId = `prompt-slider-${Dd()}`;
      }
      template() {
        return oi.createElement(
          "div",
          {
            class: oi.const("dcg-create-sliders"),
            handleEvent: oi.const("true"),
            role: oi.const("group"),
            "aria-labelledby": this.const(this.promptGroupId),
          },
          oi.createElement("span", {
            class: oi.const("dcg-msg"),
            id: this.const(this.promptGroupId),
          }, this.bindFn(this.getPromptMsg)),
          oi.createElement(
            "span",
            { class: oi.const("btns") },
            oi.createElement(
              "span",
              null,
              oi.createElement(roe, {
                each: this.bindFn(this.getMissingVariables),
              }, (e) =>
                oi.createElement(
                  "div",
                  { class: oi.const("dcg-slider-btn-container") },
                  oi.createElement(
                    "button",
                    {
                      class: () => ({
                        "dcg-btn-slider": true,
                        "dcg-btn-blue": this.getMissingVariables().length === 1,
                        "dcg-base-case-btn":
                          this.getMissingBaseCases().length > 0,
                        "dcg-btn-light-gray":
                          this.getMissingVariables().length !== 1,
                      }),
                      onTap: (t) => this.onCreateSlider(t, [e]),
                    },
                    oi.createElement(nt, {
                      config: this.const({}),
                      latex: () => e,
                    }),
                  ),
                )),
            ),
            oi.createElement(ooe, {
              predicate: () => this.getMissingVariables().length > 1,
            }, () =>
              oi.createElement(
                "div",
                { class: oi.const("dcg-slider-btn-container dcg-all") },
                oi.createElement(
                  "button",
                  {
                    class: oi.const("dcg-btn-slider dcg-btn-blue"),
                    onTap: (e) =>
                      this.onCreateSlider(e, this.getMissingVariables()),
                  },
                  () =>
                    this.controller.s(
                      "graphing-calculator-button-slider-add-all-variables",
                    ),
                ),
              )),
          ),
        );
      }
      getPromptMsg() {
        return this.getMissingBaseCases().length > 0
          ? this.controller.s("graphing-calculator-label-add-base-case")
          : this.controller.s("graphing-calculator-label-add-slider");
      }
      onCreateSlider(e, t) {
        this.model.type === "ticker"
          ? this.controller.dispatch({
            type: "create-sliders-for-ticker",
            variables: t,
          })
          : this.controller.dispatch({
            type: "create-sliders-for-item",
            id: this.model.id,
            variables: t,
          }),
          e.device === "keyboard" &&
          this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "expression", id: this.model.id },
          });
      }
      getMissingBaseCases() {
        return this.model.type !== "expression" ? [] : Ep(this.model);
      }
      getMissingVariables() {
        let e = this.getMissingBaseCases();
        return e.length > 0
          ? e
          : (this.model.type === "ticker" ? Sw(this.model) : Iw(this.model))
            .slice(0, zw);
      }
    };
  var Ke = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var gv = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var pl = class extends gv.Class {
    init() {
      this.controller = this.props.controller();
    }
    template() {
      return gv.createElement(
        Mo,
        {
          latex: this.props.latex,
          brailleShouldFocus: this.bindFn(this.shouldFocus),
          onBrailleFocusedChanged: this.bindFn(this.onFocusChange),
          isStatic: this.const(true),
          ariaLabel: this.props.brailleAriaLabel || this.props.ariaLabel,
          ...ui(this.controller),
          onBrailleKeydown: (e) => {
            var t, o;
            return (o = (t = this.props).onKeypress) == null
              ? void 0
              : o.call(t, e);
          },
          tabIndex: () => this.props.tabbable() ? 0 : -1,
        },
        gv.createElement($b, {
          latex: this.props.latex,
          config: this.const({ tabbable: this.props.tabbable() }),
          isFocused: this.bindFn(this.shouldFocus),
          onFocusedChanged: this.bindFn(this.onFocusChange),
          getAriaLabel: this.props.ariaLabel,
          onUserPressedKey: (e, t) => {
            t && this.props.onKeypress && this.props.onKeypress(t);
          },
        }),
      );
    }
    shouldFocus() {
      return __dcg_shared_module_exports__["E"](
        this.props.focusLocation(),
        this.controller.getFocusLocation(),
      );
    }
    onFocusChange(e) {
      e
        ? this.controller.dispatch({
          type: "set-focus-location",
          location: this.props.focusLocation(),
        })
        : this.controller.dispatch({
          type: "blur-focus-location",
          location: this.props.focusLocation(),
        });
    }
  };
  var W8 = 1e-6, $8 = 1e9;
  function fP(r, e) {
    let t = Math.max(bP(r.parameters[e]), r.displayPrecision);
    return __dcg_shared_module_exports__["truncatedLatexLabel"](
      r.parameters[e],
      {
        digits: t,
        scientificNotationDigits: t - 1,
        smallCutoff: W8,
        bigCutoff: $8,
      },
    );
  }
  function bP(r) {
    let e = Math.abs(r);
    if (e >= $8 || e < W8 || e <= 1) return 6;
    let t = Math.floor(Math.log10(e)) + 1;
    return Math.min(9, t + 5);
  }
  function yP(r) {
    return __dcg_shared_module_exports__["truncatedLatexLabel"](r, {
      zeroCutoff: 1e-15,
      digits: 4,
      smallCutoff: 1e-6,
      bigCutoff: 1e9,
    });
  }
  var ns = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: ioe } = ns.Components,
    ZT = class extends ns.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return ns.createElement(
          ioe,
          {
            predicate: () =>
              this.controller.showResidualsZoomFitButton(this.model),
          },
          () =>
            ns.createElement(
              "div",
              {
                class: ns.const("dcg-residuals-zoom-view dcg-do-blur"),
                handleEvent: ns.const(true),
              },
              ns.createElement(
                Le,
                {
                  tooltip: this.bindFn(this.getZoomText),
                  gravity: () => "e",
                },
                ns.createElement("i", {
                  onTap: this.bindFn(this.onZoom),
                  role: ns.const("button"),
                  tabIndex: ns.const("0"),
                  "aria-label": this.bindFn(this.getZoomText),
                  class: ns.const("dcg-icon-zoom-fit"),
                  manageFocus: this.const(
                    rt({
                      controller: this.controller,
                      location: {
                        type: "regression-output",
                        id: this.props.model().id,
                        parameter: "residual-zoom",
                      },
                    }),
                  ),
                }),
              ),
            ),
        );
      }
      getZoomText() {
        return this.controller.s("graphing-calculator-text-zoom-fit");
      }
      onZoom(e) {
        this.controller.dispatch({
          type: "expression-zoom-fit-residuals",
          id: this.model.id,
          focusAfterTap: e.device === "keyboard",
        });
      }
    };
  var { If: oh, For: j8, IfElse: noe } = Ke.Components,
    eD = class extends Ke.Class {
      template() {
        return Ke.createElement(
          "div",
          {
            class: Ke.const("dcg-parameter-warning dcg-text-selectable"),
            role: Ke.const("note"),
          },
          Ke.createElement("i", {
            class: Ke.const("dcg-icon-error"),
            "aria-hidden": Ke.const("true"),
          }),
          Ke.const("\xA0"),
          () =>
            this.props.controller().s(
              "graphing-calculator-text-regression-potentially-inaccurate-parameters",
            ),
          Ke.const("\xA0"),
          Ke.createElement("a", {
            href: Ke.const(
              "https://help.desmos.com/hc/en-us/articles/360042942771",
            ),
            target: Ke.const("_blank"),
          }, () =>
            this.props.controller().s(
              "graphing-calculator-link-learn-more",
            )),
        );
      }
    },
    Yb = class extends Ke.Class {
      template() {
        return Ke.createElement(
          Le,
          { tooltip: this.props.tooltip, gravity: this.const("s") },
          Ke.createElement(
            "a",
            {
              class: Ke.const("dcg-expression-footer-title-help"),
              target: Ke.const("_blank"),
              href: this.props.helpURL,
              "aria-label": this.props.tooltip,
            },
            Ke.createElement("i", {
              class: Ke.const("dcg-icon-question-sign"),
              "aria-hidden": Ke.const("true"),
            }),
          ),
        );
      }
    },
    Xb = class extends Ke.Class {
      template() {
        return this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.id = this.model.id,
          Ke.createElement(
            "div",
            { class: Ke.const("dcg-regression-footer-view") },
            Ke.createElement(
              "div",
              {
                class: Ke.const("dcg-handle-event"),
                handleEvent: Ke.const("true"),
              },
              Ke.createElement(oh, {
                predicate: () => {
                  var e, t;
                  return this.hasParameterWarning() &&
                    !!((t = (e = this.props).hideParameters) != null &&
                      t.call(e));
                },
              }, () => Ke.createElement(eD, { ...this.props })),
              Ke.createElement(oh, {
                predicate: this.bindFn(this.getShouldSuggestLogMode),
              }, () =>
                Ke.createElement(
                  "div",
                  { class: Ke.const("dcg-log-mode-toggle") },
                  noe(() => this.areLogModeRegressionsForced(), {
                    true: () =>
                      Ke.createElement("div", {
                        class: Ke.const(
                          "dcg-action-log-mode-toggle dcg-no-hover-styling",
                        ),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-button-regression-log-mode",
                        )),
                    false: () =>
                      Ke.createElement(
                        "div",
                        null,
                        Ke.createElement(mt, {
                          class: this.const(
                            "dcg-action-log-mode-toggle dcg-log-mode-checkbox",
                          ),
                          onChange: this.bindFn(this.onTapLogMode),
                          checked: () => this.getIsLogModeRegression(),
                        }, () =>
                          this.controller.s(
                            "graphing-calculator-button-regression-log-mode",
                          )),
                        Ke.createElement(Yb, {
                          helpURL: this.const(
                            "https://help.desmos.com/hc/en-us/articles/204349605",
                          ),
                          tooltip: () =>
                            this.controller.s(
                              "graphing-calculator-label-regression-log-mode-help-tooltip",
                            ),
                        }),
                      ),
                  }),
                )),
              Ke.createElement(oh, {
                predicate: () =>
                  this.shouldShowParameters() &&
                  Object.keys(this.getRegression().parameters).length > 0,
              }, () =>
                Ke.createElement(xP, {
                  controller: this.props.controller,
                  id: this.const(this.id),
                  regression: () => this.getRegression(),
                })),
              Ke.createElement(
                "div",
                {
                  class: Ke.const("dcg-statistics"),
                  role: Ke.const("region"),
                  "aria-label": () =>
                    this.controller.s(
                      "graphing-calculator-heading-regression-statistics",
                    ),
                },
                Ke.createElement(
                  "div",
                  { class: Ke.const("dcg-expression-footer-title") },
                  () =>
                    this.controller.s(
                      "graphing-calculator-heading-regression-statistics",
                    ),
                  Ke.createElement(oh, {
                    predicate: this.bindFn(this.showRMSENotice),
                  }, () =>
                    Ke.createElement(Yb, {
                      helpURL: this.const(
                        "https://help.desmos.com/hc/en-us/articles/202529129-What-is-RMSE-",
                      ),
                      tooltip: () =>
                        this.controller.s(
                          "graphing-calculator-label-regression-what-is-rmse-tooltip",
                        ),
                    })),
                  Ke.createElement(oh, {
                    predicate: this.bindFn(
                      this.showNegativeRSquaredWarning,
                    ),
                  }, () =>
                    Ke.createElement(Yb, {
                      helpURL: this.const(
                        "https://help.desmos.com/hc/en-us/articles/202529139-Why-am-I-seeing-a-negative-R-2-value-",
                      ),
                      tooltip: () =>
                        this.controller.s(
                          "graphing-calculator-label-regression-why-is-negative-tooltip",
                        ),
                    })),
                ),
                Ke.createElement(
                  "div",
                  { class: Ke.const("dcg-statistics-values") },
                  Ke.createElement(j8, {
                    each: this.bindFn(this.getStatisticsSections),
                    key: (e) => e.type + ":" + e.value,
                  }, (e) => {
                    let t = e.value;
                    return t === void 0
                      ? Ke.createElement(
                        "div",
                        null,
                        Ke.createElement(es, {
                          mqConfig: this.const({}),
                          content: () =>
                            this.controller.s(
                              "graphing-calculator-text-undefined-parameter",
                              { parameter: "`" + e.type + "`" },
                            ),
                        }),
                      )
                      : Ke.createElement(
                        "div",
                        {
                          class: () => ({
                            "dcg-indented-r-value": e.type === "r",
                          }),
                        },
                        Ke.createElement(pl, {
                          latex: () => `\\operatorname{${e.type}}=` + yP(t),
                          ariaLabel: this.const(""),
                          tabbable: this.const(true),
                          focusLocation: this.const({
                            type: "regression-output",
                            id: this.id,
                            parameter: e.type,
                          }),
                          controller: this.props.controller,
                        }),
                      );
                  }),
                ),
              ),
              Ke.createElement(
                "div",
                {
                  role: Ke.const("region"),
                  "aria-label": () =>
                    this.controller.s(
                      "graphing-calculator-heading-regression-residuals",
                    ),
                  class: Ke.const("dcg-residuals"),
                },
                Ke.createElement("div", {
                  class: Ke.const("dcg-expression-footer-title"),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-heading-regression-residuals",
                  )),
                Ke.createElement(pl, {
                  latex: this.bindFn(this.getResidualVariable),
                  ariaLabel: this.const(""),
                  tabbable: this.const(true),
                  focusLocation: this.const({
                    type: "regression-output",
                    id: this.id,
                    parameter: this.getResidualVariable(),
                  }),
                  controller: this.props.controller,
                }),
                Ke.createElement(oh, {
                  predicate: this.bindFn(
                    this.getResidualSuggestionVisible,
                  ),
                }, () =>
                  Ke.createElement(
                    "div",
                    {
                      class: Ke.const(
                        "dcg-residual-suggestion dcg-action-plot-residual dcg-btn dcg-btn-light-gray",
                      ),
                      role: Ke.const("button"),
                      tabIndex: Ke.const("0"),
                      onTap: this.bindFn(this.onTapResidualsSuggestion),
                    },
                    () =>
                      this.controller.s(
                        "graphing-calculator-button-regression-plot-residuals",
                      ),
                  )),
                Ke.createElement(ZT, {
                  model: this.props.model,
                  controller: this.props.controller,
                }),
              ),
              Ke.createElement("div", { class: Ke.const("dcg-clear") }),
              Ke.createElement(oh, {
                predicate: () => {
                  var e, t;
                  return this.hasParameterWarning() &&
                    !((t = (e = this.props).hideParameters) != null &&
                      t.call(e));
                },
              }, () => Ke.createElement(eD, { ...this.props })),
            ),
          );
      }
      showNegativeRSquaredWarning() {
        let e = this.getStatisticsSections();
        return __dcg_shared_module_exports__["k"](
          e,
          (t) => t.type === "R^2" && t.value !== void 0 && t.value < 0,
        );
      }
      showRMSENotice() {
        let e = this.getStatisticsSections();
        return __dcg_shared_module_exports__["k"](
          e,
          (t) => t.type === "RMSE",
        );
      }
      getStatisticsSections() {
        var o, i, n, a, s, l;
        let e = [], t = this.getRegression().statistics;
        return t.RMSE !== void 0 &&
          ((i = (o = this.props).suppressRMSE) != null && i.call(o)
            ? e.push({ type: "R^2", value: void 0 })
            : e.push({ type: "RMSE", value: t.RMSE })),
          t.Rsquared !== void 0 &&
          e.push({ type: "R^2", value: t.Rsquared }),
          t.rsquared !== void 0 &&
          e.push({ type: "R^2", value: t.rsquared }),
          t.r !== void 0 &&
            ((a = (n = this.props).showRValue) == null ? void 0 : a.call(n)) !==
              "never"
            ? e.push({ type: "r", value: t.r })
            : ((l = (s = this.props).showRValue) == null
                  ? void 0
                  : l.call(s)) === "always" &&
              e.push({ type: "r", value: void 0 }),
          e;
      }
      shouldShowParameters() {
        return !this.props.hideParameters || !this.props.hideParameters();
      }
      onTapResidualsSuggestion() {
        this.controller.dispatch({ type: "plot-residuals", id: this.id });
      }
      onTapLogMode() {
        this.controller.dispatch({ type: "toggle-logmode", id: this.id });
      }
      getRegression() {
        return this.props.regression();
      }
      getResidualVariable() {
        return this.getRegression().residualVariable || "";
      }
      getResidualSuggestionVisible() {
        return this.getRegression().residualSuggestionId !== void 0;
      }
      areLogModeRegressionsForced() {
        return this.controller.areLogModeRegressionsForced();
      }
      getShouldSuggestLogMode() {
        var e, t;
        return (t = (e = this.props).suppressLogModeCheckbox) != null &&
            t.call(e)
          ? false
          : !!this.getRegression().shouldSuggestLogMode;
      }
      hasParameterWarning() {
        return !!this.getRegression().parameterWarning;
      }
      getIsLogModeRegression() {
        var e;
        return this.model.type === "expression"
          ? !!this.model.isLogModeRegression
          : !!((e = this.model.regression) != null && e.isLogMode);
      }
    },
    xP = class extends Ke.Class {
      init() {
        this.controller = this.props.controller(), this.id = this.props.id();
      }
      template() {
        return Ke.createElement(
          "div",
          { class: Ke.const("dcg-parameters-container") },
          Ke.createElement(
            "div",
            { class: Ke.const("dcg-expression-footer-title") },
            () =>
              this.controller.s(
                "graphing-calculator-heading-regression-parameters",
              ),
            Ke.createElement(oh, {
              predicate: () => !this.props.regression().isLinear,
            }, () =>
              Ke.createElement(Yb, {
                helpURL: this.const(
                  "https://help.desmos.com/hc/en-us/articles/360042428612",
                ),
                tooltip: () =>
                  this.controller.s(
                    "graphing-calculator-label-regression-parameters-not-exact",
                  ),
              })),
          ),
          Ke.createElement(
            "div",
            {
              role: Ke.const("region"),
              "aria-label": () =>
                this.controller.s(
                  "graphing-calculator-heading-regression-parameters",
                ),
              class: Ke.const("dcg-parameters"),
            },
            Ke.createElement(j8, {
              each: () => Object.keys(this.props.regression().parameters),
            }, (e) =>
              Ke.createElement(pl, {
                latex: () => this.getParameterEquationLatex(e),
                ariaLabel: this.const(""),
                tabbable: this.const(true),
                focusLocation: this.const({
                  type: "regression-output",
                  id: this.id,
                  parameter: e,
                }),
                controller: this.props.controller,
              })),
          ),
        );
      }
      getParameterEquationLatex(e) {
        return e + "=" + fP(this.props.regression(), e);
      }
    };
  var mi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var hi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  qt();
  var aoe = 0,
    soe = `guid_${Math.round(Math.random() * 1e6)}_${new Date().getTime()}_`;
  function wP(r, e, t) {
    var o;
    (o = r[e]) == null || o.forEach((i) => i.callback(e, t));
  }
  function vP(r, e) {
    e.split(" ").forEach((t) => {
      var n, a;
      let [o, i] = t.split(".");
      if (o && i) {
        r[o] = (n = r[o]) == null ? void 0 : n.filter((s) => s.namespace !== i);
      } else if (o) delete r[o];
      else if (i) {
        for (let s in r) {
          r[s] = (a = r[s]) == null
            ? void 0
            : a.filter((l) => l.namespace !== i);
        }
      }
    });
  }
  function CP(r, e, t) {
    e.split(" ").forEach((o) => {
      var s;
      let [i, n] = o.split("."), a = { namespace: n, callback: t };
      r[i] || (r[i] = []), (s = r[i]) == null || s.push(a);
    });
  }
  var Kl = class {
    constructor() {
      this.__eventObservers = {}, this.guid = soe + ++aoe;
    }
    triggerEvent(e, t) {
      wP(this.__eventObservers, e, t);
    }
    observeEvent(e, t) {
      CP(this.__eventObservers, e, t);
    }
    unobserveEvent(e) {
      vP(this.__eventObservers, e);
    }
  };
  var tD = class {
    constructor() {
      this._eventBus = new Kl();
      this.dragging = false;
      this.guid = __dcg_shared_module_exports__["K"]("dragdrop-class");
    }
    _evt2pt(e) {
      return {
        x: e.changedTouches[0].pageX - this._offsetPt.x,
        y: e.changedTouches[0].pageY - this._offsetPt.y,
      };
    }
    _dispatch(e, t) {
      if (this._destroyed) return;
      let o = this._evt2pt(t);
      this._eventBus.triggerEvent(e, {
        x: o.x,
        y: o.y,
        dx: o.x - this._startPt.x,
        dy: o.y - this._startPt.y,
        evt: t,
      });
    }
    destroy() {
      ee(document).off(`.${this.guid}`), this._destroyed = true;
    }
    startDrag(e, t = {}) {
      if (!this.dragging) {
        return ee(document).on(`dcg-tapmove.${this.guid}`, (o) => {
          (o.originalEvent || o).preventDefault(),
            cancelAnimationFrame(this.frameThrottle),
            this.frameThrottle = requestAnimationFrame(() => this.doDrag(o));
        }),
          ee(document).on(
            `dcg-tapend.${this.guid} dcg-tapcancel.${this.guid}`,
            (o) => this.endDrag(o),
          ),
          this._offsetPt = { x: 0, y: 0 },
          t.origin &&
          (this._offsetPt = {
            x: this._evt2pt(e).x - t.origin.x,
            y: this._evt2pt(e).y - t.origin.y,
          }),
          this._startPt = this._evt2pt(e),
          this.dragging = true,
          this._dispatch("onGrab", e);
      }
    }
    doDrag(e) {
      this.dragging && this._dispatch("onDrag", e);
    }
    endDrag(e) {
      this.dragging &&
        (ee(document).off(`.${this.guid}`),
          this.doDrag(e),
          this.dragging = false,
          this._dispatch("onDrop", e));
    }
    observeEvent(e, t) {
      return this._eventBus.observeEvent(e, t);
    }
  };
  var { If: loe } = hi.Components,
    Kg = class extends hi.Class {
      template() {
        return hi.createElement(
          "div",
          {
            class: () => ({
              "dcg-slider-interior": true,
              "dcg-disable-slider": this.shouldDisableSlider(),
            }),
            didMount: this.bindFn(this.didMountRoot),
            onTapStart: this.bindFn(this.onStartDrag),
          },
          hi.createElement(
            "div",
            { class: hi.const("dcg-track") },
            hi.createElement("div", {
              class: hi.const("dcg-ticks"),
              onMount: this.bindFn(this.didMountTickMarks),
            }),
            hi.createElement("div", { class: hi.const("dcg-graphic") }),
          ),
          hi.createElement(loe, {
            predicate: this.bindFn(this.shouldShowZeroMarker),
          }, () =>
            hi.createElement("div", {
              class: hi.const("dcg-zeroMarker"),
              style: () => ({ left: this.getZeroMarkerPercent() + "%" }),
            })),
          hi.createElement(
            "div",
            {
              class: () => ({
                "dcg-thumb": true,
                "dcg-down": this.isDragging,
              }),
              role: hi.const("slider"),
              tabIndex: hi.const("0"),
              disablescroll: hi.const("true"),
              style: () => ({ left: this.getThumbPercent() + "%" }),
              onKeyDown: this.bindFn(this.onKeyDown),
              "aria-label": this.props.ariaLabel,
              "aria-valuemin": () => {
                var e, t;
                return (t = (e = this.props).ariaPercent) != null &&
                    t.call(e)
                  ? 0
                  : this.props.min();
              },
              "aria-valuemax": () => {
                var e, t;
                return (t = (e = this.props).ariaPercent) != null &&
                    t.call(e)
                  ? 100
                  : this.props.max();
              },
              "aria-valuenow": () => {
                var e, t;
                return (t = (e = this.props).ariaPercent) != null &&
                    t.call(e)
                  ? void 0
                  : this.props.value();
              },
              "aria-valuetext": () => {
                var e, t;
                return (t = (e = this.props).ariaPercent) != null &&
                    t.call(e)
                  ? `${Math.floor(this.getThumbPercent())}%`
                  : void 0;
              },
              manageFocus: this.buildFocusManager(),
            },
            hi.createElement("div", { class: hi.const("dcg-graphic") }),
            hi.createElement("div", { class: hi.const("dcg-center") }),
          ),
        );
      }
      willUnmount() {
        this.dragDrop.destroy();
      }
      didMountRoot(e) {
        this.rootNode = e,
          this.dragDrop = new tD(),
          this.isMounted = true,
          this.dragDrop.observeEvent("onDrop", () => {
            this.isDragging = false,
              this.update(),
              this.props.onDrop && this.props.onDrop();
          }),
          this.dragDrop.observeEvent("onGrab", () => {
            this.isDragging = true,
              this.update(),
              this.props.onGrab && this.props.onGrab();
          }),
          this.dragDrop.observeEvent("onDrag", (t, o) => {
            this.props.onDragUpdate(this.valueFromPixels(o.x));
          });
      }
      didMountTickMarks(e) {
        this.tickMarksNode = e, this.renderTickMarks();
      }
      didUpdate() {
        this.renderTickMarks();
      }
      shouldDisableSlider() {
        return this.props.min() === this.props.max();
      }
      renderTickMarks() {
        if (!this.tickMarksNode) return;
        let e = this.props.step(),
          t = this.props.min(),
          o = this.props.max(),
          i;
        if (
          e === void 0 ? i = 0 : i = 100 * e / (o - t),
            i < 3 && (i = 0),
            i > 100 && (i = 0),
            isNaN(i) && (i = 0),
            this.lastTickMarksPercent === i
        ) return;
        this.lastTickMarksPercent = i;
        let n = "";
        if (i > 0 && i < 100) {
          for (let a = i; a < 100; a += i) {
            n += '<div class="dcg-tick" style="left:' + a + '%"></div>';
          }
        }
        this.tickMarksNode.innerHTML = n;
      }
      shouldShowZeroMarker() {
        return this.props.min() <= 0 && this.props.max() >= 0;
      }
      getZeroMarkerPercent() {
        let e = this.props.min(), t = this.props.max();
        return 100 * (0 - e) / (t - e);
      }
      getThumbPercent() {
        return 100 * this.percentFromValue(this.props.value());
      }
      valueFromPixels(e) {
        if (!this.isMounted) return 0;
        let t = this.props.min(),
          o = this.props.max(),
          i = this.rootNode.getBoundingClientRect().width,
          n = __dcg_shared_module_exports__["clamp"](e / i, 0, 1),
          a = t + (o - t) * n,
          s = (o - t) / i;
        return ho(a - s, a + s);
      }
      percentFromValue(e) {
        let t = this.props.min(), o = this.props.max();
        return __dcg_shared_module_exports__["clamp"](
          (e - t) / (o - t),
          0,
          1,
        );
      }
      pixelsFromValue(e) {
        if (!this.isMounted) return 0;
        let t = this.percentFromValue(e);
        return this.rootNode.getBoundingClientRect().width * t;
      }
      onKeyDown(e) {
        switch (ke(e)) {
          case xa:
            this.props.onUpPress &&
              (this.props.onUpPress(), e.preventDefault(), e.stopPropagation());
            break;
          case Kn:
            this.props.onDownPress &&
              (this.props.onDownPress(),
                e.preventDefault(),
                e.stopPropagation());
            break;
          case xg:
            this.props.onEnterPress &&
              (this.props.onEnterPress(),
                e.preventDefault(),
                e.stopPropagation());
            break;
          case kn:
            document.activeElement &&
              ee(document.activeElement).trigger("blur");
            break;
          case ld:
            this.props.onKeyboardUpdate("down"),
              e.preventDefault(),
              e.stopPropagation();
            break;
          case cd:
            this.props.onKeyboardUpdate("up"),
              e.preventDefault(),
              e.stopPropagation();
            break;
          case Au:
            this.props.onKeyboardUpdate("bigdown"),
              e.preventDefault(),
              e.stopPropagation();
            break;
          case Iu:
            this.props.onKeyboardUpdate("bigup"),
              e.preventDefault(),
              e.stopPropagation();
            break;
          case wg:
            this.props.onKeyboardUpdate("min"),
              e.preventDefault(),
              e.stopPropagation();
            break;
          case fp:
            this.props.onKeyboardUpdate("max"),
              e.preventDefault(),
              e.stopPropagation();
            break;
        }
      }
      onStartDrag(e) {
        if (e.device === "keyboard" || !e.target) return;
        e.preventDefault(), Jr();
        let t = { x: 0, y: 0 };
        e.target.closest(".dcg-thumb")
          ? t.x = this.pixelsFromValue(this.props.value())
          : t.x = e.changedTouches[0].clientX -
            this.rootNode.getBoundingClientRect().left,
          this.dragDrop.startDrag(e, { origin: t });
      }
      buildFocusManager() {
        return !this.props.onFocusedChanged || !this.props.isFocused
          ? this.const(void 0)
          : this.const({
            shouldBeFocused: this.props.isFocused,
            onFocusedChanged: this.props.onFocusedChanged,
          });
      }
    };
  var gi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: coe } = gi.Components,
    mv = class extends gi.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.id = this.model.id;
      }
      template() {
        return gi.createElement(
          "div",
          {
            class: gi.const("dcg-slider_menu dcg-do-blur"),
            handleEvent: gi.const("true"),
            didMount: (e) => this.node = e,
          },
          gi.createElement(
            "div",
            { class: gi.const("dcg-editable-mathquill-container") },
            gi.createElement(coe, {
              predicate: () => !this.shouldOnlyShowStep(),
            }, () =>
              gi.createElement(
                "span",
                null,
                gi.createElement(lr, {
                  readonly: () => this.controller.isItemReadonly(this.id),
                  latex: () =>
                    this.model.slider.hardMin ? this.model.slider.min : "",
                  isFocused: () => this.getFocusedInput() === "min",
                  ariaLabel: () =>
                    this.controller.s(
                      "graphing-calculator-narration-slider-minimum",
                    ),
                  brailleLabel: () => this.controller.raw("sldrmin"),
                  handleFocusChanged: (e, t) =>
                    this.handleFocusedChanged("min", e, t),
                  hasError: () => !ZE(this.model),
                  controller: this.props.controller,
                  handlePressedKey: (e, t) =>
                    this.handlePressedKey("min", e, t),
                  handleLatexChanged: (e) => this.handleLatexChanged("min", e),
                  dataLabelAttributeValue: this.const("slidermin"),
                }),
                gi.createElement(
                  "span",
                  { class: gi.const("dcg-interval-interior") },
                  gi.createElement(nt, {
                    latex: this.bindFn(this.getDependentLatex),
                    config: this.const({}),
                  }, gi.createElement("span", null)),
                ),
                gi.createElement(lr, {
                  readonly: () => this.controller.isItemReadonly(this.id),
                  latex: () =>
                    this.model.slider.hardMax ? this.model.slider.max : "",
                  isFocused: () => this.getFocusedInput() === "max",
                  ariaLabel: () =>
                    this.controller.s(
                      "graphing-calculator-narration-slider-maximum",
                    ),
                  brailleLabel: () => this.controller.raw("sldrmax"),
                  handleFocusChanged: (e, t) =>
                    this.handleFocusedChanged("max", e, t),
                  hasError: () => !eT(this.model),
                  controller: this.props.controller,
                  handlePressedKey: (e, t) =>
                    this.handlePressedKey("max", e, t),
                  handleLatexChanged: (e) => this.handleLatexChanged("max", e),
                  dataLabelAttributeValue: this.const("slidermax"),
                }),
              )),
            gi.createElement(
              "span",
              {
                class: () => ({
                  "dcg-slider-step-container": !this.shouldOnlyShowStep(),
                }),
              },
              gi.createElement("span", {
                class: gi.const("dcg-slider-step-label"),
                "aria-hidden": gi.const("true"),
              }, () =>
                this.controller.s(
                  "graphing-calculator-label-slider-step",
                )),
              gi.createElement(lr, {
                readonly: () => this.controller.isItemReadonly(this.id),
                latex: () => this.model.slider.step,
                isFocused: () => this.getFocusedInput() === "step",
                ariaLabel: () =>
                  this.controller.s(
                    "graphing-calculator-narration-slider-step",
                  ),
                brailleLabel: () => this.controller.raw("sldrstep"),
                handleFocusChanged: (e, t) =>
                  this.handleFocusedChanged("step", e, t),
                hasError: () => !tT(this.model),
                controller: this.props.controller,
                handlePressedKey: (e, t) => this.handlePressedKey("step", e, t),
                handleLatexChanged: (e) => this.handleLatexChanged("step", e),
                dataLabelAttributeValue: this.const("sliderstep"),
              }),
            ),
          ),
        );
      }
      handlePressedKey(e, t, o) {
        if (
          !this.controller.isInEditListMode() &&
          !this.shouldOnlyShowStep() && (t === "Esc" || t === "Enter")
        ) {
          this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "slider-thumb", id: this.id },
          });
          return;
        }
        let i = Fe.getFocusedMathquill(), n = os();
        if (t === "Left" || t === "Right" || t === "Down" || t === "Up") {
          let a;
          i ? a = Fe.applyArrowKeyAndReturnIfWasAtBounds(i, t, o) : n &&
              (n.selectionStart === 0 && t === "Left" ||
                n.selectionStart === n.value.length && t === "Right" ||
                t === "Up" || t === "Down")
            ? a = true
            : a = false,
            a &&
            (o && o.preventDefault(),
              t === "Left" && !this.shouldOnlyShowStep()
                ? e === "max"
                  ? this.controller.dispatch({
                    type: "set-focus-location",
                    location: {
                      type: "slider-limit",
                      id: this.id,
                      location: "min",
                    },
                  })
                  : e === "step" &&
                    this.controller.dispatch({
                      type: "set-focus-location",
                      location: {
                        type: "slider-limit",
                        id: this.id,
                        location: "max",
                      },
                    })
                : t === "Right" && !this.shouldOnlyShowStep()
                ? e === "min"
                  ? this.controller.dispatch({
                    type: "set-focus-location",
                    location: {
                      type: "slider-limit",
                      id: this.id,
                      location: "max",
                    },
                  })
                  : e === "max" &&
                    this.controller.dispatch({
                      type: "set-focus-location",
                      location: {
                        type: "slider-limit",
                        id: this.id,
                        location: "step",
                      },
                    })
                : t === "Down"
                ? this.controller.dispatch({
                  type: "on-special-key-pressed",
                  key: "Down",
                })
                : t === "Up" &&
                  this.controller.dispatch({
                    type: "set-focus-location",
                    location: { type: "expression", id: this.id },
                  }));
          return;
        }
        i && (i.keystroke(t, o), this.handleLatexChanged(e, i.latex()));
      }
      shouldOnlyShowStep() {
        return this.model.slider.loopMode === "PLAY_INDEFINITELY";
      }
      handleLatexChanged(e, t) {
        e === "min"
          ? this.dispatchMinLatexIfChanged(t)
          : e === "max"
          ? this.dispatchMaxLatexIfChanged(t)
          : e === "step" && this.dispatchStepLatexIfChanged(t);
      }
      handleFocusedChanged(e, t, o) {
        t && this.getFocusedInput() !== e
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "slider-limit", id: this.id, location: e },
          })
          : this.getFocusedInput() === e &&
            this.controller.getBrailleMode() === "none" &&
            (!o.relatedTarget || !this.node.contains(o.relatedTarget)) &&
            this.controller.dispatch({
              type: "blur-focus-location",
              location: {
                type: "slider-limit",
                id: this.id,
                location: e,
              },
            });
      }
      dispatchMinLatexIfChanged(e) {
        this.model.slider.min !== e &&
          this.controller.dispatch({
            type: "set-slider-minlatex",
            id: this.id,
            latex: e,
          });
      }
      dispatchMaxLatexIfChanged(e) {
        this.model.slider.max !== e &&
          this.controller.dispatch({
            type: "set-slider-maxlatex",
            id: this.id,
            latex: e,
          });
      }
      dispatchStepLatexIfChanged(e) {
        this.model.slider.step !== e &&
          this.controller.dispatch({
            type: "set-slider-steplatex",
            id: this.id,
            latex: e,
          });
      }
      getDependentLatex() {
        let e = Ya(this.model) || "";
        return " \\le " +
          __dcg_shared_module_exports__["identifierToLatex"](e) +
          " \\le ";
      }
      getFocusedInput() {
        let e = this.controller.getFocusLocation();
        if (!(!e || e.type !== "slider-limit" || e.id !== this.id)) {
          return e.location;
        }
      }
    };
  var { If: Y8 } = mi.Components,
    fv = class extends mi.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.id = this.model.id;
      }
      template() {
        return mi.createElement(
          "div",
          {
            class: mi.const("dcg-slider-container"),
            tapboundary: mi.const("true"),
            onKeyDown: (e) => {
              if (
                ke(e) === "Tab" && !e.altKey && !e.metaKey && !e.ctrlKey
              ) {
                if (e.shiftKey) {
                  if (
                    this.isSliderMinFocused() &&
                    this.controller.isInEditListMode()
                  ) {
                    if (e.target) {
                      let t = e.target.closest(".dcg-expressionitem");
                      if (t) {
                        let o = Array.from(t.querySelectorAll('[tabindex="0"]'))
                          .filter(bp)[0];
                        o == null || o.focus();
                      }
                    }
                    e.preventDefault(), e.stopPropagation();
                  } else {this.isSliderThumbFocused() &&
                      (this.controller.isItemReadonly(this.model.id) ||
                        (this.controller.dispatch({
                          type: "set-focus-location",
                          location: {
                            type: "slider-limit",
                            id: this.id,
                            location: "step",
                          },
                        }),
                          e.preventDefault(),
                          e.stopPropagation()));}
                } else {!e.shiftKey && this.isSliderStepFocused() &&
                    (this.controller.isInEditListMode()
                      ? this.controller.dispatch({
                        type: "set-focus-location",
                        location: { type: "slider-icon", id: this.id },
                      })
                      : this.controller.dispatch({
                        type: "set-focus-location",
                        location: { type: "slider-thumb", id: this.id },
                      }),
                      e.preventDefault(),
                      e.stopPropagation());}
              }
            },
          },
          mi.createElement(Y8, {
            predicate: this.bindFn(this.shouldShowSlider),
          }, () =>
            mi.createElement(
              "div",
              {
                class: mi.const("dcg-do-blur dcg-slider"),
                handleEvent: mi.const("true"),
              },
              mi.createElement(
                "div",
                {
                  class: mi.const(
                    "dcg-minLabel dcg-template-minlabelhtml",
                  ),
                  role: mi.const("button"),
                  "aria-label": this.bindFn(this.getMinAriaLabel),
                  onTap: () => this.onEditLimit("min"),
                },
                mi.createElement(nt, {
                  latex: () => pL(this.model),
                  config: this.const({}),
                  tokenController: this.props.controller,
                }),
              ),
              mi.createElement(Kg, {
                min: () => nl(this.model),
                max: () => bc(this.model),
                step: () => Rl(this.model),
                value: () => al(this.model),
                ariaLabel: () =>
                  this.controller.getBrailleMode() === "none"
                    ? '"' + Ya(this.model) + '"'
                    : "" + Ya(this.model),
                onGrab: this.bindFn(this.onGrab),
                onDrop: this.bindFn(this.onDrop),
                onDragUpdate: this.bindFn(this.onDragUpdate),
                onKeyboardUpdate: this.bindFn(this.onKeyboardUpdate),
                onUpPress: () =>
                  this.controller.dispatch({
                    type: "on-special-key-pressed",
                    key: "Up",
                  }),
                onDownPress: () =>
                  this.controller.dispatch({
                    type: "on-special-key-pressed",
                    key: "Down",
                  }),
                onEnterPress: () =>
                  this.controller.dispatch({
                    type: "on-special-key-pressed",
                    key: "Enter",
                  }),
                isFocused: this.bindFn(this.isSliderThumbFocused),
                onFocusedChanged: (e) => {
                  e
                    ? this.controller.dispatch({
                      type: "set-focus-location",
                      location: { type: "slider-thumb", id: this.id },
                    })
                    : this.controller.dispatch({
                      type: "blur-focus-location",
                      location: { type: "slider-thumb", id: this.id },
                    });
                },
              }),
              mi.createElement(
                "div",
                {
                  class: mi.const(
                    "dcg-maxLabel dcg-template-maxlabelhtml",
                  ),
                  onTap: () => this.onEditLimit("max"),
                  role: mi.const("button"),
                  "aria-label": () =>
                    this.controller.s(
                      "graphing-calculator-narration-slider-maximum",
                    ) + " " + ei(uL(this.model)),
                },
                mi.createElement(nt, {
                  latex: () => uL(this.model),
                  config: this.const({}),
                  tokenController: this.props.controller,
                }),
              ),
            )),
          mi.createElement(
            Y8,
            { predicate: this.bindFn(this.shouldShowLimitInputs) },
            () =>
              mi.createElement(mv, {
                model: this.props.model,
                controller: this.props.controller,
              }),
          ),
        );
      }
      getMinAriaLabel() {
        return this.controller.isItemReadonly(this.model.id)
          ? this.controller.s(
            "graphing-calculator-narration-slider-minimum",
          ) + " " + ei(pL(this.model))
          : this.controller.s(
            "graphing-calculator-narration-edit-slider-variable-limits",
            {
              variable: this.controller.getBrailleMode() === "none"
                ? '"' + Ya(this.model) + '"'
                : "" + Ya(this.model),
            },
          );
      }
      onGrab() {
        this.dispatchIsDraggingIfChanged(true);
      }
      onDrop() {
        this.controller.dispatch({ type: "set-none-selected" }),
          this.dispatchIsPlayingIfChanged(false),
          this.dispatchIsDraggingIfChanged(false);
      }
      onKeyboardUpdate(e) {
        this.controller.dispatch({
          type: "adjust-slider-by-keyboard",
          id: this.id,
          adjustment: e,
        });
      }
      onDragUpdate(e) {
        this.controller.dispatch({
          type: "adjust-slider-by-dragging-thumb",
          id: this.model.id,
          target: e,
        });
      }
      onEditLimit(e) {
        this.controller.dispatch({
          type: "set-focus-location",
          location: { type: "slider-limit", id: this.id, location: e },
        });
      }
      dispatchIsPlayingIfChanged(e) {
        this.model.slider.isPlaying !== e &&
          this.controller.dispatch({
            type: "set-slider-isplaying",
            id: this.id,
            isPlaying: e,
          });
      }
      dispatchIsDraggingIfChanged(e) {
        this.model.sliderDragging !== e &&
          this.controller.dispatch({
            type: "set-slider-dragging",
            id: this.id,
            dragging: e,
          });
      }
      shouldShowLimitInputs() {
        if (this.controller.isInEditListMode()) return true;
        if (this.controller.isItemReadonly(this.model.id)) return false;
        if (
          !ZE(this.model) || !eT(this.model) || !tT(this.model) ||
          this.model.slider.loopMode === "PLAY_INDEFINITELY"
        ) return true;
        let e = this.controller.getFocusLocation();
        return !!(e &&
          (e.type === "slider-limit" || e.type === "expression" ||
            e.type === "top-level-icon" ||
            e.type === "readonly-expression") &&
          e.id === this.id);
      }
      shouldShowSlider() {
        return !this.shouldShowLimitInputs();
      }
      isSliderThumbFocused() {
        let e = this.controller.getFocusLocation();
        return !!(e && e.type === "slider-thumb" && e.id === this.id);
      }
      isSliderMinFocused() {
        let e = this.controller.getFocusLocation();
        return !!(e && e.type === "slider-limit" && e.id === this.id &&
          e.location === "min");
      }
      isSliderStepFocused() {
        let e = this.controller.getFocusLocation();
        return !!(e && e.type === "slider-limit" && e.id === this.id &&
          e.location === "step");
      }
    };
  var Gn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { For: doe } = Gn.Components,
    bv = class extends Gn.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.id = this.model.id;
      }
      template() {
        return Gn.createElement(
          "div",
          {
            class: Gn.const("dcg-stats-footer-container dcg-do-blur"),
            handleEvent: Gn.const("true"),
          },
          Gn.createElement(
            "ul",
            { class: Gn.const("dcg-unstyled-list") },
            Gn.createElement(doe, {
              each: this.bindFn(this.getValues),
              key: (e) => e.parameter + ":" + e.label + ":" + e.value,
            }, (e) => {
              let t = this.controller.s(e.label);
              return Gn.createElement(
                "li",
                { class: Gn.const("dcg-value") },
                Gn.createElement("div", {
                  class: Gn.const("dcg-row-header dcg-text-selectable"),
                }, () => t),
                Gn.createElement(
                  "div",
                  { class: Gn.const("dcg-evaluation") },
                  Gn.createElement(pl, {
                    latex: () => e.value,
                    ariaLabel: () => t,
                    tabbable: this.const(true),
                    focusLocation: this.const({
                      type: "stats-output",
                      id: this.id,
                      parameter: e.parameter,
                    }),
                    controller: this.props.controller,
                    onKeypress: this.bindFn(this.handlePressedKey),
                  }),
                ),
              );
            }),
          ),
        );
      }
      getValues() {
        let e = Tq(this.model);
        return e
          ? [{
            parameter: "min",
            label: "graphing-calculator-label-stats-minimum",
            value: this.getStatValue(e.min),
          }, {
            parameter: "q1",
            label: "graphing-calculator-label-stats-first-quartile",
            value: this.getStatValue(e.q1),
          }, {
            parameter: "median",
            label: "graphing-calculator-label-stats-median",
            value: this.getStatValue(e.median),
          }, {
            parameter: "q3",
            label: "graphing-calculator-label-stats-third-quartile",
            value: this.getStatValue(e.q3),
          }, {
            parameter: "max",
            label: "graphing-calculator-label-stats-maximum",
            value: this.getStatValue(e.max),
          }]
          : [];
      }
      handlePressedKey(e) {
        let t = ke(e);
        if (t) {
          switch (t) {
            case "Up":
              this.controller.dispatch({
                type: "set-focus-location",
                location: { type: "expression", id: this.id },
              }), e.preventDefault();
              break;
            case "PageUp":
            case "PageDown":
            case "Down":
            case "Enter":
              this.controller.dispatch({
                type: "on-special-key-pressed",
                key: t,
              }), e.preventDefault();
              break;
            case "Esc":
              Jr(), e.preventDefault();
              break;
          }
        }
      }
      getStatValue(e) {
        var t;
        return (t = __dcg_shared_module_exports__["truncatedLatexLabel"](e, {
            ...__dcg_shared_module_exports__[
              "DEFAULT_EVALUATION_LABEL_OPTIONS"
            ],
          })) != null
          ? t
          : "";
      }
    };
  var hr = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var yv = class extends hr.Class {
    init() {
      this.controller = this.props.controller(),
        this.model = this.props.model(),
        this.id = this.model.id;
    }
    template() {
      return hr.createElement(
        "div",
        {
          class: hr.const("dcg-ttest-footer-container dcg-do-blur"),
          handleEvent: hr.const("true"),
        },
        hr.createElement(
          "ul",
          { class: hr.const("dcg-unstyled-list") },
          hr.createElement(
            "li",
            {
              class: hr.const("dcg-value"),
              role: hr.const("textbox"),
              "aria-readonly": hr.const("true"),
              tabIndex: hr.const("0"),
              "aria-label": () => "Less than: " + this.getLessThan(),
            },
            hr.createElement(
              "div",
              { class: hr.const("dcg-operator") },
              hr.createElement(nt, {
                config: this.const({}),
                latex: this.const("<"),
              }),
            ),
            hr.createElement(
              "div",
              { class: hr.const("dcg-evaluation") },
              hr.createElement(nt, {
                config: this.const({}),
                latex: () => this.getLessThan(),
              }),
            ),
          ),
          hr.createElement(
            "li",
            {
              class: hr.const("dcg-value"),
              role: hr.const("textbox"),
              "aria-readonly": hr.const("true"),
              tabIndex: hr.const("0"),
              "aria-label": () => "Greater than: " + this.getGreaterThan(),
            },
            hr.createElement(
              "div",
              { class: hr.const("dcg-operator") },
              hr.createElement(nt, {
                config: this.const({}),
                latex: this.const(">"),
              }),
            ),
            hr.createElement(
              "div",
              { class: hr.const("dcg-evaluation") },
              hr.createElement(nt, {
                config: this.const({}),
                latex: () => this.getGreaterThan(),
              }),
            ),
          ),
          hr.createElement(
            "li",
            {
              class: hr.const("dcg-value"),
              role: hr.const("textbox"),
              "aria-readonly": hr.const("true"),
              tabIndex: hr.const("0"),
              "aria-label": () => "Not equal: " + this.getNotEqual(),
            },
            hr.createElement(
              "div",
              { class: hr.const("dcg-operator") },
              hr.createElement(nt, {
                config: this.const({}),
                latex: this.const("\u2260"),
              }),
            ),
            hr.createElement(
              "div",
              { class: hr.const("dcg-evaluation") },
              hr.createElement(nt, {
                config: this.const({}),
                latex: () => this.getNotEqual(),
              }),
            ),
          ),
        ),
      );
    }
    getLessThan() {
      let e = Hw(this.model);
      return e ? __dcg_shared_module_exports__["de"](e.lessThan, 5) : "";
    }
    getGreaterThan() {
      let e = Hw(this.model);
      return e ? __dcg_shared_module_exports__["de"](e.greaterThan, 5) : "";
    }
    getNotEqual() {
      let e = Hw(this.model);
      return e ? __dcg_shared_module_exports__["de"](e.notEqual, 5) : "";
    }
  };
  var jt = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { SwitchUnion: poe, If: X8 } = jt.Components,
    Jb = class extends jt.Class {
      template() {
        return jt.createElement(
          "div",
          { class: jt.const("dcg-toggle-container") },
          jt.createElement(
            "div",
            { class: jt.const("dcg-expression-footer-title") },
            this.props.title,
            jt.createElement(X8, {
              predicate: () => !!this.props.helpLink,
            }, () =>
              jt.createElement(
                "a",
                {
                  "aria-label": () =>
                    this.props.controller().s("account-shell-link-help"),
                  class: jt.const("dcg-expression-footer-title-help"),
                  target: jt.const("_blank"),
                  href: this.props.helpLink,
                },
                jt.createElement("i", {
                  class: jt.const("dcg-icon-question-sign"),
                  "aria-hidden": jt.const("true"),
                }),
              )),
          ),
          jt.createElement(vo, {
            staticConfig: this.bindFn(this.getSegmentedControlOptions),
            ariaGroupLabel: this.props.title,
            disabled: this.bindFn(this.isReadonly),
            theme: this.const("mini"),
            minButtonWidth: this.const(65),
          }),
        );
      }
      isReadonly() {
        return this.props.controller().isItemReadonly(
          this.props.model().id,
        );
      }
      getSegmentedControlOptions() {
        return this.props.options().map((e) => ({
          key: e.name,
          label: () => e.displayName,
          selected: () => this.isSelected(e.name),
          onSelect: () => {
            this.props.controller().dispatch({
              type: "set-visualization-prop",
              id: this.props.model().id,
              prop: this.props.vizProp(),
              value: e.name,
            });
          },
        }));
      }
      isSelected(e) {
        return Tp(this.props.model(), this.props.vizProp()) === e;
      }
    },
    xv = class extends jt.Class {
      template() {
        return this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.id = this.model.id,
          jt.createElement(
            "div",
            {
              class: jt.const(
                "dcg-visualization-parameters-container dcg-do-blur",
              ),
              tapboundary: jt.const("true"),
              handleEvent: jt.const("true"),
            },
            jt.createElement(jb, { ...this.props }),
            jt.createElement(
              "div",
              { class: jt.const("dcg-smaller-font") },
              poe(() => this.getVisualizationType(), {
                boxplot: () =>
                  jt.createElement(
                    "div",
                    null,
                    jt.createElement("div", {
                      class: jt.const("dcg-expression-footer-title"),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-heading-visual-parameters-display-properties",
                      )),
                    this.makeMQInput({
                      prop: "axisOffset",
                      siblingProps: ["breadth"],
                      default: "1",
                      name: () =>
                        this.controller.s(
                          "graphing-calculator-narration-visual-parameters-offset",
                        ),
                    }),
                    this.makeMQInput({
                      prop: "breadth",
                      siblingProps: ["axisOffset"],
                      default: "1",
                      name: () =>
                        Tp(this.model, "alignedAxis") === "y"
                          ? this.controller.s(
                            "graphing-calculator-narration-visual-parameters-width",
                          )
                          : this.controller.s(
                            "graphing-calculator-narration-visual-parameters-height",
                          ),
                    }),
                    jt.createElement(
                      mt,
                      {
                        checked: () => !!Tp(this.model, "showBoxplotOutliers"),
                        disabled: () =>
                          this.controller.isItemReadonly(this.model.id),
                        onChange: this.bindFn(this.onToggleOutliers),
                      },
                      jt.createElement("span", {
                        class: jt.const("dcg-parameter-name"),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-button-visual-parameters-exclude-outliers",
                        )),
                    ),
                  ),
                dotplot: () =>
                  jt.createElement(X8, {
                    predicate: () => Vq(this.model),
                  }, () =>
                    jt.createElement(
                      "div",
                      { class: jt.const("dcg-toggles-container") },
                      jt.createElement(Jb, {
                        ...this.props,
                        vizProp: () => "dotplotXMode",
                        options: () => [{
                          name: "exact",
                          displayName: this.controller.s(
                            "graphing-calculator-button-visual-parameters-exact",
                          ),
                        }, {
                          name: "bin",
                          displayName: this.controller.s(
                            "graphing-calculator-button-visual-parameters-binned",
                          ),
                        }],
                        title: () =>
                          this.controller.s(
                            "graphing-calculator-heading-visual-parameters-x-values",
                          ),
                      }),
                      jt.createElement(Jb, {
                        ...this.props,
                        vizProp: () => "binAlignment",
                        options: () => [{
                          name: "center",
                          displayName: this.controller.s(
                            "graphing-calculator-button-visual-parameters-center",
                          ),
                        }, {
                          name: "left",
                          displayName: this.controller.s(
                            "graphing-calculator-button-visual-parameters-left",
                          ),
                        }],
                        title: () =>
                          this.controller.s(
                            "graphing-calculator-heading-visual-parameters-bin-alignment",
                          ),
                      }),
                    )),
                histogram: () =>
                  jt.createElement(
                    "div",
                    { class: jt.const("dcg-toggles-container") },
                    jt.createElement(Jb, {
                      ...this.props,
                      vizProp: () => "histogramMode",
                      options: () => [{
                        name: "",
                        displayName: this.controller.s(
                          "graphing-calculator-button-visual-parameters-count",
                        ),
                      }, {
                        name: "relative",
                        displayName: this.controller.s(
                          "graphing-calculator-button-visual-parameters-relative",
                        ),
                      }, {
                        name: "density",
                        displayName: this.controller.s(
                          "graphing-calculator-button-visual-parameters-density",
                        ),
                      }],
                      title: () =>
                        this.controller.s(
                          "graphing-calculator-heading-visual-parameters-bar-heights",
                        ),
                      helpLink: this.const(
                        "https://help.desmos.com/hc/en-us/articles/360022405991",
                      ),
                    }),
                    jt.createElement(Jb, {
                      ...this.props,
                      vizProp: () => "binAlignment",
                      options: () => [{
                        name: "center",
                        displayName: this.controller.s(
                          "graphing-calculator-button-visual-parameters-center",
                        ),
                      }, {
                        name: "left",
                        displayName: this.controller.s(
                          "graphing-calculator-button-visual-parameters-left",
                        ),
                      }],
                      title: () =>
                        this.controller.s(
                          "graphing-calculator-heading-visual-parameters-bin-alignment",
                        ),
                    }),
                  ),
                none: () => jt.createElement("span", null),
              }),
            ),
          );
      }
      makeMQInput(e) {
        return jt.createElement(
          "span",
          null,
          jt.createElement(
            "span",
            { class: jt.const("dcg-parameter-name") },
            e.name,
            jt.const(":"),
          ),
          jt.createElement(lr, {
            latex: () => this.getPropLatex(e),
            ariaLabel: e.name,
            placeholder: () => e.default,
            isFocused: () => this.isInputFocused(e.prop),
            hasError: () => !Gq(this.model, e.prop),
            handleFocusChanged: (t) => this.handleFocusedChanged(e.prop, t),
            handlePressedKey: (t, o) => this.handlePressedKey(t, o, e.prop),
            handleLatexChanged: (t) => this.handleLatexChanged(e.prop, t),
            readonly: () => this.controller.isItemReadonly(this.model.id),
            controller: this.props.controller,
          }),
        );
      }
      handlePressedKey(e, t, o) {
        if (e === "Esc") {
          this.controller.dispatch({
            type: "set-focus-location",
            location: void 0,
          });
          return;
        }
        if (e === "Enter") {
          return this.controller.dispatch({
            type: "on-special-key-pressed",
            key: "Enter",
          });
        }
        let i = Fe.getFocusedMathquill();
        i && (i.keystroke(e, t), this.handleLatexChanged(o, i.latex()));
      }
      isInputFocused(e) {
        let t = this.controller.getFocusLocation();
        return !t || t.type !== "visualization-prop" || t.id !== this.id
          ? false
          : t.location === e;
      }
      handleFocusedChanged(e, t) {
        t
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: {
              type: "visualization-prop",
              id: this.id,
              location: e,
            },
          })
          : this.controller.dispatch({
            type: "blur-focus-location",
            location: {
              type: "visualization-prop",
              id: this.id,
              location: e,
            },
          });
      }
      getPropLatex({ prop: e }) {
        let t = Tp(this.model, e);
        return typeof t == "string" ? t : "";
      }
      handleLatexChanged(e, t) {
        Tp(this.model, e) !== t &&
          this.controller.dispatch({
            type: "set-visualization-prop",
            id: this.id,
            prop: e,
            value: t,
          });
      }
      onToggleOutliers() {
        let e = Tp(this.model, "showBoxplotOutliers");
        this.controller.dispatch({
          type: "set-visualization-prop",
          id: this.id,
          prop: "showBoxplotOutliers",
          value: !e,
        });
      }
      getVisualizationType() {
        return Yw(this.model)
          ? ju(this.model)
            ? "boxplot"
            : kp(this.model)
            ? "dotplot"
            : Pg(this.model)
            ? "histogram"
            : "none"
          : "none";
      }
    };
  var { If: uoe, SwitchUnion: hoe, Each: goe } = no.Components,
    moe = [
      "warning",
      "regression",
      "slider",
      "domain",
      "ttest",
      "stats",
      "action-info",
      "label",
      "distribution",
      "visualization",
      "rename-prompt",
      "extend-to-3d",
      "slider-prompt",
      "evaluation",
      "braille-error",
    ],
    rD = class extends no.Class {
      constructor() {
        super(...arguments),
          this.model = this.props.model(),
          this.controller = this.props.controller();
      }
      id() {
        return this.model.id;
      }
      getFooterComponents() {
        return moe.filter((e) => this.hasFooterComponent(e));
      }
      hasFooterComponent(e) {
        switch (e) {
          case "action-info":
            return this.shouldShowActionInfo();
          case "braille-error":
            return this.shouldShowBrailleError();
          case "distribution":
            return _p(this.model);
          case "domain":
            return !this.model.sliderExists &&
              (Wu(this.model) || Dp(this.model));
          case "evaluation":
            return this.controller.shouldShowEvaluationForItem(
              this.model.id,
            );
          case "extend-to-3d":
            return this.shouldShowExtendTo3D();
          case "label":
            return ub(this.model) && !this.controller.isThreeDMode();
          case "regression":
            return !!this.model.formula.regression;
          case "rename-prompt":
            return this.shouldShowRenamePrompt();
          case "slider":
            return !!this.model.sliderExists;
          case "slider-prompt":
            return this.controller.shouldShowSliderPrompt(this.model);
          case "stats":
            return uT(this.model);
          case "ttest":
            return jw(this.model);
          case "visualization":
            return pT(this.model);
          case "warning":
            return !!this.getFooterWarning();
          default:
            let t = e;
            throw new Error(`Unexpected footer type ${t}`);
        }
      }
      template() {
        return no.createElement(
          uoe,
          { predicate: () => this.getFooterComponents().length > 0 },
          () =>
            no.createElement(
              "div",
              { class: this.getFooterClass() },
              goe(() => this.getFooterComponents(), {
                item: (e) =>
                  hoe(() => e, {
                    regression: () =>
                      no.createElement(Xb, {
                        model: this.props.model,
                        controller: this.props.controller,
                        regression: () => this.props.model().formula.regression,
                      }),
                    label: () =>
                      no.createElement(Hg, {
                        model: this.props.model,
                        controller: this.props.controller,
                      }),
                    slider: () =>
                      no.createElement(fv, {
                        model: this.props.model,
                        controller: this.props.controller,
                      }),
                    "slider-prompt": () =>
                      no.createElement(Ec, {
                        model: this.props.model,
                        controller: this.props.controller,
                      }),
                    "braille-error": () =>
                      no.createElement(
                        "div",
                        {
                          tabIndex: no.const(0),
                          class: no.const("dcg-expression-braille-error"),
                          role: no.const("button"),
                          "aria-roledescription": no.const("error"),
                          "aria-label": () =>
                            this.controller.unpack(this.model.error),
                        },
                        no.createElement("i", {
                          class: no.const("dcg-icon-error"),
                          "aria-hidden": no.const("true"),
                        }),
                        () => this.controller.unpack(this.model.error),
                      ),
                    domain: () =>
                      no.createElement(pv, {
                        model: this.props.model,
                        controller: this.props.controller,
                      }),
                    evaluation: () =>
                      no.createElement(qg, {
                        id: () => this.props.model().id,
                        val: () =>
                          this.controller.getEvaluationValueForItem(
                            this.id(),
                          ),
                        controller: this.props.controller,
                        valueType: () =>
                          this.controller.getEvaluationValueTypeForItem(
                            this.id(),
                          ),
                      }),
                    distribution: () =>
                      no.createElement(dv, {
                        model: this.props.model,
                        controller: this.props.controller,
                      }),
                    visualization: () =>
                      no.createElement(xv, {
                        model: this.props.model,
                        controller: this.props.controller,
                      }),
                    "rename-prompt": () =>
                      no.createElement(hv, {
                        controller: this.props.controller,
                        id: this.bindFn(this.id),
                      }),
                    ttest: () =>
                      no.createElement(yv, {
                        model: this.props.model,
                        controller: this.props.controller,
                      }),
                    stats: () =>
                      no.createElement(bv, {
                        model: this.props.model,
                        controller: this.props.controller,
                      }),
                    "action-info": () =>
                      no.createElement(zg, {
                        model: this.props.model,
                        controller: this.props.controller,
                      }),
                    "extend-to-3d": () =>
                      no.createElement(
                        "div",
                        { handleEvent: no.const("true") },
                        no.createElement(mt, {
                          onChange: (t) => {
                            this.controller.dispatch({
                              type: "set-item-extend-to-3D",
                              id: this.model.id,
                              extendTo3D: t,
                            });
                          },
                          checked: () => this.model.extendTo3D,
                          class: this.const("dcg-extend-to-3d-checkbox"),
                        }, () =>
                          this.controller.s(
                            "graphing-calculator-label-extend-to-3d",
                          )),
                      ),
                    warning: () =>
                      no.createElement(uv, {
                        controller: this.props.controller,
                        warning: () => this.getFooterWarning(),
                      }),
                  }),
              }),
            ),
        );
      }
      getFooterClass() {
        let e = !this.props.isFirstRender() &&
          !this.model.expressionTooComplex;
        return this.const({
          "dcg-expression-bottom": true,
          "dcg-indent-in-folder": true,
          "dcg-fadein-bottom": e,
        });
      }
      shouldShowRenamePrompt() {
        let e = this.controller.getSuggestedIdentifierRenameInfo(
          this.model.id,
        );
        return !!(e && e.countOfChanges);
      }
      shouldShowActionInfo() {
        return !!(this.controller.areActionsEnabled() &&
          this.model.clickableInfo && this.model.clickableInfo.enabled &&
          this.model.clickableInfo.latex);
      }
      shouldShowBrailleError() {
        return this.controller.getBrailleMode() !== "none" &&
          this.hasError();
      }
      hasError() {
        return !!this.model.error && !Vl(this.model);
      }
      shouldShowExtendTo3D() {
        return this.controller.isThreeDMode()
          ? cT(this.model) && !this.model.expressionTooComplex &&
            this.model.shouldGraph
          : false;
      }
      getFooterWarning() {
        let e = this.model.formula;
        if (e.warning !== void 0) {
          return {
            type: "evaluation",
            message: this.controller.unpack(e.warning),
          };
        }
        if (
          !this.controller.getIncludeFunctionParametersInRandomSeed() &&
          e.depends_on_random_seed && e.function_definition
        ) return { type: "legacy-random-seed-behavior" };
        if (this.model.expressionTooComplex) {
          return { type: "expressionTooComplex" };
        }
        if (this.model.unresolved) return { type: "unresolved" };
        if (Iq(this.model)) return { type: "tone-out-of-range" };
        if (
          this.model.nanBlame ===
            __dcg_shared_module_exports__["Zd"].ComplexCoercion
        ) return { type: "nan-blame-complex-coercion" };
        if (this.model.recursiveDepthPlottingError) {
          return { type: "recursive-depth-plotting-error" };
        }
      }
    };
  Ss();
  var ji = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Vp = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Di = class extends Vp.Class {
    template() {
      return Vp.createElement(
        Le,
        {
          tooltip: this.props.error,
          sticky: this.const(true),
          gravity: this.props.gravity,
          additionalClass: this.const("dcg-tooltipped-error-container"),
        },
        Vp.createElement(
          "div",
          {
            class: () => {
              var e, t, o, i;
              return {
                "dcg-tooltipped-error": true,
                "dcg-small":
                  ((t = (e = this.props).size) == null ? void 0 : t.call(e)) ===
                    "small",
                "dcg-white": this.props.isWhite && this.props.isWhite(),
                "dcg-tooltipped-error__instant":
                  (i = (o = this.props).instant) == null ? void 0 : i.call(o),
              };
            },
          },
          Vp.createElement("i", {
            class: Vp.const("dcg-icon-error"),
            "aria-hidden": Vp.const("true"),
          }),
        ),
      );
    }
  };
  var Gd = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Ln = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Go = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    oD = class extends Go.Class {
      template() {
        return Go.createElement(
          "div",
          { class: Go.const("dcg-slow-plotting-icon") },
          Go.createElement("div", {
            class: Go.const("dcg-slow-plotting-icon__dot"),
          }),
          Go.createElement("div", {
            class: Go.const("dcg-slow-plotting-icon__dot"),
          }),
          Go.createElement("div", {
            class: Go.const("dcg-slow-plotting-icon__dot"),
          }),
          Go.createElement("div", {
            class: Go.const("dcg-slow-plotting-icon__dot"),
          }),
          Go.createElement("div", {
            class: Go.const("dcg-slow-plotting-icon__dot"),
          }),
          Go.createElement("div", {
            class: Go.const("dcg-slow-plotting-icon__dot"),
          }),
          Go.createElement("div", {
            class: Go.const("dcg-slow-plotting-icon__dot"),
          }),
          Go.createElement("div", {
            class: Go.const("dcg-slow-plotting-icon__dot"),
          }),
          Go.createElement("div", {
            class: Go.const("dcg-slow-plotting-icon__dot"),
          }),
          Go.createElement("div", {
            class: Go.const("dcg-slow-plotting-icon__dot"),
          }),
          Go.createElement("div", {
            class: Go.const("dcg-slow-plotting-icon__dot"),
          }),
        );
      }
    };
  var { If: wv } = Ln.Components,
    $o = class extends Ln.Class {
      template() {
        return Ln.createElement(
          "span",
          {
            class: () => ({
              "dcg-do-not-blur": true,
              "dcg-forced-color-none": true,
              "dcg-circular-icon": true,
              "dcg-thick-outline": this.isThickOutline(),
              "dcg-white-icon": !!this.props.whiteIcon &&
                this.props.whiteIcon(),
              "dcg-hidden": this.isHidden(),
              "dcg-semi-transparent": this.props.semiTransparent &&
                this.props.semiTransparent(),
              "dcg-colored-icon": this.isColoredIcon(),
              "dcg-has-background-image": this.hasBackgroundImage(),
              [this.iconModifier()]: this.iconModifier().length > 0,
            }),
            style: this.bindFn(this.getIconStyle),
          },
          Ln.createElement(wv, {
            predicate: this.bindFn(this.hasBackgroundImage),
          }, () =>
            Ln.createElement("span", {
              class: Ln.const("dcg-background-image"),
              style: () => ({
                "background-image": this.props.backgroundImage &&
                  this.props.backgroundImage(),
                opacity: this.props.backgroundOpacity &&
                  this.props.backgroundOpacity().toString(),
              }),
            })),
          Ln.createElement(wv, {
            predicate: () => !!this.backgroundIcon(),
          }, () =>
            Ln.createElement("i", {
              class: () => ({
                [this.backgroundIcon()]: true,
                "dcg-layered-icon": true,
              }),
              style: () => ({
                opacity: this.backgroundOpacity().toString(),
              }),
            })),
          Ln.createElement(
            wv,
            { predicate: () => !!this.primaryIcon() },
            () =>
              Ln.createElement("i", {
                class: () => ({
                  [this.primaryIcon()]: true,
                  "dcg-layered-icon": true,
                }),
                style: () => ({
                  color: this.props.foregroundColor &&
                    this.props.foregroundColor(),
                }),
              }),
          ),
          Ln.createElement(
            wv,
            { predicate: () => this.props.iconType() === "loading" },
            () =>
              Ln.createElement("span", {
                class: Ln.const("dcg-spinner"),
              }),
          ),
          Ln.createElement(wv, {
            predicate: () => this.props.iconType() === "slow-plotting",
          }, () => Ln.createElement(oD, null)),
        );
      }
      isColoredIcon() {
        return !this.isThickOutline() && !this.isHidden() &&
          !this.hasBackgroundImage() &&
          this.props.iconType() !== "loading";
      }
      iconModifier() {
        if (!this.props.iconModifier) return "";
        switch (this.props.iconModifier()) {
          case "medium":
            return "dcg-modifier-size-medium";
          case "large":
            return "dcg-modifier-size-large";
          case "small":
            return "dcg-modifier-size-small";
          case "rotated":
            return "dcg-modifier-rotated";
          case "fade-in":
            return "dcg-modifier-fade-in";
          case "none":
            return "";
        }
      }
      getIconStyle() {
        let e = !this.isHidden() && this.props.backgroundColor
          ? Hf(this.props.backgroundColor())
          : void 0;
        return e ? { background: e } : {};
      }
      isHidden() {
        return this.props.iconType() === "hidden";
      }
      isThickOutline() {
        let e = this.props.iconType();
        return e === "folder" || e === "pause" || e === "play" ||
          e === "fraction" || e === "action" || e === "metronome" ||
          e === "sound";
      }
      hasBackgroundImage() {
        return !!this.props.backgroundImage && !this.isHidden() &&
          !!this.props.backgroundImage();
      }
      primaryIcon() {
        let e = this.props.iconType();
        switch (e) {
          case "sound":
            return "dcg-icon-sound-wave";
          case "folder":
            return "dcg-icon-folder";
          case "pause":
            return "dcg-icon-pause";
          case "play":
            return "dcg-icon-play";
          case "polygon-dashed":
          case "polygon-dashed-filled":
            return "dcg-icon-polygon-dashed";
          case "polygon-dotted":
          case "polygon-dotted-filled":
            return "dcg-icon-polygon-dotted";
          case "polygon-default":
          case "polygon-default-filled":
            return "dcg-icon-polygon-solid";
          case "graph-dashed":
          case "parametric-dashed-filled":
            return "dcg-icon-parametric-dashed";
          case "graph-dotted":
          case "parametric-dotted-filled":
            return "dcg-icon-parametric-dotted";
          case "graph-default":
          case "parametric-default-filled":
            return "dcg-icon-parametric-solid";
          case "movable-vertical":
            return "dcg-icon-move-vertical";
          case "movable-both":
            return "dcg-icon-move";
          case "movable-horizontal":
            return "dcg-icon-move-horizontal";
          case "point-open":
            return "dcg-icon-open";
          case "point-cross":
            return "dcg-icon-cross";
          case "point-default":
            return "dcg-icon-point";
          case "table-points":
          case "table-points-and-lines":
            return "dcg-icon-points";
          case "table-lines":
            return "dcg-icon-lines-solid";
          case "shaded-inequality":
          case "inequality":
            return "dcg-icon-shaded-inequality-dash";
          case "check":
            return "dcg-icon-check";
          case "none":
          case "background":
          case "hidden":
          case "polygon-none-filled":
          case "parametric-none-filled":
          case "loading":
          case "slow-plotting":
            return "";
          case "fraction":
            return "dcg-icon-fraction";
          case "boxplot":
            return "dcg-icon-boxplot";
          case "dotplot-cross":
            return "dcg-icon-dotplot-cross";
          case "dotplot-default":
            return "dcg-icon-dotplot-default";
          case "dotplot-open":
            return "dcg-icon-dotplot-open";
          case "histogram":
            return "dcg-icon-histogram";
          case "unfilled-distribution":
          case "filled-distribution":
            return "dcg-icon-distribution";
          case "action":
            return "dcg-icon-chevron-right";
          case "metronome":
            return "dcg-icon-metronome-2";
          case "arrow-right":
            return "dcg-icon-arrow-right";
          default:
            return e;
        }
      }
      backgroundOpacity() {
        let e = this.backgroundIcon();
        return e === "dcg-icon-polygon-filled" ||
            e === "dcg-icon-parametric-filled" ||
            e === "dcg-icon-shaded-inequality-shade2" ||
            e === "dcg-icon-distribution-fill" ||
            e === "dcg-icon-histogram-fill"
          ? .5
          : 1;
      }
      backgroundIcon() {
        let e = this.props.iconType();
        return e === "filled-distribution"
          ? "dcg-icon-distribution-fill"
          : e === "histogram"
          ? "dcg-icon-histogram-fill"
          : e === "polygon-dashed-filled" ||
              e === "polygon-dotted-filled" ||
              e === "polygon-default-filled" ||
              e === "polygon-none-filled"
          ? "dcg-icon-polygon-filled"
          : e === "parametric-dashed-filled" ||
              e === "parametric-dotted-filled" ||
              e === "parametric-default-filled" ||
              e === "parametric-none-filled"
          ? "dcg-icon-parametric-filled"
          : e === "table-points-and-lines"
          ? "dcg-icon-lines-solid"
          : e === "shaded-inequality"
          ? "dcg-icon-shaded-inequality-shade2"
          : e === "action"
          ? "dcg-icon-minus"
          : "";
      }
    };
  var iD = class extends Gd.Class {
    constructor() {
      super(...arguments), this.isAnimating = false;
    }
    init() {
      this.controller = this.props.controller(),
        this.model = this.props.model();
    }
    template() {
      return Gd.createElement(
        "div",
        {
          class: () => ({
            "dcg-action-icon-view": true,
            "dcg-action-icon-view-animating": this.isAnimating,
          }),
        },
        Gd.createElement(
          "div",
          {
            class: Gd.const("dcg-circular-icon-container"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-narration-run-action-icon",
              ),
            role: Gd.const("button"),
            tabIndex: Gd.const("0"),
            onTap: (e) => {
              e.wasHandled("dragdrop") || this.runActionOnce();
            },
            manageFocus: this.const(
              rt({
                controller: this.props.controller(),
                location: { type: "action-icon", id: this.model.id },
              }),
            ),
          },
          Gd.createElement($o, {
            iconType: this.const("action"),
            whiteIcon: () =>
              !this.controller.isInEditListMode() &&
                this.controller.isItemSelected(this.model.id) ||
              this.controller.isItemBeingDragged(this.model.id),
          }),
        ),
      );
    }
    runActionOnce() {
      this.isAnimating = true,
        this.controller.dispatch({
          type: "action-single-step",
          id: this.model.id,
        }),
        setTimeout(
          this.bindIfMounted(() => {
            this.isAnimating = false, this.update();
          }),
          150,
        );
    }
  };
  var Jn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var nD = class extends Jn.Class {
    init() {
      this.controller = this.props.controller(),
        this.model = this.props.model();
    }
    template() {
      return Jn.createElement(
        "div",
        { class: Jn.const("dcg-play-pause-icon-view") },
        Jn.createElement(
          Le,
          {
            gravity: this.const("s"),
            tooltip: () =>
              this.controller.s(
                "graphing-calculator-label-slider-disabled-while-ticker-playing",
              ),
            disabled: () => !this.controller.getTickerPlaying(),
            sticky: this.const(true),
          },
          Jn.createElement(
            "div",
            {
              class: () => ({
                "dcg-circular-icon-container": true,
                "dcg-disabled": this.controller.getTickerPlaying(),
              }),
              "aria-label": this.bindFn(this.getAriaLabel),
              "aria-disabled": () => this.controller.getTickerPlaying(),
              role: Jn.const("button"),
              tabIndex: () => this.controller.getTickerPlaying() ? "-1" : "0",
              onTap: (e) => {
                this.controller.getTickerPlaying() ||
                  e.wasHandled("dragdrop") ||
                  this.toggleSliderIsPlaying();
              },
              "dcg-open-menu-guid": () => this.model.guid,
              manageFocus: this.const(
                rt({
                  controller: this.controller,
                  location: { type: "slider-icon", id: this.model.id },
                }),
              ),
            },
            Jn.createElement($o, {
              iconType: () => this.getIconType(),
              whiteIcon: () =>
                !this.controller.isInEditListMode() &&
                  this.controller.isItemSelected(this.model.id) ||
                this.controller.isItemBeingDragged(this.model.id),
            }),
          ),
        ),
        Jn.createElement(
          "div",
          { class: Jn.const("dcg-slider-menu-container") },
          Jn.createElement(
            Le,
            {
              tooltip: () =>
                this.controller.s(
                  "graphing-calculator-label-animation-properties-tooltip",
                ),
              gravity: this.const("e"),
            },
            Jn.createElement(
              "div",
              {
                class: () => ({
                  "dcg-slider-menu-opener": true,
                  "dcg-menu-open": this.myOptionsOpen(),
                }),
                tabIndex: Jn.const(0),
                "dcg-open-menu-guid": () => this.getMenuGUID(),
                role: Jn.const("button"),
                "aria-label": () =>
                  this.myOptionsOpen()
                    ? this.controller.s(
                      "graphing-calculator-narration-hide-animation-properties",
                    )
                    : this.controller.s(
                      "graphing-calculator-narration-show-animation-properties",
                    ),
                onTap: (e) => {
                  e.wasHandled("dragdrop") || e.wasLongheld() ||
                    this.toggleOptions(e);
                },
                manageFocus: this.const(
                  rt({
                    controller: this.controller,
                    location: {
                      type: "slider-animation-properties-icon",
                      id: this.model.id,
                    },
                  }),
                ),
              },
              Jn.createElement("i", {
                class: this.bindFn(this.getIcon),
                "aria-hidden": Jn.const("true"),
              }),
            ),
          ),
        ),
      );
    }
    getIcon() {
      return __dcg_shared_module_exports__["qd"](
        this.model.slider.loopMode,
      );
    }
    getIconType() {
      return !this.model.slider.isPlaying || hL(this.model) ? "play" : "pause";
    }
    getMenuGUID() {
      return "slider-" + this.model.guid;
    }
    myOptionsOpen() {
      return this.controller.isItemSettingsMenuOpen(this.getMenuGUID());
    }
    toggleOptions(e) {
      this.controller.dispatch({
        type: "toggle-item-settings-menu",
        menu: {
          type: "slider",
          model: this.model,
          guid: this.getMenuGUID(),
          focusFirstOption: e.device === "keyboard",
        },
      });
    }
    getAriaLabel() {
      if (!this.model.sliderExists) return "";
      let e = Ya(this.model);
      return e
        ? this.model.slider.isPlaying
          ? this.controller.s(
            "graphing-calculator-narration-pause-variable-animation",
            { variable: e },
          )
          : this.controller.s(
            "graphing-calculator-narration-play-variable-animation",
            { variable: e },
          )
        : "";
    }
    toggleSliderIsPlaying() {
      if (this.model.sliderExists) {
        let e = "", t = Ya(this.model);
        hL(this.model)
          ? (typeof t == "string" &&
            (e = this.controller.s(
              "graphing-calculator-narration-slider-variable-restarted",
              { variable: t },
            )),
            this.controller.dispatch({
              type: "play-slider-from-min",
              id: this.model.id,
            }))
          : this.model.slider.isPlaying
          ? (typeof t == "string" &&
            (e = this.controller.s(
              "graphing-calculator-narration-slider-variable-paused",
              { variable: t },
            )),
            this.controller.dispatch({
              type: "set-slider-isplaying",
              id: this.model.id,
              isPlaying: false,
            }))
          : (typeof t == "string" &&
            (e = this.controller.s(
              "graphing-calculator-narration-slider-variable-playing",
              { variable: t },
            )),
            this.controller.dispatch({
              type: "set-slider-isplaying",
              id: this.model.id,
              isPlaying: true,
            })), e !== "" && xe(e);
      }
    }
  };
  var vv = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var aD = class extends vv.Class {
    init() {
      this.model = this.props.model(),
        this.controller = this.props.controller();
    }
    toggleMuted() {
      this.controller.dispatch({
        type: "toggle-item-hidden",
        id: this.model.id,
      });
    }
    showAsTurnedOff() {
      return Bw(this.model);
    }
    template() {
      return vv.createElement(
        "button",
        {
          class: () => {
            var e;
            return {
              "dcg-unstyled-button": true,
              "dcg-circular-icon-container": true,
              "dcg-show-globally-muted":
                ((e = this.controller.toneController) == null
                  ? void 0
                  : e.isGlobalMuted()) && !this.showAsTurnedOff(),
            };
          },
          onTap: (e) => {
            e.wasHandled("dragdrop") || this.toggleMuted();
          },
          "aria-label": this.props.ariaLabel,
        },
        vv.createElement($o, {
          iconType: () => this.showAsTurnedOff() ? "hidden" : "sound",
          whiteIcon: () =>
            !this.controller.isInEditListMode() &&
              this.controller.isItemSelected(this.model.id) ||
            this.controller.isItemBeingDragged(this.model.id),
        }),
      );
    }
  };
  var { SwitchUnion: foe, If: boe } = ji.Components,
    yoe = "#6A93D2",
    J8 = "#000",
    Q8 = "#fff",
    Cv = class extends ji.Class {
      init() {
        this.model = this.props.model(),
          this.controller = this.props.controller();
      }
      template() {
        return ji.createElement(
          "div",
          { class: ji.const("dcg-expression-icon-container") },
          foe(this.bindFn(this.getIconMode), {
            error: () =>
              ji.createElement(Di, {
                error: this.bindFn(this.getErrorMsg),
                isWhite: this.bindFn(this.renderAsSelected),
              }),
            none: () => ji.createElement("span", null),
            slider: () =>
              ji.createElement(nD, {
                controller: this.props.controller,
                model: this.props.model,
              }),
            action: () =>
              ji.createElement(iD, {
                controller: this.props.controller,
                model: this.props.model,
              }),
            icon: () =>
              ji.createElement(
                "div",
                {
                  class: ji.const("dcg-circular-icon-container"),
                  role: ji.const("button"),
                  tabIndex: ji.const("0"),
                  "dcg-open-menu-guid": () => this.getMenuGUID(),
                  "aria-label": this.bindFn(this.getIconAriaLabel),
                  onTap: (e) => {
                    if (!e.wasHandled("dragdrop") && !e.wasLongheld()) {
                      if (this.myOptionsOpen()) {
                        return this.toggleOptions(e);
                      }
                      if (
                        (this.controller.isInEditListMode() ||
                          e.shiftKey) && !this.isFraction()
                      ) return this.toggleOptions(e);
                      if (this.isFraction()) {
                        return this
                          .onToggleFractionDisplay();
                      }
                      this.toggleGraphShown();
                    }
                  },
                  onLongHold: (e) => {
                    e.handle("dcg-longhold"),
                      e.handle("dcg-tap"),
                      !(this.isFraction() ||
                        this.displaySlowPlotting() && !qw(this.model)) &&
                      this.toggleOptions(e);
                  },
                  manageFocus: this.const(
                    rt({
                      controller: this.controller,
                      location: {
                        type: "expression-icon",
                        id: this.model.id,
                      },
                    }),
                  ),
                },
                ji.createElement($o, {
                  iconType: this.bindFn(this.getIconType),
                  backgroundColor: this.bindFn(this.getBackgroundColor),
                  whiteIcon: this.bindFn(this.renderAsSelected),
                  foregroundColor: this.bindFn(this.getForegroundColor),
                  iconModifier: this.bindFn(this.getIconModifier),
                  backgroundImage: this.bindFn(this.backgroundImage),
                  backgroundOpacity: this.const(1),
                }),
                ji.createElement(boe, {
                  predicate: () => this.model.disableGraphInteractions,
                }, () =>
                  ji.createElement("i", {
                    class: ji.const(
                      "dcg-graph-interaction-disabled dcg-icon-lock",
                    ),
                  })),
              ),
            tone: () =>
              ji.createElement(aD, {
                controller: this.props.controller,
                model: this.props.model,
                ariaLabel: this.bindFn(this.getIconAriaLabel),
              }),
          }),
        );
      }
      backgroundImage() {
        let e = this.getBackgroundColor();
        return e.type === "image" ? `url("${e.value}")` : "";
      }
      getErrorMsg() {
        return this.colorError()
          ? this.controller.s(
            "shared-calculator-error-color-not-assigned",
          )
          : this.controller.unpack(this.model.error);
      }
      getMenuGUID() {
        return this.model.guid;
      }
      myOptionsOpen() {
        return this.controller.isItemSettingsMenuOpen(this.getMenuGUID());
      }
      toggleOptions(e) {
        this.controller.dispatch({
          type: "toggle-item-settings-menu",
          menu: {
            type: "expression",
            model: this.model,
            guid: this.getMenuGUID(),
            focusFirstOption: e.device === "keyboard",
          },
        });
      }
      renderAsSelected() {
        return this.controller.isItemBeingDragged(this.model.id)
          ? true
          : this.controller.isItemSelected(this.model.id) &&
            !this.controller.isInEditListMode();
      }
      displaySlowPlotting() {
        return this.controller.shouldShowProgressUpdateIcons() &&
          this.controller.isItemGraphing(this.model.id) &&
          this.controller.isItemSlowInEvaluator(this.model.id) &&
          !Hi(this.model);
      }
      isFraction() {
        return this.controller.canDisplayEvaluationForItemAsFraction(
          this.model.id,
        );
      }
      getIconMode() {
        return this.displaySlowPlotting()
          ? "icon"
          : this.hasError()
          ? "error"
          : this.controller.getGraphSettings().config.graphpaper
          ? qw(this.model)
            ? "icon"
            : this.hasSlider()
            ? "slider"
            : this.isFraction()
            ? "icon"
            : this.isNonemptyAction()
            ? "action"
            : this.isToneExpression() && this.controller.toneEnabled()
            ? "tone"
            : "none"
          : "none";
      }
      isToneExpression() {
        return Is(this.model);
      }
      toggleGraphShown() {
        this.controller.dispatch({
          type: "toggle-item-hidden",
          id: this.model.id,
        });
      }
      colorError() {
        return !!this.model.formula.rgb_value &&
          !this.model.formula.assignment;
      }
      hasError() {
        return this.colorError()
          ? true
          : !!this.model.error && !Vl(this.model) &&
            this.controller.getBrailleMode() === "none";
      }
      hasSlider() {
        return !!this.model.sliderExists;
      }
      isNonemptyAction() {
        return vb(this.model);
      }
      getDisplayProps() {
        let { points: e, lines: t, fill: o } = this.model;
        return __dcg_shared_module_exports__["Zc"](
          this.model.formula.expression_type,
          { points: e, lines: t, fill: o },
          (i) => {
            So("getReconciledExpressionProps [Chrome Switch Bug]", {
              metaData: { method: "getDisplayProps", type: i },
            });
          },
        );
      }
      getBackgroundColor() {
        if (!this.isFraction()) return xw(this.model);
        let e = this.renderAsSelected();
        return this.controller.shouldEvaluationForItemDisplayAsFraction(
            this.model.id,
          )
          ? { type: "single-color", value: e ? Q8 : J8 }
          : { type: "single-color", value: "" };
      }
      getForegroundColor() {
        if (!this.isFraction()) return "";
        let e = this.renderAsSelected(),
          t = this.controller.shouldEvaluationForItemDisplayAsFraction(
            this.model.id,
          );
        return e !== t ? Q8 : e ? yoe : J8;
      }
      onToggleFractionDisplay() {
        this.controller.dispatch({
          type: "toggle-fraction-evaluation",
          id: this.model.id,
        });
      }
      getIconModifier() {
        return ju(this.model) && Tp(this.model, "alignedAxis") === "y"
          ? "rotated"
          : this.displaySlowPlotting() &&
              this.model.formula.is_graphable === void 0
          ? "fade-in"
          : "none";
      }
      getIconType() {
        if (this.isFraction()) return "fraction";
        if (this.displaySlowPlotting()) return "slow-plotting";
        if (!this.model.shouldGraph) return "hidden";
        if (this.controller.isInEditListMode()) return "none";
        let e = this.model.pointStyle,
          t = this.model.lineStyle,
          o = this.getDisplayProps(),
          i = this.model.formula;
        if (ju(this.model)) return "boxplot";
        if (kp(this.model)) {
          if (this.model.pointStyle === "POINT") return "dotplot-default";
          if (this.model.pointStyle === "CROSS") return "dotplot-cross";
          if (this.model.pointStyle === "OPEN") return "dotplot-open";
        }
        if (Pg(this.model)) return "histogram";
        if (_p(this.model)) {
          return vd(this.model)
            ? "filled-distribution"
            : "unfilled-distribution";
        }
        if (Ro(this.model) === "X") return "movable-horizontal";
        if (Ro(this.model) === "Y") return "movable-vertical";
        if (Ro(this.model) === "XY") return "movable-both";
        if (Ea(this.model)) {
          return e === "OPEN"
            ? "point-open"
            : e === "CROSS"
            ? "point-cross"
            : "point-default";
        }
        if (Cb(this.model)) return "point-default";
        if (Lg(this.model) || $u(this.model)) {
          return o.lines && o.points
            ? "table-points-and-lines"
            : o.lines
            ? "table-lines"
            : "table-points";
        }
        if (lT(this.model)) return "polygon-default-filled";
        let n = this.getDisplayProps().fill;
        if (pb(this.model)) {
          return n
            ? o.lines
              ? t === "DASHED"
                ? "polygon-dashed-filled"
                : t === "DOTTED"
                ? "polygon-dotted-filled"
                : "polygon-default-filled"
              : "polygon-none-filled"
            : o.lines
            ? t === "DASHED"
              ? "polygon-dashed"
              : t === "DOTTED"
              ? "polygon-dotted"
              : "polygon-default"
            : "none";
        }
        if (Gg(this.model)) {
          return n
            ? o.lines
              ? t === "DASHED"
                ? "parametric-dashed-filled"
                : t === "DOTTED"
                ? "parametric-dotted-filled"
                : "parametric-default-filled"
              : "parametric-none-filled"
            : o.lines
            ? t === "DASHED"
              ? "graph-dashed"
              : t === "DOTTED"
              ? "graph-dotted"
              : "graph-default"
            : "none";
        }
        let a = i.operator,
          s = __dcg_shared_module_exports__["rc"][a].direction !== 0,
          l = __dcg_shared_module_exports__["rc"][a].inclusive === false;
        return i.is_shade_between || !l && s
          ? "shaded-inequality"
          : l && !s
          ? "inequality"
          : l && s
          ? "shaded-inequality"
          : t === "DASHED"
          ? "graph-dashed"
          : t === "DOTTED"
          ? "graph-dotted"
          : "graph-default";
      }
      getIconAriaLabel() {
        return this.displaySlowPlotting()
          ? this.controller.s("shared-calculator-label-slow-plotting")
          : this.isFraction()
          ? Hu(this.model)
            ? this.controller.s(
              "shared-calculator-narration-display-as-decimal",
            )
            : this.controller.s(
              "shared-calculator-narration-display-as-fraction",
            )
          : this.myOptionsOpen()
          ? Xr(this.model, "hide-options")
          : this.controller.isInEditListMode()
          ? Xr(this.model, "show-options")
          : Is(this.model)
          ? this.model.hidden
            ? Xr(this.model, "unmute")
            : Xr(this.model, "mute")
          : this.model.hidden
          ? Xr(this.model, "show")
          : Xr(this.model, "hide");
      }
    };
  var as = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: xoe } = as.Components,
    sD = class extends as.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return as.createElement(
          xoe,
          { predicate: this.bindFn(this.shouldShow) },
          () =>
            as.createElement(
              "div",
              {
                class: as.const("dcg-generate-table-view dcg-do-blur"),
                handleEvent: as.const(true),
              },
              as.createElement(
                Le,
                {
                  tooltip: this.bindFn(this.getTooltip),
                  gravity: () => "s",
                },
                as.createElement("i", {
                  onTap: () =>
                    this.controller.dispatch({
                      type: "convert-or-create-table",
                      index: this.model.index,
                    }),
                  role: as.const("button"),
                  tabIndex: as.const("0"),
                  "aria-label": () => Xr(this.model, "create_table"),
                  class: as.const("dcg-icon-create-table"),
                }),
              ),
            ),
        );
      }
      shouldShow() {
        return Sg(this.model) !== "recursive-function" || !this.model ||
            this.model.type !== "expression"
          ? false
          : !this.controller.hasTableHeaderWithIdentifier(
            this.model.formula.function_definition,
          );
      }
      getTooltip() {
        return this.controller.s(
          "graphing-calculator-label-create-table",
        );
      }
    };
  var ss = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: woe } = ss.Components,
    Qb = class extends ss.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return ss.createElement(
          woe,
          {
            predicate: () =>
              this.controller.showExpressionZoomFitButton(this.model),
          },
          () =>
            ss.createElement(
              "div",
              {
                class: ss.const("dcg-suggested-zoom-view dcg-do-blur"),
                handleEvent: ss.const(true),
              },
              ss.createElement(
                Le,
                {
                  tooltip: this.bindFn(this.getZoomText),
                  gravity: () => "e",
                },
                ss.createElement("i", {
                  onTap: this.bindFn(this.onZoom),
                  role: ss.const("button"),
                  tabIndex: ss.const("0"),
                  "aria-label": this.bindFn(this.getZoomText),
                  class: ss.const("dcg-icon-zoom-fit"),
                }),
              ),
            ),
        );
      }
      getZoomText() {
        return this.controller.s("graphing-calculator-text-zoom-fit");
      }
      onZoom(e) {
        this.controller.dispatch({
          type: "expression-zoom-fit",
          id: this.model.id,
          focusAfterTap: e.device === "keyboard",
        });
      }
    };
  var cn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: voe, Switch: Coe } = cn.Components,
    Wl = class extends cn.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      iconType() {
        return this.controller.shouldShowReplaceIcon()
          ? "rename"
          : this.controller.isItemMarkedReadonly(this.model.id)
          ? "lock"
          : "delete";
      }
      getAriaLabel() {
        switch (this.iconType()) {
          case "none":
          case "lock":
            return;
          case "rename":
            return Xr(this.model, "rename");
          case "delete":
            return Xr(this.model, "delete");
        }
      }
      onIconTap() {
        this.iconType() === "delete"
          ? this.controller.dispatch({
            type: "delete-item-and-animate-out",
            id: this.model.id,
            setFocusAfterDelete: !this.controller.isInEditListMode(),
          })
          : this.iconType() === "rename" &&
            this.controller.dispatch({
              type: "rename-identifier-in-item",
              search: this.controller.getExpressionSearchStr(),
              replace: this.controller.getExpressionReplaceStr(),
              id: this.model.id,
            });
      }
      isIconTappable() {
        let e = this.iconType();
        return e !== "none" && e !== "lock";
      }
      template() {
        return cn.createElement(voe, {
          predicate: () => !this.controller.isInEditListMode(),
        }, () =>
          cn.createElement(
            "div",
            {
              class: () => ({
                "dcg-top-level-icon": true,
                "dcg-tappable": this.isIconTappable(),
              }),
              tabIndex: () => this.isIconTappable() ? 0 : -1,
              "aria-label": this.bindFn(this.getAriaLabel),
              handleEvent: this.bindFn(this.isIconTappable),
              onTap: this.bindFn(this.onIconTap),
              role: cn.const("button"),
              manageFocus: this.const({
                shouldBeFocused: () =>
                  Bg({
                    controller: this.controller,
                    location: {
                      type: "top-level-icon",
                      id: this.model.id,
                    },
                  }),
                onFocusedChanged: (e, t) => {
                  var o;
                  e
                    ? this.controller.dispatch({
                      type: "set-focus-location",
                      location: {
                        type: "top-level-icon",
                        id: this.model.id,
                      },
                    })
                    : t.relatedTarget &&
                      !((o = t.relatedTarget) != null &&
                        o.closest("[data-dcg-label]")) &&
                      this.controller.dispatch({
                        type: "blur-focus-location",
                        location: {
                          type: "top-level-icon",
                          id: this.model.id,
                        },
                      });
                },
              }),
            },
            cn.createElement(Coe, { key: () => this.iconType() }, (e) => {
              switch (e) {
                case "delete":
                  return cn.createElement("i", {
                    class: cn.const(
                      "dcg-icon-remove dcg-top-level-delete",
                    ),
                    "aria-hidden": cn.const("true"),
                  });
                case "lock":
                  return cn.createElement("i", {
                    class: cn.const("dcg-icon-lock dcg-lock-indicator"),
                    "aria-hidden": cn.const("true"),
                  });
                case "rename":
                  return cn.createElement("i", {
                    class: cn.const("dcg-icon-replace"),
                    "aria-hidden": cn.const("true"),
                  });
                case "none":
                  return cn.createElement("span", null);
              }
            }),
          ));
      }
    };
  var { If: Z8 } = Ur.Components,
    Wg = class extends is {
      didMountRootNode(e) {
        this.rootNode = e,
          this.onItemViewMounted(e),
          this.lastBrailleMode = this.controller.getBrailleMode();
      }
      willUnmount() {
        this.onItemViewUnmounted();
      }
      template() {
        return Ur.createElement(
          "div",
          {
            class: () => ({
              "dcg-do-not-blur": true,
              "dcg-expressionitem": true,
              "dcg-mathitem": true,
              "dcg-inFolder": !!this.model.folderId,
              "dcg-readonly": this.controller.isItemReadonly(this.id),
              "dcg-selected": this.controller.isItemSelected(this.id) &&
                !this.controller.isInEditListMode(),
              "dcg-dragging": this.controller.isItemBeingDragged(this.id),
              "dcg-hasSlider": this.hasSlider(),
              "dcg-hasEvaluation": !!this.controller
                .shouldShowEvaluationForItem(this.id),
              "dcg-hasRegression": this.hasRegression(),
              "dcg-hasDomain": this.hasDomain() || this.hasDomain3d(),
            }),
            "expr-id": () => this.model.id,
            didMount: this.bindFn(this.didMountRootNode),
          },
          Ur.createElement(
            "div",
            {
              class: Ur.const("dcg-fade-container"),
              onTapStart: this.bindFn(this.onMouseSelect),
              onTap: this.bindFn(this.onMouseSelect),
            },
            Ur.createElement(
              "div",
              { class: Ur.const("dcg-main") },
              Ur.createElement(Z8, {
                predicate: () =>
                  !this.controller.isInEditListMode() &&
                  !this.isReadonly(),
              }, () =>
                Ur.createElement(
                  Mo,
                  {
                    latex: () => Kw(this.model),
                    operatorNames: () => this.getMQConfig().autoOperatorNames,
                    ariaLabel: () => this.getAriaLabel("braille"),
                    brailleShouldFocus: () => this.isFocused(),
                    onBrailleInput: (e) => this.handleLatexChanged(e),
                    onBrailleFocusedChanged: (e, t) =>
                      this.handleMQFocusedChanged(e, t),
                    onBrailleKeydown: this.bindFn(
                      this.handleBraillePressedKey,
                    ),
                    ...ui(this.controller),
                  },
                  Ur.createElement(Fe, {
                    latex: () => Kw(this.model),
                    getAriaLabel: () => this.getAriaLabel("speech"),
                    getAriaPostLabel: this.bindFn(this.getFormulaAria),
                    isFocused: () => this.isFocused(),
                    noFadeout: () =>
                      this.controller.isItemMarkedReadonly(this.model.id),
                    tokenController: this.props.controller,
                    capExpressionSize: () =>
                      this.controller.getCapExpressionSize(),
                    config: this.bindFn(this.getMQConfig),
                    hasError: this.const(false),
                    onUserPressedKey: (e, t) => this.handlePressedKey(e, t),
                    onUserChangedLatex: (e) => this.handleLatexChanged(e),
                    onExpressionSizeExceeded: () =>
                      this.controller.dispatch({
                        type: "expression-size-exceeded",
                      }),
                    onFocusedChanged: (e, t) =>
                      this.handleMQFocusedChanged(e, t),
                    onSelectionChanged: () => {
                      this.controller.runAfterDispatch(() => {
                        this.controller.dispatch({ type: "render" });
                      });
                    },
                    needsSystemKeypad: () => !this.controller.isKeypadEnabled(),
                  }),
                )),
              Ur.createElement(Z8, {
                predicate: () =>
                  this.controller.isInEditListMode() || this.isReadonly(),
              }, () =>
                Ur.createElement(
                  "div",
                  {
                    class: Ur.const("dcg-edit-list-mathquill"),
                    onTap: () =>
                      this.controller.isInEditListMode()
                        ? this.exitEditListMode()
                        : {},
                    onKeyDown: this.bindFn(this.handleReadonlyPressedKey),
                  },
                  Ur.createElement(
                    Mo,
                    {
                      latex: () => Kw(this.model),
                      operatorNames: () => this.getMQConfig().autoOperatorNames,
                      ariaLabel: () => this.getAriaLabel("braille"),
                      isStatic: this.const(true),
                      brailleShouldFocus: () => {
                        let e = this.controller.getFocusLocation();
                        return !e || e.type !== "readonly-expression"
                          ? false
                          : e.id === this.id;
                      },
                      onBrailleFocusedChanged: (e, t) => {
                        e
                          ? this.controller.dispatch({
                            type: "set-focus-location",
                            location: {
                              type: "readonly-expression",
                              id: this.model.id,
                            },
                          })
                          : this.doesNodeBelongToSliderLimit(
                            t.relatedTarget,
                          ) ||
                            this.controller.dispatch({
                              type: "blur-focus-location",
                              location: {
                                type: "readonly-expression",
                                id: this.model.id,
                              },
                            });
                      },
                      ...ui(this.controller),
                    },
                    Ur.createElement(
                      nt,
                      {
                        latex: () => Kw(this.model),
                        config: this.bindFn(this.getMQConfig),
                        getAriaLabel: () => this.getAriaLabel("speech"),
                        tokenController: this.props.controller,
                      },
                      Ur.createElement("span", {
                        class: Ur.const(
                          "dcg-focusable-readonly-mathquill",
                        ),
                        tabIndex: Ur.const("0"),
                        role: Ur.const("textbox"),
                        "aria-readonly": Ur.const("true"),
                        manageFocus: this.const({
                          shouldBeFocused: () =>
                            this.controller.getBrailleMode() !== "none"
                              ? false
                              : Bg({
                                controller: this.controller,
                                location: {
                                  type: "readonly-expression",
                                  id: this.model.id,
                                },
                              }),
                          onFocusedChanged: (e, t) => {
                            this.controller.getBrailleMode() === "none" &&
                              (e
                                ? this.controller.dispatch({
                                  type: "set-focus-location",
                                  location: {
                                    type: "readonly-expression",
                                    id: this.model.id,
                                  },
                                })
                                : this.doesNodeBelongToSliderLimit(
                                  t.relatedTarget,
                                ) ||
                                  this.controller.dispatch({
                                    type: "blur-focus-location",
                                    location: {
                                      type: "readonly-expression",
                                      id: this.model.id,
                                    },
                                  }));
                          },
                        }),
                      }),
                    ),
                  ),
                )),
            ),
            Ur.createElement(Wl, {
              controller: this.props.controller,
              model: this.props.model,
            }),
            Ur.createElement(rD, {
              controller: this.props.controller,
              model: this.props.model,
              isFirstRender: this.bindFn(this.isFirstRender),
            }),
          ),
          Ur.createElement(
            "span",
            {
              class: () => ({
                "dcg-tab": true,
                "dcg-action-drag": true,
                "dcg-action-icon-touch": true,
                ...this.debugProgressClassMap(),
              }),
              handleEvent: Ur.const("true"),
              tapboundary: Ur.const("true"),
              disablescroll: Ur.const("true"),
              onTapStart: this.bindFn(this.onDragPending),
            },
            Ur.createElement(
              "span",
              { class: Ur.const("dcg-num") },
              () => this.model.displayIndex,
            ),
            Ur.createElement(
              "div",
              {
                class: Ur.const("dcg-tab-interior dcg-action-icon-mouse"),
              },
              Ur.createElement(Cv, {
                model: this.props.model,
                controller: this.props.controller,
              }),
            ),
            Ur.createElement(Qb, {
              model: this.props.model,
              controller: this.props.controller,
            }),
            Ur.createElement(sD, {
              model: this.props.model,
              controller: this.props.controller,
            }),
          ),
          Ur.createElement(Hl, {
            controller: this.props.controller,
            id: () => this.model.id,
          }),
        );
      }
      debugProgressClassMap() {
        if (!this.controller.shouldShowProgressUpdateColors()) return {};
        let e = this.controller.getEvaluatorStateForItem(this.model.id);
        switch (e) {
          case void 0:
          case "IDLE":
          case "RESOLVED":
            return {};
          case "UNPUBLISHED":
            return { "dcg-progress-unpublished": true };
          case "ANALYZING":
            return { "dcg-progress-analyzing": true };
          case "GRAPHING":
            return { "dcg-progress-graphing": true };
          default:
            throw new Error(`Unexpected analysis state: ${e}`);
        }
      }
      didUpdate() {
        this.lastBrailleMode = this.controller.getBrailleMode();
      }
      shouldShowLabelView() {
        return ub(this.model) && !this.controller.isThreeDMode();
      }
      hasRegression() {
        return !!this.model.formula.is_regression;
      }
      hasDomain() {
        return Wu(this.model);
      }
      hasDomain3d() {
        return Dp(this.model);
      }
      isTTest() {
        return jw(this.model);
      }
      hasSlider() {
        return !!this.model.sliderExists;
      }
      getLabelOptions() {
        return this.controller.getEvaluationLabelOptionsForItem(
          this.model.id,
        );
      }
      getAriaLabel(e) {
        if (this.shouldShowLabelView()) {
          let t;
          this.model.label && this.model.label !== ""
            ? t = this.model.label
            : e === "speech"
            ? t = this.controller.s(
              "graphing-calculator-narration-expression-label",
            )
            : t = this.controller.raw("lbl");
          let o;
          return ja(this.model)
            ? o = t
            : e === "speech"
            ? o = this.controller.s(
              "graphing-calculator-narration-expression-hidden-label",
              { label: t },
            )
            : o = this.controller.raw("h __label__", { label: t }),
            o;
        }
        if (e === "speech") {
          let t = this.controller.s(
            "shared-calculator-narration-expression-index",
            { index: this.model.displayIndex },
          );
          if (this.controller.shouldShowProgressUpdateIcons()) {
            let o = this.controller.getEvaluatorStateForItem(
              this.model.id,
            );
            if (o) return `${t} - ${o}`;
          }
          return t;
        } else {return this.controller.raw("eq__index__", {
            index: this.model.displayIndex,
          });}
      }
      getFormulaAria() {
        let e = this.model.formula, t = "";
        if (this.controller.isItemSlowInEvaluator(this.model.id)) {
          return this.controller.shouldShowEvaluationForItem(this.id)
            ? this.controller.s(
              "graphing-calculator-narration-slow-evaluation",
            )
            : this.controller.s(
              "graphing-calculator-narration-slow-compute",
            );
        }
        if (!e || Vl(this.model)) return t;
        if (this.controller.shouldShowEvaluationForItem(this.model.id)) {
          t = `equals ${
            IT(this.model, this.controller, this.getLabelOptions())
          }`;
        } else if (
          e.error && !this.controller.shouldShowSliderPrompt(this.model)
        ) t = this.controller.unpack(e.error);
        else if (this.controller.shouldShowSliderPrompt(this.model)) {
          let o = Ep(this.model).length;
          if (o > 0) {
            t = this.controller.s(
              "graphing-calculator-narration-add-base-case-prompt",
              { count: __dcg_shared_module_exports__["ra"](o) },
            );
          } else {
            let i = [], n = ab(this.model);
            for (let a = 0; a < n.length; a++) i.push(Ao(n[a]));
            t = this.controller.s(
              "graphing-calculator-narration-add-slider-prompt",
              { vars: Cd(this.controller.getLanguage(), i) },
            );
          }
        } else {_p(this.model)
            ? t = this.controller.s(
              "graphing-calculator-narration-expression-evaluation-is-distribution",
            )
            : this.isTTest() &&
              (t = this.controller.s(
                "graphing-calculator-narration-expression-evaluation-is-t-test",
              ));}
        if (
          this.model.shouldGraph && (e.is_graphable || e.is_regression)
        ) {
          e.is_graphable && e.is_regression
            ? t += " " +
              this.controller.s(
                "graphing-calculator-narration-expression-evaluation-has-graph-and-regression",
              )
            : e.is_regression
            ? t += " " +
              this.controller.s(
                "graphing-calculator-narration-expression-evaluation-has-regression",
              )
            : t += " " +
              this.controller.s(
                "graphing-calculator-narration-expression-evaluation-has-graph",
              );
          let o = this.controller.getAudioGraph();
          o && o.agNavigator.canTrace(this.model) &&
            (Zo
              ? t += " " +
                this.controller.s(
                  "graphing-calculator-narration-expression-audio-trace-mac",
                )
              : t += " " +
                this.controller.s(
                  "graphing-calculator-narration-expression-audio-trace-windows",
                ));
        }
        return this.controller.toneEnabled() && Is(this.model) &&
          (this.model.hidden
            ? t += " " +
              this.controller.s(
                "graphing-calculator-narration-expression-tone-muted",
              )
            : t += " " +
              this.controller.s(
                "graphing-calculator-narration-expression-tone-unmuted",
              )),
          t;
      }
      handleBraillePressedKey(e) {
        let t = ke(e);
        if (t) {
          if (t === "Esc") {
            Jr(),
              this.hasSlider() &&
              this.controller.dispatch({
                type: "set-focus-location",
                location: { type: "slider-thumb", id: this.model.id },
              });
          } else if (t === "Up" || t === "Down" || t === "Enter") {
            this.controller.dispatch({
              type: "on-special-key-pressed",
              key: t,
            });
          } else if (t === "Del" || t === "Backspace") {
            let o = os();
            Vl(this.model) && Wb(o) &&
              (this.controller.dispatch({
                type: "on-special-key-pressed",
                key: t === "Del" ? "Delete" : t,
              }),
                e.preventDefault(),
                e.stopPropagation());
          }
        }
      }
      handleReadonlyPressedKey(e) {
        if (this.controller.isInEditListMode()) return;
        let t = ke(e);
        !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey &&
          (t === "Esc"
            ? (e.preventDefault(),
              e.stopPropagation(),
              Jr(),
              this.hasSlider() &&
              this.controller.dispatch({
                type: "set-focus-location",
                location: { type: "slider-thumb", id: this.model.id },
              }))
            : (t === "Up" || t === "Down" || t === "Enter") &&
              (e.preventDefault(),
                e.stopPropagation(),
                this.controller.dispatch({
                  type: "on-special-key-pressed",
                  key: t,
                })));
      }
      handlePressedKey(e, t) {
        var i;
        let o = Fe.getFocusedMathquill();
        if (o) {
          if (t && this.controller.isGraphPaperFocused()) {
            let n = (i = this.controller.getGrapher2d()) == null
              ? void 0
              : i.poiController;
            if (!n) return;
            let a = n.keyboardAttentionManager;
            if (e === "Tab" || e === "Shift-Tab") {
              t.stopPropagation(),
                t.preventDefault(),
                a.focusNextObjFromKeyboard({
                  direction: t.shiftKey ? "prev" : "next",
                });
              return;
            } else if (
              e === "Left" || e === "Right" || e === "Up" ||
              e === "Down" || e === "Shift-Left" || e === "Shift-Right" ||
              e === "Shift-Up" || e === "Shift-Down"
            ) {
              t.stopPropagation(),
                t.preventDefault(),
                t && n.moveGeoPointFromKeyboard(t);
              return;
            } else if (e === "Enter") {
              t.stopPropagation(), t.preventDefault();
              let s = a.getKeyboardAttention();
              n.activateGeoObjectFromKeyboard(s, t),
                this.controller.getEvaluator().notifyWhenSynced(() => {
                  let l = this.controller.getValidCursorContext(),
                    c = this.model.formula.cursor_context;
                  if (l && __dcg_shared_module_exports__["E"](l, c)) {
                    let d = this.controller.getFocusLocation();
                    if (
                      d && d.type === "expression" &&
                      d.id === this.model.id && !d.isFakeGraphFocus &&
                      this.controller.dispatch({
                        type: "set-focus-location",
                        location: { ...d, isFakeGraphFocus: true },
                      }), s
                    ) {
                      let p = a.findTabbableObjectsForCurrentTool(s);
                      p.currentIsTabbable &&
                        a.updateKeyboardAttention(
                          p.targets[p.currentTabIndex],
                          { describe: false },
                        );
                    }
                  }
                });
              return;
            } else if (e === "Esc") {
              t.stopPropagation(),
                t.preventDefault(),
                this.controller.dispatch({
                  type: "set-focus-location",
                  location: { type: "expression", id: this.model.id },
                });
              return;
            }
          }
          if (e === "Esc") {
            Jr(),
              this.hasSlider() &&
              this.controller.dispatch({
                type: "set-focus-location",
                location: { type: "slider-thumb", id: this.model.id },
              });
            return;
          } else {
            if (e === "Up" || e === "Down") {
              return Fe.applyArrowKeyAndReturnIfWasAtBounds(o, e, t)
                ? this.controller.dispatch({
                  type: "on-special-key-pressed",
                  key: e,
                })
                : void 0;
            }
            if (e === "Delete" || e === "Backspace") {
              if (Vl(this.model)) {
                return this.controller.dispatch({
                  type: "on-special-key-pressed",
                  key: e,
                });
              }
            } else if (e === "Enter") {
              return t && (t.preventDefault(), t.stopPropagation()),
                this.controller.dispatch({
                  type: "on-special-key-pressed",
                  key: "Enter",
                });
            }
          }
          o.keystroke(e, t), this.handleLatexChanged(o.latex());
        }
      }
      handleLatexChanged(e) {
        e !== this.model.latex &&
          this.controller.dispatch({
            type: "set-item-latex",
            id: this.id,
            latex: e,
            source: "user-edit",
          });
      }
      doesNodeBelongToSliderLimit(e) {
        return !e || !this.rootNode.contains(e)
          ? false
          : !!e.closest("[data-dcg-label]");
      }
      handleMQFocusedChanged(e, t) {
        e
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "expression", id: this.id },
          })
          : !this.doesNodeBelongToSliderLimit(t.relatedTarget) &&
            this.lastBrailleMode === this.controller.getBrailleMode() &&
            this.controller.dispatch({
              type: "blur-focus-location",
              location: { type: "expression", id: this.id },
            });
      }
      onMouseSelect(e) {
        this.isReadonly() ||
          e.device !== "keyboard" &&
            (e.type === "dcg-tap" && e.device === "mouse" ||
              e.type === "dcg-tapstart" && e.device === "touch" ||
              e.wasHandled() ||
              (e.handle(),
                this.controller.dispatch({
                  type: "set-focus-location",
                  location: { type: "expression", id: this.id },
                })));
      }
      isReadonly() {
        return this.controller.isItemReadonly(this.id);
      }
      isFocused() {
        let e = this.controller.getFocusLocation();
        return !e || e.type !== "expression" ? false : e.id === this.id;
      }
      hasError() {
        return !!this.model.error && !Vl(this.model);
      }
      getMQConfig() {
        return this.controller.getMathquillConfig({});
      }
    };
  function ui(r) {
    return {
      sixKeyInput: () => r.getSixKeyInput(),
      mode: () => r.getBrailleMode(),
      capExpressionSize: () =>
        r.getCapExpressionSize()
          ? {
            exceedsLimit: (e) => e.length > zb,
            onExpressionSizeExceeded: () =>
              r.dispatch({ type: "expression-size-exceeded" }),
          }
          : void 0,
    };
  }
  var bt = function (r, e, t) {
      var o = document.createElement("img"), i, n;
      if (
        o.onerror = e,
          o.onload = function () {
            n && !(t && t.noRevoke) && bt.revokeObjectURL(n),
              e && e(bt.scale(o, t));
          },
          bt.isInstanceOf("Blob", r) || bt.isInstanceOf("File", r)
      ) i = n = bt.createObjectURL(r), o._type = r.type;
      else if (typeof r == "string") {
        i = r, t && t.crossOrigin && (o.crossOrigin = t.crossOrigin);
      } else return false;
      return i ? (o.src = i, o) : bt.readFile(r, function (a) {
        var s = a.target;
        s && s.result ? o.src = s.result : e && e(a);
      });
    },
    lD = window.createObjectURL && window ||
      window.URL && URL.revokeObjectURL && URL ||
      window.webkitURL && webkitURL;
  bt.isInstanceOf = function (r, e) {
    return Object.prototype.toString.call(e) === "[object " + r + "]";
  };
  bt.transformCoordinates = function () {};
  bt.getTransformedOptions = function (r) {
    return r;
  };
  bt.renderImageToCanvas = function (r, e, t, o, i, n, a, s, l, c) {
    return r.getContext("2d").drawImage(e, t, o, i, n, a, s, l, c), r;
  };
  bt.hasCanvasOption = function (r) {
    return r.canvas || r.crop;
  };
  bt.scale = function (r, e) {
    e = e || {};
    var t = document.createElement("canvas"),
      o = r.getContext || bt.hasCanvasOption(e) && t.getContext,
      i = r.naturalWidth || r.width,
      n = r.naturalHeight || r.height,
      a = i,
      s = n,
      l,
      c,
      d,
      p,
      h,
      u,
      f,
      y,
      C,
      E = function () {
        var w = Math.max((d || a) / a, (p || s) / s);
        w > 1 && (a = Math.ceil(a * w), s = Math.ceil(s * w));
      },
      v = function () {
        var w = Math.min((l || a) / a, (c || s) / s);
        w < 1 && (a = Math.ceil(a * w), s = Math.ceil(s * w));
      };
    return o &&
      (e = bt.getTransformedOptions(e),
        f = e.left || 0,
        y = e.top || 0,
        e.sourceWidth
          ? (h = e.sourceWidth,
            e.right !== void 0 && e.left === void 0 &&
            (f = i - h - e.right))
          : h = i - f - (e.right || 0),
        e.sourceHeight
          ? (u = e.sourceHeight,
            e.bottom !== void 0 && e.top === void 0 &&
            (y = n - u - e.bottom))
          : u = n - y - (e.bottom || 0),
        a = h,
        s = u),
      l = e.maxWidth,
      c = e.maxHeight,
      d = e.minWidth,
      p = e.minHeight,
      o && l && c && e.crop
        ? (a = l,
          s = c,
          C = h / u - l / c,
          C < 0
            ? (u = c * h / l,
              e.top === void 0 && e.bottom === void 0 &&
              (y = (n - u) / 2))
            : C > 0 &&
              (h = l * u / c,
                e.left === void 0 && e.right === void 0 &&
                (f = (i - h) / 2)))
        : ((e.contain || e.cover) && (d = l = l || d, p = c = c || p),
          e.cover ? (v(), E()) : (E(), v())),
      o
        ? (t.width = a,
          t.height = s,
          bt.transformCoordinates(t, e),
          bt.renderImageToCanvas(t, r, f, y, h, u, 0, 0, a, s))
        : (r.width = a, r.height = s, r);
  };
  bt.createObjectURL = function (r) {
    return lD ? lD.createObjectURL(r) : false;
  };
  bt.revokeObjectURL = function (r) {
    return lD ? lD.revokeObjectURL(r) : false;
  };
  bt.readFile = function (r, e, t) {
    if (window.FileReader) {
      var o = new FileReader();
      if (o.onload = o.onerror = e, t = t || "readAsDataURL", o[t]) {
        return o[t](r), o;
      }
    }
    return false;
  };
  (!window.navigator || !window.navigator.platform ||
    !/iP(hone|od|ad)/.test(window.navigator.platform)) &&
    (eK = bt.renderImageToCanvas,
      bt.detectSubsampling = function (r) {
        var e, t;
        return r.width * r.height > 1024 * 1024
          ? (e = document.createElement("canvas"),
            e.width = e.height = 1,
            t = e.getContext("2d"),
            t.drawImage(r, -r.width + 1, 0),
            t.getImageData(0, 0, 1, 1).data[3] === 0)
          : false;
      },
      bt.detectVerticalSquash = function (r, e) {
        var t = r.naturalHeight || r.height,
          o = document.createElement("canvas"),
          i = o.getContext("2d"),
          n,
          a,
          s,
          l,
          c;
        for (
          e && (t /= 2),
            o.width = 1,
            o.height = t,
            i.drawImage(r, 0, 0),
            n = i.getImageData(0, 0, 1, t).data,
            a = 0,
            s = t,
            l = t;
          l > a;
        ) c = n[(l - 1) * 4 + 3], c === 0 ? s = l : a = l, l = s + a >> 1;
        return l / t || 1;
      },
      bt.renderImageToCanvas = function (r, e, t, o, i, n, a, s, l, c) {
        if (e._type === "image/jpeg") {
          var d = r.getContext("2d"),
            p = document.createElement("canvas"),
            h = 1024,
            u = p.getContext("2d"),
            f,
            y,
            C,
            E;
          if (
            p.width = h,
              p.height = h,
              d.save(),
              f = bt.detectSubsampling(e),
              f && (t /= 2, o /= 2, i /= 2, n /= 2),
              y = bt.detectVerticalSquash(e, f),
              f || y !== 1
          ) {
            for (
              o *= y,
                l = Math.ceil(h * l / i),
                c = Math.ceil(h * c / n / y),
                s = 0,
                E = 0;
              E < n;
            ) {
              for (a = 0, C = 0; C < i;) {
                u.clearRect(0, 0, h, h),
                  u.drawImage(e, t, o, i, n, -C, -E, i, n),
                  d.drawImage(p, 0, 0, h, h, a, s, l, c),
                  C += h,
                  a += l;
              }
              E += h, s += c;
            }
            return d.restore(), r;
          }
        }
        return eK(r, e, t, o, i, n, a, s, l, c);
      });
  var eK,
    Soe = window.Blob &&
      (Blob.prototype.slice || Blob.prototype.webkitSlice ||
        Blob.prototype.mozSlice);
  bt.blobSlice = Soe && function () {
    var r = this.slice || this.webkitSlice || this.mozSlice;
    return r.apply(this, arguments);
  };
  bt.metaDataParsers = { jpeg: { 65505: [] } };
  bt.parseMetaData = function (r, e, t) {
    t = t || {};
    var o = this,
      i = t.maxMetaDataSize || 262144,
      n = {},
      a = !(window.DataView && r && r.size >= 12 &&
        r.type === "image/jpeg" && bt.blobSlice);
    (a || !bt.readFile(bt.blobSlice.call(r, 0, i), function (s) {
      var l = s.target.result,
        c = new DataView(l),
        d = 2,
        p = c.byteLength - 4,
        h = d,
        u,
        f,
        y,
        C;
      if (c.getUint16(0) === 65496) {
        for (
          ;
          d < p &&
          (u = c.getUint16(d), u >= 65504 && u <= 65519 || u === 65534);
        ) {
          if (f = c.getUint16(d + 2) + 2, d + f > c.byteLength) {
            console.log("Invalid meta data: Invalid segment size.");
            break;
          }
          if (y = bt.metaDataParsers.jpeg[u], y) {
            for (C = 0; C < y.length; C += 1) {
              y[C].call(o, c, d, f, n, t);
            }
          }
          d += f, h = d;
        }
        !t.disableImageHead && h > 6 &&
          (l.slice
            ? n.imageHead = l.slice(0, h)
            : n.imageHead = new Uint8Array(l).subarray(0, h));
      } else console.log("Invalid JPEG file: Missing JPEG marker.");
      e(n);
    }, "readAsArrayBuffer")) && e(n);
  };
  var Eoe = bt.hasCanvasOption;
  bt.hasCanvasOption = function (r) {
    return Eoe(r) || r.orientation;
  };
  bt.transformCoordinates = function (r, e) {
    var t = r.getContext("2d"),
      o = r.width,
      i = r.height,
      n = e.orientation;
    if (n) {
      switch (n > 4 && (r.width = i, r.height = o), n) {
        case 2:
          t.translate(o, 0), t.scale(-1, 1);
          break;
        case 3:
          t.translate(o, i), t.rotate(Math.PI);
          break;
        case 4:
          t.translate(0, i), t.scale(1, -1);
          break;
        case 5:
          t.rotate(.5 * Math.PI), t.scale(1, -1);
          break;
        case 6:
          t.rotate(.5 * Math.PI), t.translate(0, -i);
          break;
        case 7:
          t.rotate(.5 * Math.PI), t.translate(o, -i), t.scale(-1, 1);
          break;
        case 8:
          t.rotate(-.5 * Math.PI), t.translate(-o, 0);
          break;
      }
    }
  };
  bt.getTransformedOptions = function (r) {
    if (!r.orientation || r.orientation === 1) return r;
    var e = {}, t;
    for (t in r) r.hasOwnProperty(t) && (e[t] = r[t]);
    switch (r.orientation) {
      case 2:
        e.left = r.right, e.right = r.left;
        break;
      case 3:
        e.left = r.right, e.top = r.bottom, e.right = r.left, e.bottom = r.top;
        break;
      case 4:
        e.top = r.bottom, e.bottom = r.top;
        break;
      case 5:
        e.left = r.top, e.top = r.left, e.right = r.bottom, e.bottom = r.right;
        break;
      case 6:
        e.left = r.top, e.top = r.right, e.right = r.bottom, e.bottom = r.left;
        break;
      case 7:
        e.left = r.bottom, e.top = r.right, e.right = r.top, e.bottom = r.left;
        break;
      case 8:
        e.left = r.bottom, e.top = r.left, e.right = r.top, e.bottom = r.right;
        break;
    }
    return r.orientation > 4 &&
      (e.maxWidth = r.maxHeight,
        e.maxHeight = r.maxWidth,
        e.minWidth = r.minHeight,
        e.minHeight = r.minWidth,
        e.sourceWidth = r.sourceHeight,
        e.sourceHeight = r.sourceWidth),
      e;
  };
  bt.ExifMap = function () {
    return this;
  };
  bt.ExifMap.prototype.map = { Orientation: 274 };
  bt.ExifMap.prototype.get = function (r) {
    return this[r] || this[this.map[r]];
  };
  bt.getExifThumbnail = function (r, e, t) {
    var o, i, n;
    if (!t || e + t > r.byteLength) {
      console.log("Invalid Exif data: Invalid thumbnail data.");
      return;
    }
    for (o = [], i = 0; i < t; i += 1) {
      n = r.getUint8(e + i), o.push((n < 16 ? "0" : "") + n.toString(16));
    }
    return "data:image/jpeg,%" + o.join("%");
  };
  bt.exifTagTypes = {
    1: {
      getValue: function (r, e) {
        return r.getUint8(e);
      },
      size: 1,
    },
    2: {
      getValue: function (r, e) {
        return String.fromCharCode(r.getUint8(e));
      },
      size: 1,
      ascii: true,
    },
    3: {
      getValue: function (r, e, t) {
        return r.getUint16(e, t);
      },
      size: 2,
    },
    4: {
      getValue: function (r, e, t) {
        return r.getUint32(e, t);
      },
      size: 4,
    },
    5: {
      getValue: function (r, e, t) {
        return r.getUint32(e, t) / r.getUint32(e + 4, t);
      },
      size: 8,
    },
    9: {
      getValue: function (r, e, t) {
        return r.getInt32(e, t);
      },
      size: 4,
    },
    10: {
      getValue: function (r, e, t) {
        return r.getInt32(e, t) / r.getInt32(e + 4, t);
      },
      size: 8,
    },
  };
  bt.exifTagTypes[7] = bt.exifTagTypes[1];
  bt.getExifValue = function (r, e, t, o, i, n) {
    var a = bt.exifTagTypes[o], s, l, c, d, p, h;
    if (!a) {
      console.log("Invalid Exif data: Invalid tag type.");
      return;
    }
    if (
      s = a.size * i,
        l = s > 4 ? e + r.getUint32(t + 8, n) : t + 8,
        l + s > r.byteLength
    ) {
      console.log("Invalid Exif data: Invalid data offset.");
      return;
    }
    if (i === 1) return a.getValue(r, l, n);
    for (c = [], d = 0; d < i; d += 1) {
      c[d] = a.getValue(r, l + d * a.size, n);
    }
    if (a.ascii) {
      for (
        p = "", d = 0;
        d < c.length && (h = c[d], h !== "\0");
        d += 1
      ) p += h;
      return p;
    }
    return c;
  };
  bt.parseExifTag = function (r, e, t, o, i) {
    var n = r.getUint16(t, o);
    i.exif[n] = bt.getExifValue(
      r,
      e,
      t,
      r.getUint16(t + 2, o),
      r.getUint32(t + 4, o),
      o,
    );
  };
  bt.parseExifTags = function (r, e, t, o, i) {
    var n, a, s;
    if (t + 6 > r.byteLength) {
      console.log("Invalid Exif data: Invalid directory offset.");
      return;
    }
    if (n = r.getUint16(t, o), a = t + 2 + 12 * n, a + 4 > r.byteLength) {
      console.log("Invalid Exif data: Invalid directory size.");
      return;
    }
    for (s = 0; s < n; s += 1) {
      this.parseExifTag(r, e, t + 2 + 12 * s, o, i);
    }
    return r.getUint32(a, o);
  };
  bt.parseExifData = function (r, e, t, o, i) {
    if (!i.disableExif) {
      var n = e + 10, a, s, l;
      if (r.getUint32(e + 4) === 1165519206) {
        if (n + 8 > r.byteLength) {
          console.log("Invalid Exif data: Invalid segment size.");
          return;
        }
        if (r.getUint16(e + 8) !== 0) {
          console.log(
            "Invalid Exif data: Missing byte alignment offset.",
          );
          return;
        }
        switch (r.getUint16(n)) {
          case 18761:
            a = true;
            break;
          case 19789:
            a = false;
            break;
          default:
            console.log(
              "Invalid Exif data: Invalid byte alignment marker.",
            );
            return;
        }
        if (r.getUint16(n + 2, a) !== 42) {
          console.log("Invalid Exif data: Missing TIFF marker.");
          return;
        }
        s = r.getUint32(n + 4, a),
          o.exif = new bt.ExifMap(),
          s = bt.parseExifTags(r, n, n + s, a, o),
          s && !i.disableExifThumbnail &&
          (l = { exif: {} },
            s = bt.parseExifTags(r, n, n + s, a, l),
            l.exif[513] &&
            (o.exif.Thumbnail = bt.getExifThumbnail(
              r,
              n + l.exif[513],
              l.exif[514],
            ))),
          o.exif[34665] && !i.disableExifSub &&
          bt.parseExifTags(r, n, n + o.exif[34665], a, o),
          o.exif[34853] && !i.disableExifGps &&
          bt.parseExifTags(r, n, n + o.exif[34853], a, o);
      }
    }
  };
  bt.metaDataParsers.jpeg[65505].push(bt.parseExifData);
  bt.ExifMap.prototype.tags = {
    256: "ImageWidth",
    257: "ImageHeight",
    34665: "ExifIFDPointer",
    34853: "GPSInfoIFDPointer",
    40965: "InteroperabilityIFDPointer",
    258: "BitsPerSample",
    259: "Compression",
    262: "PhotometricInterpretation",
    274: "Orientation",
    277: "SamplesPerPixel",
    284: "PlanarConfiguration",
    530: "YCbCrSubSampling",
    531: "YCbCrPositioning",
    282: "XResolution",
    283: "YResolution",
    296: "ResolutionUnit",
    273: "StripOffsets",
    278: "RowsPerStrip",
    279: "StripByteCounts",
    513: "JPEGInterchangeFormat",
    514: "JPEGInterchangeFormatLength",
    301: "TransferFunction",
    318: "WhitePoint",
    319: "PrimaryChromaticities",
    529: "YCbCrCoefficients",
    532: "ReferenceBlackWhite",
    306: "DateTime",
    270: "ImageDescription",
    271: "Make",
    272: "Model",
    305: "Software",
    315: "Artist",
    33432: "Copyright",
    36864: "ExifVersion",
    40960: "FlashpixVersion",
    40961: "ColorSpace",
    40962: "PixelXDimension",
    40963: "PixelYDimension",
    42240: "Gamma",
    37121: "ComponentsConfiguration",
    37122: "CompressedBitsPerPixel",
    37500: "MakerNote",
    37510: "UserComment",
    40964: "RelatedSoundFile",
    36867: "DateTimeOriginal",
    36868: "DateTimeDigitized",
    37520: "SubSecTime",
    37521: "SubSecTimeOriginal",
    37522: "SubSecTimeDigitized",
    33434: "ExposureTime",
    33437: "FNumber",
    34850: "ExposureProgram",
    34852: "SpectralSensitivity",
    34855: "PhotographicSensitivity",
    34856: "OECF",
    34864: "SensitivityType",
    34865: "StandardOutputSensitivity",
    34866: "RecommendedExposureIndex",
    34867: "ISOSpeed",
    34868: "ISOSpeedLatitudeyyy",
    34869: "ISOSpeedLatitudezzz",
    37377: "ShutterSpeedValue",
    37378: "ApertureValue",
    37379: "BrightnessValue",
    37380: "ExposureBias",
    37381: "MaxApertureValue",
    37382: "SubjectDistance",
    37383: "MeteringMode",
    37384: "LightSource",
    37385: "Flash",
    37396: "SubjectArea",
    37386: "FocalLength",
    41483: "FlashEnergy",
    41484: "SpatialFrequencyResponse",
    41486: "FocalPlaneXResolution",
    41487: "FocalPlaneYResolution",
    41488: "FocalPlaneResolutionUnit",
    41492: "SubjectLocation",
    41493: "ExposureIndex",
    41495: "SensingMethod",
    41728: "FileSource",
    41729: "SceneType",
    41730: "CFAPattern",
    41985: "CustomRendered",
    41986: "ExposureMode",
    41987: "WhiteBalance",
    41988: "DigitalZoomRatio",
    41989: "FocalLengthIn35mmFilm",
    41990: "SceneCaptureType",
    41991: "GainControl",
    41992: "Contrast",
    41993: "Saturation",
    41994: "Sharpness",
    41995: "DeviceSettingDescription",
    41996: "SubjectDistanceRange",
    42016: "ImageUniqueID",
    42032: "CameraOwnerName",
    42033: "BodySerialNumber",
    42034: "LensSpecification",
    42035: "LensMake",
    42036: "LensModel",
    42037: "LensSerialNumber",
    0: "GPSVersionID",
    1: "GPSLatitudeRef",
    2: "GPSLatitude",
    3: "GPSLongitudeRef",
    4: "GPSLongitude",
    5: "GPSAltitudeRef",
    6: "GPSAltitude",
    7: "GPSTimeStamp",
    8: "GPSSatellites",
    9: "GPSStatus",
    10: "GPSMeasureMode",
    11: "GPSDOP",
    12: "GPSSpeedRef",
    13: "GPSSpeed",
    14: "GPSTrackRef",
    15: "GPSTrack",
    16: "GPSImgDirectionRef",
    17: "GPSImgDirection",
    18: "GPSMapDatum",
    19: "GPSDestLatitudeRef",
    20: "GPSDestLatitude",
    21: "GPSDestLongitudeRef",
    22: "GPSDestLongitude",
    23: "GPSDestBearingRef",
    24: "GPSDestBearing",
    25: "GPSDestDistanceRef",
    26: "GPSDestDistance",
    27: "GPSProcessingMethod",
    28: "GPSAreaInformation",
    29: "GPSDateStamp",
    30: "GPSDifferential",
    31: "GPSHPositioningError",
  };
  bt.ExifMap.prototype.stringValues = {
    ExposureProgram: {
      0: "Undefined",
      1: "Manual",
      2: "Normal program",
      3: "Aperture priority",
      4: "Shutter priority",
      5: "Creative program",
      6: "Action program",
      7: "Portrait mode",
      8: "Landscape mode",
    },
    MeteringMode: {
      0: "Unknown",
      1: "Average",
      2: "CenterWeightedAverage",
      3: "Spot",
      4: "MultiSpot",
      5: "Pattern",
      6: "Partial",
      255: "Other",
    },
    LightSource: {
      0: "Unknown",
      1: "Daylight",
      2: "Fluorescent",
      3: "Tungsten (incandescent light)",
      4: "Flash",
      9: "Fine weather",
      10: "Cloudy weather",
      11: "Shade",
      12: "Daylight fluorescent (D 5700 - 7100K)",
      13: "Day white fluorescent (N 4600 - 5400K)",
      14: "Cool white fluorescent (W 3900 - 4500K)",
      15: "White fluorescent (WW 3200 - 3700K)",
      17: "Standard light A",
      18: "Standard light B",
      19: "Standard light C",
      20: "D55",
      21: "D65",
      22: "D75",
      23: "D50",
      24: "ISO studio tungsten",
      255: "Other",
    },
    Flash: {
      0: "Flash did not fire",
      1: "Flash fired",
      5: "Strobe return light not detected",
      7: "Strobe return light detected",
      9: "Flash fired, compulsory flash mode",
      13: "Flash fired, compulsory flash mode, return light not detected",
      15: "Flash fired, compulsory flash mode, return light detected",
      16: "Flash did not fire, compulsory flash mode",
      24: "Flash did not fire, auto mode",
      25: "Flash fired, auto mode",
      29: "Flash fired, auto mode, return light not detected",
      31: "Flash fired, auto mode, return light detected",
      32: "No flash function",
      65: "Flash fired, red-eye reduction mode",
      69: "Flash fired, red-eye reduction mode, return light not detected",
      71: "Flash fired, red-eye reduction mode, return light detected",
      73: "Flash fired, compulsory flash mode, red-eye reduction mode",
      77:
        "Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",
      79:
        "Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",
      89: "Flash fired, auto mode, red-eye reduction mode",
      93:
        "Flash fired, auto mode, return light not detected, red-eye reduction mode",
      95:
        "Flash fired, auto mode, return light detected, red-eye reduction mode",
    },
    SensingMethod: {
      1: "Undefined",
      2: "One-chip color area sensor",
      3: "Two-chip color area sensor",
      4: "Three-chip color area sensor",
      5: "Color sequential area sensor",
      7: "Trilinear sensor",
      8: "Color sequential linear sensor",
    },
    SceneCaptureType: {
      0: "Standard",
      1: "Landscape",
      2: "Portrait",
      3: "Night scene",
    },
    SceneType: { 1: "Directly photographed" },
    CustomRendered: { 0: "Normal process", 1: "Custom process" },
    WhiteBalance: { 0: "Auto white balance", 1: "Manual white balance" },
    GainControl: {
      0: "None",
      1: "Low gain up",
      2: "High gain up",
      3: "Low gain down",
      4: "High gain down",
    },
    Contrast: { 0: "Normal", 1: "Soft", 2: "Hard" },
    Saturation: {
      0: "Normal",
      1: "Low saturation",
      2: "High saturation",
    },
    Sharpness: { 0: "Normal", 1: "Soft", 2: "Hard" },
    SubjectDistanceRange: {
      0: "Unknown",
      1: "Macro",
      2: "Close view",
      3: "Distant view",
    },
    FileSource: { 3: "DSC" },
    ComponentsConfiguration: {
      0: "",
      1: "Y",
      2: "Cb",
      3: "Cr",
      4: "R",
      5: "G",
      6: "B",
    },
    Orientation: {
      1: "top-left",
      2: "top-right",
      3: "bottom-right",
      4: "bottom-left",
      5: "left-top",
      6: "right-top",
      7: "right-bottom",
      8: "left-bottom",
    },
  };
  bt.ExifMap.prototype.getText = function (r) {
    var e = this.get(r);
    switch (r) {
      case "LightSource":
      case "Flash":
      case "MeteringMode":
      case "ExposureProgram":
      case "SensingMethod":
      case "SceneCaptureType":
      case "SceneType":
      case "CustomRendered":
      case "WhiteBalance":
      case "GainControl":
      case "Contrast":
      case "Saturation":
      case "Sharpness":
      case "SubjectDistanceRange":
      case "FileSource":
      case "Orientation":
        return this.stringValues[r][e];
      case "ExifVersion":
      case "FlashpixVersion":
        return String.fromCharCode(e[0], e[1], e[2], e[3]);
      case "ComponentsConfiguration":
        return this.stringValues[r][e[0]] + this.stringValues[r][e[1]] +
          this.stringValues[r][e[2]] + this.stringValues[r][e[3]];
      case "GPSVersionID":
        return e[0] + "." + e[1] + "." + e[2] + "." + e[3];
    }
    return String(e);
  };
  (function (r) {
    var e = r.tags, t = r.map, o;
    for (o in e) e.hasOwnProperty(o) && (t[e[o]] = o);
  })(bt.ExifMap.prototype);
  bt.ExifMap.prototype.getAll = function () {
    var r = {}, e, t;
    for (e in this) {
      this.hasOwnProperty(e) &&
        (t = this.tags[e], t && (r[t] = this.getText(t)));
    }
    return r;
  };
  function tK(r, e) {
    let t = [.92, .86, .8, .7, .6, .5, .4, .3, .2, .1], o;
    for (let i = 0; i < t.length; i++) {
      if (o = r.toDataURL("image/jpeg", t[i]), o.length < e) return o;
    }
    return o;
  }
  function Toe(r, e) {
    let t = r.toDataURL().length,
      o = r.width,
      i = r.height,
      n = document.createElement("canvas"),
      a;
    for (let s = 0; s < 2; s++) {
      let l = Math.sqrt(e / t);
      if (
        o = Math.round(l * o),
          i = Math.round(l * i),
          n.height = i,
          n.width = o,
          n.getContext("2d").drawImage(r, 0, 0, o, i),
          a = n.toDataURL(),
          t = a.length,
          t < e
      ) return a;
    }
    return a;
  }
  function Doe(r) {
    let t = r.getContext("2d").getImageData(0, 0, r.width, r.height).data;
    for (let o = 3; o < t.length; o += 4) if (t[o] !== 255) return true;
    return false;
  }
  function cD(r, e) {
    bt(r, (o) => {
      if (!o.toDataURL) {
        e(true);
        return;
      }
      let i = 2e5, n;
      r.type === "image/jpeg"
        ? n = tK(o, i)
        : (n = o.toDataURL(),
          n.length > i &&
          (n = n.length > .75 * o.width * o.height && !Doe(o)
            ? tK(o, i)
            : Toe(o, i))), e(null, n);
    }, { orientation: true, canvas: true, maxWidth: 1600, maxHeight: 1600 });
  }
  var Pn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  function dD(r) {
    let e = document.createElement("a");
    return e.href = r, e.href;
  }
  var { SwitchUnion: koe, If: _oe } = Pn.Components,
    $g = class extends Pn.Class {
      init() {
        this.model = this.props.model(),
          this.controller = this.props.controller();
      }
      template() {
        return Pn.createElement(
          "div",
          {
            class: Pn.const(
              "dcg-expression-icon-container dcg-image-icon-container",
            ),
          },
          koe(this.bindFn(this.typeOfIcon), {
            error: () =>
              Pn.createElement(Di, {
                error: () => this.controller.unpack(this.model.error),
                isWhite: this.bindFn(this.isSelected),
              }),
            failed: () => Pn.createElement("span", null),
            loading: () =>
              Pn.createElement($o, { iconType: this.const("loading") }),
            hidden: () => this.buildIconView(),
            image: () => this.buildIconView(),
          }),
        );
      }
      buildIconView() {
        return Pn.createElement(
          "div",
          {
            class: Pn.const("dcg-circular-icon-container"),
            role: Pn.const("button"),
            tabIndex: Pn.const("0"),
            "dcg-open-menu-guid": () => this.getMenuGUID(),
            "aria-label": this.bindFn(this.getIconAriaLabel),
            onTap: (e) => {
              if (!e.wasHandled("dragdrop") && !e.wasLongheld()) {
                if (this.myOptionsOpen()) return this.toggleOptions(e);
                if (
                  this.controller.isInEditListMode() || e.shiftKey
                ) return this.toggleOptions(e);
                this.toggleImageShown();
              }
            },
            onLongHold: (e) => {
              e.handle("dcg-longhold"),
                e.handle("dcg-tap"),
                this.toggleOptions(e);
            },
            manageFocus: this.const(
              rt({
                controller: this.controller,
                location: { type: "image-icon", id: this.model.id },
              }),
            ),
          },
          Pn.createElement($o, {
            iconType: () =>
              this.typeOfIcon() === "hidden" ? "hidden" : "background",
            backgroundImage: this.bindFn(this.getBackgroundImage),
            backgroundOpacity: this.const(1),
            whiteIcon: this.bindFn(this.isSelected),
          }),
          Pn.createElement(_oe, {
            predicate: () => this.model.disableGraphInteractions,
          }, () =>
            Pn.createElement("i", {
              class: Pn.const(
                "dcg-graph-interaction-disabled dcg-icon-lock",
              ),
            })),
        );
      }
      isSelected() {
        return this.controller.isItemSelected(this.model.id) ||
          this.controller.isItemBeingDragged(this.model.id);
      }
      typeOfIcon() {
        return this.model.loadStatus === "loading"
          ? "loading"
          : this.model.loadStatus === "failed"
          ? "failed"
          : this.hasError()
          ? "error"
          : this.model.shouldGraph
          ? "image"
          : "hidden";
      }
      getMenuGUID() {
        return this.model.guid;
      }
      myOptionsOpen() {
        return this.controller.isItemSettingsMenuOpen(this.getMenuGUID());
      }
      toggleOptions(e) {
        this.controller.dispatch({
          type: "toggle-item-settings-menu",
          menu: {
            type: "image",
            model: this.model,
            guid: this.getMenuGUID(),
            focusFirstOption: e.device === "keyboard",
          },
        });
      }
      hasError() {
        return !!this.model.error &&
          this.controller.getBrailleMode() === "none";
      }
      getBackgroundImage() {
        return this.model.image_url === this.lastURL
          ? this.lastEncodedURL
          : (this.lastURL = this.model.image_url,
            this.lastEncodedURL = 'url("' + dD(this.model.image_url) +
              '")',
            this.lastEncodedURL);
      }
      toggleImageShown() {
        this.controller.dispatch({
          type: "toggle-item-hidden",
          id: this.model.id,
        }),
          this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "image-icon", id: this.model.id },
          });
      }
      getIconAriaLabel() {
        return this.myOptionsOpen()
          ? Xr(this.model, "hide-options")
          : this.controller.isInEditListMode()
          ? Xr(this.model, "show-options")
          : this.model.hidden
          ? Xr(this.model, "show")
          : Xr(this.model, "hide");
      }
    };
  function Ev(r, e) {
    for (let t in e) if (e.hasOwnProperty(t) && e[t] === r) return true;
    return false;
  }
  function SP(r) {
    return Ev(r, TP);
  }
  function EP(r) {
    return Ev(r, DP);
  }
  function oK(r) {
    return Ev(r, kP);
  }
  function Ioe(r) {
    return Ev(r, Sv);
  }
  function Aoe(r) {
    return Ev(r, _P);
  }
  var TP = { OPEN: "OPEN", CROSS: "CROSS", POINT: "POINT" },
    DP = { SOLID: "SOLID", DASHED: "DASHED", DOTTED: "DOTTED" },
    kP = { NONE: "NONE", AUTO: "AUTO", X: "X", Y: "Y", XY: "XY" },
    Sv = {
      POINTS: "POINTS",
      LINES: "LINES",
      POINTS_AND_LINES: "POINTS_AND_LINES",
    },
    _P = {
      DEFAULT: "default",
      CENTER: "center",
      CENTER_AUTO: "center_auto",
      AUTO_CENTER: "auto_center",
      ABOVE: "above",
      ABOVE_LEFT: "above_left",
      ABOVE_RIGHT: "above_right",
      ABOVE_AUTO: "above_auto",
      BELOW: "below",
      BELOW_LEFT: "below_left",
      BELOW_RIGHT: "below_right",
      BELOW_AUTO: "below_auto",
      LEFT: "left",
      AUTO_LEFT: "auto_left",
      RIGHT: "right",
      AUTO_RIGHT: "auto_right",
    };
  function Moe(r) {
    return { id: r.id, type: r.type, columns: r.columns.map(Goe) };
  }
  function Goe(r) {
    return {
      id: r.id,
      latex: r.latex,
      color: r.color,
      hidden: r.hidden,
      pointStyle: r.pointStyle,
      pointSize: r.pointSize,
      pointOpacity: r.pointOpacity,
      lineStyle: r.lineStyle,
      lineWidth: r.lineWidth,
      lineOpacity: r.lineOpacity,
      points: r.points,
      lines: r.lines,
      dragMode: r.dragMode,
      values: r.values.slice(),
    };
  }
  function Loe(r) {
    let e = [
        "latex",
        "color",
        "lineStyle",
        "lineWidth",
        "lineOpacity",
        "pointStyle",
        "pointSize",
        "movablePointSize",
        "pointOpacity",
        "points",
        "lines",
        "fill",
        "fillOpacity",
        "hidden",
        "secret",
        "dragMode",
        "label",
        "showLabel",
        "labelSize",
        "labelOrientation",
        "interactiveLabel",
        "readonly",
      ],
      t = { id: r.id, type: r.type };
    return e.forEach((o) => {
      r.hasOwnProperty(o) && (t[o] = r[o]);
    }),
      r.hasOwnProperty("parametricDomain") &&
      (t.parametricDomain = {
        min: r.parametricDomain.min,
        max: r.parametricDomain.max,
      }),
      r.hasOwnProperty("parametricDomain3Du") &&
      (t.parametricDomain3Du = {
        min: r.parametricDomain3Du.min,
        max: r.parametricDomain3Du.max,
      }),
      r.hasOwnProperty("parametricDomain3Dv") &&
      (t.parametricDomain3Dv = {
        min: r.parametricDomain3Dv.min,
        max: r.parametricDomain3Dv.max,
      }),
      r.hasOwnProperty("parametricDomain3Dr") &&
      (t.parametricDomain3Dr = {
        min: r.parametricDomain3Dr.min,
        max: r.parametricDomain3Dr.max,
      }),
      r.hasOwnProperty("parametricDomain3Dphi") &&
      (t.parametricDomain3Dphi = {
        min: r.parametricDomain3Dphi.min,
        max: r.parametricDomain3Dphi.max,
      }),
      r.hasOwnProperty("polarDomain") &&
      (t.polarDomain = {
        min: r.polarDomain.min,
        max: r.polarDomain.max,
      }),
      r.hasOwnProperty("domain") &&
      (t.domain = { min: r.domain.min, max: r.domain.max }),
      r.slider &&
      (r.slider.hardMin &&
        (t.sliderBounds = t.sliderBounds || {},
          t.sliderBounds.min = r.slider.min),
        r.slider.hardMax &&
        (t.sliderBounds = t.sliderBounds || {},
          t.sliderBounds.max = r.slider.max),
        r.slider.step &&
        (t.sliderBounds = t.sliderBounds || {},
          t.sliderBounds.step = r.slider.step),
        t.playing = !!r.slider.isPlaying),
      t;
  }
  function Poe(r) {
    return { id: r.id, type: r.type, hidden: r.hidden, secret: r.secret };
  }
  function Voe(r) {
    return { id: r.id, type: r.type, hidden: r.hidden, secret: r.secret };
  }
  function Ooe(r) {
    return { id: r.id, type: r.type, secret: r.secret, text: r.text };
  }
  function pD(r) {
    switch (r.type) {
      case "expression":
        return Loe(r);
      case "table":
        return Moe(r);
      case "folder":
        return Voe(r);
      case "image":
        return Poe(r);
      case "text":
        return Ooe(r);
      default:
        return r;
    }
  }
  function jg(r, e) {
    return r.hasOwnProperty("id") ? r.id + "" : e.generateId();
  }
  function Roe(r, e) {
    let t = { type: "expression", id: jg(r, e) };
    if (
      t.type = "expression",
        t.id = jg(r, e),
        r.hasOwnProperty("latex") && (t.latex = r.latex + ""),
        r.hasOwnProperty("color") && (t.color = r.color + ""),
        r.hasOwnProperty("points") && (t.points = !!r.points),
        r.hasOwnProperty("lines") && (t.lines = !!r.lines),
        r.hasOwnProperty("style") &&
        (__dcg_shared_module_exports__["qe"].warn(
          "As of API v1.1 the 'style' property is deprecated and has been split into 'pointStyle' and 'lineStyle'.",
        ),
          SP(r.style)
            ? t.pointStyle = r.style
            : EP(r.style)
            ? t.lineStyle = r.style
            : __dcg_shared_module_exports__["qe"].warn(
              "Invalid style: '" + r.style + "'.",
            )),
        r.hasOwnProperty("pointStyle") && (SP(r.pointStyle)
          ? t.pointStyle = r.pointStyle
          : __dcg_shared_module_exports__["qe"].warn(
            "Invalid pointStyle: '" + r.pointStyle + "'.",
          )),
        r.hasOwnProperty("pointSize") && (t.pointSize = "" + r.pointSize),
        r.hasOwnProperty("movablePointSize") &&
        (t.movablePointSize = "" + r.movablePointSize),
        r.hasOwnProperty("pointOpacity") &&
        (t.pointOpacity = "" + r.pointOpacity),
        r.hasOwnProperty("lineStyle") &&
        (EP(r.lineStyle)
          ? t.lineStyle = r.lineStyle
          : __dcg_shared_module_exports__["qe"].warn(
            "Invalid lineStyle: '" + r.lineStyle + "'.",
          )),
        r.hasOwnProperty("lineWidth") && (t.lineWidth = "" + r.lineWidth),
        r.hasOwnProperty("lineOpacity") &&
        (t.lineOpacity = "" + r.lineOpacity),
        r.hasOwnProperty("hidden") && (t.hidden = !!r.hidden),
        r.hasOwnProperty("readonly") && (t.readonly = !!r.readonly),
        r.hasOwnProperty("secret") && (t.secret = !!r.secret),
        r.hasOwnProperty("sliderBounds") && r.sliderBounds &&
        (t.slider = {
          min: __dcg_shared_module_exports__["be"](r.sliderBounds.min),
          max: __dcg_shared_module_exports__["be"](r.sliderBounds.max),
          step: __dcg_shared_module_exports__["be"](r.sliderBounds.step),
        },
          t.slider.min && (t.slider.hardMin = true),
          t.slider.max && (t.slider.hardMax = true)),
        r.hasOwnProperty("playing")
    ) {
      let { playing: o } = r;
      typeof o != "boolean"
        ? __dcg_shared_module_exports__["qe"].warn(
          `Invalid value for 'playing'. Expected a boolean but got '${o}'.`,
        )
        : (t.slider || (t.slider = {}), t.slider.isPlaying = o);
    }
    return r.hasOwnProperty("parametricDomain3Du") &&
      r.parametricDomain3Du &&
      (t.parametricDomain3Du = {
        min: __dcg_shared_module_exports__["be"](
          r.parametricDomain3Du.min,
        ),
        max: __dcg_shared_module_exports__["be"](
          r.parametricDomain3Du.max,
        ),
      }),
      r.hasOwnProperty("parametricDomain3Dv") && r.parametricDomain3Dv &&
      (t.parametricDomain3Dv = {
        min: __dcg_shared_module_exports__["be"](
          r.parametricDomain3Dv.min,
        ),
        max: __dcg_shared_module_exports__["be"](
          r.parametricDomain3Dv.max,
        ),
      }),
      r.hasOwnProperty("parametricDomain3Dr") && r.parametricDomain3Dr &&
      (t.parametricDomain3Dr = {
        min: __dcg_shared_module_exports__["be"](
          r.parametricDomain3Dr.min,
        ),
        max: __dcg_shared_module_exports__["be"](
          r.parametricDomain3Dr.max,
        ),
      }),
      r.hasOwnProperty("parametricDomain3Dphi") &&
      r.parametricDomain3Dphi &&
      (t.parametricDomain3Dphi = {
        min: __dcg_shared_module_exports__["be"](
          r.parametricDomain3Dphi.min,
        ),
        max: __dcg_shared_module_exports__["be"](
          r.parametricDomain3Dphi.max,
        ),
      }),
      r.hasOwnProperty("parametricDomain") && r.parametricDomain
        ? (t.parametricDomain = {
          min: __dcg_shared_module_exports__["be"](
            r.parametricDomain.min,
          ),
          max: __dcg_shared_module_exports__["be"](
            r.parametricDomain.max,
          ),
        },
          r.hasOwnProperty("domain") &&
          __dcg_shared_module_exports__["qe"].warn(
            "Both 'parametricDomain' and the deprecated 'domain' property were specified. Using 'parametricDomain'.",
          ))
        : r.hasOwnProperty("domain") &&
          (__dcg_shared_module_exports__["qe"].warn(
            "The 'domain' property is deprecated.Use 'parametricDomain' to specify the domain for parametric functions",
          ),
            t.parametricDomain = {
              min: __dcg_shared_module_exports__["be"](r.domain.min),
              max: __dcg_shared_module_exports__["be"](r.domain.max),
            }),
      r.hasOwnProperty("polarDomain") && r.polarDomain &&
      (t.polarDomain = {
        min: __dcg_shared_module_exports__["be"](r.polarDomain.min),
        max: __dcg_shared_module_exports__["be"](r.polarDomain.max),
      }),
      r.hasOwnProperty("dragMode") &&
      (oK(r.dragMode)
        ? t.dragMode = r.dragMode
        : __dcg_shared_module_exports__["qe"].warn(
          "Invalid dragMode: '" + r.dragMode + "'.",
        )),
      r.hasOwnProperty("label") && (t.label = r.label + ""),
      r.hasOwnProperty("showLabel") && (t.showLabel = !!r.showLabel),
      r.hasOwnProperty("showAngleLabel") &&
      (t.showAngleLabel = !!r.showAngleLabel),
      r.hasOwnProperty("labelSize") &&
      (typeof r.labelSize == "string"
        ? t.labelSize = r.labelSize
        : __dcg_shared_module_exports__["qe"].warn(
          "Invalid labelSize: " + r.labelSize,
        )),
      r.hasOwnProperty("labelOrientation") &&
      (Aoe(r.labelOrientation)
        ? t.labelOrientation = r.labelOrientation
        : __dcg_shared_module_exports__["qe"].warn(
          "Invalid labelOrientation: " + r.labelOrientation,
        )),
      r.hasOwnProperty("fill") && (t.fill = !!r.fill),
      r.hasOwnProperty("fillOpacity") &&
      (t.fillOpacity = "" + r.fillOpacity),
      t;
  }
  function Foe(r, e) {
    let t = { id: jg(r, e) };
    return r.hasOwnProperty("latex") && (t.latex = r.latex + ""),
      r.hasOwnProperty("color") && (t.color = r.color + ""),
      r.hasOwnProperty("hidden") && (t.hidden = !!r.hidden),
      r.hasOwnProperty("points") && (t.points = !!r.points),
      r.hasOwnProperty("lines") && (t.lines = !!r.lines),
      r.hasOwnProperty("values") && r.values &&
      (t.values = r.values.map((o) => o + "")),
      r.hasOwnProperty("pointStyle") &&
      (SP(r.pointStyle)
        ? t.pointStyle = r.pointStyle
        : __dcg_shared_module_exports__["qe"].warn(
          "Invalid pointStyle: '" + r.pointStyle + "'.",
        )),
      r.hasOwnProperty("pointSize") && (t.pointSize = "" + r.pointSize),
      r.hasOwnProperty("pointOpacity") &&
      (t.pointOpacity = "" + r.pointOpacity),
      r.hasOwnProperty("lineStyle") &&
      (EP(r.lineStyle)
        ? t.lineStyle = r.lineStyle
        : __dcg_shared_module_exports__["qe"].warn(
          "Invalid lineStyle: '" + r.lineStyle + "'.",
        )),
      r.hasOwnProperty("lineWidth") && (t.lineWidth = "" + r.lineWidth),
      r.hasOwnProperty("lineOpacity") &&
      (t.lineOpacity = "" + r.lineOpacity),
      r.hasOwnProperty("columnMode") &&
      (__dcg_shared_module_exports__["qe"].warn(
        "As of API v1.1 the 'columnMode' property is deprecated and has been split into individual 'points' and 'lines' properties.",
      ),
        r.columnMode === Sv.POINTS_AND_LINES
          ? (t.points = true, t.lines = true)
          : r.columnMode === Sv.LINES
          ? (t.points = false, t.lines = true)
          : (t.points = true, t.lines = false),
        t.lines && !t.points && r.hasOwnProperty("dragMode") &&
        r.dragMode !== "NONE" &&
        (__dcg_shared_module_exports__["qe"].warn(
          "A 'lines' value of true and 'points' value of false is only compatible with a dragMode of 'NONE'. Proceeding by setting 'points' to true.",
        ),
          t.points = true),
        Ioe(r.columnMode) &&
        __dcg_shared_module_exports__["qe"].warn(
          "Invalid columnMode: '" + r.columnMode + "'.",
        )),
      r.hasOwnProperty("dragMode") &&
      (oK(r.dragMode)
        ? t.dragMode = r.dragMode === "AUTO" ? "NONE" : r.dragMode
        : __dcg_shared_module_exports__["qe"].warn(
          "Invalid dragMode: '" + r.dragMode + "'.",
        )),
      t;
  }
  function Noe(r, e) {
    let t = { type: "table", id: jg(r, e) };
    return r.hasOwnProperty("columns") && r.columns &&
      (t.columns = r.columns.map((o) => Foe(o, e))),
      t;
  }
  function Boe(r, e) {
    let t = { type: "folder", id: jg(r, e) };
    return r.hasOwnProperty("hidden") && (t.hidden = !!r.hidden), t;
  }
  function rK(r, e) {
    let t = { type: "text", id: jg(r, e) };
    return r.hasOwnProperty("text") && (t.text = r.text),
      r.hasOwnProperty("secret") && (t.secret = !!r.secret),
      r.hasOwnProperty("readonly") && (t.readonly = !!r.readonly),
      t;
  }
  function Uoe(r, e) {
    let t = { type: "image", id: jg(r, e) };
    return r.hasOwnProperty("hidden") && (t.hidden = !!r.hidden), t;
  }
  function uD(r, e, t) {
    let o = r.type;
    if (e && o && o !== e) {
      __dcg_shared_module_exports__["qe"].warn(
        "Cannot change type of expression from '" + e + "' to '" + o +
          "'.",
      );
      return;
    }
    if (e === "text" && o === void 0) return rK(r, t);
    switch (o) {
      case void 0:
      case "expression":
        return Roe(r, t);
      case "image":
        return Uoe(r, t);
      case "table":
        return Noe(r, t);
      case "folder":
        return Boe(r, t);
      case "text":
        return rK(r, t);
      default:
        if (e) {
          __dcg_shared_module_exports__["qe"].warn(
            "Cannot modify expressions of type: '" + e +
              "' through the API.",
          );
          return;
        } else {
          __dcg_shared_module_exports__["qe"].warn(
            "Invalid expression type: '" + o + "'.",
          );
          return;
        }
    }
  }
  var hD = {};
  __dcg_shared_module_exports__["defineProperties"](hD, {
    LARGE: () => Hoe,
    MEDIUM: () => IP,
    SMALL: () => qoe,
    VERY_LARGE: () => Koe,
    VERY_SMALL: () => zoe,
  });
  var zoe = 9, qoe = 12, IP = 16, Hoe = 20, Koe = 24;
  Ss();
  var fi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var Sr = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Yt = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var $l = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var Op = class extends $l.Class {
    init() {
      this.controller = this.props.controller();
    }
    template() {
      return $l.createElement(
        "div",
        {
          class: $l.const("dcg-do-not-blur"),
          onTap: this.bindFn(this.newImage),
          handleEvent: $l.const("true"),
          role: $l.const("button"),
          tabIndex: () => this.props.readonly() ? -1 : 0,
          "aria-label": this.props.ariaLabel,
          "aria-disabled": () => this.props.readonly(),
          manageFocus: this.const(
            this.props.location
              ? rt({
                controller: this.controller,
                location: this.props.location(),
              })
              : void 0,
          ),
        },
        this.props.children,
        $l.createElement("input", {
          type: $l.const("file"),
          accept: $l.const("image/*"),
          style: $l.const("display: none"),
          didMount: this.bindFn(this.didMountFileInput),
        }),
      );
    }
    didMountFileInput(e) {
      this.fileInputNode = e,
        ee(e).on("change", () => {
          this.props.onFileChange(e.files), e.value = "";
        });
    }
    newImage() {
      this.props.readonly() || this.fileInputNode.click();
    }
  };
  var { If: iK, Switch: nK } = Yt.Components,
    gD = class extends Yt.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.id = this.model.id;
      }
      template() {
        return Yt.createElement(
          "div",
          {
            class: Yt.const("dcg-clickable-image-info-view"),
            role: Yt.const("region"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-narration-clickable-image-options",
              ),
          },
          Yt.createElement(
            "div",
            { class: Yt.const("dcg-clickable-image-state-container") },
            Yt.createElement(
              Le,
              {
                tooltip: () => this.tooltip("hovered"),
                gravity: this.const("s"),
              },
              Yt.createElement(
                Op,
                {
                  controller: () => this.controller,
                  ariaLabel: () => this.tooltip("hovered"),
                  onFileChange: (e) => this.updateImage("hovered", e),
                  readonly: () => this.controller.isItemReadonly(this.id),
                },
                Yt.createElement(nK, {
                  key: this.bindFn(this.hoveredStatus),
                }, () =>
                  Yt.createElement("div", {
                    class: Yt.const("dcg-clickable-image-state"),
                    style: () => this.getStyleForState("hovered"),
                  })),
              ),
            ),
            Yt.createElement(iK, {
              predicate: () => !!this.model.clickableInfo.hoveredImage,
            }, () =>
              Yt.createElement(
                "div",
                {
                  class: Yt.const("dcg-clickable-image-state-close"),
                  onTap: () => this.removeImageState("hovered"),
                  ariaLabel: () =>
                    this.controller.s(
                      "graphing-calculator-label-remove-hovered-image",
                    ),
                  role: Yt.const("button"),
                  tabIndex: Yt.const(0),
                },
                Yt.createElement("i", {
                  class: Yt.const("dcg-icon-remove"),
                  "aria-hidden": Yt.const("true"),
                }),
              )),
            Yt.createElement(
              "div",
              {
                role: Yt.const("heading"),
                "aria-level": Yt.const("2"),
                class: Yt.const("dcg-clickable-image-label"),
              },
              () => this.controller.s("graphing-calculator-label-hovered"),
            ),
          ),
          Yt.createElement(
            "div",
            { class: Yt.const("dcg-clickable-image-state-container") },
            Yt.createElement(
              Le,
              {
                tooltip: () => this.tooltip("depressed"),
                gravity: this.const("s"),
              },
              Yt.createElement(
                Op,
                {
                  controller: () => this.controller,
                  ariaLabel: () => this.tooltip("depressed"),
                  onFileChange: (e) => this.updateImage("depressed", e),
                  readonly: () => this.controller.isItemReadonly(this.id),
                },
                Yt.createElement(nK, {
                  key: this.bindFn(this.depressedStatus),
                }, () =>
                  Yt.createElement("div", {
                    class: Yt.const("dcg-clickable-image-state"),
                    style: () => this.getStyleForState("depressed"),
                  })),
              ),
            ),
            Yt.createElement(iK, {
              predicate: () => !!this.model.clickableInfo.depressedImage,
            }, () =>
              Yt.createElement(
                "div",
                {
                  class: Yt.const("dcg-clickable-image-state-close"),
                  onTap: () => this.removeImageState("depressed"),
                  ariaLabel: () =>
                    this.controller.s(
                      "graphing-calculator-label-remove-depressed-image",
                    ),
                  role: Yt.const("button"),
                  tabIndex: Yt.const(0),
                },
                Yt.createElement("i", {
                  class: Yt.const("dcg-icon-remove"),
                  "aria-hidden": Yt.const("true"),
                }),
              )),
            Yt.createElement(
              "div",
              {
                role: Yt.const("heading"),
                "aria-level": Yt.const("2"),
                class: Yt.const("dcg-clickable-image-label"),
              },
              () => this.controller.s("graphing-calculator-label-depressed"),
            ),
          ),
        );
      }
      hoveredStatus() {
        return this.hoveredUploading ? "loading" : "background";
      }
      depressedStatus() {
        return this.depressedUploading ? "loading" : "background";
      }
      tooltip(e) {
        return (e === "hovered"
            ? this.model.clickableInfo.hoveredImage
            : this.model.clickableInfo.depressedImage)
          ? e === "depressed"
            ? this.controller.s(
              "graphing-calculator-label-change-depressed-image-tooltip",
            )
            : this.controller.s(
              "graphing-calculator-label-change-hovered-image-tooltip",
            )
          : e === "depressed"
          ? this.controller.s(
            "graphing-calculator-label-add-depressed-image-tooltip",
          )
          : this.controller.s(
            "graphing-calculator-label-add-hovered-image-tooltip",
          );
      }
      getImageURLForState(e) {
        let t;
        if (e === "hovered") {
          if (this.hoveredStatus() !== "background") return "";
          t = "hoveredImage";
        } else {
          if (this.depressedStatus() !== "background") return "";
          t = "depressedImage";
        }
        let o = this.model.clickableInfo[t];
        return o ? `url(${o})` : `url(${this.model.image_url})`;
      }
      getStyleForState(e) {
        let t = {
          "background-image": this.getImageURLForState(e),
          opacity: "1",
        };
        return e === "hovered" &&
          !this.model.clickableInfo.hoveredImage && (t.opacity = "0.5"),
          t;
      }
      removeImageState(e) {
        e === "hovered"
          ? this.controller.dispatch({
            type: "set-hovered-image",
            id: this.model.id,
            url: "",
          })
          : this.controller.dispatch({
            type: "set-depressed-image",
            id: this.model.id,
            url: "",
          });
      }
      updateImage(e, t) {
        if (!t || !t[0]) return;
        let o = t[0];
        e === "hovered" && (this.hoveredUploading = true),
          e === "depressed" && (this.depressedUploading = true),
          this.controller.getGraphSettings().config.imageUploadCallback(
            o,
            (i, n) => {
              e === "hovered" && (this.hoveredUploading = false),
                e === "depressed" && (this.depressedUploading = false),
                !i && n && (e === "hovered"
                  ? this.controller.dispatch({
                    type: "set-hovered-image",
                    id: this.model.id,
                    url: n,
                  })
                  : this.controller.dispatch({
                    type: "set-depressed-image",
                    id: this.model.id,
                    url: n,
                  }));
            },
          );
      }
    };
  var Tc = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    go = class extends Tc.Class {
      template() {
        return Tc.createElement(
          "div",
          {
            class: () => ({
              "dcg-toggle-view": true,
              "dcg-toggled": this.props.toggled(),
            }),
            "aria-label": () => this.props.ariaLabel(),
            role: Tc.const("checkbox"),
            tabIndex: Tc.const("0"),
            "aria-checked": () => this.props.toggled(),
            toggled: () => this.props.toggled(),
            onTap: this.bindFn(this.props.onChange),
          },
          Tc.createElement(
            "div",
            { class: Tc.const("dcg-toggle-track") },
            Tc.createElement("div", {
              class: Tc.const("dcg-toggle-switch"),
            }),
          ),
        );
      }
    };
  var ls = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    mD = __dcg_shared_module_exports__["defineDefaultExport"](fK());
  var MP = /\{\$([a-zA-Z0-9\-]+([a-zA-Z0-9\-]+_)*[a-zA-Z0-9\-]+)\}/;
  function bK(r, e) {
    let t = 0, o = 0, i = {}, n = {}, a = s(r);
    if (!/^<0>/.test(a) || !/<\/0>$/.test(a)) {
      throw new Error(
        "Expected template string to start and end with <0> and </0>, but found " +
          JSON.stringify(a),
      );
    }
    return a.slice(3, -4).trim();
    function s(c) {
      if (e.isConst(c)) return Zoe(e.getConstValue(c));
      if (e.isNamedBinding(c)) {
        let d = l(i, e.getBindingName(c)), p = `{$${d}}`;
        if (!MP.test(p)) {
          throw new Error(`Invalid <Localize> variable: ${p}.`);
        }
        return e.addBinding && e.addBinding(d, c), i[d] = true, p;
      } else if (c !== r && e.isView(c)) {
        let d = l(n, e.getViewName(c));
        if (!/[a-zA-Z0-9\-_]/.test(d)) {
          throw new Error(`Invalid <Localize> subview identifier: ${d}.`);
        }
        return e.addView && e.addView(d, c), n[d] = true, `<${d}/>`;
      } else if (e.isBinding(c)) {
        let d = l(i, `v${t++}`), p = `{$${d}}`;
        return e.addBinding && e.addBinding(d, c), i[d] = true, p;
      } else {
        let d = `${o++}`;
        e.addElement && e.addElement(d, c);
        let p = [];
        return e.forEachChild(c, (h) => {
          p.push(s(h));
        }),
          n[d] = true,
          p.length > 0 ? `<${d}>${p.join("")}</${d}>` : `<${d}/>`;
      }
    }
    function l(c, d) {
      let p = 0, h = d;
      for (; c[h];) h = `${d}-${++p}`;
      return h;
    }
  }
  var Qoe = true;
  function Zoe(r) {
    return Qoe ? r : r.replace(/\{|\}/g, (e) => `{"${e}"}`).replace(
      /(^|[\s\n]+)(\[|\]|\.)/g,
      (e, t, o) => `${t}{"${o}"}`,
    );
  }
  function eie(r) {
    return r.__DCGViewLocalizeBindingName;
  }
  function tie(r) {
    return typeof r == "function" && r.__DCGViewLocalizeViewName;
  }
  var Oi = class extends ls.Class {
    init() {
      this.viewMap = {},
        this.elementMap = {},
        this.bindingMap = {},
        this.i18n = this.props.i18n(),
        this.templateString = this.serializeToTemplateString(
          ls.createElement("div", {
            style: ls.const("display: contents;"),
          }, this.props.children),
        );
    }
    template() {
      return ls.createElement(
        ls.Components.If,
        { predicate: () => this.shouldShow() },
        () =>
          ls.createElement(
            ls.Components.Switch,
            { key: () => GP(this.translatedString()) },
            (e) =>
              this.renderDeserializedTemplateNode(
                this.parseAndValidate(e),
              ),
          ),
      );
    }
    shouldShow() {
      let e = this.props.options && this.props.options();
      return e && e.hideUntranslatedView && this.i18n.hasTranslation
        ? this.i18n.hasTranslation(this.props.key())
        : true;
    }
    translatedString() {
      let e = {};
      for (let t in this.bindingMap) e[t] = Gs(`{$${t}}`);
      return this.i18n.s(this.props.key(), e);
    }
    static variable(e, t) {
      let o = () => t();
      return o.__DCGViewLocalizeBindingName = e, o;
    }
    static subview(e, t) {
      let o = () => t();
      return o.__DCGViewLocalizeViewName = e, o;
    }
    parseAndValidate(e) {
      let t = (0, mD.parse)(e), o = {}, i = {};
      n(t);
      for (let a in this.elementMap) {
        if (!i[a]) return (0, mD.parse)(GP(this.templateString));
      }
      for (let a in this.bindingMap) {
        if (!o[a]) return (0, mD.parse)(GP(this.templateString));
      }
      return t;
      function n(a) {
        if (Array.isArray(a)) {
          for (let s of a) n(s);
          return;
        }
        a.name === "token"
          ? o[a.attrs.id] = true
          : a.type !== "text" && (i[a.name] = true, n(a.children));
      }
    }
    renderDeserializedTemplateNode(e) {
      if (Array.isArray(e)) {
        return e.map((t) => this.renderDeserializedTemplateNode(t));
      }
      if (e.type === "text") return ls.const(e.content || "");
      if (e.name === "token") {
        let t = this.bindingMap[e.attrs.id];
        return t || (() => "");
      } else if (this.elementMap[e.name]) {
        let t = this.elementMap[e.name],
          o = e.children.map((i) => this.renderDeserializedTemplateNode(i));
        return xK(t.type, t.attributes, o);
      } else {return this.viewMap[e.name]
          ? this.viewMap[e.name]()
          : xK("span", {}, []);}
    }
    serializeToTemplateString(e) {
      return bK(e, {
        isView: tie,
        isConst: yK,
        isBinding: (t) => typeof t == "function",
        isNamedBinding: eie,
        getConstValue: (t) => t(),
        getBindingName: (t) => t.__DCGViewLocalizeBindingName,
        getViewName: (t) => t.__DCGViewLocalizeViewName,
        addBinding: (t, o) => {
          this.bindingMap[t] = o;
        },
        addElement: (t, o) => {
          this.elementMap[t] = {
            type: o.tagName,
            attributes: o.attributes,
          };
        },
        addView: (t, o) => {
          if (this.viewMap[t]) {
            throw new Error(`Unexpected duplicate view ${t}.`);
          }
          this.viewMap[t] = o;
        },
        forEachChild: (t, o) => {
          for (let i of t.children) {
            if (
              !yK(i) && typeof i != "function" && i instanceof ls.View
            ) {
              throw new Error(
                "Bare DCGViews are not allowed inside <Localize>. Use Localize.subview().",
              );
            }
            o(i);
          }
        },
      });
    }
  };
  function yK(r) {
    return typeof r == "function" && r.isDCGViewConst;
  }
  function xK(r, e, t) {
    return ls.createElement(r, e, t);
  }
  function GP(r) {
    return `<0>${r}</0>`.replace(
      new RegExp(MP.source, "g"),
      (t, o) => `<token id="${o}"/>`,
    );
  }
  function ki(r, e, t) {
    return rie(r, e) === t;
  }
  function rie(r, e) {
    let t = r.getFocusLocation();
    if (!(!t || t.type !== "expression-menu" || t.id !== e)) {
      return t.location;
    }
  }
  function _i(r, e, t, o) {
    let i = e;
    t
      ? r.dispatch({
        type: "set-focus-location",
        location: { type: "expression-menu", id: i, location: o },
      })
      : r.dispatch({
        type: "blur-focus-location",
        location: { type: "expression-menu", id: i, location: o },
      });
  }
  var { If: fD, IfDefined: oie, Textarea: iie } = Sr.Components,
    Zb = class extends Sr.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return Sr.createElement(
          "div",
          {
            class: Sr.const(
              "dcg-options-menu-section dcg-clickable-section",
            ),
          },
          Sr.createElement(
            "div",
            { class: Sr.const("dcg-options-menu-section-title") },
            () => this.controller.s("graphing-calculator-heading-clickable"),
            Sr.createElement(go, {
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-make-clickable",
                ),
              toggled: this.props.isOpen,
              onChange: this.bindFn(this.toggleClickable),
            }),
          ),
          Sr.createElement(
            fD,
            { predicate: this.props.isOpen },
            () =>
              Sr.createElement(
                "div",
                { class: Sr.const("dcg-options-menu-content") },
                Sr.createElement(
                  "div",
                  { class: Sr.const("dcg-clickable-menu-row") },
                  Sr.createElement("span", {
                    class: Sr.const("dcg-input-label"),
                  }, () =>
                    this.controller.s(
                      "graphing-calculator-label-update-on-click",
                    )),
                  Sr.createElement(
                    Mo,
                    {
                      latex: () => this.model.clickableInfo.latex,
                      operatorNames: () => this.getMQConfig().autoOperatorNames,
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-click-action",
                        ),
                      brailleShouldFocus: () =>
                        ki(this.controller, this.model.id, "updaterule"),
                      onBrailleInput: (e) =>
                        this.dispatchUpdateRuleLatexIfChanged(e),
                      onBrailleFocusedChanged: (e) =>
                        _i(
                          this.controller,
                          this.model.id,
                          e,
                          "updaterule",
                        ),
                      ...ui(this.controller),
                    },
                    Sr.createElement(Fe, {
                      latex: () => this.model.clickableInfo.latex,
                      placeholder: this.const(""),
                      isFocused: () =>
                        ki(this.controller, this.model.id, "updaterule"),
                      capExpressionSize: () =>
                        !!this.controller.getGraphSettings().config
                          .capExpressionSize,
                      tokenController: this.props.controller,
                      selectOnFocus: this.const(true),
                      config: this.bindFn(this.getMQConfig),
                      getAriaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-click-action",
                        ),
                      getAriaPostLabel: this.const(""),
                      hasError: () => this.hasError(),
                      onUserChangedLatex: (e) =>
                        this.dispatchUpdateRuleLatexIfChanged(e),
                      onExpressionSizeExceeded: () =>
                        this.controller.dispatch({
                          type: "expression-size-exceeded",
                        }),
                      onFocusedChanged: (e) =>
                        _i(
                          this.controller,
                          this.model.id,
                          e,
                          "updaterule",
                        ),
                      dataLabelAttributeValue: this.const(
                        "click-handler",
                      ),
                      needsSystemKeypad: () =>
                        !this.controller.isKeypadEnabled(),
                    }),
                  ),
                  oie(() => this.packedError(), (e) =>
                    Sr.createElement(
                      "span",
                      {
                        class: Sr.const(
                          "dcg-clickable-info-error-container",
                        ),
                      },
                      Sr.createElement(Di, {
                        error: () => this.controller.unpack(e()),
                        size: this.const("small"),
                      }),
                    )),
                ),
                Sr.createElement(fD, {
                  predicate: this.bindFn(this.isList),
                }, () =>
                  Sr.createElement(
                    "div",
                    {
                      class: Sr.const("dcg-clickable-list-index-notice"),
                    },
                    Sr.createElement(
                      Oi,
                      {
                        i18n: this.const(this.controller),
                        key: this.const(
                          "graphing-calculator-label-list-index",
                        ),
                      },
                      Sr.const("Use"),
                      Sr.const(" "),
                      Sr.createElement("span", {
                        class: () => ({
                          "dcg-index-variable-marker": true,
                          "dcg-btn": true,
                          "dcg-btn-light-gray": true,
                          "dcg-mathquill-has-focus": ki(
                            this.controller,
                            this.model.id,
                            "updaterule",
                          ),
                          "dcg-do-not-blur": true,
                        }),
                        onTap: this.bindFn(this.insertIndex),
                      }, Sr.const("index")),
                      Sr.const(" "),
                      Sr.const(
                        "to reference the clicked index in the list.",
                      ),
                    ),
                  )),
                Sr.createElement(fD, {
                  predicate: () => this.model.type !== "image",
                }, () =>
                  Sr.createElement(iie, {
                    placeholder: () =>
                      this.controller.s(
                        "graphing-calculator-text-add-screen-reader-label-placeholder",
                      ),
                    value: () => this.model.description,
                    onInput: (e) =>
                      this.controller.dispatch({
                        type: "set-item-description",
                        id: this.model.id,
                        description: e,
                      }),
                  })),
                Sr.createElement(fD, {
                  predicate: () => this.model.type === "image",
                }, () =>
                  Sr.createElement(
                    "div",
                    { class: Sr.const("dcg-clickable-menu-row") },
                    Sr.createElement(gD, {
                      controller: () => this.controller,
                      model: () => this.model,
                    }),
                  )),
              ),
          ),
        );
      }
      insertIndex() {
        this.controller.dispatch({
          type: "keypad/type-text",
          text: "index",
        });
      }
      isList() {
        return this.model.formula
          ? !!this.model.formula.is_concrete_list
          : false;
      }
      hasError() {
        return this.packedError() !== void 0;
      }
      packedError() {
        if (
          this.model.formula.click_handler &&
          this.model.formula.click_handler.status === "error"
        ) return this.model.formula.click_handler.error;
      }
      toggleClickable() {
        this.controller.dispatch({
          type: "set-clickableinfo-prop",
          id: this.model.id,
          prop: "enabled",
          value: !this.model.clickableInfo.enabled,
        }),
          this.model.clickableInfo.enabled &&
          _i(this.controller, this.model.id, true, "updaterule");
      }
      dispatchUpdateRuleLatexIfChanged(e) {
        this.model.clickableInfo.latex !== e &&
          this.controller.dispatch({
            type: "set-clickableinfo-rule-latex",
            id: this.model.id,
            latex: e,
          });
      }
      getMQConfig() {
        return this.controller.getMathquillConfig({
          additionalOperators: ["index"],
        });
      }
    };
  var Rp = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Er = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { For: wK, If: bD } = Er.Components,
    ey = class extends Er.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Er.createElement(
          "div",
          {
            class: Er.const("dcg-color-picker-container"),
            role: Er.const("group"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-narration-color-picker-label",
              ),
            onKeyDown: this.bindFn(this.handleKeydown),
          },
          Er.createElement(
            "div",
            {
              class: Er.const("dcg-color-picker-menu dcg-do-not-blur"),
              role: Er.const("listbox"),
              "aria-label": () =>
                this.controller.s(
                  "graphing-calculator-narration-color-picker-standard-colors-label",
                ),
            },
            Er.createElement(
              wK,
              { each: () => this.getColorValues() },
              (e) =>
                Er.createElement(
                  "div",
                  {
                    class: Er.const("dcg-color-tile"),
                    handleEvent: Er.const("true"),
                    role: Er.const("option"),
                    "aria-label": () => md(this.controller, e),
                    tabIndex: () =>
                      this.isSelected(e) || this.isFirstAndNoneSelected(e)
                        ? 0
                        : -1,
                    "aria-selected": () => this.isSelected(e),
                    manageFocus: () =>
                      rt({
                        controller: this.controller,
                        location: {
                          type: "color-picker-option",
                          category: "standard",
                          color: e,
                        },
                      }),
                    onTap: () => this.props.onColorSelected(e),
                  },
                  Er.createElement(Pp, {
                    color: () => ({ type: "single-color", value: e }),
                    invertSwatches: () => this.controller.invertSwatches(),
                  }),
                  Er.createElement(bD, {
                    predicate: () => this.isSelected(e),
                  }, () =>
                    Er.createElement("i", {
                      class: Er.const("dcg-icon-check"),
                      "aria-hidden": Er.const("true"),
                    })),
                ),
            ),
          ),
          Er.createElement(bD, {
            predicate: () => this.getUniqueCustomColors().length > 0,
          }, () =>
            Er.createElement(
              "div",
              {
                class: Er.const("dcg-color-picker-menu dcg-do-not-blur"),
                role: Er.const("listbox"),
                "aria-label": () =>
                  this.controller.s(
                    "graphing-calculator-narration-color-picker-custom-colors-label",
                  ),
              },
              Er.createElement(wK, {
                each: this.bindFn(this.getUniqueCustomColors),
                key: (e) => e.assignmentLatex,
              }, (e) =>
                Er.createElement(
                  Kb,
                  { tooltip: () => e.assignmentLatex },
                  Er.createElement(
                    "div",
                    {
                      class: Er.const("dcg-color-tile"),
                      handleEvent: Er.const("true"),
                      role: Er.const("option"),
                      "aria-label": () => {
                        let t = this.getColorValue(e);
                        return t.type === "single-color"
                          ? md(this.controller, t.value)
                          : Ao(e.assignmentLatex);
                      },
                      tabIndex: () =>
                        this.props.colorLatex() === e.assignmentLatex ? 0 : -1,
                      "aria-selected": () =>
                        this.props.colorLatex() === e.assignmentLatex,
                      manageFocus: () =>
                        rt({
                          controller: this.controller,
                          location: {
                            type: "color-picker-option",
                            category: "custom",
                            color: e.assignmentLatex,
                          },
                        }),
                      onTap: () =>
                        this.props.onCustomColorSelected(
                          e.assignmentLatex,
                        ),
                    },
                    Er.createElement(Pp, {
                      color: () => this.getColorValue(e),
                      invertSwatches: () => this.controller.invertSwatches(),
                    }),
                    Er.createElement(
                      bD,
                      {
                        predicate: () =>
                          this.props.colorLatex() === e.assignmentLatex,
                      },
                      () =>
                        Er.createElement("i", {
                          class: () => this.getCheckmarkClass(e),
                          "aria-hidden": Er.const("true"),
                        }),
                    ),
                    Er.createElement(
                      bD,
                      {
                        predicate: () => {
                          var t, o;
                          return ((o =
                              (t = this.props).customColorVisibility) ==
                              null
                            ? void 0
                            : o.call(t)) === "suppressed";
                        },
                      },
                      () =>
                        Er.createElement("i", {
                          class: Er.const("dcg-icon-lock"),
                        }),
                    ),
                  ),
                )),
            )),
        );
      }
      hideColorFunctions() {
        var e, t, o;
        return (o = (t = (e = this.props).hideColorFunctions) == null
            ? void 0
            : t.call(e)) != null
          ? o
          : false;
      }
      isFirstAndNoneSelected(e) {
        return e === this.getColorValues()[0] &&
          !this.props.selectedColor();
      }
      isSelected(e) {
        let t = this.props.colorLatex();
        return t &&
            __dcg_shared_module_exports__["m"](
                this.getUniqueCustomColors(),
                "assignmentLatex",
              ).indexOf(t) >= 0
          ? false
          : this.props.selectedColor() === e;
      }
      getColorValues() {
        return __dcg_shared_module_exports__["C"](
          this.controller.getColors(),
        );
      }
      getUniqueCustomColors() {
        if (
          this.props.customColorVisibility &&
          this.props.customColorVisibility() === "hidden"
        ) return [];
        let e = [];
        e.push(...this.controller.getAllColorAssignments()),
          this.hideColorFunctions() ||
          e.push(...this.controller.getAllColorFunctionAssignments());
        let t = __dcg_shared_module_exports__["r"](
          e,
          (o) => o.assignmentLatex,
        );
        return e.filter((o) => t[o.assignmentLatex] === 1);
      }
      getColorValue(e) {
        switch (e.id) {
          case "shader":
            return { type: e.id };
          default:
            let t = this.controller.getColorById(e.id);
            return Array.isArray(t)
              ? { type: "color-array", value: t }
              : /^data:image/.test(t)
              ? { type: "image", value: t }
              : { type: "single-color", value: t };
        }
      }
      getCheckmarkClass(e) {
        return qf(this.getColorValue(e), false)
          ? `dcg-icon-check ${
            _z(this.getColorValue(e), false)
              ? "dcg-light-color"
              : "dcg-mixed-color"
          }`
          : "dcg-icon-check";
      }
      handleKeydown(e) {
        let t = this.controller.getFocusLocation();
        if (
          (t == null ? void 0 : t.type) !== "color-picker-option" ||
          e.altKey || e.ctrlKey || e.metaKey || e.shiftKey
        ) return;
        let o = ke(e);
        if (
          o !== "Up" && o !== "Down" && o !== "Left" && o !== "Right" &&
          o !== "Home" && o !== "End"
        ) return;
        e.preventDefault(), e.stopPropagation();
        let i = this.getColorValues(),
          n = this.getUniqueCustomColors().map((d) => d.assignmentLatex),
          a = i.length,
          s = t.category === "standard"
            ? i.indexOf(t.color)
            : a + n.indexOf(t.color),
          l = s,
          c = i.length + n.length - 1;
        o === "Left" && (l = s - 1),
          o === "Right" && (l = s + 1),
          o === "Home" && (l = 0),
          o === "End" && (l = 1 / 0),
          o === "Up" && s - a >= 0 && (l = s - a),
          o === "Down" && s + a <= c && (l = s + a),
          l = __dcg_shared_module_exports__["clamp"](l, 0, c),
          l !== s &&
          (l < a
            ? (this.props.onColorSelected(i[l]),
              this.controller.dispatch({
                type: "set-focus-location",
                location: {
                  type: "color-picker-option",
                  category: "standard",
                  color: i[l],
                },
              }))
            : (this.props.onCustomColorSelected(n[l - a]),
              this.controller.dispatch({
                type: "set-focus-location",
                location: {
                  type: "color-picker-option",
                  category: "custom",
                  color: n[l - a],
                },
              })));
      }
    };
  var ih = class extends Rp.Class {
    init() {
      this.controller = this.props.controller(),
        this.model = this.props.model();
    }
    template() {
      return Rp.createElement(
        "div",
        { class: Rp.const("dcg-options-menu-section") },
        Rp.createElement(
          "div",
          { class: Rp.const("dcg-options-menu-content") },
          Rp.createElement(ey, {
            controller: this.props.controller,
            colorLatex: this.bindFn(this.getColorLatex),
            selectedColor: this.bindFn(this.getModelColor),
            onColorSelected: this.bindFn(this.onColorSelected),
            onCustomColorSelected: this.bindFn(
              this.onCustomColorSelected,
            ),
            hideColorFunctions: this.bindFn(this.hideColorFunctions),
            customColorVisibility: this.bindFn(
              this.customColorVisibility,
            ),
          }),
        ),
      );
    }
    hideColorFunctions() {
      return this.model.type !== "expression"
        ? false
        : Cb(this.model) || $u(this.model);
    }
    customColorVisibility() {
      return this.model.type === "expression" && sT(this.model) ||
          this.model.type === "table"
        ? "hidden"
        : "visible";
    }
    onColorSelected(e) {
      this.model.type !== "image" &&
        (this.model.type === "expression"
          ? this.controller.dispatch({
            type: "set-item-color",
            id: this.model.id,
            color: e,
          })
          : this.model.type === "table"
          ? this.controller.dispatch({
            type: "set-tableregression-color",
            color: e,
            tableId: this.model.id,
          })
          : this.controller.dispatch({
            type: "set-tablecolumn-color",
            color: e,
            tableId: this.model.table.id,
            columnId: this.model.id,
          }));
    }
    onCustomColorSelected(e) {
      this.model.type !== "image" &&
        (this.model.type === "expression"
          ? this.controller.dispatch({
            type: "set-item-colorlatex",
            id: this.model.id,
            colorLatex: e,
          })
          : this.model.type === "table-column" &&
            this.controller.dispatch({
              type: "set-tablecolumn-colorlatex",
              tableId: this.model.table.id,
              columnId: this.model.id,
              colorLatex: e,
            }));
    }
    getColorLatex() {
      var e, t;
      return this.model.type === "image"
        ? ""
        : this.model.type === "table"
        ? (t = (e = this.model.regression) == null ? void 0 : e.color) !=
            null
          ? t
          : ""
        : this.model.colorLatex;
    }
    getModelColor() {
      var e, t;
      return this.model.type === "image"
        ? ""
        : this.model.type === "table"
        ? (t = (e = this.model.regression) == null ? void 0 : e.color) !=
            null
          ? t
          : ""
        : Fu(this.model);
    }
  };
  var Yi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: nie, For: aie } = Yi.Components,
    ty = class extends Yi.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return Yi.createElement(
          "div",
          { class: Yi.const("dcg-options-menu-section") },
          Yi.createElement(
            "div",
            { class: Yi.const("dcg-options-menu-section-title") },
            () => this.controller.s("graphing-calculator-heading-drag"),
            Yi.createElement(go, {
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-menu-drag-enabled",
                ),
              toggled: this.props.isOpen,
              onChange: this.bindFn(this.toggleDragEnabled),
            }),
          ),
          Yi.createElement(
            nie,
            { predicate: this.props.isOpen },
            () =>
              Yi.createElement(
                "div",
                { class: Yi.const("dcg-options-menu-content") },
                Yi.createElement(
                  "div",
                  {
                    class: Yi.const("dcg-style-icons"),
                    role: Yi.const("radiogroup"),
                  },
                  Yi.createElement(
                    aie,
                    { each: () => ["X", "Y", "XY"] },
                    (e) =>
                      Yi.createElement(
                        "div",
                        {
                          class: () => ({
                            "dcg-style-icon-container": true,
                            "dcg-disabled": this.isDisabled(e),
                          }),
                          onTap: () => this.onDragModeSelected(e),
                          role: Yi.const("radio"),
                          tabIndex: () => this.isDisabled(e) ? -1 : 0,
                          "aria-label": () =>
                            e === "X"
                              ? this.controller.s(
                                "graphing-calculator-narration-drag-mode-x",
                              )
                              : e === "Y"
                              ? this.controller.s(
                                "graphing-calculator-narration-drag-mode-y",
                              )
                              : e === "XY"
                              ? this.controller.s(
                                "graphing-calculator-narration-drag-mode-xy",
                              )
                              : this.controller.raw(""),
                          "aria-checked": () => this.getDragMode() === e,
                        },
                        Yi.createElement($o, {
                          backgroundColor: () => ({
                            type: "single-color",
                            value: "#000",
                          }),
                          semiTransparent: () => this.getDragMode() !== e,
                          iconType: () =>
                            e === "X"
                              ? "movable-horizontal"
                              : e === "Y"
                              ? "movable-vertical"
                              : "movable-both",
                        }),
                      ),
                  ),
                ),
              ),
          ),
        );
      }
      isDisabled(e) {
        let t = this.controller.getEnabledDragModesForItem(this.model.id);
        return !__dcg_shared_module_exports__["l"](t, e);
      }
      onDragModeSelected(e) {
        if (this.model.type === "expression") {
          if (this.isDisabled(e)) return;
          this.controller.dispatch({
            type: "set-item-dragmode",
            id: this.model.id,
            dragMode: e,
          });
        } else {
          let t = this.model.id, o = this.model.table.id;
          this.controller.dispatch({
            type: "set-tablecolumn-dragmode",
            tableId: o,
            columnId: t,
            dragMode: e,
          });
        }
      }
      getDragMode() {
        return this.model.type === "expression"
          ? Ro(this.model) || this.model.dragMode
          : this.model.dragMode;
      }
      toggleDragEnabled() {
        let e = this.getDragMode() !== "NONE" ? "NONE" : "XY";
        this.model.type === "expression"
          ? this.controller.dispatch({
            type: "set-item-dragmode",
            id: this.model.id,
            dragMode: e,
          })
          : this.onDragModeSelected(e);
      }
    };
  var Ri = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: vK } = Ri.Components,
    yD = class extends Ri.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return Ri.createElement(
          "div",
          { class: Ri.const("dcg-options-menu-section") },
          Ri.createElement(
            "div",
            { class: Ri.const("dcg-options-menu-section-title") },
            () => this.controller.s("graphing-calculator-heading-fill"),
            Ri.createElement(vK, {
              predicate: () => !this.isInequality(),
            }, () =>
              Ri.createElement(go, {
                ariaLabel: () =>
                  this.controller.s(
                    "graphing-calculator-narration-fill-visible",
                  ),
                toggled: this.props.isOpen,
                onChange: this.bindFn(this.toggleFillVisible),
              })),
          ),
          Ri.createElement(
            vK,
            { predicate: this.props.isOpen },
            () =>
              Ri.createElement(
                "div",
                { class: Ri.const("dcg-options-menu-content") },
                Ri.createElement(
                  "div",
                  {
                    class: Ri.const(
                      "dcg-iconed-mathquill-row dcg-fill-opacity-row",
                    ),
                  },
                  Ri.createElement(
                    Le,
                    {
                      tooltip: () =>
                        this.controller.s(
                          "graphing-calculator-label-opacity-tooltip",
                        ),
                    },
                    Ri.createElement("i", {
                      class: Ri.const("dcg-icon-opacity"),
                      "aria-hidden": Ri.const("true"),
                    }),
                  ),
                  Ri.createElement(lr, {
                    latex: () => this.model.fillOpacity,
                    placeholder: this.bindFn(this.getFillOpacity),
                    isFocused: () =>
                      ki(this.controller, this.model.id, "opacity"),
                    ariaPostLabel: () =>
                      ML(this.model)
                        ? this.controller.raw("")
                        : this.controller.s(
                          "shared-calculator-narration-input-error",
                        ),
                    ariaLabel: () =>
                      this.controller.s(
                        "graphing-calculator-narration-fill-opacity",
                      ),
                    hasError: () => !ML(this.model),
                    handleLatexChanged: this.bindFn(
                      this.dispatchOpacityLatexIfChanged,
                    ),
                    dataLabelAttributeValue: this.const("fill-opacity"),
                    controller: this.props.controller,
                    readonly: () =>
                      this.controller.isItemReadonly(this.model.id),
                    handleFocusChanged: (e) =>
                      _i(this.controller, this.model.id, e, "opacity"),
                  }),
                ),
              ),
          ),
        );
      }
      getFillOpacity() {
        return "" + .4;
      }
      isInequality() {
        return wd(this.model);
      }
      toggleFillVisible() {
        this.controller.dispatch({
          type: "set-item-fill",
          id: this.model.id,
          fill: !this.props.isOpen(),
        });
      }
      dispatchOpacityLatexIfChanged(e) {
        this.model.fillOpacity !== e &&
          this.controller.dispatch({
            type: "set-item-fillopacity",
            id: this.model.id,
            fillOpacity: e,
          });
      }
    };
  var jl = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: lie } = jl.Components,
    nh = class extends jl.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return jl.createElement(
          lie,
          { predicate: () => this.isVisible() },
          () =>
            jl.createElement(
              "div",
              {
                class: jl.const(
                  "dcg-options-menu-section dcg-interactivity-section dcg-section-without-title",
                ),
              },
              jl.createElement(
                "div",
                { class: jl.const("dcg-options-menu-content") },
                jl.createElement(mt, {
                  checked: () => Ds(this.model),
                  onChange: () => this.toggleGraphInteractionsDisabled(),
                  ariaLabel: () =>
                    this.controller.s(
                      "graphing-calculator-label-disable-graph-interactions",
                    ),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-label-disable-graph-interactions",
                  )),
              ),
            ),
        );
      }
      isVisible() {
        return this.controller.shouldShowAuthorFeatures();
      }
      toggleGraphInteractionsDisabled() {
        this.model.type === "table-column"
          ? this.controller.dispatch({
            type: "set-tablecolumn-disable-graph-interactions",
            tableId: this.model.table.id,
            columnId: this.model.id,
            disableGraphInteractions: !Ds(this.model),
          })
          : this.controller.dispatch({
            type: "set-item-disable-graph-interactions",
            id: this.model.id,
            disableGraphInteractions: !Ds(this.model),
          });
      }
    };
  var Jt = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Qn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { For: cie } = Qn.Components,
    die = [{
      orientation: "default",
      cssClass: "dcg-label-orientation-center",
      description: "graphing-calculator-text-label-orientation-default",
    }, {
      orientation: "above",
      cssClass: "dcg-label-orientation-above",
      description: "graphing-calculator-text-label-orientation-above",
    }, {
      orientation: "above_right",
      cssClass: "dcg-label-orientation-above-right",
      description: "graphing-calculator-text-label-orientation-above-right",
    }, {
      orientation: "right",
      cssClass: "dcg-label-orientation-right",
      description: "graphing-calculator-text-label-orientation-right",
    }, {
      orientation: "below_right",
      cssClass: "dcg-label-orientation-below-right",
      description: "graphing-calculator-text-label-orientation-below-right",
    }, {
      orientation: "below",
      cssClass: "dcg-label-orientation-below",
      description: "graphing-calculator-text-label-orientation-below",
    }, {
      orientation: "below_left",
      cssClass: "dcg-label-orientation-below-left",
      description: "graphing-calculator-text-label-orientation-below-left",
    }, {
      orientation: "left",
      cssClass: "dcg-label-orientation-left",
      description: "graphing-calculator-text-label-orientation-left",
    }, {
      orientation: "above_left",
      cssClass: "dcg-label-orientation-above-left",
      description: "graphing-calculator-text-label-orientation-above-left",
    }],
    xD = class extends Qn.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.id = this.model.id;
      }
      template() {
        return Qn.createElement(
          "div",
          {
            class: Qn.const("dcg-label-orientation-view"),
            style: () => `transform: rotate(${this.getCSSRotationValue()});`,
          },
          Qn.createElement("span", {
            class: Qn.const("dcg-vertical-orientation-indicator"),
          }),
          Qn.createElement(
            "div",
            {
              class: Qn.const("dcg-label-orientations"),
              role: Qn.const("radiogroup"),
              "aria-label": () =>
                this.controller.s(
                  "graphing-calculator-heading-label-orientation",
                ),
            },
            Qn.createElement(cie, {
              each: () => die,
              key: (e) => e.orientation,
            }, (e) =>
              Qn.createElement(
                "div",
                {
                  class: () => ({
                    [e.cssClass]: true,
                    "dcg-orientation-option": true,
                    "dcg-selected": this.isSelected(e.orientation),
                    "dcg-orientation-disabled": this.isDisabled(
                      e.orientation,
                    ),
                  }),
                  role: Qn.const("radio"),
                  tabIndex: Qn.const("0"),
                  "aria-label": () => this.controller.s(e.description),
                  "aria-checked": () => this.getOrientation() === e.orientation,
                  onTap: () => this.onTapOrientation(e.orientation),
                },
                Qn.createElement("i", {
                  class: () => ({
                    "dcg-icon-chevron-left": e.orientation !== "default",
                  }),
                }),
              )),
          ),
        );
      }
      isDisabled(e) {
        return e !== "default"
          ? false
          : this.isPointVisible()
          ? true
          : this.model.labelOrientation === "default";
      }
      isSelected(e) {
        return e === "default" && e === this.model.labelOrientation
          ? !this.isPointVisible()
          : e === this.model.labelOrientation;
      }
      isPointVisible() {
        return this.model.hidden
          ? false
          : Ea(this.model)
          ? !this.model.hidden
          : this.model.points;
      }
      getCSSRotationValue() {
        let e = vH(this.model);
        return `${Array.isArray(e) ? 0 : e}rad`;
      }
      getOrientation() {
        return this.props.model().labelOrientation;
      }
      onTapOrientation(e) {
        e === this.getOrientation() && (e = "default"),
          this.controller.dispatch({
            type: "set-item-label-orientation",
            id: this.id,
            labelOrientation: e,
          });
      }
    };
  var Dc = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var ry = class extends Dc.Class {
    init() {
      this.controller = this.props.controller(),
        this.model = this.props.model();
    }
    template() {
      return Dc.createElement(
        "div",
        {
          class: Dc.const(
            "dcg-iconed-mathquill-row dcg-point-opacity-row",
          ),
        },
        Dc.createElement(
          Le,
          {
            tooltip: () =>
              this.controller.s(
                "graphing-calculator-label-opacity-tooltip",
              ),
          },
          Dc.createElement("i", {
            class: Dc.const("dcg-icon-opacity"),
            "aria-hidden": Dc.const("true"),
          }),
        ),
        Dc.createElement(lr, {
          latex: () => this.model.pointOpacity,
          placeholder: this.bindFn(this.getPointOpacityPlaceholder),
          isFocused: () => ki(this.controller, this.model.id, "pointopacity"),
          ariaPostLabel: () =>
            this.isPointOpacityValid()
              ? this.controller.raw("")
              : this.controller.s(
                "shared-calculator-narration-input-error",
              ),
          ariaLabel: () =>
            this.controller.s(
              "graphing-calculator-narration-line-opacity",
            ),
          hasError: () => !this.isPointOpacityValid(),
          handleLatexChanged: this.bindFn(
            this.dispatchPointOpacityLatexIfChanged,
          ),
          dataLabelAttributeValue: this.const("point-opacity"),
          controller: this.props.controller,
          readonly: () => this.controller.isItemReadonly(this.model.id),
          handleFocusChanged: (e) =>
            _i(this.controller, this.model.id, e, "pointopacity"),
        }),
      );
    }
    isPointOpacityValid() {
      return this.model.type === "expression"
        ? yH(this.model)
        : this.model.type === "table-column"
        ? ZU(this.model)
        : false;
    }
    dispatchPointOpacityLatexIfChanged(e) {
      this.model.pointOpacity !== e &&
        (this.model.type === "expression"
          ? this.controller.dispatch({
            type: "set-item-pointopacity",
            id: this.model.id,
            pointOpacity: e,
          })
          : this.controller.dispatch({
            type: "set-tablecolumn-pointopacity",
            columnId: this.model.id,
            tableId: this.model.table.id,
            pointOpacity: e,
          }));
    }
    getPointOpacityPlaceholder() {
      return `${1}`;
    }
  };
  var { If: Tv } = Jt.Components,
    wD = class extends Jt.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return Jt.createElement(
          "div",
          { class: Jt.const("dcg-options-menu-section") },
          Jt.createElement(
            "div",
            { class: Jt.const("dcg-options-menu-section-title") },
            () => this.controller.s("graphing-calculator-heading-label"),
            Jt.createElement(go, {
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-label-visible",
                ),
              toggled: this.props.isOpen,
              onChange: this.bindFn(this.toggleLabelVisible),
            }),
          ),
          Jt.createElement(
            Tv,
            { predicate: this.props.isOpen },
            () =>
              Jt.createElement(
                "div",
                { class: Jt.const("dcg-options-menu-content") },
                Jt.createElement(
                  "div",
                  { class: Jt.const("dcg-options-flex-container") },
                  Jt.createElement(
                    "div",
                    { class: Jt.const("dcg-options-left-side") },
                    Jt.createElement(Tv, {
                      predicate: this.props.showPointOpacity,
                    }, () => Jt.createElement(ry, { ...this.props })),
                    Jt.createElement(
                      "div",
                      {
                        class: Jt.const(
                          "dcg-iconed-mathquill-row dcg-label-size-row",
                        ),
                      },
                      Jt.createElement(
                        Le,
                        {
                          tooltip: () =>
                            this.controller.s(
                              "graphing-calculator-label-label-size-tooltip",
                            ),
                        },
                        Jt.createElement("span", {
                          class: Jt.const("dcg-font-size"),
                        }, Jt.const("A")),
                      ),
                      Jt.createElement(lr, {
                        latex: () => this.model.labelSize,
                        placeholder: () => "1",
                        isFocused: () =>
                          ki(this.controller, this.model.id, "labelsize"),
                        ariaPostLabel: () =>
                          LL(this.model)
                            ? this.controller.raw("")
                            : this.controller.s(
                              "shared-calculator-narration-input-error",
                            ),
                        ariaLabel: () =>
                          this.controller.s(
                            "graphing-calculator-narration-label-size",
                          ),
                        hasError: () => !LL(this.model),
                        handleLatexChanged: this.bindFn(
                          this.dispatchLabelSizeIfChanged,
                        ),
                        dataLabelAttributeValue: this.const("label-size"),
                        controller: this.props.controller,
                        readonly: () =>
                          this.controller.isItemReadonly(this.model.id),
                        handleFocusChanged: (e) =>
                          _i(
                            this.controller,
                            this.model.id,
                            e,
                            "labelsize",
                          ),
                      }),
                    ),
                    Jt.createElement(
                      "div",
                      {
                        class: () => ({
                          "dcg-iconed-mathquill-row": true,
                          "dcg-label-angle-row": true,
                          "dcg-suffix-degree":
                            this.props.controller().getGraphSettings()
                              .degreeMode,
                          "dcg-suffix-radian": !this.props.controller()
                            .getGraphSettings().degreeMode,
                        }),
                      },
                      Jt.createElement(
                        Le,
                        {
                          tooltip: () =>
                            this.controller.s(
                              "graphing-calculator-label-angle-tooltip",
                            ),
                        },
                        Jt.createElement("i", {
                          class: Jt.const("dcg-icon-angle"),
                          "aria-hidden": Jt.const("true"),
                        }),
                      ),
                      Jt.createElement(lr, {
                        latex: () => this.model.labelAngle,
                        placeholder: () => "0",
                        isFocused: () =>
                          ki(
                            this.controller,
                            this.model.id,
                            "labelangle",
                          ),
                        ariaPostLabel: () =>
                          PL(this.model)
                            ? this.controller.raw("")
                            : this.controller.s(
                              "shared-calculator-narration-input-error",
                            ),
                        ariaLabel: () =>
                          this.controller.s(
                            "graphing-calculator-narration-label-angle",
                          ),
                        hasError: () => !PL(this.model),
                        handleLatexChanged: this.bindFn(
                          this.dispatchLabelAngleIfChanged,
                        ),
                        dataLabelAttributeValue: this.const(
                          "label-angle",
                        ),
                        controller: this.props.controller,
                        readonly: () =>
                          this.controller.isItemReadonly(this.model.id),
                        handleFocusChanged: (e) =>
                          _i(
                            this.controller,
                            this.model.id,
                            e,
                            "labelangle",
                          ),
                      }),
                    ),
                  ),
                  Jt.createElement(
                    "div",
                    { class: Jt.const("dcg-options-right-side") },
                    Jt.createElement(xD, {
                      controller: () => this.controller,
                      model: () => this.model,
                    }),
                  ),
                ),
                Jt.createElement(Tv, {
                  predicate: () => this.controller.canUseAdvancedStyling(),
                }, () =>
                  Jt.createElement(
                    "div",
                    { class: Jt.const("dcg-label-advanced") },
                    Jt.createElement(mt, {
                      checked: this.bindFn(this.getWhiteTextOutline),
                      onChange: this.bindFn(this.setWhiteTextOutline),
                      disabled: () => this.getEditable(),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-button-label-text-outline",
                      )),
                    Jt.createElement(
                      "div",
                      {
                        role: Jt.const("region"),
                        "aria-label": () =>
                          this.controller.s(
                            "graphing-calculator-heading-advanced",
                          ),
                      },
                      Jt.createElement(Tv, {
                        predicate: () => this.shouldShowHoverLabelCheckbox(),
                      }, () =>
                        Jt.createElement(
                          mt,
                          {
                            checked: this.bindFn(
                              this.getInteractiveLabel,
                            ),
                            onChange: this.bindFn(
                              this.setInteractiveLabel,
                            ),
                          },
                          () =>
                            this.controller.s(
                              "graphing-calculator-button-label-show-on-hover",
                            ),
                        )),
                      Jt.createElement(
                        Tv,
                        {
                          predicate: this.bindFn(
                            this.shouldShowEditableLabelToggle,
                          ),
                        },
                        () =>
                          Jt.createElement(mt, {
                            checked: this.bindFn(this.getEditable),
                            onChange: this.bindFn(this.setEditable),
                          }, () =>
                            this.controller.s(
                              "graphing-calculator-button-label-editable",
                            )),
                      ),
                    ),
                  )),
              ),
          ),
        );
      }
      getWhiteTextOutline() {
        return this.getEditable() ? false : !this.model.suppressTextOutline;
      }
      setWhiteTextOutline(e) {
        this.controller.dispatch({
          type: "set-suppress-text-outline",
          id: this.model.id,
          suppressTextOutline: !e,
        });
      }
      setInteractiveLabel(e) {
        this.controller.dispatch({
          type: "set-item-interactive-label",
          id: this.model.id,
          interactiveLabel: e,
        });
      }
      getInteractiveLabel() {
        return !!this.model.interactiveLabel;
      }
      setEditable(e) {
        if (e) {
          let t = __dcg_shared_module_exports__["ie"](this.model.label) ===
              "latex"
            ? "MATH"
            : "TEXT";
          this.controller.dispatch({
            type: "set-item-editable-label-mode",
            id: this.model.id,
            editableLabelMode: t,
          });
        } else {this.controller.dispatch({
            type: "set-item-editable-label-mode",
            id: this.model.id,
            editableLabelMode: "NONE",
          });}
      }
      getEditable() {
        return this.model.editableLabelMode !== "NONE";
      }
      shouldShowEditableLabelToggle() {
        return Ea(this.model);
      }
      shouldShowHoverLabelCheckbox() {
        return Ro(this.model) === "NONE";
      }
      dispatchLabelAngleIfChanged(e) {
        this.model.labelAngle !== e &&
          this.controller.dispatch({
            type: "set-item-labelangle",
            id: this.model.id,
            labelAngle: e,
          });
      }
      dispatchLabelSizeIfChanged(e) {
        this.model.labelSize !== e &&
          this.controller.dispatch({
            type: "set-item-labelSize",
            id: this.model.id,
            labelSize: e,
          });
      }
      toggleLabelVisible() {
        this.controller.dispatch({
          type: "set-item-showlabel",
          id: this.model.id,
          showLabel: !this.props.isOpen(),
        });
      }
    };
  var zr = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: CK } = zr.Components,
    oy = class extends zr.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return zr.createElement(
          "div",
          { class: zr.const("dcg-options-menu-section") },
          zr.createElement(
            "div",
            { class: zr.const("dcg-options-menu-section-title") },
            () => this.controller.s("graphing-calculator-heading-lines"),
            zr.createElement(go, {
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-lines-visible",
                ),
              toggled: this.props.isOpen,
              onChange: this.bindFn(this.toggleLinesVisible),
            }),
          ),
          zr.createElement(
            CK,
            { predicate: () => this.props.isOpen() },
            () =>
              zr.createElement(
                "div",
                { class: zr.const("dcg-options-menu-content") },
                zr.createElement(
                  "div",
                  { class: zr.const("dcg-options-flex-container") },
                  zr.createElement(
                    "div",
                    { class: zr.const("dcg-options-left-side") },
                    zr.createElement(
                      "div",
                      {
                        class: zr.const(
                          "dcg-iconed-mathquill-row dcg-line-opacity-row",
                        ),
                      },
                      zr.createElement(
                        Le,
                        {
                          tooltip: () =>
                            this.controller.s(
                              "graphing-calculator-label-opacity-tooltip",
                            ),
                        },
                        zr.createElement("i", {
                          class: zr.const("dcg-icon-opacity"),
                          "aria-hidden": zr.const("true"),
                        }),
                      ),
                      zr.createElement(lr, {
                        latex: () => this.model.lineOpacity,
                        placeholder: this.bindFn(this.getLineOpacity),
                        isFocused: () =>
                          ki(
                            this.controller,
                            this.model.id,
                            "lineopacity",
                          ),
                        ariaPostLabel: () =>
                          this.isLineOpacityValid()
                            ? this.controller.raw("")
                            : this.controller.s(
                              "shared-calculator-narration-input-error",
                            ),
                        ariaLabel: () =>
                          this.controller.s(
                            "graphing-calculator-narration-line-opacity",
                          ),
                        hasError: () => !this.isLineOpacityValid(),
                        handleLatexChanged: this.bindFn(
                          this.dispatchLineOpacityLatexIfChanged,
                        ),
                        dataLabelAttributeValue: this.const(
                          "line-opacity",
                        ),
                        controller: this.props.controller,
                        readonly: () =>
                          this.controller.isItemReadonly(this.model.id),
                        handleFocusChanged: (e) =>
                          _i(
                            this.controller,
                            this.model.id,
                            e,
                            "lineopacity",
                          ),
                      }),
                    ),
                    zr.createElement(
                      "div",
                      {
                        class: zr.const(
                          "dcg-iconed-mathquill-row dcg-line-thickness-row",
                        ),
                      },
                      zr.createElement(
                        Le,
                        {
                          tooltip: () =>
                            this.controller.s(
                              "graphing-calculator-label-line-thickness-tooltip",
                            ),
                        },
                        zr.createElement("i", {
                          class: zr.const("dcg-icon-line-thickness"),
                          "aria-hidden": zr.const("true"),
                        }),
                      ),
                      zr.createElement(lr, {
                        latex: () => this.model.lineWidth,
                        placeholder: this.bindFn(this.getLineWidth),
                        isFocused: () =>
                          ki(this.controller, this.model.id, "linewidth"),
                        ariaPostLabel: () =>
                          this.isLineWidthValid()
                            ? this.controller.raw("")
                            : this.controller.s(
                              "shared-calculator-narration-input-error",
                            ),
                        ariaLabel: () =>
                          this.controller.s(
                            "graphing-calculator-label-line-thickness-tooltip",
                          ),
                        hasError: () => !this.isLineWidthValid(),
                        handleLatexChanged: this.bindFn(
                          this.dispatchLineWidthLatexIfChanged,
                        ),
                        dataLabelAttributeValue: this.const("line-width"),
                        controller: this.props.controller,
                        readonly: () =>
                          this.controller.isItemReadonly(this.model.id),
                        handleFocusChanged: (e) =>
                          _i(
                            this.controller,
                            this.model.id,
                            e,
                            "linewidth",
                          ),
                      }),
                    ),
                  ),
                  zr.createElement(
                    "div",
                    { class: zr.const("dcg-options-right-side") },
                    zr.createElement(CK, {
                      predicate: this.bindFn(this.shouldShowLineStyles),
                    }, () =>
                      zr.createElement(vo, {
                        staticConfig: this.bindFn(
                          this.getPointStyleOptions,
                        ),
                        ariaGroupLabel: () =>
                          this.controller.s(
                            "graphing-calculator-heading-style",
                          ),
                        theme: this.const("mini"),
                      })),
                  ),
                ),
              ),
          ),
        );
      }
      getLineWidth() {
        return "" + 2.5;
      }
      getLineOpacity() {
        return "" + 1;
      }
      getPointStyleOptions() {
        return ["SOLID", "DASHED", "DOTTED"].map((t) => ({
          key: t,
          icon: () => this.getStyleIcon(t),
          ariaLabel: () => this.getStyleAria(t),
          selected: () => this.model.lineStyle === t,
          class: () => "dcg-line-segmented-option",
          onSelect: () => {
            this.onLineStyleSelected(t);
          },
        }));
      }
      getStyleIcon(e) {
        switch (e) {
          case "SOLID":
            return "dcg-icon-line-solid";
          case "DASHED":
            return "dcg-icon-line-dashed";
          case "DOTTED":
            return "dcg-icon-line-dotted";
        }
      }
      getStyleAria(e) {
        let t = this.controller.s;
        switch (e) {
          case "SOLID":
            return t("graphing-calculator-narration-line-style-solid");
          case "DASHED":
            return t("graphing-calculator-narration-line-style-dashed");
          case "DOTTED":
            return t("graphing-calculator-narration-line-style-dotted");
        }
      }
      isLineOpacityValid() {
        return this.model.type === "expression"
          ? bH(this.model)
          : this.model.type === "table-column"
          ? XU(this.model)
          : false;
      }
      isLineWidthValid() {
        return this.model.type === "expression"
          ? yT(this.model)
          : this.model.type === "table-column"
          ? JU(this.model)
          : false;
      }
      dispatchLineOpacityLatexIfChanged(e) {
        this.model.lineOpacity !== e &&
          (this.model.type === "expression"
            ? this.controller.dispatch({
              type: "set-item-lineopacity",
              id: this.model.id,
              lineOpacity: e,
            })
            : this.controller.dispatch({
              type: "set-tablecolumn-lineopacity",
              tableId: this.model.table.id,
              columnId: this.model.id,
              lineOpacity: e,
            }));
      }
      shouldShowLineStyles() {
        return !(this.model.type === "expression" && wd(this.model));
      }
      onLineStyleSelected(e) {
        this.model.lineStyle !== e &&
          (this.model.type === "expression"
            ? this.controller.dispatch({
              type: "set-item-linestyle",
              id: this.model.id,
              lineStyle: e,
            })
            : this.controller.dispatch({
              type: "set-tablecolumn-linestyle",
              tableId: this.model.table.id,
              columnId: this.model.id,
              lineStyle: e,
            }));
      }
      dispatchLineWidthLatexIfChanged(e) {
        this.model.lineWidth !== e &&
          (this.model.type === "expression"
            ? this.controller.dispatch({
              type: "set-item-linewidth",
              id: this.model.id,
              lineWidth: e,
            })
            : this.controller.dispatch({
              type: "set-tablecolumn-linewidth",
              tableId: this.model.table.id,
              columnId: this.model.id,
              lineWidth: e,
            }));
      }
      toggleLinesVisible() {
        this.model.type === "expression"
          ? this.controller.dispatch({
            type: "set-item-lines",
            id: this.model.id,
            lines: !this.props.isOpen(),
          })
          : this.controller.dispatch({
            type: "set-tablecolumn-lines",
            tableId: this.model.table.id,
            columnId: this.model.id,
            bool: !this.props.isOpen(),
          });
      }
    };
  var Xi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: uie } = Xi.Components,
    CD = class extends Xi.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return Xi.createElement(
          "div",
          { class: Xi.const("dcg-options-menu-section") },
          Xi.createElement(
            "div",
            { class: Xi.const("dcg-options-menu-section-title") },
            () => this.controller.s("graphing-calculator-heading-lines"),
            Xi.createElement(go, {
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-lines-visible",
                ),
              toggled: this.props.isOpen,
              onChange: this.bindFn(this.toggleLinesVisible),
            }),
          ),
          Xi.createElement(
            uie,
            { predicate: () => this.props.isOpen() },
            () =>
              Xi.createElement(
                "div",
                { class: Xi.const("dcg-options-menu-content") },
                Xi.createElement(
                  "div",
                  {
                    class: Xi.const(
                      "dcg-iconed-mathquill-row dcg-line-thickness-row-3d",
                    ),
                  },
                  Xi.createElement(
                    Le,
                    {
                      tooltip: () =>
                        this.controller.s(
                          "graphing-calculator-label-line-thickness-3d-tooltip",
                        ),
                    },
                    Xi.createElement("i", {
                      class: Xi.const("dcg-icon-line-thickness"),
                      "aria-hidden": Xi.const("true"),
                    }),
                  ),
                  Xi.createElement(lr, {
                    latex: () => this.model.lineWidth,
                    placeholder: () => `${1}`,
                    isFocused: () =>
                      ki(this.controller, this.model.id, "linewidth"),
                    ariaPostLabel: () =>
                      this.isLineWidthValid()
                        ? this.controller.raw("")
                        : this.controller.s(
                          "shared-calculator-narration-input-error",
                        ),
                    ariaLabel: () =>
                      this.controller.s(
                        "graphing-calculator-label-line-thickness-3d-tooltip",
                      ),
                    hasError: () => !this.isLineWidthValid(),
                    handleLatexChanged: this.bindFn(
                      this.dispatchLineWidthLatexIfChanged,
                    ),
                    dataLabelAttributeValue: this.const("line-width"),
                    controller: this.props.controller,
                    readonly: () =>
                      this.controller.isItemReadonly(this.model.id),
                    handleFocusChanged: (e) =>
                      _i(this.controller, this.model.id, e, "linewidth"),
                  }),
                ),
              ),
          ),
        );
      }
      toggleLinesVisible() {
        this.controller.dispatch({
          type: "set-item-lines",
          id: this.model.id,
          lines: !this.props.isOpen(),
        });
      }
      isLineWidthValid() {
        return this.model.type === "expression" ? yT(this.model) : false;
      }
      dispatchLineWidthLatexIfChanged(e) {
        this.model.lineWidth !== e && this.model.type === "expression" &&
          this.controller.dispatch({
            type: "set-item-linewidth",
            id: this.model.id,
            lineWidth: e,
          });
      }
    };
  var mo = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: PP } = mo.Components,
    iy = class extends mo.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return mo.createElement(
          "div",
          { class: mo.const("dcg-options-menu-section") },
          mo.createElement(
            "div",
            { class: mo.const("dcg-options-menu-section-title") },
            () => this.controller.s("graphing-calculator-heading-points"),
            mo.createElement(go, {
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-points-visible",
                ),
              toggled: this.props.isOpen,
              onChange: this.bindFn(this.togglePointsVisible),
            }),
          ),
          mo.createElement(
            PP,
            { predicate: this.props.isOpen },
            () =>
              mo.createElement(
                "div",
                { class: mo.const("dcg-options-menu-content") },
                mo.createElement(
                  "div",
                  { class: mo.const("dcg-options-flex-container") },
                  mo.createElement(
                    "div",
                    { class: mo.const("dcg-options-left-side") },
                    mo.createElement(ry, { ...this.props }),
                    mo.createElement(PP, {
                      predicate: () =>
                        this.model.type === "expression" ||
                        !this.isDraggable(),
                    }, () =>
                      mo.createElement(
                        "div",
                        {
                          class: mo.const(
                            "dcg-iconed-mathquill-row dcg-point-size-row",
                          ),
                        },
                        mo.createElement(
                          Le,
                          {
                            tooltip: () =>
                              this.controller.s(
                                "graphing-calculator-label-point-size-tooltip",
                              ),
                          },
                          mo.createElement("i", {
                            class: mo.const("dcg-icon-line-thickness"),
                            "aria-hidden": mo.const("true"),
                          }),
                        ),
                        mo.createElement(lr, {
                          latex: this.bindFn(this.getPointSize),
                          placeholder: this.bindFn(
                            this.getDefaultPointSize,
                          ),
                          isFocused: () =>
                            ki(
                              this.controller,
                              this.model.id,
                              "pointsize",
                            ),
                          ariaPostLabel: () =>
                            this.isPointSizeValid()
                              ? this.controller.raw("")
                              : this.controller.s(
                                "shared-calculator-narration-input-error",
                              ),
                          ariaLabel: () =>
                            this.controller.s(
                              "graphing-calculator-narration-point-size",
                            ),
                          hasError: () => !this.isPointSizeValid(),
                          handleLatexChanged: (e) =>
                            this.dispatchPointSizeLatexIfChanged(e),
                          dataLabelAttributeValue: this.const(
                            "point-size",
                          ),
                          controller: this.props.controller,
                          readonly: () =>
                            this.controller.isItemReadonly(this.model.id),
                          handleFocusChanged: (e) =>
                            _i(
                              this.controller,
                              this.model.id,
                              e,
                              "pointsize",
                            ),
                        }),
                      )),
                  ),
                  mo.createElement(
                    "div",
                    { class: mo.const("dcg-options-right-side") },
                    mo.createElement(PP, {
                      predicate: () => !this.isDraggable(),
                    }, () =>
                      mo.createElement(vo, {
                        staticConfig: this.bindFn(
                          this.getPointStyleOptions,
                        ),
                        ariaGroupLabel: () =>
                          this.controller.s(
                            "graphing-calculator-heading-style",
                          ),
                        theme: this.const("mini"),
                      })),
                  ),
                ),
              ),
          ),
        );
      }
      getPointSize() {
        return this.isDraggable() && this.model.type === "expression"
          ? this.model.movablePointSize
          : this.model.pointSize;
      }
      getPointStyleOptions() {
        return ["POINT", "OPEN", "CROSS"].map((t) => ({
          key: t,
          icon: () => this.getStyleIcon(t),
          ariaLabel: () => this.getStyleAria(t),
          selected: () => this.model.pointStyle === t,
          class: () => "dcg-point-segmented-option",
          onSelect: () => {
            this.onPointStyleSelected(t);
          },
        }));
      }
      getStyleIcon(e) {
        switch (e) {
          case "POINT":
            return "dcg-icon-point";
          case "OPEN":
            return "dcg-icon-open";
          case "CROSS":
            return "dcg-icon-cross";
        }
      }
      getStyleAria(e) {
        let t = this.controller.s;
        switch (e) {
          case "POINT":
            return t("graphing-calculator-narration-point-style-point");
          case "OPEN":
            return t("graphing-calculator-narration-point-style-open");
          case "CROSS":
            return t("graphing-calculator-narration-point-style-cross");
        }
      }
      isPointSizeValid() {
        return this.model.type === "expression"
          ? this.isDraggable() ? xH(this.model) : bT(this.model)
          : this.model.type === "table-column"
          ? QU(this.model)
          : false;
      }
      onPointStyleSelected(e) {
        this.model.pointStyle !== e &&
          (this.model.type === "expression"
            ? this.controller.dispatch({
              type: "set-item-pointstyle",
              id: this.model.id,
              pointStyle: e,
            })
            : this.controller.dispatch({
              type: "set-tablecolumn-pointstyle",
              columnId: this.model.id,
              tableId: this.model.table.id,
              pointStyle: e,
            }));
      }
      dispatchPointSizeLatexIfChanged(e) {
        this.getPointSize() !== e &&
          (this.model.type === "expression"
            ? this.controller.dispatch({
              type: "set-item-pointsize",
              id: this.model.id,
              pointSize: e,
            })
            : this.controller.dispatch({
              type: "set-tablecolumn-pointsize",
              columnId: this.model.id,
              tableId: this.model.table.id,
              pointSize: e,
            }));
      }
      isDraggable() {
        return this.getDragMode() !== "NONE";
      }
      togglePointsVisible() {
        this.model.type === "expression" && Ea(this.model)
          ? this.controller.dispatch({
            type: "toggle-item-hidden",
            id: this.model.id,
          })
          : this.model.type === "expression"
          ? this.controller.dispatch({
            type: "set-item-points",
            id: this.model.id,
            points: !this.props.isOpen(),
          })
          : this.controller.dispatch({
            type: "set-tablecolumn-points",
            columnId: this.model.id,
            tableId: this.model.table.id,
            bool: !this.props.isOpen(),
          });
      }
      getDragMode() {
        return this.model.type === "expression"
          ? Ro(this.model) || this.model.dragMode
          : this.model.dragMode;
      }
      getDefaultPointSize() {
        return this.model.type === "expression" && kp(this.model)
          ? `${14}`
          : `${8}`;
      }
    };
  var Ji = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: mie } = Ji.Components,
    SD = class extends Ji.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return Ji.createElement(
          "div",
          { class: Ji.const("dcg-options-menu-section") },
          Ji.createElement(
            "div",
            { class: Ji.const("dcg-options-menu-section-title") },
            () => this.controller.s("graphing-calculator-heading-points"),
            Ji.createElement(go, {
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-points-visible",
                ),
              toggled: this.props.isOpen,
              onChange: this.bindFn(this.togglePointsVisible),
            }),
          ),
          Ji.createElement(
            mie,
            { predicate: () => this.props.isOpen() },
            () =>
              Ji.createElement(
                "div",
                { class: Ji.const("dcg-options-menu-content") },
                Ji.createElement(
                  "div",
                  {
                    class: Ji.const(
                      "dcg-iconed-mathquill-row dcg-line-thickness-row-3d",
                    ),
                  },
                  Ji.createElement(
                    Le,
                    {
                      tooltip: () =>
                        this.controller.s(
                          "graphing-calculator-label-point-size-3d-tooltip",
                        ),
                    },
                    Ji.createElement("i", {
                      class: Ji.const("dcg-icon-line-thickness"),
                      "aria-hidden": Ji.const("true"),
                    }),
                  ),
                  Ji.createElement(lr, {
                    latex: () => this.model.pointSize,
                    placeholder: this.bindFn(this.getDefaultPointSize),
                    isFocused: () =>
                      ki(this.controller, this.model.id, "pointsize"),
                    ariaPostLabel: () =>
                      this.isPointSizeValid()
                        ? this.controller.raw("")
                        : this.controller.s(
                          "shared-calculator-narration-input-error",
                        ),
                    ariaLabel: () =>
                      this.controller.s(
                        "graphing-calculator-narration-point-size",
                      ),
                    hasError: () => !this.isPointSizeValid(),
                    handleLatexChanged: (e) =>
                      this.dispatchPointSizeLatexIfChanged(e),
                    dataLabelAttributeValue: this.const("point-size"),
                    controller: this.props.controller,
                    readonly: () =>
                      this.controller.isItemReadonly(this.model.id),
                    handleFocusChanged: (e) =>
                      _i(this.controller, this.model.id, e, "pointsize"),
                  }),
                ),
              ),
          ),
        );
      }
      togglePointsVisible() {
        this.controller.dispatch({
          type: "set-item-points",
          id: this.model.id,
          points: !this.props.isOpen(),
        });
      }
      isPointSizeValid() {
        return this.model.type === "expression" ? bT(this.model) : false;
      }
      dispatchPointSizeLatexIfChanged(e) {
        this.model.pointSize !== e && this.model.type === "expression" &&
          this.controller.dispatch({
            type: "set-item-pointsize",
            id: this.model.id,
            pointSize: e,
          });
      }
      getDefaultPointSize() {
        return `${3}`;
      }
    };
  var jo = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: VP } = jo.Components,
    ED = class extends jo.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return jo.createElement(
          "div",
          { class: jo.const("dcg-options-menu-section") },
          jo.createElement(
            "div",
            { class: jo.const("dcg-options-menu-section-title") },
            () => this.controller.s("graphing-calculator-heading-surfaces"),
            jo.createElement(go, {
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-surfaces-visible",
                ),
              toggled: this.props.isOpen,
              onChange: this.bindFn(this.toggleSurfacesVisible),
            }),
          ),
          jo.createElement(
            VP,
            { predicate: () => this.props.isOpen() },
            () =>
              jo.createElement(
                "div",
                { style: jo.const("font-size:85%; margin-top:8px") },
                jo.createElement(VP, {
                  predicate: () =>
                    this.usesResolution() &&
                    this.controller.getGraphSettings().config.beta3d,
                }, () =>
                  jo.createElement(
                    "div",
                    null,
                    jo.const("Resolution:"),
                    jo.createElement(lr, {
                      latex: () => this.model.resolution,
                      placeholder: () => this.getDefaultResolution(),
                      isFocused: () =>
                        ki(this.controller, this.model.id, "resolution"),
                      ariaPostLabel: () =>
                        this.isResolutionValid()
                          ? this.controller.raw("")
                          : this.controller.s(
                            "shared-calculator-narration-input-error",
                          ),
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-label-resolution-tooltip",
                        ),
                      hasError: () => !this.isResolutionValid(),
                      handleLatexChanged: this.bindFn(
                        this.dispatchResolutionLatexIfChanged,
                      ),
                      dataLabelAttributeValue: this.const("resolution"),
                      controller: this.props.controller,
                      readonly: () =>
                        this.controller.isItemReadonly(this.model.id),
                      handleFocusChanged: (e) =>
                        _i(
                          this.controller,
                          this.model.id,
                          e,
                          "resolution",
                        ),
                    }),
                  )),
                jo.createElement(VP, {
                  predicate: this.bindFn(this.shouldShowOpacity),
                }, () =>
                  jo.createElement(
                    "div",
                    {
                      class: jo.const(
                        "dcg-iconed-mathquill-row dcg-surface-opacity-row",
                      ),
                    },
                    jo.createElement(
                      Le,
                      {
                        tooltip: () =>
                          this.controller.s(
                            "graphing-calculator-label-opacity-tooltip",
                          ),
                        sticky: this.const(true),
                        gravity: this.const("s"),
                      },
                      jo.createElement("i", {
                        class: jo.const("dcg-icon-opacity"),
                        "aria-hidden": jo.const("true"),
                      }),
                    ),
                    jo.createElement(lr, {
                      latex: () => this.model.surfaceOpacity,
                      isFocused: () =>
                        ki(this.controller, this.model.id, "opacity"),
                      placeholder: this.const("1"),
                      ariaPostLabel: () =>
                        GL(this.model)
                          ? this.controller.raw("")
                          : this.controller.s(
                            "shared-calculator-narration-input-error",
                          ),
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-surface-opacity",
                        ),
                      hasError: () => !GL(this.model),
                      handleLatexChanged: this.bindFn(
                        this.dispatchOpacityLatexIfChanged,
                      ),
                      dataLabelAttributeValue: this.const(
                        "surface-opacity",
                      ),
                      controller: this.props.controller,
                      readonly: () =>
                        this.controller.isItemReadonly(this.model.id),
                      handleFocusChanged: (e) =>
                        _i(this.controller, this.model.id, e, "opacity"),
                    }),
                  )),
              ),
          ),
        );
      }
      shouldShowOpacity() {
        return this.controller.getGraphSettings().config.beta3d
          ? this.model.formula.is_inequality !== true
          : false;
      }
      toggleSurfacesVisible() {
        this.controller.dispatch({
          type: "set-item-lines",
          id: this.model.id,
          lines: !this.props.isOpen(),
        });
      }
      usesResolution() {
        return !lT(this.model) && !lH(this.model);
      }
      dispatchResolutionLatexIfChanged(e) {
        this.model.resolution !== e && this.model.type === "expression" &&
          this.controller.dispatch({
            type: "set-item-resolution",
            id: this.model.id,
            resolution: e,
          });
      }
      isResolutionValid() {
        return this.model.type === "expression" ? wH(this.model) : false;
      }
      getDefaultResolution() {
        return this.model.type === "expression" && cH(this.model)
          ? `${__dcg_shared_module_exports__["kd"]}`
          : `${__dcg_shared_module_exports__["ld"]}`;
      }
      dispatchOpacityLatexIfChanged(e) {
        this.model.surfaceOpacity !== e &&
          this.controller.dispatch({
            type: "set-item-surfaceopacity",
            id: this.model.id,
            surfaceOpacity: e,
          });
      }
    };
  var { For: fie, If: bie } = fi.Components;
  function Vs(r, e) {
    e.runAfterDispatch(() => {
      if (!r) return;
      let t = r.closest(".dcg-options-menu-container"),
        o = e.findEl(".dcg-container"),
        i = e.getOpenMenuIcon(),
        n = !!r.closest(".dcg-table-column-menu");
      if (!t || !o || !i) return;
      let a = e.computeMajorLayout(),
        s = a.list.top + a.list.height,
        l = a.keypad.top,
        c = Math.min(s, l),
        d = o.getBoundingClientRect(),
        p = i.getBoundingClientRect(),
        h = c + d.top - p.top,
        u = t.offsetHeight,
        f = 0;
      u > h && (f = +h - u);
      let y = n ? !f : -f < u - 38;
      t.style.marginTop = `${n && f < 0 ? f - 34 : f}px`,
        r.style.marginTop = `${-f}px`,
        r.style.display = y ? "" : "none";
    });
  }
  function Fp(r, e) {
    requestAnimationFrame(() => {
      let t = e.getExppanelElt(), o = e.getOpenMenuIcon();
      r && t && o && t.contains(o) && ee(t).on(`scroll.${r}`, () => {
        ee(t).off(`scroll.${r}`);
        let i = e.getFocusLocation(), n = e.getOpenItemMenu();
        i && n && i.type === "expression-menu" && "model" in n &&
        i.id === n.model.id &&
        e.dispatch({ type: "blur-focus-location", location: i }),
          e.dispatch({ type: "close-item-settings-menu" });
      });
    });
  }
  function Np(r, e) {
    let t = e.getExppanelElt();
    t && r && ee(t).off(`scroll.${r}`);
  }
  var ny = class extends fi.Class {
    init() {
      var e;
      this.controller = this.props.controller(),
        this.guid = (e = this.controller.getOpenItemMenu()) == null
          ? void 0
          : e.guid;
    }
    didMount() {
      Fp(this.guid, this.controller);
    }
    willUnmount() {
      Np(this.guid, this.controller);
    }
    didUpdate() {
      Vs(this.arrowElt, this.controller);
    }
    template() {
      let e = this.props.model();
      return fi.createElement(
        "div",
        {
          class: () => ({
            "dcg-expressions-options-menu": true,
            "dcg-options-menu": true,
          }),
          role: fi.const("region"),
          "aria-label": () =>
            this.controller.s(
              "graphing-calculator-narration-options-menu",
            ),
        },
        fi.createElement(
          "div",
          null,
          fi.createElement(fie, {
            each: this.bindFn(this.getSectionsWithColorAfterFirstOpen),
          }, (t) => {
            switch (t) {
              case "points":
                return fi.createElement(iy, {
                  model: () => e,
                  controller: this.bindFn(this.props.controller),
                  isOpen: () => this.isSectionOpen("points"),
                });
              case "label":
                return fi.createElement(wD, {
                  model: () => e,
                  controller: this.bindFn(this.props.controller),
                  isOpen: () => this.isSectionOpen("label"),
                  showPointOpacity: () => this.isFirstOpenSection("label"),
                });
              case "drag":
                return fi.createElement(ty, {
                  model: () => e,
                  controller: this.bindFn(this.props.controller),
                  isOpen: () => this.isSectionOpen("drag"),
                });
              case "lines":
                return fi.createElement(oy, {
                  model: () => e,
                  controller: this.bindFn(this.props.controller),
                  isOpen: () => this.isSectionOpen("lines"),
                });
              case "fill":
                return fi.createElement(yD, {
                  model: () => e,
                  controller: this.bindFn(this.props.controller),
                  isOpen: () => this.isSectionOpen("fill"),
                });
              case "colors":
                return fi.createElement(ih, {
                  model: () => e,
                  controller: this.bindFn(this.props.controller),
                });
              case "points3d":
                return fi.createElement(SD, {
                  model: () => e,
                  controller: this.bindFn(this.props.controller),
                  isOpen: () => this.isSectionOpen("points3d"),
                });
              case "lines3d":
                return fi.createElement(CD, {
                  model: () => e,
                  controller: this.bindFn(this.props.controller),
                  isOpen: () => this.isSectionOpen("lines3d"),
                });
              case "surfaces":
                return fi.createElement(ED, {
                  model: () => e,
                  controller: this.bindFn(this.props.controller),
                  isOpen: () => this.isSectionOpen("surfaces"),
                });
            }
          }),
        ),
        fi.createElement(bie, {
          predicate: this.bindFn(this.shouldShowClickableSection),
        }, () =>
          fi.createElement(Zb, {
            model: () => e,
            controller: this.bindFn(this.props.controller),
            isOpen: () => !!e.clickableInfo.enabled,
          })),
        fi.createElement(nh, {
          model: () => e,
          controller: () => this.props.controller(),
        }),
        fi.createElement("div", {
          class: fi.const("dcg-triangle"),
          didMount: this.bindFn(this.didMountArrow),
          didUnmount: () => this.arrowElt = void 0,
        }),
      );
    }
    didMountArrow(e) {
      this.arrowElt = e, Vs(this.arrowElt, this.controller);
    }
    shouldShowClickableSection() {
      let e = this.props.model();
      return this.controller.areActionsEnabled() && OL(e) &&
        !this.controller.isItemReadonly(e.id) &&
        (this.controller.shouldShowAuthorFeatures() || !Ds(e));
    }
    shouldShowDragSection() {
      let e = this.props.model();
      return this.controller.shouldShowAuthorFeatures() || !Ds(e);
    }
    getSectionsWithColorAfterFirstOpen() {
      let e = this.getSections(), t = [], o = false;
      for (let i of e) {
        t.push(i),
          i === "colors" && (o = true),
          !o && this.canColorComeAfterSection(i) &&
          this.isSectionOpen(i) && (t.push("colors"), o = true);
      }
      return t;
    }
    getSections() {
      let e = this.props.model();
      if (this.controller.isThreeDMode()) {
        if (cT(e)) return e.extendTo3D ? ["surfaces"] : ["lines3d"];
        if (TL(e)) return ["surfaces"];
        if (Gg(e) || EL(e) || hH(e) || kL(e) || _L(e)) return ["lines3d"];
        if (Ea(e) || Cb(e)) return ["points3d"];
        if (Lg(e) || $u(e)) return ["points3d", "lines3d"];
      }
      return Pg(e) || ju(e) || sT(e) || uH(e) || zu(e)
        ? ["colors"]
        : _p(e)
        ? ["lines"]
        : kp(e)
        ? ["points"]
        : Lg(e)
        ? ["points", "label", "lines"]
        : Ea(e)
        ? e.formula.move_strategy && this.shouldShowDragSection()
          ? ["points", "label", "drag"]
          : ["points", "label"]
        : Gg(e) || pb(e)
        ? ["lines", "fill"]
        : wd(e)
        ? Sb(e) || dT(e) || DL(e) ? ["lines"] : ["lines", "fill"]
        : ["lines"];
    }
    canColorComeAfterSection(e) {
      switch (e) {
        case "colors":
        case "drag":
          return false;
        case "fill":
        case "label":
        case "lines":
        case "lines3d":
        case "points":
        case "points3d":
        case "surfaces":
          return true;
        default:
          return e;
      }
    }
    isFirstOpenSection(e) {
      return this.getSections().find((t) => this.isSectionOpen(t)) === e;
    }
    isSectionOpen(e) {
      let t = this.props.model(),
        { points: o, lines: i, fill: n } = t,
        a = __dcg_shared_module_exports__["Zc"](
          t.formula.expression_type,
          { points: o, lines: i, fill: n },
          (s) => {
            So("getReconciledExpressionProps [Chrome Switch Bug]", {
              metaData: { method: "isSectionOpen", type: s },
            });
          },
        );
      switch (e) {
        case "lines":
          return t.hidden ? false : a.lines;
        case "label":
          return ja(t);
        case "fill":
          return t.hidden ? false : wd(t) ? true : a.fill;
        case "points":
          return t.hidden ? false : Ea(t) ? !t.hidden : a.points;
        case "drag":
          return Ro(t) !== "NONE";
        case "colors":
          return true;
        case "points3d":
          return t.hidden ? false : a.points;
        case "lines3d":
        case "surfaces":
          return t.hidden ? false : a.lines;
      }
    }
  };
  var OP = {
      showGrid: true,
      showXAxis: true,
      showYAxis: true,
      xAxisStep: 0,
      yAxisStep: 0,
      xAxisScale: "linear",
      yAxisScale: "linear",
      xAxisMinorSubdivisions: 0,
      yAxisMinorSubdivisions: 0,
      xAxisArrowMode: "NONE",
      yAxisArrowMode: "NONE",
      xAxisLabel: "",
      yAxisLabel: "",
      xAxisNumbers: true,
      yAxisNumbers: true,
      polarMode: false,
      polarNumbers: true,
      degreeMode: false,
      randomSeed: "",
      restrictGridToFirstQuadrant: false,
      userLockedViewport: false,
      complex: false,
    },
    EK = {
      threeDMode: false,
      worldRotation3D: [],
      axis3D: [0, 0, 1],
      speed3D: 0,
      showPlane3D: true,
      showNumbers3D: true,
      plane3dOpacity: "",
      backgroundColor3d: "#FFF",
      showAxis3D: true,
      showAxisLabels3D: true,
      showBox3D: true,
    },
    yie = { squareAxes: true },
    xie = {
      ...EK,
      ...yie,
      product: "graphing",
      includeFunctionParametersInRandomSeed: true,
      hideCustomColors: false,
    };
  function TK(r) {
    return r in EK;
  }
  var Os = { ...OP, ...xie }, DK = Object.keys(OP);
  function kK(r) {
    return r in OP;
  }
  var ay = (r) => isFinite(r) && (r > 0 || r === 0);
  var TD = class {
    constructor(e) {
      this.mq = e, this.id = e.id, this.data = e.data;
    }
    simulateUserChangedLatex() {
      Fe.simulateUserChangedLatex(this.mq);
    }
    simulateKeypress(e) {
      Fe.simulateKeypressFromKeypad(this.mq, e);
    }
    config(e) {
      return this.mq.config(e), this;
    }
    latex(e) {
      return e === void 0
        ? this.mq.latex()
        : (this.mq.latex(e), this.simulateUserChangedLatex(), this);
    }
    reflow() {
      this.mq.reflow();
    }
    el() {
      return this.mq.el();
    }
    getAriaLabel() {
      return this.mq.getAriaLabel();
    }
    setAriaLabel(e) {
      return this.mq.setAriaLabel(e);
    }
    html() {
      return this.mq.html();
    }
    mathspeak() {
      return this.mq.mathspeak();
    }
    text() {
      return this.mq.text();
    }
    selection() {
      return this.mq.selection();
    }
    select() {
      return this.mq.select(), this;
    }
    moveToRightEnd() {
      return this.mq.moveToRightEnd(), this;
    }
    moveToLeftEnd() {
      return this.mq.moveToLeftEnd(), this;
    }
    cmd(e) {
      return this.mq.cmd(e), this.simulateUserChangedLatex(), this;
    }
    write(e) {
      return this.mq.write(e), this.simulateUserChangedLatex(), this;
    }
    keystroke(e) {
      return this.simulateKeypress(e), this;
    }
    typedText(e) {
      return this.mq.typedText(e), this.simulateUserChangedLatex(), this;
    }
    clearSelection() {
      return this.mq.clearSelection(), this;
    }
    getAriaPostLabel() {
      return this.mq.getAriaPostLabel();
    }
    setAriaPostLabel(e, t) {
      return this.mq.setAriaPostLabel(e, t), this;
    }
    blur() {
      return this.mq.blur(), this;
    }
    focus() {
      return this.mq.focus(), this;
    }
    revert() {
      return this.mq.revert();
    }
    ignoreNextMousedown(e) {
      return this.mq.ignoreNextMousedown(e), this;
    }
    clickAt(e, t, o) {
      return this.mq.clickAt(e, t, o), this;
    }
  };
  function _K(r) {
    let e = r.mode,
      t = r.width,
      o = r.height,
      i = r.currentBounds,
      n = r.graphpaperAspectRatio,
      a = r.mathAspectRatio,
      s = r.mathBounds,
      l = t / o,
      c = { x: i.left + i.width / 2, y: i.bottom + i.height / 2 };
    if (
      s.left === void 0 != (s.right === void 0) ||
      s.bottom === void 0 != (s.top === void 0)
    ) {
      return __dcg_shared_module_exports__["qe"].warn(
        'asyncScreenshot: cannot specify "left" bound without "right" or "bottom" bound without "top". Got: ' +
          s,
      ),
        i;
    }
    let d = s.left !== void 0 && s.right !== void 0,
      p = s.bottom !== void 0 && s.top !== void 0,
      h = d && p,
      u,
      f,
      y,
      C,
      E,
      v,
      w,
      S,
      k,
      _;
    switch (e) {
      case "stretch":
        return h
          ? s
          : d
          ? { left: s.left, right: s.right, bottom: i.bottom, top: i.top }
          : p
          ? { left: i.left, right: i.right, bottom: s.bottom, top: s.top }
          : i;
      case "contain":
        return h
          ? (C = s.right - s.left,
            E = s.top - s.bottom,
            v = { x: s.left + C / 2, y: s.bottom + E / 2 },
            y = C / E,
            l > y
              ? (f = E / o, u = f * a, {
                left: v.x - u * t / 2,
                right: v.x + u * t / 2,
                bottom: s.bottom,
                top: s.top,
              })
              : (u = C / t, f = u / a, {
                left: s.left,
                right: s.right,
                bottom: v.y - f * o / 2,
                top: v.y + f * o / 2,
              }))
          : d
          ? (w = s.right - s.left,
            S = s.left + w / 2,
            y = w / i.height,
            l > y
              ? (f = i.height / o, u = f * a, {
                left: S - u * t / 2,
                right: S + u * t / 2,
                bottom: i.bottom,
                top: i.top,
              })
              : (u = w / t, f = u / a, {
                left: s.left,
                right: s.right,
                bottom: c.y - f * o / 2,
                top: c.y + f * o / 2,
              }))
          : p
          ? (k = s.top - s.bottom,
            _ = s.bottom + k / 2,
            y = i.width / k,
            l > y
              ? (f = k / o, u = f * a, {
                left: c.x - u * t / 2,
                right: c.x + u * t / 2,
                bottom: s.bottom,
                top: s.top,
              })
              : (u = i.width / t, f = u / a, {
                left: i.left,
                right: i.right,
                bottom: _ - f * o / 2,
                top: _ + f * o / 2,
              }))
          : l > n
          ? (f = i.height / o, u = f * a, {
            left: c.x - u * t / 2,
            right: c.x + u * t / 2,
            bottom: i.bottom,
            top: i.top,
          })
          : (u = i.width / t, f = u / a, {
            left: i.left,
            right: i.right,
            bottom: c.y - f * o / 2,
            top: c.y + f * o / 2,
          });
      case "preserveX":
        return h
          ? (C = s.right - s.left,
            E = s.top - s.bottom,
            v = { x: s.left + C / 2, y: s.bottom + E / 2 },
            y = C / E,
            u = C / t,
            f = u / a,
            {
              left: s.left,
              right: s.right,
              bottom: v.y - f * o / 2,
              top: v.y + f * o / 2,
            })
          : p
          ? (k = s.top - s.bottom,
            _ = s.bottom + k / 2,
            y = i.width / k,
            u = i.width / t,
            f = u / a,
            {
              left: i.left,
              right: i.right,
              bottom: _ - f * o / 2,
              top: _ + f * o / 2,
            })
          : d
          ? (w = s.right - s.left, u = w / t, f = u / a, {
            left: s.left,
            right: s.right,
            bottom: c.y - f * o / 2,
            top: c.y + f * o / 2,
          })
          : (w = i.right - i.left, u = w / t, f = u / a, {
            left: i.left,
            right: i.right,
            bottom: c.y - f * o / 2,
            top: c.y + f * o / 2,
          });
      case "preserveY":
        return h
          ? (C = s.right - s.left,
            E = s.top - s.bottom,
            v = { x: s.left + C / 2, y: s.bottom + E / 2 },
            y = C / E,
            f = E / o,
            u = f * a,
            {
              left: v.x - u * t / 2,
              right: v.x + u * t / 2,
              bottom: s.bottom,
              top: s.top,
            })
          : d
          ? (w = s.right - s.left,
            S = s.left + w / 2,
            y = w / i.height,
            f = i.height / o,
            u = f * a,
            {
              left: S - u * t / 2,
              right: S + u * t / 2,
              bottom: i.bottom,
              top: i.top,
            })
          : p
          ? (k = s.top - s.bottom, f = k / o, u = f * a, {
            left: c.x - u * t / 2,
            right: c.x + u * t / 2,
            bottom: s.bottom,
            top: s.top,
          })
          : (k = i.top - i.bottom, f = k / o, u = f * a, {
            left: c.x - u * t / 2,
            right: c.x + u * t / 2,
            bottom: i.bottom,
            top: i.top,
          });
      default:
        return i;
    }
  }
  function Ld(r) {
    return r === "es-ES"
      ? (__dcg_shared_module_exports__["qe"].warn(
        "{language: 'es-ES'} has been deprecated. Proceeding with {language: 'es'}",
      ),
        "es")
      : r;
  }
  var RP = {
      keypad: true,
      graphpaper: true,
      expressions: true,
      settingsMenu: true,
      zoomButtons: true,
      showResetButtonOnGraphpaper: false,
      expressionsTopbar: true,
      capExpressionSize: false,
      pointsOfInterest: true,
      trace: true,
      border: true,
      lockViewport: false,
      expressionsCollapsed: false,
      authorFeatures: false,
      authorMode: true,
      advancedStyling: false,
      images: true,
      imageUploadCallback: cD,
      folders: true,
      notes: true,
      sliders: true,
      links: true,
      qwertyKeyboard: true,
      restrictedFunctions: false,
      forceEnableGeometryFunctions: false,
      pasteGraphLink: false,
      pasteTableData: true,
      degreeMode: false,
      clearIntoDegreeMode: false,
      autosize: true,
      plotSingleVariableImplicitEquations: true,
      plotImplicits: true,
      plotInequalities: true,
      colors: {
        RED: pE,
        BLUE: uE,
        GREEN: hE,
        ORANGE: mE,
        PURPLE: gE,
        BLACK: zf,
      },
      invertedColors: false,
      functionDefinition: true,
      projectorMode: false,
      decimalToFraction: true,
      fontSize: 16,
      language: "en",
      backgroundColor: "#fff",
      textColor: "#000",
      distributions: true,
      brailleMode: "none",
      sixKeyInput: false,
      brailleControls: true,
      graphDescription: void 0,
      zoomFit: true,
      forceLogModeRegressions: false,
      defaultLogModeRegressions: false,
      actions: "auto",
      audio: true,
      logScales: true,
      translucentSurfaces: false,
      perspectiveDistortion: 1,
      showKeyboardShortcutsInTooltips: false,
      tone: true,
      muted: true,
      showPerformanceMeter: false,
      allowComplex: true,
      customRegressions: true,
    },
    IK = Object.keys(RP),
    wie = {
      orientationButtons: true,
      debug3dRender: void 0,
      debugPeelLayers: void 0,
      adaptivePeeling: true,
      debugPixelRatio: void 0,
      translucentOpacity: "0.8",
      peelFloatTexture: false,
      debugScale: 1 / 10,
      peelUpsample: void 0,
    },
    AK = {
      product: "graphing",
      showHamburger: false,
      disableScrollFix: false,
      branding: true,
      onlyTraceSelected: false,
      disableMouseInteractions: false,
      nativeOnscreenKeypad: false,
      plaidMode: false,
      wireframe: false,
      pasteGraphLinkCallback: void 0,
      editOnWeb: false,
      crossOriginSaveTest: false,
      enableTabindex: true,
      audioTraceReverseExpressions: false,
      audioTraceSimult: false,
      transparentBackground: false,
      pauseWhenOffscreen: false,
      hideGeoUI: false,
      substitutions: true,
      intervalComprehensions: true,
      recursion: true,
      beta3d: false,
      disableLighting: false,
      disableWorkerOnZoom: false,
      cacheRenderedSvgs: false,
      ghostMode: false,
      tableRegressions: true,
      reflectionArc: false,
      logInternalErrors: false,
      debugProgressUpdates: false,
      recursionDepthLimit: void 0,
      ...wie,
    },
    vie = {
      solutions: true,
      menus: true,
      singleVariableSolutions: true,
      clickableObjects: false,
      administerSecretFolders: false,
    },
    sy = { ...RP, ...AK };
  function FP(r) {
    return !!(RP.hasOwnProperty(r) || AK.hasOwnProperty(r) ||
      vie.hasOwnProperty(r));
  }
  function DD(r) {
    let e = __dcg_shared_module_exports__["Jc"](sy);
    for (let t in r) e.hasOwnProperty(t) && (e[t] = r[t]);
    return __dcg_shared_module_exports__["Jd"](e.backgroundColor) ||
      (e.backgroundColor = sy.backgroundColor,
        __dcg_shared_module_exports__["qe"].warn(
          "Invalid backgroundColor. Background color must be a 3- or 6-character hex color (e.g. #cde or #ffaaaa)",
        )),
      __dcg_shared_module_exports__["Jd"](e.textColor) ||
      (e.textColor = sy.textColor,
        __dcg_shared_module_exports__["qe"].warn(
          "Invalid textColor. Text color must be a 3- or 6-character hex color (e.g. #000 or #001111)",
        )),
      e.actions !== true && e.actions !== false && e.actions !== "auto" &&
      (e.actions = sy.actions,
        __dcg_shared_module_exports__["qe"].warn(
          "Invalid actions setting. Must be true, false, or 'auto'.",
        )),
      r.zoomButtons === void 0 && (!e.graphpaper || e.lockViewport) &&
      (e.zoomButtons = false),
      r.images === void 0 && (e.graphpaper || (e.images = false)),
      r.hasOwnProperty("menus") &&
      (__dcg_shared_module_exports__["qe"].warn(
        "As of API version 0.4, the 'menus' option is deprecated and has been split into 'settingsMenu' (boolean) and 'expressionsTopbar' (boolean).",
      ),
        r.hasOwnProperty("settingsMenu") || (e.settingsMenu = !!r.menus),
        r.hasOwnProperty("expressionsTopbar") ||
        (e.expressionsTopbar = !!r.menus)),
      r.hasOwnProperty("solutions") &&
      (__dcg_shared_module_exports__["qe"].warn(
        "As of API v1.0, the 'solutions' option is deprecated and has been replaced with 'pointsOfInterest' (boolean).",
      ),
        r.hasOwnProperty("pointsOfInterest") ||
        (e.pointsOfInterest = !!r.solutions)),
      r.hasOwnProperty("singleVariableSolutions") &&
      __dcg_shared_module_exports__["qe"].warn(
        "As of API v1.0, the 'singleVariableSolutions' has been removed. The calculator no longer displays solutions to single variable equations.",
      ),
      r.hasOwnProperty("clickableObjects") &&
      (__dcg_shared_module_exports__["qe"].warn(
        "As of API v1.7, the 'clickableObjects' option is deprecated and has been replaced with 'actions'.",
      ),
        r.clickableObjects === true && !r.hasOwnProperty("actions") &&
        (e.actions = true)),
      r.hasOwnProperty("administerSecretFolders") &&
      (__dcg_shared_module_exports__["qe"].warn(
        "As of API v1.8, the 'administerSecretFolders' option is deprecated and has been subsumed under 'authorFeatures'.",
      ),
        r.administerSecretFolders === true &&
        !r.hasOwnProperty("authorFeatures") && (e.authorFeatures = true)),
      e.graphpaper ||
      (e.expressionsCollapsed &&
        (e.expressionsCollapsed = false,
          __dcg_shared_module_exports__["qe"].warn(
            "Desmos API initialized with bad options. graphpaper: false and expressionsCollapsed: true are incompatible. Proceeding with expressionsCollapsed: false.",
          )),
        e.zoomButtons &&
        (e.zoomButtons = false,
          __dcg_shared_module_exports__["qe"].warn(
            "Desmos API initialized with bad options. graphpaper: false and zoomButtons: true are incompatible. Proceeding with zoomButtons: false.",
          )),
        e.showResetButtonOnGraphpaper &&
        (e.showResetButtonOnGraphpaper = false,
          __dcg_shared_module_exports__["qe"].warn(
            "Desmos API initialized with bad options. graphpaper: false and showResetButtonOnGraphpaper: true are incompatible. Proceeding with showResetButtonOnGraphpaper: false.",
          ))),
      e.lockViewport && e.zoomButtons &&
      (e.zoomButtons = false,
        __dcg_shared_module_exports__["qe"].warn(
          "Desmos API initialized with bad options. lockViewport: true and zoomButtons: true are incompatible. Proceeding with zoomButtons: false.",
        )),
      (e.notes === false || e.folders === false || e.images === false) &&
      e.pasteGraphLink === true &&
      (e.pasteGraphLink = false,
        __dcg_shared_module_exports__["qe"].warn(
          "Desmos API initialized with bad options. pasteGraphLink: true is incompatible with disabling the creation of note, folder, or image expressions. Proceeding with pasteGraphLink: false.",
        )),
      e.language && (e.language = Ld(e.language)),
      e;
  }
  function Cie(r) {
    FS ? setTimeout(r, 25) : requestAnimationFrame(r);
  }
  var MK = 1, ly = {}, Dv = false;
  function LK() {
    Dv = true, Cie(Sie);
  }
  var GK = {};
  function Sie() {
    GK.rafSPY && GK.rafSPY(), Dv = false;
    for (let r in ly) ly[r].detectAndEnqueueEvent(), Dv = true;
    if (Dv) {
      LK();
      for (let r in ly) ly[r].dispatchQueuedEvent();
    }
  }
  var Yg = class {
    constructor(e, t) {
      this.elt = e;
      this.cb = t;
      this.destroyed = false;
      this.lastOffscreen = false;
      this.id = MK.toString(), this.appliedScale = { x: 1, y: 1 }, MK++;
    }
    stopWatching() {
      delete ly[this.id];
    }
    startWatching() {
      this.checkForChanges(), ly[this.id] = this, Dv || LK();
    }
    resetAppliedScalingAndGetBoundingClientRect() {
      let e = this.elt.getBoundingClientRect(),
        t = {
          x: e.width / this.elt.offsetWidth,
          y: e.height / this.elt.offsetHeight,
        };
      if (t.x === this.appliedScale.x && t.y === this.appliedScale.y) {
        return e;
      }
      let o = this.elt.querySelector(".dcg-dom-change-wrapper");
      return o && (this.appliedScale = t,
        Wn(o, {
          transform: "scale(" + 1 / this.appliedScale.x + "," +
            1 / this.appliedScale.y + ")",
          width: 100 * this.appliedScale.x + "%",
          height: 100 * this.appliedScale.y + "%",
          transformOrigin: "0 0",
        })),
        e;
    }
    detectAndEnqueueEvent() {
      if (this.destroyed) return;
      let e = true;
      if (!(document.body && document.body.contains(this.elt))) {
        this.lastSize &&
          (this.lastSize = void 0,
            this.queuedEvent = {
              type: "removed",
              target: this.elt,
              isOffscreen: true,
            });
      } else {
        let o = this.resetAppliedScalingAndGetBoundingClientRect();
        e = o.top > window.innerHeight || o.bottom < 0 ||
          o.left > window.innerWidth || o.right < 0,
          this.lastSize
            ? (o.width !== this.lastSize.width ||
              o.height !== this.lastSize.height ||
              window.devicePixelRatio !== this.lastSize.pixelRatio) &&
              (this.lastSize.width = o.width,
                this.lastSize.height = o.height,
                this.lastSize.pixelRatio = window.devicePixelRatio,
                this.queuedEvent = {
                  type: "resized",
                  target: this.elt,
                  size: { ...this.lastSize },
                  isOffscreen: e,
                })
            : (this.lastSize = {
              width: o.width,
              height: o.height,
              pixelRatio: window.devicePixelRatio,
            },
              this.queuedEvent = {
                type: "added",
                target: this.elt,
                size: { ...this.lastSize },
                isOffscreen: e,
              });
      }
      e !== this.lastOffscreen &&
        (this.lastOffscreen = e,
          this.queuedEvent ||
          (this.queuedEvent = {
            type: "offscreen-noop",
            target: this.elt,
            isOffscreen: e,
          }));
    }
    dispatchQueuedEvent() {
      let e = this.queuedEvent;
      e && (this.queuedEvent = void 0, this.cb(e));
    }
    checkForChanges() {
      this.detectAndEnqueueEvent(), this.dispatchQueuedEvent();
    }
    destroy() {
      this.stopWatching();
      for (let e in this) this.hasOwnProperty(e) && delete this[e];
      this.destroyed = true;
    }
  };
  var Eie = 0,
    Tie = "guid_" + Math.round(Math.random() * 1e6) + "_" +
      new Date().getTime() + "_",
    NP = class {
      constructor(e) {
        this.__observers = {},
          this.guid = Tie + ++Eie,
          e && this.setProperties(e);
      }
      unobserveAll() {
        this.__observers = {};
      }
      getProperty(e) {
        return this[e];
      }
      setProperty(e, t) {
        let o = this[e];
        this.setPropertyWithoutNotifying(e, t),
          !__dcg_shared_module_exports__["E"](o, t) &&
          this.notifyPropertyChange(e);
      }
      setPropertyWithoutNotifying(e, t) {
        this[e] = t;
      }
      setProperties(e) {
        let t = [];
        for (let o of Object.keys(e)) {
          let i = this[o];
          this.setPropertyWithoutNotifying(o, e[o]),
            __dcg_shared_module_exports__["E"](i, e[o]) || t.push(o);
        }
        t.forEach((o) => this.notifyPropertyChange(o));
      }
      notifyPropertyChange(e) {
        wP(this.__observers, e, this);
      }
      observe(e, t) {
        CP(this.__observers, e, t);
      }
      unobserve(e) {
        vP(this.__observers, e);
      }
      observeAndSync(e, t) {
        this.observe(e, t);
        let o = e.split(" ");
        for (let i = 0; i < o.length; i++) {
          let a = o[i].split(".")[0];
          this.hasOwnProperty(a) && t(a, this);
        }
      }
    },
    cs = NP;
  var sx = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Hv = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var cy, xt, kv, zP, UP;
  function Da(r, e) {
    var t = Object.keys(e), o;
    for (o = 0; o < t.length; o++) {
      r = r.replace(new RegExp("\\{" + t[o] + "\\}", "gi"), e[t[o]]);
    }
    return r;
  }
  function kD(r) {
    var e, t, o;
    if (!r) {
      throw new Error(
        "cannot create a random attribute name for an undefined object",
      );
    }
    e = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", t = "";
    do for (t = "", o = 0; o < 12; o++) {
      t += e[Math.floor(Math.random() * e.length)];
    } while (r[t]);
    return t;
  }
  function Die(r, e) {
    var t, o, i = {}, n, a;
    for (r = r.split(","), e = e || 10, t = 0; t < r.length; t += 2) {
      o = "&" + r[t + 1] + ";", n = parseInt(r[t], e), i[o] = "&#" + n + ";";
    }
    return i["\\xa0"] = "&#160;", i;
  }
  function kie(r) {
    var e = {
      left: "start",
      right: "end",
      center: "middle",
      start: "start",
      end: "end",
    };
    return e[r] || e.start;
  }
  UP = Die(
    "50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro",
    32,
  );
  cy = {
    strokeStyle: {
      svgAttr: "stroke",
      canvas: "#000000",
      svg: "none",
      apply: "stroke",
    },
    fillStyle: {
      svgAttr: "fill",
      canvas: "#000000",
      svg: null,
      apply: "fill",
    },
    lineCap: {
      svgAttr: "stroke-linecap",
      canvas: "butt",
      svg: "butt",
      apply: "stroke",
    },
    lineJoin: {
      svgAttr: "stroke-linejoin",
      canvas: "miter",
      svg: "miter",
      apply: "stroke",
    },
    miterLimit: {
      svgAttr: "stroke-miterlimit",
      canvas: 10,
      svg: 4,
      apply: "stroke",
    },
    lineWidth: {
      svgAttr: "stroke-width",
      canvas: 1,
      svg: 1,
      apply: "stroke",
    },
    globalAlpha: {
      svgAttr: "opacity",
      canvas: 1,
      svg: 1,
      apply: "fill stroke",
    },
    font: { canvas: "10px sans-serif" },
    shadowColor: { canvas: "#000000" },
    shadowOffsetX: { canvas: 0 },
    shadowOffsetY: { canvas: 0 },
    shadowBlur: { canvas: 0 },
    textAlign: { canvas: "start" },
    textBaseline: { canvas: "alphabetic" },
    lineDash: {
      svgAttr: "stroke-dasharray",
      canvas: [],
      svg: null,
      apply: "stroke",
    },
  };
  kv = function (r, e) {
    this.__root = r, this.__ctx = e;
  };
  kv.prototype.addColorStop = function (r, e) {
    var t = this.__ctx.__createElement("stop"), o, i;
    t.setAttribute("offset", r),
      e.indexOf("rgba") !== -1
        ? (o =
          /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi,
          i = o.exec(e),
          t.setAttribute(
            "stop-color",
            Da("rgb({r},{g},{b})", { r: i[1], g: i[2], b: i[3] }),
          ),
          t.setAttribute("stop-opacity", i[4]))
        : t.setAttribute("stop-color", e),
      this.__root.appendChild(t);
  };
  zP = function (r, e) {
    this.__root = r, this.__ctx = e;
  };
  xt = function (r) {
    var e = { width: 500, height: 500, enableMirroring: false }, t;
    if (
      arguments.length > 1
        ? (t = e, t.width = arguments[0], t.height = arguments[1])
        : r
        ? t = r
        : t = e, !(this instanceof xt)
    ) return new xt(t);
    this._randomPostfix = "-" + function () {
      return "xxxxxxxx".replace(/x/g, function (i) {
        return (Math.random() * 16 | 0).toString(16);
      });
    }(),
      this._svgClassNames = [],
      this.width = t.width || e.width,
      this.height = t.height || e.height,
      this.enableMirroring = t.enableMirroring !== void 0
        ? t.enableMirroring
        : e.enableMirroring,
      this.canvas = this,
      this.__document = t.document || document,
      t.ctx
        ? this.__ctx = t.ctx
        : (this.__canvas = this.__document.createElement("canvas"),
          this.__ctx = this.__canvas.getContext("2d")),
      this.__setDefaultStyles(),
      this.__stack = [this.__getStyleState()],
      this.__groupStack = [],
      this.__root = this.__document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg",
      ),
      this.__root.setAttribute("version", 1.1),
      this.__root.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
      this.__root.setAttributeNS(
        "http://www.w3.org/2000/xmlns/",
        "xmlns:xlink",
        "http://www.w3.org/1999/xlink",
      ),
      this.__root.setAttribute("width", this.width),
      this.__root.setAttribute("height", this.height),
      this.__ids = {},
      this.__defs = this.__document.createElementNS(
        "http://www.w3.org/2000/svg",
        "defs",
      ),
      this.__root.appendChild(this.__defs),
      this.__currentElement = this.__document.createElementNS(
        "http://www.w3.org/2000/svg",
        "g",
      ),
      this.__root.appendChild(this.__currentElement);
  };
  xt.prototype.__createElement = function (r, e, t) {
    typeof e == "undefined" && (e = {});
    var o = this.__document.createElementNS(
        "http://www.w3.org/2000/svg",
        r,
      ),
      i = Object.keys(e),
      n,
      a;
    for (
      t &&
      (o.setAttribute("fill", "none"), o.setAttribute("stroke", "none")), n = 0;
      n < i.length;
      n++
    ) a = i[n], o.setAttribute(a, e[a]);
    var s = this._svgClassNames &&
      this._svgClassNames[this._svgClassNames.length - 1];
    return s && o.setAttribute("class", s), o;
  };
  xt.prototype.__setDefaultStyles = function () {
    var r = Object.keys(cy), e, t;
    for (e = 0; e < r.length; e++) t = r[e], this[t] = cy[t].canvas;
  };
  xt.prototype.__applyStyleState = function (r) {
    var e = Object.keys(r), t, o;
    for (t = 0; t < e.length; t++) o = e[t], this[o] = r[o];
  };
  xt.prototype.__getStyleState = function () {
    var r, e = {}, t = Object.keys(cy), o;
    for (r = 0; r < t.length; r++) o = t[r], e[o] = this[o];
    return e;
  };
  xt.prototype.__applyStyleToCurrentElement = function (r) {
    var e = this.__currentElement, t = this.__currentElementsToStyle;
    t &&
      (e.setAttribute(r, ""),
        e = t.element,
        t.children.forEach(function (u) {
          u.setAttribute(r, "");
        }));
    var o = Object.keys(cy), i, n, a, s, l, c;
    for (i = 0; i < o.length; i++) {
      if (n = cy[o[i]], a = this[o[i]], n.apply) {
        if (a instanceof zP) {
          if (a.__ctx) {
            for (; a.__ctx.__defs.childNodes.length;) {
              s = a.__ctx.__defs.childNodes[0].getAttribute("id"),
                this.__ids[s] = s,
                this.__defs.appendChild(a.__ctx.__defs.childNodes[0]);
            }
          }
          e.setAttribute(
            n.apply,
            Da("url(#{id})", { id: a.__root.getAttribute("id") }),
          );
        } else if (a instanceof kv) {
          e.setAttribute(
            n.apply,
            Da("url(#{id})", { id: a.__root.getAttribute("id") }),
          );
        } else if (n.apply.indexOf(r) !== -1 && n.svg !== a) {
          if (
            (n.svgAttr === "stroke" || n.svgAttr === "fill") &&
            a.indexOf("rgba") !== -1
          ) {
            l =
              /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi,
              c = l.exec(a),
              e.setAttribute(
                n.svgAttr,
                Da("rgb({r},{g},{b})", { r: c[1], g: c[2], b: c[3] }),
              );
            var d = c[4], p = this.globalAlpha;
            p != null && (d *= p), e.setAttribute(n.svgAttr + "-opacity", d);
          } else {
            var h = n.svgAttr;
            if (
              o[i] === "globalAlpha" &&
              (h = r + "-" + n.svgAttr, e.getAttribute(h))
            ) continue;
            e.setAttribute(h, a);
          }
        }
      }
    }
  };
  xt.prototype.__closestGroupOrSvg = function (r) {
    return r = r || this.__currentElement,
      r.nodeName === "g" || r.nodeName === "svg"
        ? r
        : this.__closestGroupOrSvg(r.parentNode);
  };
  xt.prototype.getSerializedSvg = function (r) {
    var e = new XMLSerializer().serializeToString(this.__root),
      t,
      o,
      i,
      n,
      a,
      s;
    if (
      s =
        /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi,
        s.test(e) &&
        (e = e.replace(
          'xmlns="http://www.w3.org/2000/svg',
          'xmlns:xlink="http://www.w3.org/1999/xlink',
        )),
        r
    ) {
      for (t = Object.keys(UP), o = 0; o < t.length; o++) {
        i = t[o],
          n = UP[i],
          a = new RegExp(i, "gi"),
          a.test(e) && (e = e.replace(a, n));
      }
    }
    return e;
  };
  xt.prototype.getSvg = function () {
    return this.__root;
  };
  xt.prototype._dcgStartNamedGroup = function (r) {
    var e = this.__createElement("g");
    e.setAttribute("id", r + this._randomPostfix);
    var t = this.__closestGroupOrSvg();
    this.__groupStack.push(t), t.appendChild(e), this.__currentElement = e;
  };
  xt.prototype._dcgEndNamedGroup = function () {
    this.__currentElement = this.__groupStack.pop(),
      this.__currentElement ||
      (this.__currentElement = this.__root.childNodes[1]);
  };
  xt.prototype._dcgSaveClassName = function (r) {
    this._svgClassNames.push(r),
      this.__currentElement && this.__currentElement.tagName === "path" &&
      !this.__currentDefaultPath &&
      (this.__currentElement.getAttribute("class") ||
        this.__currentElement.setAttribute("class", r));
  };
  xt.prototype._dcgRestoreClassName = function () {
    this._svgClassNames.pop();
  };
  xt.prototype.save = function () {
    var r = this.__createElement("g"), e = this.__closestGroupOrSvg();
    this.__groupStack.push(e),
      e.appendChild(r),
      this.__currentElement = r,
      this.__stack.push(this.__getStyleState());
  };
  xt.prototype.restore = function () {
    this.__currentElement = this.__groupStack.pop(),
      this.__currentElementsToStyle = null,
      this.__currentElement ||
      (this.__currentElement = this.__root.childNodes[1]);
    var r = this.__stack.pop();
    this.__applyStyleState(r);
  };
  xt.prototype.__addTransform = function (r) {
    var e = this.__closestGroupOrSvg();
    if (e.childNodes.length > 0) {
      this.__currentElement.nodeName === "path" &&
        (this.__currentElementsToStyle ||
          (this.__currentElementsToStyle = { element: e, children: [] }),
          this.__currentElementsToStyle.children.push(
            this.__currentElement,
          ),
          this.__applyCurrentDefaultPath());
      var t = this.__createElement("g");
      e.appendChild(t), this.__currentElement = t;
    }
    var o = this.__currentElement.getAttribute("transform");
    o ? o += " " : o = "",
      o += r,
      this.__currentElement.setAttribute("transform", o);
  };
  xt.prototype.scale = function (r, e) {
    e === void 0 && (e = r),
      this.__addTransform(Da("scale({x},{y})", { x: r, y: e }));
  };
  xt.prototype.rotate = function (r) {
    var e = r * 180 / Math.PI;
    this.__addTransform(
      Da("rotate({angle},{cx},{cy})", { angle: e, cx: 0, cy: 0 }),
    );
  };
  xt.prototype.translate = function (r, e) {
    this.__addTransform(Da("translate({x},{y})", { x: r, y: e }));
  };
  xt.prototype.transform = function (r, e, t, o, i, n) {
    this.__addTransform(
      Da("matrix({a},{b},{c},{d},{e},{f})", {
        a: r,
        b: e,
        c: t,
        d: o,
        e: i,
        f: n,
      }),
    );
  };
  xt.prototype.beginPath = function () {
    var r, e;
    this.__currentDefaultPath = "",
      this.__currentPosition = {},
      r = this.__createElement("path", {}, true),
      e = this.__closestGroupOrSvg(),
      e.appendChild(r),
      this.__currentElement = r;
  };
  xt.prototype.__applyCurrentDefaultPath = function () {
    var r = this.__currentElement;
    r.nodeName === "path"
      ? r.setAttribute("d", this.__currentDefaultPath)
      : console.error(
        "Attempted to apply path command to node",
        r.nodeName,
      );
  };
  xt.prototype.__addPathCommand = function (r) {
    this.__currentDefaultPath += " ", this.__currentDefaultPath += r;
  };
  xt.prototype.moveTo = function (r, e) {
    this.__currentElement.nodeName !== "path" && this.beginPath(),
      this.__currentPosition = { x: r, y: e },
      this.__addPathCommand(Da("M {x} {y}", { x: r, y: e }));
  };
  xt.prototype.closePath = function () {
    this.__currentDefaultPath && this.__addPathCommand("Z");
  };
  xt.prototype.lineTo = function (r, e) {
    this.__currentPosition = { x: r, y: e },
      this.__currentDefaultPath.indexOf("M") > -1
        ? this.__addPathCommand(Da("L {x} {y}", { x: r, y: e }))
        : this.__addPathCommand(Da("M {x} {y}", { x: r, y: e }));
  };
  xt.prototype.bezierCurveTo = function (r, e, t, o, i, n) {
    this.__currentPosition = { x: i, y: n },
      this.__addPathCommand(
        Da("C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}", {
          cp1x: r,
          cp1y: e,
          cp2x: t,
          cp2y: o,
          x: i,
          y: n,
        }),
      );
  };
  xt.prototype.quadraticCurveTo = function (r, e, t, o) {
    this.__currentPosition = { x: t, y: o },
      this.__addPathCommand(
        Da("Q {cpx} {cpy} {x} {y}", { cpx: r, cpy: e, x: t, y: o }),
      );
  };
  var BP = function (r) {
    var e = Math.sqrt(r[0] * r[0] + r[1] * r[1]);
    return [r[0] / e, r[1] / e];
  };
  xt.prototype.arcTo = function (r, e, t, o, i) {
    var n = this.__currentPosition && this.__currentPosition.x,
      a = this.__currentPosition && this.__currentPosition.y;
    if (!(typeof n == "undefined" || typeof a == "undefined")) {
      if (i < 0) {
        throw new Error(
          "IndexSizeError: The radius provided (" + i + ") is negative.",
        );
      }
      if (n === r && a === e || r === t && e === o || i === 0) {
        this.lineTo(r, e);
        return;
      }
      var s = BP([n - r, a - e]), l = BP([t - r, o - e]);
      if (s[0] * l[1] === s[1] * l[0]) {
        this.lineTo(r, e);
        return;
      }
      var c = s[0] * l[0] + s[1] * l[1],
        d = Math.acos(Math.abs(c)),
        p = BP([s[0] + l[0], s[1] + l[1]]),
        h = i / Math.sin(d / 2),
        u = r + h * p[0],
        f = e + h * p[1],
        y = [-s[1], s[0]],
        C = [l[1], -l[0]],
        E = function (S) {
          var k = S[0], _ = S[1];
          return _ >= 0 ? Math.acos(k) : -Math.acos(k);
        },
        v = E(y),
        w = E(C);
      this.lineTo(u + y[0] * i, f + y[1] * i), this.arc(u, f, i, v, w);
    }
  };
  xt.prototype.stroke = function () {
    this.__currentElement.nodeName === "path" &&
    this.__currentElement.setAttribute(
      "paint-order",
      "fill stroke markers",
    ),
      this.__applyCurrentDefaultPath(),
      this.__applyStyleToCurrentElement("stroke");
  };
  xt.prototype.fill = function () {
    this.__currentElement.nodeName === "path" &&
    this.__currentElement.setAttribute(
      "paint-order",
      "stroke fill markers",
    ),
      this.__applyCurrentDefaultPath(),
      this.__applyStyleToCurrentElement("fill");
  };
  xt.prototype.rect = function (r, e, t, o) {
    this.__currentElement.nodeName !== "path" && this.beginPath(),
      this.moveTo(r, e),
      this.lineTo(r + t, e),
      this.lineTo(r + t, e + o),
      this.lineTo(r, e + o),
      this.lineTo(r, e),
      this.closePath();
  };
  xt.prototype.fillRect = function (r, e, t, o) {
    var i, n;
    i = this.__createElement(
      "rect",
      { x: r, y: e, width: t, height: o },
      true,
    ),
      n = this.__closestGroupOrSvg(),
      n.appendChild(i),
      this.__currentElement = i,
      this.__applyStyleToCurrentElement("fill");
  };
  xt.prototype.strokeRect = function (r, e, t, o) {
    var i, n;
    i = this.__createElement(
      "rect",
      { x: r, y: e, width: t, height: o },
      true,
    ),
      n = this.__closestGroupOrSvg(),
      n.appendChild(i),
      this.__currentElement = i,
      this.__applyStyleToCurrentElement("stroke");
  };
  xt.prototype.__clearCanvas = function () {
    for (
      var r = this.__closestGroupOrSvg(),
        e = r.getAttribute("transform"),
        t = this.__root.childNodes[1],
        o = t.childNodes,
        i = o.length - 1;
      i >= 0;
      i--
    ) o[i] && t.removeChild(o[i]);
    this.__currentElement = t,
      this.__groupStack = [],
      e && this.__addTransform(e);
  };
  xt.prototype.clearRect = function (r, e, t, o) {
    if (r === 0 && e === 0 && t === this.width && o === this.height) {
      this.__clearCanvas();
      return;
    }
    var i, n = this.__closestGroupOrSvg();
    i = this.__createElement("rect", {
      x: r,
      y: e,
      width: t,
      height: o,
      fill: "#FFFFFF",
    }, true), n.appendChild(i);
  };
  xt.prototype.createLinearGradient = function (r, e, t, o) {
    var i = this.__createElement("linearGradient", {
      id: kD(this.__ids),
      x1: r + "px",
      x2: t + "px",
      y1: e + "px",
      y2: o + "px",
      gradientUnits: "userSpaceOnUse",
    }, false);
    return this.__defs.appendChild(i), new kv(i, this);
  };
  xt.prototype.createRadialGradient = function (r, e, t, o, i, n) {
    var a = this.__createElement("radialGradient", {
      id: kD(this.__ids),
      cx: o + "px",
      cy: i + "px",
      r: n + "px",
      fx: r + "px",
      fy: e + "px",
      gradientUnits: "userSpaceOnUse",
    }, false);
    return this.__defs.appendChild(a), new kv(a, this);
  };
  xt.prototype.__parseFont = function () {
    var r =
        /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\'\"\sa-z0-9]+?)\s*$/i,
      e = r.exec(this.font),
      t = {
        style: e[1] || "normal",
        size: e[4] || "10px",
        family: e[6] || "sans-serif",
        weight: e[3] || "normal",
        decoration: e[2] || "normal",
        href: null,
      };
    return this.__fontUnderline === "underline" &&
      (t.decoration = "underline"),
      this.__fontHref && (t.href = this.__fontHref),
      t;
  };
  xt.prototype.__wrapTextLink = function (r, e) {
    if (r.href) {
      var t = this.__createElement("a");
      return t.setAttributeNS(
        "http://www.w3.org/1999/xlink",
        "xlink:href",
        r.href,
      ),
        t.appendChild(e),
        t;
    }
    return e;
  };
  xt.prototype.__applyText = function (r, e, t, o) {
    var i = this.__parseFont(),
      n = this.__closestGroupOrSvg(),
      a = this.__createElement("text", {
        "font-family": i.family,
        "font-size": i.size,
        "font-style": i.style,
        "font-weight": i.weight,
        "text-decoration": i.decoration,
        x: e,
        y: t,
        "text-anchor": kie(this.textAlign),
      }, true);
    a.appendChild(this.__document.createTextNode(r)),
      this.__currentElement = a,
      this.__applyStyleToCurrentElement(o),
      n.appendChild(this.__wrapTextLink(i, a));
  };
  xt.prototype.fillText = function (r, e, t) {
    this.__applyText(r, e, t, "fill");
  };
  xt.prototype.strokeText = function (r, e, t) {
    this.__applyText(r, e, t, "stroke");
  };
  xt.prototype.measureText = function (r) {
    return this.__ctx.font = this.font, this.__ctx.measureText(r);
  };
  xt.prototype.arc = function (r, e, t, o, i, n) {
    if (o !== i) {
      o = o % (2 * Math.PI),
        i = i % (2 * Math.PI),
        o === i &&
        (i = (i + 2 * Math.PI - .001 * (n ? -1 : 1)) % (2 * Math.PI));
      var a = r + t * Math.cos(i),
        s = e + t * Math.sin(i),
        l = r + t * Math.cos(o),
        c = e + t * Math.sin(o),
        d = n ? 0 : 1,
        p = 0,
        h = i - o;
      h < 0 && (h += 2 * Math.PI),
        n ? p = h > Math.PI ? 0 : 1 : p = h > Math.PI ? 1 : 0,
        this.lineTo(l, c),
        this.__addPathCommand(
          Da(
            "A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}",
            {
              rx: t,
              ry: t,
              xAxisRotation: 0,
              largeArcFlag: p,
              sweepFlag: d,
              endX: a,
              endY: s,
            },
          ),
        ),
        this.__currentPosition = { x: a, y: s };
    }
  };
  xt.prototype.clip = function () {
    var r = this.__closestGroupOrSvg(),
      e = this.__createElement("clipPath"),
      t = kD(this.__ids),
      o = this.__createElement("g");
    this.__applyCurrentDefaultPath(),
      r.removeChild(this.__currentElement),
      e.setAttribute("id", t),
      e.appendChild(this.__currentElement),
      this.__defs.appendChild(e),
      r.setAttribute("clip-path", Da("url(#{id})", { id: t })),
      r.appendChild(o),
      this.__currentElement = o;
  };
  xt.prototype.drawImage = function () {
    var r = Array.prototype.slice.call(arguments),
      e = r[0],
      t,
      o,
      i,
      n,
      a = 0,
      s = 0,
      l,
      c,
      d,
      p,
      h,
      u,
      f,
      y,
      C,
      E,
      v;
    if (r.length === 3) {
      t = r[1], o = r[2], l = e.width, c = e.height, i = l, n = c;
    } else if (r.length === 5) {
      t = r[1], o = r[2], i = r[3], n = r[4], l = e.width, c = e.height;
    } else if (r.length === 9) {
      a = r[1],
        s = r[2],
        l = r[3],
        c = r[4],
        t = r[5],
        o = r[6],
        i = r[7],
        n = r[8];
    } else {throw new Error(
        "Invalid number of arguments passed to drawImage: " +
          arguments.length,
      );}
    d = this.__closestGroupOrSvg(), f = this.__currentElement;
    var w = "translate(" + t + ", " + o + ")";
    if (e instanceof xt) {
      if (
        p = e.getSvg().cloneNode(true), p.childNodes && p.childNodes.length > 1
      ) {
        for (h = p.childNodes[0]; h.childNodes.length;) {
          v = h.childNodes[0].getAttribute("id"),
            this.__ids[v] = v,
            this.__defs.appendChild(h.childNodes[0]);
        }
        if (u = p.childNodes[1], u) {
          var S = u.getAttribute("transform"), k;
          S ? k = S + " " + w : k = w,
            u.setAttribute("transform", k),
            d.appendChild(u);
        }
      }
    } else {(e.nodeName === "CANVAS" || e.nodeName === "IMG") &&
        (y = this.__createElement("image"),
          y.setAttribute("width", i),
          y.setAttribute("height", n),
          y.setAttribute("opacity", this.globalAlpha),
          y.setAttribute("preserveAspectRatio", "none"),
          (a || s || l !== e.width || c !== e.height) &&
          (C = this.__document.createElement("canvas"),
            C.width = i,
            C.height = n,
            E = C.getContext("2d"),
            E.drawImage(e, a, s, l, c, 0, 0, i, n),
            e = C),
          y.setAttribute("transform", w),
          y.setAttribute(
            "xlink:href",
            e.nodeName === "CANVAS" ? e.toDataURL() : e.getAttribute("src"),
          ),
          d.appendChild(y));}
  };
  xt.prototype.createPattern = function (r, e) {
    var t = this.__document.createElementNS(
        "http://www.w3.org/2000/svg",
        "pattern",
      ),
      o = kD(this.__ids),
      i;
    return t.setAttribute("id", o),
      t.setAttribute("width", r.width),
      t.setAttribute("height", r.height),
      r.nodeName === "CANVAS" || r.nodeName === "IMG"
        ? (i = this.__document.createElementNS(
          "http://www.w3.org/2000/svg",
          "image",
        ),
          i.setAttribute("width", r.width),
          i.setAttribute("height", r.height),
          i.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            r.nodeName === "CANVAS" ? r.toDataURL() : r.getAttribute("src"),
          ),
          t.appendChild(i),
          this.__defs.appendChild(t))
        : r instanceof xt &&
          (t.appendChild(r.__root.childNodes[1]), this.__defs.appendChild(t)),
      new zP(t, this);
  };
  xt.prototype.setLineDash = function (r) {
    r && r.length > 0 ? this.lineDash = r.join(",") : this.lineDash = null;
  };
  xt.prototype.ellipse = function (r, e, t, o, i, n, a, s) {
    if (n !== a) {
      n = n % (2 * Math.PI),
        a = a % (2 * Math.PI),
        n === a &&
        (a = (a + 2 * Math.PI - .001 * (s ? -1 : 1)) % (2 * Math.PI));
      var l = r + Math.cos(-i) * t * Math.cos(a) +
          Math.sin(-i) * o * Math.sin(a),
        c = e - Math.sin(-i) * t * Math.cos(a) +
          Math.cos(-i) * o * Math.sin(a),
        d = r + Math.cos(-i) * t * Math.cos(n) +
          Math.sin(-i) * o * Math.sin(n),
        p = e - Math.sin(-i) * t * Math.cos(n) +
          Math.cos(-i) * o * Math.sin(n),
        h = s ? 0 : 1,
        u = 0,
        f = a - n;
      f < 0 && (f += 2 * Math.PI),
        s ? u = f > Math.PI ? 0 : 1 : u = f > Math.PI ? 1 : 0,
        this.lineTo(d, p),
        this.__addPathCommand(
          Da(
            "A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}",
            {
              rx: t,
              ry: o,
              xAxisRotation: i * (180 / Math.PI),
              largeArcFlag: u,
              sweepFlag: h,
              endX: l,
              endY: c,
            },
          ),
        ),
        this.__currentPosition = { x: l, y: c };
    }
  };
  xt.prototype._dcgSetTitle = function (r) {
    var e = this.__currentElement,
      t = false,
      o,
      i = e.getElementsByTagName("title");
    i.length > 0 ? o = i[0] : (o = this.__document.createElementNS(
      "http://www.w3.org/2000/svg",
      "title",
    ),
      t = true),
      o.textContent = r,
      t && e.appendChild(o);
  };
  xt.prototype.drawFocusRing = function () {};
  xt.prototype.createImageData = function () {};
  xt.prototype.getImageData = function () {};
  xt.prototype.putImageData = function () {};
  xt.prototype.globalCompositeOperation = function () {};
  xt.prototype.setTransform = function () {};
  var PK = xt;
  var Bp = class r extends cs {
    constructor() {
      super();
      this.highlightPropertyMultipliers = {};
      this.stateProperties = [],
        this.cloneProperties = [],
        this.highlightPropertyMultipliers = {},
        this.config = new cs();
      for (let t in Os) {
        Os.hasOwnProperty(t) && this.addStateProperty(t, Os[t]);
      }
      this.setProperty("labelHangingColor", "rgba(150,150,150,1)"),
        this.setProperty("lastChangedAxis", "x"),
        this.addDynamicProperties();
    }
    addDynamicProperties() {
      let t = this;
      function o(n, a, s) {
        t.cloneProperties.push(n);
        function l() {
          t.setProperty(n, t.config.projectorMode ? s : a);
        }
        t.config.observe("projectorMode", l), l();
      }
      function i(n, a, s, l, c) {
        t.cloneProperties.push(n);
        function d() {
          let h;
          t.config.projectorMode
            ? h = t.highlight ? c : l
            : h = t.highlight ? s : a, t.setProperty(n, h);
        }
        let p = [a, s, l, c];
        t.highlightPropertyMultipliers[n] = p.map((h) => h / p[0]),
          t.observe("highlight", d),
          t.config.observe("projectorMode", d),
          d();
      }
      o("labelSize", 14, 19),
        o("majorAxisOpacity", .4, 1),
        o("minorAxisOpacity", .12, .25),
        o("axisOpacity", .9, .9),
        o("axisLineWidth", 1.5, 2),
        o("axisLineOffset", .25, 0),
        o("pixelsPerLabel", 80, 120),
        i("curveOpacity", .7, 1, .7, 1),
        o("globalCurveColor", void 0, void 0),
        o("disableFill", false, false),
        i("graphLineWidth", 2.5, 3.5, 5, 7),
        i("pointLineWidth", 8, 8 * 1.2, 8 * 1.3, 8 * 1.2 * 1.3);
    }
    setController(t) {
      this.controller = t, this.registerCallbacks();
    }
    getHighlightPropertyMultiplier(t, o) {
      let i = o ? 1 : 0;
      return this.config.projectorMode
        ? this.highlightPropertyMultipliers[t][2 + i]
        : this.highlightPropertyMultipliers[t][i];
    }
    getFillOpacityMultiplier() {
      return this.highlight && this.controller &&
          this.controller.isGeometry()
        ? 1.3
        : 1;
    }
    addStateProperty(t, o) {
      this[t] = o, this.stateProperties.push(t), this.cloneProperties.push(t);
    }
    static fromObject(t) {
      let o = new r();
      return o.cloneProperties.forEach((i) => {
        t.hasOwnProperty(i) && o.setProperty(i, t[i]);
      }),
        o;
    }
    registerCallbacks() {
      let t = () => {
        var o;
        (o = this.controller) == null || o.requestRedrawGraph();
      };
      this.stateProperties.forEach((o) => {
        this.observe(o, t);
      }),
        this.config.observe("backgroundColor", t),
        this.config.observe("textColor", t),
        this.config.observe("invertedColors", t),
        this.observe("backgroundColor", t),
        this.observe("textColor", t),
        this.config.observe("enableTabindex", t),
        this.config.observeAndSync("projectorMode", t);
    }
    _validateSetting(t, o) {
      let i;
      switch (t) {
        case "xAxisMinorSubdivisions":
        case "yAxisMinorSubdivisions":
          i = Math.round(Math.min(Math.max(0, o), 5)),
            o !== i &&
            __dcg_shared_module_exports__["qe"].warn(
              "minorSubdivisions must be an integer between 0 and 5. You provided " +
                o + ", which we changed to " + i + ".",
            );
          break;
        case "degreeMode":
        case "projectorMode":
        case "showGrid":
        case "showXAxis":
        case "showYAxis":
        case "xAxisNumbers":
        case "yAxisNumbers":
        case "polarNumbers":
        case "enableTabindex":
        case "invertedColors":
        case "complex":
          i = o === "false" ? false : !!o,
            o !== i &&
            __dcg_shared_module_exports__["qe"].warn(
              t + " must be a Boolean. You provided " + o + " (" +
                typeof o + "), which we changed to " + i + " (" +
                typeof i + ").",
            );
          break;
        case "xAxisStep":
        case "yAxisStep":
          i = parseFloat(o),
            isFinite(o) ||
            (i = 0,
              __dcg_shared_module_exports__["qe"].warn(
                t + " must be a number. You provided " + o +
                  ", which we changed to " + i + ".",
              ));
          break;
        case "xAxisScale":
        case "yAxisScale":
          i = o,
            !this.config.logScales && o === "logarithmic"
              ? (i = "linear",
                __dcg_shared_module_exports__["qe"].warn(
                  "Must set logScales: true to set " + t +
                    " to 'logarithmic'.",
                ))
              : o !== "linear" && o !== "logarithmic" &&
                (i = "linear",
                  __dcg_shared_module_exports__["qe"].warn(
                    t +
                      ' must be "linear" or "logarithmic". You provided ' +
                      o + ", which we changed to " + i + ".",
                  ));
          break;
        case "xAxisArrowMode":
        case "yAxisArrowMode":
          i = __dcg_shared_module_exports__["pd"][o],
            i !== o &&
            (i = "NONE",
              __dcg_shared_module_exports__["qe"].warn(
                `unknown AxisArrowMode. Allowed values are: 
` +
                  __dcg_shared_module_exports__["B"](
                    __dcg_shared_module_exports__["pd"],
                  ).join(`
`),
              ));
          break;
        case "xAxisLabel":
        case "yAxisLabel":
          i = o,
            typeof o != "string" &&
            (i = "",
              __dcg_shared_module_exports__["qe"].warn(
                t + " must be a string. you provided a " + typeof o + ".",
              ));
          break;
        case "randomSeed":
          i = o,
            typeof o != "string" &&
            (i = "" + o,
              __dcg_shared_module_exports__["qe"].warn(
                "randomSeed must be a string. you provided a " +
                  typeof o + ".",
              ));
          break;
        case "backgroundColor":
          i = o,
            typeof o != "string" &&
            (i = "",
              __dcg_shared_module_exports__["qe"].warn(
                t + " must be a string. you provided a " + typeof o + ".",
              )),
            i || (i = "#fff"),
            i[0] !== "#" && (i = "#" + i);
          break;
        case "textColor":
          i = o,
            typeof o != "string" &&
            (i = "",
              __dcg_shared_module_exports__["qe"].warn(
                t + " must be a string. you provided a " + typeof o + ".",
              )),
            i || (i = "#000"),
            i[0] !== "#" && (i = "#" + i);
          break;
        case "fontSize":
          i = o,
            typeof o != "number" &&
            (i = parseInt(i, 10),
              __dcg_shared_module_exports__["qe"].warn(
                "fontSize must be a number. Attempted to convert " + o +
                  " to " + i + ".",
              ));
          break;
        case "language":
          i = o,
            typeof o != "string" &&
            (i = "",
              __dcg_shared_module_exports__["qe"].warn(
                t + " must be a string. you provided a " + typeof o + ".",
              )),
            o !== "en" && !_T(o) &&
            (i = "en",
              __dcg_shared_module_exports__["qe"].warn(
                o + " is not currently an available language.",
              ));
          break;
        default:
          i = o;
          break;
      }
      return i;
    }
    validateSettings(t) {
      let o = {}, i = false;
      for (let n in t) {
        this.stateProperties.indexOf(n) >= 0
          ? o[n] = this._validateSetting(n, t[n])
          : (__dcg_shared_module_exports__["qe"].warn(
            'Invalid graph setting "' + n + '".',
          ),
            i = true);
      }
      return i &&
        __dcg_shared_module_exports__["qe"].warn(
          `Available graph settings are: 
` + this.stateProperties.join(`
`),
        ),
        this.config.allowComplex ||
        o.complex &&
          (__dcg_shared_module_exports__["qe"].warn(
            "complex: true is not compatible with allowComplex: false. Forcing complex: false",
          ),
            o.complex = false),
        o.complex &&
        (o.degreeMode &&
          __dcg_shared_module_exports__["qe"].warn(
            "degreeMode: true is not compatible with complex: true. Forcing degreeMode: false",
          ),
          o.degreeMode = false),
        o;
    }
    getConfiguredBackgroundColor() {
      return __dcg_shared_module_exports__["Id"](
        this.config.backgroundColor || "#fff",
      );
    }
    getBackgroundColor({ invertWhite: t } = { invertWhite: false }) {
      let o = this.getConfiguredBackgroundColor();
      return this.config.invertedColors && t
        ? __dcg_shared_module_exports__["Md"](o)
        : o;
    }
    getConfiguredTextColor() {
      return __dcg_shared_module_exports__["Id"](
        this.config.textColor || "#000",
      );
    }
    getTextColor({ invertBlack: t } = { invertBlack: false }) {
      let o = this.getConfiguredTextColor();
      return this.config.invertedColors && t
        ? __dcg_shared_module_exports__["Md"](o)
        : o;
    }
    cloneConfig() {
      let t = {};
      for (let o of Object.keys(sy)) {
        t[o] = __dcg_shared_module_exports__["Jc"](this.config[o]);
      }
      return t;
    }
  };
  qt();
  var _D = class {
    constructor(e, t) {
      this.is3d = true;
      this.color = "#000000",
        this.showHighlight = false,
        this.selected = false,
        this.hoistToTop = false,
        this.id = e,
        this.branches = t !== void 0 ? t : [];
    }
    updateFrom(e) {
      e &&
        (this.showHighlight = e.showHighlight,
          this.hoistToTop = e.hoistToTop,
          this.selected = e.selected);
    }
  };
  function OK(r) {
    return r.is3d;
  }
  function ul(r, e) {
    if (
      OK(e) ||
      r.isGeoUIActive() &&
        r.getAllToolPreviewItems().filter((o) => o.id === e.id).length > 0
    ) return false;
    for (let t of e.branches) {
      if (kc(t, r.getGraphSettings().config.audioTraceSimult)) return true;
    }
    return false;
  }
  function kc(r, e) {
    if (r) {
      switch (r.graphMode) {
        case 8:
        case 5:
        case 6:
          return e && r.segments.length > 0;
        case 1:
        case 2:
        case 3:
        case 4:
        case 25:
        case 26:
          return r.segments.length > 0;
        default:
          return false;
      }
    }
  }
  function RK(r, e) {
    for (let t = 0; t < r.branches.length; t++) {
      if (kc(r.branches[t], e)) return t;
    }
    return 0;
  }
  function _v(r, e, t) {
    let o = 0;
    for (let i = 0; i <= e; i++) kc(r.branches[i], t) && (o += 1);
    return o;
  }
  function FK(r) {
    switch (r.graphMode) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 25:
      case 26:
        return true;
      default:
        return false;
    }
  }
  function NK(r, e) {
    switch (e) {
      case 2:
      case 8:
      case 5:
      case 6:
      case 3:
      case 4:
      case 25:
      case 26:
        return {
          independentMin: r.xmin,
          independentMax: r.xmax,
          dependentMin: r.ymin,
          dependentMax: r.ymax,
        };
      case 1:
        return {
          independentMin: r.ymin,
          independentMax: r.ymax,
          dependentMin: r.xmin,
          dependentMax: r.xmax,
        };
      default:
        throw qP(e);
    }
  }
  function qP(r) {
    return `Unexpected graph mode. Received ${r}`;
  }
  function HP(r) {
    let e = Math.random() * 2 - 1;
    return (r + .2 * e) / 1.02;
  }
  function BK(r, e) {
    if (r === 1) return e.y;
    if (r === 2 || r === 8 || r === 5 || r === 6) return e.x;
    throw qP(r);
  }
  function UK(r, e) {
    let t = ([o, i]) => {
      let n = e != null && e.degreeMode ? o * Math.PI / 180 : o;
      return [i * Math.cos(n), i * Math.sin(n)];
    };
    return __dcg_shared_module_exports__["t"](
      __dcg_shared_module_exports__["y"](r, 2).map((o) => t(o)),
      true,
    );
  }
  function KP(r, e, t) {
    let o = vu(r, e.mathToPixels, t),
      i = Z3(o, {
        xmin: 0,
        xmax: e.screen.width,
        ymin: 0,
        ymax: e.screen.height,
      }),
      n = e.pixelsToMath;
    return t === ef &&
      (n = new __dcg_shared_module_exports__["jd"](n.yScale, n.xScale)),
      i.map((s) => vu(s, n, t));
  }
  function zK(r, e) {
    return r[0] - e[0];
  }
  function qK(r) {
    switch (r.graphMode) {
      case 2:
      case 3:
      case 4:
      case 25:
      case 26:
        return { independent: r.x, dependent: r.y };
      case 1:
        return { independent: r.y, dependent: r.x };
      default:
        throw qP(r.graphMode);
    }
  }
  var _ie = .1;
  function WP(r) {
    return r < 0 ? _ie : 0;
  }
  function Iv(r) {
    var k;
    let e = r.getGrapher();
    if (!e) return "";
    let t = e.viewportController.getViewport(),
      o = e.getProjection(),
      {
        showGrid: i,
        showXAxis: n,
        xAxisNumbers: a,
        showYAxis: s,
        yAxisNumbers: l,
        xAxisLabel: c,
        yAxisLabel: d,
      } = e.settings,
      p = false,
      h = "",
      u = false,
      f = [],
      y = Ao(
        __dcg_shared_module_exports__["OoLabel"].value(t.xmin, Ng(o, t.xmin))
          .latex,
      ),
      C = Ao(
        __dcg_shared_module_exports__["OoLabel"].value(t.xmax, Ng(o, t.xmax))
          .latex,
      ),
      E = Ao(
        __dcg_shared_module_exports__["OoLabel"].value(t.ymin, jT(o, t.ymin))
          .latex,
      ),
      v = Ao(
        __dcg_shared_module_exports__["OoLabel"].value(t.ymax, jT(o, t.ymax))
          .latex,
      ),
      w = t.zmin
        ? Ao(__dcg_shared_module_exports__["OoLabel"].value(t.zmin).latex)
        : "",
      S = t.zmax
        ? Ao(__dcg_shared_module_exports__["OoLabel"].value(t.zmax).latex)
        : "";
    if (r.is3dProduct()) {
      let { xmin: _, xmax: A, ymin: P, ymax: O, zmin: U, zmax: z } = t,
        { showAxis3D: x, showNumbers3D: L, showPlane3D: V } = e.settings;
      _ === P && _ === U && A === O && A === z && x
        ? (n = s = p = false,
          f.push(
            r.s(
              "graphing-calculator-narration-audio-trace-description-visible-xyz-axis-range",
              { xmin: y, xmax: C },
            ),
          ))
        : (n = s = p = x, c = d = h = "", a = l = u = L, i = n && V);
    }
    if (
      n && (a && c !== ""
        ? f.push(
          r.s(
            "graphing-calculator-narration-audio-trace-description-visible-x-axis-range-and-label",
            { xmin: y, xmax: C, label: c },
          ),
        )
        : a && c === ""
        ? f.push(
          r.s(
            "graphing-calculator-narration-audio-trace-description-visible-x-axis-range",
            { xmin: y, xmax: C },
          ),
        )
        : !a && c !== ""
        ? f.push(
          r.s(
            "graphing-calculator-narration-audio-trace-description-visible-x-axis-and-label",
            { label: c },
          ),
        )
        : !a && c === "" &&
          f.push(
            r.s(
              "graphing-calculator-narration-audio-trace-description-visible-x-axis",
            ),
          )),
        s && (l && d !== ""
          ? f.push(
            r.s(
              "graphing-calculator-narration-audio-trace-description-visible-y-axis-range-and-label",
              { ymin: E, ymax: v, label: d },
            ),
          )
          : l && d === ""
          ? f.push(
            r.s(
              "graphing-calculator-narration-audio-trace-description-visible-y-axis-range",
              { ymin: E, ymax: v },
            ),
          )
          : !l && d !== ""
          ? f.push(
            r.s(
              "graphing-calculator-narration-audio-trace-description-visible-y-axis-and-label",
              { label: d },
            ),
          )
          : !l && d === "" &&
            f.push(
              r.s(
                "graphing-calculator-narration-audio-trace-description-visible-y-axis",
              ),
            )),
        p && (u && h !== ""
          ? f.push(
            r.s(
              "graphing-calculator-narration-audio-trace-description-visible-z-axis-range-and-label",
              { zmin: w, zmax: S, label: h },
            ),
          )
          : u && h === ""
          ? f.push(
            r.s(
              "graphing-calculator-narration-audio-trace-description-visible-z-axis-range",
              { zmin: w, zmax: S },
            ),
          )
          : !u && h !== ""
          ? f.push(
            r.s(
              "graphing-calculator-narration-audio-trace-description-visible-z-axis-and-label",
              { label: h },
            ),
          )
          : !u && h === "" &&
            f.push(
              r.s(
                "graphing-calculator-narration-audio-trace-description-visible-z-axis",
              ),
            )),
        i &&
        f.push(
          r.s(
            "graphing-calculator-narration-audio-trace-description-visible-grid",
          ),
        ),
        r.is3dProduct() && f.push(Iie(r)),
        !r.isGeometry() && !r.is3dProduct()
    ) {
      let _ = (k = r.getGrapher()) == null ? void 0 : k.graphSketches,
        A = 0;
      for (let P in _) ul(r, _[P]) && (A += 1);
      f.push(
        r.s(
          "graphing-calculator-narration-audio-trace-traceable-curves",
          { sketchCount: __dcg_shared_module_exports__["ra"](A) },
        ),
      );
    }
    return f.join(" ").trim();
  }
  function Iie(r) {
    return "";
  }
  function Aie(r, e, t) {
    return {
      x: r.x,
      y: r.y,
      branch: r.branch,
      reportedBranch: t,
      type: r.type,
      graphMode: e,
      intersects: r.intersects,
    };
  }
  var py = 101,
    ID = class {
      constructor(e, t, o) {
        this.grapher = o,
          this.controller = e,
          this.audiograph = t,
          this.reset();
      }
      reset() {
        this.currentPoint = void 0,
          this.resetToFirstBranch(),
          this.sampledPoints = [],
          this.pois = [],
          this.independent = 0;
      }
      resetToFirstBranch() {
        let e = this.getCurrentSketch();
        this.branch = e
          ? RK(e, this.grapher.settings.config.audioTraceSimult)
          : 0;
      }
      resetTracePoint() {
        this.grapher.traceLayer.setTraceInfo(void 0),
          this.grapher.traceLayer.setTraceLine(void 0),
          this.drawTracePoint(this.getCurrentPoint());
      }
      drawTracePoint(e) {
        let t = this.getCurrentSketch();
        if (!e || !t) return;
        let o = t.branches[this.branch];
        if (!o) return;
        let i = o.graphMode;
        if (__dcg_shared_module_exports__["N"](i)) return;
        let n = { x: e.x, y: e.y },
          a = {
            branchInfo: { branch: e.branch, id: t.id, sketch: t },
            pt: n,
          };
        __dcg_shared_module_exports__["E"](
          a,
          this.grapher.traceLayer.getTraceInfo(),
        ) ||
          (this.grapher.traceLayer.setTraceInfo(a),
            this.controller.requestRedrawGraph());
      }
      drawTraceLine(e, t) {
        if (e === void 0 || !t) return;
        let o = this.getCurrentSketch();
        t === 1
          ? this.grapher.traceLayer.setTraceLine({
            x: void 0,
            y: e,
            color: o == null ? void 0 : o.color,
          })
          : this.grapher.traceLayer.setTraceLine({
            x: e,
            y: void 0,
            color: o == null ? void 0 : o.color,
          });
      }
      moveToOrigin() {
        let e = this.getCurrentSketch();
        if (!e || !ul(this.controller, e)) return;
        let t = e.branches[this.branch];
        if (!kc(t, this.grapher.settings.config.audioTraceSimult)) return;
        let o = t.graphMode;
        if (o === 2) this.setIndependent("x", 0);
        else if (o === 1) this.setIndependent("y", 0);
        else if (__dcg_shared_module_exports__["N"](o)) {
          let i = this.getSortedPOI()[0];
          this.setIndependent("x", i ? i.x : 0);
        }
      }
      getCurrentSketch() {
        let e, t = this.controller.getSelectedItem();
        if (t) {
          if (t.type === "table") {
            let o = this.audiograph.getFocusedTableLocation();
            if (
              o && (e = this.getGraphSketchForTableLocation(t, o)), !e
            ) {
              for (let i of t.columnModels) {
                if (
                  e = this.grapher.getGraphSketch(i.id), e !== void 0
                ) break;
              }
            }
          } else e = this.grapher.getGraphSketch(t.id);
        }
        return e;
      }
      getFirstTraceableSketch(e) {
        let [t] = this.getTraceableCurves(
          void 0,
          this.controller.shouldAudioTraceReverseExpressions() ? "up" : "down",
        );
        if (t) {
          let o = this.controller.getItemModelByIndex(t.expressionIndex);
          if (!o) return;
          let i;
          switch (t.type) {
            case "expression":
              i = this.grapher.getGraphSketch(o.id);
              break;
            case "table":
              e != null && e.selectAssociatedExpression &&
              this.audiograph.setFocusedTableLocation(t.location),
                i = this.getGraphSketchForTableLocation(o, t.location);
              break;
            default:
              let n = t;
              throw new Error(`Unexpected curve type ${n}`);
          }
          if (i) {
            return e != null && e.selectAssociatedExpression &&
              this.controller.dispatch({
                type: "set-selected-index",
                index: t.expressionIndex,
              }),
              i;
          }
        }
      }
      canTrace(e) {
        if (!e || e.type === "image" || e.type === "text") return false;
        let t;
        if (e.type === "expression" && e.shouldGraph) {
          t = this.grapher.getGraphSketch(e.id);
        } else if (e.type === "table") {
          for (let o of e.columnModels) {
            if (o.shouldGraph) {
              t = this.grapher.getGraphSketch(o.id);
              break;
            }
          }
        }
        return t ? ul(this.controller, t) : false;
      }
      getTraceableExpressionCount() {
        let e = 0, t = this.controller.getItemCount();
        for (let o = 0; o < t; o++) {
          let i = this.controller.getItemModelByIndex(o);
          i && this.canTrace(i) && e++;
        }
        return e;
      }
      computeStepSizes() {
        let e = this.grapher.getProjection().viewport;
        if (!e) return;
        let t = e.xmin,
          o = e.xmax,
          i = e.ymin,
          n = e.ymax,
          a = this.getCurrentSketch();
        if (!a || !ul(this.controller, a)) return;
        let s = a.branches[this.branch];
        if (!kc(s, this.grapher.settings.config.audioTraceSimult)) return;
        let l = s.graphMode;
        if (l === 2) {
          this.independent < t
            ? this.independent = t
            : this.independent > o && (this.independent = o);
        } else if (l === 1) {
          this.independent < i
            ? this.independent = i
            : this.independent > n && (this.independent = n);
        } else if (__dcg_shared_module_exports__["N"](l)) {
          let c, d;
          this.independent < t
            ? (d = this.getSortedPOI()[0],
              this.independent = d && d.x !== void 0 ? d.x : 0)
            : this.independent > o &&
              (c = this.getSortedPOI(),
                d = c[c.length - 1],
                this.independent = d && d.x !== void 0 ? d.x : 0);
        }
      }
      getPoint(e, t) {
        let o, i = this.getCurrentSketch();
        if (!i || !ul(this.controller, i)) return o;
        let n, a, s = 0, l = i.branches[e];
        if (!l) return;
        let c = _v(i, e, this.grapher.settings.config.audioTraceSimult);
        "compiled" in l && l.compiled && (a = l.compiled.fn);
        let d = l.graphMode,
          p = this.grapher.getProjection(),
          { mathToPixels: h, pixelsToMath: u, screen: f } = p;
        if (d === 2 || d === 8) {
          let y = u.mapX(h.mapX(t) + f.width / (py - 1));
          n = this.getInterveningPOIs(t, y, e, d)[0],
            (!n || n.x !== t || n.branch !== e) &&
            (n = void 0, s = a ? a(t) : 0),
            n
              ? o = {
                x: n.x,
                y: n.y,
                type: n.type,
                typeChain: n.typeChain,
                branch: n.branch,
                reportedBranch: c,
                graphMode: d,
                intersects: n.intersects,
              }
              : a &&
                (o = {
                  x: t,
                  y: s,
                  branch: e,
                  reportedBranch: c,
                  graphMode: d,
                });
        } else if (d === 1) {
          let y = u.mapY(h.mapY(t) - f.height / (py - 1));
          n = this.getInterveningPOIs(t, y, e, d)[0],
            (!n || n.y !== t || n.branch !== e) &&
            (n = void 0, s = a ? a(t) : 0),
            n
              ? o = {
                x: n.x,
                y: n.y,
                type: n.type,
                typeChain: n.typeChain,
                branch: n.branch,
                reportedBranch: c,
                graphMode: d,
                intersects: n.intersects,
              }
              : a &&
                (o = {
                  y: t,
                  x: s,
                  branch: e,
                  reportedBranch: c,
                  graphMode: d,
                });
        } else if (__dcg_shared_module_exports__["N"](d)) {
          let y = u.mapX(h.mapX(t) + f.width / (py - 1));
          n = this.getInterveningPOIs(t, y, e, d)[0],
            n && n.x === t && n.branch === e
              ? o = {
                x: n.x,
                y: n.y,
                type: n.type,
                typeChain: n.typeChain,
                branch: n.branch,
                reportedBranch: c,
                graphMode: d,
                intersects: n.intersects,
              }
              : o = {
                x: t,
                y: NaN,
                branch: e,
                reportedBranch: c,
                graphMode: d,
              };
        }
        return o;
      }
      getSampledPoints() {
        return this.sampledPoints.length === 0 &&
          this.updateSampledPoints(),
          this.sampledPoints;
      }
      updateSampledPoints() {
        let e = this.getCurrentSketch();
        if (!e || !ul(this.controller, e)) return;
        let t = [], o = this.grapher.getProjection(), i = o.viewport;
        for (let n = 0; n < e.branches.length; n++) {
          let a = e.branches[n];
          if (!kc(a, this.grapher.settings.config.audioTraceSimult)) {
            continue;
          }
          let s = a.graphMode, l = 0, c = 0, d = [], p;
          if (s === 2 || __dcg_shared_module_exports__["N"](s)) {
            l = i.xmin,
              c = i.xmax,
              p = (h, u, f) => o.mathToPixels.interpolateX(h, u, f);
          } else if (s === 1) {
            l = i.ymin,
              c = i.ymax,
              p = (h, u, f) => o.mathToPixels.interpolateY(h, u, f);
          } else continue;
          for (let h = 0; h < py; h++) {
            let u = p(l, c, h / (py - 1)),
              f = __dcg_shared_module_exports__["value"](u).value,
              y = p(l, c, (h + 1) / (py - 1)),
              C = __dcg_shared_module_exports__["value"](y).value,
              E = this.getInterveningPOIs(f, C, n, s);
            if (E.length > 0) d.push.apply(d, E);
            else {
              let v = this.getPoint(n, f);
              v && d.push(v);
            }
          }
          t.push.apply(t, this.removeDuplicates(d, s));
        }
        this.sampledPoints = t;
      }
      getCurrentPoint() {
        return this.currentPoint || this.updateCurrentPoint(),
          this.currentPoint;
      }
      updateCurrentPoint(e) {
        if (e) {
          this.currentPoint = e;
          let t = e.graphMode;
          t === 2 || __dcg_shared_module_exports__["N"](t)
            ? this.independent = e.x !== void 0 ? e.x : 0
            : t === 1 && (this.independent = e.y !== void 0 ? e.y : 0),
            this.branch = e.branch;
        } else {this.currentPoint = this.getPoint(
            this.branch,
            this.independent,
          );}
      }
      prevPoint() {
        this.moveToPoint(-1);
      }
      nextPoint() {
        this.moveToPoint(1);
      }
      firstPoint() {
        let e = this.getSampledPoints();
        e.length > 0 && this.updateCurrentPoint(e[0]);
      }
      lastPoint() {
        let e = this.getSampledPoints();
        e.length > 0 && this.updateCurrentPoint(e[e.length - 1]);
      }
      moveToPoint(e) {
        let t = this.getCurrentPoint();
        if (!t) return;
        if (__dcg_shared_module_exports__["N"](t.graphMode)) {
          this.moveToPOI(e);
          return;
        }
        let o = this.getSampledPoints(),
          i = this.getClosestPointIndexOnSameBranch(o, t);
        if (i !== -1) {
          let n = i + e;
          n <= 0
            ? (n = 0,
              yt(
                this.controller.s(
                  "graphing-calculator-narration-audio-trace-first-point",
                ),
              ))
            : n >= o.length - 1 &&
              (n = o.length - 1,
                yt(
                  this.controller.s(
                    "graphing-calculator-narration-audio-trace-last-point",
                  ),
                ));
          let a = o[n];
          this.updateCurrentPoint(a);
        }
      }
      canMoveToPrevPoint() {
        let e = this.getCurrentPoint();
        if (!e) return false;
        if (__dcg_shared_module_exports__["N"](e.graphMode)) {
          return this.canMoveToPrevPOI();
        }
        let t = this.getSampledPoints(),
          o = this.getClosestPointIndexOnSameBranch(t, e);
        return o !== -1 && o > 0;
      }
      canMoveToNextPoint() {
        let e = this.getCurrentPoint();
        if (!e) return false;
        if (__dcg_shared_module_exports__["N"](e.graphMode)) {
          return this.canMoveToNextPOI();
        }
        let t = this.getSampledPoints(),
          o = this.getClosestPointIndexOnSameBranch(t, e);
        return o !== -1 && o < t.length - 1;
      }
      prevPOI() {
        this.moveToPOI(-1);
      }
      nextPOI() {
        this.moveToPOI(1);
      }
      getSortedPOI() {
        return (!this.pois || this.pois.length === 0) && this.updatePOI(),
          this.pois;
      }
      updatePOI() {
        let e = [], t, o = [], i = this.getCurrentSketch();
        if (!(!i || !ul(this.controller, i))) {
          for (let n = 0; n < i.branches.length; n++) {
            let a = i.branches[n];
            if (!a) continue;
            let s = _v(
                i,
                n,
                this.grapher.settings.config.audioTraceSimult,
              ),
              l = a.graphMode;
            if (o = [], t = i.getBranchPOI(n), t.length > 0) {
              l === 2 || __dcg_shared_module_exports__["N"](l)
                ? o = __dcg_shared_module_exports__["q"](t, "x")
                : l === 1 &&
                  (o = __dcg_shared_module_exports__["q"](t, "y"));
              let c = [];
              for (let d of o) c.push(Aie(d, l, s));
              e.push.apply(e, this.removeDuplicates(c, l));
            }
          }
          this.pois = e;
        }
      }
      removeDuplicates(e, t) {
        let o = [];
        for (let i of e) {
          if (i = { ...i }, i.graphMode = t, o.length === 0) {
            o.push(i);
            continue;
          }
          let n = o[o.length - 1];
          __dcg_shared_module_exports__["value"](n.x).value ===
              __dcg_shared_module_exports__["value"](i.x).value &&
            __dcg_shared_module_exports__["value"](n.y).value ===
              __dcg_shared_module_exports__["value"](i.y).value &&
            n.branch === i.branch
            ? (n.typeChain ||
              (n.typeChain = n.type !== void 0 ? [n.type] : []),
              i.type !== void 0 && n.typeChain.indexOf(i.type) === -1 &&
              n.typeChain.push(i.type),
              i.type === 1001 && i.intersects &&
              n.intersects === void 0 && (n.intersects = i.intersects))
            : o.push(i);
        }
        return o;
      }
      getInterveningPOIs(e, t, o, i) {
        let n = [], a = this.getSortedPOI(), s = NaN;
        for (let l of a) {
          l &&
            ((i === 2 || __dcg_shared_module_exports__["N"](i)) &&
                !isNaN(l.x)
              ? s = l.x
              : i === 1 && !isNaN(l.y) && (s = l.y),
              l.branch === o && !isNaN(s) &&
              (e <= s && s < t || t <= s && s < e) && n.push(l));
        }
        return e > t ? n.reverse() : n;
      }
      setIndependent(e, t) {
        let o = this.getSampledPoints();
        for (let n of o) {
          if (n && n.hasOwnProperty(e) && n[e] === t) {
            if (e === "x") {
              this.independent = n.x !== void 0 ? n.x : 0,
                this.updateCurrentPoint();
              return;
            } else if (e === "y") {
              this.independent = n.y !== void 0 ? n.y : 0,
                this.updateCurrentPoint();
              return;
            }
          }
        }
        let i = true;
        if (o.length > 0) {
          let n = Math.floor((o.length - 1) / 2), a = o[n];
          a &&
            (e === "x"
              ? (this.independent = a.x !== void 0 ? a.x : 0, i = false)
              : e === "y" &&
                (this.independent = a.y !== void 0 ? a.y : 0, i = false));
        }
        i && (this.independent = 0),
          this.resetToFirstBranch(),
          this.updateCurrentPoint();
      }
      moveToPOI(e) {
        if (!this.getCurrentPoint()) return;
        let o = this.getSampledPoints(),
          i = this.getPOIIndexByDirection(e);
        i === -1
          ? yt(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-no-more-pois",
            ),
          )
          : this.updateCurrentPoint(o[i]);
      }
      getPOIIndexByDirection(e) {
        let t = this.getCurrentPoint();
        if (!t) return -1;
        let o = this.getSampledPoints(),
          i = this.getClosestPointIndexOnSameBranch(o, t),
          n = -1;
        if (i !== -1) {
          let a = t.graphMode, s = e === 1 ? o.length - 1 : 0;
          for (let l = i; l !== s + e; l += e) {
            let c = o[l];
            if (
              ((a === 2 || __dcg_shared_module_exports__["N"](a)) &&
                  t.x !== c.x || a === 1 && t.y !== c.y) &&
              c.type !== void 0
            ) {
              n = l;
              break;
            }
          }
        }
        return n;
      }
      canMoveToPrevPOI() {
        return this.getPOIIndexByDirection(-1) !== -1;
      }
      canMoveToNextPOI() {
        return this.getPOIIndexByDirection(1) !== -1;
      }
      getClosestPointIndexOnSameBranch(e, t) {
        let o = -1, i = 1 / 0;
        if (e.length > 0 && t) {
          let n = t.graphMode;
          for (let a = 0; a < e.length; a++) {
            let s = e[a];
            if (t.branch !== s.branch) continue;
            let l;
            n === 2 || __dcg_shared_module_exports__["N"](n)
              ? l = Math.abs(s.x - t.x)
              : l = Math.abs(s.y - t.y), l < i && (o = a, i = l);
          }
        }
        return o;
      }
      prevCurve() {
        this.controller.shouldAudioTraceReverseExpressions()
          ? this.switchCurves("down")
          : this.switchCurves("up");
      }
      nextCurve() {
        this.controller.shouldAudioTraceReverseExpressions()
          ? this.switchCurves("up")
          : this.switchCurves("down");
      }
      switchCurves(e) {
        let t = this.controller.getSelectedItem();
        if (!t) return;
        let o = e === "down"
          ? this.findNextTraceableIndex(t.index)
          : this.findPrevTraceableIndex(t.index);
        if (o) {
          let i = this.controller.getItemModelByIndex(o.expressionIndex);
          if (!i) return;
          o.type === "table" &&
          this.audiograph.setFocusedTableLocation(o.location),
            this.controller.dispatch({
              type: "set-selected-id",
              id: i.id,
              state: "selected",
            }),
            this.controller.runAfterDispatch(() =>
              this.audiograph.enterAudioTrace()
            );
        }
      }
      canMoveToPrevCurve() {
        let e = this.controller.getSelectedItem();
        return e
          ? this.controller.shouldAudioTraceReverseExpressions()
            ? !!this.findNextTraceableIndex(e.index)
            : !!this.findPrevTraceableIndex(e.index)
          : false;
      }
      canMoveToNextCurve() {
        let e = this.controller.getSelectedItem();
        return e
          ? this.controller.shouldAudioTraceReverseExpressions()
            ? !!this.findPrevTraceableIndex(e.index)
            : !!this.findNextTraceableIndex(e.index)
          : false;
      }
      *getTraceableCurves(e, t = "down") {
        let o = t === "down" ? 1 : -1;
        for (
          let i = e != null
            ? e
            : t === "down"
            ? 0
            : this.controller.getItemCount() - 1;
          t === "down" ? i <= this.controller.getItemCount() - 1 : i >= 0;
          i += o
        ) {
          let n = this.controller.getItemModelByIndex(i);
          if (this.canTrace(n)) {
            if ((n == null ? void 0 : n.type) === "table") {
              let a = [];
              for (let l = 1; l < n.columnModels.length; l += 1) {
                let c = n.columnModels[l];
                c != null && c.shouldGraph &&
                  this.grapher.getGraphSketch(c.id) &&
                  a.push({
                    type: "table",
                    expressionIndex: i,
                    location: {
                      tableId: n.id,
                      type: "cell",
                      location: { column: l, row: 0 },
                    },
                  });
              }
              this.controller.areTableRegressionsEnabled() &&
              n.regression && !n.regression.hidden &&
              a.push({
                type: "table",
                expressionIndex: i,
                location: {
                  type: "table-regression",
                  location: void 0,
                  tableId: n.id,
                },
              }), t === "up" && a.reverse();
              let s = this.audiograph.getFocusedTableLocation();
              if (s) {
                let l = a.findIndex(({ location: c }) =>
                  __dcg_shared_module_exports__["E"](c, s)
                );
                yield* a.slice(l !== -1 ? l : 0);
              } else yield* a;
            } else yield { type: "expression", expressionIndex: i };
          }
        }
      }
      findNextTraceableIndex(e) {
        let [t, o] = this.getTraceableCurves(e, "down");
        return o;
      }
      findPrevTraceableIndex(e) {
        let [t, o] = this.getTraceableCurves(e, "up");
        return o;
      }
      getGraphSketchForTableLocation(e, t) {
        if (!(!e || e.type !== "table")) {
          if (t.type === "cell") {
            let o = e.columnModels[t.location.column];
            if (o) return this.grapher.getGraphSketch(o.id);
          } else if (t.type === "table-regression") {
            let o = e.regression;
            if (o) return this.grapher.getGraphSketch(o.id);
          }
        }
      }
    };
  Ss();
  var HK = __dcg_shared_module_exports__["f"](
    "//tQxAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAIAAAHVwAgICAgICAgICAgICBAQEBAQEBAQEBAQEBgYGBgYGBgYGBgYGBggICAgICAgICAgICAoKCgoKCgoKCgoKCgoMDAwMDAwMDAwMDAwODg4ODg4ODg4ODg4OD///////////////8AAAA5TEFNRTMuOThyAaUAAAAALmcAABRAJAiwQgAAQAAAB1cctrbdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/7UMQAAAjsKyK0YYABp52xtx8wAgAgBd34IAhAgnsECEe7QIAAgsPxACDgcBAEHQfD/g+D4PggCAIf///ghLny4Pg+D5+sHz/wf+XPwfB8H3iMHwfwffUCYPvz/Y7Hg/H4/H4/H4HAwADcoDwAP7XfuAFtXrhzjsjOXP8iCYM4IBVoH2DGAhQR2hm5vikA2IVEPX9nQaITi6IiLCKX/fxcg/DdGmS5BP7fIGQ0hw7DQi5Q//8midImXygdJ0tlz/1NAgXIANV6MA2Vy2y27jv/+1LEBIALOHOTvGGAMXWhbnTxGZ+LOa2FNMsDtj9/jUmPqqqARrNvlVjDDoGZqq0T11A0DVqeEnlQk8q4sVEp0FcqdxLoEJ0RPYWvIlQkbGA0Anw6VJJgqRKw1NJaAXkR4ag0/FwCCABbbdbJA0fzVgdvgvu5Px6Rwiv3VllZVDREqmWntLyBDka3sz951iTve+ddHP0/M3P/+ydU4zbqOZOeop5jfu1kwk8VezPeGc1hRMbWrJNv6SO/fH0Mc15KYvKqAAAAdrdsrbBDuBpp4v/7UsQGgguVE2ekjNP5aSBo6YSNgKAQUoCZEBJK8q73G/nhJFFmLY5dNc4b7gjBRyEs5yjJokY9TBoU/pXQBglyNjeiA87V8vkzaw019YTu2fxY0t6gteLMI37f9fYw7UVnWoE4NJOSpQBu3GfVAIVACgw+IikZZAnB7UKlLGnha4PDbIhsBhk4RYmlE2hYZ8NrQ5HnyEUvZxDyVG1hM33ZZH0OlrJV5///3/51qTGtJgxhREVLEfoO1w6686eRAAAAUicksbA1qegZCe2AuEgJ//tSxAkCDF0XSaw8ailyn+l1h4w1BvVY04S56fYY5nGkBZHMGLBjHDUMlORG4wcCT9R6RB+3vM8jVMU1hmlOoXIOMKqotE2HxWYNJq/7EZ2l63NJ+Z2aTA4Yq+7t0PhOxCz9WP1mA3DJZZGDkRfq+qFAGwhwHUAVqBfDiMUlypaMWApR1VoWLChfUpJzkBDMCTf85UZr6jyHa1psZnTS5iKatTVKcX/Ker9zMvM1T0okGyiQcreJbU1tc+Yj/ms3395FBIADkjlkjbAZNdiwgRD/+1LEBwAL8Tdbp6Rh+XmT6XWHjCx5U4sTCtlUidNtS9I7oUx7oxdIZlOghkIQYzB0vxtMs6QgCg4WMVakQMM5HRfrsdIEftM0yfOHnNGkiPRMoWCKSsxsChat8/vYw4c4t+CMMB5AAAAXZrftWiEVdbSgnURZoWvK2KhK9GfCkIGnQKxIqbYJ0JCNFJ3St1wuUNRLW4Kw5VhLVGrmgYKhhRe1qzzC7SqFFyjJlIqXcPD6gw//epZ9bwQFw+s+rdVAFtzl0AAAA3I3JK0QJxtCHv/7UsQGAApAM0WssGFpSCKqNYMMvgZph6CwIhKEt0yEiMwFKpnDBBajVc5jbTM7KayRt3I43h8Ag05kd9AtqO0bItmf/+Aevzf7dx28sK0hvP//3/izNwf1pfEAgANutuOJACSqWvuW+SKNLQSpOQKsrX3XxnZxy2Rus0Q1irPy9Mkg4kZGJFRQUax4R+jsACwavqYd2bmRX/6VnKrLk2Z2VGYwQNCIEasJh7/oBScAAMtBNgBWssKw0uCAgKkVpJirpZyBklUCwqaSIkW6BgIY//tSxBIDSYw3Km0kSoEzi9KAliSw9QNAydBqoFQVEQNBwiJYiBWdDqxiwVBUGqg6JgaBoGj3//////huVcFQsIRoPjBXLBGA8AkCwOhcD4KAmFAtEYcR6E8gD2OAXJ2N//uSJVZVJNRdh0gkLCwuKioqz4sLC3//////4sLC31ioqKpAoqKirOgFqkxBTUUzLjk4LjKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+1LEIwPAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg==",
  );
  var ah = .075,
    fo = .0015,
    KK = .02,
    WK = 125,
    $K = 330,
    jK = 2e3,
    Gie = 27.5,
    Lie = 4186,
    $P = .04,
    jP = .2,
    YK = 25;
  function XK(r) {
    return r < 2e3 ? .002 : .005;
  }
  function Pie(r) {
    return {
      segments: r.clippedSegments.length,
      totalPoints: r.clippedSegments.map((e) => e.length).reduce(
        (e, t) => e + t,
        0,
      ),
      graphMode: r.graphMode,
      duration: r.duration,
      discrete: r.discrete,
    };
  }
  var Av = class {
    constructor(e, t) {
      this.audioContext = e.audioContext,
        this.audioContext &&
        (this.oscillator = this.audioContext.createOscillator(),
          this.oscillator.setPeriodicWave(e.getBaseWaveform()),
          this.firstHarmonic = this.audioContext.createOscillator(),
          this.firstHarmonic.setPeriodicWave(
            e.getFirstHarmonicWaveform(),
          ),
          this.firstHarmonicGain = this.audioContext.createGain(),
          this.firstHarmonicGain.gain.value = 0,
          this.pan = this.audioContext.createStereoPanner(),
          this.pan.pan.value = 0,
          this.gain = this.audioContext.createGain(),
          this.gain.gain.value = 0,
          this.oscillatorGain = this.audioContext.createGain(),
          this.oscillatorGain.gain.value = .5,
          this.oscillatorGain.connect(this.gain),
          this.oscillator.connect(this.oscillatorGain),
          this.firstHarmonic.connect(this.firstHarmonicGain),
          this.firstHarmonicGain.connect(this.gain),
          this.gain.connect(this.pan),
          this.pan.connect(t),
          this.oscillator.start(),
          this.firstHarmonic.start(),
          this.brownNoiseGain = this.audioContext.createGain(),
          this.brownNoiseGain.gain.value = 0,
          this.brownNoiseSource = this.audioContext.createBufferSource(),
          this.brownNoiseSource.buffer = e.brownNoiseSample,
          this.brownNoiseSource.loop = true,
          this.brownNoiseSource.start(),
          this.brownNoiseSource.connect(this.brownNoiseGain),
          this.brownNoiseGain.connect(this.pan));
    }
    stop(e) {
      let t = Math.max(this.audioContext.currentTime, e);
      this.gain.gain.setTargetAtTime(0, t, fo),
        this.brownNoiseGain.gain.setTargetAtTime(0, t, fo),
        setTimeout(
          () => {
            this.oscillator.stop(),
              this.firstHarmonic.stop(),
              this.brownNoiseSource.stop(),
              this.pan.disconnect();
          },
          1e3 *
              (2 * fo + Math.max(0, e - this.audioContext.currentTime)) +
            1,
        );
    }
  };
  function Vie(r) {
    if (r.length <= 2) return [r];
    let e = __dcg_shared_module_exports__["y"](r, 2),
      t = 0,
      o = [[e[0]]],
      i = e[0][0] < e[1][0];
    for (let n = 1; n < e.length; n++) {
      o[t].push(e[n]),
        n < e.length - 1 && i !== e[n][0] < e[n + 1][0] &&
        (i = !i, t++, o[t] = [e[n]]);
    }
    return o.map((n) => __dcg_shared_module_exports__["t"](n));
  }
  function Oie(r) {
    let e = __dcg_shared_module_exports__["y"](r, 2);
    return e.sort((t, o) => t[0] - o[0]), __dcg_shared_module_exports__["t"](e);
  }
  var AD = class {
    constructor({ controller: e, agNavigator: t, audioEnabled: o }) {
      this.isPlayingOneBranch = false;
      this.FREQ_MIN = WK;
      this.FREQ_MAX = jK;
      this.FREQ_BASE = $K;
      e && (this.controller = e),
        this.audioContextManager = new hb(),
        this.audioGraphNavigator = t,
        this.audioEnabled = o,
        this.screenDuration = 5,
        this.audioVolume = .5;
    }
    getBaseWaveform() {
      var o;
      let e = new Float32Array([0, 1, 0, .25]),
        t = new Float32Array([1, 0, .25, 0]);
      return (o = this.audioContext) == null
        ? void 0
        : o.createPeriodicWave(e, t);
    }
    getFirstHarmonicWaveform() {
      var o;
      let e = new Float32Array([0, 0, 0, .25, 0, 0, 0, 0]),
        t = new Float32Array([1, 0, 1, 0, .25, 0, .3, 0]);
      return (o = this.audioContext) == null
        ? void 0
        : o.createPeriodicWave(e, t);
    }
    async prepareSynthesizer() {
      if (
        !this.audioEnabled() || !this.audioContextManager ||
        !this.audioGraphNavigator
      ) return;
      try {
        this.audioContext =
          (await this.audioContextManager.getResumedAudioContext())
            .audioContext, this.playbackSupported = true;
      } catch (o) {
        this.playbackSupported = false;
        return;
      }
      this.audioContext.destination.disconnect(),
        this.mainGainNode = this.audioContext.createGain(),
        this.mainGainNode.gain.value = this.audioVolume,
        this.mainGainNode.connect(this.audioContext.destination);
      let e = this.audioContext.sampleRate * this.screenDuration;
      this.brownNoiseSample = this.audioContext.createBuffer(
        1,
        e,
        this.audioContext.sampleRate,
      );
      let t = HP(0);
      for (let o = 0; o < e; o++) {
        t = HP(t), this.brownNoiseSample.getChannelData(0)[o] = t;
      }
      if (!this.poiBufferSample) {
        try {
          this.poiBufferSample = await this.audioContext.decodeAudioData(
            HK.buffer.slice(0),
          );
        } catch (o) {
          So(o);
        }
      }
      jE();
    }
    releaseAudio() {
      var e;
      this.stop(), (e = this.audioContextManager) == null || e.suspend();
    }
    synthesizePoint(e, t, o, i) {
      let {
        gain: n,
        brownNoiseGain: a,
        oscillator: s,
        firstHarmonic: l,
        firstHarmonicGain: c,
        pan: d,
      } = i;
      o = Math.max(o, this.audioContext.currentTime);
      let p = this.mapDependentToFrequency(t);
      if (!(!this.viewportBounds || !p)) {
        if (
          t < this.viewportBounds.dependentMin ||
          t > this.viewportBounds.dependentMax
        ) {
          a.gain.setTargetAtTime($P, o, fo),
            a.gain.setTargetAtTime(0, o + ah, fo);
          return;
        }
        s.frequency.setValueAtTime(p, o),
          l.frequency.setValueAtTime(p, o),
          n.gain.setTargetAtTime(1, o, fo),
          e > 0 && c.gain.setTargetAtTime(.15, o, fo),
          a.gain.setTargetAtTime(WP(t), o, fo),
          d.pan.setTargetAtTime(
            this.getPanValueFromIndependent(e),
            o,
            fo,
          ),
          n.gain.setTargetAtTime(0, o + ah, fo),
          c.gain.setTargetAtTime(0, o + ah, fo),
          a.gain.setTargetAtTime(0, o + ah, fo);
      }
    }
    playPoint(e) {
      !FK(e) || !this.audioContextManager ||
        (this.setupScales(e.graphMode),
          this.prepareSynthesizer().then(() => {
            let t = new Av(this, this.mainGainNode);
            this.turnMainGainOn();
            let o = this.audioContext.currentTime,
              { independent: i, dependent: n } = qK(e);
            if (
              !this.mapDependentToFrequency(n) || !this.viewportBounds
            ) {
              t.stop(o);
              return;
            }
            if (this.synthesizePoint(i, n, o, t), e.intersects) {
              let a = this.audioContext.createBufferSource();
              a.connect(t.gain), a.buffer = this.poiBufferSample;
              try {
                a == null || a.start(this.audioContext.currentTime);
              } catch (s) {}
            }
            t.stop(o + ah + fo);
          }));
    }
    playCurrentSketch(e = "sequential") {
      this.audioContextManager && this.prepareSynthesizer().then(() => {
        this.isPlaying = true,
          this.isPlayingOneBranch = false,
          this.controller.runAfterDispatch(() =>
            this.controller.dispatch({ type: "render" })
          ),
          this.prepareToPlay(e),
          this.startPlayingTime = this.audioContext.currentTime + fo,
          this.currentPlayLoopStartTime = this.startPlayingTime,
          this.lagLoggingData || (this.lagLoggingData = {
            startPlayingTime: this.startPlayingTime,
            branchCount: this.branches.length,
            branchInfo: this.branches.map((t) => Pie(t)),
            branchIteratorStartTimes: [],
            branchIteratorRunTimes: [],
            branchIteratorCallCount: 0,
            branchLags: [],
            screenDuration: this.screenDuration,
          }),
          e === "sequential"
            ? (this.currentPlayLoopBranchIndex = 0,
              this.playBranchIterators = [
                this.playBranch(
                  this.currentPlayLoopBranchIndex,
                  this.currentPlayLoopStartTime,
                ),
              ],
              this.lagLoggingData &&
              (this.lagLoggingData.proposedDuration = this.branches
                .reduce((t, o) => {
                  var i;
                  return t + ((i = o.duration) != null ? i : 0);
                }, 0)),
              this.sequentialPlayLoop())
            : e === "simultaneous" &&
              (this.playBranchIterators = this.branches.map((t, o) =>
                this.playBranch(o, this.currentPlayLoopStartTime)
              ),
                this.playBranchIterators.push(
                  this.playBlankSpace(this.currentPlayLoopStartTime),
                ),
                this.simultaneousPlayLoop());
      });
    }
    stop() {
      var i, n, a, s, l, c;
      YE(),
        clearTimeout(this.timeoutId),
        this.isPlaying = false,
        this.startPlayingTime = void 0;
      let e = (i = this.audioContext) == null ? void 0 : i.currentTime;
      if (!e) return;
      this.lagLoggingData &&
        (this.lagLoggingData.actualDuration = e -
          this.lagLoggingData.startPlayingTime,
          this.lagLoggingData.stopPlayingTime = e,
          (a = (n = this.controller).logEvent) == null ||
          a.call(n, { category: "audio-trace", action: "stop-graph" }),
          this.lagLoggingData = void 0);
      let t = (s = this.playBranchIterators) == null
        ? void 0
        : s.map((d) => d.next()).filter((d) => !d.done);
      t == null || t.forEach((d) => {
        var p, h;
        return (h = (p = d.value).synthStopCallback) == null
          ? void 0
          : h.call(p, e);
      }),
        this.playBranchIterators = [],
        (l = this.mainGainNode) == null ||
        l.gain.cancelScheduledValues(e),
        (c = this.mainGainNode) == null ||
        c.gain.setTargetAtTime(0, e, fo);
      let o = this.mainGainNode;
      setTimeout(() => o.disconnect(), 1e3 * 2 * fo + 1),
        this.controller.runAfterDispatch(() =>
          this.controller.dispatch({ type: "render" })
        );
    }
    getGraphMode() {
      if (this.branches) {
        return this.currentPlayLoopBranchIndex !== void 0
          ? this.branches[this.currentPlayLoopBranchIndex].graphMode
          : this.branches[0].graphMode;
      }
    }
    playBranchByIndex(e) {
      this.audioContext && this.prepareSynthesizer().then(() => {
        this.prepareToPlay("simultaneous"),
          this.isPlayingOneBranch = true,
          this.isPlaying = true,
          this.startPlayingTime = this.audioContext.currentTime + fo,
          this.currentPlayLoopStartTime = this.startPlayingTime,
          this.currentPlayLoopBranchIndex = e,
          this.branches[0].graphMode === 8 ||
            this.branches[0].graphMode == 5 ||
            this.branches[0].graphMode == 6
            ? (this.playBranchIterators = this.branches.map((t, o) =>
              this.playBranch(o, this.currentPlayLoopStartTime)
            ),
              this.playBranchIterators.push(
                this.playBlankSpace(this.currentPlayLoopStartTime),
              ))
            : this.playBranchIterators = [
              this.playBranch(e, this.startPlayingTime),
            ],
          this.simultaneousPlayLoop();
      });
    }
    getPlaybackSupported() {
      return this.playbackSupported;
    }
    getIsPlaying() {
      return this.isPlaying;
    }
    getAudioSpeed() {
      return this.screenDuration * 10;
    }
    setAudioSpeed(e) {
      this.screenDuration = e / 10;
    }
    getAudioVolume() {
      return this.audioVolume;
    }
    setAudioVolume(e) {
      var t;
      this.audioVolume = e,
        (t = this.mainGainNode) == null ||
        t.gain.setTargetAtTime(this.audioVolume, 0, fo);
    }
    getCurrentIndependentValue() {
      var o, i;
      if (!this.getIsPlaying() || this.startPlayingTime === void 0) {
        return;
      }
      if (this.isPlayingOneBranch) {
        return (i = (o = this.branches[this.currentPlayLoopBranchIndex])
            .mapTimeToIndependent) == null
          ? void 0
          : i.call(
            o,
            this.audioContext.currentTime - this.startPlayingTime,
          );
      }
      let e = this.audioContext.currentTime - this.startPlayingTime,
        t = 0;
      for (let n of this.branches) {
        if (
          !(!n.duration || !n.mapIndependentToTime ||
            !n.mapTimeToIndependent)
        ) {
          if (e - t >= n.duration) {
            t += n.duration;
            continue;
          }
          return n.mapTimeToIndependent(e - t);
        }
      }
    }
    getCurrentBranchIndex() {
      if (!this.getIsPlaying() || this.startPlayingTime === void 0) {
        return;
      }
      if (this.isPlayingOneBranch) return this.currentPlayLoopBranchIndex;
      let e = this.audioContext.currentTime - this.startPlayingTime,
        t = 0;
      for (let o = 0; o < this.branches.length; o++) {
        let i = this.branches[o];
        if (i.duration) {
          if (e - t >= i.duration) {
            t += i.duration;
            continue;
          }
          return o;
        }
      }
    }
    preprocessBranch(e, t) {
      switch (e.graphMode) {
        case 8:
        case 5:
        case 6:
          let o = [], i = e.segments;
          if (e.graphMode === 6) {
            let n = this.controller.getViewState();
            i = i.map((a) => UK(a, n));
          }
          for (let n of i) {
            let s = KP(n, t, lg);
            o.push(...s.filter((l) => l.length > 2));
          }
          return o = __dcg_shared_module_exports__["t"](
            o.map((n) => Vie(n).map((a) => Oie(a))),
            true,
          ),
            o.sort((n, a) => n[0] - a[0]),
            o.map((n) => ({
              graphMode: e.graphMode,
              discrete: false,
              poi: e.poi,
              clippedSegments: [n],
            })).filter((n) => n.clippedSegments.length > 0);
        case 2:
        case 1: {
          let n = [];
          for (let a of e.segments) {
            let s = e.graphMode === 2 ? lg : ef, l = KP(a, t, s);
            n.push(...l.filter((c) => c.length > 2));
          }
          return n.sort((a, s) => a[0] - s[0]), {
            graphMode: e.graphMode,
            discrete: false,
            clippedSegments: n,
            poi: e.poi,
          };
        }
        case 3:
        case 25:
        case 26:
        case 4: {
          let { viewport: n } = t, a = e.segments[0].slice();
          a.sort(zK);
          let s = [], l = [];
          for (let c of a) {
            s.push(c[0], c[1]),
              c[0] >= n.xmin && c[0] <= n.xmax && c[1] >= n.ymin &&
              c[1] <= n.ymax && l.push(c[0], c[1]);
          }
          return {
            graphMode: 2,
            discrete: true,
            clippedSegments: [l],
            poi: void 0,
          };
        }
        default:
          throw new Error(`Unimplemented graph mode: ${e.graphMode}`);
      }
    }
    turnMainGainOn() {
      var e, t;
      (e = this.mainGainNode) == null || e.gain.cancelScheduledValues(0),
        (t = this.mainGainNode) == null ||
        t.gain.setTargetAtTime(this.audioVolume, 0, fo);
    }
    getPanValueFromIndependent(e) {
      if (!this.independentScale) return 0;
      let t = __dcg_shared_module_exports__["fd"](this.independentScale, e) /
        this.screenDuration;
      return __dcg_shared_module_exports__["clamp"](2 * t - 1, -1, 1);
    }
    setupScales(e) {
      this.projection = this.controller.get2dProjection(),
        this.viewportBounds = NK(this.projection.viewport, e);
      let t = e === 1
          ? this.projection.settings.yAxisScale
          : this.projection.settings.xAxisScale,
        o = e === 1
          ? this.projection.settings.xAxisScale
          : this.projection.settings.yAxisScale;
      this.independentScale = __dcg_shared_module_exports__["ed"](t, [
        this.viewportBounds.independentMin,
        this.viewportBounds.independentMax,
      ], [0, this.screenDuration]),
        this.dependentScale = __dcg_shared_module_exports__["ed"](o, [
          this.viewportBounds.dependentMin,
          this.viewportBounds.dependentMax,
        ], [0, 1]),
        this.viewportBounds.dependentMax <= Lie &&
          this.viewportBounds.dependentMin >= Gie &&
          this.viewportBounds.dependentMax -
                this.viewportBounds.dependentMin >= 1e3
          ? (this.FREQ_MIN = this.viewportBounds.dependentMin,
            this.FREQ_MAX = this.viewportBounds.dependentMax,
            this.FREQ_BASE = void 0)
          : (this.FREQ_MIN = WK, this.FREQ_MAX = jK, this.FREQ_BASE = $K);
    }
    densifyBranches() {
      this.branches.map((e) => {
        if (e.discrete) return e;
        let t = this.independentScale, o = this.dependentScale;
        return !t || !o || !e.clippedSegments ||
          (e.clippedSegments = e.clippedSegments.map((i) => {
            let n = [];
            for (let a = 0; a < i.length; a += 2) {
              let s = this.mapDependentToFrequency(i[a + 1]),
                l = this.mapDependentToFrequency(i[a + 3]);
              if (
                n.push(i[a]),
                  n.push(i[a + 1]),
                  s && l && isFinite(s) && isFinite(l) &&
                  Math.abs((l - s) / s) >= XK(Math.min(l, s))
              ) {
                let c = Math.ceil(
                  Math.abs((l - s) / s) / XK(Math.min(l, s)),
                );
                for (let d = 1; d < c; d++) {
                  n.push(
                    __dcg_shared_module_exports__["gd"](
                      t.type,
                      i[a],
                      i[a + 2],
                      d * 1 / c,
                    ),
                  ),
                    n.push(
                      __dcg_shared_module_exports__["gd"](
                        o.type,
                        i[a + 1],
                        i[a + 3],
                        d * 1 / c,
                      ),
                    );
                }
              }
            }
            return n;
          })),
          e;
      });
    }
    setupToPlayBranches(e) {
      if (
        !this.audioGraphNavigator || !this.audioContext ||
        !this.mainGainNode
      ) return;
      let t = this.audioGraphNavigator.getCurrentSketch();
      if (!t) return;
      let o = this.controller.get2dProjection();
      if (
        this.branches = __dcg_shared_module_exports__["t"](
          t.branches.filter((i) =>
            kc(
              i,
              this.controller.getGraphSettings().config.audioTraceSimult,
            )
          ).map((i) => this.preprocessBranch(i, o)),
        ).filter((i) => i.clippedSegments.length > 0), !!this.branches.length
      ) {
        if (
          this.setupScales(this.branches[0].graphMode),
            this.densifyBranches(),
            e === "simultaneous"
        ) {
          let i = Math.min(
              ...this.branches.map((c) => c.clippedSegments[0][0]),
            ),
            n = Math.max(
              ...this.branches.map((c) =>
                c.clippedSegments.slice(-1)[0].slice(-2)[0]
              ),
            ),
            a = this.mapIndependentToTime(n) -
              this.mapIndependentToTime(i),
            s = __dcg_shared_module_exports__["ed"](
              this.branches[0].graphMode === 1
                ? this.projection.settings.yAxisScale
                : this.projection.settings.xAxisScale,
              [i, n],
              [0, a],
            ),
            l = __dcg_shared_module_exports__["ed"](
              this.branches[0].graphMode === 1
                ? this.projection.settings.yAxisScale
                : this.projection.settings.xAxisScale,
              [0, a],
              [i, n],
            );
          this.branches.forEach((c) => {
            c.duration = c.discrete ? a + ah : a,
              c.mapIndependentToTime = (d) =>
                __dcg_shared_module_exports__["fd"](s, d),
              c.mapTimeToIndependent = (d) =>
                __dcg_shared_module_exports__["fd"](l, d);
          });
        } else {this.branches.forEach((i) => {
            let n = i.clippedSegments[0][0],
              a = i.clippedSegments.slice(-1)[0].slice(-2)[0];
            i.discrete
              ? i.duration = i.clippedSegments.reduce((c, d) =>
                c + d.length / 2, 0) * (ah + KK)
              : i.duration = this.mapIndependentToTime(a) -
                this.mapIndependentToTime(n);
            let s = __dcg_shared_module_exports__["ed"](
                this.branches[0].graphMode === 1
                  ? this.projection.settings.yAxisScale
                  : this.projection.settings.xAxisScale,
                [n, a],
                [0, i.duration],
              ),
              l = __dcg_shared_module_exports__["ed"](
                this.branches[0].graphMode === 1
                  ? this.projection.settings.yAxisScale
                  : this.projection.settings.xAxisScale,
                [0, i.duration],
                [n, a],
              );
            i.mapIndependentToTime = (c) =>
              __dcg_shared_module_exports__["fd"](s, c),
              i.mapTimeToIndependent = (c) =>
                __dcg_shared_module_exports__["fd"](l, c);
          });}
      }
    }
    prepareToPlay(e) {
      this.setupToPlayBranches(e),
        this.turnMainGainOn(),
        clearInterval(this.timeoutId);
    }
    sequentialPlayLoop() {
      var o, i, n, a, s;
      let e = this.audioContext.currentTime,
        t = (o = this.playBranchIterators[0]) == null ? void 0 : o.next();
      if (
        this.lagLoggingData &&
        (this.lagLoggingData.branchIteratorCallCount++,
          this.audioContext.currentTime - e > 0 &&
          (this.lagLoggingData.branchIteratorStartTimes.push(e),
            this.lagLoggingData.branchIteratorRunTimes.push(
              this.audioContext.currentTime - e,
            ))), !!t
      ) {
        if (t.done) {
          if (
            ((i = t.value) == null ? void 0 : i.duration) !== void 0 &&
            (this.currentPlayLoopStartTime = ((n = t.value.startTime) != null
              ? n
              : this.currentPlayLoopStartTime) + t.value.duration),
              this.currentPlayLoopBranchIndex < this.branches.length - 1
          ) {
            this.currentPlayLoopBranchIndex++,
              this.playBranchIterators[0] = this.playBranch(
                this.currentPlayLoopBranchIndex,
                this.currentPlayLoopStartTime,
              ),
              this.sequentialPlayLoop();
          } else {
            (a = this.mainGainNode) == null ||
            a.gain.cancelScheduledValues(this.currentPlayLoopStartTime),
              (s = this.mainGainNode) == null ||
              s.gain.setTargetAtTime(
                0,
                this.currentPlayLoopStartTime,
                fo,
              ),
              clearTimeout(this.timeoutId),
              this.timeoutId = setTimeout(
                () => this.stop(),
                1e3 *
                  (Math.max(
                    this.currentPlayLoopStartTime -
                      this.audioContext.currentTime,
                    0,
                  ) + fo),
              );
            return;
          }
        }
        this.timeoutId = setTimeout(() => this.sequentialPlayLoop(), YK);
      }
    }
    simultaneousPlayLoop() {
      var t, o;
      let e = this.playBranchIterators.map((i) => i.next());
      if (e.every((i) => i.done)) {
        let i = this.currentPlayLoopStartTime + Math.max(...e.map((n) => {
          var a;
          return (a = n.value) != null && a.duration &&
              isFinite(n.value.duration)
            ? n.value.duration
            : 0;
        }));
        (t = this.mainGainNode) == null ||
        t.gain.cancelScheduledValues(i),
          (o = this.mainGainNode) == null ||
          o.gain.setTargetAtTime(0, i, fo),
          this.timeoutId = setTimeout(
            () => this.stop(),
            1e3 * (Math.max(i - this.audioContext.currentTime, 0) + fo),
          );
      } else this.timeoutId = setTimeout(() => this.simultaneousPlayLoop(), YK);
    }
    *playBlankSpace(e) {
      let t = Math.max(this.audioContext.currentTime, e),
        o = new Av(this, this.mainGainNode),
        { oscillator: i, pan: n, brownNoiseGain: a, gain: s } = o;
      i.stop(), s.gain.setTargetAtTime(1, t, fo);
      let l = this.branches.map((p) => {
          if (p.mapIndependentToTime) {
            return [
              p.clippedSegments[0][0],
              p.clippedSegments.slice(-1)[0].slice(-2)[0],
            ];
          }
        }).filter((p) => !!p),
        c = [];
      for (l.sort((p, h) => p[0] - h[0]); l.length > 0;) {
        let p = l[0];
        l = l.filter((h) => h[1] > p[1]),
          l.filter((h) => h[0] <= p[1]).length === 0 &&
          c.push([p[1], Math.min(...l.map((h) => h[0]))]);
      }
      c = c.filter((p) => isFinite(p[0]) && isFinite(p[1]));
      let d = (p) => {
        o.stop(p);
      };
      for (let p of c) {
        let h = t + this.mapIndependentToTime(p[0]),
          u = t + this.mapIndependentToTime(p[1]);
        for (; h > this.audioContext.currentTime + jP;) {
          yield { synthStopCallback: d };
        }
        a.gain.setTargetAtTime($P, h, fo),
          a.gain.setTargetAtTime(0, u, fo),
          n.pan.setValueAtTime(this.getPanValueFromIndependent(p[0]), h),
          n.pan.linearRampToValueAtTime(
            this.getPanValueFromIndependent(p[1]),
            u,
          );
      }
      return { duration: 0 };
    }
    mapDiscreteSegmentIndexToTime(e) {
      return e / 2 * (ah + KK);
    }
    *playBranch(e, t) {
      var y, C, E, v;
      let o = this.branches[e];
      if (
        !(o != null && o.duration) ||
        !(o != null && o.mapIndependentToTime)
      ) return { duration: 0 };
      let i = new Av(this, this.mainGainNode),
        n = o.clippedSegments,
        a = (w) => {
          i.stop(w);
        },
        {
          oscillator: s,
          gain: l,
          firstHarmonic: c,
          firstHarmonicGain: d,
          pan: p,
          brownNoiseGain: h,
        } = i,
        u = Math.max(this.audioContext.currentTime, t);
      if (o.poi && o.poi.intersections && this.poiBufferSample) {
        let w = BK(o.graphMode, o.poi.intersections);
        for (let S of w) {
          let k = this.audioContext.createBufferSource();
          k.connect(l), k.buffer = this.poiBufferSample;
          try {
            k == null || k.start(u + o.mapIndependentToTime(S));
          } catch (_) {}
        }
      }
      let f = u;
      for (let w = 0; w < n.length; w++) {
        let S = n[w];
        for (let k = 0; k < S.length; k += 2) {
          let _ = k === 0,
            A = k + 2 >= S.length,
            P = o.discrete
              ? f + this.mapDiscreteSegmentIndexToTime(k)
              : u + o.mapIndependentToTime(S[k]),
            O = this.mapDependentToFrequency(S[k + 1]);
          for (; P > this.audioContext.currentTime + jP;) {
            yield { synthStopCallback: a, duration: void 0 };
          }
          if (o.discrete) {
            this.synthesizePoint(
              S[k],
              S[k + 1],
              f + this.mapDiscreteSegmentIndexToTime(k),
              i,
            );
            continue;
          }
          if (
            P < this.audioContext.currentTime - jP &&
            this.lagLoggingData &&
            this.lagLoggingData.branchLags.push({
              branchIndex: e,
              segmentIndex: w,
              pos: k,
              nextTime: P,
              proposedStartTime: t,
              lagAmount: this.audioContext.currentTime - P,
              currentTime: this.audioContext.currentTime,
            }),
              _ &&
              (d.gain.cancelScheduledValues(P),
                h.gain.cancelScheduledValues(P),
                l.gain.setTargetAtTime(1, P, fo)),
              O !== void 0 && isFinite(O)
          ) {
            s.frequency.linearRampToValueAtTime(O, P),
              c.frequency.linearRampToValueAtTime(O, P);
            let U = P;
            if (k >= 2 && S[k - 2] <= 0 != S[k] <= 0) {
              let V = S[k - 2], R = S[k];
              U = u +
                o.mapIndependentToTime(
                  __dcg_shared_module_exports__["gd"](
                    (C = (y = this.independentScale) == null
                        ? void 0
                        : y.type) != null
                      ? C
                      : "linear",
                    V,
                    R,
                    Math.abs(R) / (Math.abs(R) + Math.abs(V)),
                  ),
                );
            }
            d.gain.setTargetAtTime(S[k] > 0 ? .15 : 0, U, fo);
            let x = P;
            if (k >= 2 && S[k + 1] <= 0 != S[k - 1] <= 0) {
              let V = S[k - 2], R = S[k], N = S[k - 1], M = S[k + 1];
              x = u +
                o.mapIndependentToTime(
                  __dcg_shared_module_exports__["gd"](
                    (v = (E = this.independentScale) == null
                        ? void 0
                        : E.type) != null
                      ? v
                      : "linear",
                    V,
                    R,
                    Math.abs(N) / (Math.abs(N) + Math.abs(M)),
                  ),
                );
            }
            h.gain.setTargetAtTime(WP(S[k + 1]), x, fo);
          }
          A &&
          (l.gain.setTargetAtTime(0, P, fo),
            w < o.clippedSegments.length - 1 &&
            h.gain.setTargetAtTime($P, P, fo)),
            k === 0
              ? p.pan.setValueAtTime(
                this.getPanValueFromIndependent(S[k]),
                P,
              )
              : p.pan.linearRampToValueAtTime(
                this.getPanValueFromIndependent(S[k]),
                P,
              );
        }
        f += this.mapDiscreteSegmentIndexToTime(S.length);
      }
      return o.duration = Math.max(
        0,
        o.duration,
        this.audioContext.currentTime - t,
      ),
        i.stop(u + o.duration),
        { duration: o.duration, startTime: u };
    }
    mapIndependentToTime(e) {
      return this.independentScale
        ? __dcg_shared_module_exports__["fd"](this.independentScale, e)
        : 0;
    }
    mapDependentToFrequency(e) {
      if (!this.dependentScale) return;
      let t = __dcg_shared_module_exports__["fd"](this.dependentScale, e);
      if (this.FREQ_BASE) {
        return Math.min(
          Math.max(this.FREQ_BASE * Math.pow(2, t), this.FREQ_MIN),
          this.FREQ_MAX,
        );
      }
      {
        let o = this.FREQ_MAX - this.FREQ_MIN;
        return Math.min(
          Math.max(this.FREQ_MIN + o * t, this.FREQ_MIN),
          this.FREQ_MAX,
        );
      }
    }
  };
  var Mv = [
      { speed: 1600, displayedSpeed: "1/32 x" },
      { speed: 1200, displayedSpeed: "1/24 x" },
      { speed: 800, displayedSpeed: "1/16 x" },
      { speed: 400, displayedSpeed: "1/8 x" },
      { speed: 200, displayedSpeed: "1/4 x" },
      { speed: 100, displayedSpeed: "1/2 x" },
      { speed: 50, displayedSpeed: "1 x" },
      { speed: 25, displayedSpeed: "2 x" },
      { speed: 12.5, displayedSpeed: "4 x" },
      { speed: 6.25, displayedSpeed: "8 x" },
    ],
    MD = class {
      constructor(e, t) {
        this.focusedTableLocation = void 0;
        this.grapher = t,
          this.controller = e,
          this.audioTraceActive = false,
          this.wasFocusInExpressionsView = false,
          this.sliderTraceActive = false,
          this.sliderIndex = 0,
          this.sliderArray = [],
          this.lastSpokenBranch = 1,
          this.agNavigator = new ID(e, this, this.grapher),
          this.agSynthesizer = new AD({
            controller: e,
            agNavigator: this.agNavigator,
            audioEnabled: () => this.controller.getAudio(),
          }),
          this.audioSpeedIndex = 6,
          this.agSynthesizer.releaseAudio();
      }
      remove() {}
      handleKeydown(e) {
        let t = e.altKey && !e.metaKey && !e.ctrlKey && !e.shiftKey;
        t && Ko(e) === "S"
          ? this.controller.getSelectedItem() &&
            (this.audioTraceActive || this.isFocusInExpressionsView()) &&
            (e.preventDefault(), e.stopPropagation(), this.describeCurve())
          : t && Ko(e) === "G"
          ? (this.audioTraceActive || this.isFocusInExpressionsView()) &&
            (e.preventDefault(), e.stopPropagation(), this.describeAxes())
          : t && Ko(e) === "T"
          ? (e.preventDefault(), e.stopPropagation(), this.toggleAudioTrace())
          : this.audioTraceActive &&
            (this.sliderTraceActive
              ? this.sliderTraceKeydown(e)
              : (this.stopAnimations(), this.audioTraceKeydown(e)));
      }
      sliderTraceKeydown(e) {
        let t = e.altKey || e.metaKey,
          o = !t && !e.ctrlKey && !e.shiftKey;
        o && ke(e) === ld || Ko(e) === "J"
          ? (e.preventDefault(),
            e.stopPropagation(),
            this.decrementSliderValue())
          : o && ke(e) === cd || Ko(e) === "L"
          ? (e.preventDefault(),
            e.stopPropagation(),
            this.incrementSliderValue())
          : o && ke(e) === Au
          ? (e.preventDefault(),
            e.stopPropagation(),
            this.decrementBigSliderValue())
          : o && ke(e) === Iu
          ? (e.preventDefault(),
            e.stopPropagation(),
            this.incrementBigSliderValue())
          : !t &&
              (ke(e) === Kn || !e.shiftKey && ke(e) === rl ||
                Ko(e) === "K")
          ? (e.preventDefault(), e.stopPropagation(), this.nextSlider())
          : !t &&
              (ke(e) === xa || e.shiftKey && ke(e) === rl ||
                Ko(e) === "I")
          ? (e.preventDefault(), e.stopPropagation(), this.prevSlider())
          : o && ke(e) === wg || Ko(e) === "U"
          ? (e.preventDefault(), e.stopPropagation(), this.sliderMin())
          : o && ke(e) === fp || Ko(e) === "N"
          ? (e.preventDefault(), e.stopPropagation(), this.sliderMax())
          : this.audioTraceKeydown(e);
      }
      audioTraceKeydown(e) {
        let t = e.altKey || e.metaKey,
          o = t && !e.ctrlKey && !e.shiftKey,
          i = !t && !e.ctrlKey && !e.shiftKey,
          n = Ko(e);
        if (ke(e) === xa && o) {
          e.preventDefault(),
            e.stopPropagation(),
            Si(),
            this.agNavigator.prevCurve();
        } else if (ke(e) === Kn && o) {
          e.preventDefault(),
            e.stopPropagation(),
            Si(),
            this.agNavigator.nextCurve();
        } else if (i && ke(e) === ld || ke(e) === xa || n === "J") {
          e.preventDefault(),
            e.stopPropagation(),
            this.controller.dispatch({
              type: "keypad/audio-trace",
              command: "previous-point",
            });
        } else if (i && ke(e) === cd || ke(e) === Kn || n === "L") {
          e.preventDefault(),
            e.stopPropagation(),
            this.controller.dispatch({
              type: "keypad/audio-trace",
              command: "next-point",
            });
        } else if (
          !t && (ke(e) === Au || !e.shiftKey && ke(e) === rl || n === "I")
        ) {
          e.preventDefault(),
            e.stopPropagation(),
            this.reportAndMoveToNextPOI();
        } else if (
          !t && (ke(e) === Iu || e.shiftKey && ke(e) === rl || n === "K")
        ) {
          e.preventDefault(),
            e.stopPropagation(),
            this.reportAndMoveToPrevPOI();
        } else if (i && ke(e) === wg || n === "U") {
          e.preventDefault(),
            e.stopPropagation(),
            this.reportAndMoveToFirstPoint();
        } else if (i && ke(e) === fp || n === "N") {
          e.preventDefault(),
            e.stopPropagation(),
            this.reportAndMoveToLastPoint();
        } else if (i && n === "X") {
          e.preventDefault(), e.stopPropagation(), this.reportX();
        } else if (i && n === "P") {
          e.preventDefault(), e.stopPropagation(), this.reportPOICount();
        } else if (i && n === "Y") {
          e.preventDefault(), e.stopPropagation(), this.reportY();
        } else if (i && n === "T") {
          e.preventDefault(), e.stopPropagation(), this.reportType();
        } else if (i && n === "B") {
          e.preventDefault(), e.stopPropagation(), this.reportBranch();
        } else if (i && n === "O") {
          e.preventDefault(), e.stopPropagation(), this.reportAndMoveToOrigin();
        } else if (i && n === "H") {
          e.preventDefault(), e.stopPropagation(), this.hearGraph();
        } else if (i && typeof n == "string" && n >= "0" && n <= "9") {
          if (
            e.preventDefault(),
              e.stopPropagation(),
              Si(),
              !this.controller.getAudio()
          ) {
            xe(
              this.controller.s(
                "graphing-calculator-narration-audio-trace-sound-effects-disabled",
              ),
            );
            return;
          }
          this.agSynthesizer.stop();
          let a = this.agNavigator.getCurrentSketch();
          if (a) {
            let s;
            e.which === 48 ? s = 9 : s = e.which - 49;
            let l = s, c = -1;
            for (let d = 0; d < a.branches.length; d++) {
              if (
                kc(
                  a.branches[d],
                  this.grapher.settings.config.audioTraceSimult,
                ) && (l -= 1), l < 0
              ) {
                c = d;
                break;
              }
            }
            c >= 0
              ? this.agSynthesizer.getPlaybackSupported()
                ? (this.agSynthesizer.playBranchByIndex(c),
                  this.grapher.traceLayer.setTraceInfo(void 0),
                  this.graphAnimationTimeoutId = requestAnimationFrame(
                    () => this.animateCurrentSketchLine(),
                  ))
                : xe(
                  this.controller.s(
                    "graphing-calculator-narration-audio-trace-unable-to-play",
                  ),
                )
              : xe(
                this.controller.s(
                  "graphing-calculator-narration-audio-trace-branch-not-found",
                  { branch: s + 1 },
                ),
              );
          } else {xe(
              this.controller.s(
                "graphing-calculator-narration-audio-trace-description-no-curve-selected",
              ),
            );}
        } else {t && typeof n == "string" && n >= "1" && n <= "5"
            ? (e.preventDefault(),
              e.stopPropagation(),
              this.controller.dispatch({
                type: "set-audio-trace-speed",
                speed: parseInt(n, 10) + 3,
              }))
            : !e.altKey && !e.ctrlKey && !e.metaKey && n === "V"
            ? (e.preventDefault(),
              e.stopPropagation(),
              this.controller.getAudio()
                ? e.shiftKey
                  ? this.controller.dispatch({
                    type: "keypad/audio-trace",
                    command: "volume-down",
                  })
                  : this.controller.dispatch({
                    type: "keypad/audio-trace",
                    command: "volume-up",
                  })
                : xe(
                  this.controller.s(
                    "graphing-calculator-narration-audio-trace-unable-to-play",
                  ),
                ))
            : i && n === "A"
            ? (e.preventDefault(),
              e.stopPropagation(),
              Si(),
              this.queueAnimatingPoints(true),
              xe())
            : i && n === "S" && this.controller.isListEnabled()
            ? (e.preventDefault(),
              e.stopPropagation(),
              this.toggleSliderTrace())
            : i && n === "C"
            ? (e.preventDefault(), e.stopPropagation(), this.reportColor())
            : i && this.exitAudioTrace();}
        this.controller.dispatch({ type: "render" });
      }
      describeCurve() {
        Si();
        let e = this.agNavigator.getCurrentSketch();
        if (!e) {
          xe(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-description-no-curve-selected",
            ),
          );
          return;
        }
        yt(
          this.controller.s(
            "graphing-calculator-narration-audio-trace-description-color",
            { color: md(this.controller, e.color) },
          ),
        );
        let t = _v(
          e,
          e.branches.length - 1,
          this.grapher.settings.config.audioTraceSimult,
        );
        t > 1 &&
          yt(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-description-branch-count",
              { branches: t },
            ),
          );
        let o = false, i = false;
        for (let a of e.branches) {
          if (
            t === 1 && a.segments.length > 0 &&
            a.hasOwnProperty("operator")
          ) {
            if (a.graphMode === 2) {
              if (a.operator === ">" || a.operator === ">=") {
                yt(
                  this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-shading-above",
                  ),
                );
                break;
              } else if (a.operator === "<" || a.operator === "<=") {
                yt(
                  this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-shading-below",
                  ),
                );
                break;
              }
            } else if (a.graphMode === 1) {
              if (a.operator === ">" || a.operator === ">=") {
                yt(
                  this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-shading-right",
                  ),
                );
                break;
              } else if (a.operator === "<" || a.operator === "<=") {
                yt(
                  this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-shading-left",
                  ),
                );
                break;
              }
            }
          } else {t > 1 && (a.graphMode === 2 || a.graphMode === 1
              ? (a.operator === "<" || a.operator === "<=" ||
                a.operator === ">" || a.operator === ">=") && (o = true)
              : a.graphMode === 7 && (i = true));}
        }
        o && i &&
          yt(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-description-shading-in-regions",
            ),
          );
        let n = e.getPOI();
        if (n.length > 0) {
          let a = [];
          for (let s of n) {
            a[s.type] === void 0 ? a[s.type] = 1 : a[s.type] += 1;
          }
          a.forEach((s, l) => {
            l === 1001
              ? yt(
                s === 1
                  ? this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-one-intersection",
                  )
                  : this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-multiple-intersections",
                    { count: s },
                  ),
              )
              : l === 1002
              ? yt(
                s === 1
                  ? this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-one-root",
                  )
                  : this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-multiple-roots",
                    { count: s },
                  ),
              )
              : l === 1003
              ? yt(
                s === 1
                  ? this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-one-intercept",
                  )
                  : this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-multiple-intercepts",
                    { count: s },
                  ),
              )
              : l === 1004
              ? yt(
                s === 1
                  ? this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-one-extremum",
                  )
                  : this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-multiple-extrema",
                    { count: s },
                  ),
              )
              : l === 1008 &&
                yt(
                  s === 1
                    ? this.controller.s(
                      "graphing-calculator-narration-audio-trace-description-one-label",
                    )
                    : this.controller.s(
                      "graphing-calculator-narration-audio-trace-description-multiple-labels",
                      { count: s },
                    ),
                );
          });
        }
        xe();
      }
      describeAxes() {
        Si(), xe(Iv(this.controller));
      }
      queueCoordinates(e) {
        if (!this.grapher.getProjection().viewport || !e) return;
        let o = this.agNavigator.getCurrentSketch();
        e.hasOwnProperty("branch") && o && o.branches.length > 1 &&
        this.lastSpokenBranch !== e.reportedBranch &&
        this.queueCoordinateProp(e, "branch"),
          e.hasOwnProperty("type") &&
          yt(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-property-type-before-coordinates",
              { type: this.describePOI(e) },
            ),
          ),
          e.graphMode === 25 || e.graphMode === 26
            ? yt(
              Ao(
                __dcg_shared_module_exports__["complexNumberLabel"]([e.x, e.y]),
              ),
            )
            : (this.queueCoordinateProp(e, "x"),
              this.queueCoordinateProp(e, "y"));
      }
      queueCoordinateProp(e, t) {
        if (this.grapher.getProjection().viewport && e) {
          switch (t) {
            case "branch":
              typeof e.reportedBranch == "number" &&
                yt(
                  this.controller.s(
                    "graphing-calculator-narration-audio-trace-property-branch-number",
                    { branch: e.reportedBranch },
                  ),
                );
              break;
            case "type":
              yt(this.describePOI(e));
              break;
            case "x":
              yt(Bl(this.controller, e.x));
              break;
            case "y":
              yt(Ul(this.controller, e.y));
              break;
            default:
              let i = t;
              throw new Error(`Unexpected prop ${i}`);
          }
        }
      }
      describePOI(e) {
        if (e != null && e.typeChain) {
          let t = [];
          for (let o = 0; o < e.typeChain.length; o++) {
            t.push(this.poiTypeToText(e, o));
          }
          return Cd(this.controller.getLanguage(), t);
        } else return this.poiTypeToText(e);
      }
      poiTypeToText(e, t) {
        switch (t && e.typeChain ? e.typeChain[t] : e.type) {
          case 1001:
            let i = this.getIntersectingCurves(e);
            return i !== ""
              ? this.controller.s(
                "graphing-calculator-narration-audio-trace-point-type-intersection-with-curves",
                { curves: i },
              )
              : this.controller.s(
                "graphing-calculator-narration-audio-trace-point-type-intersection",
              );
          case 1002:
            return this.controller.s(
              "graphing-calculator-narration-audio-trace-point-type-root",
            );
          case 1003:
            return this.controller.s(
              "graphing-calculator-narration-audio-trace-point-type-intercept",
            );
          case 1004:
            return this.controller.s(
              "graphing-calculator-narration-audio-trace-point-type-extremum",
            );
          case 1006:
            return this.controller.s(
              "graphing-calculator-narration-audio-trace-point-type-definition",
            );
          case 1007:
            return this.controller.s(
              "graphing-calculator-narration-audio-trace-point-type-trace",
            );
          case 1008:
            return this.controller.s(
              "graphing-calculator-narration-audio-trace-point-type-label",
            );
          default:
            return this.controller.s(
              "graphing-calculator-narration-audio-trace-point-type-not-a-poi",
            );
        }
      }
      getIntersectingCurves(e) {
        return !e || !e.intersects
          ? ""
          : this.getExpressionAriaLabel(e.intersects);
      }
      getExpressionAriaLabel(e) {
        var o;
        let t = this.controller.getItemModel(e);
        return t
          ? t.type === "expression" && t.label
            ? ei(t.label)
            : t.type === "table" &&
                ((o = this.focusedTableLocation) == null ? void 0 : o.type) ===
                  "cell"
            ? this.controller.s(
              "graphing-calculator-narration-audio-trace-expression-with-column",
              {
                index: t.displayIndex,
                column: this.focusedTableLocation.location.column + 1,
              },
            )
            : Xr(t, "describe")
          : "";
      }
      exitAudioTrace(e) {
        var t;
        if (this.audioTraceActive) {
          if (
            this.audioTraceActive = false,
              this.controller.isKeypadEnabled() &&
              this.controller.dispatch({ type: "keypad/123" }),
              e ||
              (e = this.controller.s(
                "graphing-calculator-text-audio-trace-off",
              )),
              this.controller.dispatch({ type: "toast/close" }),
              this.wasFocusInExpressionsView
          ) {
            let o = this.controller.getSelectedItem();
            if (
              (!o || !this.controller.isItemSelectable(o.id)) &&
              (o = this.controller.getFirstFullyVisibleItem()),
                o && this.controller.isItemSelectable(o.id)
            ) {
              let i = {
                type: "move-focus-to-item",
                id: o.id,
                where: "end",
              };
              if (o.type === "table") {
                switch (
                  (t = this.focusedTableLocation) == null ? void 0 : t.type
                ) {
                  case "cell":
                    i.where = {
                      location: "cell",
                      ...this.focusedTableLocation.location,
                    },
                      this.focusedTableLocation.location.column === 1 &&
                      this.enteredAudioTraceWithFirstTableColumnFocused &&
                      (i.where.column = 0);
                    break;
                  case "table-regression":
                    i = {
                      type: "set-focus-location",
                      location: {
                        type: "table-regression-type-dropdown",
                        id: o.id,
                      },
                    };
                }
              }
              this.controller.dispatch(i);
            }
          }
          this.wasFocusInExpressionsView = false,
            this.focusedTableLocation = void 0,
            this.stopAnimations(),
            this.sliderTraceActive = false,
            this.sliderIndex = 0,
            this.agSynthesizer.stop(),
            this.agSynthesizer.releaseAudio(),
            this.agNavigator.reset(),
            this.lastSpokenBranch = 1,
            this.grapher.traceLayer.setTraceInfo(void 0),
            this.grapher.traceLayer.setTraceLine(void 0),
            this.controller.requestRedrawGraph(),
            this.enteredAudioTraceWithFirstTableColumnFocused = false,
            xe(e),
            this.resumeAnimations();
        }
      }
      isFocusInExpressionsView() {
        var e;
        return !!((e = document.activeElement) != null &&
          e.closest(".dcg-exppanel-container"));
      }
      canAudioTraceCurrentExp() {
        let e = this.controller.getSelectedItem();
        return e
          ? e.type === "table"
            ? !!this.agNavigator.getCurrentSketch()
            : this.agNavigator.canTrace(e)
          : false;
      }
      enterAudioTrace(e) {
        var a, s;
        let t = this.controller.getSelectedItem(),
          o = t && t.type !== "table" && !this.agNavigator.canTrace(t)
            ? this.getExpressionAriaLabel(t.id)
            : void 0,
          i = false;
        this.audioTraceActive ||
          (this.wasFocusInExpressionsView = this
            .isFocusInExpressionsView(),
            t && o &&
            yt(
              this.controller.s(
                "graphing-calculator-narration-audio-trace-unsupported-expression",
                { expression: o },
              ),
            ),
            i = !!o || !this.wasFocusInExpressionsView);
        let n;
        if (i) {
          n = this.agNavigator.getFirstTraceableSketch({
            selectAssociatedExpression: true,
          });
        } else if (!o) {
          if (
            t && t.type === "expression" && t.formula && t.formula.error
          ) {
            return this.exitAudioTrace(),
              this.controller.dispatch({
                type: "toast/show",
                toast: {
                  message: this.controller.s(
                    "graphing-calculator-narration-audio-trace-description-no-curve-selected",
                  ),
                },
              });
          }
          if (t && t.type === "table") {
            if (!this.focusedTableLocation) {
              let l = wa(t), c = this.controller.getFocusLocation();
              c != null && c.type.startsWith("table-regression") ||
                (a = document.activeElement) != null &&
                  a.closest(".dcg-table-regression")
                ? this.setFocusedTableLocation({
                  tableId: t.id,
                  type: "table-regression",
                  location: void 0,
                })
                : (this.enteredAudioTraceWithFirstTableColumnFocused =
                  (l == null ? void 0 : l.column) === 0,
                  this.setFocusedTableLocation(
                    l
                      ? {
                        tableId: t.id,
                        type: "cell",
                        location: { column: l.column || 1, row: l.row },
                      }
                      : void 0,
                  ));
            }
          } else {this.enteredAudioTraceWithFirstTableColumnFocused = false,
              this.setFocusedTableLocation(void 0);}
          n = this.agNavigator.getCurrentSketch();
        }
        if (!n) {
          this.agNavigator.reset(),
            this.lastSpokenBranch = 1,
            this.exitAudioTrace(),
            n = this.agNavigator.getCurrentSketch();
          let l = n == null ? void 0 : n.branches[0].graphMode;
          return l === 8 && !this.grapher.settings.config.audioTraceSimult
            ? (this.exitAudioTrace(),
              this.controller.dispatch({
                type: "toast/show",
                toast: {
                  message: this.controller.s(
                    "graphing-calculator-text-audio-trace-no-implicit-support",
                  ),
                },
              }))
            : l === 5 && !this.grapher.settings.config.audioTraceSimult
            ? (this.exitAudioTrace(),
              this.controller.dispatch({
                type: "toast/show",
                toast: {
                  message: this.controller.s(
                    "graphing-calculator-text-audio-trace-no-parametric-support",
                  ),
                },
              }))
            : l === 6 && !this.grapher.settings.config.audioTraceSimult
            ? (this.exitAudioTrace(),
              this.controller.dispatch({
                type: "toast/show",
                toast: {
                  message: this.controller.s(
                    "graphing-calculator-text-audio-trace-no-polar-support",
                  ),
                },
              }))
            : this.controller.dispatch({
              type: "toast/show",
              toast: {
                message: this.controller.s(
                  "graphing-calculator-narration-audio-trace-description-no-curve-selected",
                ),
              },
            });
        }
        if (
          (s = this.controller.toneController) == null ||
          s.handleAction({ type: "mute-global" }),
            this.agNavigator.reset(),
            this.agNavigator.computeStepSizes(),
            this.lastSpokenBranch = 1,
            this.grapher.traceLayer.clearOpenedPOI(),
            this.controller.requestRedrawGraph(),
            !this.audioTraceActive &&
            (this.controller.isKeypadEnabled() ||
              this.controller.dispatch({
                type: "toast/show",
                toast: {
                  message: this.controller.s(
                    "graphing-calculator-text-audio-trace-on",
                  ),
                  noAria: true,
                  onHide: () => this.exitAudioTrace(),
                  hideAfter: 0,
                },
              }),
              o && n &&
              yt(
                this.controller.s(
                  "graphing-calculator-narration-audio-trace-tracing-different-expression",
                  {
                    expression: this.getExpressionAriaLabel(
                      this.focusedTableLocation
                        ? this.focusedTableLocation.tableId
                        : n.id,
                    ),
                  },
                ),
              ),
              yt(
                this.controller.s(
                  "graphing-calculator-text-audio-trace-on",
                ),
              ),
              this.controller.getAudio() ||
              yt(
                this.controller.s(
                  "graphing-calculator-narration-audio-trace-sound-effects-disabled",
                ),
              ),
              this.pauseAnimations(),
              this.queueAnimatingPoints(false),
              this.agSynthesizer.prepareSynthesizer(),
              (!e || !e.fromKeypad) &&
              (yt(
                this.controller.s(
                  "graphing-calculator-narration-audio-trace-instructions-use-arrow-keys",
                ),
              ),
                this.controller.getAudio() &&
                yt(
                  this.controller.s(
                    "graphing-calculator-narration-audio-trace-instructions-hear-graph",
                  ),
                ),
                this.agNavigator.getTraceableExpressionCount() > 1 && (Zo
                  ? yt(
                    this.controller.s(
                      "graphing-calculator-narration-audio-trace-instructions-expression-navigation-mac",
                    ),
                  )
                  : yt(
                    this.controller.s(
                      "graphing-calculator-narration-audio-trace-instructions-expression-navigation-windows",
                    ),
                  )),
                Zo
                  ? yt(
                    this.controller.s(
                      "graphing-calculator-narration-audio-trace-instructions-disable-mac",
                    ),
                  )
                  : yt(
                    this.controller.s(
                      "graphing-calculator-narration-audio-trace-instructions-disable-windows",
                    ),
                  )),
              this.wasFocusInExpressionsView)
        ) {
          let l = this.controller.findEl(".dcg-graph-outer");
          l && (ee(l).one("focusin", () => {
            setTimeout(() => {
              xe();
            }, 0);
          }),
            this.controller.dispatch({
              type: "set-focus-location",
              location: { type: "graph-paper" },
            }));
        }
        this.agNavigator.moveToOrigin(),
          yt(this.getExpressionAriaLabel(n.id)),
          this.reportAudioTrace({ playSound: false }),
          this.wasFocusInExpressionsView || xe(),
          this.audioTraceActive = true,
          this.controller.isKeypadEnabled() &&
          this.controller.dispatch({ type: "keypad/audio" });
      }
      checkIfSelectedItemChanged(e) {
        this.lastSelectedId !== e &&
          (this.lastSelectedId = e,
            this.audioTraceActive &&
            (e
              ? (yt(this.getExpressionAriaLabel(e)),
                this.exitSliderTrace(),
                this.agNavigator.updatePOI(),
                this.agNavigator.moveToOrigin(),
                this.reportAudioTrace(),
                xe())
              : this.exitAudioTrace()));
      }
      pauseAnimations() {
        this.sliderArray.length = 0,
          this.controller.getAllModelsWithSliders().forEach((t) => {
            t.slider.isPlaying &&
              (this.controller.dispatch({
                type: "set-slider-isplaying",
                id: t.id,
                isPlaying: false,
              }),
                this.sliderArray.push(t));
          });
      }
      resumeAnimations() {
        if (this.sliderArray.length !== 0) {
          for (let e = 0; e < this.sliderArray.length; e++) {
            let t = this.sliderArray[e];
            t.slider.isPlaying !== true &&
              this.controller.dispatch({
                type: "set-slider-isplaying",
                id: t.id,
                isPlaying: true,
              });
          }
          this.sliderArray.length = 0;
        }
      }
      stopAnimations() {
        this.controller.getAllModelsWithSliders().forEach((t) => {
          t.slider.isPlaying &&
            this.controller.dispatch({
              type: "set-slider-isplaying",
              id: t.id,
              isPlaying: false,
            });
        });
      }
      hasActiveSliders() {
        let e = this.controller.getAllModelsWithSliders();
        for (let t = 0; t < e.length; t++) {
          if (e[t].slider.isPlaying) return true;
        }
        return false;
      }
      queueAnimatingPoints(e) {
        this.sliderArray.length === 1
          ? yt(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-one-slider-paused",
            ),
          )
          : this.sliderArray.length > 1
          ? yt(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-multiple-sliders-paused",
              { sliders: this.sliderArray.length },
            ),
          )
          : e &&
            yt(
              this.controller.s(
                "graphing-calculator-narration-audio-trace-no-sliders-paused",
              ),
            );
      }
      queueSliderLatex() {
        this.hasActiveSliders() || this.agSynthesizer.stop();
        let e = this.getSelectedSlider();
        e ? yt(e.latex) : yt(
          this.controller.s(
            "graphing-calculator-narration-audio-trace-slider-value-unknown",
          ),
        );
      }
      getSelectedSlider() {
        let e = this.controller.getAllModelsWithSliders();
        return this.sliderIndex <= e.length - 1 ? e[this.sliderIndex] : null;
      }
      incrementSliderValue() {
        this.adjustSlider("up");
      }
      decrementSliderValue() {
        this.adjustSlider("down");
      }
      incrementBigSliderValue() {
        this.adjustSlider("bigup");
      }
      decrementBigSliderValue() {
        this.adjustSlider("bigdown");
      }
      nextSlider() {
        this.adjustSlider("next");
      }
      prevSlider() {
        this.adjustSlider("prev");
      }
      sliderMin() {
        this.adjustSlider("min");
      }
      sliderMax() {
        this.adjustSlider("max");
      }
      adjustSlider(e) {
        let t = this.getSelectedSlider();
        if (!t) {
          yt(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-cannot-change-slider-value",
            ),
          );
          return;
        }
        let o = t.latex,
          i = this.controller.getAllModelsWithSliders().length;
        switch (e) {
          case "up":
          case "down":
          case "bigup":
          case "bigdown":
          case "min":
          case "max":
            this.controller.dispatch({
              type: "adjust-slider-by-keyboard",
              id: t.id,
              adjustment: e,
            }),
              this.queueSliderLatex(),
              xe();
            break;
          case "next":
            this.sliderIndex++,
              this.sliderIndex >= i &&
              (yt(
                this.controller.s(
                  "graphing-calculator-narration-audio-trace-last-slider",
                ),
              ),
                this.sliderIndex = i - 1),
              this.queueSliderLatex(),
              xe();
            return;
          case "prev":
            this.sliderIndex--,
              this.sliderIndex < 0 &&
              (yt(
                this.controller.s(
                  "graphing-calculator-narration-audio-trace-first-slider",
                ),
              ),
                this.sliderIndex = 0),
              this.queueSliderLatex(),
              xe();
            return;
        }
        !t.slider.isPlaying && o !== t.latex &&
          (this.queueSliderLatex(), xe());
      }
      toggleAudioTrace() {
        this.audioTraceActive ? this.exitAudioTrace() : this.enterAudioTrace();
      }
      toggleSliderTrace() {
        this.sliderTraceActive
          ? this.exitSliderTrace()
          : this.enterSliderTrace();
      }
      enterSliderTrace() {
        if (this.sliderTraceActive) return;
        this.sliderIndex = 0,
          this.controller.getAllModelsWithSliders().length !== 0
            ? (yt(
              this.controller.s(
                "graphing-calculator-narration-slider-trace-on",
              ),
            ),
              this.queueSliderLatex(),
              this.sliderTraceActive = true)
            : (yt(
              this.controller.s(
                "graphing-calculator-narration-slider-trace-no-sliders",
              ),
            ),
              this.sliderTraceActive = false),
          xe();
      }
      exitSliderTrace() {
        this.sliderTraceActive &&
          (yt(
            this.controller.s(
              "graphing-calculator-narration-slider-trace-off",
            ),
          ),
            this.sliderTraceActive = false,
            this.sliderIndex = 0,
            xe());
      }
      recomputePoints() {
        !this.audioTraceActive || this.agSynthesizer.getIsPlaying() ||
          (this.agNavigator.updatePOI(),
            this.agNavigator.updateSampledPoints(),
            this.agNavigator.updateCurrentPoint(),
            this.agNavigator.resetTracePoint(),
            this.agNavigator.computeStepSizes());
      }
      reportAndMoveToPrevPoint() {
        Si(),
          this.agNavigator.prevPoint(),
          this.reportAudioTrace(),
          this.controller.dispatch({ type: "render" });
      }
      reportAndMoveToNextPoint() {
        Si(),
          this.agNavigator.nextPoint(),
          this.reportAudioTrace(),
          this.controller.dispatch({ type: "render" });
      }
      reportAndMoveToOrigin() {
        Si(),
          this.agNavigator.moveToOrigin(),
          this.reportAudioTrace(),
          this.controller.dispatch({ type: "render" });
      }
      reportAndMoveToPrevPOI() {
        Si(),
          this.agNavigator.prevPOI(),
          this.reportAudioTrace(),
          this.controller.dispatch({ type: "render" });
      }
      reportAndMoveToNextPOI() {
        Si(),
          this.agNavigator.nextPOI(),
          this.reportAudioTrace(),
          this.controller.dispatch({ type: "render" });
      }
      reportAndMoveToFirstPoint() {
        Si(),
          this.agNavigator.firstPoint(),
          this.reportAudioTrace(),
          this.controller.dispatch({ type: "render" });
      }
      reportAndMoveToLastPoint() {
        Si(),
          this.agNavigator.lastPoint(),
          this.reportAudioTrace(),
          this.controller.dispatch({ type: "render" });
      }
      reportX() {
        Si(), this.reportAudioTrace({ propToSpeak: "x", playSound: false });
      }
      reportY() {
        Si(), this.reportAudioTrace({ propToSpeak: "y", playSound: false });
      }
      reportColor() {
        Si();
        let e = this.agNavigator.getCurrentSketch();
        e ? yt(md(this.controller, e.color)) : yt(
          this.controller.s(
            "graphing-calculator-narration-color-unknown",
          ),
        ), xe();
      }
      reportPOICount() {
        Si();
        let e = this.agNavigator.getCurrentSketch(),
          t = e ? e.getPOI().length : 0;
        xe(
          this.controller.s(
            "graphing-calculator-narration-audio-trace-poi-count",
            { x: t },
          ),
        );
      }
      reportType() {
        Si(), this.reportAudioTrace({ propToSpeak: "type", playSound: false });
      }
      reportBranch() {
        Si(),
          this.reportAudioTrace({ propToSpeak: "branch", playSound: false });
      }
      describePoint() {
        Si(), this.reportAudioTrace({ playSound: false }), xe();
      }
      playCurrentPoint() {
        let e = this.agNavigator.getCurrentPoint();
        e && this.agSynthesizer.playPoint(e);
      }
      reportAudioTrace(e) {
        var a, s;
        let t = this.agNavigator.getCurrentPoint();
        if (!t) return;
        let o = e == null ? void 0 : e.propToSpeak,
          i = this.controller.getAudio() &&
            this.agSynthesizer.getPlaybackSupported() &&
            ((a = e == null ? void 0 : e.playSound) != null ? a : true),
          n = (s = e == null ? void 0 : e.speakCoordinates) != null ? s : true;
        this.agSynthesizer.stop(),
          i && this.playCurrentPoint(),
          n &&
          (o ? this.queueCoordinateProp(t, o) : this.queueCoordinates(t),
            this.lastSpokenBranch = t.reportedBranch
              ? t.reportedBranch
              : t.branch + 1,
            setTimeout(() => {
              xe();
            }, o ? 0 : 100));
      }
      adjustPlaybackSpeed(e) {
        if (!this.controller.getAudio()) {
          xe(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-sound-effects-disabled",
            ),
          );
          return;
        }
        if (e < 0 || e >= Mv.length) return;
        this.audioSpeedIndex = e;
        let t = Mv[e];
        return this.agSynthesizer.setAudioSpeed(t.speed),
          xe(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-playback-speed",
              { speed: t.displayedSpeed },
            ),
          );
      }
      speedUp() {
        this.adjustPlaybackSpeed(this.audioSpeedIndex + 1);
      }
      speedDown() {
        this.adjustPlaybackSpeed(this.audioSpeedIndex - 1);
      }
      adjustVolume(e) {
        if (Si(), !this.controller.getAudio()) {
          xe(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-sound-effects-disabled",
            ),
          );
          return;
        }
        let t = this.agSynthesizer.getAudioVolume(),
          o = e === "up"
            ? Math.min(100, Math.round((t + .1) * 100))
            : Math.max(0, Math.round((t - .1) * 100));
        this.agSynthesizer.setAudioVolume(o / 100),
          this.playCurrentPoint(),
          xe(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-volume",
              { volume: o },
            ),
          );
      }
      getFocusedTableLocation() {
        return this.focusedTableLocation;
      }
      setFocusedTableLocation(e) {
        this.focusedTableLocation = e;
      }
      getAudioTraceActive() {
        return this.audioTraceActive;
      }
      isAudioTracing() {
        return !!this.agSynthesizer && this.agSynthesizer.getIsPlaying();
      }
      handleEvaluatorChange(e) {}
      hearGraph() {
        var e, t;
        if (Si(), !this.controller.getAudio()) {
          xe(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-sound-effects-disabled",
            ),
          );
          return;
        }
        if (this.agSynthesizer.getPlaybackSupported()) {
          this.agSynthesizer.stop();
          let o = this.agNavigator.getCurrentSketch();
          if (
            (t = (e = this.controller).logEvent) == null ||
            t.call(e, { category: "audio-trace", action: "hear-graph" }),
              o && ul(this.controller, o)
          ) {
            let i = this.grapher.settings.config.audioTraceSimult
              ? "simultaneous"
              : "sequential";
            this.agSynthesizer.playCurrentSketch(i),
              i === "simultaneous"
                ? (this.grapher.traceLayer.setTraceInfo(void 0),
                  requestAnimationFrame(() => this.animateCurrentSketchLine()))
                : (this.grapher.traceLayer.setTraceLine(void 0),
                  requestAnimationFrame(() =>
                    this.animateCurrentSketchPoint()
                  ));
          } else {xe(
              this.controller.s(
                "graphing-calculator-narration-audio-trace-unable-to-trace-this-expression",
              ),
            );}
        } else {xe(
            this.controller.s(
              "graphing-calculator-narration-audio-trace-unable-to-play",
            ),
          );}
      }
      animateCurrentSketchPoint() {
        if (
          this.graphAnimationTimeoutId &&
          cancelAnimationFrame(this.graphAnimationTimeoutId),
            this.graphAnimationTimeoutId = requestAnimationFrame(() =>
              this.animateCurrentSketchPoint()
            ),
            !this.agSynthesizer.getIsPlaying()
        ) return;
        let e = this.agSynthesizer.getCurrentIndependentValue(),
          t = this.agSynthesizer.getCurrentBranchIndex();
        e !== void 0 && t !== void 0 &&
          this.agNavigator.drawTracePoint(
            this.agNavigator.getPoint(t, e),
          );
      }
      animateCurrentSketchLine() {
        if (
          this.graphAnimationTimeoutId &&
          cancelAnimationFrame(this.graphAnimationTimeoutId),
            this.graphAnimationTimeoutId = requestAnimationFrame(() =>
              this.animateCurrentSketchLine()
            ),
            !this.agSynthesizer.getIsPlaying()
        ) return;
        let e = this.agSynthesizer.getCurrentIndependentValue();
        e !== void 0 &&
          this.agNavigator.drawTraceLine(
            e,
            this.agSynthesizer.getGraphMode(),
          );
      }
      stopGraph() {
        this.agSynthesizer.stop(),
          this.graphAnimationTimeoutId &&
          cancelAnimationFrame(this.graphAnimationTimeoutId);
      }
      getAudioSpeedIndex() {
        return this.audioSpeedIndex;
      }
      getAudioVolume() {
        var e;
        return (e = this.agSynthesizer.getAudioVolume()) != null ? e : .5;
      }
    };
  var GD = class {
    redrawToCtx(e, t) {
      let { ctx: o, projection: i } = e;
      if (!t) return;
      o.save(),
        o.lineWidth = 2,
        o.fillStyle = "rgba(0,0,0,.15)",
        o.strokeStyle = "rgba(0,0,0,.4)";
      let n = i.mapx(t.left),
        a = i.mapy(t.top),
        s = i.mapx(t.right),
        l = i.mapy(t.bottom),
        c = s - n,
        d = l - a;
      o.fillRect(n, a, c, d), o.strokeRect(n, a, c, d), o.restore();
    }
  };
  var uy = {};
  uy.vpmax8 = {
    width: 170,
    height: 220,
    margins: { left: 5, top: 15, right: 5, bottom: 50 },
  };
  uy.vpmax11 = {
    width: 230,
    height: 220,
    margins: { left: 15, top: 15, right: 5, bottom: 5 },
  };
  uy.etc8 = {
    width: 96,
    height: 96,
    margins: { left: 5, top: 15, right: 0, bottom: 0 },
  };
  uy.etc11 = {
    width: 132,
    height: 134,
    margins: { left: 10, top: 15, right: 5, bottom: 5 },
  };
  var Rs = class {
    constructor(e, t, o) {
      this.screen = e,
        this.viewport = t,
        this.settings = o,
        this.mathCoordinates = __dcg_shared_module_exports__["id"](t),
        this.pixelCoordinates = __dcg_shared_module_exports__["hd"](e),
        this.updateScalePairs();
    }
    updateScalePairs() {
      let { xAxisScale: e, yAxisScale: t } = this.settings;
      this.mathToPixels = __dcg_shared_module_exports__["jd"].fromRects(
        this.mathCoordinates,
        this.pixelCoordinates,
        { xAxisScale: e, yAxisScale: t },
      ), this.pixelsToMath = this.mathToPixels.inverse();
    }
    mapx(e) {
      return this.mathToPixels.mapX(e);
    }
    mapy(e) {
      return this.mathToPixels.mapY(e);
    }
    reverse_mapx(e) {
      return this.pixelsToMath.mapX(e);
    }
    reverse_mapy(e) {
      return this.pixelsToMath.mapY(e);
    }
    mapAlongAxis(e, t) {
      switch (t) {
        case "x":
          return this.mapx(e);
        case "y":
          return this.mapy(e);
        default: {
          let o = t;
          throw new Error(`Unknown axis: ${o}`);
        }
      }
    }
    reverseMapAlongAxis(e, t) {
      switch (t) {
        case "x":
          return this.reverse_mapx(e);
        case "y":
          return this.reverse_mapy(e);
        default: {
          let o = t;
          throw new Error(`Unknown axis: ${o}`);
        }
      }
    }
    map_pt(e) {
      return this.mathToPixels.mapPoint(e);
    }
    map_xy_pairs(e) {
      let t = [];
      for (let o = 0; o < e.length; o += 2) {
        t.push(this.mapx(e[o])), t.push(this.mapy(e[o + 1]));
      }
      return t;
    }
    reverse_map_pt(e) {
      return this.pixelsToMath.mapPoint(e);
    }
    coordsAreOnscreen(e, t, o = 0) {
      return e > -o && t > -o && e < this.screen.width + o &&
        t < this.screen.height + o;
    }
    closestPointOnScreen(e) {
      let t = this.pixelCoordinates;
      return {
        x: Math.min(Math.max(e.x, t.left), t.right),
        y: Math.min(Math.max(e.y, t.top), t.bottom),
      };
    }
  };
  var hl = class {
    constructor(e, t) {
      this.width = e, this.height = t;
    }
  };
  var Rie = 10240;
  function Fie(r, e, t, o, i) {
    let { dotSpacing: n } = r, a = 1 + n, s = i.charCodeAt(0) - Rie;
    s & 1 && e.fillRect(t, o, 1, 1),
      s & 2 && e.fillRect(t, o + a, 1, 1),
      s & 4 && e.fillRect(t, o + 2 * a, 1, 1),
      s & 8 && e.fillRect(t + a, o, 1, 1),
      s & 16 && e.fillRect(t + a, o + a, 1, 1),
      s & 32 && e.fillRect(t + a, o + 2 * a, 1, 1);
  }
  function VD(r, e) {
    let { x: t, y: o, width: i, height: n } = e,
      a = r.getImageData(t, o, i, n).data;
    for (let s = 3; s < a.length; s += 4) if (a[s] !== 0) return false;
    return true;
  }
  function Nie(r, e) {
    let { x: t, y: o, width: i, height: n } = e,
      a = r.getImageData(t, o, i, n).data;
    for (let s = 3; s < a.length; s += 4) if (a[s] === 0) return false;
    return true;
  }
  function YP(r, e, t, o, i) {
    return VD(e, RD(r, t, o, i));
  }
  function Bie(r, e, t, o, i) {
    let { dotSpacing: n } = r, a = 3 + 2 * n;
    for (let s = 0; s < i.length; s++) Fie(r, e, t + a * s, o, i[s]);
  }
  function zp(r, e) {
    let { dotSpacing: t } = r;
    return (2 + t) * e.length + (1 + t) * (e.length - 1);
  }
  function OD(r, e) {
    let { dotSpacing: t } = r;
    return 3 + 2 * t;
  }
  function RD(r, e, t, o) {
    let { cellPadding: i } = r;
    return {
      x: e - i,
      y: t - i,
      width: zp(r, o) + 2 * i,
      height: OD(r, o) + 2 * i,
    };
  }
  function LD(r, e) {
    if (!r) return e;
    let t = Math.min(r.x, e.x),
      o = Math.min(r.y, e.y),
      i = Math.max(r.x + r.width, e.x + e.width) - t,
      n = Math.max(r.y + r.height, e.y + e.height) - o;
    return { x: t, y: o, width: i, height: n };
  }
  function JK(r, e, t) {
    return Math.min(Math.max(r, e), t);
  }
  function Gv(r, e, t, o, i) {
    return {
      x: JK(t, 0, e.canvas.width - zp(r, i)),
      y: JK(o, 0, e.canvas.height - OD(r, i)),
    };
  }
  function Lv(r, e, t, o, i) {
    let n = e.fillStyle;
    e.fillStyle = "white";
    let a = RD(r, t, o, i);
    e.fillRect(a.x, a.y, a.width, a.height),
      e.fillStyle = "black",
      Bie(r, e, t, o, i),
      e.fillStyle = n;
  }
  function XP(r, e, t, o) {
    let { cellPadding: i } = r;
    return { x: Math.round(e - (zp(r, o) + i)), y: t };
  }
  function Uie(r) {
    return r.replace(/\u283C(?!$)/g, "");
  }
  function Up(r, e) {
    let t = e === "nemeth" ? lp(r) : cp(r);
    return t.isError ? "" : Uie(t.value);
  }
  function gy(r, e) {
    return e >= 0 ? r * Math.pow(10, e) : r / Math.pow(10, -e);
  }
  function ZK(r, e, t, o) {
    let [i, n] = t,
      a = Math.ceil(Math.log(n - i) / Math.LN10) - 1,
      s = a,
      l = 5,
      c = 15;
    e: for (let d = a; a - d < 4; d--) {
      for (let p of [5, 2, 1]) {
        let h = gy(p, d),
          u = Math.floor(i / h) + 1,
          f = Math.ceil(n / h) - 1,
          y = Math.abs(o(h) - o(0)),
          C = Up(String(gy(u * p, d)), e),
          E = Up(String(gy(f * p, d)), e);
        if (
          y < zp(r, C) + zp(r, " ") || y < zp(r, E) + zp(r, " ") ||
          f - u >= c
        ) break e;
        s = d, l = p;
      }
    }
    return { int: l, exp: s };
  }
  function e6(r, e, t) {
    return ZK(r, e, [t.viewport.xmin, t.viewport.xmax], (o) => t.mapx(o));
  }
  function zie(r, e, t) {
    return t.viewport.isSquare(t.screen, {
        xAxisScale: t.settings.xAxisScale,
        yAxisScale: t.settings.yAxisScale,
      })
      ? e6(r, e, t)
      : ZK(r, e, [t.viewport.ymin, t.viewport.ymax], (o) => t.mapy(o));
  }
  function QK(r, e) {
    let { int: t, exp: o } = r,
      [i, n] = e,
      a = Math.ceil(i / gy(t, o)),
      s = Math.floor(n / gy(t, o)),
      l = [];
    for (let c = a; c <= s; c++) l.push(gy(c * t, o));
    return l;
  }
  function qie(r, e, t) {
    return {
      x: QK(e6(r, e, t), [t.viewport.xmin, t.viewport.xmax]),
      y: QK(zie(r, e, t), [t.viewport.ymin, t.viewport.ymax]),
    };
  }
  function t6(r, e, t, o, i, n) {
    if (t.margins === void 0 || e === void 0) return;
    let a = Hie(o),
      s = t.margins,
      l = { ...e.settings },
      c = l.showGrid && Kie(o),
      d = !!l.showXAxis,
      p = !!l.showYAxis,
      h = !!l.xAxisNumbers,
      u = l.xAxisArrowMode,
      f = !!l.yAxisNumbers,
      y = l.yAxisArrowMode,
      C = a.graphLineWidth,
      E = {
        showGrid: false,
        xAxisNumbers: false,
        xAxisArrowMode: "NONE",
        yAxisNumbers: false,
        yAxisArrowMode: "NONE",
        showXAxis: false,
        showYAxis: false,
        graphLineWidth: C,
        pointLineWidth: 2.5,
        curveOpacity: 1,
        globalCurveColor: "#000",
        disableFill: true,
      };
    for (let F in E) e.settings[F] = E[F];
    let v = r.width - s.right - s.left,
      w = r.height - s.top - s.bottom,
      S = new hl(v, w),
      k = e.getProjection().viewport;
    e.settings.squareAxes && (k = k.squareCrop(S, e.settings));
    let _ = new Rs(S, k, e.settings),
      A = r.getContext("2d"),
      P = document.createElement("canvas");
    P.width = v, P.height = w;
    let O = P.getContext("2d"), U = document.createElement("canvas");
    U.width = v, U.height = w;
    let z = U.getContext("2d"), x = document.createElement("canvas");
    x.width = v, x.height = w;
    let L = x.getContext("2d"), V = document.createElement("canvas");
    V.width = v, V.height = w;
    let R = V.getContext("2d"), N = document.createElement("canvas");
    N.width = v, N.height = w;
    let M = N.getContext("2d");
    if (
      A !== null && R !== null && O !== null && L !== null &&
      M !== null && z !== null
    ) {
      e.settings.disableFill = true,
        e.screenshotToCanvas(V, {
          width: v,
          height: w,
          targetPixelRatio: 1,
          transparentBackground: true,
          showMovablePoints: n,
        }),
        e.settings.disableFill = false,
        e.screenshotToCanvas(P, {
          width: v,
          height: w,
          targetPixelRatio: 1,
          transparentBackground: true,
          showMovablePoints: n,
        }),
        A.fillStyle = "white",
        A.fillRect(0, 0, r.width, r.height);
      let F = Math.round(_.mapx(0)),
        Z = Math.round(_.mapy(0)),
        te = l.xAxisLabel !== "" ? l.xAxisLabel.replace(/ /g, "\\ ") : "x",
        Y = l.yAxisLabel !== "" ? l.yAxisLabel.replace(/ /g, "\\ ") : "y",
        he = 1;
      if (d && _.coordsAreOnscreen(v - 6, Z - 8, 0)) {
        let q = { ...a, cellPadding: a.cellPadding + he },
          oe = 2 + 2 * OD(q, te),
          K = v - 2,
          fe = Z - oe,
          me = Up(te, i);
        ({ x: K, y: fe } = XP(q, K, fe, me)),
          { x: K, y: fe } = Gv(q, O, K, fe, me),
          Lv(q, M, K, fe, me);
      }
      if (p && _.coordsAreOnscreen(F + 4, 1, 0)) {
        let q = { ...a, cellPadding: a.cellPadding + he },
          oe = F + 4,
          K = 1,
          fe = Up(Y, i);
        ({ x: oe, y: K } = Gv(q, O, oe, K, fe)), Lv(q, M, oe, K, fe);
      }
      let { x: se, y: ae } = qie(a, i, _);
      if (d) {
        let q;
        for (let oe of se) {
          if (oe === 0 && p) continue;
          let K = Math.round(_.mapx(oe));
          if (!(K < 2 || K > _.screen.width - 2) && h) {
            let fe = zp(a, Up("-1", i)) - zp(a, Up("1", i)),
              me = oe < 0 ? fe + 1 : 1,
              we = K - me,
              Ce = Z + 4,
              _e = Up("" + oe, i);
            ({ x: we, y: Ce } = Gv(a, M, we, Ce, _e)),
              YP(a, R, we, Ce, _e) &&
              (Lv(a, M, we, Ce, _e), q = LD(q, RD(a, we, Ce, _e)));
          }
        }
        a.embossPatternInequalities && q &&
          (q = LD(q, { x: 0, y: Z, width: v, height: 0 }),
            L.fillStyle = "white",
            L.fillRect(q.x, q.y, q.width, q.height));
      }
      if (p) {
        let q;
        for (let oe of ae) {
          if (oe === 0 && d) continue;
          let K = Math.round(_.mapy(oe));
          if (K < 2 || K > _.screen.height - 2) continue;
          let fe = -Math.ceil(OD(a, " ") / 2);
          if (f) {
            let me = F - 4, we = K + fe, Ce = Up("" + oe, i);
            ({ x: me, y: we } = XP(a, me, we, Ce)),
              { x: me, y: we } = Gv(a, M, me, we, Ce),
              YP(a, R, me, we, Ce) &&
              (Lv(a, M, me, we, Ce), q = LD(q, RD(a, me, we, Ce)));
          }
        }
        a.embossPatternInequalities && q &&
          (q = LD(q, { x: F, y: 0, width: 0, height: w }),
            L.fillStyle = "white",
            L.fillRect(q.x, q.y, q.width, q.height));
      }
      if (d && p) {
        let q = F - 2, oe = Z + 2, K = Up(h || f ? "0" : "o", i);
        ({ x: q, y: oe } = XP(a, q, oe, K)),
          _.coordsAreOnscreen(q, oe, 0) &&
          ({ x: q, y: oe } = Gv(a, M, q, oe, K),
            YP(a, R, q, oe, K) && Lv(a, M, q, oe, K));
      }
      for (let q of se) {
        let oe = Math.round(_.mapx(q));
        oe < 2 || oe > _.screen.width - 2 || p && q === 0 ||
          c && Pv(L, "white", oe - 1, 0, w, 3);
      }
      for (let q of ae) {
        let oe = Math.round(_.mapy(q));
        oe < 2 || oe > _.screen.height - 2 || d && q === 0 ||
          c && Vv(L, "white", oe - 1, 0, v, 3);
      }
      d && Vv(L, "white", Z - 3, 0, v, 7), p && Pv(L, "white", F - 3, 0, w, 7);
      for (let q of se) {
        let oe = Math.round(_.mapx(q));
        oe < 2 || oe > _.screen.width - 2 || p && q === 0 ||
          (c ? Pv(L, PD(o), oe, 0, w) : d && Pv(L, PD(o), oe, Z - 3, Z + 2));
      }
      for (let q of ae) {
        let oe = Math.round(_.mapy(q));
        oe < 2 || oe > _.screen.height - 2 || d && q === 0 ||
          (c ? Vv(L, PD(o), oe, 0, v) : p && Vv(L, PD(o), oe, F - 3, F + 2));
      }
      if (
        d && Vv(L, hy(o), Z, 0, v),
          p && Pv(L, hy(o), F, 0, w),
          y !== "NONE" &&
          (Yie(L, hy(o), F, 0), y === "BOTH" && jie(L, hy(o), F, w - 1)),
          u !== "NONE" &&
          (Wie(L, hy(o), v - 1, Z), u === "BOTH" && $ie(L, hy(o), 0, Z)),
          a.embossPatternInequalities
      ) {
        for (let q = 0; q < v; q += 6) {
          for (let oe = 0; oe < w; oe += 6) {
            let K = { x: q, y: oe, width: 3, height: 3 };
            Nie(O, K) && VD(L, K) && VD(R, K) && VD(M, K) &&
              Xie(z, "black", q, oe);
          }
        }
      }
      a.embossPatternInequalities || A.drawImage(P, s.left, s.top),
        A.drawImage(x, s.left, s.top),
        A.drawImage(V, s.left, s.top),
        A.drawImage(N, s.left, s.top),
        a.embossPatternInequalities && A.drawImage(U, s.left, s.top);
    }
    for (let F in E) e.settings[F] = l[F];
  }
  function Hie(r) {
    if (r === "etc8" || r === "etc11") {
      return {
        dotSpacing: 0,
        cellPadding: 1,
        graphLineWidth: 1.75,
        embossPatternInequalities: true,
      };
    }
    if (r === "vpmax8" || r === "vpmax11") {
      return {
        dotSpacing: 1,
        cellPadding: 2,
        graphLineWidth: 1,
        embossPatternInequalities: false,
      };
    }
    {
      let e = r;
      throw new Error(`Unexpected embosser model ${e}`);
    }
  }
  function Kie(r) {
    if (r === "etc8" || r === "etc11") return false;
    if (r === "vpmax8" || r === "vpmax11") return true;
    {
      let e = r;
      throw new Error(`Unexpected embosser model ${e}`);
    }
  }
  function hy(r) {
    switch (r) {
      case "vpmax8":
      case "vpmax11":
        return "rgb(145, 145, 145)";
      case "etc8":
      case "etc11":
        return "rgb(0, 0, 0)";
      default:
        let e = r;
        throw new Error("Unexpected embosser model: " + e);
    }
  }
  function PD(r) {
    switch (r) {
      case "vpmax8":
      case "vpmax11":
        return "rgb(219, 219, 219)";
      case "etc8":
      case "etc11":
        return "rgb(0, 0, 0)";
      default:
        let e = r;
        throw new Error("Unexpected embosser model: " + e);
    }
  }
  function Pv(r, e, t, o, i, n = 1) {
    let a = r.fillStyle;
    r.fillStyle = e, r.fillRect(t - 1, o, n, i - o), r.fillStyle = a;
  }
  function Vv(r, e, t, o, i, n = 1) {
    let a = r.fillStyle;
    r.fillStyle = e, r.fillRect(o, t - 1, i - o, n), r.fillStyle = a;
  }
  function Wie(r, e, t, o) {
    let i = r.fillStyle;
    r.fillStyle = e;
    for (let n = -2; n <= 2; n++) {
      r.fillRect(t - Math.abs(n), o - 1 + n, 1, 1);
    }
    r.fillStyle = i;
  }
  function $ie(r, e, t, o) {
    let i = r.fillStyle;
    r.fillStyle = e;
    for (let n = -2; n <= 2; n++) {
      r.fillRect(t + Math.abs(n), o - 1 + n, 1, 1);
    }
    r.fillStyle = i;
  }
  function jie(r, e, t, o) {
    let i = r.fillStyle;
    r.fillStyle = e;
    for (let n = -2; n <= 2; n++) {
      r.fillRect(t - 1 + n, o - Math.abs(n), 1, 1);
    }
    r.fillStyle = i;
  }
  function Yie(r, e, t, o) {
    let i = r.fillStyle;
    r.fillStyle = e;
    for (let n = -2; n <= 2; n++) {
      r.fillRect(t - 1 + n, o + Math.abs(n), 1, 1);
    }
    r.fillStyle = i;
  }
  function Xie(r, e, t, o) {
    let i = r.fillStyle;
    r.fillStyle = e,
      r.fillRect(t + 1, o, 1, 1),
      r.fillRect(t, o + 1, 1, 1),
      r.fillRect(t + 1, o + 1, 1, 1),
      r.fillRect(t + 2, o + 1, 1, 1),
      r.fillRect(t + 1, o + 2, 1, 1),
      r.fillStyle = i;
  }
  var jAe = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  function JP(r, e) {
    return `${r}_dcg_delim_${e}`;
  }
  var Ov = class {
    constructor(e) {
      this.hoveredObjects = {},
        this.grapher = e,
        this.controller = this.grapher.controller,
        this.renderedTabTargetOrder = [],
        this.renderedTabTargets = {};
    }
    getOrderedTabTargets() {
      return this.renderedTabTargetOrder.map((e) => {
        let t = this.renderedTabTargets[e];
        return {
          calcId: t.id,
          listIndex: t.listIndex,
          polygonEdge: void 0,
          description: t.description,
        };
      });
    }
    recomputeClickableObjects() {
      this.renderedTabTargets = {}, this.renderedTabTargetOrder = [];
      for (let e of this.grapher.getTabOrder()) {
        let t = this.controller.getItemModel(e);
        if (!t) continue;
        let o = this.grapher.getGraphSketch(e),
          i = this.grapher.getGraphImage(e);
        if (o && t.type === "expression" && $n(t)) {
          for (let n = 0; n < o.branches.length; n++) {
            let a = o.branches[n];
            if (!a.segments || a.segments.length === 0) {
              continue;
            }
            let s = 0;
            __dcg_shared_module_exports__["_d"](a)
              ? o.getBranchPOI(n).forEach((l) => {
                s = l.pointIdxOnBranch || 0,
                  isFinite(l.x) && isFinite(l.y) &&
                  this.addTabTarget(t, s);
              })
              : (s = "listIndex" in a && a.listIndex !== void 0
                ? a.listIndex
                : 0,
                a.segments.length > 0 && this.addTabTarget(t, s));
          }
        } else if (i && i.shouldGraph && t.type === "image" && Dg(t)) {
          let n = t.formula && t.formula.dimensions;
          if (
            !n || !n.x || !n.y || !n.width || !n.height || !n.radianAngle
          ) continue;
          for (let a = 0; a < n.x.length; a++) {
            isFinite(n.x[a]) && isFinite(n.y[a]) &&
              isFinite(n.width[a]) && isFinite(n.height[a]) &&
              isFinite(n.radianAngle[a]) && this.addTabTarget(t, a);
          }
        }
      }
      Object.keys(this.hoveredObjects).length || this.pressedObject
        ? this.grapher.setLayerClass(
          "clickableObjects",
          "dcg-mouse-over-clickable-object",
        )
        : this.grapher.setLayerClass("clickableObjects", void 0);
    }
    addTabTarget(e, t) {
      let o = JP(e.id, t);
      this.renderedTabTargetOrder.indexOf(o) !== -1 ||
        this.renderedTabTargets[o] !== void 0 ||
        (this.renderedTabTargetOrder.push(o),
          this.renderedTabTargets[o] = {
            type: e.type,
            id: e.id,
            listIndex: t,
            description: this.getComputedDescription(e, t),
          });
    }
    getTabIndex(e) {
      if (
        this.controller.getActiveTool() !== "selection" ||
        !this.renderedTabTargets[e]
      ) return -1;
      let o = this.grapher.settings;
      return !o.config.graphpaper || !o.config.enableTabindex ? -1 : 0;
    }
    getAriaHidden() {
      return !this.grapher.settings.config.graphpaper;
    }
    getCachedDescription(e) {
      return this.renderedTabTargets[e].description;
    }
    getComputedDescription(e, t) {
      let o = e.formula && e.formula.computed_description &&
        e.formula.computed_description[t];
      return o && o !== ""
        ? ei(o)
        : this.grapher.getAudioTrace().getExpressionAriaLabel(e.id);
    }
    getModelId(e) {
      let t = this.renderedTabTargets[e];
      return t ? t.id : "";
    }
    getListIndex(e) {
      let t = this.renderedTabTargets[e];
      if (t) return t.listIndex;
    }
    isKeyboardFocused(e, t) {
      if (!e) return false;
      let o = this.grapher.poiController.keyboardAttentionManager
          .getKeyboardAttention(),
        i = o == null ? void 0 : o.calcId;
      return e === i &&
        (t === void 0 || t === (o == null ? void 0 : o.listIndex));
    }
    shouldDrawHovered(e, t, o) {
      if (!t) return false;
      if (this.isKeyboardFocused(t, o)) return true;
      let {
        translationPreviewVectorParents: i,
        rotationPreviewAngleMarkerParents: n,
      } = e.transformationPreviewParentData;
      if (i.has(t) || n.has(t) && !this.controller.isToolPreviewItem(t)) {
        return true;
      }
      if (this.isAnObjectPressed() && !this.isObjectPressed(t)) return false;
      let a = this.getHoveredObjectById(t);
      return a
        ? a.listIndexes === void 0 || o === void 0 ? true : !!a.listIndexes[o]
        : false;
    }
    setHoveredObjects(e) {
      __dcg_shared_module_exports__["E"](e, this.hoveredObjects) ||
        (this.hoveredObjects = e, this.requestRedrawNextFrame());
    }
    getHoveredObjects() {
      let e = this.grapher.poiController.keyboardAttentionManager
        .getKeyboardAttention();
      if (e) {
        let t = __dcg_shared_module_exports__["Jc"](this.hoveredObjects),
          o = t[e.calcId],
          i = e.listIndex || 0;
        return o
          ? o.listIndexes
            ? o.listIndexes[i] = true
            : o.listIndexes = { [i]: true }
          : (o = { listIndexes: { [i]: true } }, t[e.calcId] = o),
          t;
      } else return this.hoveredObjects;
    }
    getHoveredObjectById(e) {
      return this.getHoveredObjects()[e];
    }
    shouldDrawPressed(e, t) {
      if (!e) return false;
      let o = this.pressedObject;
      return !o || o.id !== e ? false : t === void 0 ? true : o.listIndex === t;
    }
    isObjectPressed(e) {
      return e === void 0
        ? false
        : !!(this.pressedObject && this.pressedObject.id === e);
    }
    setPressedObject(e) {
      !e && !this.pressedObject ||
        e && this.pressedObject && e.id === this.pressedObject.id &&
          e.listIndex === this.pressedObject.listIndex ||
        (this.pressedObject = e, this.requestRedrawNextFrame());
    }
    getPressedObject() {
      return this.pressedObject;
    }
    isAnObjectPressed() {
      return !!this.pressedObject;
    }
    requestRedrawNextFrame() {
      this.controller.requestRedrawGraph();
    }
    shouldDrawGhosted(e) {
      if (!e) return false;
      let t = this.controller.getItemModel(e);
      return !t || t.type !== "expression" ? false : Hi(t);
    }
  };
  var qp = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    { If: Qie } = qp.Components,
    FD = class extends qp.Class {
      init() {
        this.controller = this.props.grapher().controller,
          this.poiController = this.props.grapher().poiController;
      }
      template() {
        return qp.createElement(
          Qie,
          { predicate: this.bindFn(this.showCursor) },
          () =>
            qp.createElement("div", {
              class: qp.const("dcg-geo-keyboard-cursor"),
              style: () => ({
                top: `${this.getPosition().y}px`,
                left: `${this.getPosition().x}px`,
              }),
            }),
        );
      }
      getPosition() {
        let e = this.poiController.getGeoKeyboardPt(),
          t = this.props.grapher().getProjection();
        return { x: t.mapx(e.x), y: t.mapy(e.y) };
      }
      showCursor() {
        return this.controller.isVirtualMouseAllowed();
      }
    };
  var r6 = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var ka = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: Zie } = ka.Components,
    ND = class extends ka.Class {
      init() {
        this.grapher = this.props.grapher(),
          this.controller = this.grapher.controller,
          this.width = 0,
          this.height = 0,
          this.pixelRatio = 0;
      }
      getDevicePixelRatio() {
        return window.devicePixelRatio || 1;
      }
      template() {
        return ka.createElement(
          "div",
          {
            class: ka.const("dcg-graph-outer"),
            didMount: (e) => this.rootNode = e,
            manageFocus: this.const(
              rt({
                controller: this.controller,
                location: { type: "graph-paper" },
              }),
            ),
          },
          ka.createElement("div", {
            tabIndex: () => this.getShiftTabElementTabIndex(),
            onFocus: () => {
              let e = this.rootNode.getAttribute("aria-label") || "";
              this.rootNode.setAttribute("aria-label", ""),
                this.rootNode.focus(),
                this.rootNode.setAttribute("aria-label", e),
                this.controller.get2dPOIController().handleTabEvent(
                  "prev",
                );
            },
          }),
          ka.createElement(Zie, {
            predicate: () => this.isIOSAndIframe(),
          }, () =>
            ka.createElement("div", {
              style: ka.const(
                "width:1px; height:.5px; pointer-events:none; opacity: 0;",
              ),
              "aria-hidden": ka.const("true"),
            }, ka.const("text"))),
          ka.createElement("canvas", {
            class: ka.const("dcg-graph-inner"),
            didMount: (e) => {
              this.canvasNode = e,
                this.ctx = this.canvasNode.getContext("2d"),
                this.resize(0, 0);
            },
            style: () => ({
              position: "relative",
              display: "block",
              outline: "none",
              "-webkit-transform": this.isIOSAndIframe()
                ? "translate3d(0,-.25px,0)"
                : void 0,
            }),
          }),
        );
      }
      getShiftTabElementTabIndex() {
        var t;
        return ((t = this.rootNode) == null
                ? void 0
                : t.getAttribute("tabindex")) !== "0" ||
            this.controller.getActiveTool() !== "selection" ||
            this.rootNode === document.activeElement
          ? "-1"
          : "0";
      }
      isIOSAndIframe() {
        return Ml && mp;
      }
      resize(e, t, o) {
        var i;
        o = o || this.getDevicePixelRatio(),
          !(e === this.width && t === this.height &&
            o === this.pixelRatio) &&
          (this.width = e,
            this.height = t,
            this.canvasNode.style.width = e + "px",
            this.canvasNode.style.height = t + "px",
            this.canvasNode.setAttribute("width", "" + e * o),
            this.canvasNode.setAttribute("height", "" + t * o),
            this.pixelRatio = o,
            this.ctx = this.canvasNode.getContext("2d"),
            (i = this.ctx) == null || i.scale(o, o),
            this.update());
      }
      getAriaLabel(e) {
        let t = [],
          { graphDescription: o } = this.grapher.settings.config;
        if (this.grapher.type === "3d" && this.controller.is3dProduct()) {
          o !== void 0 ? t.push(o) : (t.push(
            `${
              this.controller.s(
                "graphing-calculator-narration-3d-graphpaper-label",
              )
            }.`,
          ),
            t.push(Iv(this.controller)));
        } else if (
          this.grapher.type === "2d" && !this.controller.is3dProduct()
        ) {
          let i = this.grapher.getAudioTrace();
          if (!i) return "";
          o !== void 0 ? t.push(o) : (t.push(
            `${
              this.controller.s(
                "graphing-calculator-narration-graphpaper-label",
              )
            }.`,
          ),
            t.push(Iv(this.controller)),
            e > 0 &&
            (i.getAudioTraceActive() ||
              i.agNavigator.getFirstTraceableSketch({
                      selectAssociatedExpression: false,
                    }) !== void 0 && (Zo
                    ? t.push(
                      this.controller.s(
                        "graphing-calculator-narration-audio-instructions-enter-audio-trace-mac",
                      ),
                    )
                    : t.push(
                      this.controller.s(
                        "graphing-calculator-narration-audio-instructions-enter-audio-trace-windows",
                      ),
                    ))));
        }
        if (t.length) return t.join(" ").trim();
      }
      updateAria(e, t) {
        let o = this.getAriaLabel(t);
        o !== void 0
          ? (this.rootNode.setAttribute("role", "img"),
            this.rootNode.setAttribute(
              "aria-roledescription",
              this.controller.s(
                "graphing-calculator-narration-graphpaper-label",
              ),
            ),
            this.rootNode.setAttribute("aria-label", o),
            this.rootNode.setAttribute(
              "aria-hidden",
              !e || !this.grapher.settings.config.graphpaper ? "true" : "false",
            ),
            this.rootNode.setAttribute(
              "tabindex",
              e && this.grapher.settings.config.graphpaper &&
                this.grapher.settings.config.enableTabindex
                ? "0"
                : "-1",
            ))
          : [
            "role",
            "aria-roledescription",
            "aria-label",
            "aria-hidden",
            "tabindex",
          ].forEach((n) => this.rootNode.removeAttribute(n)), this.update();
      }
      speakAriaLabelAgain() {
        let e = this.rootNode.getAttribute("aria-label");
        e && xe(e);
      }
    };
  var QP = class {
      constructor(e) {
        this._layerClasses = {};
        this._classLayers = {};
        this.elt = e.elt,
          this.settings = e.settings,
          this.controller = e.controller,
          this.evaluator = e.evaluator,
          this.elt.style.overflow = "hidden";
      }
      classLayers(e) {
        var t, o;
        return (o = (t = this._classLayers)[e]) != null ? o : t[e] = new Set();
      }
      setLayerClass(e, t) {
        let o = this._layerClasses[e];
        if (this._layerClasses[e] = t, o !== t) {
          if (o) {
            let i = this.classLayers(o);
            i.delete(e), i.size === 0 && this.elt.classList.remove(o);
          }
          t && (this.classLayers(t).add(e), this.elt.classList.add(t));
        }
      }
    },
    ZP = class extends QP {
      constructor(e) {
        super(e),
          this.canvasLayer = r6.mountToNode(ND, this.elt, {
            grapher: () => this,
          }),
          this.elt.appendChild(this.canvasLayer.rootNode);
      }
      getImageData(e, t, o, i) {
        var n;
        return (n = this.canvasLayer.ctx) == null
          ? void 0
          : n.getImageData(e, t, o, i);
      }
      _setIsVisible(e) {
        e !== this.isVisible &&
          (this.isVisible = e,
            e
              ? this.controller.requestRedrawGraph()
              : this.canvasLayer.resize(0, 0));
      }
      getIsVisible() {
        return this.isVisible;
      }
    };
  function* Rv(r) {
    for (let e = 0; e < r.length; e++) yield* r[e].drawOrder;
  }
  var eV = class extends ZP {
      setDrawLayers(e) {
        __dcg_shared_module_exports__["E"](this.__drawLayers, e) ||
          (this.__drawLayers = e, this.controller.requestRedrawGraph());
      }
      setTabOrder(e) {
        this.__tabOrder = e;
      }
      getDrawLayers() {
        return this.__drawLayers;
      }
      getTabOrder() {
        return this.__tabOrder;
      }
      generateMergeDrawOrder() {
        return Rv(this.__drawLayers);
      }
    },
    tV = class extends eV {
      constructor() {
        super(...arguments);
        this.__redrawRequested = false;
        this.events = new Kl();
      }
      redrawAllLayers() {
        this.__redrawRequested = true;
      }
      redrawAllLayersSynchronously() {
        return this._redrawAllLayers();
      }
      notifyAfterRedraw(t) {
        if (!this.__redrawRequested) t();
        else {
          this.notifyAfterRedraw_i
            ? this.notifyAfterRedraw_i++
            : this.notifyAfterRedraw_i = 1;
          let o = "redraw.notifyAfterRedraw" + this.notifyAfterRedraw_i;
          this.events.observeEvent(o, () => {
            this.events.unobserveEvent(o), t();
          });
        }
      }
    },
    rV = class extends tV {
      getUserRequestedViewport() {
        return this._lastUserRequestedViewport;
      }
      setUserRequestedViewport(e) {
        this._lastUserRequestedViewportUpdateToken ||
        (this._lastUserRequestedViewportUpdateToken = 0),
          this._lastUserRequestedViewportUpdateToken += 1,
          this._lastUserRequestedViewport = __dcg_shared_module_exports__
            ["Jc"](e),
          this._afterViewportChange();
      }
      getCurrentViewport() {
        return this.viewportController.getViewport().toObject();
      }
      debounceUserRequestedViewportChange() {
        this.__debouncedViewportCommit ||
          (this.__debouncedViewportCommit = __dcg_shared_module_exports__
            ["A"]((o, i) => {
              if (
                !this.isDragging &&
                this._lastUserRequestedViewportUpdateToken === i
              ) {
                if (this._lastUserRequestedViewport) {
                  let n = Br.fromObject(this._lastUserRequestedViewport);
                  if (this.computeConcreteViewport(n).equals(o)) return;
                }
                this.controller.dispatch({
                  type: "commit-user-requested-viewport",
                  viewport: o,
                });
              }
            }, 1e3));
        let e = this.getCurrentViewport();
        this.__debouncedViewportCommit(
          e,
          this._lastUserRequestedViewportUpdateToken,
        );
      }
    },
    oV = class extends rV {
      getState(e) {
        let t = { ...this.getCurrentViewport() };
        this.controller.is3dProduct() || (delete t.zmin, delete t.zmax);
        let o = { viewport: t };
        return this.settings.stateProperties.forEach((i) => {
          i !== "randomSeed" &&
            i !== "includeFunctionParametersInRandomSeed" &&
            (!this.controller.is3dProduct() && TK(i) ||
              (o[i] = this.settings[i]));
        }),
          e.stripDefaults &&
          (o = __dcg_shared_module_exports__["md"](Os, o)),
          o;
      }
      getUndoRedoDiffState() {
        let e = this.getUndoRedoFullState();
        return e.speed3D !== 0 && delete e.worldRotation3D, e;
      }
      getUndoRedoFullState() {
        let e = {};
        return this.settings.stateProperties.forEach((t) => {
          e[t] = this.settings[t];
        }),
          e.viewport = this.getUserRequestedViewport(),
          e;
      }
    },
    my = class extends oV {};
  var BD = class {
    constructor(e, t) {
      this.is3d = false;
      this.color = "#000000",
        this.style = "normal",
        this.showPOI = false,
        this.showHighlight = false,
        this.hoistToTop = false,
        this.selected = false,
        this.tokenHovered = false,
        this.tokenSelected = false,
        this.labels = [],
        this.id = e,
        this.branches = t !== void 0 ? t : [],
        this.getPOI().forEach((o) => {
          o.type === 1008 && this.labels.push({ type: "poi", poi: o });
        }),
        t.forEach((o, i) => {
          if (o.graphMode === 22) {
            if (o.objectType === 17) {
              let n = new Lp(0, 0, 1008, this, i, 0, false);
              this.labels.push({
                id: "label-" + e + "-" + (o.listIndex || 0),
                type: "segment",
                poi: n,
                segments: o.segments[0],
                text: o.labels && o.labels[0] || "",
              });
            } else if (o.objectType === 16) {
              let n = new Lp(0, 0, 1008, this, i, 0, false);
              this.labels.push({
                id: "label-" + e + "-" + (o.listIndex || 0),
                type: "polygon",
                poi: n,
                segments: o.segments[0],
                text: o.labels && o.labels[0] || "",
              });
            } else if (o.objectType === 23) {
              let n = new Lp(0, 0, 1008, this, i, 0, false);
              this.labels.push({
                id: "label-" + e + "-" + (o.listIndex || 0),
                type: "angle",
                poi: n,
                segments: o.segments[0],
                text: o.labels && o.labels[0] || "",
              });
            }
          }
        });
    }
    getPOI() {
      if (this.__cachedPOI) return this.__cachedPOI;
      this.__cachedPOI = [], this.__cachedPOIIds = {};
      for (let e = 0; e < this.branches.length; e++) {
        let t = this.branches[e];
        if (t.graphMode === 1 || t.graphMode === 2) {
          let o = t.poi;
          o.zeros && this._pushPOI(o.zeros, e, 1002),
            o.intercept && this._pushPOI(o.intercept, e, 1003),
            o.extrema && this._pushPOI(o.extrema, e, 1004),
            o.intersections && this._pushPOI(o.intersections, e, 1001);
        } else if (__dcg_shared_module_exports__["_d"](t)) {
          let o = t.poi,
            i = (t.graphMode === 3 || t.graphMode === 25) &&
              t.interactiveLabel === true;
          if (t.showLabel === true || i) {
            let n = t.nakedLabel;
            o.defined && this._pushPOI(o.defined, e, 1008, n);
          } else o.defined && this._pushPOI(o.defined, e, 1006);
        }
      }
      return this.__cachedPOI;
    }
    getBranchPOI(e) {
      return this.getPOI().filter((t) => t.branch === e);
    }
    getMovablePoints() {
      if (this.__cachedMovablePoints) return this.__cachedMovablePoints;
      this.__cachedMovablePoints = [];
      let e = this.branches[0];
      if (
        e && e.segments.length === 1 &&
        __dcg_shared_module_exports__["$d"](e)
      ) {
        let t = e.segments[0];
        for (let o = 0; o < t.length; o++) {
          let i;
          e.tableId &&
            (i = {
              tableId: e.tableId,
              columnId: this.id,
              rowIndex: e.movablePointInfo[o].index,
              dragX: e.movablePointInfo[o].dragX,
              dragY: e.movablePointInfo[o].dragY,
            });
          let n = e.scaleFactors ? e.scaleFactors[0][o] : void 0,
            a = i ? i.rowIndex : o,
            s = e.segments.length === 1 && e.labels && e.labels[o]
              ? e.labels[o]
              : void 0,
            l = e.hasOwnProperty("pointOpacity") ? e.pointOpacity : 1,
            c = e.pointSize !== void 0 ? e.pointSize : 8;
          this.__cachedMovablePoints.push({
            type: "movable-point",
            id: "movable:[" + this.id + "," + a + "]",
            listIndex: a,
            sketch: this,
            color: this.color,
            pointOpacity: l,
            pointSize: c,
            tableInfo: i,
            scaleFactor: n,
            x: t[o][0],
            y: t[o][1],
            label: s,
            ariaLabel: s && ei(s),
          });
        }
      }
      return this.__cachedMovablePoints;
    }
    getMovablePointByIndex(e) {
      return this.getMovablePoints()[e];
    }
    getStaticLabeledPoints() {
      if (this.__cachedStaticLabeledPoints) {
        return this.__cachedStaticLabeledPoints;
      }
      let e = this.branches[0];
      return this.__cachedStaticLabeledPoints = [],
        this.getPOI().forEach((t) => {
          if (
            t.type !== 1006 && t.type !== 1008 ||
            e.graphMode !== 3 && e.graphMode !== 25
          ) return;
          let o = e.showLabel, i = t.getLabel();
          !o && i === "" ||
            this.__cachedStaticLabeledPoints.push({
              type: "static-labeled-point",
              id: "static[" + this.id + "," + t.id + "]",
              listIndex: t.pointIdxOnBranch,
              x: t.x,
              y: t.y,
              sketch: t.sketch,
              label: i,
              ariaLabel: i !== "" ? ei(i) : void 0,
            });
        }),
        this.__cachedStaticLabeledPoints;
    }
    _pushPOI(e, t, o, i = false) {
      for (let n = 0, a = e.x.length; n < a; n++) {
        let s = new Lp(e.x[n], e.y[n], o, this, t, n, i);
        e.intersects && (s.intersects = e.intersects[n]),
          this.__cachedPOI.push(s),
          this.__cachedPOIIds[s.id] = s;
      }
    }
    updateIntersections(e) {
      for (let o = 0, i = this.branches.length; o < i; o++) {
        let n = this.branches[o];
        n.graphMode !== 15 && n.graphMode !== 22 &&
          (n.poi.intersections = e[o]);
      }
      let t = this.__cachedPOI;
      this.__cachedPOI = [],
        t.forEach((o) => {
          o.type !== 1001
            ? this.__cachedPOI.push(o)
            : delete this.__cachedPOIIds[o.id];
        });
      for (let o = 0; o < this.branches.length; o++) {
        let i = this.branches[o];
        if (i.graphMode === 1 || i.graphMode === 2) {
          let n = i.poi;
          n.intersections && this._pushPOI(n.intersections, o, 1001);
        }
      }
    }
    getPOIById(e) {
      return this.__cachedPOIIds[e];
    }
    updateFrom(e) {
      if (
        e &&
        (this.showPOI = e.showPOI,
          this.showHighlight = e.showHighlight,
          this.hoistToTop = e.hoistToTop,
          this.selected = e.selected,
          this.tokenSelected = e.tokenSelected,
          this.tokenHovered = e.tokenHovered,
          __dcg_shared_module_exports__["_d"](this.branches[0]))
      ) {
        let t = true;
        for (let o = 0; o < this.__cachedPOI.length; o++) {
          let i = e.__cachedPOI[o], n = this.__cachedPOI[o];
          if (!i || i.type !== n.type) {
            t = false;
            break;
          }
        }
        if (t) {
          for (let o = 0; o < this.__cachedPOI.length; o++) {
            let i = e.__cachedPOI[o], n = this.__cachedPOI[o];
            delete this.__cachedPOIIds[n.id],
              this.__cachedPOIIds[i.id] = n,
              n.id = i.id;
          }
        }
      }
    }
  };
  var Hp = document.createElement("canvas").getContext("2d"),
    _a = class r {
      constructor(e, t) {
        this._label = e, this._fontSize = t, this._layout = tne(e, t);
      }
      getRect() {
        return this.getRectWhenCenteredAt({ x: 0, y: 0 });
      }
      getRectWhenCenteredAt(e) {
        return {
          left: this._layout.left + e.x,
          right: this._layout.right + e.x,
          top: this._layout.top + e.y,
          bottom: this._layout.bottom + e.y,
        };
      }
      getBoundsWhenCenteredAt(e, t) {
        switch (t) {
          case "x":
            return {
              lower: this._layout.left + e,
              upper: this._layout.right + e,
            };
          case "y":
            return {
              lower: this._layout.top + e,
              upper: this._layout.bottom + e,
            };
          default:
            let o = t;
            throw new Error(`Unknown axis: ${o}`);
        }
      }
      getWidth() {
        return this._layout.right - this._layout.left;
      }
      getHeight() {
        return this._layout.bottom - this._layout.top;
      }
      getDimensionAlongAxis(e) {
        switch (e) {
          case "x":
            return this.getWidth();
          case "y":
            return this.getHeight();
          default:
            let t = e;
            throw new Error(`Unknown axis: ${t}`);
        }
      }
      clampBoundsWithinRect(e, t) {
        let o, i;
        return e.x + this._layout.left < t.left
          ? o = t.left - this._layout.left
          : e.x + this._layout.right > t.right
          ? o = t.right - this._layout.right
          : o = e.x,
          e.y + this._layout.top < t.top
            ? i = t.top - this._layout.top
            : e.y + this._layout.bottom > t.bottom
            ? i = t.bottom - this._layout.bottom
            : i = e.y,
          { x: o, y: i };
      }
      getValue() {
        return this._label.value;
      }
      getMinusWidth() {
        return this.getValue() < 0
          ? (r.setCtxFontSize(Hp, this._fontSize),
            Hp.measureText("-1").width - Hp.measureText("1").width)
          : 0;
      }
      getString() {
        return this._label.superscript
          ? this._label.mantissa + "^" + this._label.superscript
          : this._label.string;
      }
      drawCenteredAt(e, t, o) {
        let i = t.x, n = r.computeBaselineFromCenter(t.y, this._fontSize);
        o && No(e, o),
          e.save(),
          o && To(e),
          r.setCtxFontSize(e, this._fontSize),
          this._label.superscript
            ? (e.strokeText(
              this._label.mantissa,
              this._layout.mantissa_x + i,
              this._layout.mantissa_y + n,
            ),
              e.strokeText(
                this._label.superscript,
                this._layout.superscript_x + i,
                this._layout.superscript_y + n,
              ),
              e.fillText(
                this._label.mantissa,
                this._layout.mantissa_x + i,
                this._layout.mantissa_y + n,
              ),
              e.fillText(
                this._label.superscript,
                this._layout.superscript_x + i,
                this._layout.superscript_y + n,
              ))
            : (e.strokeText(
              this._label.string,
              this._layout.mantissa_x + i,
              this._layout.mantissa_y + n,
            ),
              e.fillText(
                this._label.string,
                this._layout.mantissa_x + i,
                this._layout.mantissa_y + n,
              )),
          e.restore();
      }
      static computeBaselineFromCenter(e, t) {
        return e + .272 * t;
      }
      static setCtxFontSize(e, t) {
        e.font = t + "px Arial", e.textAlign = "center";
      }
    };
  function tne(r, e) {
    if (r.superscript) {
      let t = e;
      _a.setCtxFontSize(Hp, t);
      let o = Hp.measureText(r.mantissa).width, i = Math.round(.8 * e);
      _a.setCtxFontSize(Hp, i);
      let n = Hp.measureText(r.superscript).width,
        a = 0,
        s = e / 5,
        l = o / 2 + n / 2,
        c = -e / 4,
        d = c - i / 2,
        p = s + t / 2,
        h = a - o / 2,
        u = l + n / 2;
      return {
        top: d,
        bottom: p,
        left: h,
        right: u,
        mantissa_height: t,
        mantissa_width: o,
        mantissa_x: a,
        mantissa_y: s,
        superscript_height: i,
        superscript_width: n,
        superscript_x: l,
        superscript_y: c,
      };
    } else {
      let t = e;
      _a.setCtxFontSize(Hp, e);
      let o = Hp.measureText(r.string).width,
        i = 0,
        n = 0,
        a = n - t / 2,
        s = n + t / 2,
        l = i - o / 2,
        c = i + o / 2;
      return {
        top: a,
        bottom: s,
        left: l,
        right: c,
        mantissa_height: t,
        mantissa_width: o,
        mantissa_x: i,
        mantissa_y: n,
      };
    }
  }
  function rne(r, e, t, o) {
    let i = Math.ceil(r / t), n = Math.floor(e / t), a = 1 / t;
    if (!(i > n) && !(n - i > 1e4)) {
      for (let s = i; s <= n; s++) {
        o(
          s / a,
        );
      }
    }
  }
  var iV = { base: 10, major: [1, 2, 5], minor: [5, 4, 5] },
    one = {
      base: 10,
      major: [Math.PI, 2 * Math.PI, 5 * Math.PI],
      minor: [4, 4, 5],
    },
    ine = { base: 2, major: [Math.PI / 3], minor: [3] };
  function nne(r) {
    return r ? { base: 10, major: [r, 2 * r, 5 * r], minor: [4, 4, 5] } : iV;
  }
  function nV(r, e) {
    let { major: t, minor: o, base: i } = e, n = 1 / 0, a = 1 / 0;
    for (let s = 0; s < t.length; s++) {
      let l = t[s],
        c = Math.ceil(Math.log(r / l) / Math.log(i)),
        d = l * Math.pow(i, c);
      if (d < n) {
        n = d;
        let p = o[s];
        a = n / p;
      }
    }
    return { major: n, minor: a };
  }
  function ane(r, e, t) {
    return 1 + (e - r) / t;
  }
  function o6(r) {
    let e = r.screen.width,
      t = r.screen.height,
      o = r.viewport.xmax - r.viewport.xmin,
      i = r.viewport.ymax - r.viewport.ymin,
      n = r.settings.pixelsPerLabel;
    return { majorStepX: n / e * o, majorStepY: n / t * i };
  }
  function gl(r) {
    let e = (l) => {
        let [c, d, p, h, u] = l === "x"
            ? [
              r.viewport.xmin,
              r.viewport.xmax,
              r.settings.xAxisStep,
              r.settings.xAxisNumbers,
              r.settings.xAxisMinorSubdivisions,
            ]
            : [
              r.viewport.ymin,
              r.viewport.ymax,
              r.settings.yAxisStep,
              r.settings.yAxisNumbers,
              r.settings.yAxisMinorSubdivisions,
            ],
          f = d - c,
          y = Math.abs(p != null ? p : NaN),
          C = 0,
          E = 0;
        if (y && y !== Math.PI) {
          let v = ane(c, d, y);
          if (v >= 3 && v < 100) {
            let w = 0;
            if (h) {
              let k = 0;
              rne(c, d, y, (_) => {
                let A = new _a(
                  __dcg_shared_module_exports__["value"](_, f),
                  r.settings.labelSize,
                );
                k = Math.max(A.getDimensionAlongAxis(l), k);
              }), w = k + 10;
            } else w = u === 1 ? 8 : 20;
            let S = l === "x" ? "width" : "height";
            v * w <= r.screen[S] &&
              (C = y, y === 3 || y === 5 ? E = 1 : E = y / 4);
          }
        }
        if (!C) {
          let v = o6(r)[l === "x" ? "majorStepX" : "majorStepY"],
            w = nV(
              v,
              __dcg_shared_module_exports__["value"](y, f).string.indexOf(
                  "\u03C0",
                ) >= 0
                ? v >= 1 ? one : ine
                : nne(y),
            );
          C = w.major, E = w.minor;
        }
        return { majorStep: C, minorStep: E };
      },
      t = () => {
        var l, c;
        if (
          Math.abs((l = r.settings.xAxisStep) != null ? l : NaN) ===
            Math.abs((c = r.settings.yAxisStep) != null ? c : NaN)
        ) {
          let { xmin: h, xmax: u, ymin: f, ymax: y } = r.viewport,
            C = r.screen.width / (u - h),
            E = r.screen.height / (y - f),
            v = C / E,
            w = .01;
          if (v >= 1 - w && v <= 2) {
            let { majorStep: S, minorStep: k } = e("y");
            return {
              x: { majorStep: S, minorStep: k },
              y: { majorStep: S, minorStep: k },
            };
          }
          if (v <= 1 - w && v >= .5) {
            let { majorStep: S, minorStep: k } = e("x");
            return {
              x: { majorStep: S, minorStep: k },
              y: { majorStep: S, minorStep: k },
            };
          }
        }
        return { x: e("x"), y: e("y") };
      },
      o = () => {
        let { xAxisScale: l, yAxisScale: c } = r.settings,
          d = l === "logarithmic",
          p = c === "logarithmic";
        return !d && !p ? t() : {
          x: d ? { majorStep: NaN, minorStep: NaN } : e("x"),
          y: p ? { majorStep: NaN, minorStep: NaN } : e("y"),
        };
      },
      { x: i, y: n } = o(),
      { xAxisMinorSubdivisions: a = 0, yAxisMinorSubdivisions: s = 0 } =
        r.settings;
    return {
      majorStepX: i.majorStep,
      minorStepX: a > 0 ? i.majorStep / a : i.minorStep,
      majorStepY: n.majorStep,
      minorStepY: s > 0 ? n.majorStep / s : n.minorStep,
    };
  }
  function i6(r) {
    let e = o6(r),
      t = nV(e.majorStepX, iV),
      o = nV(e.majorStepY, iV),
      i = t.major > o.major ? t : o;
    return { majorStepR: i.major, minorStepR: i.minor };
  }
  var { floor: Xg, ceil: Jg, round: sne, log10: UD, log2: n6, abs: lh } = Math,
    sh = (r) => US ? `rgba(255,255,255,${r})` : `rgba(0,0,0,${r})`,
    HD = class {
      redrawToCtx(e, t) {
        let { ctx: o, projection: i } = e;
        Ja(o, "graphpaper");
        let n = i.settings.showGrid && !i.settings.threeDMode;
        if (i.settings.polarMode && n) {
          let a = i6(i);
          Ja(o, "grid"),
            this.drawPolarGrid(o, i, a),
            Qa(o),
            Ja(o, "axis"),
            this.drawAxes(o, i, t);
          let s = this.drawPolarStepNumbers(o, i, a);
          this.drawLabels(o, i, s), Qa(o);
        } else {
          let a = gl(i), s = aV(i);
          n && (Ja(o, "grid"), this.drawCartesianGrid(o, i, a, s), Qa(o));
          let l = !n && !i.settings.threeDMode;
          Ja(o, "axis"), i.settings.threeDMode || this.drawAxes(o, i, t);
          let c = this.drawCartesianStepNumbers(o, i, a, l, s);
          this.drawLabels(o, i, c), Qa(o);
        }
        Qa(o);
      }
      addTextShadow(e, t) {
        let { threeDMode: o, showPlane3D: i } = t.settings;
        e.strokeStyle = t.settings.getBackgroundColor({ invertWhite: o }),
          e.lineWidth = 3,
          o && (!i || t.settings.invertedColors) && (e.lineWidth = 1.5),
          e.miterLimit = 2;
      }
      drawPolarGrid(e, t, o) {
        e.save();
        let i = t.settings.minorAxisOpacity,
          a = 1 - (1 - t.settings.majorAxisOpacity) / (1 - i),
          s = __dcg_shared_module_exports__["Z"](t.mapx(0)),
          l = __dcg_shared_module_exports__["Z"](t.mapy(0)),
          c = t.screen.height / (t.viewport.ymax - t.viewport.ymin),
          d = t.screen.width / (t.viewport.xmax - t.viewport.xmin),
          p = c / d,
          h = d / c,
          u = l / p,
          f = t.viewport.smallestR(),
          y = t.viewport.largestR(),
          C = o.minorStepR * Math.max(1, Math.floor(f / o.minorStepR)),
          E = o.majorStepR * Math.max(1, Math.floor(f / o.majorStepR));
        e.lineWidth = 1, e.strokeStyle = sh(i);
        for (let w of ds(C, y, o.minorStepR)) {
          No(e, "dcg-svg-minor-gridline"), e.beginPath(), To(e), e.scale(1, p);
          let S = t.mapx(w) - s;
          e.moveTo(s + S, u),
            e.arc(s, u, S, 0, 2 * Math.PI),
            e.scale(1, h),
            e.stroke();
        }
        let v = f > 0 ? 5 : 15;
        for (let w of ds(0, 359, v)) {
          if (
            (w === 0 || w === 180) && t.settings.showXAxis ||
            (w === 90 || w === 270) && t.settings.showYAxis
          ) continue;
          No(e, "dcg-svg-minor-gridline"), e.beginPath(), To(e), e.moveTo(s, l);
          let S = t.mapx(y * Math.cos(w * Math.PI / 180)),
            k = t.mapy(y * Math.sin(w * Math.PI / 180));
          e.lineTo(
            __dcg_shared_module_exports__["Z"](S),
            __dcg_shared_module_exports__["Z"](k),
          ), e.stroke();
        }
        e.lineWidth = 1, e.strokeStyle = sh(a);
        for (let w of ds(E, y, o.majorStepR)) {
          No(e, "dcg-svg-major-gridline"), e.beginPath(), To(e), e.scale(1, p);
          let S = t.mapx(w) - s;
          e.moveTo(s + S, u),
            e.arc(s, u, S, 0, 2 * Math.PI),
            e.scale(1, h),
            e.stroke();
        }
        e.restore();
      }
      drawCartesianGrid(e, t, o, i = aV(t)) {
        e.save();
        let { xmin: n, xmax: a, ymin: s, ymax: l } = t.viewport,
          c = t.screen.width,
          d = t.screen.height,
          p = d,
          h = 0;
        t.settings.restrictGridToFirstQuadrant &&
          (n = 0, s = 0, p = t.mapy(0), h = t.mapx(0));
        let u = t.settings.minorAxisOpacity * i.x.unitOpacity,
          f = t.settings.minorAxisOpacity * i.y.unitOpacity,
          y = t.settings.majorAxisOpacity;
        e.lineWidth = 1;
        let C = (V) => {
            if (V === 0 && t.settings.showYAxis) return;
            let R = __dcg_shared_module_exports__["Z"](t.mapx(V));
            R === __dcg_shared_module_exports__["Z"](0) ||
              R === __dcg_shared_module_exports__["Z"](c) ||
              (e.beginPath(), e.moveTo(R, 0), e.lineTo(R, p), e.stroke());
          },
          E = (V) => {
            if (V === 0 && t.settings.showXAxis) return;
            let R = __dcg_shared_module_exports__["Z"](t.mapy(V));
            R === __dcg_shared_module_exports__["Z"](0) ||
              R === __dcg_shared_module_exports__["Z"](d) ||
              (e.beginPath(), e.moveTo(h, R), e.lineTo(c, R), e.stroke());
          };
        No(e, "dcg-svg-minor-gridline");
        let {
            majorStepX: v,
            majorStepY: w,
            minorStepX: S,
            minorStepY: k,
          } = o,
          _ = t.settings.xAxisScale === "logarithmic",
          A = t.settings.yAxisScale === "logarithmic",
          P = _ ? i.x.minor : ds(n, a, S),
          O = A ? i.y.minor : ds(s, l, k);
        e.strokeStyle = sh(u);
        for (let V of P) C(V);
        e.strokeStyle = sh(f);
        for (let V of O) E(V);
        To(e);
        let U = 1 - (1 - y) / (1 - u), z = 1 - (1 - y) / (1 - f);
        No(e, "dcg-svg-major-gridline");
        let x = _ ? i.x.major : ds(n, a, v),
          L = A ? i.y.major : ds(s, l, w);
        e.strokeStyle = sh(U);
        for (let V of x) C(V);
        e.strokeStyle = sh(z);
        for (let V of L) E(V);
        To(e), e.restore();
      }
      drawAxes(e, t, o) {
        let i = t.settings.axisLineOffset,
          n = t.settings.axisOpacity,
          a = `rgba(127,205,230,${n.toString()})`,
          s = sh(n),
          l = t.settings.xAxisArrowMode,
          c = t.settings.yAxisArrowMode,
          d = t.settings.showXAxis,
          p = t.settings.showYAxis,
          h = 1,
          u = Math.round(t.mapx(0)) - i,
          f = Math.round(t.mapy(0)) - i,
          y = t.screen.height,
          C = t.screen.width;
        function E(S, k, _) {
          e.save();
          let A = Math.PI / 12, P = 8 * Math.max(e.lineWidth, 1.5);
          e.lineJoin = "round",
            e.fillStyle = s,
            e.strokeStyle = s,
            e.beginPath(),
            e.moveTo(S, k),
            e.lineTo(S + Math.cos(_ - A) * P, k + Math.sin(_ - A) * P),
            e.lineTo(S + Math.cos(_ + A) * P, k + Math.sin(_ + A) * P),
            e.lineTo(S, k),
            e.lineTo(S + Math.cos(_ - A) * P, k + Math.sin(_ - A) * P),
            e.stroke(),
            e.fill(),
            e.restore();
        }
        let v = y, w = 0;
        t.settings.restrictGridToFirstQuadrant &&
        (v = f,
          w = u,
          l === "BOTH" && (l = "POSITIVE"),
          c === "BOTH" && (c = "POSITIVE")),
          p && (Ja(e, "yaxis"),
            t.settings.takingScreenshot &&
            rv(e, t.settings.yAxisLabel || "Y axis"),
            e.save(),
            No(e, "dcg-svg-axis-line"),
            e.lineWidth = t.settings.axisLineWidth * (o === "y" ? h : 1),
            e.strokeStyle = o === "y" ? a : s,
            c === "BOTH"
              ? (e.beginPath(),
                e.moveTo(u, 2 * t.settings.axisLineWidth),
                e.lineTo(u, y - 2 * t.settings.axisLineWidth),
                e.stroke(),
                E(u, y - t.settings.axisLineWidth, 3 * Math.PI / 2),
                E(u, t.settings.axisLineWidth, Math.PI / 2))
              : c === "POSITIVE"
              ? (e.beginPath(),
                e.moveTo(u, 2 * t.settings.axisLineWidth),
                e.lineTo(u, v),
                e.stroke(),
                E(u, t.settings.axisLineWidth, Math.PI / 2))
              : (e.beginPath(), e.moveTo(u, 0), e.lineTo(u, v), e.stroke()),
            To(e),
            e.restore(),
            Qa(e)),
          d && (Ja(e, "xaxis"),
            t.settings.takingScreenshot &&
            rv(e, t.settings.xAxisLabel || "X axis"),
            e.save(),
            No(e, "dcg-svg-axis-line"),
            e.lineWidth = t.settings.axisLineWidth * (o === "x" ? h : 1),
            e.strokeStyle = o === "x" ? a : s,
            l === "BOTH"
              ? (e.beginPath(),
                e.moveTo(2 * t.settings.axisLineWidth, f),
                e.lineTo(C - 2 * t.settings.axisLineWidth, f),
                e.stroke(),
                E(t.settings.axisLineWidth, f, 0),
                E(C - t.settings.axisLineWidth, f, Math.PI))
              : l === "POSITIVE"
              ? (e.beginPath(),
                e.lineTo(w, f),
                e.lineTo(C - 2 * t.settings.axisLineWidth, f),
                e.stroke(),
                E(C - t.settings.axisLineWidth, f, Math.PI))
              : (e.beginPath(), e.lineTo(w, f), e.lineTo(C, f), e.stroke()),
            To(e),
            e.restore(),
            Qa(e));
      }
      drawPolarStepNumbers(e, t, o) {
        e.save();
        let i = t.settings.showGrid,
          n = t.settings.xAxisNumbers && t.settings.showXAxis,
          a = t.settings.yAxisNumbers && t.settings.showYAxis,
          s = i && t.settings.polarNumbers,
          l = t.viewport.largestR(),
          c = t.viewport.smallestR(),
          d = t.viewport.xmin,
          p = t.viewport.xmax,
          h = t.viewport.ymin,
          u = t.viewport.ymax,
          f = t.screen.width,
          y = t.screen.height,
          C = { left: 3, right: f - 3, top: 3, bottom: y - 3 },
          E = t.settings.labelHangingColor,
          v = t.settings.getTextColor(),
          w = t.settings.labelSize,
          S = w;
        this.addTextShadow(e, t), e.fillStyle = v;
        function k(N, M, F) {
          let Z = Math.sqrt(N * N - M * M);
          h <= Z && Z <= u && F.push({ x: t.mapx(M), y: t.mapy(Z) }),
            h <= -Z && -Z <= u && F.push({ x: t.mapx(M), y: t.mapy(-Z) });
        }
        function _(N, M, F) {
          let Z = Math.sqrt(N * N - M * M);
          d <= Z && Z <= p && F.push({ x: t.mapx(Z), y: t.mapy(M) }),
            d <= -Z && -Z <= p && F.push({ x: t.mapx(-Z), y: t.mapy(M) });
        }
        let A = t.mapx(0),
          P = t.mapy(0),
          O = h <= 0 && 0 <= u,
          U = d <= 0 && 0 <= p,
          z = O && n,
          x = U && a,
          L = "";
        if (!z && !x && i) {
          let N = lh(A),
            M = lh(A - f),
            F = lh(P),
            Z = lh(P - y),
            te,
            Y,
            he,
            se;
          N <= M ? (te = "left", he = N) : (te = "right", he = M),
            F <= Z ? (Y = "top", se = F) : (Y = "bottom", se = Z),
            n && a ? L = he <= se ? te : Y : a ? L = te : n && (L = Y);
        }
        let V = { left: 0, right: f, top: P - 1, bottom: P + 1 },
          R = { left: A - 1, right: A + 1, top: 0, bottom: y };
        for (let N of ds(0, l, o.majorStepR)) {
          let M = [],
            F = [],
            Z = [],
            te = new _a(__dcg_shared_module_exports__["value"](N, l), w),
            Y = te.getRect();
          switch (
            N > 0
              ? (x && h <= N && N <= u &&
                F.push({ x: A - Y.right - 5, y: t.mapy(N) }),
                x && h <= -N && -N <= u &&
                F.push({ x: A - Y.right - 5, y: t.mapy(-N) }),
                z && d <= N && N <= p &&
                M.push({ x: t.mapx(N), y: P - Y.top + 3 }),
                z && d <= -N && -N <= p &&
                M.push({ x: t.mapx(-N), y: P - Y.top + 3 }))
              : x && !n && h <= N && N <= u
              ? F.push({ x: A - Y.right - 5, y: t.mapy(N) })
              : z && !a && d <= N && N <= p &&
                M.push({ x: t.mapx(N), y: P - Y.top + 3 }), L
          ) {
            case "top":
              _(N, u, Z);
              break;
            case "bottom":
              _(N, h, Z);
              break;
            case "left":
              k(N, d, Z);
              break;
            case "right":
              k(N, p, Z);
              break;
          }
          M.forEach((he) => {
            he = te.clampBoundsWithinRect(he, C),
              te.drawCenteredAt(e, he, "dcg-svg-axis-value"),
              zD(V, te.getRectWhenCenteredAt(he));
          }),
            F.forEach((he) => {
              he = te.clampBoundsWithinRect(he, C),
                te.drawCenteredAt(e, he, "dcg-svg-axis-value"),
                zD(R, te.getRectWhenCenteredAt(he));
            }),
            Z.forEach((he) => {
              he = te.clampBoundsWithinRect(he, C),
                te.drawCenteredAt(e, he, "dcg-svg-axis-value");
            });
        }
        if (s) {
          let N = Math.ceil(c / o.majorStepR),
            M = Math.floor(l / o.majorStepR),
            Z = Math.ceil((N + M) / 2) * o.majorStepR,
            te = c > 0 ? 15 : 30;
          for (let Y of ds(0, 359, te)) {
            let he;
            t.settings.degreeMode
              ? he = Y.toString() + "\xB0"
              : he = __dcg_shared_module_exports__["value"](
                Y * Math.PI / 180,
                2 * Math.PI,
              ).string;
            let se = e.measureText(he).width / 2,
              ae = Z / 1.05,
              q = ae * Math.cos(Y * Math.PI / 180),
              oe = ae * Math.sin(Y * Math.PI / 180);
            if (q < d || q > p || oe < h || oe > u) continue;
            let K = t.mapx(q), fe = t.mapy(oe);
            Y === 0 || Y === 180
              ? fe -= S
              : (Y === 90 || Y === 270) && (K += se + 3);
            let me = __dcg_shared_module_exports__["clamp"](
                K,
                3 + se,
                f - 3 - se,
              ),
              we = __dcg_shared_module_exports__["clamp"](
                fe,
                3 + S,
                y - 3 - S,
              );
            we = _a.computeBaselineFromCenter(we, w),
              No(e, "dcg-svg-polar-axis-value"),
              e.save(),
              To(e),
              e.fillStyle = E,
              _a.setCtxFontSize(e, w),
              e.strokeText(he, me, we),
              e.fillText(he, me, we),
              e.restore();
          }
        }
        return e.restore(), { x: V, y: R };
      }
      drawLabels(e, t, o) {
        let i = t.viewport.xmin,
          n = t.viewport.xmax,
          a = t.viewport.ymin,
          s = t.viewport.ymax,
          l = t.screen.width,
          c = t.screen.height,
          d = (n - i) / l,
          p = (s - a) / c,
          h = t.settings.getTextColor(),
          u = t.mapx(0),
          f = t.mapy(0),
          y = t.settings.labelSize,
          C = 15,
          E = t.settings.showXAxis && t.settings.xAxisLabel,
          v = t.settings.showYAxis && t.settings.yAxisLabel,
          w = o.x,
          S = o.y;
        if (E && w) {
          No(e, "dcg-svg-axis-label"), e.save(), To(e), e.fillStyle = h;
          let k;
          if (
            e.__xLabelOffset && t.settings.isViewportTransient &&
            qD(e.__xLabelOffset.xscale, d) &&
            qD(e.__xLabelOffset.yscale, p) &&
            (k = {
              x: e.__xLabelOffset.x + u,
              y: e.__xLabelOffset.y + f,
            }),
              this._setAxisLabelFont(e, E, y, t),
              !k
          ) {
            let _ = e.measureText(E).width, A = l - _ - C, P = y;
            w.bottom + P < c
              ? k = { x: A, y: w.bottom + P }
              : k = { x: A, y: w.top - P / 2 },
              e.__xLabelOffset = {
                x: k.x - u,
                y: k.y - f,
                xscale: d,
                yscale: p,
              };
          }
          e.strokeText(E, k.x, k.y), e.fillText(E, k.x, k.y), e.restore();
        } else e.__xLabelPosition = null;
        if (v && S) {
          No(e, "dcg-svg-axis-label"), e.save(), To(e), e.fillStyle = h;
          let k;
          if (
            e.__yLabelOffset && t.settings.isViewportTransient &&
            qD(e.__yLabelOffset.xscale, d) &&
            qD(e.__yLabelOffset.yscale, p) &&
            (k = {
              x: e.__yLabelOffset.x + u,
              y: e.__yLabelOffset.y + f,
            }),
              this._setAxisLabelFont(e, v, y, t),
              !k
          ) {
            let _ = e.measureText(v).width, A = y, P = _ + 5;
            if (!this._isShortMathyLabel(v)) {
              let U = _;
              _ = A, A = U, P = _ * .5;
            }
            let O = 0 + C + A;
            S.left - _ > 0
              ? k = { x: S.left - P, y: O }
              : k = { x: S.right + _, y: O },
              e.__yLabelOffset = {
                x: k.x - u,
                y: k.y - f,
                xscale: d,
                yscale: p,
              };
          }
          e.translate(k.x, k.y),
            this._isShortMathyLabel(v) || e.rotate(-Math.PI / 2),
            e.strokeText(v, 0, 0),
            e.fillText(v, 0, 0),
            e.restore();
        } else e.__yLabelPosition = null;
      }
      _isShortMathyLabel(e) {
        return e.trim().match(/^([a-zA-Z]?)\(?([a-zA-Z]?)\)?$/);
      }
      _setAxisLabelFont(e, t, o, i) {
        this.addTextShadow(e, i),
          this._isShortMathyLabel(t)
            ? e.font = "italic " + Math.round(o * 1.4) + "px Times"
            : e.font = Math.round(o * 1.2) + "px Arial";
      }
      drawCartesianStepNumbers(e, t, o, i, n = aV(t)) {
        e.save();
        let { showXAxis: a, showYAxis: s } = t.settings,
          l = a && t.settings.xAxisNumbers,
          c = s && t.settings.yAxisNumbers,
          { xmin: d, xmax: p, ymin: h, ymax: u } = t.viewport,
          f = t.screen.width,
          y = t.screen.height,
          C = { left: 3, top: 3, right: f - 3, bottom: y - 3 };
        t.settings.restrictGridToFirstQuadrant && (d = 0, h = 0);
        let E = t.settings.getTextColor({
            invertBlack: t.settings.threeDMode,
          }),
          v = t.settings.threeDMode ? E : t.settings.labelHangingColor,
          w = t.mapx(0),
          S = t.mapy(0),
          k = t.settings.labelSize;
        this.addTextShadow(e, t);
        let _ = { left: 0, right: f, top: S - 1, bottom: S + 1 },
          A = { left: w - 1, right: w + 1, top: 0, bottom: y };
        if (t.settings.threeDMode && !t.settings.showNumbers3D) {
          return { x: _, y: A };
        }
        let P = 5, O = false;
        if (a && s && (l || c)) {
          O = true, e.fillStyle = E;
          let V = new _a(__dcg_shared_module_exports__["value"](0, 1), k);
          V.drawCenteredAt(e, {
            x: w - V.getRect().right - P,
            y: S - V.getRect().top + P,
          }, "dcg-svg-axis-value");
        }
        let { majorStepX: U, majorStepY: z } = o, x = [], L = [];
        if (l) {
          let V = t.settings.xAxisScale === "logarithmic",
            R = V ? n.x.label : ds(d, p, U);
          for (let N of R) {
            let M = V ? void 0 : p - d,
              F = __dcg_shared_module_exports__["value"](N, M, V),
              Z = new _a(F, k);
            Z.getString() === "0" && O || x.push(Z);
          }
        }
        if (c) {
          let V = t.settings.yAxisScale === "logarithmic",
            R = V ? n.y.label : ds(h, u, z);
          for (let N of R) {
            let M = V ? void 0 : u - h,
              F = __dcg_shared_module_exports__["value"](N, M, V),
              Z = new _a(F, k);
            Z.getString() === "0" && O || L.push(Z);
          }
        }
        if (i) {
          e.save(), No(e, "dcg-svg-tickmark");
          let V = t.settings.axisLineOffset,
            R = t.settings.axisOpacity,
            N = sh(R);
          e.lineWidth = t.settings.axisLineWidth, e.strokeStyle = N;
          let M = Math.round(t.mapy(0)) - V,
            F = Math.round(t.mapx(0)) - V,
            Z = Math.round(2 * e.lineWidth) - V;
          e.beginPath(),
            x.forEach((te) => {
              let Y = Math.round(t.mapx(te.getValue())) - V;
              e.moveTo(Y, M - Z), e.lineTo(Y, M + Z);
            }),
            L.forEach((te) => {
              let Y = Math.round(t.mapy(te.getValue())) - V;
              e.moveTo(F - Z, Y), e.lineTo(F + Z, Y);
            }),
            e.stroke(),
            To(e),
            e.restore();
        }
        return x.forEach((V) => {
          let R = {
              x: t.mapx(V.getValue()) - .5 * V.getMinusWidth(),
              y: S - V.getRect().top + P,
            },
            N = V.clampBoundsWithinRect(R, C);
          e.fillStyle = R.y === N.y || t.settings.yAxisScale === "logarithmic"
            ? E
            : v;
          let M = "dcg-svg-axis-value";
          R.x !== N.x && (M += " dcg-svg-offcenter-axis-value"),
            V.drawCenteredAt(e, N, M),
            zD(_, V.getRectWhenCenteredAt(N)),
            To(e);
        }),
          L.forEach((V) => {
            let R = {
                x: w - P - V.getRect().right,
                y: t.mapy(V.getValue()),
              },
              N = V.clampBoundsWithinRect(R, C);
            e.fillStyle = R.x === N.x || t.settings.xAxisScale === "logarithmic"
              ? E
              : v;
            let M = "dcg-svg-axis-value";
            R.y !== N.y && (M += " dcg-svg-offcenter-axis-value"),
              V.drawCenteredAt(e, N, M),
              zD(A, V.getRectWhenCenteredAt(N)),
              To(e);
          }),
          e.restore(),
          { x: _, y: A };
      }
    };
  function ds(r, e, t) {
    let o = Math.ceil(r / t), i = Math.floor(e / t);
    if (!lne({ nmin: o, nmax: i })) return [];
    let n = [];
    for (let a = o; a <= i; a++) n.push(a * t);
    return n;
  }
  var lne = ({ nmin: r, nmax: e }) => isFinite(e - r) && e - r <= 1e4;
  function aV(r) {
    return { x: a6("x", r), y: a6("y", r) };
  }
  function a6(r, e) {
    let t = new Set(), o = new Set(), i = new Set(), n = 1;
    function a(se) {
      return w ? e.mapx(se) : e.mapy(se);
    }
    function s(se, ae) {
      return lh(a(ae) - a(se));
    }
    let l = (se, ae) => {
        let q = se * ae, oe = (se + 1) * ae;
        if (q < S && oe < S || q > k && oe > k) return;
        let K = se >= 5
            ? s(7 * ae, 8 * ae)
            : se >= 2
            ? s(3 * ae, 4 * ae)
            : s(ae, 2 * ae),
          fe = K / s(q, oe);
        if (K < 40) return;
        let me = {
            settings: {
              pixelsPerLabel: e.settings.pixelsPerLabel * fe,
              labelSize: e.settings.labelSize,
              xAxisNumber: e.settings.xAxisNumbers,
              yAxisNumber: e.settings.yAxisNumbers,
            },
            screen: { width: K, height: K },
            viewport: { xmin: q, ymin: q, xmax: oe, ymax: oe },
          },
          { minorStepX: we, majorStepX: Ce } = gl(me),
          _e = Math.max(q, S),
          We = Math.min(oe, k);
        for (let $ = Xg(_e / we); $ < Jg(We / we); $++) i.add($ * we);
        for (let $ = Xg(_e / Ce); $ < Jg(We / Ce); $++) {
          let W = $ * Ce;
          W <= q || W >= oe || (o.add(W), t.add(W));
        }
      },
      c = { label: [], major: [], minor: [], unitOpacity: 1 },
      { xAxisScale: d, yAxisScale: p, pixelsPerLabel: h } = e.settings,
      { xmin: u, xmax: f, ymin: y, ymax: C } = e.viewport,
      { width: E, height: v } = e.screen,
      w = r === "x",
      [S, k] = w ? [u, f] : [y, C],
      _ = w ? E : v,
      A = w ? d : p,
      P = e.settings.xAxisMinorSubdivisions !== 0;
    if (A !== "logarithmic") return c;
    let O = Xg(UD(S)),
      U = Jg(UD(k)),
      z = Jg(UD(k) - UD(S)),
      x = s(10 ** O, 10 ** (O + 1)),
      L = 15,
      V = 100,
      R = x > L,
      N = [];
    x > 6.25 * h && (N = [2, 3, 4, 6, 8]),
      x > 12 * h && (N = [2, 3, 4, 5, 6, 7, 8]),
      x > 14 * h && (N = [2, 3, 4, 5, 6, 7, 8, 9]);
    let M = N.length != 0;
    if (
      L <= x && x <= V && (n = Math.sqrt((x - L) / (V - L))), !isFinite(z)
    ) return c;
    let F = Xg(_ / h), Z = Math.max(1, 2 ** sne(n6(z / F)));
    for (let se = Jg(O / Z); se <= Xg(U / Z); se++) t.add(10 ** (se * Z));
    o = new Set([...t]);
    let te = Xg(_ / L), Y = Math.max(1, 2 ** Jg(n6(z / te)));
    for (let se = Jg(O / Y); se <= Xg(U / Y); se++) {
      (R ? o : i).add(10 ** (se * Y));
    }
    if (R) {
      for (let se = O; se < U; se++) {
        let ae = 10 ** se;
        for (let q of N) t.add(q * ae);
        if (M) {
          for (let q = 2; q <= 9; q++) o.add(q * ae);
          for (let q = 1; q <= 9; q++) l(q, ae);
        } else for (let q = 2; q <= 9; q++) i.add(q * ae);
      }
    }
    P && (i = new Set());
    let he = w
      ? e.reverse_mapx(a(S) + h / 4)
      : e.reverse_mapy(a(S) - 2 * e.settings.labelSize);
    return {
      label: [...t].filter((se) => he <= se && se <= k),
      major: [...o].filter((se) => S <= se && se <= k),
      minor: [...i].filter((se) => S <= se && se <= k),
      unitOpacity: n,
    };
  }
  function zD(r, e) {
    e.left < r.left && (r.left = e.left),
      e.right > r.right && (r.right = e.right),
      e.top < r.top && (r.top = e.top),
      e.bottom > r.bottom && (r.bottom = e.bottom);
  }
  function qD(r, e) {
    let t = lh(r), o = lh(e);
    return lh(t - o) <= (t < o ? o : t) * 1e-4;
  }
  var EMe = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Nv = class {
    constructor(e) {
      this.grapher = e,
        this.controller = this.grapher.controller,
        this.renderedTabTargetOrder = [],
        this.renderedTabTargets = {};
    }
    recomputeImages(e) {
      let { projection: t } = e;
      this.renderedTabTargets = {}, this.renderedTabTargetOrder = [];
      for (let o of this.grapher.generateMergeDrawOrder()) {
        let i = this.controller.getItemModel(o);
        if (i && i.type === "image" && i.shouldGraph && fc(i)) {
          let n = i.formula.dimensions;
          if (
            !n || !n.x || !n.y || !n.width || !n.height || !n.radianAngle
          ) continue;
          for (let a = 0; a < n.x.length; a++) {
            if (
              isFinite(n.x[a]) && isFinite(n.y[a]) &&
              isFinite(n.width[a]) && isFinite(n.height[a]) &&
              isFinite(n.radianAngle[a])
            ) {
              this.renderedTabTargetOrder.push(o),
                this.renderedTabTargets[o] = {
                  id: o,
                  description: this.getComputedDescription(i, a),
                  x: n.x[a],
                  y: n.y[a],
                  radianAngle: n.radianAngle[a],
                  width: n.width[a],
                  height: n.height[a],
                  widthScale: Math.abs(t.mapx(1) - t.mapx(0)),
                  heightScale: Math.abs(t.mapy(1) - t.mapy(0)),
                  screenX: t.mapx(n.x[a]),
                  screenY: t.mapy(n.y[a]),
                  centerId: i.formula.center_reference_id,
                  selected: Sa(i),
                };
              break;
            }
          }
        }
      }
      this.speakAriaAlert();
    }
    getOrderedTabTargets() {
      return this.getTabIndex() === -1
        ? []
        : this.renderedTabTargetOrder.map((e) => {
          var o;
          let t = this.renderedTabTargets[e];
          return {
            calcId: t.id,
            listIndex: void 0,
            polygonEdge: void 0,
            description: this.controller.isGeometry() ||
                (o = this.getAriaAlert({
                    id: t.id,
                    includeUsageInstructions: true,
                  })) == null
              ? void 0
              : o.completeMessage,
          };
        });
    }
    getStyle(e) {
      let t = this.renderedTabTargets[e];
      if (!t) return;
      let {
          screenX: o,
          screenY: i,
          radianAngle: n,
          width: a,
          height: s,
          widthScale: l,
          heightScale: c,
        } = t,
        d = c / l,
        p = a * l,
        h = s * c / d,
        u = o - p / 2,
        f = i - h / 2,
        y = `translate(${u}px, ${f}px)`,
        C = n ? ` rotate(${n}rad)` : "",
        E = d === 1 ? "" : ` scale(1,${d})`;
      return {
        position: "absolute",
        top: 0,
        left: 0,
        transform: y + E + C,
        width: p + "px",
        height: h + "px",
      };
    }
    getTabIndex() {
      if (this.controller.getActiveTool() !== "selection") return -1;
      let e = this.grapher.settings;
      return e.config.graphpaper && e.config.enableTabindex ? 0 : -1;
    }
    getAriaHidden() {
      return !this.grapher.settings.config.graphpaper;
    }
    getComputedDescription(e, t) {
      let o = e.formula && e.formula.computed_description &&
        e.formula.computed_description[t];
      return o && o !== ""
        ? ei(o)
        : this.grapher.getAudioTrace().getExpressionAriaLabel(e.id);
    }
    getAriaLabel(e) {
      let t = this.getAriaAlert({ id: e, includeUsageInstructions: false });
      return t && t.completeMessage;
    }
    speakAriaAlert() {
      if (this.controller.isGeometry()) return;
      let e = this.getFocusedImage();
      if (!e) {
        this.lastAriaAlert = void 0;
        return;
      }
      let t = e.id,
        o = this.getAriaAlert({
          id: t,
          lastAriaAlert: this.lastAriaAlert,
          includeUsageInstructions: true,
        });
      this.lastAriaAlert = o, o && o.completeMessage && xe(o.completeMessage);
    }
    getAriaAlert(e) {
      let { id: t, lastAriaAlert: o, includeUsageInstructions: i } = e;
      if (!t) return;
      let n = this.controller.getItemModel(t);
      if (!n || n.type !== "image") return;
      let a = this.renderedTabTargets[t];
      if (!a) return;
      o && o.id !== t && (o = void 0);
      let s = o == null ? void 0 : o.label,
        l = a.description,
        c = s !== l,
        d = !!(o != null && o.selected),
        p = a.selected,
        h = d !== p,
        u = o && o.coordX,
        f = o && o.coordY,
        y = a.x,
        C = a.y,
        E = y !== u || C !== f,
        v = this.grapher.getProjection(),
        w = ll(this.controller, y, C),
        S = l,
        k = i
          ? this.controller.s(
            "graphing-calculator-narration-movable-point-suffix-usage-instructions",
          )
          : "",
        _ = this.isImageFullyVisible(n, v) ? "" : this.controller.s(
          "graphing-calculator-narration-draggable-image-off-screen-prompt",
        ),
        A;
      return o
        ? c || !E && h ? A = S + _ : E ? A = w + _ : A = ""
        : A = this.controller.s(
          "graphing-calculator-narration-item-at-coordinates",
          { itemDescription: S, coordinates: w },
        ) + k + _,
        { id: t, coordX: y, coordY: C, label: l, completeMessage: A };
    }
    getFocusedImage() {
      let e = this.grapher.poiController.keyboardAttentionManager
        .getKeyboardAttention();
      return e ? this.renderedTabTargets[e.calcId] : void 0;
    }
    speakImageAttribute(e, t) {
      if (
        !(!e || !this.grapher.getAudioTrace() ||
          !this.grapher.getProjection())
      ) {
        switch (t) {
          case "X":
            xe(Bl(this.controller, e.x));
            break;
          case "Y":
            xe(Ul(this.controller, e.y));
            break;
          case "L":
            xe(e.description);
            break;
        }
      }
    }
    hasNonlinearMoveStrategy(e) {
      if (!e) return false;
      let t = this.controller.getItemModel(e);
      if (!t || t.type !== "expression" || !t.formula) return false;
      let o = t.formula.move_strategy;
      return !o || !o[0] ? false : o[0].type === "updateSliderNonlinear";
    }
    isImageFullyVisible(e, t) {
      let o = e.formula.dimensions;
      if (!o || !o.x || !o.y) return false;
      for (let i = 0; i < o.x.length; i++) {
        if (!t.coordsAreOnscreen(t.mapx(o.x[i]), t.mapy(o.y[i]))) {
          return false;
        }
      }
      return true;
    }
  };
  var s6 = { translate: true, reflect: true, dilate: true, rotate: true },
    MMe = {
      selection: true,
      point: true,
      line: true,
      segment: true,
      ray: true,
      vector: true,
      circle: true,
      arc: true,
      parallel: true,
      perpendicular: true,
      midpoint: true,
      polygon: true,
      compass: true,
      angle: true,
      directedangle: true,
      anglebisector: true,
      "box-selection": true,
      "expression-edit": true,
      ...s6,
    },
    fy = Object.keys(s6);
  var Et = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  function sV(r, e) {
    if (r.indexOf("\\idref_{") === 0) {
      let t = r.indexOf("}"), o = r.slice(8, t);
      return e(o) + r.slice(t + 1);
    } else return r;
  }
  function lV(r, e) {
    var i;
    let t = {};
    for (let n in r) {
      let a = r[n];
      if (a.type === "polygon-segment" && !a.showAsSepratePreviewObject) {
        let s = l6(a, e, {});
        if (!s) {
          throw new Error(
            "Expected polygon-segment object to be converted",
          );
        }
        t[n] = { type: "inline", rhs: s.rhs };
      }
    }
    let o = { ...t };
    for (let n in r) {
      if (t[n]) continue;
      let a = r[n], s = l6(a, e, t);
      s &&
        (o[n] = {
          type: "assignment",
          latex: `${(i = s.lhs) != null ? i : a.id}=${s.rhs}`,
          color: a.color,
          showAngleLabel: s.showAngleLabel,
          sliderInfo: s.sliderInfo,
        });
    }
    return o;
  }
  function l6(r, e, t) {
    var n;
    let o = (a) => {
        let s = a;
        return t[a]
          ? s = t[a].rhs
          : e.isBeingCommitted && (s = sV(a, e.getVariableNameForId)),
          s;
      },
      i = (a) => a.map(o);
    switch (r.type) {
      case "point-reference":
        return { rhs: r.parents[0] };
      case "point":
        let { x: a, y: s } = r;
        return {
          rhs: "\\left(" + __dcg_shared_module_exports__["be"](a) + "," +
            __dcg_shared_module_exports__["be"](s) + "\\right)",
        };
      case "glider":
        return {
          rhs: "\\operatorname{glider}\\left(" + i(r.parents)[0] + "," +
            __dcg_shared_module_exports__["be"](r.t) + "\\right)",
        };
      case "polygon":
        return {
          rhs: "\\operatorname{" + r.type + "}\\left(" +
            i(r.parents).join(",") + "\\right)",
        };
      case "circle":
      case "arc":
      case "compass":
      case "segment":
      case "line":
      case "ray":
      case "parallel":
      case "perpendicular":
      case "anglebisector":
      case "intersection":
      case "midpoint":
        return {
          rhs: "\\operatorname{" + r.type + "}\\left(" +
            i(r.parents).join(",") + "\\right)",
        };
      case "vector-copy": {
        let [f, y] = i(r.parents);
        return {
          rhs:
            `\\operatorname{translate}\\left(${f},${f}.\\operatorname{start},${y}\\right)`,
        };
      }
      case "vector":
        return {
          rhs: "\\operatorname{" + r.type + "}\\left(" +
            i(r.parents).join(",") + "\\right)",
        };
      case "vector-endpoint":
        return {
          rhs: `${i(r.parents)[0]}.\\operatorname{${r.location}}`,
        };
      case "translate":
      case "reflect":
      case "dilate":
      case "rotate": {
        let f = r.type === "dilate" || r.type === "rotate"
          ? [...i([r.parents[0]]), r.parents[1]]
          : i(r.parents);
        return {
          rhs: `\\operatorname{${r.type}}\\left(x,${f.join(",")}\\right)`,
          lhs: `${r.id}\\left(x\\right)`,
        };
      }
      case "angle":
      case "directedangle":
        return {
          showAngleLabel: (n = r.showAngleLabel) != null ? n : true,
          rhs: "\\operatorname{" + r.type + "}\\left(" +
            i(r.parents).join(",") + "\\right)",
        };
      case "polygon-angle":
      case "polygon-directedangle":
        let l = r.type === "polygon-angle" ? "angles" : "directedangles",
          c = i(r.parents)[0],
          d = r.angleIndex;
        return {
          showAngleLabel: e.isBeingCommitted,
          rhs: `\\operatorname{${l}}\\left(${c}\\right)\\left[${d}\\right]`,
        };
      case "polygon-segment":
        return {
          rhs: i(r.parents)[0] +
            (r.listAccess !== void 0
              ? "\\left[" + r.listAccess + "\\right]"
              : "") +
            ".\\operatorname{segments}\\left[" + (r.edgeNumber + 1) +
            "\\right]",
        };
      case "slider":
        return {
          lhs: r.lhsLatex,
          rhs: r.rhsLatex,
          sliderInfo: r.sliderInfo,
        };
      case "expression-edit-preview-latex":
        return r.rhsLatex === "" ? void 0 : {
          showAngleLabel: r.rhsLatex.trim().startsWith(
            "\\operatorname{angle}\\left(",
          ),
          rhs: r.rhsLatex,
        };
      default:
        return r;
    }
  }
  function cV(r, e) {
    __dcg_shared_module_exports__["Ob"](r)
      ? r.value.forEach((t, o) => {
        let i = __dcg_shared_module_exports__["elementType"](r.valueType);
        if (__dcg_shared_module_exports__["isMapOrListOfMap"](i)) {
          throw new Error("Programming error: unexpected lambda type");
        }
        e({ valueType: i, value: t }, o + 1);
      })
      : e(r, void 0);
  }
  function Bv(r) {
    let e = r.formula.geometry, t = e == null ? void 0 : e.identifier;
    return t
      ? __dcg_shared_module_exports__["identifierToLatex"](t)
      : "\\idref_{" + r.id + "}";
  }
  function Qg(r, e) {
    let { controller: t, expandLists: o = true } = r;
    t.getAllItemModels().concat(t.getAllToolPreviewItems()).forEach(
      (n) => {
        var d;
        if (!il(n)) return;
        let a = n.formula.typed_constant_value,
          s = n.formula.geometry,
          l = Bv(n),
          c = !t.getItemModel(n.id);
        o && t.canExpandListForItem(n.id)
          ? cV(a, (p, h) => {
            var y;
            let u = l + (h === void 0 ? "" : "\\left[" + h + "\\right]"),
              f = {
                calcId: n.id,
                data: s,
                hidden: !n.shouldGraph,
                isGraphableAndInteractive:
                  !!((y = n.formula) != null && y.is_graphable) &&
                  !r.controller.shouldIgnoreGraphInteractions(n),
                assignment: l,
                listIndex: h !== void 0 ? h - 1 : void 0,
                typedRuntimeValue: p,
                referenceLatex: u,
              };
            e(f, c);
          })
          : e({
            calcId: n.id,
            data: s,
            hidden: !n.shouldGraph,
            isGraphableAndInteractive:
              !!((d = n.formula) != null && d.is_graphable) &&
              !r.controller.shouldIgnoreGraphInteractions(n),
            assignment: l,
            listIndex: void 0,
            typedRuntimeValue: a,
            referenceLatex: l,
          }, c);
      },
    );
  }
  function cne(r, e) {
    switch (r.valueType) {
      case __dcg_shared_module_exports__["ListOfPoint"]:
        return {
          valueType: __dcg_shared_module_exports__["Point"],
          value: r.value[e],
        };
      case __dcg_shared_module_exports__["ListOfCircle"]:
        return {
          valueType: __dcg_shared_module_exports__["Circle"],
          value: r.value[e],
        };
      case __dcg_shared_module_exports__["ListOfSegment"]:
        return {
          valueType: __dcg_shared_module_exports__["Segment"],
          value: r.value[e],
        };
      case __dcg_shared_module_exports__["ListOfRay"]:
        return {
          valueType: __dcg_shared_module_exports__["Ray"],
          value: r.value[e],
        };
      case __dcg_shared_module_exports__["ListOfVector"]:
        return {
          valueType: __dcg_shared_module_exports__["Vector"],
          value: r.value[e],
        };
      case __dcg_shared_module_exports__["ListOfLine"]:
        return {
          valueType: __dcg_shared_module_exports__["Line"],
          value: r.value[e],
        };
      case __dcg_shared_module_exports__["ListOfPolygon"]:
        return {
          valueType: __dcg_shared_module_exports__["Polygon"],
          value: r.value[e],
        };
      case __dcg_shared_module_exports__["ListOfArc"]:
        return {
          valueType: __dcg_shared_module_exports__["Arc"],
          value: r.value[e],
        };
      case __dcg_shared_module_exports__["ListOfAngleMarker"]:
        return {
          valueType: __dcg_shared_module_exports__["AngleMarker"],
          value: r.value[e],
        };
      case __dcg_shared_module_exports__["ListOfDirectedAngleMarker"]:
        return {
          valueType: __dcg_shared_module_exports__["DirectedAngleMarker"],
          value: r.value[e],
        };
      case __dcg_shared_module_exports__["EmptyList"]:
      case __dcg_shared_module_exports__["ListOfNumber"]:
      case __dcg_shared_module_exports__["ListOfComplex"]:
      case __dcg_shared_module_exports__["ListOfTransformation"]:
      case __dcg_shared_module_exports__["ListOfBool"]:
      case __dcg_shared_module_exports__["ListOfRestriction"]:
      case __dcg_shared_module_exports__["ListOfColor"]:
      case __dcg_shared_module_exports__["ListOfTone"]:
      case __dcg_shared_module_exports__["ListOfPoint3D"]:
      case __dcg_shared_module_exports__["ListOfSegment3D"]:
      case __dcg_shared_module_exports__["ListOfTriangle3D"]:
      case __dcg_shared_module_exports__["ListOfSphere3D"]:
      case __dcg_shared_module_exports__["ListOfVector3D"]:
        throw new Error(
          "Programming Error: unexpected type " +
            __dcg_shared_module_exports__["prettyPrint"](r.valueType),
        );
      default:
        throw r.valueType,
          new Error(
            "Programming Error: expected a list type but found " +
              __dcg_shared_module_exports__["prettyPrint"](r.valueType),
          );
    }
  }
  function dV(r, e) {
    return {
      ...r,
      referenceLatex: r.assignment + "\\left[" + e + "\\right]",
      typedRuntimeValue: cne(r.typedRuntimeValue, e),
      listIndex: e,
    };
  }
  function KD(r) {
    switch (r) {
      case __dcg_shared_module_exports__["Point"]:
        return "Point";
      case __dcg_shared_module_exports__["Circle"]:
        return "Circle";
      case __dcg_shared_module_exports__["Arc"]:
        return "Arc";
      case __dcg_shared_module_exports__["Polygon"]:
        return "Polygon";
      case __dcg_shared_module_exports__["Line"]:
        return "Line";
      case __dcg_shared_module_exports__["Segment"]:
        return "Segment";
      case __dcg_shared_module_exports__["Ray"]:
        return "Ray";
      case __dcg_shared_module_exports__["Vector"]:
        return "Vector";
      case __dcg_shared_module_exports__["AngleMarker"]:
        return "Angle";
      case __dcg_shared_module_exports__["DirectedAngleMarker"]:
        return "Angle";
    }
  }
  function c6(r) {
    if (!r) return;
    let e = r.typedRuntimeValue;
    return KD(e.valueType);
  }
  var _c = class {
    constructor(e) {
      this.model = e;
      this.s = e.s;
    }
    createOutput() {
      return this.model.createCustomToolOutput(this.getSpec());
    }
    clearTentativeOutputs() {
      let e = this.getSpec(),
        t = {},
        o = this.model.getNonObjectsState().ui.currentTool.idMap;
      for (let i in o) {
        let n = o[i];
        !this.model.isObjectALockedToolInput(n) &&
          this.model.isObjectUncommitted(n) && (t[i] = n);
      }
      this.model.deleteObjectsAndRememberReusableId(t),
        this.model.tentativelyMatchToolInput(e, ""),
        this.createOutput();
    }
    didLockInput(e) {
      var n;
      let { currentTool: t } = this.model.getNonObjectsState().ui,
        o = t.inputIndex,
        i = e.inputs[o];
      i && (n = i.numberInputInfo) != null && n.defaultLatex &&
        !t.idMap[i.id] &&
        this.onNumberInput(i.numberInputInfo.defaultLatex);
    }
    shouldReferenceSpecificItemInList(e, t) {
      return !t;
    }
    getExpandedReferenceForDef(e, t) {
      return this.shouldReferenceSpecificItemInList(e, t)
        ? e.referenceLatex
        : e.assignment;
    }
    getListIndexForHover(e, t) {
      if (this.shouldReferenceSpecificItemInList(e, t)) {
        return e.listIndex;
      }
    }
    _getOrCreatePoint(e, t, o) {
      let i = this.model.getOrCreatePointNearMouse(e, o);
      if (i.type === "def") {
        return {
          createdNew: false,
          def: i.def,
          reference: this.getExpandedReferenceForDef(i.def, t),
          previewOnly: false,
        };
      }
      let n = this.createPointDefinition(i.spec, t),
        a = i.spec.type === "point-reference"
          ? i.spec.targetSpec.parentDefs
          : i.spec.parentDefs,
        s = 0;
      for (let c = 0; c < a.length; c++) {
        let d = a[c];
        if (d.polygonEdgeInfo) {
          let p = this.model.createToolInputDependency(
            {
              type: "polygon-segment",
              parents: [d.polygonEdgeInfo.polygonDef.referenceLatex],
              edgeNumber: d.polygonEdgeInfo.edgeNumber || 0,
              polygonColor: this.getPolygonEdgeColor(d),
            },
            this.getSpec(),
            s,
          );
          n.parents[c] = p,
            s += 1,
            this.model.setObjectHovered({
              tokenId: p,
              listIndex: void 0,
            });
        } else {this.model.setObjectHovered({
            calcId: d.calcId,
            listIndex: this.getListIndexForHover(d, t),
          });}
      }
      return {
        createdNew: true,
        def: void 0,
        reference: this.model._createInputObject(n),
        previewOnly: n.type === "point" && n.previewOnly,
      };
    }
    _isReadyToCommit() {
      return this.model.getNonObjectsState().ui.currentTool.inputIndex >=
        this.getSpec().inputs.length;
    }
    _getFirstMissingInput() {
      let { inputIndex: e } = this.model.getNonObjectsState().ui.currentTool;
      return this.getSpec().inputs[e];
    }
    canNextInputBePoint() {
      let e = this._getFirstMissingInput();
      return e && e.type === "point" ? true : !!(e && e.type === "union" &&
        e.valueTypes.indexOf(__dcg_shared_module_exports__["Point"]) !==
          -1);
    }
    getNonPointInputType() {
      let e = this._getFirstMissingInput();
      if (!(!e || e.type === "point")) {
        return e.type === "union" ? e : e.type;
      }
    }
    isValidNextInputType(e) {
      if (
        this.canNextInputBePoint() &&
        __dcg_shared_module_exports__["isSubTypeOrCoercible"](
          e,
          __dcg_shared_module_exports__["Point"],
        )
      ) return true;
      let t = this._getFirstMissingInput();
      if (!t) return false;
      let o = [];
      if (t.type === "union") o = t.valueTypes;
      else {
        let i = t.type;
        switch (i) {
          case "point":
            o = [__dcg_shared_module_exports__["Point"]];
            break;
          case "straight":
            o = [...__dcg_shared_module_exports__["straightTypes"].types];
            break;
          case "angle":
            o = [
              __dcg_shared_module_exports__["AngleMarker"],
              __dcg_shared_module_exports__["DirectedAngleMarker"],
            ];
            break;
          case "arc":
            o = [__dcg_shared_module_exports__["Arc"]];
            break;
          case "circle":
            o = [__dcg_shared_module_exports__["Circle"]];
            break;
          case "polygon":
            o = [__dcg_shared_module_exports__["Polygon"]];
            break;
          case "segment":
            o = [__dcg_shared_module_exports__["Segment"]];
            break;
          case "vector":
            o = [__dcg_shared_module_exports__["Vector"]];
            break;
          default:
            return i;
        }
      }
      return t.numberInputInfo &&
        o.push(__dcg_shared_module_exports__["Number"]),
        o.some((i) =>
          __dcg_shared_module_exports__["isSubTypeOrCoercible"](e, i)
        );
    }
    getAllValidNextInputTypes() {
      return __dcg_shared_module_exports__["allValueTypes"].filter((e) =>
        this.isValidNextInputType(e)
      );
    }
    getHint() {
      let e = this._getFirstMissingInput();
      return e
        ? e.hint !== void 0
          ? this.s(e.hint)
          : this.s("graphing-calculator-text-geometry-select-hint", {
            type: e.type,
          })
        : "";
    }
    getSpecIdToLockIn(e, t) {
      let o = e.inputs[t];
      if (o) return o.id;
    }
    tryCommitResults() {
      if (
        this.model.attemptLockToolInputIn(this.getSpec()),
          this._isReadyToCommit()
      ) {
        let e = this.model.getUncommittedObjects();
        for (let o in e) {
          e[o].type === "expression-edit-preview-latex" && delete e[o];
        }
        let t = {
          ...this.model.getNonObjectsState().ui.currentTool.idMap,
        };
        return this.model.commitObjects(),
          this.model.deselectAllObjects(),
          this.model.cancelToolplay(),
          { committed: e, toolIdToLatex: t };
      }
      return { committed: void 0 };
    }
    tentativelyAddInput({ target: e, pointInfo: t }, o) {
      var n, a;
      let i;
      if (e) {
        if (e.polygonEdgeInfo) {
          let s = this.model.createToolInputDependency(
            {
              type: "polygon-segment",
              parents: [
                (n = e.polygonEdgeInfo) == null
                  ? void 0
                  : n.polygonDef.referenceLatex,
              ],
              edgeNumber:
                ((a = e.polygonEdgeInfo) == null ? void 0 : a.edgeNumber) || 0,
              polygonColor: this.getPolygonEdgeColor(e),
            },
            this.getSpec(),
            0,
          );
          this.model.setObjectHovered({ tokenId: s, listIndex: void 0 }), i = s;
        } else {i = this.getExpandedReferenceForDef(e, o),
            this.model.setObjectHovered({
              calcId: e.calcId,
              listIndex: this.getListIndexForHover(e, o),
            });}
      } else {t &&
          (i = t.reference,
            t != null && t.def && !t.createdNew && !t.previewOnly &&
            this.model.setObjectHovered({
              calcId: t.def.calcId,
              listIndex: this.getListIndexForHover(t.def, o),
            }));}
      i && this.model.tentativelyMatchToolInput(this.getSpec(), i);
    }
    onFocus(e) {
      this.clearTentativeOutputs(),
        e && this.tentativelyAddInput({ target: e }, false),
        this.createOutput();
    }
    onMove(e) {
      this.clearTentativeOutputs();
      let t = this.canNextInputBePoint(),
        o = this.getNonPointInputType(),
        i = false;
      if (o) {
        let n = this.model.getObjectDefUnderMouse(
          e.pt,
          e.tolerance,
          this.model.getCurrentTool(),
        );
        n && this.model.objectIsInstanceOf(n, o) &&
          (this.tentativelyAddInput({ target: n }, e.shift), i = true);
      }
      if (!i && t) {
        let n = this._getOrCreatePoint(e.pt, e.shift, e.tolerance);
        i = !n.previewOnly,
          this.isDegenerateInput(n.reference)
            ? n.def &&
              this.model.setObjectHovered({
                calcId: n.def.calcId,
                listIndex: this.getListIndexForHover(n.def, e.shift),
              })
            : this.tentativelyAddInput({ pointInfo: n }, e.shift);
      }
      return this.createOutput(), i;
    }
    isDegenerateInput(e) {
      return !!this.model.getNonObjectsState().ui.currentTool
        .lockedIds[e];
    }
    getNumberInputLatex() {
      let e = this.getSpec(),
        { inputIndex: t, idMap: o } =
          this.model.getNonObjectsState().ui.currentTool,
        i = e.inputs[t];
      return i != null && i.numberInputInfo && o[`${i.id}-number`] || "";
    }
    onNumberInput(e) {
      this.clearTentativeOutputs();
      let t = this.getSpec();
      this.model.storeNumberInputLatex(t, e), this.createOutput();
    }
    createPointDefinition(e, t) {
      let o = e.parentDefs, i;
      switch (e.type) {
        case "point-reference": {
          i = {
            type: "point-reference",
            parents: [this.getExpandedReferenceForDef(o[0], t)],
          };
          break;
        }
        default: {
          let n = o.map((a) => this.getExpandedReferenceForDef(a, t));
          i = { ...e, parents: n };
        }
      }
      return i;
    }
    shouldUseJitEdges() {
      return true;
    }
    shouldHighlightRelevantObjects() {
      return true;
    }
    getPolygonEdgeColor(e) {
      var n;
      let { ui: t } = this.model.getNonObjectsState(),
        o = e.polygonEdgeInfo
          ? this.model.controller.getItemModel(
            e.polygonEdgeInfo.polygonDef.calcId,
          )
          : void 0;
      if ((o == null ? void 0 : o.type) !== "expression") {
        return t.colors.line;
      }
      let i = bE(o) && yE(o);
      return e.listIndex !== void 0 && Array.isArray(i)
        ? (n = i[e.listIndex]) != null ? n : t.colors.line
        : typeof i == "string"
        ? i
        : o.color;
    }
  };
  function WD(r, e) {
    if (typeof e == "object") {
      return e.valueTypes.some((t) =>
        __dcg_shared_module_exports__["isSubTypeOrCoercible"](r, t)
      );
    }
    switch (e) {
      case "point":
        return r === __dcg_shared_module_exports__["Point"];
      case "straight":
        return r === __dcg_shared_module_exports__["Line"] ||
          r === __dcg_shared_module_exports__["Ray"] ||
          r === __dcg_shared_module_exports__["Segment"] ||
          r === __dcg_shared_module_exports__["Vector"];
      case "angle":
        return r === __dcg_shared_module_exports__["AngleMarker"] ||
          r === __dcg_shared_module_exports__["DirectedAngleMarker"];
      case "arc":
        return r === __dcg_shared_module_exports__["Arc"];
      case "circle":
        return r === __dcg_shared_module_exports__["Circle"];
      case "polygon":
        return r === __dcg_shared_module_exports__["Polygon"];
      case "segment":
        return r === __dcg_shared_module_exports__["Segment"];
      case "vector":
        return r === __dcg_shared_module_exports__["Vector"];
      default:
        return e;
    }
  }
  var jD = class r {
      constructor(e, t) {
        this.value = e;
        this.valueType = t;
      }
      static point(e) {
        return new r(e, __dcg_shared_module_exports__["Point"]);
      }
      static polygonSegment(e) {
        return new r(e, __dcg_shared_module_exports__["Segment"]);
      }
    },
    Vr = class extends _c {
      constructor(t, o) {
        super(t);
        this.definition = o;
        this.s = t.s,
          this.displayName = o.displayName,
          this.toolType = o.toolType,
          this.toolName = o.name,
          this.icon = o.icon,
          this.workflows = o.workflows.map((i) => {
            let n = i.input.broadcast
              ? __dcg_shared_module_exports__["broadcastable"](i.input.types, {
                geometry: true,
              })
              : __dcg_shared_module_exports__["signature"](i.input.types, {
                geometry: true,
              });
            return { ...i, signature: n };
          });
      }
      getWorkflows() {
        return this.workflows;
      }
      getMatchingWorkflow(t) {
        let o = t.map((s) => s.valueType),
          i = this.workflows.filter((s) => s.signature.matches(o));
        if (i.length === 0) return;
        let n = i.find((s) => o.length >= s.signature.minArity),
          a = n != null && n.canCommit ? n.canCommit(t) : !!n;
        return {
          firstMatch: n != null ? n : i[0],
          canCommit: a,
          allMatches: i,
          inputs: t,
          argTypes: o,
        };
      }
      getInputAtIndex(t) {
        let { idMap: o } = this.model.getNonObjectsState().ui.currentTool,
          i = o[`${t}`];
        if (i) return this.getInputById(i);
      }
      getInputById(t) {
        let i = this.model.getUncommittedObjects()[t];
        if (i && dne(i)) return jD.point(i);
        if (i && i.type === "polygon-segment") {
          return jD.polygonSegment(i);
        }
        let n = this.model.findDefsForInputId(t)[0];
        return n == null ? void 0 : n.typedRuntimeValue;
      }
      getMatchingWorkflowForCurrentInputs(t = 1 / 0) {
        let { inputIndex: o } = this.model.getNonObjectsState().ui.currentTool,
          i = [];
        for (let n = 0; n <= Math.min(o, t); n++) {
          let a = this.getInputAtIndex(n);
          if (a === void 0) break;
          i.push(a);
        }
        return this.getMatchingWorkflow(i);
      }
      canNextInputBePoint() {
        let { inputIndex: t } = this.model.getNonObjectsState().ui.currentTool,
          o = this.getMatchingWorkflowForCurrentInputs(t - 1);
        return !!(o != null && o.allMatches.some((i) => {
          let n = i.signature.argTypeAtIndex(t);
          return n === void 0
            ? false
            : __dcg_shared_module_exports__["typeSatisfiesArgType"](
              __dcg_shared_module_exports__["Point"],
              n,
            );
        }));
      }
      isDegenerateInput(t) {
        if (this.definition.isDegenerateInput) {
          let o = this.getMatchingWorkflowForCurrentInputs(),
            i = this.getInputById(t);
          return i
            ? this.definition.isDegenerateInput({
              previousInputs: (o == null ? void 0 : o.inputs) || [],
              proposedInput: i,
            })
            : false;
        }
        return super.isDegenerateInput(t);
      }
      getSpec({ isCommitting: t } = { isCommitting: false }) {
        var l, c;
        let o = this.getMatchingWorkflowForCurrentInputs();
        if (!o) return { inputs: [], outputs: [] };
        let { inputIndex: i } = this.model.getNonObjectsState().ui.currentTool,
          n = o.firstMatch,
          a = [],
          s = (l = n.signature.maxArity) != null ? l : i + 1;
        for (let d = 0; d < s; d++) {
          let p = n.signature.argTypeAtIndex(d);
          if (!p) throw new Error(`Expected arg type for arg ${d}`);
          if (d6(p)) {
            let h = [];
            if (d === i) {
              let u = this.getMatchingWorkflowForCurrentInputs(d - 1);
              for (
                let f of (c = u == null ? void 0 : u.allMatches) != null
                  ? c
                  : []
              ) {
                let y = f.signature.argTypeAtIndex(d);
                y && !d6(y) &&
                  h.push(...typeof y == "number" ? [y] : y.getTypes());
              }
            }
            h.length > 0
              ? a.push({
                id: `${d}`,
                type: "union",
                hint: $D(n, d),
                valueTypes: [...h, __dcg_shared_module_exports__["Point"]],
              })
              : a.push({ id: `${d}`, type: "point", hint: $D(n, d) });
          } else {a.push({
              id: `${d}`,
              type: "union",
              hint: $D(n, d),
              valueTypes: typeof p == "number" ? [p] : p.getTypes().slice(),
            });}
        }
        return { inputs: a, outputs: pV(n, o.inputs, t) };
      }
      tryCommitResults() {
        var t;
        if (
          this.model.attemptLockToolInputIn(this.getSpec()),
            (t = this.getMatchingWorkflowForCurrentInputs()) != null &&
            t.canCommit
        ) {
          this.clearTentativeOutputs(),
            this.model.createCustomToolOutput(
              this.getSpec({ isCommitting: true }),
            );
          let o = this.model.getUncommittedObjects();
          for (let n in o) {
            o[n].type === "expression-edit-preview-latex" && delete o[n];
          }
          let i = {
            ...this.model.getNonObjectsState().ui.currentTool.idMap,
          };
          return this.model.commitObjects(),
            this.model.deselectAllObjects(),
            this.model.cancelToolplay(),
            { committed: o, toolIdToLatex: i };
        }
        return { committed: void 0 };
      }
      getExpressionEditHint(t) {
        var i;
        let o = (i = this.getMatchingWorkflowForCurrentInputs()) == null
          ? void 0
          : i.firstMatch;
        return o ? this.s($D(o, t)) : "";
      }
      shouldReferenceSpecificItemInList(t, o) {
        var i, n;
        if (o) {
          let { inputIndex: a } =
            this.model.getNonObjectsState().ui.currentTool;
          return !((n = (i = this.getMatchingWorkflowForCurrentInputs()) == null
              ? void 0
              : i.allMatches) != null
            ? n
            : []).some((c) => {
              let d = c.signature.argTypeAtIndex(a);
              return d === void 0
                ? false
                : typeof d == "number"
                ? __dcg_shared_module_exports__["isList"](d)
                : d.getTypes().some(__dcg_shared_module_exports__["isList"]);
            });
        } else return true;
      }
    };
  function pV(r, e, t) {
    let o;
    return Array.isArray(r.output)
      ? o = r.output
      : o = r.output({ inputs: e, isCommitting: t }),
      o.map((i, n) => ({
        ...i,
        id: `result-${n}`,
        hidden: false,
        parents: i.parents.map((a) => ({
          type: "reference-input",
          id: `${a}`,
        })),
      }));
  }
  function d6(r) {
    return typeof r == "number"
      ? r === __dcg_shared_module_exports__["Point"]
      : r.getTypes().every((e) =>
        __dcg_shared_module_exports__["isTypeOrListOfType"](
          e,
          __dcg_shared_module_exports__["Point"],
        )
      );
  }
  function $D(r, e) {
    return Array.isArray(r.input.hints) ? r.input.hints[e] : r.input.hints(e);
  }
  function dne(r) {
    switch (r.type) {
      case "point":
      case "intersection":
      case "glider":
      case "point-reference":
      case "midpoint":
      case "vector-endpoint":
        return true;
      default:
        return r.type, false;
    }
  }
  var Kp = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    by = class extends Kp.Class {
      template() {
        return Kp.createElement(
          "div",
          { class: Kp.const("dcg-dot-dot-dropdown") },
          Kp.createElement("i", {
            class: Kp.const("dcg-icon-ellipsis-vertical"),
            "aria-hidden": Kp.const("true"),
          }),
        );
      }
    };
  var yy = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var p6 =
      'a, input, button:not([disabled]), textarea, select [role="textbox"], [tabIndex="0"], [role="option"], [role="button"], [role="link"], summary',
    YD = class {
      constructor(
        {
          closeMenu: e,
          focusIcon: t,
          getIconSelector: o,
          getContainerEl: i,
          isIconFocused: n,
        },
      ) {
        this.globalKeyDownListener = (e) => {
          let t = ke(e);
          if (t === kn) {
            e.preventDefault(),
              e.stopPropagation(),
              this.focusIcon(),
              this.closeMenu();
            return;
          }
          if (t === "Tab" && !e.altKey && !e.ctrlKey && !e.metaKey) {
            if (this.isIconFocused()) {
              e.shiftKey ? this.focusLastOption() : this.focusFirstOption(),
                e.preventDefault(),
                e.stopPropagation();
              return;
            }
            if (this.isLastOptionViewFocused() && !e.shiftKey) {
              this.focusIcon(), e.preventDefault(), e.stopPropagation();
              return;
            }
            if (this.isFirstOptionViewFocused() && e.shiftKey) {
              this.focusIcon(), e.preventDefault(), e.stopPropagation();
              return;
            }
          }
        };
        this.tapListener = (e) => {
          let t = this.getContainerEl();
          if (!t) return;
          let { target: o } = e, i = this.getIconSelector();
          if (i && o.closest(i)) return;
          if (t.contains(o)) {
            if (!o.matches(p6)) return;
            let { first: a, last: s } = this.getDOMTabStops();
            a === o
              ? this.focusFirstOption()
              : s === o && this.focusLastOption();
            return;
          }
          Array.from(
            document.querySelectorAll(
              ".dcg-keypad,.dcg-show-keypad-container",
            ),
          ).some((a) => a.contains(o)) || this.closeMenu();
        };
        this.closeMenu = e,
          this.getContainerEl = i,
          this.getIconSelector = o,
          this.isIconFocused = n,
          this.focusIcon = t;
      }
      isFirstOptionViewFocused() {
        let { first: e } = this.getDOMTabStops();
        return e !== void 0 && e.matches(":focus");
      }
      focusFirstOption() {
        let { first: e } = this.getDOMTabStops();
        e !== void 0 && e.focus();
      }
      focusLastOption() {
        let { last: e } = this.getDOMTabStops();
        e !== void 0 && e.focus();
      }
      isLastOptionViewFocused() {
        let { last: e } = this.getDOMTabStops();
        return e !== void 0 && e.matches(":focus");
      }
      getDOMTabStops() {
        let e = this.getContainerEl();
        if (e === void 0) return {};
        let t = Array.from(e.querySelectorAll(p6)).filter((o) =>
          o.getAttribute("tabIndex") !== "-1"
        );
        return {
          first: t.find((o) => bp(o)),
          last: [...t.reverse()].find((o) => bp(o)),
        };
      }
    };
  var ps = class extends yy.Class {
    init() {
      this.controller = this.props.controller();
    }
    template() {
      return yy.createElement("div", {
        class: yy.const("dcg-options-menu-container"),
        didMount: this.bindFn(this.didMountView),
        didUnmount: this.bindFn(this.didUnmountView),
      }, this.props.children);
    }
    didMount() {
      this.props.openAriaAlert && xe(this.props.openAriaAlert());
    }
    willUnmount() {
      this.props.closeAriaAlert && xe(this.props.closeAriaAlert());
    }
    didMountView(e) {
      this.focusHelper = new YD({
        isIconFocused: () => this.isIconModelFocused(),
        focusIcon: () => this.focusIcon(),
        getContainerEl: () => this.openView,
        closeMenu: () => this.hideOptions(),
        getIconSelector: () => {
          var t;
          return `[dcg-open-menu-guid="${
            (t = this.controller.getOpenItemMenu()) == null ? void 0 : t.guid
          }"]`;
        },
      }),
        this.guid = __dcg_shared_module_exports__["K"](
          "dcg-dropdown-menu",
        ),
        this.openView = e,
        this.positionMenu(),
        this.moveFocusIfAppropriate(),
        this.attachKeyDownListeners(),
        this.attachTapListener();
    }
    isIconModelFocused() {
      let e = this.controller.getFocusLocation();
      return __dcg_shared_module_exports__["E"](
        e,
        this.props.menuButtonFocusLocation(),
      );
    }
    attachKeyDownListeners() {
      this.props.shouldHandleTabAndEscape() &&
        document.addEventListener(
          "keydown",
          this.focusHelper.globalKeyDownListener,
        );
    }
    attachTapListener() {
      ee(document.body).on(
        `dcg-tapstart.${this.guid}`,
        this.focusHelper.tapListener,
      );
    }
    didUnmountView() {
      document.removeEventListener(
        "keydown",
        this.focusHelper.globalKeyDownListener,
      ),
        ee(document.body).off(`.${this.guid}`),
        this.openView = void 0;
    }
    moveFocusIfAppropriate() {
      this.shouldMoveFocusToFirstOption()
        ? this.focusHelper.focusFirstOption()
        : this.shouldMoveFocusToLastOption() &&
          this.focusHelper.focusLastOption();
    }
    hideOptions() {
      this.controller.dispatch({ type: "close-item-settings-menu" });
    }
    getRootEl() {
      return this.controller.findEl(this.props.rootElSelector());
    }
    positionMenu() {
      var a;
      let e = this.controller.getOpenMenuIcon();
      if (!e || !this.openView) return;
      let t = this.getRootEl();
      if (!t) return;
      let o = t.getBoundingClientRect(),
        i = e.getBoundingClientRect(),
        n = i.width;
      if (
        this.props.menuType() === "geo-tool-dropdown" ||
        this.props.menuType() === "multi-select-construct" ||
        this.props.menuType() === "multi-select-style" ||
        this.props.menuType() === "multi-select-label" ||
        this.props.menuType() === "multi-select-more"
      ) {
        Wn(this.openView, { display: "block" });
        let s = (a = this.openView.querySelector(".dcg-options-menu")) == null
          ? void 0
          : a.getBoundingClientRect();
        if (!s) return;
        let l = i.left - o.left, c = o.right - (i.left + n);
        l + n / 2 >= s.width / 2 && c + n / 2 >= s.width / 2
          ? Wn(this.openView, {
            top: `${i.top - o.top}px`,
            left: `${l + n / 2 - s.width / 2}px`,
          })
          : l < c
          ? Wn(this.openView, { top: `${i.top - o.top}px`, left: "0px" })
          : Wn(this.openView, {
            top: `${i.top - o.top}px`,
            right: `${s.width}px`,
          });
      } else {Wn(this.openView, {
          top: `${i.top - o.top}px`,
          left: `${i.left - o.left}px`,
          display: "block",
        });}
    }
    focusIcon() {
      this.controller.focusOpenMenuIcon();
    }
    shouldMoveFocusToFirstOption() {
      if (this.props.focusOnOpen) {
        return this.props.focusOnOpen() === "first";
      }
      if (this.openView && this.openView.matches(":focus-within")) {
        return false;
      }
      let e = this.controller.getOpenItemMenu();
      return (e == null ? void 0 : e.type) === this.props.menuType() &&
        !!(e != null && e.focusFirstOption);
    }
    shouldMoveFocusToLastOption() {
      return this.props.focusOnOpen
        ? this.props.focusOnOpen() === "last"
        : false;
    }
  };
  var Zg = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    XD = class extends Zg.Class {
      onSpanMount(e) {
        e.insertAdjacentHTML(
          "beforeend",
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><style>.cls-1{fill:#7c69b3}.cls-3{fill:#719972}</style></defs><g id="Layer_1"><path d="M35.3 45.6ZM7.2 97.3z" class="cls-3"/><path fill="#fff" d="M7.2 97.3"/><path d="M47.7 39.8c2.5-2.9 3.7-6.3 3.7-10.3s-1-6.6-3-9.3c-2-2.7-4.6-4.6-7.7-5.7V2.7H30v11.8c-3.1 1.1-5.7 3-7.7 5.7s-3 5.8-3 9.3 1.3 7.6 3.9 10.5L4.7 89.4l2.5 7.9 8.2-5.1 17.1-46.9c.9.2 1.9.2 2.8.2 1.1 0 2.1 0 3.1-.3l16.8 47.1 8.2 4.3 1.7-8.2-17.5-48.7Zm-16.2-6.5c-1-1-1.5-2.3-1.5-3.8s.5-2.8 1.5-3.8 2.3-1.5 3.8-1.5 2.8.5 3.8 1.5 1.5 2.3 1.5 3.8-.5 2.8-1.5 3.8-2.3 1.5-3.8 1.5-2.8-.5-3.8-1.5Z" class="cls-3"/><path d="m49.8 94.3-9.9-27.8-8.7 15.6c-.6 1.1-.2 2.5.8 3.2l17.6 10.5c.4.2.8.3 1.2.3-.4-.5-.8-1.1-1-1.8ZM94.1 16 76.5 5.5c-1.1-.6-2.5-.3-3.1.8L54.2 40.8l11.3 31.3 29.5-53c.6-1.1.2-2.5-.8-3.2Z" class="cls-1"/></g></svg>',
        );
      }
      template() {
        return Zg.createElement("span", {
          "aria-hidden": Zg.const("true"),
          class: Zg.const("dcg-construct-button-icon"),
          onMount: this.bindFn(this.onSpanMount),
        });
      }
    };
  var _r = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var JD = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  function h6(r, e, t) {
    r.save();
    for (let o of t) {
      switch (o.type) {
        case "point":
          {
            let i;
            !o.color || o.color === "dark"
              ? i = GT({
                isPoint: true,
                color: e.point,
                uncommitted: false,
                featured: false,
                hidden: false,
                hovered: false,
                projectorMode: false,
              })
              : o.color === "light"
              ? i = __dcg_shared_module_exports__["Kd"](e.point, .7)
              : i = o.color;
            let n;
            switch (o.size) {
              case "small":
                n = 5;
                break;
              case "large":
                n = 10;
                break;
              case "medium":
              default:
                n = 5;
                break;
            }
            o.hollow
              ? (r.lineWidth = 2,
                r.strokeStyle = i,
                r.beginPath(),
                r.arc(o.x, o.y, n - 1, 0, 2 * Math.PI),
                r.stroke())
              : (r.fillStyle = i,
                r.beginPath(),
                r.arc(o.x, o.y, n, 0, 2 * Math.PI),
                r.fill());
          }
          break;
        case "circle":
          {
            let i;
            !o.color || o.color === "dark"
              ? i = tv({
                isPoint: false,
                color: e.circle,
                uncommitted: false,
                featured: false,
                hidden: false,
                hovered: false,
                projectorMode: false,
              })
              : o.color === "light"
              ? i = __dcg_shared_module_exports__["Kd"](e.circle, .7)
              : typeof o.color == "function"
              ? i = o.color(e)
              : i = o.color;
            let n;
            switch (o.lineWidth) {
              case "small":
                n = 2;
                break;
              case "large":
                n = 7;
                break;
              case "medium":
              case void 0:
                n = 4;
                break;
              default:
                n = o.lineWidth;
                break;
            }
            r.lineWidth = n,
              r.strokeStyle = i,
              r.beginPath(),
              r.arc(o.x, o.y, o.radius, 0, 2 * Math.PI),
              r.stroke();
          }
          break;
        case "arc":
          {
            let i;
            !o.color || o.color === "dark"
              ? i = tv({
                isPoint: false,
                color: e.circle,
                uncommitted: false,
                featured: false,
                hidden: false,
                hovered: false,
                projectorMode: false,
              })
              : o.color === "light"
              ? i = __dcg_shared_module_exports__["Kd"](e.circle, .7)
              : i = o.color;
            let n;
            switch (o.lineWidth) {
              case "small":
                n = 2;
                break;
              case "large":
                n = 7;
                break;
              case "medium":
              default:
                n = 4;
                break;
            }
            r.lineWidth = n,
              r.strokeStyle = i,
              r.beginPath(),
              r.arc(o.x, o.y, o.radius, o.startAngle, o.endAngle),
              r.stroke();
          }
          break;
        case "stroked-path":
          {
            let i;
            !o.color || o.color === "dark"
              ? i = tv({
                isPoint: false,
                color: e.line,
                uncommitted: false,
                featured: false,
                hidden: false,
                hovered: false,
                projectorMode: false,
              })
              : o.color === "light"
              ? i = __dcg_shared_module_exports__["Kd"](e.line, .7)
              : typeof o.color == "function"
              ? i = o.color(e)
              : i = o.color;
            let n = o.path, a;
            switch (o.lineWidth) {
              case "small":
                a = 1;
                break;
              case "large":
                a = 5;
                break;
              case "medium":
              default:
                a = 3;
                break;
            }
            r.lineCap = "round",
              r.lineJoin = "round",
              r.strokeStyle = i,
              r.lineWidth = a,
              r.beginPath(),
              r.moveTo(n[0], n[1]);
            for (let s = 2; s < n.length; s += 2) {
              r.lineTo(n[s], n[s + 1]);
            }
            if (o.arrow) {
              let s = [], l = n.length - 1;
              une(s, n[l - 3], n[l - 2], n[l - 1], n[l], a / 2 + 9.5);
              for (let c = 0; c < s.length; c += 2) {
                r.lineTo(s[c], s[c + 1]);
              }
            }
            r.stroke();
          }
          break;
        case "filled-polygon":
          {
            let i;
            o.color ? i = o.color : i = GT({
              isPoint: false,
              color: e.polygon,
              uncommitted: false,
              featured: false,
              hidden: false,
              hovered: false,
              projectorMode: false,
              isTransparentObject: true,
            });
            let n = o.path;
            r.fillStyle = i, r.beginPath(), r.moveTo(n[0], n[1]);
            for (let a = 2; a < n.length; a += 2) {
              r.lineTo(n[a], n[a + 1]);
            }
            r.fill();
          }
          break;
        case "angle":
          {
            let i = tv({
                isPoint: false,
                color: e.angle,
                uncommitted: false,
                featured: false,
                hidden: false,
                hovered: false,
                projectorMode: false,
                isTransparentObject: true,
              }),
              n = GT({
                isPoint: false,
                color: e.angle,
                uncommitted: false,
                featured: false,
                hidden: false,
                hovered: false,
                projectorMode: false,
                isTransparentObject: true,
              });
            pne(r, {
              type: "angle-indicator",
              lineWidth: 4,
              strokeStyle: i,
              fillStyle: n,
              isRightAngle: false,
              x: o.x,
              y: o.y,
              isDirected: o.isDirected,
              radius: o.radius,
              startAngle: o.startAngle,
              deltaAngle: o.deltaAngle,
            });
          }
          break;
        case "ellipse":
          r.lineWidth = o.lineWidth,
            r.strokeStyle = o.color,
            r.beginPath(),
            r.ellipse(o.x, o.y, o.rx, o.ry, 0, 0, 2 * Math.PI),
            r.stroke();
          break;
        default:
          return o;
      }
    }
    r.restore();
  }
  function pne(r, e) {
    r.beginPath(),
      u6(r, e),
      r.lineTo(e.x, e.y),
      r.lineTo(
        e.x + e.radius * Math.cos(e.startAngle),
        e.y + e.radius * Math.sin(e.startAngle),
      ),
      e.isDirected || (r.fillStyle = e.fillStyle, r.fill()),
      r.strokeStyle = e.strokeStyle,
      r.lineWidth = e.lineWidth,
      r.beginPath(),
      u6(r, e),
      r.stroke();
  }
  function u6(r, e) {
    let t = e.startAngle + e.deltaAngle;
    if (e.isRightAngle) {
      let o = e.radius * Math.cos(e.startAngle),
        i = e.radius * Math.cos(t),
        n = e.radius * Math.sin(e.startAngle),
        a = e.radius * Math.sin(t);
      r.moveTo(e.x + o, e.y + n),
        r.lineTo(e.x + o + i, e.y + n + a),
        r.lineTo(e.x + i, e.y + a);
    } else r.arc(e.x, e.y, e.radius, e.startAngle, t);
  }
  function une(r, e, t, o, i, n = 12) {
    let a = Math.atan2(i - t, o - e),
      s = o - n * Math.cos(a - Math.PI / 9),
      l = i - n * Math.sin(a - Math.PI / 9),
      c = o - n * Math.cos(a + Math.PI / 9),
      d = i - n * Math.sin(a + Math.PI / 9),
      p = o - (n - 2) * Math.cos(a - Math.PI / 18),
      h = i - (n - 2) * Math.sin(a - Math.PI / 18),
      u = o - (n - 2) * Math.cos(a + Math.PI / 18),
      f = i - (n - 2) * Math.sin(a + Math.PI / 18);
    r.push(s, l, c, d, o, i, p, h, u, f, o, i);
  }
  var em = class extends JD.Class {
    template() {
      return JD.createElement("canvas", {
        didMount: this.bindFn(this.didMountCanvas),
        width: () => this.props.width(),
        height: () => this.props.height(),
        style: () => ({
          width: this.props.width() / 2 + "px",
          height: this.props.height() / 2 + "px",
        }),
      });
    }
    didMountCanvas(e) {
      this.canvas = e, this.redraw();
    }
    didUpdate() {
      this.redraw();
    }
    redraw() {
      let e = this.props.instructions() || [],
        t = this.props.model().getNonObjectsState().ui.colors;
      if (
        __dcg_shared_module_exports__["E"](e, this.lastInstructions) &&
        __dcg_shared_module_exports__["E"](t, this.lastColors)
      ) return;
      this.lastInstructions = e, this.lastColors = t;
      let o = this.canvas.getContext("2d");
      o.clearRect(0, 0, o.canvas.width, o.canvas.height), h6(o, t, e);
    }
  };
  var pa = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { For: hne, Each: gne, SwitchUnion: mne } = pa.Components,
    xy = class extends pa.Class {
      init() {
        this.controller = this.props.controller(),
          this.geoModel = this.controller.getGeoModel();
      }
      template() {
        return pa.createElement(
          "div",
          {
            class: () => ({
              "dcg-options-menu": true,
              "dcg-select-tools-dropdown": true,
              "dcg-shift-menu-left": this.props.items()[0][0] === "angle" ||
                this.props.items()[0][0] === "segment",
            }),
            "aria-label": this.props.ariaLabel,
            onKeyDown: this.bindFn(this.handleKeyPress),
            "dcg-geo-tool-group": this.bindFn(this.props.group),
          },
          pa.createElement(
            "div",
            {
              class: pa.const("dcg-options-menu-section-container"),
              role: pa.const("menu"),
            },
            gne(() => this.props.items(), {
              item: (e) =>
                pa.createElement(
                  "div",
                  { class: () => ({ "dcg-options-menu-section": true }) },
                  pa.createElement(hne, {
                    each: () => e,
                  }, (t) =>
                    pa.createElement(
                      "button",
                      {
                        role: pa.const("menuitemradio"),
                        tabIndex: () =>
                          t === e[0] &&
                            this.sectionKey(e) ===
                              this.sectionKey(this.props.items()[0])
                            ? 0
                            : -1,
                        "aria-disabled": () => !this.isToolEnabled(t),
                        "aria-description": () =>
                          this.isToolEnabled(t) ? void 0 : this.controller.s(
                            "graphing-calculator-narration-geometry-tool-disabled",
                            { tool: t },
                          ),
                        "aria-checked": () =>
                          this.controller.getActiveTool() === t,
                        onTap: (o) => {
                          this.isToolEnabled(t) &&
                            this.props.onChooseTool({
                              tool: t,
                              fromKeyboard: o.device === "keyboard",
                            });
                        },
                        "dcg-geo-tool": this.const(t),
                        class: () => ({
                          "dcg-dropdown-tool": true,
                          "dcg-unstyled-button": true,
                          "dcg-transformation-tool":
                            __dcg_shared_module_exports__["Dc"](t),
                          "dcg-selected-tool":
                            this.controller.getActiveTool() === t,
                          "dcg-disabled": !this.isToolEnabled(t),
                          "dcg-will-be-hidden-or-disabled": this
                            .controller.toolWillBeHiddenOrDisabled(t),
                        }),
                        manageFocus: this.const(
                          rt({
                            controller: this.controller,
                            location: {
                              type: "geo-basic-tool-menu-item",
                              tool: t,
                            },
                          }),
                        ),
                      },
                      mne("type", () => this.getIconInfo(t))({
                        css: (o) =>
                          pa.createElement("i", {
                            class: () => o().className,
                          }),
                        canvas: (o) =>
                          pa.createElement(em, {
                            model: () => this.geoModel,
                            width: this.const(100),
                            height: this.const(100),
                            instructions: () => o().instructions,
                          }),
                      }),
                      pa.createElement(
                        "span",
                        null,
                        () => this.geoModel.getDisplayNameForTool(t),
                      ),
                    )),
                ),
              key: (e) => this.sectionKey(e),
            }),
          ),
          this.props.children,
        );
      }
      sectionKey(e) {
        return e.join("-");
      }
      getIconInfo(e) {
        switch (e) {
          case "dilate":
            return { type: "css", className: "dcg-icon-dilation" };
          case "reflect":
            return { type: "css", className: "dcg-icon-reflection" };
          case "rotate":
            return { type: "css", className: "dcg-icon-rotation" };
          case "translate":
            return { type: "css", className: "dcg-icon-vector" };
          default:
            return {
              type: "canvas",
              instructions: this.geoModel.getIconInstructionsForTool(e),
            };
        }
      }
      isToolEnabled(e) {
        return this.controller.isGeoToolEnabled(e) &&
          this.geoModel.isToolActuallyUsable(e);
      }
      handleKeyPress(e) {
        let t = ke(e);
        if (t !== "Up" && t !== "Down" && t !== "Esc") return;
        let o = __dcg_shared_module_exports__["t"](this.props.items()),
          i = this.controller.getFocusLocation();
        if (t === "Esc") {
          (i == null ? void 0 : i.type) === "geo-basic-tool-menu-item" &&
          this.focusMenuIcon(),
            this.controller.dispatch({
              type: "close-item-settings-menu",
            }),
            e.stopPropagation(),
            e.preventDefault();
          return;
        }
        if (
          (i == null ? void 0 : i.type) !== "geo-basic-tool-menu-item"
        ) return;
        let n = t === "Down" ? 1 : -1,
          s = (o.indexOf(i.tool) + n) % o.length;
        s < 0 && (s = o.length + s),
          s >= 0 &&
          (this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "geo-basic-tool-menu-item", tool: o[s] },
          }),
            e.preventDefault(),
            e.stopPropagation());
      }
      focusMenuIcon() {
        let e = this.props.group();
        if (!e) return;
        if (e === "construct-from-selection") {
          return this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "multi-select-construct-icon" },
          });
        }
        let t = this.controller.getGeoToolbarItemsForGroup(e),
          o = t == null ? void 0 : t.current;
        if (o) {
          return this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "geo-basic-tool", tool: o },
          });
        }
      }
    };
  var { If: g6, For: fne, Switch: bne } = _r.Components,
    tm = class extends _r.Class {
      getAriaLabel() {
        let e = this.props.controller(), t = this.props.menuName();
        if (t) {
          return e.s(
            "graphing-calculator-label-geometry-tools-open-dropdown-menu-transformation",
            { item: t },
          );
        }
      }
      template() {
        return _r.createElement(
          "span",
          {
            class: _r.const("dcg-tool-dropdown"),
            role: _r.const("button"),
            tabIndex: _r.const("-1"),
            "aria-label": this.bindFn(this.getAriaLabel),
            "aria-expanded": this.props.ariaExpanded,
            onTap: this.bindFn(this.handleOnTap),
          },
          _r.createElement(
            "span",
            { class: _r.const("dcg-dropdown-icon") },
            _r.createElement("i", {
              class: _r.const("dcg-icon-caret-down"),
            }),
          ),
        );
      }
      handleOnTap(e) {
        e.handle(), this.props.openDropDown();
      }
    },
    QD = class extends _r.Class {
      init() {
        this.controller = this.props.controller(),
          this.geoModel = this.controller.getGeoModel();
      }
      getGroups() {
        return this.controller.getGeoToolbarGroupKeys();
      }
      hasDropdown(e) {
        return !!this.getGroup(e).dropdown;
      }
      template() {
        return _r.createElement(
          "div",
          {
            role: _r.const("toolbar"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-label-geometry-tools",
              ),
            class: _r.const(
              "dcg-geo-basic-tools dcg-animate-in-after-initial-load",
            ),
            onKeyDown: (e) => this.handleToolbarKeydown(e),
          },
          _r.createElement(
            "div",
            { class: _r.const("dcg-geo-basic-tools-row") },
            _r.createElement(
              fne,
              { each: () => this.getGroups() },
              (e) =>
                _r.createElement(
                  "div",
                  { class: _r.const("dcg-tool-button-container") },
                  _r.createElement(
                    "button",
                    {
                      class: () => ({
                        "dcg-split-btn": this.hasDropdown(e),
                        "dcg-selected": this.isGroupSelected(
                          this.getGroup(e),
                        ),
                        "dcg-disabled": !this.isGroupEnabled(
                          this.getGroup(e),
                        ),
                        "dcg-menu-open": this.isGroupDropdownOpen(
                          this.getGroup(e),
                        ),
                        "dcg-will-be-hidden-or-disabled": this.controller
                          .toolWillBeHiddenOrDisabled(
                            this.getGroup(e).current,
                          ),
                      }),
                      "dcg-geo-tool": () => this.getGroup(e).current,
                      "dcg-geo-tool-group": () => e,
                      tabIndex: () =>
                        this.isGroupSelected(this.getGroup(e)) ? 0 : -1,
                      "aria-label": () =>
                        this.geoModel.getDisplayNameForTool(
                          this.getGroup(e).current,
                        ),
                      "aria-disabled": () =>
                        !this.isGroupEnabled(this.getGroup(e)),
                      "aria-haspopup": () => this.hasDropdown(e),
                      "aria-pressed": () =>
                        this.isGroupSelected(this.getGroup(e)),
                      onTap: (t) => this.handleTap(t, this.getGroup(e)),
                      onLongHold: () =>
                        this.openMenuFromLongHold(this.getGroup(e)),
                      "dcg-open-menu-guid": () =>
                        this.getGuid(this.getGroup(e)),
                      manageFocus: () =>
                        rt({
                          controller: this.controller,
                          location: {
                            type: "geo-basic-tool",
                            tool: this.getGroup(e).current,
                          },
                        }),
                      "aria-controls": () => this.getGuid(this.getGroup(e)),
                      "aria-expanded": () =>
                        this.isGroupDropdownOpen(this.getGroup(e)),
                    },
                    _r.createElement(
                      "span",
                      {
                        class: () => ({
                          "dcg-basic-tool-btn": true,
                          "dcg-icon": true,
                        }),
                      },
                      _r.createElement(em, {
                        model: () => this.geoModel,
                        width: this.const(96),
                        height: this.const(96),
                        instructions: () =>
                          this.geoModel.getIconInstructionsForTool(
                            this.getGroup(e).current,
                          ),
                      }),
                    ),
                    _r.createElement(g6, {
                      predicate: () => this.hasDropdown(e),
                    }, () =>
                      _r.createElement(tm, {
                        menuName: () => m6(this.controller, e),
                        controller: this.props.controller,
                        ariaExpanded: () =>
                          this.isGroupDropdownOpen(this.getGroup(e)),
                        openDropDown: () =>
                          this.openDropdownMenu(this.getGroup(e)),
                      })),
                  ),
                  _r.createElement(g6, {
                    predicate: () => this.isGroupDropdownOpen(this.getGroup(e)),
                  }, () =>
                    _r.createElement(
                      ps,
                      {
                        controller: this.props.controller,
                        shouldHandleTabAndEscape: this.const(false),
                        menuType: this.const("geo-tool-dropdown"),
                        menuButtonFocusLocation: this.const({
                          type: "geo-basic-tool",
                          tool: this.getGroup(e).current,
                        }),
                        rootElSelector: this.const(
                          ".dcg-geo-basic-tools-row",
                        ),
                      },
                      _r.createElement(xy, {
                        controller: this.props.controller,
                        group: () => e,
                        ariaLabel: () => m6(this.controller, e),
                        items: () => this.getDropdownTools(e),
                        onChooseTool: (t) => {
                          this.controller.dispatch({
                            type: "select-geo-tool",
                            tool: t.tool,
                            focusGraphPaper: !!t.fromKeyboard,
                          });
                        },
                      }),
                    )),
                ),
            ),
          ),
          _r.createElement(bne, {
            key: () => this.controller.getGeometryGettingStartedMessageState(),
          }, (e) => {
            switch (e) {
              case "hidden":
                return _r.createElement("span", null);
              case "construct":
              case "pick-a-tool":
                return _r.createElement(
                  "div",
                  {
                    class: () => ({
                      "dcg-geo-getting-started-pointer": true,
                      "dcg-geo-getting-started-has-tool": this.controller
                        .getGeometryGettingStartedMessageState() !==
                        "pick-a-tool",
                    }),
                  },
                  this.bindFn(this.getPointerMessage),
                  _r.createElement(
                    "span",
                    { class: _r.const("dcg-curved-icon-container") },
                    _r.createElement("i", {
                      class: _r.const("dcg-icon-curved-arrow"),
                    }),
                  ),
                );
            }
          }),
        );
      }
      getDropdownTools(e) {
        let t = this.controller.getOpenItemMenu();
        if (!t || t.type !== "geo-tool-dropdown" || t.group !== e) {
          return [];
        }
        if (t.group === "line") {
          let o = [], i = [];
          for (let n of t.tools) {
            n === "segment" || n === "line" || n === "ray" ||
              n === "vector"
              ? o.push(n)
              : i.push(n);
          }
          return [o, i];
        }
        return [t.tools];
      }
      isGroupSelected(e) {
        return this.selectedTool() === e.current;
      }
      isGroupEnabled(e) {
        return this.controller.isGeoToolEnabled(e.current);
      }
      getGroup(e) {
        let t = this.controller.getGeoToolbarItemsForGroup(e);
        if (!t) throw new Error("Programing error: " + e + " not found");
        return t;
      }
      getPointerMessage() {
        return this.controller.getGeometryGettingStartedMessageState() ===
            "pick-a-tool"
          ? this.controller.s("geometry-label-pick-tool-instruction")
          : this.controller.s("geometry-label-construct-instruction");
      }
      getFocusedOrActiveTool() {
        let e = this.controller.getAllVisibleGeoToolbarItems(),
          t = this.controller.getFocusLocation();
        if (!t) return;
        let o;
        return t.type === "geo-basic-tool" ||
            t.type === "geo-basic-tool-menu-item"
          ? o = t.tool
          : o = this.controller.getActiveTool(),
          e.find((i) => {
            var n, a;
            return i.current === o ||
              i.dropdown &&
                ((a = (n = i.dropdown) == null ? void 0 : n.indexOf) ==
                      null
                    ? void 0
                    : a.call(n, o)) > -1;
          });
      }
      handleToolbarKeydown(e) {
        var l, c, d, p;
        let t = ke(e);
        if (
          t !== "Up" && t !== "Down" && t !== "Left" && t !== "Right" &&
            t !== "Home" && t !== "End" ||
          (e.preventDefault(),
            e.stopPropagation(),
            !this.controller.getFocusLocation())
        ) return;
        let i = this.controller.getAllVisibleGeoToolbarItems(),
          n = this.getFocusedOrActiveTool();
        if (!n) return;
        let a = i.findIndex((h) => h.group === n.group), s;
        if (t === "Home") s = (l = i[0]) == null ? void 0 : l.current;
        else if (t === "End") {
          s = (c = i[i.length - 1]) == null ? void 0 : c.current;
        } else if (t === "Left" || t === "Right") {
          let h = t === "Left" ? -1 : 1,
            u = Math.max(0, Math.min(i.length - 1, a + h));
          s = (d = i[u]) == null ? void 0 : d.current,
            ((p = this.controller.getOpenItemMenu()) == null
                ? void 0
                : p.type) === "geo-tool-dropdown" &&
            this.controller.dispatch({
              type: "toggle-item-settings-menu",
              menu: {
                type: "geo-tool-dropdown",
                guid: this.getGuid(n),
                tools: [],
                group: n.group,
              },
            });
        } else (t === "Up" || t === "Down") && this.openDropdownMenu(n);
        s &&
          this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "geo-basic-tool", tool: s },
          });
      }
      selectedTool() {
        let e = this.controller.getActiveTool();
        return e === "expression-edit" ? "selection" : e;
      }
      openDropdownMenu(e) {
        e.dropdown &&
          (this.isGroupSelected(e) ||
            this.controller.dispatch({
              type: "select-geo-tool",
              tool: e.current,
            }),
            this.controller.dispatch({
              type: "toggle-item-settings-menu",
              menu: {
                type: "geo-tool-dropdown",
                guid: this.getGuid(e),
                tools: e.dropdown,
                group: e.group,
                focusFirstOption: false,
              },
            }),
            this.controller.dispatch({
              type: "set-focus-location",
              location: {
                type: "geo-basic-tool-menu-item",
                tool: e.current,
              },
            }));
      }
      getGuid(e) {
        return e.dropdown ? "geo-dropdown-" + e.dropdown[0] : "";
      }
      openMenuFromLongHold(e) {
        this.controller.dispatch({
          type: "select-geo-tool",
          tool: e.current,
        }), this.openDropdownMenu(e);
      }
      handleTap(e, t) {
        e.wasLongheld() || e.wasHandled() ||
          (e.shiftKey || this.isGroupSelected(this.getGroup(t.group))
            ? this.openDropdownMenu(t)
            : (this.controller.dispatch({
              type: "select-geo-tool",
              tool: t.current,
              focusGraphPaper: e.device === "keyboard",
            }),
              e.device !== "keyboard" &&
              this.controller.dispatch({
                type: "set-focus-location",
                location: { type: "geo-basic-tool", tool: t.current },
              })));
      }
      isGroupDropdownOpen(e) {
        let t = this.controller.getOpenItemMenu();
        return (t == null ? void 0 : t.type) === "geo-tool-dropdown" &&
          t.group === e.group;
      }
    };
  function m6(r, e) {
    switch (e) {
      case "selection":
        return r.s(
          "graphing-calculator-label-geometry-tools-dropdown-menu-selection",
        );
      case "point":
        return r.s(
          "graphing-calculator-label-geometry-tools-dropdown-menu-point",
        );
      case "line":
        return r.s(
          "graphing-calculator-label-geometry-tools-dropdown-menu-line",
        );
      case "circle":
        return r.s(
          "graphing-calculator-label-geometry-tools-dropdown-menu-circle",
        );
      case "angle":
        return r.s(
          "graphing-calculator-label-geometry-tools-dropdown-menu-angle",
        );
      case "polygon":
        return r.s(
          "graphing-calculator-label-geometry-tools-dropdown-menu-polygon",
        );
      case "transformation":
        return r.s(
          "graphing-calculator-label-geometry-tools-dropdown-menu-transformation",
        );
    }
  }
  var Zn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var or = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { Switch: yne, SwitchUnion: xne } = or.Components,
    Pd = class extends or.Class {
      template() {
        return xne("type", () => this.getLatexOrToken())({
          identifier: (e) =>
            or.createElement(Ad, {
              identifier: () => e().identifier,
              insideMQ: () => false,
              controller: () => this.props.controller(),
              insideGroup: () => false,
              putInTabOrder: () => false,
            }),
          latex: (e) =>
            or.createElement(nt, {
              config: () => this.props.controller().getMathquillConfig({}),
              latex: () => e().latex,
              tokenController: this.props.controller,
            }),
        });
      }
      getLatexOrToken() {
        let e = this.props.parent();
        switch (e.type) {
          case "arbitrary-expression":
            return { type: "latex", latex: e.latex };
          case "list-access":
          case "polygon-edge":
          case "simple":
            return {
              type: "identifier",
              identifier: __dcg_shared_module_exports__["Cc"](e),
            };
          default:
            return { type: "latex", latex: "unknown" };
        }
      }
    },
    ZD = class extends or.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return or.createElement(yne, {
          key: this.bindFn(this.getTransformationType),
        }, (e) => {
          switch (e) {
            case "translate":
              return this.getParents().length === 1
                ? or.createElement(
                  "div",
                  null,
                  or.createElement(
                    Oi,
                    {
                      i18n: this.const(this.controller),
                      key: this.const(
                        "graphing-calculator-label-geometry-translation-by-vector",
                      ),
                    },
                    or.const("Translate by"),
                    or.const(" "),
                    Oi.subview(
                      "parent1",
                      () =>
                        or.createElement(Pd, {
                          controller: this.props.controller,
                          parent: () => this.getParents()[0],
                        }),
                    ),
                  ),
                )
                : or.createElement(
                  "div",
                  null,
                  or.createElement(
                    Oi,
                    {
                      i18n: this.const(this.controller),
                      key: this.const(
                        "graphing-calculator-label-geometry-translation-by-two-points",
                      ),
                    },
                    or.const("Translate from"),
                    or.const(" "),
                    Oi.subview(
                      "parent1",
                      () =>
                        or.createElement(Pd, {
                          controller: this.props.controller,
                          parent: () => this.getParents()[0],
                        }),
                    ),
                    or.const(" "),
                    or.const("to"),
                    or.const(" "),
                    Oi.subview(
                      "parent2",
                      () =>
                        or.createElement(Pd, {
                          controller: this.props.controller,
                          parent: () => this.getParents()[1],
                        }),
                    ),
                  ),
                );
            case "reflect":
              return or.createElement(
                "div",
                null,
                or.createElement(
                  Oi,
                  {
                    i18n: this.const(this.controller),
                    key: this.const(
                      "graphing-calculator-label-geometry-reflection-over-point",
                    ),
                  },
                  or.const("Reflect over"),
                  or.const(" "),
                  Oi.subview(
                    "parent1",
                    () =>
                      or.createElement(Pd, {
                        controller: this.props.controller,
                        parent: () => this.getParents()[0],
                      }),
                  ),
                ),
              );
            case "dilate":
              return or.createElement(
                "div",
                null,
                or.createElement(
                  Oi,
                  {
                    i18n: this.const(this.controller),
                    key: this.const(
                      "graphing-calculator-label-geometry-dilation-by-point",
                    ),
                  },
                  or.const("Dilate at"),
                  or.const(" "),
                  Oi.subview(
                    "parent1",
                    () =>
                      or.createElement(Pd, {
                        controller: this.props.controller,
                        parent: () => this.getParents()[0],
                      }),
                  ),
                  or.const(" by "),
                  Oi.subview(
                    "parent2",
                    () =>
                      or.createElement(Pd, {
                        controller: this.props.controller,
                        parent: () => this.getParents()[1],
                      }),
                  ),
                ),
              );
            case "rotate":
              return or.createElement(
                "div",
                null,
                or.createElement(
                  Oi,
                  {
                    i18n: this.const(this.controller),
                    key: this.const(
                      "graphing-calculator-label-geometry-rotation-around-point-by-angle",
                    ),
                  },
                  or.const("Rotate around"),
                  or.const(" "),
                  Oi.subview(
                    "parent1",
                    () =>
                      or.createElement(Pd, {
                        controller: this.props.controller,
                        parent: () => this.getParents()[0],
                      }),
                  ),
                  or.const(" by "),
                  Oi.subview(
                    "parent2",
                    () =>
                      or.createElement(Pd, {
                        controller: this.props.controller,
                        parent: () =>
                          wne(
                            this.getParents()[1],
                            this.controller.getGraphSettings().degreeMode,
                          ),
                      }),
                  ),
                ),
              );
            case void 0:
              return or.createElement("span", null);
          }
        });
      }
      getParents() {
        let e = this.getGeometry();
        return !e || !e.call ? [] : e && e.call ? e.call.parents : [];
      }
      getGeometry() {
        var e;
        return (e = this.props.model()) == null ? void 0 : e.formula.geometry;
      }
      getTransformationType() {
        var o;
        let e = this.getGeometry(),
          t = (o = e == null ? void 0 : e.call) == null ? void 0 : o.symbol;
        switch (t) {
          case "translate":
          case "dilate":
          case "reflect":
          case "rotate":
            return t;
        }
      }
    };
  function wne(r, e) {
    let t = e ? "\xB0" : "";
    if (r.type === "arbitrary-expression") {
      return { ...r, latex: r.latex + t };
    }
    if (r.type === "simple") {
      let o = __dcg_shared_module_exports__["identifierToLatex"](r.identifier);
      if (!/^\\token\{(\d+)\}$/.test(o)) {
        return { type: "arbitrary-expression", latex: o + t };
      }
    }
    return r;
  }
  var { Each: vne, If: Cne } = Zn.Components,
    ek = class extends Zn.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Zn.createElement(
          xy,
          {
            controller: this.props.controller,
            ariaLabel: () =>
              this.controller.s(
                "graphing-calculator-narration-geometry-construct-menu",
              ),
            group: () => "construct-from-selection",
            items: () => {
              var o, i;
              let e = [this.getTransformations()],
                t = (i = (o = this.props.constructFromSelectionInfo()) ==
                      null
                    ? void 0
                    : o.relevantTools) != null
                  ? i
                  : [];
              return t.length > 0 && e.push(t), e;
            },
            onChooseTool: (e) => this.chooseTool(e),
          },
          Zn.createElement(Cne, {
            predicate: () => this.props.existingTransformations().length > 0,
          }, () =>
            Zn.createElement(
              "div",
              {
                class: Zn.const(
                  "dcg-options-menu-section dcg-existing-transformations-container",
                ),
              },
              Zn.createElement("div", {
                class: Zn.const("dcg-transformation-header"),
              }, () =>
                this.controller.s(
                  "graphing-calculator-label-recent-transformations",
                )),
              Zn.createElement(
                "div",
                {
                  role: Zn.const("menu"),
                  "aria-label": () =>
                    this.controller.s(
                      "graphing-calculator-label-recent-transformations",
                    ),
                  onKeyDown: this.bindFn(this.handleKeyPress),
                },
                vne(() => this.props.existingTransformations(), {
                  item: (e, t) =>
                    Zn.createElement(
                      "div",
                      {
                        class: Zn.const("dcg-existing-transformation"),
                        role: Zn.const("menuitemradio"),
                        tabIndex: () =>
                          t === this.props.existingTransformations()[0].id
                            ? 0
                            : -1,
                        onTap: () => this.applyTransformation(e),
                        onPointerOut: (o) => this.onPointerOut(o, e),
                        onPointerOver: (o) => this.onPointerOver(o, e),
                        willUnmount: () => this.onImplicitMouseOut(e),
                        manageFocus: () =>
                          rt({
                            controller: this.controller,
                            location: {
                              type:
                                "geo-construct-menu-existing-transformations",
                              transformationId: e.id,
                            },
                          }),
                      },
                      Zn.createElement(ZD, {
                        controller: this.props.controller,
                        model: () => e,
                      }),
                    ),
                  key: (e) => e.id,
                }),
              ),
            )),
        );
      }
      generateToolOutput(e) {
        let t = this.props.constructFromSelectionInfo();
        if (!t) return;
        let { selected: o } = t;
        return this.controller.getGeoModel().generatePureToolOutput(e, o);
      }
      chooseTool(e) {
        var o, i;
        let t = e.tool;
        if (!__dcg_shared_module_exports__["Dc"](t)) {
          let n = this.generateToolOutput(t);
          if (n != null && n.canCommit) {
            this.controller.dispatch({
              type: "close-item-settings-menu",
            }),
              this.controller.getGeoModel().resetToolMode(),
              this.controller.dispatch({
                type: "commit-geo-objects",
                shiftKey: false,
                committed: n.outputs,
                clearToolAndSelection: true,
                toolIdToLatex: {},
              });
          } else {
            let a = this.controller.getSelectedItem();
            this.controller.dispatch({
              type: "select-geo-tool",
              tool: t,
              forceSingleUse: true,
              focusGraphPaper: !!e.fromKeyboard,
            });
            let s = this.controller.getGeoModel(),
              l = (i = (o = s.getTool(t)).getSpec) == null ? void 0 : i.call(o);
            if (!l || (a == null ? void 0 : a.type) !== "expression") {
              return;
            }
            s.tentativelyMatchToolInput(l, Bv(a)), s.attemptLockToolInputIn(l);
          }
          return;
        }
        this.controller.dispatch({
          type: "select-geo-tool",
          tool: t,
          focusGraphPaper: !!e.fromKeyboard,
        });
      }
      getTransformations() {
        return fy.filter((e) => this.controller.isGeoToolVisible(e));
      }
      handleKeyPress(e) {
        let t = ke(e);
        if (t !== "Up" && t !== "Down" && t !== "Esc") return;
        let o = this.props.existingTransformations(),
          i = this.controller.getFocusLocation();
        if (t === "Esc") {
          if (
            (i == null ? void 0 : i.type) ===
              "geo-construct-menu-existing-transformations"
          ) {
            return this.controller.dispatch({
              type: "set-focus-location",
              location: { type: "multi-select-construct-icon" },
            });
          }
          this.controller.dispatch({ type: "close-item-settings-menu" }),
            e.stopPropagation(),
            e.preventDefault();
          return;
        }
        if (
          (i == null ? void 0 : i.type) !==
            "geo-construct-menu-existing-transformations"
        ) return;
        let n = t === "Down" ? 1 : -1,
          s = (o.findIndex((l) => l.id === i.transformationId) + n) %
            o.length;
        s < 0 && (s = o.length + s),
          s >= 0 &&
          (this.controller.dispatch({
            type: "set-focus-location",
            location: {
              type: "geo-construct-menu-existing-transformations",
              transformationId: o[s].id,
            },
          }),
            e.preventDefault(),
            e.stopPropagation());
      }
      onPointerOver(e, t) {
        var i;
        if (e.pointerType !== "mouse") return;
        let o = (i = pi(t)) == null ? void 0 : i.identifier;
        o &&
          (this.currentlyActiveTokenIdentifier = o,
            this.controller.dispatch({
              type: "set-active-token",
              identifier: this.currentlyActiveTokenIdentifier,
              style: "hovered",
            }));
      }
      onPointerOut(e, t) {
        var i;
        if (e.pointerType !== "mouse") return;
        let o = (i = pi(t)) == null ? void 0 : i.identifier;
        o && this.currentlyActiveTokenIdentifier &&
          this.currentlyActiveTokenIdentifier === o &&
          (this.controller.dispatch({
            type: "unset-active-token",
            identifier: this.currentlyActiveTokenIdentifier,
            style: "hovered",
          }),
            this.currentlyActiveTokenIdentifier = void 0);
      }
      onImplicitMouseOut(e) {
        var o;
        let t = (o = pi(e)) == null ? void 0 : o.identifier;
        t && this.currentlyActiveTokenIdentifier &&
          this.currentlyActiveTokenIdentifier === t &&
          this.controller.runAfterDispatch(() => {
            let i = this.currentlyActiveTokenIdentifier;
            i &&
              (this.currentlyActiveTokenIdentifier = void 0,
                this.controller.dispatch({
                  type: "unset-active-token",
                  identifier: i,
                  style: "hovered",
                }));
          });
      }
      applyTransformation(e) {
        var o;
        if (!((o = e.formula.geometry) != null && o.identifier)) return;
        let t = __dcg_shared_module_exports__["identifierToLatex"](
          e.formula.geometry.identifier,
        );
        this.controller.dispatch({
          type: "apply-transformation-to-selected",
          assignmentLatex: t,
        });
      }
    };
  var dn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: Sne, IfElse: Ene, SwitchUnion: Tne } = dn.Components,
    tk = class extends dn.Class {
      init() {
        this.controller = this.props.controller(), this.updateSingleItemState();
      }
      willUpdate() {
        this.updateSingleItemState();
      }
      updateSingleItemState() {
        var o;
        let e = this.getSelectionLabelInfo();
        if (e.type === "multiple") {
          this.singleItemState = void 0;
          return;
        }
        if (
          ((o = this.singleItemState) == null ? void 0 : o.itemId) ===
            e.model.id
        ) return;
        let t;
        ja(e.model)
          ? t = e.model.label === "" ? "measurement" : "text"
          : t = "text", this.singleItemState = { itemId: e.model.id, mode: t };
      }
      sectionValues() {
        return this.props.sectionValues();
      }
      getSelectionLabelInfo() {
        var o, i;
        let t = this.sectionValues().singleLabelableExpressionModel;
        switch (
          (i = (o = t == null ? void 0 : t.formula) == null
              ? void 0
              : o.geometry) == null
            ? void 0
            : i.valueType
        ) {
          case __dcg_shared_module_exports__["Point"]:
            return { type: "single", objectType: "point", model: t };
          case __dcg_shared_module_exports__["AngleMarker"]:
          case __dcg_shared_module_exports__["DirectedAngleMarker"]:
            return { type: "single", objectType: "angle", model: t };
          case __dcg_shared_module_exports__["Segment"]:
            return { type: "single", objectType: "segment", model: t };
          default:
            return { type: "multiple", objectType: "point" };
        }
      }
      allowPointCoordinates() {
        return !!this.controller.getGraphSettings().showXAxis;
      }
      getLabelMode() {
        var t;
        return this.getSelectionLabelInfo().type === "multiple"
          ? this.sectionValues().pointLabels
          : (t = this.singleItemState) == null
          ? void 0
          : t.mode;
      }
      getSegmentedLabels() {
        switch (this.getSelectionLabelInfo().objectType) {
          case "point":
            return { text: "A,B,C", measurement: "(x,y)" };
          case "angle":
            return { text: "Text", measurement: "Measure" };
          case "segment":
            return { text: "Text", measurement: "Length" };
        }
      }
      getSegmentedControlConfig() {
        let e = () =>
          this.getSelectionLabelInfo().objectType === "point" &&
            this.allowPointCoordinates()
            ? "dcg-segmented-control-btn--point"
            : "";
        return [{
          key: "text",
          label: () => this.getSegmentedLabels().text,
          selected: () => this.getLabelMode() === "text",
          onSelect: (t) => {
            this.lastSelectionDevice = t, this.onSelectTextLabel();
          },
          class: e,
        }, {
          key: "measurements",
          label: () => this.getSegmentedLabels().measurement,
          selected: () => this.getLabelMode() === "measurement",
          onSelect: (t) => {
            this.lastSelectionDevice = t, this.onSelectMeasurementLabel();
          },
          class: e,
        }];
      }
      onSelectTextLabel() {
        var t;
        let e = this.getSelectionLabelInfo();
        if (e.type === "multiple") {
          this.controller.dispatch({
            type: "set-label-state-for-selected-points",
            state: this.getLabelMode() === "text" ? "none" : "auto",
          });
          return;
        }
        if (!this.singleItemState) {
          throw new Error("Expected singleItemState to be defined");
        }
        this.getLabelMode() === "text"
          ? (this.singleItemState.mode = "none",
            this.controller.dispatch({
              type: "set-item-showlabel",
              id: e.model.id,
              showLabel: false,
            }))
          : (this.singleItemState.mode = "text",
            ((t = e.model.formula.geometry) == null ? void 0 : t.valueType) ===
                __dcg_shared_module_exports__["Point"]
              ? this.controller.dispatch({
                type: "set-label-state-for-selected-points",
                state: "auto",
              })
              : this.controller.dispatch({
                type: "set-item-showlabel",
                id: e.model.id,
                showLabel: false,
              }));
      }
      onSelectMeasurementLabel() {
        let e = this.getSelectionLabelInfo();
        if (e.type === "multiple") {
          this.controller.dispatch({
            type: "set-label-state-for-selected-points",
            state: this.getLabelMode() === "measurement"
              ? "none"
              : "measurement",
          });
          return;
        }
        if (!this.singleItemState) {
          throw new Error("Expected singleItemState to be defined");
        }
        this.getLabelMode() === "measurement"
          ? (this.singleItemState.mode = "none",
            this.controller.dispatch({
              type: "set-item-showlabel",
              id: e.model.id,
              showLabel: false,
            }))
          : (this.singleItemState.mode = "measurement",
            this.controller.dispatch({
              type: "set-item-showlabel",
              id: e.model.id,
              showLabel: true,
            }),
            this.controller.dispatch({
              type: "set-item-label",
              id: e.model.id,
              label: "",
            }));
      }
      template() {
        return dn.createElement(
          "div",
          {
            class: () => ({
              "dcg-generic-options-menu": true,
              "dcg-options-menu": true,
              "dcg-multi-select-label-menu": true,
            }),
            role: dn.const("region"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-narration-label-menu",
              ),
          },
          dn.createElement(
            "div",
            { class: dn.const("dcg-options-menu-section") },
            Tne("type", () => this.getSelectionLabelInfo())({
              multiple: () =>
                dn.createElement(
                  "div",
                  null,
                  Ene(this.bindFn(this.allowPointCoordinates), {
                    true: () =>
                      dn.createElement("div", {
                        class: dn.const(
                          "dcg-multi-select-menu_margin-top-section",
                        ),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-button-geometry-label-points",
                        ), dn.const(":")),
                    false: () =>
                      dn.createElement(mt, {
                        checked: () => this.getLabelMode() === "text",
                        onChange: () => this.onSelectTextLabel(),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-button-geometry-label-points",
                        )),
                  }),
                ),
              single: (e) =>
                dn.createElement(
                  "div",
                  {
                    class: dn.const(
                      "dcg-multi-select-menu_margin-top-section",
                    ),
                  },
                  dn.createElement(Hg, {
                    controller: this.props.controller,
                    model: () => e().model,
                    forceEnabled: this.const(true),
                    displayComputedValue: () => {
                      if (this.getLabelMode() !== "measurement") return;
                      let t = this.controller.getGrapher2d(),
                        o = t.getGraphSketch(e().model.id);
                      return o && o.labels.length === 1
                        ? iP(o.labels[0], t.getProjection()).text
                        : "";
                    },
                    selectInputOnMount: () =>
                      this.lastSelectionDevice !== "keyboard",
                    suppressInput: () => this.getLabelMode() === "none",
                    manageInputFocus: this.const(
                      rt({
                        controller: this.controller,
                        location: {
                          type: "multi-select-label-menu-label-input",
                        },
                      }),
                    ),
                  }),
                ),
            }),
            dn.createElement(Sne, {
              predicate: () =>
                this.getSelectionLabelInfo().objectType !== "point" ||
                this.allowPointCoordinates(),
            }, () =>
              dn.createElement(vo, {
                ariaGroupLabel: () =>
                  this.controller.s(
                    "graphing-calculator-narration-geometry-label-options",
                  ),
                staticConfig: this.bindFn(this.getSegmentedControlConfig),
              })),
          ),
        );
      }
    };
  var ao = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Fi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { Input: Dne, If: uV } = Fi.Components,
    rk = class extends Fi.Class {
      constructor() {
        super(...arguments),
          this.controller = this.props.controller(),
          this.newFolderTitle = "";
      }
      init() {
        this.cacheFolderList();
      }
      willUpdate() {
        this.cacheFolderList();
      }
      template() {
        return Fi.createElement(
          uV,
          { predicate: () => this.getMovableItems().length > 0 },
          () =>
            Fi.createElement(
              "div",
              { class: Fi.const("dcg-move-to-expression-list") },
              Fi.createElement(
                "div",
                {
                  class: Fi.const("dcg-move-to-expression-list-title"),
                  role: () =>
                    this.canMoveToExpressionList() ? "button" : void 0,
                  tabIndex: () => this.canMoveToExpressionList() ? 0 : void 0,
                  onTap: this.bindFn(this.moveToExpressionList),
                },
                Fi.createElement(uV, {
                  predicate: () => this.canMoveToExpressionList(),
                }, () =>
                  Fi.createElement("i", {
                    class: Fi.const("dcg-icon-insert"),
                    "aria-hidden": Fi.const("true"),
                  })),
                Fi.createElement(
                  "span",
                  null,
                  this.bindFn(this.getMoveMessage),
                ),
              ),
              Fi.createElement(uV, {
                predicate: () => !this.canMoveToExpressionList(),
              }, () =>
                Fi.createElement(
                  "div",
                  { class: Fi.const("dcg-move-to-expression-list-flex") },
                  Fi.createElement(Dne, {
                    "aria-label": this.bindFn(this.getMoveMessage),
                    value: () => this.newFolderTitle,
                    onInput: (e) => {
                      this.newFolderTitle = e, this.update();
                    },
                    placeholder: () =>
                      this.controller.s(
                        "graphing-calculator-label-geometry-move-to-folder-placeholder",
                      ),
                    didMount: (e) => {
                      e.onkeydown = function (t) {
                        let o = ke(t);
                        (o === "Backspace" || o === "Del") &&
                          t.stopPropagation();
                      };
                    },
                    onEnterPressed: this.bindFn(this.onEnterPressed),
                  }),
                  Fi.createElement("div", {
                    class: () => ({
                      "dcg-btn-purple": true,
                      "dcg-disabled": !this.newFolderTitle,
                    }),
                    role: Fi.const("button"),
                    tabIndex: () => this.newFolderTitle ? 0 : -1,
                    onTap: this.bindFn(this.createNewFolder),
                  }, () =>
                    this.controller.s(
                      "graphing-calculator-button-move-to-expression-list-action",
                    )),
                )),
            ),
        );
      }
      getMovableItems() {
        return this.controller.getAllSelectedItems().filter((t) =>
          !this.controller.isItemReadonly(t.id)
        );
      }
      canMoveToExpressionList() {
        var n, a;
        let e = this.getMovableItems(), [t] = e;
        if (
          !(e.length === 1 && t.type !== "folder" &&
            t.folderId === __dcg_shared_module_exports__["xd"])
        ) return false;
        if (
          t.type !== "expression" ||
          ((a = (n = t.formula.geometry) == null ? void 0 : n.call) ==
                null
              ? void 0
              : a.symbol) !== "apply"
        ) return true;
        let i = t.formula.geometry.call.parents[0];
        return i.type === "arbitrary-expression"
          ? true
          : this.controller.getItemsByIdentifier(
            __dcg_shared_module_exports__["Cc"](i),
          ).every((s) => s.folderId !== __dcg_shared_module_exports__["xd"]);
      }
      getMoveMessage() {
        return `${
          this.controller.s(
            "graphing-calculator-text-geometry-move-to-expression-list-message",
          )
        }${this.canMoveToExpressionList() ? "" : ":"}`;
      }
      onEnterPressed() {
        let e = this.folderList.find((t) => t.title === this.newFolderTitle);
        e ? this.chooseFolder(e.id) : this.createNewFolder();
      }
      chooseFolder(e) {
        this.controller.dispatch({
          type: "update-all-selected-items",
          update: { prop: "folderId", value: e },
        });
      }
      createNewFolder() {
        this.newFolderTitle &&
          this.controller.dispatch({
            type: "update-all-selected-items",
            update: {
              prop: "folderId",
              value: this.newFolderTitle,
              createFolder: true,
            },
          });
      }
      cacheFolderList() {
        this.folderList = this.controller.getAllItemModels().filter((e) =>
          e.type === "folder" && !this.controller.isGeoFolder(e)
        );
      }
      moveToExpressionList() {
        this.canMoveToExpressionList() &&
          this.controller.dispatch({
            type: "move-selected-item-to-expression-list",
          });
      }
    };
  var { If: Uv } = ao.Components,
    ok = class extends ao.Class {
      constructor() {
        super(...arguments), this.controller = this.props.controller();
      }
      sectionValues() {
        return this.props.sectionValues();
      }
      template() {
        return ao.createElement(
          "div",
          {
            class: () => ({
              "dcg-generic-options-menu": true,
              "dcg-options-menu": true,
              "dcg-multi-select-options-menu": true,
            }),
            role: ao.const("region"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-narration-options-menu",
              ),
          },
          ao.createElement(
            "div",
            { class: ao.const("dcg-options-menu-section") },
            ao.createElement(Uv, {
              predicate: () => this.hasSelectedAndEditableItems(),
            }, () =>
              ao.createElement(
                "div",
                {
                  role: ao.const("button"),
                  handleEvent: ao.const("true"),
                  class: ao.const("dcg-delete-btn dcg-btn-purple"),
                  tabIndex: ao.const("0"),
                  onTap: this.bindFn(this.deleteSelected),
                },
                ao.createElement("i", {
                  class: ao.const("dcg-icon-trashcan"),
                  "aria-hidden": ao.const("true"),
                }),
                ao.createElement(
                  "span",
                  null,
                  () => this.getDeleteItemString(),
                ),
              )),
            ao.createElement(Uv, {
              predicate: () =>
                this.sectionValues().draggableFreePoint !== void 0,
            }, () =>
              ao.createElement(
                "div",
                { class: ao.const("dcg-checkbox-section") },
                ao.createElement(mt, {
                  checked: () => !!this.sectionValues().draggableFreePoint,
                  onChange: this.bindFn(this.onDraggableFreePointChanged),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-button-draggable-points",
                  )),
              )),
            ao.createElement(Uv, {
              predicate: () =>
                this.sectionValues().graphInteractionDisabled !==
                  void 0 &&
                this.props.controller().shouldShowAuthorFeatures(),
            }, () =>
              ao.createElement(
                "div",
                {
                  class: ao.const(
                    "dcg-checkbox-section dcg-disable-graph-interactions",
                  ),
                },
                ao.createElement(
                  mt,
                  {
                    checked: () =>
                      !!this.sectionValues().graphInteractionDisabled,
                    onChange: () => this.toggleGraphInteractionsDisabled(),
                  },
                  () =>
                    this.controller.s(
                      "graphing-calculator-label-disable-graph-interactions",
                    ),
                ),
              )),
            ao.createElement(
              Uv,
              {
                predicate: () => this.sectionValues().arrowMode !== void 0,
              },
              () =>
                ao.createElement("div", null, () =>
                  this.controller.s(
                    "graphing-calculator-text-geometry-arrow-mode",
                    { mode: this.getArrowModeDisplayName() },
                  )),
            ),
            ao.createElement(
              Uv,
              {
                predicate: () =>
                  this.controller.getGraphSettings().config.expressions,
              },
              () =>
                ao.createElement(rk, {
                  controller: this.props.controller,
                }),
            ),
          ),
        );
      }
      getSelectedAndEditableItems() {
        return this.controller.getAllSelectedItems().filter((t) =>
          !this.controller.isItemReadonly(t.id)
        );
      }
      hasSelectedAndEditableItems() {
        return this.getSelectedAndEditableItems().length > 0;
      }
      toggleGraphInteractionsDisabled() {
        this.controller.dispatch({
          type: "update-all-selected-items",
          update: {
            prop: "disableGraphInteractions",
            value: !this.sectionValues().graphInteractionDisabled,
          },
        });
      }
      onDraggableFreePointChanged(e) {
        this.controller.dispatch({
          type: "update-all-selected-items",
          update: { prop: "dragMode", value: e ? "XY" : "NONE" },
        });
      }
      getArrowModeDisplayName() {
        let e = this.sectionValues().arrowMode;
        if (!e) return "";
        switch (e) {
          case "NONE":
            return this.controller.s(
              "graphing-calculator-text-arrow-mode-none",
            );
          case "DEFAULT":
            return this.controller.s(
              "graphing-calculator-text-arrow-mode-default",
            );
          case "POSITIVE":
            return this.controller.s(
              "graphing-calculator-text-arrow-mode-positive",
            );
          case "BOTH":
            return this.controller.s(
              "graphing-calculator-text-arrow-mode-both",
            );
        }
      }
      getSelectedCount() {
        return this.controller.getAllSelectedItems().length;
      }
      getDeleteItemString() {
        let e = this.getSelectedCount(),
          t = this.getSelectedAndEditableItems().length;
        return e - t > 0
          ? this.controller.s(
            "graphing-calculator-text-geometry-delete-selected-unlocked-objects",
            { count: __dcg_shared_module_exports__["ra"](t) },
          )
          : this.controller.s(
            "graphing-calculator-text-geometry-delete-selected-objects",
            { count: __dcg_shared_module_exports__["ra"](t) },
          );
      }
      deleteSelected() {
        this.controller.dispatch({ type: "delete-all-selected-items" });
      }
    };
  var us = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: kne } = us.Components,
    ik = class extends us.Class {
      init() {
        this.controller = this.props.controller();
      }
      sectionValues() {
        return this.props.sectionValues();
      }
      getSelectedColor() {
        let e = this.sectionValues().color;
        return !(e != null && e.isUnique) ||
            !(e != null && e.selectedColor)
          ? ""
          : e.selectedColor;
      }
      template() {
        return us.createElement(
          "div",
          {
            class: () => ({
              "dcg-generic-options-menu": true,
              "dcg-options-menu": true,
              "dcg-multi-select-style-menu": true,
            }),
            role: us.const("region"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-narration-style-menu",
              ),
          },
          us.createElement(
            "div",
            { class: us.const("dcg-options-menu-section") },
            us.createElement(
              "div",
              { class: us.const("dcg-multi-select-color-picker") },
              us.createElement(ey, {
                controller: this.props.controller,
                colorLatex: () => {
                  var e, t;
                  return (t = (e = this.sectionValues().color) == null
                      ? void 0
                      : e.colorLatex) != null
                    ? t
                    : "";
                },
                selectedColor: this.bindFn(this.getSelectedColor),
                onColorSelected: this.bindFn(this.onColorSelected),
                onCustomColorSelected: this.bindFn(
                  this.onCustomColorSelected,
                ),
                customColorVisibility: this.bindFn(
                  this.getCustomColorVisibility,
                ),
              }),
            ),
            us.createElement(
              kne,
              {
                predicate: () => this.sectionValues().arrowMode !== void 0,
              },
              () =>
                us.createElement("div", null, () =>
                  this.controller.s(
                    "graphing-calculator-text-geometry-arrow-mode",
                    { mode: this.getArrowModeDisplayName() },
                  )),
            ),
          ),
        );
      }
      getArrowModeDisplayName() {
        let e = this.sectionValues().arrowMode;
        if (!e) return "";
        switch (e) {
          case "NONE":
            return this.controller.s(
              "graphing-calculator-text-arrow-mode-none",
            );
          case "DEFAULT":
            return this.controller.s(
              "graphing-calculator-text-arrow-mode-default",
            );
          case "POSITIVE":
            return this.controller.s(
              "graphing-calculator-text-arrow-mode-positive",
            );
          case "BOTH":
            return this.controller.s(
              "graphing-calculator-text-arrow-mode-both",
            );
        }
      }
      onColorSelected(e) {
        this.controller.dispatch({
          type: "update-all-selected-items",
          update: { prop: "color", value: e },
        });
      }
      getCustomColorVisibility() {
        return this.controller.getGraphSettings().hideCustomColors
          ? this.controller.shouldShowAuthorFeatures() ? "suppressed" : "hidden"
          : "visible";
      }
      onCustomColorSelected(e) {
        this.controller.dispatch({
          type: "update-all-selected-items",
          update: { prop: "colorLatex", value: e },
        });
      }
    };
  var { If: ch, Switch: f6 } = Et.Components,
    nk = class extends Et.Class {
      init() {
        this.controller = this.props.controller(),
          this.cacheSectionValues(),
          this.cacheExistingTransformations();
      }
      willUpdate() {
        this.cacheSectionValues(),
          this.cacheExistingTransformations(),
          this.cachedConstructFromSelectionInfo = this
            .computeConstructFromSelectionInfo();
      }
      template() {
        return Et.createElement(
          "div",
          {
            class: Et.const(
              "dcg-multi-select-header dcg-animate-in-after-initial-load",
            ),
            onKeyDown: this.bindFn(this.handleKeydown),
            role: Et.const("toolbar"),
            "aria-label": this.bindFn(this.getSelectedCountString),
          },
          Et.createElement(f6, {
            key: this.bindFn(this.getSelectedItemsKey),
          }, () =>
            Et.createElement(ch, {
              predicate: () =>
                this.isButtonVisible("multi-select-show-hide-icon"),
            }, () =>
              Et.createElement(
                "div",
                {
                  class: () => ({
                    "dcg-btn-outline": true,
                    "dcg-show-hide-btn": true,
                    "dcg-any-visible-objects": this.anyVisible(),
                  }),
                  handleEvent: Et.const("true"),
                  tabIndex: Et.const("0"),
                  role: Et.const("button"),
                  onTap: this.bindFn(this.toggleItemsVisible),
                  manageFocus: this.const(
                    rt({
                      controller: this.controller,
                      location: { type: "multi-select-show-hide-icon" },
                    }),
                  ),
                },
                Et.createElement(
                  "div",
                  { "aria-hidden": () => !this.anyVisible() },
                  () =>
                    this.controller.s(
                      "graphing-calculator-text-geometry-hide-objects",
                    ),
                  () => ` (${this.getSelectedCount()})`,
                ),
                Et.createElement(
                  "div",
                  { "aria-hidden": this.bindFn(this.anyVisible) },
                  () =>
                    this.controller.s(
                      "graphing-calculator-text-geometry-show-objects",
                    ),
                  () => ` (${this.getSelectedCount()})`,
                ),
              ))),
          Et.createElement(
            "div",
            {
              class: () => ({
                "dcg-style-button": true,
                "dcg-toolbar-dropdown-button": true,
                "dcg-menu-open": this.isStyleMenuOpen(),
              }),
              handleEvent: Et.const("true"),
              tabIndex: Et.const("-1"),
              role: Et.const("button"),
              "aria-label": () =>
                this.controller.s(
                  "graphing-calculator-narration-geometry-style-menu",
                ),
              "aria-expanded": this.bindFn(this.isStyleMenuOpen),
              "dcg-open-menu-guid": () => hV(),
              onTap: this.bindFn(this.toggleStyleMenu),
              manageFocus: this.const(
                rt({
                  controller: this.controller,
                  location: { type: "multi-select-style-icon" },
                }),
              ),
            },
            Et.createElement(Pp, {
              color: () => this.getSelectedColor(),
              invertSwatches: () => this.controller.invertSwatches(),
            }),
            Et.createElement(tm, {
              menuName: () =>
                this.controller.s(
                  "graphing-calculator-narration-geometry-style-menu",
                ),
              ariaExpanded: this.bindFn(this.isStyleMenuOpen),
              controller: this.const(this.controller),
              openDropDown: () => {},
            }),
          ),
          Et.createElement(ch, {
            predicate: () => this.isButtonVisible("multi-select-label-icon"),
          }, () =>
            Et.createElement(
              "div",
              {
                class: () => ({
                  "dcg-label-button": true,
                  "dcg-toolbar-dropdown-button": true,
                  "dcg-menu-open": this.isLabelMenuOpen(),
                }),
                handleEvent: Et.const("true"),
                tabIndex: Et.const("-1"),
                role: Et.const("button"),
                "aria-label": () =>
                  this.controller.s(
                    "graphing-calculator-narration-label-menu",
                  ),
                "aria-expanded": this.bindFn(this.isLabelMenuOpen),
                "dcg-open-menu-guid": () => gV(),
                onTap: this.bindFn(this.toggleLabelMenu),
                manageFocus: this.const(
                  rt({
                    controller: this.controller,
                    location: { type: "multi-select-label-icon" },
                  }),
                ),
              },
              Et.createElement("div", {
                class: Et.const("dcg-label-button-icon"),
              }, Et.const("A")),
              Et.createElement(tm, {
                menuName: () =>
                  this.controller.s(
                    "graphing-calculator-narration-label-menu",
                  ),
                ariaExpanded: this.bindFn(this.isLabelMenuOpen),
                controller: this.const(this.controller),
                openDropDown: () => {},
              }),
            )),
          Et.createElement(ch, {
            predicate: () =>
              this.isButtonVisible("multi-select-construct-icon"),
          }, () =>
            Et.createElement(
              "div",
              {
                class: () => ({
                  "dcg-construct-button": true,
                  "dcg-toolbar-dropdown-button": true,
                  "dcg-menu-open": this.isConstructMenuOpen(),
                }),
                handleEvent: Et.const("true"),
                tabIndex: Et.const("-1"),
                role: Et.const("button"),
                "aria-label": () =>
                  this.controller.s(
                    "graphing-calculator-narration-geometry-construct-menu",
                  ),
                "aria-expanded": this.bindFn(this.isConstructMenuOpen),
                "dcg-open-menu-guid": () => zv(),
                onTap: this.bindFn(this.toggleConstructMenu),
                manageFocus: this.const(
                  rt({
                    controller: this.controller,
                    location: { type: "multi-select-construct-icon" },
                  }),
                ),
              },
              Et.createElement(XD, null),
              Et.createElement(tm, {
                menuName: () =>
                  this.controller.s(
                    "graphing-calculator-narration-geometry-construct-menu",
                  ),
                ariaExpanded: this.bindFn(this.isConstructMenuOpen),
                controller: this.const(this.controller),
                openDropDown: () => {},
              }),
            )),
          Et.createElement(ch, {
            predicate: () => this.isButtonVisible("multi-select-more-icon"),
          }, () =>
            Et.createElement(
              Le,
              { tooltip: this.bindFn(this.getMoreString) },
              Et.createElement("div", {
                "aria-label": this.bindFn(this.getMoreString),
                role: Et.const("button"),
                tabIndex: Et.const("-1"),
                handleEvent: Et.const("true"),
                "aria-expanded": this.bindFn(this.isMoreMenuOpen),
                class: () => ({
                  "dcg-multi-select-icon-button dcg-more-options dcg-toolbar-dropdown-button":
                    true,
                  "dcg-menu-open": this.isMoreMenuOpen(),
                }),
                "dcg-open-menu-guid": () => rm(),
                manageFocus: this.const(
                  rt({
                    controller: this.controller,
                    location: { type: "multi-select-more-icon" },
                  }),
                ),
                onTap: this.bindFn(this.toggleMoreMenu),
              }, Et.createElement(by, null)),
            )),
          Et.createElement(ch, {
            predicate: this.bindFn(this.isLabelMenuOpen),
          }, () =>
            Et.createElement(f6, {
              key: () =>
                Object.keys(this.controller.getSelectedExpressionIds())
                  .join(":"),
            }, () =>
              Et.createElement(
                ps,
                {
                  controller: this.props.controller,
                  shouldHandleTabAndEscape: this.const(true),
                  menuType: this.const("multi-select-label"),
                  menuButtonFocusLocation: this.const({
                    type: "multi-select-label-icon",
                  }),
                  rootElSelector: this.const(".dcg-multi-select-header"),
                },
                Et.createElement(tk, {
                  controller: this.props.controller,
                  sectionValues: () => this.sectionValues,
                }),
              ))),
          Et.createElement(ch, {
            predicate: this.bindFn(this.isStyleMenuOpen),
          }, () =>
            Et.createElement(
              ps,
              {
                controller: this.props.controller,
                shouldHandleTabAndEscape: this.const(true),
                menuType: this.const("multi-select-style"),
                menuButtonFocusLocation: this.const({
                  type: "multi-select-style-icon",
                }),
                rootElSelector: this.const(".dcg-multi-select-header"),
              },
              Et.createElement(ik, {
                controller: this.props.controller,
                sectionValues: () => this.sectionValues,
              }),
            )),
          Et.createElement(ch, {
            predicate: this.bindFn(this.isConstructMenuOpen),
          }, () =>
            Et.createElement(
              ps,
              {
                controller: this.props.controller,
                shouldHandleTabAndEscape: this.const(true),
                menuType: this.const("multi-select-construct"),
                menuButtonFocusLocation: this.const({
                  type: "multi-select-construct-icon",
                }),
                rootElSelector: this.const(".dcg-multi-select-header"),
              },
              Et.createElement(ek, {
                controller: this.props.controller,
                constructFromSelectionInfo: () =>
                  this.cachedConstructFromSelectionInfo,
                existingTransformations: () =>
                  this.cachedExistingTransformations,
              }),
            )),
          Et.createElement(ch, {
            predicate: this.bindFn(this.isMoreMenuOpen),
          }, () =>
            Et.createElement(
              ps,
              {
                controller: this.props.controller,
                shouldHandleTabAndEscape: this.const(true),
                menuType: this.const("multi-select-more"),
                menuButtonFocusLocation: this.const({
                  type: "multi-select-more-icon",
                }),
                rootElSelector: this.const(".dcg-multi-select-header"),
              },
              Et.createElement(ok, {
                controller: this.props.controller,
                sectionValues: () => this.sectionValues,
              }),
            )),
        );
      }
      getFocusOrder() {
        return [
          "multi-select-show-hide-icon",
          "multi-select-style-icon",
          "multi-select-label-icon",
          "multi-select-construct-icon",
          "multi-select-more-icon",
        ].filter((t) => this.isButtonVisible(t)).map((t) => ({
          type: t,
        }));
      }
      isButtonVisible(e) {
        switch (e) {
          case "multi-select-show-hide-icon":
            return this.hasSelectedAndEditableItems();
          case "multi-select-style-icon":
            return true;
          case "multi-select-label-icon":
            return this.sectionValues.pointLabels !== void 0 ||
              this.sectionValues.singleLabelableExpressionModel !==
                void 0;
          case "multi-select-construct-icon":
            return this.isSomeRelevantToolEnabled();
          case "multi-select-more-icon":
            return this.controller.shouldShowAuthorFeatures() ||
              this.hasSelectedAndEditableItems() ||
              this.sectionValues.draggableFreePoint !== void 0;
          default:
            return false;
        }
      }
      cacheSectionValues() {
        this.sectionValues = this.computeSectionValues();
      }
      computeSectionValues() {
        var n;
        let e = {
            pointLabels: [],
            singleLabelableExpressionModel: [],
            draggableFreePoint: [],
            arrowMode: [],
            graphInteractionDisabled: [],
            color: [],
          },
          t = this.controller.getAllSelectedItems();
        for (let a of t) {
          if (
            e.graphInteractionDisabled.push(Ds(a)), a.type !== "expression"
          ) continue;
          e.color.push({
            selectedColor: Fu(a),
            colorLatex: a.colorLatex,
          });
          let s = (n = a.formula.geometry) == null ? void 0 : n.valueType;
          switch (
            __dcg_shared_module_exports__["isList"](s) &&
            (s = __dcg_shared_module_exports__["elementType"](s)), s
          ) {
            case __dcg_shared_module_exports__["Point"]:
              a.showLabel
                ? e.pointLabels.push(a.label ? "text" : "measurement")
                : e.pointLabels.push("none"),
                e.singleLabelableExpressionModel.push(a),
                a.formula.move_strategy &&
                e.draggableFreePoint.push(a.dragMode !== "NONE");
              break;
            case __dcg_shared_module_exports__["Polygon"]:
              break;
            case __dcg_shared_module_exports__["Arc"]:
              e.arrowMode.push(a.arrowMode);
              break;
            case __dcg_shared_module_exports__["Circle"]:
              break;
            case __dcg_shared_module_exports__["Line"]:
              break;
            case __dcg_shared_module_exports__["Ray"]:
              break;
            case __dcg_shared_module_exports__["Vector"]:
              break;
            case __dcg_shared_module_exports__["Segment"]:
              e.singleLabelableExpressionModel.push(a),
                e.arrowMode.push(a.arrowMode);
              break;
            case __dcg_shared_module_exports__["AngleMarker"]:
            case __dcg_shared_module_exports__["DirectedAngleMarker"]:
              e.singleLabelableExpressionModel.push(a);
              break;
            case __dcg_shared_module_exports__["Transformation"]:
              break;
            default:
          }
        }
        let o = {}, i = t.length;
        for (let a in e) {
          let s = a;
          switch (s) {
            case "singleLabelableExpressionModel":
              {
                let c = e[s];
                i === 1 && c.length === 1 && (o[s] = c[0]);
              }
              break;
            case "pointLabels":
              {
                let c = e[s];
                if (c.length > 0 && i > 1) {
                  let d = __dcg_shared_module_exports__["v"](c);
                  d.length === 1 ? o[s] = d[0] : o[s] = "none";
                }
              }
              break;
            case "draggableFreePoint":
              {
                let c = e[s];
                c.length > 0 &&
                  (o[s] = __dcg_shared_module_exports__["k"](c));
              }
              break;
            case "arrowMode":
              break;
            case "graphInteractionDisabled": {
              o[s] = e[s].every((c) => c);
              break;
            }
            case "color": {
              let c = e[s].map((p) => JSON.stringify(p)),
                d = new Set(c).size === 1;
              o[s] = { ...e[s][0], isUnique: d };
              break;
            }
            default:
              return s;
          }
        }
        return o;
      }
      cacheExistingTransformations() {
        this.cachedExistingTransformations = this
          .computeExistingTransformations();
      }
      computeConstructFromSelectionInfo() {
        let e = this.controller.getSelectedItem();
        if ((e == null ? void 0 : e.type) === "expression") {
          let t = e.formula.typed_constant_value;
          if (
            !t ||
            __dcg_shared_module_exports__["isTypeOrListOfType"](
              t.valueType,
              __dcg_shared_module_exports__["Point"],
            )
          ) return;
          let o = this.controller.getAllAvailableGeoTools(), i = [];
          for (let n of o) {
            let a = this.controller.getGeoModel().getTool(n);
            a instanceof Vr && a.getMatchingWorkflow([t]) && i.push(n);
          }
          return {
            type: "single-selection",
            selected: [{ referenceLatex: Bv(e), typedValue: t }],
            relevantTools: i,
          };
        }
      }
      computeExistingTransformations() {
        var t, o;
        let e = [];
        for (let i of this.controller.getAllItemModels()) {
          if (
            i.type !== "expression" ||
            !this.controller.isItemInGeoFolder(i.id)
          ) continue;
          let n = (t = i.formula.geometry) == null ? void 0 : t.call;
          if (
            !n || !__dcg_shared_module_exports__["Dc"](n.symbol) ||
            !n.parents.every((s, l) =>
              s.type !== "arbitrary-expression" ||
              (n.symbol === "rotate" || n.symbol === "dilate") && l === 1
            )
          ) continue;
          let a = (o = i.formula.typed_constant_value) == null
            ? void 0
            : o.valueType;
          a !== void 0 &&
            __dcg_shared_module_exports__["isTypeOrListOfType"](
              a,
              __dcg_shared_module_exports__["Transformation"],
            ) && e.push(i);
        }
        return e.reverse();
      }
      handleKeydown(e) {
        let t = ke(e);
        if (
          e.altKey || e.ctrlKey || e.metaKey || e.shiftKey ||
          t !== "Left" && t !== "Right" && t !== "Home" && t !== "End"
        ) return;
        let o = this.controller.getFocusLocation();
        if (!o) return;
        let i = __dcg_shared_module_exports__["w"](
          this.getFocusOrder(),
          o,
        );
        if (i === -1) return;
        e.preventDefault(), e.stopPropagation();
        let n = i;
        t === "Left"
          ? n = Math.max(0, i - 1)
          : t === "Right"
          ? n = Math.min(this.getFocusOrder().length - 1, i + 1)
          : t === "Home"
          ? n = 0
          : t === "End" && (n = this.getFocusOrder().length - 1),
          n !== i &&
          (this.controller.dispatch({ type: "close-item-settings-menu" }),
            this.controller.dispatch({
              type: "set-focus-location",
              location: this.getFocusOrder()[n],
            }));
      }
      getSelectedCountString() {
        return this.controller.getGrapherDimensions().width < 450
          ? ""
          : this.controller.s(
            "graphing-calculator-text-geometry-selected-objects",
            {
              count: __dcg_shared_module_exports__["ra"](
                this.getSelectedCount(),
              ),
            },
          );
      }
      getSelectedAndEditableItems() {
        return this.controller.getAllSelectedItems().filter((t) =>
          !this.controller.isItemReadonly(t.id)
        );
      }
      hasSelectedAndEditableItems() {
        return this.getSelectedAndEditableItems().length > 0;
      }
      isSomeRelevantToolEnabled() {
        var t, o;
        return [
          ...(o = (t = this.cachedConstructFromSelectionInfo) == null
              ? void 0
              : t.relevantTools) != null
            ? o
            : [],
          ...fy,
        ].some((i) => this.controller.isGeoToolVisible(i));
      }
      getMoreString() {
        return this.controller.s(
          "graphing-calculator-text-geometry-multi-select-more-dropdown",
        );
      }
      getSelectedItemsKey() {
        let e = this.controller.getAllSelectedItems();
        return __dcg_shared_module_exports__["m"](e, "id").join("-");
      }
      toggleItemsVisible() {
        this.anyVisible() ? this.hideSelected() : this.showSelected();
      }
      anyVisible() {
        let e = this.controller.getAllSelectedItems();
        return __dcg_shared_module_exports__["k"](e, (t) => !Hi(t));
      }
      isFolderMenuOpen() {
        return this.controller.isItemSettingsMenuOpen(_ne());
      }
      isMoreMenuOpen() {
        return this.controller.isItemSettingsMenuOpen(rm());
      }
      isConstructMenuOpen() {
        return this.controller.isItemSettingsMenuOpen(zv());
      }
      isStyleMenuOpen() {
        return this.controller.isItemSettingsMenuOpen(hV());
      }
      isLabelMenuOpen() {
        return this.controller.isItemSettingsMenuOpen(gV());
      }
      toggleMoreMenu() {
        this.controller.dispatch({
          type: "toggle-item-settings-menu",
          menu: {
            type: "multi-select-more",
            guid: rm(),
            focusFirstOption: true,
          },
        });
      }
      toggleConstructMenu() {
        this.controller.dispatch({
          type: "toggle-item-settings-menu",
          menu: {
            type: "multi-select-construct",
            guid: zv(),
            focusFirstOption: true,
          },
        });
      }
      toggleStyleMenu() {
        this.controller.dispatch({
          type: "toggle-item-settings-menu",
          menu: {
            type: "multi-select-style",
            guid: hV(),
            focusFirstOption: true,
          },
        });
      }
      toggleLabelMenu() {
        var t;
        let e = this.sectionValues.singleLabelableExpressionModel;
        !this.isLabelMenuOpen() && e && !ja(e) &&
        ((t = e.formula.geometry) == null ? void 0 : t.valueType) ===
          __dcg_shared_module_exports__["Point"] &&
        this.controller.dispatch({
          type: "set-label-state-for-selected-points",
          state: "auto",
        }),
          this.controller.dispatch({
            type: "toggle-item-settings-menu",
            menu: {
              type: "multi-select-label",
              guid: gV(),
              focusFirstOption: true,
            },
          }),
          this.isLabelMenuOpen() && e && e.label !== "" &&
          this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "multi-select-label-menu-label-input" },
          });
      }
      getSelectedCount() {
        return this.controller.getAllSelectedItems().length;
      }
      hideSelected() {
        this.controller.dispatch({
          type: "update-all-selected-items",
          update: { prop: "visible", value: false },
        });
      }
      showSelected() {
        this.controller.dispatch({
          type: "update-all-selected-items",
          update: { prop: "visible", value: true },
        });
      }
      getSelectedColor() {
        var o;
        let e = this.sectionValues.color,
          t = e &&
            ((o = this.controller.getAllColorAssignments().find((i) =>
                i.assignmentLatex === e.colorLatex
              )) == null
              ? void 0
              : o.id);
        if (t) {
          let i = this.controller.getColorById(t);
          return Array.isArray(i)
            ? { type: "color-array", value: i }
            : { type: "single-color", value: i };
        } else if (e != null && e.selectedColor) {
          return { type: "single-color", value: e.selectedColor };
        }
        return {
          type: "single-color",
          value: this.controller.getColors().GRAY,
        };
      }
    };
  function _ne() {
    return "**multi-select-folder**";
  }
  function rm() {
    return "**multi-select-more**";
  }
  function zv() {
    return "**multi-select-construct**";
  }
  function hV() {
    return "**multi-select-style**";
  }
  function gV() {
    return "**multi-select-label**";
  }
  qt();
  function wy(r) {
    let e = [[r.x0, r.y0], [r.x1, r.y1], [r.x2, r.y2]],
      [t, o] = __dcg_shared_module_exports__["arcCenter"](e),
      i = __dcg_shared_module_exports__["hypot"](r.x0 - t, r.y0 - o);
    return { x: t, y: o, radius: i };
  }
  function ak(r) {
    let e = [[r.x0, r.y0], [r.x1, r.y1], [r.x2, r.y2]],
      [t, o] = __dcg_shared_module_exports__["arcCenter"](e);
    return {
      startAngle: Math.atan2(r.y0 - o, r.x0 - t),
      deltaAngle: __dcg_shared_module_exports__["arcOmega"](e),
    };
  }
  var Ine = Math.hypot && Math.hypot(1 / 0, NaN) === 1 / 0;
  function b6(r) {
    return r === 1 / 0 || r === -1 / 0;
  }
  var dh = Ine ? Math.hypot : function (r, e) {
    if (b6(r) || b6(e)) return 1 / 0;
    if (isNaN(r) || isNaN(e)) return NaN;
    if (r === 0 && e === 0) return 0;
    if (Math.abs(r) > Math.abs(e)) {
      let t = e / r;
      return Math.abs(r) * Math.sqrt(t * t + 1);
    } else {
      let t = r / e;
      return Math.abs(e) * Math.sqrt(t * t + 1);
    }
  };
  var y6 = (r, e) => ({ x: r.x - e.x, y: r.y - e.y }),
    Ane = (r, e) => r.x * e.x + r.y * e.y;
  function lk(r, e) {
    return dh(r.x - e.x, r.y - e.y);
  }
  function x6(r, e) {
    let t = { x: r.x1, y: r.y1 },
      o = { x: r.x2, y: r.y2 },
      i = y6(e, t),
      n = y6(o, t),
      a = lk(t, o),
      s = a * a;
    return Ane(i, n) / s;
  }
  function fV(r) {
    return [{
      x1: r.left,
      y1: r.top,
      x2: r.left,
      y2: r.bottom,
      extendStart: false,
      extendEnd: false,
    }, {
      x1: r.left,
      y1: r.top,
      x2: r.right,
      y2: r.top,
      extendStart: false,
      extendEnd: false,
    }, {
      x1: r.right,
      y1: r.top,
      x2: r.right,
      y2: r.bottom,
      extendStart: false,
      extendEnd: false,
    }, {
      x1: r.left,
      y1: r.bottom,
      x2: r.right,
      y2: r.bottom,
      extendStart: false,
      extendEnd: false,
    }];
  }
  function Mne(r) {
    let { angle: e, width: t, height: o, center: i } = r,
      n = i.x,
      a = i.y,
      s = Math.cos(-e),
      l = Math.sin(-e),
      c = t / 2,
      d = o / 2,
      p = { x: n + s * -c - l * -d, y: a + l * -c + s * -d },
      h = { x: n + s * c - l * -d, y: a + l * c + s * -d },
      u = { x: n + s * c - l * d, y: a + l * c + s * d },
      f = { x: n + s * -c - l * d, y: a + l * -c + s * d };
    return [{
      x1: p.x,
      y1: p.y,
      x2: h.x,
      y2: h.y,
      extendStart: false,
      extendEnd: false,
    }, {
      x1: h.x,
      y1: h.y,
      x2: u.x,
      y2: u.y,
      extendStart: false,
      extendEnd: false,
    }, {
      x1: u.x,
      y1: u.y,
      x2: f.x,
      y2: f.y,
      extendStart: false,
      extendEnd: false,
    }, {
      x1: f.x,
      y1: f.y,
      x2: p.x,
      y2: p.y,
      extendStart: false,
      extendEnd: false,
    }];
  }
  function Gne(r, e) {
    let t = fV(r);
    return !!(ck(e, t[0]) || ck(e, t[1]) || ck(e, t[2]) || ck(e, t[3]));
  }
  function Lne(r, e) {
    let t = fV(r);
    return !!(Vd(e, t[0], false) || Vd(e, t[1], false) || Vd(e, t[2], false) ||
      Vd(e, t[3], false) || Vd(e, t[0], true) || Vd(e, t[1], true) ||
      Vd(e, t[2], true) || Vd(e, t[3], true));
  }
  function Pne(r, e) {
    let t = fV(r);
    return !!(ph(e, t[0], false) || ph(e, t[1], false) || ph(e, t[2], false) ||
      ph(e, t[3], false) || ph(e, t[0], true) || ph(e, t[1], true) ||
      ph(e, t[2], true) || ph(e, t[3], true));
  }
  function Vne(r, e) {
    return r.left <= e.left && r.right >= e.right && r.top <= e.top &&
      r.bottom >= e.bottom;
  }
  function One(r, e) {
    return r.left <= e.x && e.x <= r.right && r.top <= e.y &&
      e.y <= r.bottom;
  }
  function dk(r, e) {
    if (!e.extendStart) {
      let t = r.left <= e.x1 && e.x1 <= r.right,
        o = r.top <= e.y1 && e.y1 <= r.bottom;
      if (t && o) return true;
    }
    return Gne(r, e);
  }
  function T6(r, e) {
    let t = { x: e.x0, y: e.y0 };
    return !!(One(r, t) || Pne(r, e));
  }
  function D6(r, e) {
    let t = {
      left: e.x - e.radius,
      right: e.x + e.radius,
      top: e.y - e.radius,
      bottom: e.y + e.radius,
    };
    return !!(Vne(r, t) || Lne(r, e));
  }
  function Rne(r, e) {
    let t = r.x - e.center.x,
      o = r.y - e.center.y,
      i = Math.atan2(o, t),
      n = dh(t, o),
      a = { x: n * Math.cos(i + e.angle), y: n * Math.sin(i + e.angle) };
    return Math.abs(a.x) <= e.width / 2 && Math.abs(a.y) <= e.height / 2;
  }
  function k6(r, e) {
    if (e.length < 4) return false;
    let t = {
      x1: NaN,
      y1: NaN,
      x2: e[0],
      y2: e[1],
      extendStart: false,
      extendEnd: false,
    };
    for (let o = 2; o < e.length; o += 2) {
      if (
        t.x1 = t.x2, t.y1 = t.y2, t.x2 = e[o], t.y2 = e[o + 1], dk(r, t)
      ) return true;
    }
    return false;
  }
  function _6(r, e) {
    let t = Mne(e);
    for (let o of t) if (dk(r, o)) return true;
    return !!Rne({ x: r.left, y: r.top }, e);
  }
  function Fne(r, e, t) {
    let o = e.x1 - r.x,
      i = e.x2 - r.x,
      n = e.y1 - r.y,
      a = e.y2 - r.y,
      s = r.radius,
      l = i - o,
      c = a - n,
      d = l * l + c * c,
      p = o * a - i * n,
      h = Math.sqrt(s * s * d - p * p);
    if (h < 0) return;
    let u = c >= 0 ? 1 : -1, f = t ? -1 * u : 1 * u;
    return {
      x: r.x + (p * c + f * u * l * h) / d,
      y: r.y + (-p * l + f * Math.abs(c) * h) / d,
    };
  }
  function Nne(r, e) {
    let t = r.y2 - r.y1,
      o = r.x1 - r.x2,
      i = e.y2 - e.y1,
      n = e.x1 - e.x2,
      a = t * r.x1 + o * r.y1,
      s = i * e.x1 + n * e.y1,
      l = t * n - i * o;
    if (l !== 0) {
      return { x: (n * a - o * s) / l, y: (t * s - i * a) / l };
    }
  }
  function mV(r, e) {
    let t = x6(e, r);
    return !(isNaN(t) || t < 0 && !e.extendStart ||
      t > 1 && !e.extendEnd);
  }
  function Bne(r, e) {
    let { x: t, y: o } = wy(e),
      { startAngle: i, deltaAngle: n } = ak(e),
      a = Math.atan2(r.y - o, r.x - t);
    return __dcg_shared_module_exports__["Q"](a, i, n);
  }
  function Vd(r, e, t) {
    let o = Fne(r, e, t);
    if (o != null && mV(o, e)) return o;
  }
  function ph(r, e, t) {
    let o = Vd(wy(r), e, false) || v6, i = C6(t, S6(r, o), E6(e));
    if (
      i || (o = Vd(wy(r), e, true) || v6, i = C6(t, S6(r, o), E6(e))),
        i && Bne(o, r)
    ) return o;
  }
  var v6 = { x: NaN, y: NaN };
  function ck(r, e) {
    let t = Nne(r, e);
    if (t != null && mV(t, r) && mV(t, e)) return t;
  }
  function C6(r, e, t) {
    let o = e.x * t.y - e.y * t.x;
    return o > 0 && r || o < 0 && !r;
  }
  function S6(r, e) {
    let { x: t, y: o } = wy(r), { deltaAngle: i } = ak(r);
    return i > 0 ? { x: o - e.y, y: e.x - t } : { x: e.y - o, y: t - e.x };
  }
  function E6(r) {
    return { x: r.x2 - r.x1, y: r.y2 - r.y1 };
  }
  var om = class {
    constructor() {
      this.displayName =
        "graphing-calculator-text-geometry-tool-box-selection-display-name";
      this.toolType = "selection";
      this.icon = [{
        type: "stroked-path",
        color: "#aaa",
        path: [35, 35, 51, 35, 51, 51, 35, 51, 35, 35],
      }, {
        type: "filled-polygon",
        color: "#000",
        path: [
          50,
          50,
          63.5,
          62,
          58.25,
          62.75,
          62,
          72.5,
          59.75,
          74,
          55.25,
          64.25,
          50.75,
          68,
          50,
          50,
        ],
      }];
    }
    getNumberInputLatex() {
      return "";
    }
    clearTentativeOutputs() {}
    canNextInputBePoint() {
      return false;
    }
    getAllValidNextInputTypes() {
      return __dcg_shared_module_exports__["allValueTypes"].filter((e) =>
        this.isValidNextInputType(e)
      );
    }
    isValidNextInputType(e) {
      return e !== __dcg_shared_module_exports__["Transformation"];
    }
    getNonPointInputType() {}
    getHint() {
      return "";
    }
    getExpressionEditHint(e) {
      return this.getHint();
    }
    onNumberInput(e) {}
    onMove(e) {
      return true;
    }
    onFocus(e) {}
    tryCommitResults() {
      return { committed: void 0 };
    }
    shouldUseJitEdges() {
      return false;
    }
    shouldHighlightRelevantObjects() {
      return false;
    }
  };
  function I6(r, e) {
    return r === void 0
      ? e === void 0
      : !(e === void 0 || r.calcId !== e.calcId ||
        r.listIndex !== e.listIndex || r.polygonEdge !== e.polygonEdge);
  }
  var pk = class {
    constructor(e) {
      this.poiController = e,
        this.controller = e.controller,
        this.grapher = e.manager;
    }
    getKeyboardAttention() {
      return this.objectUnderAttention;
    }
    setKeyboardAttention(e) {
      this.objectUnderAttention = e;
    }
    findNonGeometryTabTargetsInGraph() {
      let e = this.controller.getGrapher3d();
      if (e) return e.getOrderedTabTargets();
      let t = this.grapher.imageLayer.getOrderedTabTargets(),
        o = this.grapher.clickableObjectsLayer.getOrderedTabTargets(),
        i = this.grapher.movablePointsLayer.getOrderedTabTargets();
      return t.concat(o).concat(i);
    }
    findTabbableObjectsForCurrentTool(e) {
      let t = e == null ? void 0 : e.calcId, o = {};
      if (this.controller.isGeometry()) {
        let d = this.controller.getGeoModel();
        d.getAllChoosableDefsUnordered(
          { mode: "tab" },
          d.getCurrentTool(),
        ).forEach((h) => {
          var f;
          o[h.calcId] || (o[h.calcId] = []);
          let u = {
            calcId: h.calcId,
            listIndex: h.listIndex,
            polygonEdge: (f = h.polygonEdgeInfo) == null
              ? void 0
              : f.edgeNumber,
            geoDef: { ...h },
          };
          o[h.calcId].push(u);
        });
      }
      let i = this.controller.getGeoModel().getCurrentTool();
      (!this.controller.isGeometry() ||
        i.isValidNextInputType(__dcg_shared_module_exports__["Any"])) &&
        this.findNonGeometryTabTargetsInGraph().filter((p) =>
          !(i instanceof om && this.controller.isClickableId(p.calcId))
        ).forEach((p) => {
          var u;
          let h = (u = p.listIndex) != null ? u : 0;
          if (!o[p.calcId]) o[p.calcId] = [];
          else if (
            h &&
            !(!this.controller.isGeometry() ||
              this.controller.canExpandListForItem(p.calcId))
          ) return;
          o[p.calcId][h]
            ? o[p.calcId][h].description = p.description
            : o[p.calcId].push(p);
        });
      let n = [],
        a = -1,
        s = false,
        l = this.controller.getGrapher3d(),
        c = l ? l.getTabOrder() : this.grapher.getTabOrder();
      for (let d of c) {
        d === t && (a = n.length);
        let p = o[d];
        if (p) {
          p.sort((h, u) =>
            h.listIndex !== u.listIndex
              ? h.listIndex === void 0
                ? -1
                : u.listIndex === void 0
                ? 1
                : h.listIndex - u.listIndex
              : h.polygonEdge !== u.polygonEdge
              ? h.polygonEdge === void 0
                ? -1
                : u.polygonEdge === void 0
                ? 1
                : h.polygonEdge - u.polygonEdge
              : 0
          );
          for (let h of p) {
            d === t && (s || (a = n.length), I6(h, e) && (s = true)), n.push(h);
          }
        }
      }
      return { targets: n, currentTabIndex: a, currentIsTabbable: s };
    }
    findNextObjFromKeyboard(e, t) {
      let { targets: o, currentIsTabbable: i, currentTabIndex: n } = this
        .findTabbableObjectsForCurrentTool(t);
      if (!o.length) return;
      if (n === -1) {
        return e === "next"
          ? { wrapped: false, target: o[0] }
          : { wrapped: false, target: o[o.length - 1] };
      }
      let a = false, s = n;
      return e === "prev" ? s -= 1 : i && (s += 1),
        s === -1
          ? (a = true, s = o.length - 1)
          : s >= o.length && (a = true, s = 0),
        { wrapped: a, target: o[s] };
    }
    focusNextObjFromKeyboard(e = {}) {
      let t = {
          allowWrapping: true,
          selectNonClickables: false,
          direction: "next",
        },
        { direction: o, allowWrapping: i, selectNonClickables: n } = {
          ...t,
          ...e,
        },
        a = this.findNextObjFromKeyboard(o, this.getKeyboardAttention());
      return !a || !i && a.wrapped
        ? (n && this.controller.dispatch({ type: "set-none-selected" }), false)
        : (a.wrapped && this.controller.isVirtualMouseAllowed()
          ? this.resetBackToGeoKeyboardPt()
          : (n &&
            (this.controller.isClickableId(a.target.calcId) ||
                !this.controller.isGeoItem(a.target.calcId)
              ? this.controller.dispatch({ type: "set-none-selected" })
              : this.controller.dispatch({
                type: "set-selected-id",
                id: a.target.calcId,
                state: "selected",
              })),
            this.updateKeyboardAttention(a.target, { describe: true })),
          true);
    }
    updateKeyboardAttention(e, t) {
      let o = this.getKeyboardAttention();
      I6(e, o) ||
        (this.setKeyboardAttention(e),
          this.controller.isGeometry() &&
          this.controller.getGeoModel().onFocus(
            e == null ? void 0 : e.geoDef,
          ),
          this.poiController.moveGeoKeyboardPtToFocusedItem(t),
          t.describe &&
          this.poiController.describeFocusedItem({ includeDetails: true }));
    }
    clearAttentionIfNotTabbable() {
      let { currentIsTabbable: e } = this
        .findTabbableObjectsForCurrentTool(this.getKeyboardAttention());
      e || this.updateKeyboardAttention(void 0, { describe: false });
    }
    handleGrapherGainedFocus() {
      if (
        this.controller.getGeoModel().speakCurrentGeoToolHint(),
          this.controller.isVirtualMouseAllowed()
      ) this.resetBackToGeoKeyboardPt();
      else {
        let t = this.findTabbableObjectsForCurrentTool(void 0).targets;
        t.length
          ? (this.setKeyboardAttention(void 0),
            this.updateKeyboardAttention(t[0], { describe: true }))
          : xe(
            this.controller.s(
              "graphing-calculator-narration-geometry-no-tool-inputs",
            ),
          );
      }
    }
    resetBackToGeoKeyboardPt() {
      this.updateKeyboardAttention(void 0, { describe: true }),
        this.poiController.geoKeyboardPt.x =
          this.poiController.geoKeyboardPt.lastArrowedX,
        this.poiController.geoKeyboardPt.y =
          this.poiController.geoKeyboardPt.lastArrowedY,
        this.poiController.handleGeoKeyboardPtMove();
    }
  };
  function uk(r) {
    if (!r) return 0;
    if (r.type === "image" && r.listIndex) return r.listIndex;
    if ("poi" in r) return r.poi.pointIdxOnBranch;
    if ("branchInfo" in r && r.branchInfo.sketch) {
      let e = r.branchInfo.branch, t = r.branchInfo.sketch.branches[e];
      return "listIndex" in t && t.listIndex || 0;
    }
    return 0;
  }
  var qne = 0,
    hk = class r {
      constructor(e, t) {
        this.geoKeyboardPt = {
          x: NaN,
          y: NaN,
          lastArrowedX: NaN,
          lastArrowedY: NaN,
        };
        this.canceledGeoToolplayWhilePressed = false;
        this.manager = e,
          this.controller = e.controller,
          this.keyboardAttentionManager = new pk(this),
          this.graphSettings = t,
          this.elt = this.manager.elt,
          this.id = qne++,
          this.graphSettings.config.observe(
            "disableMouseInteractions",
            () => {
              this.graphSettings.config.disableMouseInteractions
                ? this.removeHandlers()
                : this.graphSettings.config.graphpaper &&
                  this.addHandlers();
            },
          ),
          this.speakThrottledDescription = __dcg_shared_module_exports__
            ["z"](
              (o, i, n) => {
                var l, c;
                let a = this.controller.getItemModel(o);
                if (
                  !a || a.type !== "expression" && a.type !== "image"
                ) return;
                let s = (c = (l = a.formula) == null
                    ? void 0
                    : l.computed_description) == null
                  ? void 0
                  : c[i];
                s && s !== n && xe(ei(s));
              },
              100,
              { leading: false, trailing: true },
            ),
          !(!this.graphSettings.config.graphpaper ||
            this.graphSettings.config.disableMouseInteractions) &&
          this.addHandlers();
      }
      remove() {
        this.removeHandlers();
      }
      addHandlers() {
        this.addTouchEventHandlers(),
          this.addHoverEventHandler(),
          this.addKeyboardEventHandlers(),
          this.addManualUnhoverListener(),
          this.addGeoEventHandlers();
      }
      removeHandlers() {
        this.removeAllGlobalMouseListeners(),
          this.removeManualUnhoverListener(),
          this.removeAllGeoListeners(),
          this.removeHoverEventHandler(),
          this.removeElementListeners();
      }
      removeElementListeners() {
        ee(this.elt).off("touchstart"),
          ee(this.elt).off("dcg-tapstart"),
          ee(this.elt).off("mouseleave"),
          ee(this.elt).off("keydown");
      }
      addGlobalMouseListener(e, t) {
        let o = e.split(" ");
        for (let i of o) {
          let n = i + ".dcg-poiController-" + this.id;
          ee(document).on(n, t);
        }
      }
      removeAllGeoListeners() {
        ee(document).off(".dcg-poiController-geo-" + this.id);
      }
      removeAllGlobalMouseListeners() {
        ee(document).off(".dcg-poiController-" + this.id);
      }
      getToleranceByDevice(e) {
        return e === "touch" ? 20 : 10;
      }
      addGeoEventHandlers() {
        ee(document).on(
          "mouseleave.dcg-poiController-geo-" + this.id,
          () => {
            var e;
            if (
              this.controller.isGeoToolActive() &&
              !((e = this.pointerState) != null && e.isPressed)
            ) {
              let t = this.controller.getGeoModel();
              t.onMouseAction("move", {
                pt: { x: NaN, y: NaN },
                shift: false,
                tolerance: 0,
              }), t.onPreviewChange();
            }
          },
        ),
          ee(document).on(
            "dcg-tapend.dcg-poiController-geo-" + this.id,
            (e) => {
              var i;
              let t = !!((i = this.pointerState) != null && i.isPressed),
                o = this.updatePointerState(e);
              this.controller.isGeoToolActive() && t &&
                this.handleGeoTapEnd(o, e);
            },
          );
      }
      removeHoverEventHandler() {
        ee(document).off(".dcg-poiController-global-hover-" + this.id);
      }
      addHoverEventHandler() {
        let e = "dcg-tapmove.dcg-poiController-global-hover-" + this.id;
        ee(document).on(e, (t) => this.handleTapmove(t));
      }
      handleTapmove(e) {
        var _;
        let t = this.updatePointerState(e);
        if (
          this.controller.isGeoToolActive() && this.handleGeoTapMove(t) ||
          e.device === "touch"
        ) return;
        let o = document.elementFromPoint(e.clientX, e.clientY),
          i = !!o && !!o.closest(".dcg-grapher"),
          n = !!o && !!o.closest(".dcg-label"),
          a = !!o && !!o.closest(".dcg-opened"),
          s = n && !a,
          l = (_ = this.controller.getGrapher3d()) == null
            ? void 0
            : _.webglLayer,
          c = this.manager.poiLabelsLayer,
          d = this.getMouseRelativeToGrapher(e),
          p = this.getToleranceByDevice(e.device);
        l && (l == null || l.setMouse(i ? d : void 0));
        let h;
        i && !n && (h = this.getFeatureUnderPoint(d, p)),
          !!((e == null ? void 0 : e.originalEvent) || e).buttons &&
          (h = void 0);
        let u;
        if (h && h.type === "movable-point") {
          let A = h.poi, P = A && A.getMovablePoint();
          u = P && P.id;
        }
        let f, y = 0;
        h && h.isClickable && !this.isBoxSelectActive(e) &&
          !this.manager.movablePointsLayer.isMovingPoint() &&
          !this.manager.traceLayer.isTracing() &&
          (f = h.model, y = uk(h));
        let C = this.manager.clickableObjectsLayer, E = {};
        f &&
        (E[f.id] = { listIndexes: y === void 0 ? void 0 : { [y]: true } }),
          C.setHoveredObjects(E);
        let v;
        h && "poi" in h && h.poi &&
          (!h.poi.isAttachedToPlottedPoint() ||
            h.poi.hasInteractiveLabel()) &&
          (v = h.poi);
        let w = !v && s;
        v !== c.getHoveredPOI() && !w &&
          (this.controller.isTraceEnabled()
            ? c.setHoveredPOI(v)
            : c.setHoveredPOI(void 0),
            this.controller.requestRedrawGraph());
        let S = false;
        if (h && h.type === "image") {
          let A = fc(h.model), P = h.isClickable;
          S = A && !P;
        }
        let k = false;
        h && h.type === "draggable-label" && (k = true),
          S || k
            ? this.manager.setLayerClass(
              "extraMoveCursor",
              "dcg-mouse-over-movable-point",
            )
            : this.manager.setLayerClass("extraMoveCursor", ""),
          this.manager.movablePointsLayer.setHoveredPointId(u);
      }
      addManualUnhoverListener() {
        let e = () => {
          let t = this.manager;
          t.poiLabelsLayer.setHoveredPOI(void 0),
            t.clickableObjectsLayer.setHoveredObjects({}),
            this.controller.requestRedrawGraph();
        };
        ee(window).on("blur.dcg-poiController-" + this.id, e),
          ee(this.elt).on("mouseleave", e);
      }
      removeManualUnhoverListener() {
        ee(window).off(".dcg-poiController-" + this.id);
      }
      getPickResults(e, t) {
        let o = t.webglLayer,
          { x: i, y: n } = this.getMouseRelativeToGrapher(e);
        return o.setMouse({ x: i, y: n }),
          o.pickAtMouseAndReadResults(),
          o.getPickResult();
      }
      isClickable(e) {
        let t = this.controller.getItemModel(e);
        return bb(t);
      }
      add3DTouchEventHandlers(e) {
        let t = e.elt;
        if (!t) return;
        let o = e.webglLayer;
        ee(t).on("dcg-tapstart", (i) => {
          if (i.touches.length > 1) return;
          let n = this.getPickResults(i, e);
          if (n != null && n.id) {
            let { id: a, index: s } = n;
            this.isClickable(a)
              ? (o.setPressedAction({ id: a, index: s }),
                i.stopPropagation(),
                i.preventDefault())
              : this.controller.dispatch({
                type: "set-selected-id",
                id: a,
                state: "selected",
              });
          }
        }),
          ee(t).on("dcg-tapend dcg-tapcancel", () => {
            let i = o.getPressedAction();
            i &&
            (o.setPressedAction(void 0),
              this.controller.dispatch({
                type: "clickable-item-clicked",
                id: i.id,
                listIndex: i.index,
              })), o.isTrackingPressedAction = false;
          }),
          ee(t).on("dcg-tapmove", (i) => {
            if (o.isTrackingPressedAction) {
              let n = this.getPickResults(i, e);
              if (n != null && n.id) {
                let { id: a, index: s } = n;
                this.isClickable(a)
                  ? o.setPressedAction({ id: a, index: s })
                  : o.setPressedAction(void 0);
              } else o.setPressedAction(void 0);
            }
          });
      }
      addTouchEventHandlers() {
        ee(this.elt).on("touchstart", (e) => this.handleTouchstart(e)),
          ee(this.elt).on("dcg-tapstart", (e) => this.handleTapstart(e));
      }
      handleTouchstart(e) {
        if (!this.isViewportLocked()) {
          e.target.matches("input, textarea") || e.preventDefault();
          return;
        }
        let t = this.getMouseRelativeToGrapher(e),
          o = this.getToleranceByDevice(e.device),
          i = this.getFeatureUnderPoint(t, o);
        i &&
          (i.type === "image" && !Sa(i.model) && !fc(i.model) ||
            i.type === "sketch-branch" &&
              this.graphSettings.config.onlyTraceSelected &&
              !i.sketch.selected ||
            e.target.matches("input, textarea") || e.preventDefault());
      }
      handleTapstart(e) {
        let t = this.updatePointerState(e);
        if (
          this.controller.isGeoToolActive() &&
          this.handleGeoTapStart(t, e)
        ) {
          e.handle();
          return;
        }
        if (e.target.closest(".dcg-label")) {
          e.handle("do-not-clear-poi-labels");
          return;
        }
        let o = this.getMouseRelativeToGrapher(e),
          i = this.getToleranceByDevice(e.device),
          n = this.getFeatureUnderPoint(o, i);
        if (!n) {
          this.isBoxSelectActive(e) ||
          this.controller.dispatch({ type: "set-none-selected" }),
            this.isBoxSelectActive(e)
              ? this.startBoxSelect(e)
              : this.manager.viewportController.beginPanning(e);
          return;
        }
        if (n.isClickable && !this.isBoxSelectActive(e)) {
          let d = "model" in n && n.model;
          d
            ? this.manager.clickableObjectsLayer.setPressedObject({
              id: d.id,
              listIndex: uk(n),
            })
            : this.manager.clickableObjectsLayer.setPressedObject(void 0);
        } else {this.manager.clickableObjectsLayer.setPressedObject(
            void 0,
          );}
        if (n.type === "editable-label") {
          e.handle();
          return;
        } else Jr();
        if (n.type === "draggable-label") {
          this.startMovingPoints({
            poiUnderMouse: void 0,
            evt: e,
            points: [{
              type: "draggable-label",
              label: n.label,
              model: n.model,
              startScreenPt: o,
            }],
            originalTargetObjectId: n.model.id,
          }), e.handle();
          return;
        }
        if (
          n.type === "clickable-label" && e.handle(),
            n.type === "image" && fc(n.model) &&
            !this.isBoxSelectActive(e)
        ) {
          let d = !!n.isClickable;
          if (
            this.startMovingPoints({
              poiUnderMouse: void 0,
              evt: e,
              points: [{
                type: "image",
                image: n.model,
                startScreenPt: o,
                shouldDelayUntilRealMove: d,
              }],
              originalTargetObjectId: n.model.id,
            }), !d
          ) {
            e.handle();
            return;
          }
        }
        let a = false, s = n.model;
        if (
          this.controller.isGeometry() && s && s.type === "expression" &&
          s.formula.geometry
        ) {
          let d;
          "poi" in n && (d = n.poi),
            a = this.startReverseDrag(s.id, e, d),
            a && n.type !== "static-point" &&
            this.manager.clickableObjectsLayer.setPressedObject({
              id: s.id,
              listIndex: uk(n),
            }),
            !a && n.isClickable &&
            this.controller.dispatch({ type: "set-none-selected" });
        }
        if (
          n.type === "movable-point" &&
          (e.handle(), e.handle("do-not-clear-poi-labels"), !a)
        ) {
          this.startMovingPoints({
            poiUnderMouse: n.poi,
            evt: e,
            points: [{ type: "poi", poi: n.poi, startScreenPt: o }],
            originalTargetObjectId: n.sketch.id,
          });
          return;
        }
        if (!a && this._togglePOIUnderPoint(n)) {
          e.handle(), e.handle("do-not-clear-poi-labels");
          return;
        }
        if (!a && n.type === "sketch-branch" && !n.isClickable) {
          let d = !this.controller.isTraceEnabled();
          if (this.graphSettings.config.onlyTraceSelected) {
            if (
              e.handle("do-not-clear-poi-labels"),
                !d &&
                this.controller.getItemSelectedState(n.model.id) ===
                  "selected" &&
                !this.isBoxSelectActive(e)
            ) {
              this.startTracingBranch(n, o), e.handle();
              return;
            }
          } else {
            let p = !this.controller.isListEnabled();
            if (
              d && p ||
              (this.selectItemIfNotSecret(n.model.id, {
                multiSelect: this.isBoxSelectActive(e),
                tentative: false,
              }),
                d)
            ) return;
            this.startTracingBranch(n, o),
              e.handle(),
              e.handle("do-not-clear-poi-labels");
            return;
          }
        }
        (this.controller.shouldShowMultiSelectHeader()
                  ? "multi-select"
                  : "default") === "default" && a ||
          this.selectFeatureUnderMouse(n, {
            multiSelect: this.isBoxSelectActive(e),
            tentative: true,
          });
        let c = false;
        this.addGlobalMouseListener("dcg-tapmove", (d) => {
          c = true,
            this.manager.clickableObjectsLayer.isAnObjectPressed()
              ? o = this.getMouseRelativeToGrapher(d)
              : a ||
                (this.removeAllGlobalMouseListeners(),
                  this.controller.isGeometry() &&
                  (this.controller.dispatch({
                    type: "clear-tentative-selection",
                  }),
                    this.addGlobalMouseListener("dcg-tapend", (p) => {
                      this.removeAllGlobalMouseListeners(),
                        this.shouldTreatSmallDragAsClick(e, p) &&
                        this.selectFeatureUnderMouse(n, {
                          multiSelect: this.isBoxSelectActive(p),
                          tentative: false,
                        });
                    })),
                  this.manager.viewportController.beginPanning(d));
        }),
          this.addGlobalMouseListener("dcg-tapend dcg-tapcancel", (d) => {
            this.removeAllGlobalMouseListeners();
            let p = this.manager.clickableObjectsLayer.getPressedObject(),
              h = p && p.id;
            this.manager.clickableObjectsLayer.setPressedObject(void 0);
            let u = this.getFeatureUnderPoint(o, i);
            if (u && u.isClickable) {
              let f = "model" in u && u.model;
              f && f.id === h &&
                !d.wasHandled("dragged-clickable-object") &&
                !this.isBoxSelectActive(d) &&
                this.controller.dispatch({
                  type: "clickable-item-clicked",
                  id: f.id,
                  listIndex: uk(u),
                });
              return;
            }
            (!c || this.shouldTreatSmallDragAsClick(e, d)) &&
              (this.controller.hasTentativeSelection()
                ? this.controller.dispatch({
                  type: "commit-tentative-selection",
                })
                : this.selectFeatureUnderMouse(u, {
                  multiSelect: this.isBoxSelectActive(d),
                  tentative: false,
                }));
          });
      }
      shouldTreatSmallDragAsClick(e, t) {
        var a, s, l, c;
        let o = ((a = t.clientX) != null ? a : NaN) -
            ((s = e.clientX) != null ? s : NaN),
          i = ((l = t.clientY) != null ? l : NaN) -
            ((c = e.clientY) != null ? c : NaN),
          n = this.getToleranceByDevice(t.device);
        return Math.abs(o) < n && Math.abs(i) < n;
      }
      selectFeatureUnderMouse(e, t) {
        var i;
        if (!e) return;
        let o = (i = e.model) == null ? void 0 : i.id;
        o &&
          (this.controller.isItemSelected(o) && !t.multiSelect ||
            this.controller.isItemSelected(o) && t.tentative ||
            e.type === "movable-point" && !this.controller.isGeometry() ||
            e.isClickable || this.selectItemIfNotSecret(o, t));
      }
      isBoxSelectActive(e) {
        if (!this.controller.isMultiSelectEnabled()) return false;
        let t = this.controller.getActiveTool();
        return t === "selection" && e.shiftKey || t === "box-selection";
      }
      isViewportLocked() {
        return this.graphSettings.config.lockViewport ||
          this.graphSettings.userLockedViewport;
      }
      addKeyboardEventHandlers() {
        let e = `dcg-poiController-${this.id}`;
        ee(document).on(`keyup.${e} keydown.${e}`, (t) => {
          this.handleShiftKeyChange(t.shiftKey);
        }),
          ee(this.elt).on("keydown", (t) => {
            var l, c, d, p, h;
            let o = t;
            if (this.manager.getAudioTrace().getAudioTraceActive()) {
              return;
            }
            let i = this.manager.movablePointsLayer
                .getPOIUnderAttention(),
              n = this.manager.imageLayer.getFocusedImage(),
              a = ke(o),
              s = Ko(o);
            if (
              (a === "Up" || a === "Down" || a === "Left" ||
                a === "Right") && this.controller.isGraphPaperFocused()
            ) {
              o.stopPropagation(), o.preventDefault();
              let u = this.keyboardAttentionManager
                  .getKeyboardAttention(),
                f = this.controller.getActiveTool();
              if (
                !u && (f === "selection" || f === "box-selection") &&
                !o.altKey && !o.ctrlKey && !o.metaKey && !o.shiftKey
              ) {
                this.manager.viewportController.panFromKeyboard(a);
                return;
              } else if (
                u && this.controller.shouldAllowMovingPointsWithKeyboard()
              ) {
                let y = n ? n.centerId : u.calcId;
                if (!y) return;
                let C = this.getDraggablePointOrAncestors(y, o);
                this.movePointsFromKeyboard(C, o),
                  this.controller.getEvaluator().notifyWhenSynced(() => {
                    this.describeFocusedItem({ includeDetails: true });
                  });
              } else {this.controller.isVirtualMouseAllowed() &&
                  (this.keyboardAttentionManager.updateKeyboardAttention(
                    void 0,
                    { describe: false },
                  ),
                    this.moveGeoPointFromKeyboard(o));}
            } else if (
              a === "Tab" && this.controller.isGraphPaperFocused()
            ) {
              let u = o.shiftKey ? "prev" : "next",
                f = this.keyboardAttentionManager.getKeyboardAttention();
              if (
                !(this.controller.getActiveTool() !== "selection") &&
                !f && u === "prev"
              ) return;
              this.handleTabEvent(u, o);
            } else if (
              (a === "Enter" || a === "Space") &&
              this.controller.isGraphPaperFocused() &&
              this.controller.getActiveTool() === "selection"
            ) {
              let u = this.keyboardAttentionManager
                .getKeyboardAttention();
              if (u) {
                let f = this.controller.getItemModel(u.calcId);
                if (f && !this.isBoxSelectActive(o)) {
                  let y = f.type === "expression" && $n(f),
                    C = f.type === "image" && Dg(f);
                  if (y || C) {
                    this.controller.dispatch({
                      type: "clickable-item-clicked",
                      id: u.calcId,
                      listIndex: u.listIndex,
                    });
                    let E = u.listIndex || 0;
                    this.speakThrottledDescription(
                      u.calcId,
                      E,
                      (c = (l = f.formula) == null
                          ? void 0
                          : l.computed_description) == null
                        ? void 0
                        : c[E],
                    );
                  }
                }
              }
              o.preventDefault(), o.stopPropagation();
              return;
            } else if (
              this.controller.isGeometry() &&
              this.controller.isGraphPaperFocused()
            ) {
              let u = false;
              if (o.ctrlKey && o.shiftKey && !o.altKey && !o.metaKey) {
                let f;
                if (
                  s === "O"
                    ? f = {
                      type: "multi-select-more",
                      guid: rm(),
                      focusFirstOption: true,
                      previousFocusLocation: { type: "graph-paper" },
                    }
                    : s === "A" &&
                      (f = {
                        type: "multi-select-construct",
                        guid: zv(),
                        focusFirstOption: true,
                        previousFocusLocation: { type: "graph-paper" },
                      }), f
                ) {
                  o.preventDefault(), o.stopPropagation();
                  let y = this.keyboardAttentionManager
                    .getKeyboardAttention();
                  this.controller.getActiveTool() !== "box-selection" &&
                  y && this.controller.getItemModel(y.calcId) &&
                  this.controller.dispatch({
                    type: "set-selected-id",
                    id: y.calcId,
                    state: "selected",
                  }),
                    this.controller.dispatch({
                      type: "toggle-item-settings-menu",
                      menu: f,
                    });
                }
              } else if (!o.altKey && !o.ctrlKey && !o.metaKey) {
                if (a === "Enter" || a === "Space") {
                  if (
                    o.preventDefault(),
                      this.controller.getActiveTool() !== "selection" &&
                      o.stopPropagation(),
                      this.controller.getActiveTool() === "box-selection"
                  ) {
                    let f = ((d = this.keyboardAttentionManager
                        .getKeyboardAttention()) == null
                      ? void 0
                      : d.calcId) || "";
                    this.controller.isClickableId(f) && (f = ""),
                      this.selectItemIfNotSecret(f, {
                        multiSelect: true,
                        tentative: false,
                      }),
                      this.describeFocusedItem({ includeDetails: false });
                  } else {
                    let f = this.keyboardAttentionManager
                      .getKeyboardAttention();
                    this.activateGeoObjectFromKeyboard(f, o);
                  }
                } else if (s === "?") {
                  o.preventDefault(),
                    o.stopPropagation(),
                    this.controller.getGeoModel()
                      .speakCurrentGeoToolHint();
                } else if (s === "D") {
                  o.preventDefault(),
                    o.stopPropagation(),
                    this.describeFocusedItem({ includeDetails: true });
                } else if (a === "Backspace" || a === "Del") {
                  o.preventDefault(), o.stopPropagation();
                  let f = this.keyboardAttentionManager
                    .getKeyboardAttention();
                  this.controller.getActiveTool() !== "box-selection" &&
                  f && this.controller.getItemModel(f.calcId) &&
                  this.controller.dispatch({
                    type: "set-selected-id",
                    id: f.calcId,
                    state: "selected",
                  }),
                    this.controller.dispatch({
                      type: "delete-all-selected-items",
                    }),
                    u = true;
                } else if (s === "-" || s === "=") {
                  o.preventDefault(), o.stopPropagation();
                  let f = this.controller.getAllVisibleGeoToolbarItems(),
                    y = f.findIndex((C) =>
                      (C == null ? void 0 : C.current) ===
                        this.controller.getActiveTool()
                    );
                  for (let C = 1; C < f.length; C++) {
                    let E = y + (s === "-" ? -C : C);
                    E < 0 && (E = f.length + E),
                      E > f.length - 1 && (E = E - f.length);
                    let v = (p = f[E]) == null ? void 0 : p.current;
                    if (this.selectGeoTool(v)) {
                      u = true;
                      break;
                    }
                  }
                } else if (s === "[" || s === "]") {
                  o.preventDefault(), o.stopPropagation();
                  let y = this.controller.getAllVisibleGeoToolbarItems()
                    .find((v) =>
                      (v == null ? void 0 : v.current) ===
                        this.controller.getActiveTool()
                    );
                  if (!y) {
                    return;
                  }
                  let C = y.dropdown || [y.current];
                  if (C.length === 0) return;
                  let E = C.indexOf(y.current);
                  for (let v = 1; v < C.length; v++) {
                    let w = E + (s === "[" ? -v : v);
                    w < 0 && (w = C.length + w),
                      w > C.length - 1 && (w = w - C.length);
                    let S = C[w];
                    if (this.selectGeoTool(S)) {
                      u = true;
                      break;
                    }
                  }
                } else if (
                  !o.shiftKey && s !== void 0 && s >= "0" && s <= "9"
                ) {
                  let f = (h = this.controller
                      .getAllVisibleGeoToolbarItems()[
                        o.which - 49
                      ]) == null
                    ? void 0
                    : h.current;
                  u = this.selectGeoTool(f);
                }
              }
              u && this.handleGeoKeyboardPtMove();
            } else {i &&
                  (s === "X" || s === "Y" || s === "L" || s === "C")
                ? this.speakPoint(i, s)
                : n && (s === "X" || s === "Y" || s === "L") &&
                  this.manager.imageLayer.speakImageAttribute(n, s);}
          });
      }
      selectGeoTool(e) {
        return e
          ? this.controller.isGeoToolEnabled(e)
            ? (this.controller.dispatch({
              type: "select-geo-tool",
              tool: e,
            }),
              true)
            : (xe(
              this.controller.s(
                "graphing-calculator-narration-geometry-tool-disabled",
                {
                  tool: this.controller.getGeoModel()
                    .getDisplayNameForTool(e),
                },
              ),
            ),
              false)
          : false;
      }
      getMouseRelativeToGrapher(e) {
        let t = this.elt.getBoundingClientRect(),
          o = e.touches ? e.touches[0] : e,
          i = o.clientX - t.left,
          n = o.clientY - t.top;
        return { x: i, y: n };
      }
      _getStyledPointRadiusAdjustments() {
        return {
          radiusMultiplier: this.graphSettings
            .getHighlightPropertyMultiplier("pointLineWidth", false),
          selectedRadiusMultiplier: this.graphSettings
            .getHighlightPropertyMultiplier("pointLineWidth", true),
        };
      }
      _getStyledPointRadiusForPOI(e, t) {
        let o = e.getPointSize() / 2,
          i = e.isSelected() ? t.selectedRadiusMultiplier : t.radiusMultiplier;
        return o * i;
      }
      handleTabEvent(e, t) {
        let o = this.controller.getActiveTool() !== "selection";
        if (
          this.keyboardAttentionManager.focusNextObjFromKeyboard({
            direction: e,
            allowWrapping: o,
            selectNonClickables:
              this.controller.getActiveTool() === "selection",
          })
        ) {
          t == null || t.preventDefault(), t == null || t.stopPropagation();
          return;
        } else if (!o) {
          this.keyboardAttentionManager.updateKeyboardAttention(void 0, {
            describe: false,
          }),
            e === "prev" &&
            (t == null || t.preventDefault(),
              t == null || t.stopPropagation(),
              this.manager.speakGrapherFocusAriaLabel());
          return;
        }
      }
      _getDistanceFromStyledPOI(e, t) {
        let o = this._getStyledPointRadiusForPOI(e, t.adjustments),
          i = Math.max(0, t.tolerance - o),
          n = t.projection.map_pt(e),
          a = __dcg_shared_module_exports__["MathHypot"](
            n.x - t.screenPt.x,
            n.y - t.screenPt.y,
          ),
          s = Math.max(0, a - o);
        if (s <= i) return s;
      }
      _getClosestPoint(e, t, o) {
        let i = 1 / 0,
          n,
          a = {
            projection: this.manager.getProjection(),
            adjustments: this._getStyledPointRadiusAdjustments(),
            screenPt: t,
            tolerance: o,
          };
        for (let s of e) {
          let l = this._getDistanceFromStyledPOI(s, a);
          l !== void 0 && l <= i && (i = l, n = s);
        }
        return n;
      }
      findIdsThatIntersectBox(e) {
        let t = {};
        for (let o of this.manager.generateMergeDrawOrder()) {
          let i = this.controller.getItemModel(o);
          if (
            i && !this.controller.shouldIgnoreGraphInteractions(i)
          ) {
            if (i.type === "expression") {
              let n = this.manager.getGraphSketch(o);
              if (
                !n || $n(i) ||
                this.controller.isItemNotSelectableBecauseItsSecret(o)
              ) continue;
              let a = n.branches;
              if (!a || !a.length) continue;
              for (let s = 0; s < a.length; s++) {
                if (this.doesBoxIntersectBranch(a[s], e)) {
                  t[i.id] = true;
                  break;
                }
              }
            } else if (i.type === "image") {
              let n = this.manager.getGraphImage(o);
              if (!n) continue;
              r.doesBoxIntersectAnyImage(n, e) && (t[i.id] = true);
            }
          }
        }
        return this.manager.poiDotsLayer.getDrawnPOI().forEach((o) => {
          let i = o.sketch.id, n = this.controller.getItemModel(i);
          n && this.controller.shouldIgnoreGraphInteractions(n) ||
            n && n.type === "expression" && $n(n) ||
            this.controller.isItemNotSelectableBecauseItsSecret(i) ||
            o.isBareLabel() ||
            (o.isMovable() || o.isAttachedToPlottedPoint()) &&
              r.doesBoxIntersectPOI(o, e) && (t[i] = true);
        }),
          t;
      }
      _getStyledLineAdjustments() {
        return {
          thicknessMultiplier: this.graphSettings
            .getHighlightPropertyMultiplier("graphLineWidth", false),
          selectedThicknessMultiplier: this.graphSettings
            .getHighlightPropertyMultiplier("graphLineWidth", true),
        };
      }
      _getStyledLineThicknessForBranch(e, t, o) {
        let i = Math.max(0, "lineWidth" in e && e.lineWidth || 0) / 2;
        return t
          ? i * o.selectedThicknessMultiplier
          : i * o.thicknessMultiplier;
      }
      _getDistanceFromStyledBranch(e, t, o, i) {
        let n = this._getStyledLineThicknessForBranch(
            e,
            t,
            i.adjustments,
          ),
          a = this.calculateDistanceFromBranch(
            e,
            i.screenPt,
            i.projection,
            o,
          ),
          s = Math.max(0, a - n),
          l = Math.max(0, i.tolerance - n);
        if (s <= l) return s;
      }
      getLabelUnderPoint(e) {
        let t = this.manager.poiLabelsLayer.getInteractiveLabelUnderPoint(
          e,
        );
        if (
          t && !this.controller.shouldIgnoreGraphInteractions(t.model)
        ) {
          switch (t.type) {
            case "editable":
              return {
                type: "label",
                stackingContext: -1 / 0,
                stackingLayer: t.layerNumber,
                distance: 0,
                label: {
                  type: "editable-label",
                  model: t.model,
                  isClickable: void 0,
                },
              };
            case "draggable":
              return {
                type: "label",
                stackingContext: -1 / 0,
                stackingLayer: t.layerNumber,
                distance: 0,
                label: {
                  type: "draggable-label",
                  label: t.label,
                  model: t.model,
                  isClickable: void 0,
                },
              };
            case "clickable":
              return {
                type: "label",
                stackingContext: -1 / 0,
                stackingLayer: t.layerNumber,
                distance: 0,
                label: {
                  type: "clickable-label",
                  model: t.model,
                  poi: t.poi,
                  isClickable: true,
                },
              };
          }
        }
      }
      getFeatureUnderPointInLayer(e, t, o, i) {
        var p, h, u, f;
        let n,
          a = e.layer,
          s = e.drawOrder,
          l = this.manager.getProjection(),
          c = {
            adjustments: this._getStyledLineAdjustments(),
            projection: l,
            screenPt: t,
            tolerance: o,
          },
          d = 1;
        for (let y = s.length - 1; y >= 0; y--) {
          let C = s[y], E = this.controller.getItemModel(C), v = d;
          if (i[C] = { layerNumber: a, stackingContext: v }, !E) {
            let w = this.manager.getGraphSketch(C),
              S = (h = (p = w == null ? void 0 : w.branches) == null
                  ? void 0
                  : p[0]) == null
                ? void 0
                : h.tableId;
            if (S) {
              let k = this.controller.getItemModel(S);
              (k == null ? void 0 : k.type) === "table" &&
                ((u = k.regression) == null ? void 0 : u.id) === C &&
                (E = k);
            }
          }
          if (
            E && !this.controller.shouldIgnoreGraphInteractions(E)
          ) {
            if (
              E.type === "expression" ||
              E.type === "table" &&
                ((f = E.regression) == null ? void 0 : f.id) === C
            ) {
              let w = this.manager.getGraphSketch(C);
              if (!w) continue;
              let S = w.branches;
              if (!S || !S.length) continue;
              if (
                w.hoistToTop && !this.controller.isGeometry() &&
                (v = -1 / 0, i[C] = { layerNumber: 1 / 0, stackingContext: v }),
                  !n || n.stackingContext >= v
              ) {
                let k = E.type === "table" ? false : $n(E);
                for (let _ = 0; _ < S.length; _++) {
                  let A = S[_],
                    P = this._getDistanceFromStyledBranch(
                      A,
                      w.showHighlight,
                      k,
                      c,
                    );
                  if (P !== void 0) {
                    let O = false;
                    n
                      ? (v < n.stackingContext ||
                        v === n.stackingContext &&
                          P < n.distance - 3.5) && (O = true)
                      : O = true,
                      O &&
                      (n = {
                        type: "sketch-branch",
                        model: E,
                        sketch: w,
                        distance: P,
                        stackingContext: v,
                        stackingLayer: a,
                        branchInfo: { id: w.id, branch: _, sketch: w },
                      });
                  }
                }
              }
            } else if (E.type === "image") {
              let w = this.manager.getGraphImage(C);
              if (!w) continue;
              let S = this.getImageInfoUnderMouse(
                w,
                l.pixelsToMath.mapPoint(t),
                o,
              );
              if (!S) continue;
              d += 1,
                v = d,
                i[C] = { layerNumber: a, stackingContext: v },
                d += 1,
                (!n || n.stackingContext > v) &&
                (n = {
                  type: "image",
                  model: w,
                  distance: 0,
                  stackingContext: v,
                  stackingLayer: a,
                  listIndex: S.listIndex,
                });
            }
          }
        }
        return n;
      }
      getFeatureUnderPoint(e, t) {
        var f;
        if (this.manager.scaleAxis) return;
        let o, i = this.getLabelUnderPoint(e);
        if (i) {
          if (i.label.type === "editable-label") return i.label;
          o = i;
        }
        let n = {}, a = this.manager.getDrawLayers();
        for (let y = a.length - 1; y >= 0; y--) {
          let C = a[y], E = this.getFeatureUnderPointInLayer(C, e, t, n);
          E && (o ? E.stackingLayer > o.stackingLayer && (o = E) : o = E);
        }
        let s = [], l = [], c = [], d = [];
        this.manager.poiDotsLayer.getDrawnPOI().forEach((y) => {
          var v;
          if (y.isBareLabel()) return;
          let C = y.sketch.id, E = this.controller.getItemModel(C);
          if (!(E && this.controller.shouldIgnoreGraphInteractions(E))) {
            if (!E && y.sketch.branches.length > 0) {
              let w = y.sketch.branches[0].tableId,
                S = w !== void 0 ? this.controller.getItemModel(w) : void 0,
                k = (S == null ? void 0 : S.type) === "table" && Eo(S, C);
              if (k && this.controller.shouldIgnoreGraphInteractions(k)) {
                return;
              }
            }
            if (y.isMovable()) {
              let w = E && E.type === "expression" &&
                ((v = E.formula.geometry) == null ? void 0 : v.call);
              (!o || o.stackingLayer <= n[y.sketch.id].layerNumber) &&
                (w && w.symbol === "glider" ? s.push(y) : l.push(y));
            } else {y.isAttachedToPlottedPoint()
                ? (!o || o.stackingLayer < n[y.sketch.id].layerNumber ||
                  o.stackingLayer === n[y.sketch.id].layerNumber &&
                    o.stackingContext >=
                      n[y.sketch.id].stackingContext) && c.push(y)
                : d.push(y);}
          }
        });
        let p = this._getClosestPoint(s, e, t);
        if (p || (p = this._getClosestPoint(l, e, t)), p) {
          return {
            type: "movable-point",
            poi: p,
            isClickable: void 0,
            sketch: p.sketch,
            model: this.controller.getItemModel(p.sketch.id),
          };
        }
        let h = this._getClosestPoint(d, e, t + 2);
        if (h) {
          return { type: "poi", poi: h, isClickable: false, model: void 0 };
        }
        let u = this._getClosestPoint(c, e, t);
        if (u) {
          let y = this.controller.getItemModel(u.sketch.id);
          return y && y.type === "expression" && $n(y)
            ? {
              type: "static-point",
              poi: u,
              sketch: u.sketch,
              isClickable: true,
              model: y,
            }
            : {
              type: "static-point",
              poi: u,
              isClickable: false,
              sketch: u.sketch,
              model: y,
            };
        }
        if (o) {
          if (o.type === "label") return o.label;
          if (o.type === "sketch-branch") {
            let y, C;
            if (o.model.type === "table") C = true, y = false;
            else {
              y = $n(o.model);
              let E = (f = o.model.formula.typed_constant_value) == null
                ? void 0
                : f.valueType;
              C = !(this.controller.isGeometry() && E &&
                __dcg_shared_module_exports__["isGeometryType"](E));
            }
            return {
              type: "sketch-branch",
              branchInfo: o.branchInfo,
              sketch: o.sketch,
              model: o.model,
              isClickable: y,
              isTraceable: C,
              isSelected: this.controller.isItemSelected(o.model.id),
              selectionId: this.controller.isItemSelectable(o.model.id)
                ? o.model.id
                : void 0,
            };
          } else if (o.type === "image") {
            return {
              type: "image",
              model: o.model,
              isClickable: Dg(o.model),
              listIndex: o.listIndex,
              isSelected: this.controller.isItemSelected(o.model.id),
              selectionId: this.controller.isItemSelectable(o.model.id)
                ? o.model.id
                : void 0,
            };
          }
        }
      }
      _togglePOIUnderPoint(e) {
        if (!this.controller.isTraceEnabled()) return;
        if (e.isClickable) return false;
        let t = "poi" in e && e.poi;
        return !t || t.isBareLabel() ||
            this.controller.isGeometry() && e.type === "static-point" &&
              !t.hasInteractiveLabel()
          ? false
          : (this.manager.poiLabelsLayer.isOpenPOI(t)
            ? (this.manager.poiLabelsLayer.closePOI(t),
              this.manager.poiLabelsLayer.setHoveredPOI(void 0))
            : (this.manager.poiLabelsLayer.openPOI(t), this.speakPoint(t)),
            this.controller.requestRedrawGraph(),
            true);
      }
      getImageInfoUnderMouse(e, t, o) {
        if (!e) return;
        let i = e.formula;
        if (!i) return;
        let n = i.dimensions;
        if (
          !(!n.x || !n.y || !n.width || !n.height || !n.radianAngle ||
            !e.shouldGraph)
        ) {
          for (let a = n.x.length - 1; a >= 0; a--) {
            let s = n.x[a],
              l = n.y[a],
              c = n.radianAngle[a],
              d = s + Math.cos(c) * (t.x - s) - Math.sin(c) * (t.y - l),
              p = l + Math.sin(c) * (t.x - s) + Math.cos(c) * (t.y - l),
              h = .5 * Math.abs(n.width[a]),
              u = .5 * Math.abs(n.height[a]);
            if (
              d > s - h && d < s + h && p > l - u && p < l + u
            ) return { listIndex: a };
          }
        }
      }
      doesBoxIntersectBranch(e, t) {
        let o = false, i = false;
        switch (e.graphMode) {
          case 5:
          case 8:
          case 2:
            break;
          case 6:
            o = true;
            break;
          case 1:
            i = true;
            break;
          case 18:
          case 17:
          case 19:
          case 24:
            return dk(t, {
              x1: e.segments[0][0],
              y1: e.segments[0][1],
              x2: e.segments[0][2],
              y2: e.segments[0][3],
              extendStart: e.graphMode === 18,
              extendEnd: e.graphMode !== 17,
            });
          case 20:
            return D6(t, {
              x: e.segments[0][0],
              y: e.segments[0][1],
              radius: e.segments[0][2],
            });
          case 21:
          case 23: {
            let [a, s] = e.segments[0],
              [l, c, d] = e.graphMode === 21
                ? this.getBoxIntersectArgsForArc(e)
                : this.getBoxIntersectArgsForAngleMarker(e),
              p = (d - c) / 2 + c;
            return T6(t, {
              x0: a + l * Math.cos(c),
              y0: s + l * Math.sin(c),
              x1: a + l * Math.cos(p),
              y1: s + l * Math.sin(p),
              x2: a + l * Math.cos(d),
              y2: s + l * Math.sin(d),
            });
          }
          default:
            return false;
        }
        let n = e.segments;
        for (let a = 0; a < n.length; a++) {
          let s = n[a];
          if (o) {
            let l = s;
            s = [];
            for (let c = 0; c < l.length; c += 2) {
              let d = l[c], p = l[c + 1];
              s.push(p * Math.cos(d), p * Math.sin(d));
            }
          } else if (i) {
            let l = s;
            s = [];
            for (let c = 0; c < l.length; c += 2) s.push(l[c + 1], l[c]);
          }
          if (k6(t, s)) return true;
        }
        return false;
      }
      getBoxIntersectArgsForArc(e) {
        return [e.segments[0][2], e.segments[0][3], e.segments[0][4]];
      }
      getBoxIntersectArgsForAngleMarker(e) {
        let t = e.segments[0][3],
          o = this.manager.getProjection(),
          i = Zu(t, o),
          n = o.pixelsToMath.dangerouslyGetXScaleFactor(),
          a = o.pixelsToMath.dangerouslyGetYScaleFactor();
        return [
          Math.abs(Math.min(n, a)) * i,
          e.segments[0][2],
          e.segments[0][2] + t,
        ];
      }
      static doesBoxIntersectAnyImage(e, t) {
        let o = e.formula;
        if (!o) return;
        let i = o.dimensions;
        if (
          !(!i.x || !i.y || !i.width || !i.height || !i.radianAngle ||
            !e.shouldGraph)
        ) {
          for (let n = i.x.length - 1; n >= 0; n--) {
            if (
              _6(t, {
                width: i.width[n],
                height: i.height[n],
                angle: i.radianAngle[n],
                center: { x: i.x[n], y: i.y[n] },
              })
            ) return true;
          }
          return false;
        }
      }
      static doesBoxIntersectPOI(e, t) {
        return t.left <= e.x && e.x <= t.right && t.top <= e.y &&
          e.y <= t.bottom;
      }
      calculateDistanceFromBranch(e, t, o, i) {
        let n = this.controller.isGeometry() && e.graphMode === 7;
        if (i || n) {
          let l = [t.x, t.y], c = JL(o, e);
          for (let d of c) {
            if (__dcg_shared_module_exports__["ba"](d, l)) return 0;
          }
        }
        if (e.graphMode === 7) return 1 / 0;
        let s = r.getBranchesDistanceInfo(
          e,
          t,
          o,
          i,
          this.controller.isGeometry(),
        );
        return s ? s.minDistance : 1 / 0;
      }
      static getBranchesDistanceInfo(e, t, o, i, n) {
        let a = t.x, s = t.y, { mathToPixels: l, pixelsToMath: c } = o;
        switch (e.graphMode) {
          case 5:
            if (!n && !i) return;
            break;
          case 8:
            if (!i) return;
            break;
          case 6:
            if (!i) return;
            break;
          case 2:
          case 1:
            break;
          case 23:
            {
              let [E, v, w, S] = e.segments[0],
                k = l.dangerouslyGetXScaleFactor(),
                _ = l.dangerouslyGetYScaleFactor(),
                [A, P] = c.mapCoordinatePair([a, s]),
                O = Zu(S, o),
                U = O / k,
                z = 1 / 0,
                x = P - v,
                L = A - E,
                V = Math.atan2(x, L);
              if (__dcg_shared_module_exports__["Q"](V, w, S)) {
                __dcg_shared_module_exports__["MathHypot"](x * _, L * k) <=
                    O + 7 && (z = 0);
              } else {
                let R = __dcg_shared_module_exports__["V"](
                    A,
                    P,
                    E + U * Math.cos(w),
                    v + U * Math.sin(w),
                    E,
                    v,
                  ),
                  N = __dcg_shared_module_exports__["V"](
                    A,
                    P,
                    E + U * Math.cos(w + S),
                    v + U * Math.sin(w + S),
                    E,
                    v,
                  ),
                  M = __dcg_shared_module_exports__["MathHypot"](
                    k * (R[0] - A),
                    _ * (R[1] - P),
                  ),
                  F = __dcg_shared_module_exports__["MathHypot"](
                    k * (N[0] - A),
                    _ * (N[1] - P),
                  );
                z = Math.min(M, F);
              }
              return {
                closestPoint: { x: a, y: s },
                minDistance: z,
                secondDistance: z,
              };
            }
            break;
          case 18:
          case 17:
          case 19:
          case 24: {
            if (!e.segments.length) return null;
            let E = l.mapX(e.segments[0][0]),
              v = l.mapY(e.segments[0][1]),
              w = l.mapX(e.segments[0][2]),
              S = l.mapY(e.segments[0][3]),
              k = e.graphMode === 18,
              _ = e.graphMode === 18 || e.graphMode === 19,
              A = __dcg_shared_module_exports__["W"](
                a,
                s,
                E,
                v,
                w,
                S,
                k,
                _,
              );
            if (!A) return null;
            let P = __dcg_shared_module_exports__["MathHypot"](
              A[0] - a,
              A[1] - s,
            );
            return {
              closestPoint: { x: A[0], y: A[1] },
              minDistance: P,
              secondDistance: P,
            };
          }
          case 21:
          case 20: {
            let E = e.segments[0][0],
              v = e.segments[0][1],
              w = e.segments[0][2],
              S = e.graphMode === 21 ? e.segments[0][3] : 0,
              k = e.graphMode === 21 ? e.segments[0][4] : Math.PI * 2,
              _ = __dcg_shared_module_exports__["X"](
                c.mapX(a),
                c.mapY(s),
                E,
                v,
                w,
                S,
                k,
              );
            if (!_) return null;
            let A = l.mapCoordinatePair(_),
              P = __dcg_shared_module_exports__["MathHypot"](
                A[0] - a,
                A[1] - s,
              );
            return {
              closestPoint: { x: A[0], y: A[1] },
              minDistance: P,
              secondDistance: P,
            };
          }
          default:
            return;
        }
        let d = 1 / 0, p = 1 / 0, h, u;
        for (let E = 0; E < e.segments.length; E++) {
          let v = e.segments[E];
          for (let w = 0; w < v.length - 3; w += 2) {
            let S = v[w], k = v[w + 1], _ = v[w + 2], A = v[w + 3];
            if (e.graphMode === 6) {
              let R = k, N = S;
              S = R * Math.cos(N), k = R * Math.sin(N);
              let M = A, F = _;
              _ = M * Math.cos(F), A = M * Math.sin(F);
            }
            e.graphMode === 1 && ([S, k] = [k, S], [_, A] = [A, _]);
            let [P, O] = l.mapCoordinatePair([S, k]),
              [U, z] = l.mapCoordinatePair([_, A]),
              x = __dcg_shared_module_exports__["V"](
                0,
                0,
                P - a,
                O - s,
                U - a,
                z - s,
              ),
              L = __dcg_shared_module_exports__["MathHypot"](x[0], x[1]);
            x[e.graphMode === 1 ? 1 : 0] < 0
              ? L < d && (d = L, h = x)
              : L < p && (p = L, u = x);
          }
        }
        let f = d < p ? h : u;
        if (!f) return;
        let y = f[0] + a, C = f[1] + s;
        return {
          closestPoint: { x: y, y: C },
          minDistance: Math.min(d, p),
          secondDistance: Math.max(d, p),
        };
      }
      static getBranchesTracePoint(e, t, o, i) {
        let n, a = o.pixelsToMath.mapPoint(t);
        switch (e.graphMode) {
          case 20:
          case 21: {
            let O = e.graphMode === 21 ? e.segments[0][3] : 0,
              U = e.graphMode === 21 ? e.segments[0][4] : Math.PI * 2;
            n = __dcg_shared_module_exports__["X"](
              a.x,
              a.y,
              e.segments[0][0],
              e.segments[0][1],
              e.segments[0][2],
              O,
              U,
            );
            break;
          }
          case 18:
          case 19:
          case 17:
            n = __dcg_shared_module_exports__["W"](
              a.x,
              a.y,
              e.segments[0][0],
              e.segments[0][1],
              e.segments[0][2],
              e.segments[0][3],
              e.graphMode === 18,
              e.graphMode !== 17,
            );
            break;
        }
        if (n) return { x: n[0], y: n[1] };
        if (!e) return;
        let s = "compiled" in e && e.compiled, l = s && s.fn;
        if (!l) return;
        let c = this.getBranchesDistanceInfo(e, t, o, false, i);
        if (!c) return;
        let { mathToPixels: d, pixelsToMath: p } = o, h, u;
        e.graphMode === 2
          ? (u = "x", h = "y")
          : (u = "y",
            h = "x",
            d = new __dcg_shared_module_exports__["jd"](
              d.yScale,
              d.xScale,
            ),
            p = d.inverse());
        let f = Math.pow(c.minDistance / c.secondDistance, 2),
          y = c.closestPoint[u] * (1 - f) + t[u] * f,
          C = .5,
          E = .5,
          v = d.mapY(l(p.mapX(y - C))),
          w = d.mapY(l(p.mapX(y))),
          S = d.mapY(l(p.mapX(y + C))),
          k = C * Math.min(1, E / Math.abs(v - w)),
          _ = C * Math.min(1, E / Math.abs(S - w));
        isFinite(k) || (k = C), isFinite(_) || (_ = C);
        let A = ho(p.mapX(y - k), p.mapX(y + _)), P = l(A);
        if (!isFinite(d.mapY(P))) {
          let O = d.mapX(A) - C,
            U = d.mapX(A) + C,
            z = p.mapX(O),
            x = p.mapX(U),
            L = l(z),
            V = l(x),
            R = d.mapY(L),
            N = d.mapY(V);
          Math.abs(R - t[h]) < Math.abs(N - t[h]) ? P = L : P = V;
        }
        return {
          x: e.graphMode === 2 ? A : P,
          y: e.graphMode === 2 ? P : A,
        };
      }
      getPointInfo(e) {
        switch (e.type) {
          case "movable-point":
          case "static-labeled-point":
            return A6(e);
          case "poi":
            return A6(e.poi.getMovablePoint());
          case "movable-point-parent":
            return { calcId: e.id, isReverseDrag: true };
          case "image":
            return {
              calcId: e.image.formula.center_reference_id,
              isReverseDrag: false,
            };
          case "draggable-label":
            return { calcId: e.model.id, isReverseDrag: false };
          default:
            return e;
        }
      }
      getDraggablePointOrAncestors(e, t) {
        if (!this.controller.isGeometry()) {
          let l = this.controller.getItemModel(e);
          if (l && l.type === "expression" && xT(l)) {
            let c = SH(l);
            return c
              ? Ro(l) === "NONE" ? [] : [{
                type: "movable-point-parent",
                id: e,
                shouldDelayUntilRealMove: true,
                ...c,
              }]
              : [];
          }
        }
        let o = [e];
        (this.isBoxSelectActive(t) ||
          this.controller.isItemSelected(e)) &&
          o.push(
            ...this.controller.getAllSelectedItems().map((l) => l.id)
              .filter((l) => l !== e),
          );
        let i = false, n = {}, a = [];
        Qg({ controller: this.controller }, (l, c) => {
          if (
            !c &&
            l.typedRuntimeValue.valueType ===
              __dcg_shared_module_exports__["Point"] &&
            l.data.isMovablePoint
          ) {
            let [d, p] = l.typedRuntimeValue.value;
            n[l.calcId] = { id: l.calcId, value: { x: d, y: p } };
          }
        });
        let s = this.controller.getGeoModel().getComputedBoard()
          .computeReversibilityLineages(o);
        for (let l in s) {
          let c = n[l];
          if (!c) {
            i = true;
            break;
          }
          a.push({
            type: "movable-point-parent",
            id: l,
            x: c.value.x,
            y: c.value.y,
            shouldDelayUntilRealMove: true,
            transformations: s[l],
          });
        }
        return i ? [] : a;
      }
      getFeatureCenterMathPoint(e) {
        switch (e.type) {
          case "poi":
            return e.poi;
          case "movable-point-parent":
            let t = { x: e.x, y: e.y };
            if (e.transformations) {
              let o = __dcg_shared_module_exports__["transformPoint"](
                e.transformations.forward,
                [t.x, t.y],
              );
              t = { x: o[0], y: o[1] };
            }
            return t;
          case "image":
            return {
              x: e.image.formula.dimensions.x[0],
              y: e.image.formula.dimensions.y[0],
            };
          case "draggable-label":
            return { x: e.label.x, y: e.label.y };
        }
      }
      startReverseDrag(e, t, o) {
        let i = this.getMouseRelativeToGrapher(t),
          n = this.getDraggablePointOrAncestors(e, t).map((a) => ({
            ...a,
            startScreenPt: i,
          }));
        return n.length > 0
          ? (this.startMovingPoints({
            poiUnderMouse: o,
            evt: t,
            points: n,
            originalTargetObjectId: e,
          }),
            true)
          : false;
      }
      startMovingPoints(e) {
        let t = e.points,
          o = false,
          i = t.map(this.getPointInfo),
          n = this.controller;
        function a() {
          o = true, n.dispatch({ type: "start-moving-points", points: i });
        }
        let s = false;
        for (let h of t) {
          if (h.shouldDelayUntilRealMove) {
            s = true;
            break;
          }
        }
        s || a();
        let l;
        e.poiUnderMouse && e.poiUnderMouse.isMovable() &&
        (l = e.poiUnderMouse.getMovablePoint().id),
          this.manager.movablePointsLayer.setPressedPointId(l);
        let c = t.map((h) => {
            let u = this.manager.getProjection().map_pt(
              this.getFeatureCenterMathPoint(h),
            );
            return {
              x: h.startScreenPt.x - u.x,
              y: h.startScreenPt.y - u.y,
            };
          }),
          d,
          p = () => {
            if (!d) return;
            this.shouldTreatSmallDragAsClick(e.evt, d) ||
            this.controller.dispatch({
              type: "clear-tentative-selection",
            }), o || a();
            let h = this.manager.getProjection(),
              u = this.getMouseRelativeToGrapher(d);
            d = void 0,
              this.controller.dispatch({
                type: "on-move-points",
                points: t.map(this.getPointInfo),
                screenPts: c.map((f) => ({ x: u.x - f.x, y: u.y - f.y })),
                transform: t.map((f) =>
                  f.type === "movable-point-parent" ? f.transformations : void 0
                ),
                previousScreenPts: t.map((f) => f.startScreenPt),
                projection: h,
              });
          };
        this.manager.registerMovablePointListener(p),
          this.addGlobalMouseListener("dcg-tapmove", (h) => {
            d = h;
          }),
          this.addGlobalMouseListener("dcg-tapend dcg-tapcancel", (h) => {
            p(),
              this.manager.deregisterMovablePointListener(),
              this.removeAllGlobalMouseListeners(),
              this.manager.movablePointsLayer.setPressedPointId(void 0),
              o &&
              (h.handle("dragged-clickable-object"),
                this.controller.dispatch({
                  type: "stop-moving-points",
                  points: t.map(this.getPointInfo),
                }));
          });
      }
      startTracingBranch(e, t) {
        if (!e.isTraceable) return;
        let o = e.branchInfo;
        this.manager.markLabelsDirty(), this.lastScreenPt = t;
        let i = this.manager.getProjection(),
          a = o.sketch.branches[o.branch],
          s = r.getBranchesTracePoint(
            a,
            t,
            i,
            this.controller.isGeometry(),
          );
        s && this.speakPoint(s),
          this.manager.traceLayer.setTraceInfo({ pt: s, branchInfo: o }),
          this.controller.requestRedrawGraph(),
          this.addGlobalMouseListener(
            "dcg-tapmove",
            this.handleTraceUpdate.bind(this),
          ),
          this.addGlobalMouseListener(
            "dcg-tapend dcg-tapcancel",
            this.stopTracingBranch.bind(this),
          );
      }
      stopTracingBranch(e) {
        this.manager.markLabelsDirty();
        let t = this.manager.poiLabelsLayer.getHoveredPOI();
        t && !this.manager.poiLabelsLayer.isOpenPOI(t) &&
        (this.manager.poiLabelsLayer.openPOI(t),
          this.speakPoint(t),
          this.controller.requestRedrawGraph()),
          this.lastScreenPt = void 0,
          this.manager.traceLayer.setTraceInfo(void 0),
          this.controller.requestRedrawGraph(),
          this.removeAllGlobalMouseListeners();
      }
      handleTraceUpdate(e) {
        if (!this.manager.traceLayer.traceInfo) return;
        let t = this.manager.getProjection(), o;
        if (e) {
          o = this.getMouseRelativeToGrapher(e),
            this.lastScreenPt = o,
            this.manager.markLabelsDirty();
        } else if (this.lastScreenPt) o = this.lastScreenPt;
        else return;
        let i = 1 / 0,
          n = -1,
          a = this.manager.traceLayer.traceInfo,
          s = this.manager.graphSketches[a.branchInfo.sketch.id];
        if (!s) return;
        a.branchInfo.sketch = s;
        let l = a.branchInfo.sketch.branches;
        for (let p = 0; p < l.length; p++) {
          let h = this.calculateDistanceFromBranch(l[p], o, t, false);
          h < i && (n = p, i = h);
        }
        let c = l[n],
          d = c
            ? r.getBranchesTracePoint(
              c,
              o,
              t,
              this.controller.isGeometry(),
            )
            : void 0;
        d && this.speakPoint(d),
          this.manager.traceLayer.traceInfo.branchInfo.branch = n,
          this.manager.traceLayer.traceInfo.pt = d,
          this.controller.requestRedrawGraph();
      }
      hasNonlinearMoveStrategy(e) {
        if (!e || e.type !== "movable-point-parent") return false;
        let t = this.controller.getItemModel(e.id);
        if (!t || t.type !== "expression" || !t.formula) return false;
        let o = t.formula.move_strategy;
        return !o || !o[0] ? false : o[0].type === "updateSliderNonlinear";
      }
      movePointsFromKeyboard(e, t) {
        if (!t) return;
        let o = this.manager.getProjection(),
          i = e.map((u) => {
            let { x: f, y } = o.map_pt(this.getFeatureCenterMathPoint(u));
            return { x: f, y };
          }),
          n = 0,
          a = 0,
          s = ke(t),
          l = (o.pixelCoordinates.right - o.pixelCoordinates.left) / 40,
          c = (o.pixelCoordinates.bottom - o.pixelCoordinates.top) / 40,
          d = s === "Up" || s === "Down" ? c : l;
        d = t.shiftKey ? d * 5 : d;
        let p, h;
        if (
          s === "Up"
            ? (h = "y", a -= d, p = t.shiftKey ? "bigup" : "up")
            : s === "Down"
            ? (h = "y", a += d, p = t.shiftKey ? "bigdown" : "down")
            : s === "Left"
            ? (h = "x", n -= d, p = t.shiftKey ? "bigdown" : "down")
            : s === "Right" &&
              (h = "x", n += d, p = t.shiftKey ? "bigup" : "up"), p
        ) {
          let u = i.map(({ x: y, y: C }) => ({ x: y + n, y: C + a })), f;
          h === "x" || e.some((y) => this.hasNonlinearMoveStrategy(y))
            ? f = { x: p }
            : h === "y" && (f = { y: p }),
            this.controller.dispatch({
              type: "on-move-points",
              points: e.map((y) => this.getPointInfo(y)),
              screenPts: u,
              previousScreenPts: i,
              transform: e.map((y) =>
                y.type === "movable-point-parent" ? y.transformations : void 0
              ),
              projection: o,
              keyboardDirection: f,
            });
        }
      }
      getGeoKeyboardPt() {
        return this.initGeoKeyboardPt(), this.geoKeyboardPt;
      }
      setGeoKeyboardPt(e) {
        this.geoKeyboardPt = { ...this.geoKeyboardPt, x: e.x, y: e.y },
          e.fromArrowKeys &&
          (this.geoKeyboardPt.lastArrowedX = e.x,
            this.geoKeyboardPt.lastArrowedY = e.y),
          this.controller.requestRedrawGraph();
      }
      initGeoKeyboardPt() {
        if (
          !isNaN(this.geoKeyboardPt.x) && !isNaN(this.geoKeyboardPt.y)
        ) return;
        let e = this.manager.getProjection();
        if (!e) return;
        let t = e.viewport,
          o = gl(e),
          i = o.minorStepX,
          n = o.minorStepY,
          a = Math.round((t.xmin + t.xmax) / 2 / i) * i,
          s = Math.round((t.ymin + t.ymax) / 2 / n) * n;
        this.setGeoKeyboardPt({ x: a, y: s });
      }
      moveGeoPointFromKeyboard(e) {
        if (!e) return;
        this.initGeoKeyboardPt();
        let t = this.manager.getProjection();
        if (!t) return;
        let o = t.viewport,
          i = gl(t),
          n = i.minorStepX / 4,
          a = i.minorStepY / 4,
          s = this.geoKeyboardPt.x,
          l = this.geoKeyboardPt.y,
          c = ke(e);
        c === "Down"
          ? e.ctrlKey
            ? l = o.ymin
            : l = Math.max(Math.round((l - a) / a) * a, o.ymin)
          : c === "Up"
          ? e.ctrlKey
            ? l = o.ymax
            : l = Math.min(Math.round((l + a) / a) * a, o.ymax)
          : c === "Left"
          ? e.ctrlKey
            ? s = o.xmin
            : s = Math.max(Math.round((s - n) / n) * n, o.xmin)
          : c === "Right" &&
            (e.ctrlKey
              ? s = o.xmax
              : s = Math.min(Math.round((s + n) / n) * n, o.xmax)),
          !(s === this.geoKeyboardPt.x && l === this.geoKeyboardPt.y) &&
          (this.setGeoKeyboardPt({ x: s, y: l, fromArrowKeys: true }),
            this.handleGeoKeyboardPtMove(e),
            this.controller.getEvaluator().notifyWhenSynced(() => {
              yt(
                ll(
                  this.controller,
                  this.geoKeyboardPt.x,
                  this.geoKeyboardPt.y,
                ),
              );
              let d = this.manager.clickableObjectsLayer
                  .getHoveredObjects(),
                p = [];
              for (let h in d) {
                let u = this.controller.getItemModel(h, {
                  includePreviewItems: true,
                });
                u !== void 0 &&
                  p.push(
                    Fo(u, this.controller, {
                      includeDetails: false,
                      depth: this.controller.isToolPreviewItem(h) ? 0 : 1,
                    }),
                  );
              }
              p.length &&
              yt(
                this.controller.s(
                  "graphing-calculator-narration-geometry-near-item",
                  { item: Cd(this.controller.getLanguage(), p) },
                ),
              ), xe();
            }));
      }
      handleGeoKeyboardPtMove(e) {
        this.initGeoKeyboardPt();
        let t = this.controller.getGeoModel(), o = !!(e && e.shiftKey);
        t.onMouseAction("move", {
          pt: this.geoKeyboardPt,
          shift: o,
          tolerance: this.getToleranceByDevice("keyboard"),
        }), t.onPreviewChange();
      }
      activateGeoObjectFromKeyboard(e, t) {
        e != null && e.geoDef
          ? this.tapGeoObjectFromKeyboard(e.geoDef, t)
          : this.tapGeoPointFromKeyboard(t);
      }
      tapGeoObjectFromKeyboard(e, t) {
        var a;
        let o = this.controller.getGeoModel(), i = o.getCurrentTool();
        if (!i) return;
        i.onFocus(e);
        let n = i.tryCommitResults();
        n.committed &&
        this.controller.dispatch({
          type: "commit-geo-objects",
          shiftKey: t.shiftKey,
          ...n,
        }),
          o.updateNextObjectId(o.controller.findLastTokenNumber() + 1),
          o.clearHoveredObjects(),
          o.onPreviewChange(),
          this.speakGeoReleaseAction(
            this.controller.getActiveTool(),
            (a = i.getSpec) == null ? void 0 : a.call(i),
            n.committed,
          ),
          this.keyboardAttentionManager.clearAttentionIfNotTabbable();
      }
      tapGeoPointFromKeyboard(e) {
        var l;
        this.initGeoKeyboardPt();
        let t = this.controller.getGeoModel(),
          o = this.controller.getActiveTool(),
          i = t.getCurrentTool(),
          n = (l = i.getSpec) == null ? void 0 : l.call(i),
          a = !!e.shiftKey,
          s = t.onMouseAction("release", {
            pt: this.geoKeyboardPt,
            shift: a,
            tolerance: this.getToleranceByDevice("keyboard"),
          });
        s.committed &&
        this.controller.dispatch({
          type: "commit-geo-objects",
          shiftKey: e.shiftKey,
          ...s,
        }),
          t.onMouseAction("move", {
            pt: this.geoKeyboardPt,
            shift: a,
            tolerance: this.getToleranceByDevice("keyboard"),
          }),
          t.onPreviewChange(),
          this.speakGeoReleaseAction(o, n, s.committed),
          this.keyboardAttentionManager.clearAttentionIfNotTabbable();
      }
      speakGeoReleaseAction(e, t, o) {
        var i;
        if (o !== void 0) {
          let n = Object.keys(o);
          if (!n.length || !t) return;
          let a = "";
          if (e === "point" || e === "expression-edit") {
            for (let s in o) {
              let l = o[s];
              if (l) {
                if (l.type === "point-reference") {
                  a = this.controller.s(
                    "graphing-calculator-text-geometry-tool-point-display-name",
                  );
                  break;
                } else if (l.type === "intersection") {
                  a = this.controller.s(
                    "graphing-calculator-text-geometry-intersection",
                  );
                  break;
                } else if (l.type === "glider") {
                  a = this.controller.s(
                    "graphing-calculator-text-geometry-glider",
                  );
                  break;
                } else if (l.type === "vector-endpoint") {
                  l.location === "start"
                    ? a = this.controller.s(
                      "graphing-calculator-text-geometry-tool-vector-start-point-display-name",
                    )
                    : a = this.controller.s(
                      "graphing-calculator-text-geometry-tool-vector-end-point-display-name",
                    );
                  break;
                }
              }
            }
            a === "" &&
              (a = this.controller.s(
                "graphing-calculator-text-geometry-tool-point-display-name",
              ));
          } else {
            let s = (i = t.outputs[0]) == null ? void 0 : i.type;
            switch (s) {
              case "arc":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-arc-display-name",
                );
                break;
              case "circle":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-circle-display-name",
                );
                break;
              case "line":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-line-display-name",
                );
                break;
              case "segment":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-segment-display-name",
                );
                break;
              case "ray":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-ray-display-name",
                );
                break;
              case "vector-copy":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-vector-copy-display-name",
                );
                break;
              case "vector":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-vector-display-name",
                );
                break;
              case "parallel":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-parallel-display-name",
                );
                break;
              case "perpendicular":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-perpendicular-display-name",
                );
                break;
              case "anglebisector":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-angle-bisector-display-name",
                );
                break;
              case "midpoint":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-midpoint-display-name",
                );
                break;
              case "polygon":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-polygon-display-name",
                );
                break;
              case "angle":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-angle-display-name",
                );
                break;
              case "directedangle":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-directed-angle-display-name",
                );
                break;
              case "reflect":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-reflect-display-name",
                );
                break;
              case "translate":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-translate-display-name",
                );
                break;
              case "dilate":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-dilate-display-name",
                );
                break;
              case "rotate":
                a = this.controller.s(
                  "graphing-calculator-text-geometry-tool-rotate-display-name",
                );
                break;
              case "vector-endpoint":
              case "expression-edit-preview-latex":
              case "point":
              case "intersection":
              case "glider":
              case "slider":
              case "polygon-angle":
              case "polygon-directedangle":
              case "compass":
              case "polygon-segment":
              case "point-reference":
              case void 0:
                a = this.controller.s(
                  "shared-calculator-narration-item-unknown",
                );
                break;
              default:
                let l = s;
                throw new Error("Exhaustive Check failed" + l);
            }
          }
          n.length === 1
            ? xe(
              this.controller.s(
                "graphing-calculator-narration-geometry-added-object-type",
                { type: a },
              ),
            )
            : a !== "graphing-calculator-text-geometry-point"
            ? n.length === 2
              ? xe(
                this.controller.s(
                  "graphing-calculator-narration-geometry-added-object-type-and-point",
                  { type: a },
                ),
              )
              : xe(
                this.controller.s(
                  "graphing-calculator-narration-geometry-added-object-type-and-points",
                  { type: a, points: n.length - 1 },
                ),
              )
            : xe(
              this.controller.s(
                "graphing-calculator-narration-geometry-added-points",
                { points: n.length },
              ),
            );
        } else this.controller.getGeoModel().speakCurrentGeoToolHint();
      }
      describeFocusedItem(e) {
        let t = this.keyboardAttentionManager.getKeyboardAttention(),
          o = this.controller.getItemModel(
            (t == null ? void 0 : t.calcId) || "",
          );
        this.controller.getEvaluator().notifyWhenSynced(() => {
          var i, n;
          if (
            !this.controller.isGeometry() && o && o.type === "image" &&
            ((i = this.manager.imageLayer.getFocusedImage()) == null
                ? void 0
                : i.id) === o.id
          ) {
            this.manager.imageLayer.speakAriaAlert();
            return;
          }
          o &&
              ((n = this.manager.movablePointsLayer
                    .getPOIUnderAttention()) == null
                  ? void 0
                  : n.sketch.id) === o.id &&
              this.manager.movablePointsLayer.speakAriaAlert() ||
            xe(Fo(o, this.controller, {
              includeDetails: e.includeDetails,
              description: t == null ? void 0 : t.description,
              poi: this.manager.movablePointsLayer.getPOIUnderAttention(),
              listIndex: t == null ? void 0 : t.listIndex,
              polygonEdge: t == null ? void 0 : t.polygonEdge,
              includeSelectionState: this.controller.isGeometry() &&
                (this.controller.getActiveTool() === "box-selection" ||
                  this.controller.getActiveTool() === "selection"),
            }));
        });
      }
      getPointFromFocusedItem() {
        var d;
        let e = this.keyboardAttentionManager.getKeyboardAttention(),
          t = this.controller.getItemModel(
            (e == null ? void 0 : e.calcId) || "",
          );
        if (!t || t.type !== "expression" || !t.latex) return;
        let o = t.formula.typed_constant_value;
        if (!o || !this.manager.getProjection()) return;
        let n = o.valueType, a = o.value;
        if (__dcg_shared_module_exports__["isList"](o.valueType)) {
          let p = e == null ? void 0 : e.listIndex;
          p && (n = __dcg_shared_module_exports__["elementType"](n), a = a[p]);
        }
        let s = e == null ? void 0 : e.polygonEdge;
        if (
          n === __dcg_shared_module_exports__["Polygon"] && s !== void 0 &&
          s >= 0 && a.length > s
        ) {
          let p = a[s], h = a[(s + 1) % a.length];
          n = __dcg_shared_module_exports__["Segment"], a = [p, h];
        }
        let l = NaN, c = NaN;
        return n === __dcg_shared_module_exports__["Point"]
          ? (l = a[0], c = a[1])
          : n === __dcg_shared_module_exports__["Line"] ||
              n === __dcg_shared_module_exports__["Ray"] ||
              n === __dcg_shared_module_exports__["Segment"]
          ? (l = (a[0][0] + a[1][0]) / 2, c = (a[0][1] + a[1][1]) / 2)
          : n === __dcg_shared_module_exports__["Vector"]
          ? (l = a[1][0] + a[0][0] / 2, c = a[1][1] + a[0][1] / 2)
          : (d = a[0]) != null && d.length && (l = a[0][0], c = a[0][1]),
          { x: l, y: c };
      }
      moveGeoKeyboardPtToFocusedItem(e) {
        let t = this.getPointFromFocusedItem();
        if (!t) return;
        let { x: o, y: i } = t,
          n = this.keyboardAttentionManager.getKeyboardAttention(),
          a = this.controller.getFocusLocation(),
          s = a && a.type === "expression" && a.isFakeGraphFocus;
        this.controller.getGeoModel().setObjectHovered({
          calcId: (n == null ? void 0 : n.calcId) || "",
          listIndex: void 0,
        }),
          !isNaN(o) && !isNaN(i)
            ? (this.setGeoKeyboardPt({ x: o, y: i }),
              !s && this.controller.isVirtualMouseAllowed() &&
              e.describe &&
              xe(
                this.controller.s(
                  "graphing-calculator-narration-geometry-moved-to-coordinates",
                  {
                    x: Bl(this.controller, o),
                    y: Ul(this.controller, i),
                  },
                ),
              ))
            : !s && this.controller.isVirtualMouseAllowed() &&
              e.describe &&
              xe(
                this.controller.s(
                  "graphing-calculator-narration-geometry-unable-to-move",
                ),
              );
      }
      speakPoint(e, t) {
        if (
          !(!e || !this.manager.getAudioTrace() ||
            !this.manager.getProjection())
        ) {
          switch (t) {
            case "X":
              xe(Bl(this.controller, e.x));
              break;
            case "Y":
              xe(Ul(this.controller, e.y));
              break;
            case "L":
              "ariaLabel" in e && e.ariaLabel ? xe(e.ariaLabel) : xe(
                this.controller.s(
                  "graphing-calculator-narration-poi-graph-point",
                ),
              );
              break;
            case "C":
              "sketch" in e && xe(md(this.controller, e.sketch.color));
          }
        }
      }
      selectItemIfNotSecret(e, t) {
        this.controller.isItemNotSelectableBecauseItsSecret(e) ||
          (!this.controller.isMultiSelectEnabled() || !t.multiSelect
            ? this.controller.dispatch({
              type: "set-selected-id",
              id: e,
              state: t.tentative ? "tentatively-selected" : "selected",
            })
            : this.controller.dispatch({
              type: "toggle-selected-with-multi-select",
              id: e,
              state: t.tentative ? "tentatively-selected" : "selected",
            }));
      }
      convertTouchEventToMathPoint(e) {
        let { clientX: t, clientY: o } = e.changedTouches[0],
          i = this.manager.elt.getBoundingClientRect();
        return this.controller.getGeoModel().convertCanvasPixelsToPoint({
          x: t - i.left,
          y: o - i.top,
        });
      }
      handleGeoTapStart(e, t) {
        let o = this.controller.getGeoModel();
        this.canceledGeoToolplayWhilePressed = false;
        let i = e.shift;
        return o.onMouseAction("move", {
            pt: e.mathPoint,
            shift: i,
            tolerance: this.getToleranceByDevice(e.device),
          }).handled
          ? (e.device === "mouse"
            ? this.handleGeoTapMove(e)
            : (o.onPreviewChange(), this.updateGeoHoveredObjects()),
            o.getToolMode() === "expression-edit" && t.preventDefault(),
            true)
          : false;
      }
      updatePointerState(e) {
        var n;
        let t = e.target && e.target instanceof HTMLElement &&
            e.target.closest(".dcg-geometry-toolbar-view"),
          o = this.isEventWithinInstance(e),
          i;
        return e.type === "dcg-tapstart"
          ? i = true
          : e.type === "dcg-tapend"
          ? i = false
          : i = !!((n = this.pointerState) != null && n.isPressed),
          this.pointerState = {
            mathPoint: this.convertTouchEventToMathPoint(e),
            device: e.device,
            shift: !!e.shiftKey,
            isPressed: i,
            isOnToolbar: t,
            isWithinInstance: o,
          },
          (e.type === "dcg-tapmove" || e.type === "dcg-tapstart") &&
          this.updateClickToInsertMode(),
          this.pointerState;
      }
      updateClickToInsertMode() {
        var o;
        let e = this.pointerState;
        if (
          !e || !this.controller.isGeometry() ||
          ((o = this.controller.getFocusLocation()) == null
              ? void 0
              : o.type) !== "expression"
        ) return;
        let t = this.controller.getGeoModel();
        t.getClickToInsertMode() !== "permissive" && e.shift
          ? t.getObjectDefUnderMouse(
            e.mathPoint,
            this.getToleranceByDevice(e.device),
            {
              shouldUseJitEdges: () => true,
              isValidNextInputType: () => true,
            },
          ) &&
            this.controller.dispatch({
              type: "update-click-to-insert-mode",
              clickToInsertMode: "permissive",
            })
          : t.getClickToInsertMode() === "permissive" && !e.shift &&
            this.controller.dispatch({
              type: "update-click-to-insert-mode",
              clickToInsertMode: "valid-type",
            });
      }
      handleShiftKeyChange(e) {
        let t = this.pointerState;
        if (
          !(!t || t.shift === e) &&
          (t.shift = e,
            this.updateClickToInsertMode(),
            this.controller.isGeoToolActive())
        ) {
          let o = this.controller.getGeoModel();
          o.onMouseAction("move", {
            pt: t.mathPoint,
            shift: t.shift,
            tolerance: this.getToleranceByDevice("mouse"),
          }), o.onPreviewChange();
        }
      }
      handleGeoTapMove(e) {
        let t = this.controller.getGeoModel(), o;
        return !e.isOnToolbar && (e.isWithinInstance || e.isPressed)
          ? o = t.onMouseAction("move", {
            pt: e.mathPoint,
            shift: e.shift,
            tolerance: this.getToleranceByDevice(e.device),
          }).handled
          : (t.onMouseAction("move", {
            pt: { x: NaN, y: NaN },
            shift: false,
            tolerance: 0,
          }),
            o = true),
          t.onPreviewChange(),
          o;
      }
      replayGeoTapMove() {
        let e = this.controller.getGeoModel(), t = this.pointerState;
        t &&
          (e.onMouseAction("move", {
            pt: { ...t.mathPoint },
            shift: t.shift,
            tolerance: this.getToleranceByDevice("mouse"),
          }),
            e.onPreviewChange());
      }
      handleGeoTapEnd(e, t) {
        var l;
        let o = this.controller.getGeoModel(),
          i = this.canceledGeoToolplayWhilePressed
            ? { committed: void 0 }
            : o.onMouseAction("release", {
              pt: e.mathPoint,
              shift: e.shift,
              tolerance: this.getToleranceByDevice(e.device),
            });
        this.canceledGeoToolplayWhilePressed = false,
          i.committed &&
          this.controller.dispatch({
            type: "commit-geo-objects",
            shiftKey: e.shift,
            ...i,
          }),
          e.isWithinInstance && e.device === "mouse"
            ? this.handleGeoTapMove(e)
            : o.onPreviewChange();
        let n = this.controller.getActiveTool(),
          a = o.getCurrentTool(),
          s = (l = a.getSpec) == null ? void 0 : l.call(a);
        this.speakGeoReleaseAction(n, s, i.committed),
          o.getToolMode() === "expression-edit" && t.preventDefault();
      }
      isEventWithinInstance(e) {
        return e.target ? this.manager.elt.contains(e.target) : false;
      }
      updateGeoHoveredObjects() {
        let e = this.controller.getGeoModel(), t = {};
        e.getHoveredItems().forEach((o) => {
          let i;
          if ("tokenId" in o) {
            let n = this.controller.getGeoTokenInfoFromIdentifier(
              __dcg_shared_module_exports__["latexToIdentifier"](o.tokenId),
            );
            i = n && n.calcId;
          } else i = o.calcId;
          if (i !== void 0) {
            let n = t[i];
            n
              ? o.listIndex === void 0
                ? n.listIndexes = void 0
                : n.listIndexes !== void 0 &&
                  (n.listIndexes[o.listIndex] = true)
              : t[i] = {
                listIndexes: o.listIndex === void 0
                  ? void 0
                  : { [o.listIndex]: true },
              };
          }
        }),
          this.manager.clickableObjectsLayer.setHoveredObjects(t),
          this.manager.movablePointsLayer.setGeoHoveredObjects(
            this.controller.getActiveTool() === "point" ? {} : t,
          );
      }
      cancelGeoToolplay() {
        var e;
        this.canceledGeoToolplayWhilePressed =
          !!((e = this.pointerState) != null && e.isPressed),
          this.updateGeoHoveredObjects();
      }
      startBoxSelect(e) {
        let t = {};
        this.controller.getAllSelectedItems().forEach((n) => t[n.id] = true);
        let o = this.manager.getProjection().reverse_map_pt(
            this.getMouseRelativeToGrapher(e),
          ),
          i;
        this.addGlobalMouseListener("dcg-tapmove", (n) => {
          i = this.manager.getProjection().reverse_map_pt(
            this.getMouseRelativeToGrapher(n),
          );
          let a = {
            left: Math.min(o.x, i.x),
            top: Math.min(o.y, i.y),
            right: Math.max(o.x, i.x),
            bottom: Math.max(o.y, i.y),
          };
          this.manager.setBoxSelectRectangle(a);
          let s = this.findIdsThatIntersectBox(a);
          this.controller.dispatch({
            type: "set-all-selected-ids",
            ids: { ...t, ...s },
          });
        }),
          this.addGlobalMouseListener("dcg-tapend dcg-tapcancel", (n) => {
            this.removeAllGlobalMouseListeners(),
              this.manager.setBoxSelectRectangle(void 0),
              i ||
              this.controller.dispatch({ type: "set-none-selected" });
          });
      }
    };
  function A6(r) {
    return {
      calcId: r.sketch.id,
      isReverseDrag: false,
      scaleFactor: r.type === "movable-point" ? r.scaleFactor : void 0,
      tableInfo: r.type === "movable-point" ? r.tableInfo : void 0,
    };
  }
  var gk = class {
    constructor(e) {
      this.savedPOI = [], this.controller = e;
    }
    redrawToCtx(e, t, o, i, n) {
      let { ctx: a, projection: s } = e, l = [];
      for (let c of Rv(n)) {
        let d = t[c];
        if (!d) continue;
        if (d.hoistToTop && !this.controller.isGeometry()) {
          let h = d.showHighlight;
          h && e.projection.settings.setProperty("highlight", true),
            Td.drawSketchToCtx({
              sketch: d,
              drawContext: e,
              poiLabelsLayer: o,
              clickableObjectsLayer: i,
              geometryContext: this.controller.getGeoModel(),
            }),
            h && e.projection.settings.setProperty("highlight", false);
        }
        let p = d.getPOI();
        (d.showPOI || p.length && p[0].isAttachedToPlottedPoint()) &&
          l.push.apply(l, this.drawPOIs(p, a, s));
      }
      this.savedPOI = l;
    }
    getDrawnPOI() {
      return this.savedPOI;
    }
    drawPOIs(e, t, o) {
      t.lineWidth = o.settings.pointLineWidth,
        t.strokeStyle = "#AAAAAA",
        t.fillStyle = "#AAAAAA",
        t.lineJoin = "round",
        t.lineCap = "round";
      let i = [];
      if (e.length && e[0].isAttachedToPlottedPoint()) {
        for (let n of e) Td.mapPointToScreen(o, n.x, n.y) && i.push(n);
      } else {for (let n of e) {
          Td.drawPointToCtx({ ctx: t, projection: o, ...n }) && i.push(n);
        }}
      return i;
    }
  };
  mg();
  var Wp = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    mk = class extends Wp.Class {
      template() {
        return Wp.createElement(
          "div",
          {
            class: this.const(cf),
            style: () => ({
              width: this.props.width(),
              height: this.props.height(),
              position: "fixed",
              left: "0px",
              top: "0px",
            }),
          },
          Wp.createElement(
            "div",
            { class: Wp.const("dcg-container") },
            Wp.createElement("div", {
              class: Wp.const("dcg-grapher"),
              style: () => ({
                "font-size": this.props.concreteFontSize(),
              }),
            }),
          ),
        );
      }
    };
  var kPe = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Ic = class extends _c {
    generateDefaultName() {
      return "does not matter";
    }
  };
  var M6 = "graphing-calculator-text-geometry-tool-rotation-hint-center",
    Hne = "graphing-calculator-text-geometry-tool-rotation-hint-angle",
    Kne = "graphing-calculator-text-geometry-tool-rotation-hint-angle-start",
    Wne = "graphing-calculator-text-geometry-tool-rotation-hint-angle-end",
    im = class extends Ic {
      constructor(t) {
        super(t);
        this.model = t;
        this.displayName =
          "graphing-calculator-text-geometry-tool-rotate-display-name",
          this.toolName = "rotation",
          this.toolType = "transformation";
      }
      getMode() {
        let { idMap: t } = this.model.getNonObjectsState().ui.currentTool;
        return t["2-number"] ? "number" : "directed-angle";
      }
      getExpressionEditHint(t) {
        return t === 0 ? this.s(M6) : this.s(Hne);
      }
      onNumberInput(t) {
        super.onNumberInput(t), this.clearTentativeOutputs();
      }
      onMove(t) {
        return this.getMode() === "number" &&
            this.model.getNonObjectsState().ui.currentTool.inputIndex ===
              1
          ? false
          : super.onMove(t);
      }
      getSpecIdToLockIn(t, o) {
        if (o === 1) {
          let i = t.inputs[o];
          return this.getMode() === "number" ? `${i.id}-number` : i.id;
        }
        return super.getSpecIdToLockIn(t, o);
      }
      getPartialAnglePreviewInfo() {
        let { inputIndex: t, idMap: o } =
          this.model.getNonObjectsState().ui.currentTool;
        if (t > 0) {
          let i = this.model.findDefsForInputId(o[1])[0];
          if (!i) return;
          let n = [i.typedRuntimeValue],
            a = this.model.findDefsForInputId(o[2])[0],
            s = this.model.findDefsForInputId(o[3])[0];
          if (
            a && s && n.push(a.typedRuntimeValue, s.typedRuntimeValue), i
          ) {
            return {
              id: o["angle-output"],
              type: "rotation-with-incomplete-angle",
              args: n,
            };
          }
        }
      }
      getSpec() {
        let t = {
            inputs: [{ type: "point", id: "1", hint: M6 }, {
              type: "union",
              valueTypes: [
                __dcg_shared_module_exports__["Point"],
                __dcg_shared_module_exports__["DirectedAngleMarker"],
              ],
              id: "2",
              hint: Kne,
              numberInputInfo: {
                defaultLatex: "",
                sliderInfo: {
                  value: this.model.controller.getDegreeMode()
                    ? "90"
                    : "1.57079632679",
                  min: "0",
                  max: this.model.controller.getDegreeMode() ? "360" : "2\\pi",
                },
              },
            }],
            outputs: [],
          },
          o = {
            id: "number-output",
            type: "rotate",
            hidden: this.getMode() !== "number",
            name: this.generateDefaultName(),
            parents: [{ type: "reference-input", id: "1" }, {
              type: "reference-input",
              id: "2-number",
            }],
          };
        if (this.getMode() === "directed-angle") {
          let { idMap: i, inputIndex: n } =
            this.model.getNonObjectsState().ui.currentTool;
          n > 1 && delete t.inputs[1].numberInputInfo;
          let a = i[2],
            s = false,
            l = a && this.model.findDefsForInputId(a)[0];
          s = !!(l &&
            l.typedRuntimeValue.valueType ==
              __dcg_shared_module_exports__["Point"]),
            s
              ? (t.inputs.push({ type: "point", id: "3", hint: Wne }),
                t.outputs.push({
                  id: "directed-angle",
                  type: "directedangle",
                  hidden: false,
                  showAngleLabel: false,
                  parents: [{ type: "reference-input", id: "2" }, {
                    type: "reference-input",
                    id: "1",
                  }, { type: "reference-input", id: "3" }],
                }, {
                  id: "angle-output",
                  type: "rotate",
                  hidden: false,
                  name: this.generateDefaultName(),
                  parents: [{ type: "reference-input", id: "1" }, {
                    type: "reference-input",
                    id: "directed-angle",
                  }],
                }))
              : t.outputs.push({
                id: "angle-output",
                type: "rotate",
                hidden: false,
                name: this.generateDefaultName(),
                parents: [{ type: "reference-input", id: "1" }, {
                  type: "reference-input",
                  id: "2",
                }],
              });
        } else t.outputs.push(o);
        return t;
      }
    };
  var G6 = "graphing-calculator-text-geometry-tool-vector-hint-start",
    $ne = "graphing-calculator-text-geometry-tool-vector-hint-end",
    jne = "graphing-calculator-text-geometry-tool-vector-copy-hint-end",
    Yne = {
      name: "vector",
      displayName: "graphing-calculator-text-geometry-tool-vector-display-name",
      toolType: "simple",
      icon: [
        {
          type: "stroked-path",
          path: [32, 68, 65, 35],
          lineWidth: "large",
          arrow: true,
        },
        { type: "point", x: 32, y: 68 },
        { type: "point", x: 68, y: 32 },
      ],
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [G6, $ne],
        },
        output: [{ type: "vector", parents: [0, 1] }],
      }, {
        input: {
          broadcast: false,
          types: [
            __dcg_shared_module_exports__["Vector"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [G6, jne],
        },
        output: [{ type: "vector-copy", parents: [0, 1] }],
      }],
    },
    qv = class extends Vr {
      constructor(t) {
        super(t, Yne);
        this.model = t;
      }
    };
  function Xne(r) {
    return Array.isArray(r) && r.length === 2 &&
      r.every((e) =>
        Array.isArray(e) && e.length === 2 &&
        e.every((t) => !Array.isArray(t) && !isNaN(t))
      );
  }
  function nm(r) {
    if (!Xne(r)) {
      return __dcg_shared_module_exports__["Pb"](
        __dcg_shared_module_exports__["Vector"],
      );
    }
    let e = r[1][0],
      t = r[1][1],
      o = r[1][0] + r[0][0],
      i = r[1][1] + r[0][1];
    return [[e, t], [o, i]];
  }
  var Jne = 14, L6 = 2.5, Qne = 40, Zne = 15, eae = .75, tae = 1;
  function uh(r) {
    return r.valueType === __dcg_shared_module_exports__["Point"]
      ? r.value
      : r.valueType === __dcg_shared_module_exports__["ListOfPoint"]
      ? r.value[0]
      : void 0;
  }
  function rae(r) {
    return r.valueType === __dcg_shared_module_exports__["Vector"]
      ? r.value
      : r.valueType === __dcg_shared_module_exports__["ListOfVector"]
      ? r.value[0]
      : void 0;
  }
  function oae(r) {
    return r.valueType === __dcg_shared_module_exports__["Line"] ||
        r.valueType === __dcg_shared_module_exports__["Ray"] ||
        r.valueType === __dcg_shared_module_exports__["Segment"] ||
        r.valueType === __dcg_shared_module_exports__["Vector"]
      ? {
        segment: r.valueType === __dcg_shared_module_exports__["Segment"],
        value: r.value,
      }
      : r.valueType === __dcg_shared_module_exports__["ListOfLine"] ||
          r.valueType === __dcg_shared_module_exports__["ListOfRay"] ||
          r.valueType === __dcg_shared_module_exports__["ListOfSegment"] ||
          r.valueType === __dcg_shared_module_exports__["ListOfVector"]
      ? {
        segment: r.valueType === __dcg_shared_module_exports__["ListOfSegment"],
        value: r.value[0],
      }
      : void 0;
  }
  function P6(r) {
    return r.valueType === __dcg_shared_module_exports__["Number"]
      ? r.value
      : r.valueType === __dcg_shared_module_exports__["ListOfNumber"]
      ? r.value[0]
      : void 0;
  }
  function V6(r) {
    return r.valueType === __dcg_shared_module_exports__["DirectedAngleMarker"]
      ? r.value
      : r.valueType ===
          __dcg_shared_module_exports__["ListOfDirectedAngleMarker"]
      ? r.value[0]
      : void 0;
  }
  var fk = class {
    constructor(e) {
      this.controller = e.controller;
    }
    getTransformationPreviewInfoFromItem(e, t) {
      var n;
      if (e.type !== "expression" || e.hidden) return;
      let { translationsWithVisibleVectorParent: o } =
        t.transformationPreviewParentData;
      if (o.has(e.id)) return;
      let i = (n = e.formula.geometry) == null
        ? void 0
        : n.transformation_preview_info;
      if (i) return { ...i, id: e.id };
    }
    getInprogressTransformation(e) {
      let t = this.controller.getAllToolPreviewItems();
      for (let i of t) {
        let n = this.getTransformationPreviewInfoFromItem(i, e);
        if (n) return n;
      }
      let o = this.controller.getGeoModel().getCurrentTool();
      if (o instanceof im) return o.getPartialAnglePreviewInfo();
    }
    getHoveredOrSelectedTransformations(e) {
      let t = this.controller.getAllSelectedItems(),
        o = this.controller.getHoveredOrFocusedTokenIdentifier(),
        i = o ? this.controller.getItemsByIdentifier(o)[0] : void 0;
      i && !t.some((a) => a.id === i.id) && t.push(i);
      let n = [];
      return t.forEach((a) => {
        if (a.type !== "expression") return;
        let s = this.getTransformationPreviewInfoFromItem(a, e);
        s && n.push(s);
      }),
        n;
    }
    drawTranslationPreview(e, t, o, i) {
      let n = t.mapx(o[0]),
        a = t.mapy(o[1]),
        s = t.mapx(i[0]),
        l = t.mapy(i[1]);
      e.save(),
        e.beginPath(),
        e.strokeStyle = "rgba(0,0,0,.2)",
        e.lineWidth = 5,
        e.moveTo(n, a),
        e.lineTo(s, l),
        xc(e, n, a, s, l, 20),
        e.stroke(),
        e.restore();
    }
    drawReflectionPreview(e, t, o) {
      let i = o.value,
        n = o.segment,
        [a, s, l, c] = Rg([i[0][0], i[0][1], i[1][0], i[1][1]], t, 18).clipped,
        d = (a + l) / 2,
        p = (s + c) / 2;
      if (n) {
        let [v, w, S, k] =
          Rg([i[0][0], i[0][1], i[1][0], i[1][1]], t, 17).clipped;
        d = (v + S) / 2, p = (w + k) / 2;
      }
      if (isNaN(d) && isNaN(p)) return;
      let h = 40,
        u = h / __dcg_shared_module_exports__["MathHypot"](a - l, s - c),
        f = d + (c - s) * u,
        y = p - (l - a) * u,
        C = d - (c - s) * u,
        E = p + (l - a) * u;
      if (
        e.save(),
          e.beginPath(),
          e.strokeStyle = "rgba(0,0,0,.2)",
          e.lineWidth = 4,
          e.moveTo(a, s),
          e.lineTo(l, c),
          this.controller.getGraphSettings().config.reflectionArc
      ) {
        let v = Math.atan2(y - p, f - d), w = h, S = h * .7;
        e.moveTo(f, y), e.ellipse(d, p, w, S, v, 0, Math.PI, false);
        let k = .35, _ = v + Math.PI / 2 + k, A = v + Math.PI / 2 - k;
        xc(e, f + Math.cos(_), y + Math.sin(_), f, y, 10),
          xc(e, C + Math.cos(A), E + Math.sin(A), C, E, 10);
      } else {e.moveTo(f, y),
          e.lineTo(C, E),
          xc(e, d, p, f, y, 10),
          xc(e, d, p, C, E, 10);}
      e.stroke(), e.restore();
    }
    drawDilationPreview(e, t, o, i) {
      e.save(),
        e.beginPath(),
        e.strokeStyle = "rgba(0,0,0,.2)",
        e.lineWidth = 3;
      let n = i < .6 || i > 1.4 && i < 2 ? 6 : 10,
        a = t.pixelsToMath.mapX(25) - t.pixelsToMath.mapX(0);
      [[a, 0], [0, a], [-a, 0], [0, -a]].forEach((s) => {
        let l = [o[0] + s[0], o[1] + s[1]],
          c = __dcg_shared_module_exports__["transformPoint"](
            __dcg_shared_module_exports__["dilation"](o, i),
            l,
          ),
          [d, p] = t.map_xy_pairs(l),
          [h, u] = t.map_xy_pairs(c);
        e.moveTo(d, p), e.lineTo(h, u), xc(e, d, p, h, u, n);
      }),
        e.stroke(),
        e.restore();
    }
    drawRotationPreview(e, t, o, i, n, a) {
      if (
        this.drawRotationCenterPreview(e, t, o), !(n === void 0 || !isFinite(n))
      ) {
        if (a !== void 0 && a !== 0 && isFinite(a)) {
          if (i && i[0] === o[0] && i[1] === o[1]) return;
          this.drawFullRotationAngle(e, t, o, n, a, false);
        } else if (i) {
          this.drawPlaceholderRotationAngle(e, t, i, n);
          return;
        }
      }
    }
    drawFullRotationAngle(e, t, o, i, n, a) {
      e.save(),
        e.beginPath(),
        e.strokeStyle = "rgba(0,0,0,.2)",
        e.lineWidth = L6;
      let s = Qne, l = -i, c = -n, d, p;
      if (a) {
        let E = Rg([o[0], o[1], o[0] + Math.cos(i), o[1] + Math.sin(i)], t, 19)
          .clipped;
        d = E[0], p = E[1];
        let v = Rg(
          [o[0], o[1], o[0] + Math.cos(i + n), o[1] + Math.sin(i + n)],
          t,
          19,
        ).clipped;
        e.moveTo(d, p),
          e.lineTo(E[2], E[3]),
          e.moveTo(d, p),
          e.lineTo(v[2], v[3]);
        let w = s * Math.abs(c),
          S = .5 * (1 - eae) * w,
          k = Math.min(S, Zne),
          _ = (c > 0 ? 1 : -1) * k / s;
        l += _, c -= 2 * _;
      } else [d, p] = t.map_xy_pairs(o);
      let h = c <= 0,
        u = d + s * Math.cos(l),
        f = p + s * Math.sin(l),
        y = d + s * Math.cos(l + c),
        C = p + s * Math.sin(l + c);
      e.moveTo(u, f),
        e.arc(d, p, s, l, l + c, h),
        QL(e, y, C, l, c, 10, s),
        e.stroke(),
        e.restore();
    }
    drawPlaceholderRotationAngle(e, t, o, i) {
      e.save(),
        e.beginPath(),
        e.strokeStyle = "rgba(0,0,0,.2)",
        e.lineWidth = tae;
      let n = -i, [a, s] = t.map_xy_pairs(o);
      e.moveTo(a, s);
      let l = 1.5 * Zu(0, t);
      e.lineTo(a + l * Math.cos(n), s + l * Math.sin(n)),
        e.stroke(),
        e.restore();
    }
    drawRotationCenterPreview(e, t, o) {
      let [i, n] = t.map_xy_pairs(o);
      e.save(),
        e.strokeStyle = "rgba(0,0,0,.2)",
        e.lineWidth = L6,
        e.beginPath(),
        e.arc(i, n, Jne, 0, 2 * Math.PI),
        e.stroke(),
        e.restore();
    }
    redrawToCtx(e) {
      let { ctx: t, projection: o } = e,
        i = this.getInprogressTransformation(e),
        n = this.getHoveredOrSelectedTransformations(e);
      i && n.push(i);
      for (let a = 0; a < n.length; a++) {
        let s = n[a], l = s.args;
        switch (s.type) {
          case "translate":
            if (l.length === 2) {
              let c = uh(l[0]), d = uh(l[1]);
              c && d && this.drawTranslationPreview(t, o, c, d);
            } else if (l.length === 1) {
              let c = rae(l[0]);
              if (c) {
                let [d, p] = nm(c);
                this.drawTranslationPreview(t, o, d, p);
              }
            }
            break;
          case "reflect":
            {
              let c = oae(l[0]);
              c && this.drawReflectionPreview(t, o, c);
            }
            break;
          case "dilate":
            {
              let c = uh(l[0]), d = P6(l[1]);
              c && d !== void 0 && isFinite(d) && d !== 1 &&
                this.drawDilationPreview(t, o, c, d);
            }
            break;
          case "rotate":
            {
              let c = uh(l[0]);
              if (!c) return;
              let d = P6(l[1]), p = V6(l[1]), h, u;
              if (d !== void 0) {
                u = this.controller.getDegreeMode() ? d * Math.PI / 180 : d,
                  h = 0;
              } else if (p) {
                h = p[1],
                  u = p[2],
                  e.transformationPreviewParentData
                    .rotationsWithVisibleAndCenteredAngle.has(s.id) &&
                  (u = void 0);
              } else return;
              this.drawRotationPreview(t, o, c, p ? p[0] : void 0, h, u);
            }
            break;
          case "rotation-with-incomplete-angle": {
            let c = uh(l[0]);
            if (!c) return;
            let d, p;
            if (l.length >= 3) {
              let h = uh(l[1]);
              if (d = uh(l[2]), !c || !h || !d) return;
              let u = h[0] - d[0], f = h[1] - d[1];
              p = Math.atan2(f, u);
            }
            this.drawRotationPreview(t, o, c, d, p, void 0);
          }
        }
      }
    }
  };
  function O6(r) {
    var c, d, p, h, u, f, y, C, E, v;
    let e = new Set(),
      t = new Set(),
      o = new Set(),
      i = new Set(),
      n = {},
      a = {};
    for (
      let w of [...r.getAllItemModels(), ...r.getAllToolPreviewItems()]
    ) {
      if (w.type !== "expression" || Hi(w)) continue;
      let S = w.formula.typed_constant_value;
      if (!S) continue;
      if (
        __dcg_shared_module_exports__["isTypeOrListOfType"](
          S.valueType,
          __dcg_shared_module_exports__["Vector"],
        )
      ) {
        let _ = (c = pi(w)) == null ? void 0 : c.identifier;
        _ && (n[_] = w.id);
      }
      let k = V6(S);
      if (k) {
        let _ = (d = pi(w)) == null ? void 0 : d.identifier;
        _ && (a[_] = { id: w.id, value: k });
      }
    }
    let s = r.getHoveredOrFocusedTokenIdentifier(),
      l = [
        ...r.getAllItemModels().filter((w) => {
          var S;
          if (r.isItemSelected(w.id)) return true;
          if (w.type === "expression" && s) {
            let k = (S = pi(w)) == null ? void 0 : S.identifier;
            return s === k;
          }
          return false;
        }),
        ...r.getAllToolPreviewItems(),
      ];
    for (let w of l) {
      if (w.type !== "expression") continue;
      let S = w.formula.geometry,
        k = S == null ? void 0 : S.transformation_preview_info;
      if (
        ((p = S == null ? void 0 : S.call) == null ? void 0 : p.symbol) ===
          "translate" &&
        (k == null ? void 0 : k.args.length) === 1 &&
        __dcg_shared_module_exports__["isTypeOrListOfType"](
          k.args[0].valueType,
          __dcg_shared_module_exports__["Vector"],
        )
      ) {
        let _ = (f = (u = (h = w.formula.geometry) == null ? void 0 : h.call) ==
              null
            ? void 0
            : u.parents) == null
          ? void 0
          : f[0];
        if (!_ || _.type === "arbitrary-expression") continue;
        let A = n[__dcg_shared_module_exports__["Cc"](_)];
        A && (e.add(w.id), t.add(A));
      }
      if (
        ((y = S == null ? void 0 : S.call) == null ? void 0 : y.symbol) ===
          "rotate" &&
        (k != null && k.args) &&
        (k == null ? void 0 : k.args.length) > 1 &&
        __dcg_shared_module_exports__["isTypeOrListOfType"](
          k.args[1].valueType,
          __dcg_shared_module_exports__["DirectedAngleMarker"],
        )
      ) {
        let _ = (v = (E = (C = w.formula.geometry) == null ? void 0 : C.call) ==
              null
            ? void 0
            : E.parents) == null
          ? void 0
          : v[1];
        if (!_ || _.type === "arbitrary-expression") continue;
        let A = a[__dcg_shared_module_exports__["Cc"](_)];
        if (!A) continue;
        i.add(A.id);
        let P = uh(k.args[0]);
        if (!P) continue;
        A.value[0][0] === P[0] && A.value[0][1] === P[1] && o.add(w.id);
      }
    }
    return {
      translationsWithVisibleVectorParent: e,
      translationPreviewVectorParents: t,
      rotationsWithVisibleAndCenteredAngle: o,
      rotationPreviewAngleMarkerParents: i,
    };
  }
  var Ia = class Ia {
    constructor(e = 0, t = 0, o = 1, i = o) {
      this.tx = e, this.ty = t, this.sx = o, this.sy = i;
    }
    toJSON() {
      return { tx: this.tx, ty: this.ty, sx: this.sx, sy: this.sy };
    }
    compose(e) {
      return new Ia(
        this.sx * e.tx + this.tx,
        this.sy * e.ty + this.ty,
        this.sx * e.sx,
        this.sy * e.sy,
      );
    }
    translate(e, t) {
      let o = t === void 0 ? e.x : t.x - e.x,
        i = t === void 0 ? e.y : t.y - e.y;
      return new Ia(this.tx + o, this.ty + i, this.sx, this.sy);
    }
    scale(e, t) {
      return Ia.scale(e, t).compose(this);
    }
    scaleAtPoint(e, t, o = t) {
      return Ia.scaleAtPoint(e, t, o).compose(this);
    }
    mapX(e) {
      return this.sx * e + this.tx;
    }
    mapY(e) {
      return this.sy * e + this.ty;
    }
    mapPoint(e) {
      return { x: this.mapX(e.x), y: this.mapY(e.y) };
    }
    mapRect(e) {
      return {
        left: this.mapX(e.left),
        right: this.mapX(e.right),
        bottom: this.mapY(e.bottom),
        top: this.mapY(e.top),
      };
    }
  };
  Ia.scale = function (e, t = e) {
    return new Ia(0, 0, e, t);
  },
    Ia.translate = function (e, t) {
      return new Ia().translate(e, t);
    },
    Ia.scaleAtPoint = function (e, t, o = t) {
      return o === void 0 && (o = t),
        new Ia(e.x * (1 - t), e.y * (1 - o), t, o);
    },
    Ia.fromRects = function (e, t) {
      let o = (t.right - t.left) / (e.right - e.left),
        i = (t.top - t.bottom) / (e.top - e.bottom);
      return new Ia(t.left - o * e.left, t.bottom - i * e.bottom, o, i);
    },
    Ia.fromJSON = function (e) {
      return new Ia(e.tx, e.ty, e.sx, e.sy);
    };
  var $p = Ia;
  qt();
  var { log10: bk } = Math;
  function bV(r, e) {
    let t = e.x - r.x,
      o = e.y - r.y,
      i = .5 * (r.x + e.x),
      n = .5 * (r.y + e.y),
      a = .5 * __dcg_shared_module_exports__["MathHypot"](t, o);
    return { center: Aa(i, n), radius: a };
  }
  function R6(r, e) {
    let t = { x: 2 * r.x - e.x, y: 2 * r.y - e.y };
    return bV(e, t);
  }
  function F6(r, e) {
    let t = [];
    for (let o = 0; o < r.length; o++) {
      t.push(Aa(r[o].pageX - e.left, r[o].pageY - e.top));
    }
    return t;
  }
  function Aa(r, e) {
    return { x: r, y: e };
  }
  function N6(r) {
    return Aa(.5 * (r.left + r.right), .5 * (r.bottom + r.top));
  }
  var aae = 0,
    yk = class {
      constructor(e, t) {
        this.s = Ip(() => this.grapher.settings.config.language);
        this.grapher = e,
          this.elt = e.elt,
          this.id = aae++,
          this.controller = t,
          this.isScalingEnabled = false,
          this.mousePt = Aa(0, 0),
          this.lastScrollZoom = Date.now(),
          this.preventScrollZoom = false,
          this.addMouseWheelEventHandler(),
          this.addTouchEventHandler();
      }
      remove() {
        ee(window).off(".viewportcontroller-" + this.id);
      }
      getViewport() {
        return this.grapher.getProjection().viewport;
      }
      getProjection() {
        return this.grapher.getProjection();
      }
      isViewportLocked() {
        let e = this.getProjection().settings;
        return e.config.lockViewport || e.userLockedViewport;
      }
      updateMouse(e) {
        let t = this.elt.getBoundingClientRect();
        this.mousePt = Aa(e.clientX - t.left, e.clientY - t.top);
      }
      updateScaleAxis() {
        this.isMouseInViewport() &&
        (this.isMouseNearYAxis()
          ? this.grapher.scaleAxis = "y"
          : this.isMouseNearXAxis()
          ? this.grapher.scaleAxis = "x"
          : this.grapher.scaleAxis = "both"),
          this.updateCursor(),
          this.controller.requestRedrawGraph();
      }
      updateCursor() {
        this.elt.classList.toggle(
          "dcg-scale-horizontal",
          this.grapher.scaleAxis === "x",
        ),
          this.elt.classList.toggle(
            "dcg-scale-vertical",
            this.grapher.scaleAxis === "y",
          ),
          this.elt.classList.toggle(
            "dcg-scale-both",
            this.grapher.scaleAxis === "both",
          );
      }
      isMouseNearOrigin() {
        let t = this.getProjection().mathToPixels.mapPoint(Aa(0, 0));
        return Math.abs(this.mousePt.x - t.x) < 50 &&
          Math.abs(this.mousePt.y - t.y) < 50;
      }
      isMouseNearXAxis() {
        let e = this.getProjection(),
          t = e.pixelCoordinates,
          o = e.mathToPixels.mapY(0);
        return o = Math.min(Math.max(t.top, o), t.bottom),
          Math.abs(this.mousePt.y - o) < 40 && e.settings.showXAxis;
      }
      isMouseNearYAxis() {
        let e = this.getProjection(),
          t = e.pixelCoordinates,
          o = e.mathToPixels.mapX(0);
        return o = Math.min(Math.max(t.left, o), t.right),
          Math.abs(this.mousePt.x - o) < 40 && e.settings.showYAxis;
      }
      isMouseInViewport() {
        let e = this.getProjection(),
          t = e.mathCoordinates,
          o = e.pixelsToMath.mapPoint(this.mousePt);
        return o.x >= t.left && o.x <= t.right && o.y >= t.bottom &&
          o.y <= t.top;
      }
      _setViewportWithoutCancellingAnimation(e) {
        if (
          !e.isValid(this.controller.getAxisScaleSettings()) ||
          e.equals(this.getViewport())
        ) return;
        let o = this.getProjection();
        this.grapher._setProjection(new Rs(o.screen, e, o.settings));
      }
      setViewport(e) {
        this.cancelAnimation(), this._setViewportWithoutCancellingAnimation(e);
      }
      setScreen(e) {
        let t = this.getProjection(),
          o = t.settings.squareAxes
            ? t.viewport.squareYAxis(e, t.settings)
            : t.viewport,
          i = new Rs(e, o, t.settings);
        this.grapher._setProjection(i);
      }
      getTransformedViewport(e) {
        let { pixelCoordinates: t, mathCoordinates: o, settings: i } = this
            .getProjection(),
          { xAxisScale: n, yAxisScale: a } = i,
          s = e.mapRect(t),
          l = __dcg_shared_module_exports__["jd"].fromRectsInverse(o, s, {
            xAxisScale: n,
            yAxisScale: a,
          }).mapRect(t);
        return new Br(l.left, l.right, l.bottom, l.top);
      }
      transformViewport(e) {
        this.setViewport(this.getTransformedViewport(e)),
          (this.grapher.scaleAxis === "x" ||
            this.grapher.scaleAxis === "y") &&
          this.controller.markSquareAxesAfterUserEditedViewport();
      }
      animateToViewport(e) {
        this.cancelAnimation();
        let t = this.getProjection(),
          o = t.viewport,
          i = t.mathToPixels,
          n = 0,
          a,
          s = (l) => {
            a || (a = l);
            let c = (l - a) / 500;
            if (n += c, n < 1) {
              this.__animationTimeout = requestAnimationFrame(s);
              let d = i.interpolateX(o.xmin, e.xmin, n),
                p = i.interpolateX(o.xmax, e.xmax, n),
                h = i.interpolateY(o.ymin, e.ymin, n),
                u = i.interpolateY(o.ymax, e.ymax, n);
              this._setViewportWithoutCancellingAnimation(
                new Br(d, p, h, u),
              ), this.grapher.debounceUserRequestedViewportChange();
            } else {this.setViewport(Br.fromObject(e)),
                this.grapher.debounceUserRequestedViewportChange(),
                this.controller.markSquareAxesAfterUserEditedViewport();}
          };
        this.__animationTimeout = requestAnimationFrame(s);
      }
      cancelAnimation() {
        cancelAnimationFrame(this.__animationTimeout);
      }
      addMouseWheelEventHandler() {
        let e = false, t, o;
        ee(window).on("scroll.viewportcontroller-" + this.id, (a) => {
          e = true;
        }),
          ee(window).on("wheel.viewportcontroller-" + this.id, (a) => {
            t = a.clientX, o = a.clientY;
          }),
          ee(window).on(
            "mousemove.viewportcontroller-" + this.id,
            (a) => {
              if (!e) return;
              let s = a.clientX - t, l = a.clientY - o;
              s * s + l * l < 100 || (e = false);
            },
          );
        let i = 0,
          n = (a) => {
            let s = a.originalEvent;
            if (s.deltaX === 0 && s.deltaY === 0) return;
            let l = Date.now(), c = l - this.lastScrollZoom;
            if (
              this.preventScrollZoom && c > 50 &&
              (this.preventScrollZoom = false),
                this.lastScrollZoom = l,
                this.preventScrollZoom
            ) return;
            let d = this.getProjection();
            if (this.isViewportLocked()) return;
            let p = d.mathToPixels;
            if (e) return;
            s.preventDefault(), this.updateMouse(s);
            let h = p.mapPoint(Aa(0, 0)),
              f = (s.deltaY === 0 ? -s.deltaX : -s.deltaY) > 0 ? 1 : -1,
              y = this.isMouseNearOrigin() && f > 0 ? h : this.mousePt;
            if (i > 0) return;
            i += 1,
              requestAnimationFrame(() => {
                i--;
              });
            let { xAxisScale: C, yAxisScale: E } = d.settings, v = .0625;
            (C === "logarithmic" || E === "logarithmic") && c < 25 &&
              (v *= Math.max(10, c) / 25);
            let w = f > 0 ? 1 + v : 1 / (1 + v),
              S = this.grapher.scaleAxis,
              k = S === "x" || S === "both" || !S ? w : 1,
              _ = S === "y" || S === "both" || !S ? w : 1,
              A = $p.scaleAtPoint(y, k, _),
              P = this.getTransformedViewport(A);
            f == -1 && this.tooBig(P) || f == 1 && this.tooSmall(P) ||
              (this.transformViewport(A),
                this.grapher.debounceUserRequestedViewportChange());
          };
        ee(this.elt).on("wheel", n);
      }
      applyPanTouchChanges(e, t) {
        if (this.isViewportLocked() || this.isScalingEnabled) return;
        let o = Aa(t[0].x - e[0].x, t[0].y - e[0].y);
        this.transformViewport($p.translate(o)),
          this.grapher.debounceUserRequestedViewportChange();
      }
      chooseDragScaleCenter() {
        let e = this.getProjection(),
          t = e.pixelCoordinates,
          o = e.mathToPixels.mapX(0),
          i = e.mathToPixels.mapY(0);
        return o = Math.min(Math.max(t.left, o), t.right),
          i = Math.min(Math.max(t.top, i), t.bottom),
          Aa(o, i);
      }
      applyScaleTouchChanges(e, t) {
        if (this.isViewportLocked()) return;
        let o = this.grapher.scaleAxis, i, n;
        if (e.length === 2 && t.length === 2) {
          i = bV(e[0], e[1]), n = bV(t[0], t[1]);
        } else if (t.length === 1) {
          let p = this.chooseDragScaleCenter();
          i = R6(p, e[0]), n = R6(p, t[0]);
        } else return;
        let a = n.radius / i.radius,
          s = o === "y" ? 1 : a,
          l = o === "x" ? 1 : a,
          c = $p.scaleAtPoint(i.center, s, l).translate(
            i.center,
            n.center,
          ),
          d = this.getTransformedViewport(c);
        a < 1 && this.tooBig(d) || a > 1 && this.tooSmall(d) ||
          (this.transformViewport(c),
            this.grapher.debounceUserRequestedViewportChange());
      }
      panFromKeyboard(e) {
        if (this.isViewportLocked() || this.isScalingEnabled) return;
        let t = Aa(0, 0);
        e === "Up"
          ? (xe(this.s("graphing-calculator-narration-viewport-pan-up")),
            t = Aa(0, -5))
          : e === "Down"
          ? (xe(
            this.s("graphing-calculator-narration-viewport-pan-down"),
          ),
            t = Aa(0, 5))
          : e === "Left"
          ? (xe(
            this.s("graphing-calculator-narration-viewport-pan-left"),
          ),
            t = Aa(-5, 0))
          : e === "Right" &&
            (xe(
              this.s("graphing-calculator-narration-viewport-pan-right"),
            ),
              t = Aa(5, 0)),
          this.transformViewport($p.translate(t)),
          this.grapher.debounceUserRequestedViewportChange();
      }
      addTouchEventHandler() {
        let e = [],
          t = false,
          o = true,
          i = true,
          n = (u) => {
            t || this.isViewportLocked() ||
              (this.updateMouse(u.originalEvent),
                this.isScalingEnabled && this.updateScaleAxis());
          };
        ee(window).on("mousemove.viewportcontroller-" + this.id, n),
          this.beginPanning = (u) => {
            let f = this.getProjection();
            if (
              this.isViewportLocked() || t ||
              u.touches.length !== u.changedTouches.length
            ) return;
            t = true, this.grapher.isDragging = true, this.updateMouse(u);
            let y = f.mathToPixels.mapPoint(Aa(0, 0)),
              C = this.grapher.scaleAxis;
            (C === "x" || C === "both") && (o = this.mousePt.x > y.x),
              (C === "y" || C === "both") && (i = this.mousePt.y > y.y),
              this.controller.dispatch({ type: "grapher/drag-start" }),
              ee(document).on("dcg-tapmove.graphdrag", p),
              ee(document).on(
                "dcg-tapstart.graphdrag dcg-tapend.graphdrag dcg-tapcancel.graphdrag",
                h,
              );
          };
        let a = (u) => {
            if (u.length < 2) return;
            let f = this.grapher.getProjection(),
              y = f.pixelCoordinates,
              C = f.mathToPixels.mapX(0),
              E = f.mathToPixels.mapY(0),
              v = 40;
            C = Math.min(Math.max(y.left, C), y.right),
              E = Math.min(Math.max(y.top, E), y.bottom);
            let w = u[1].x - u[0].x, S = u[1].y - u[0].y;
            return Math.abs(u[0].x - C) < v && Math.abs(u[1].x - C) < v &&
                Math.abs(S) > 3 * Math.abs(w) && f.settings.showYAxis
              ? "y"
              : Math.abs(u[0].y - E) < v && Math.abs(u[1].y - E) < v &&
                  Math.abs(w) > 3 * Math.abs(S) && f.settings.showXAxis
              ? "x"
              : "both";
          },
          s = (u) => (this.grapher.scaleAxis ||
            (this.grapher.scaleAxis = a(u)),
            this.grapher.scaleAxis),
          l = () => {
            this.grapher.scaleAxis &&
              (this.grapher.scaleAxis = void 0,
                this.controller.requestRedrawGraph(),
                this.updateCursor());
          },
          c = () => {
            this.isScalingEnabled = false, this.preventScrollZoom = true, l();
          },
          d = (u) => u.altKey || u.ctrlKey || u.metaKey,
          p = (u) => {
            let f = u;
            if (!t || this.isViewportLocked()) return;
            let y = F6(f.touches, Gl(this.elt));
            if (e.length === 2 && y.length === 2) {
              s(y), this.applyScaleTouchChanges(e, y);
            } else if (e.length === 1 && this.isScalingEnabled) {
              this.updateMouse(f);
              let C = this.grapher.scaleAxis,
                v = this.getProjection().mathToPixels.mapPoint(Aa(0, 0)),
                w,
                S,
                k = 5,
                _ = o ? 1 : -1,
                A = i ? 1 : -1;
              if (
                (C === "x" || C === "both") &&
                (w = this.mousePt.x > v.x + k * _),
                  (C === "y" || C === "both") &&
                  (S = this.mousePt.y > v.y + k * A),
                  C === "x" && o !== w || C === "y" && i !== S ||
                  C === "both" && o !== w && i !== S
              ) return;
              this.applyScaleTouchChanges(e, y);
            } else l();
            e.length === 1 && this.applyPanTouchChanges(e, y),
              this.controller.dispatch({ type: "grapher/drag-move" }),
              e = y;
          },
          h = (u) => {
            let f = u;
            t &&
              (this.cancelAnimation(),
                e = F6(f.touches, Gl(this.elt)),
                f.touches.length === 0 &&
                (t = false,
                  this.grapher.isDragging = false,
                  ee(document).off(".graphdrag"),
                  this.grapher.debounceUserRequestedViewportChange(),
                  this.controller.dispatch({ type: "grapher/drag-end" })),
                (f.touches.length === 0 ||
                  f.touches.length === 1 && !this.isScalingEnabled) &&
                l());
          };
        ee(window).on("keydown.viewportcontroller-" + this.id, (u) => {
          this.controller.isGeoToolActive() || this.isViewportLocked() ||
            (ke(u) === tw && !d(u) && this.shouldAllowShiftScaling()
              ? (this.isScalingEnabled = true,
                this.grapher.scaleAxis || this.updateScaleAxis())
              : c());
        }),
          ee(window).on(
            "keyup.viewportcontroller-" + this.id +
              " blur.viewportcontroller-" + this.id,
            c,
          );
      }
      shouldAllowShiftScaling() {
        return !this.controller.isGeometry();
      }
      zoom(e) {
        let t = this.getProjection().pixelCoordinates;
        if (e === "in") {
          let o = this.getTransformedViewport($p.scaleAtPoint(N6(t), 2));
          this.tooSmall(o) || this.animateToViewport(o),
            xe(this.s("graphing-calculator-narration-viewport-zoom-in"));
        } else if (e === "out") {
          let o = this.getTransformedViewport($p.scaleAtPoint(N6(t), .5));
          this.tooBig(o) || this.animateToViewport(o),
            xe(this.s("graphing-calculator-narration-viewport-zoom-out"));
        } else if (e === "square") {
          let o = this.getSquareViewport();
          this.getProjection().settings.setProperty("squareAxes", true),
            this.animateToViewport(o),
            xe(
              this.s(
                "graphing-calculator-narration-viewport-zoom-square",
              ),
            );
        } else e === "default" && this.setDefaultViewport();
      }
      tooBig(e) {
        let t = this.getProjection(),
          { xAxisScale: o, yAxisScale: i } = t.settings,
          { xmin: n, xmax: a, ymin: s, ymax: l } = e;
        return o === "logarithmic" && bk(a) - bk(n) > 60 ||
          i === "logarithmic" && bk(l) - bk(s) > 60 ||
          this.controller.isGeometry() && a - n > 1e5;
      }
      tooSmall(e) {
        let { xmin: t, xmax: o } = e;
        return this.controller.isGeometry() && o - t < 1e-4;
      }
      zoomSquareImmediately() {
        this.setViewport(this.getSquareViewport());
      }
      zoomCustom(e) {
        this.animateToViewport(e),
          xe(this.s("graphing-calculator-narration-viewport-updated"));
      }
      setDefaultViewport() {
        let e = this.controller.getDefaultViewport();
        this.animateToViewport(e),
          xe(this.s("graphing-calculator-narration-viewport-default"));
      }
      isDefaultViewportRestored() {
        let e = this.getProjection(),
          { xAxisScale: t, yAxisScale: o } = e.settings,
          i = t === "linear",
          n = o === "linear",
          a = e.viewport,
          s = this.controller.getDefaultViewport(),
          l = i ? a.xmax - a.xmin : Math.log(a.xmax / a.xmin),
          c = n ? a.ymax - a.ymin : Math.log(a.ymax / a.ymin),
          d = i ? a.xmin - s.xmin : Math.log(a.xmin / s.xmin),
          p = i ? a.xmax - s.xmax : Math.log(a.xmax / s.xmax),
          h = n ? a.ymin - s.ymin : Math.log(a.ymin / s.ymin),
          u = n ? a.ymax - s.ymax : Math.log(a.ymax / s.ymax),
          f = .025;
        return Math.abs(d / l) < f && Math.abs(p / l) < f &&
          Math.abs(h / c) < f && Math.abs(u / c) < f;
      }
      getSquareViewport() {
        let e = this.getProjection();
        return e.settings.lastChangedAxis === "y"
          ? e.viewport.squareXAxis(e.screen, e.settings)
          : e.viewport.squareYAxis(e.screen, e.settings);
      }
    };
  function sae() {
    return new hl(1024, 768);
  }
  function B6(r) {
    let { xAxisScale: e, yAxisScale: t } = r;
    return new Br(
      ...e === "linear" ? [-Xu, Xu] : [10 ** -Ju, 10 ** Ju],
      ...t === "linear" ? [-Xu, Xu] : [10 ** -Ju, 10 ** Ju],
    );
  }
  var lae = document.createElement("canvas"),
    am = class r extends my {
      constructor(t, o, i, n) {
        super({ elt: t, settings: o, controller: i, evaluator: n });
        this.type = "2d";
        this.__screenRequested3D = new hl(768, 768);
        this.lastActiveToken = { selected: void 0, hovered: void 0 };
        let a = sae(), s = B6(o).squareYAxis(a, o);
        this.setUserRequestedViewport(s),
          this.__projection = new Rs(a, s, o),
          this.markLabelsDirty = __dcg_shared_module_exports__["A"](
            () => {
              this.evaluator.notifyWhenSynced(() => {
                this.poiLabelsLayer.markLabelsDirty(),
                  this.controller.requestRedrawGraph();
              });
            },
            300,
          ),
          this.poiController = new hk(this, o),
          this.viewportController = new yk(this, this.controller),
          this.showPOIDots = true,
          this.graphSketches = {},
          this.graphImages = {},
          this.audioGraph = new MD(i, this),
          this.boxSelectLayer = new GD();
        let l = document.createElement("div");
        this.elt.appendChild(l),
          this.imageLayer = new Nv(this),
          this.gridLayer = new HD(),
          this.poiDotsLayer = new gk(this.controller),
          this.graphsLayer = new Td(
            this.controller,
            this.settings,
            (p) => this.audioGraph.getExpressionAriaLabel(p),
          ),
          this.transformationPreviewLayer = new fk(this),
          this.clickableObjectsLayer = new Ov(this),
          this.movablePointsLayer = new nv(this);
        let c = document.createElement("div");
        this.elt.appendChild(c),
          this.poiLabelsLayer = Hv.mountToNode(Pb, c, {
            grapher: () => this,
          });
        let d = document.createElement("div");
        this.elt.appendChild(d),
          this.geoKeyboardCursorLayer = Hv.mountToNode(FD, d, {
            grapher: () => this,
          }),
          this.traceLayer = this.poiLabelsLayer,
          this.scaleAxis = void 0;
      }
      privateGetGridLayer() {
        return this.gridLayer;
      }
      static copyGraphProperties(t, o) {
        t = __dcg_shared_module_exports__["od"](Os, t);
        let i = { ...t };
        delete i.viewport;
        let n = o.validateSettings(i);
        for (let a in n) o.setProperty(a, n[a]);
        return t;
      }
      remove() {
        this.elt.remove(),
          this.poiController.remove(),
          this.viewportController.remove(),
          this.audioGraph.remove();
      }
      tick(t) {
        (this.__redrawRequested ||
          this.poiLabelsLayer.areAnyLabelsAnimating()) &&
        this._redrawAllLayers(),
          this.__movablePointListener && this.__movablePointListener();
      }
      registerMovablePointListener(t) {
        this.__movablePointListener = t;
      }
      deregisterMovablePointListener() {
        this.__movablePointListener = void 0;
      }
      clear() {
        this.graphSketches = {}, this.graphImages = {};
      }
      getGraphSketch(t) {
        return this.graphSketches[t];
      }
      getGraphImage(t) {
        return this.graphImages[t];
      }
      addGraphSketch(t) {
        this.graphSketches[t.id] = t;
      }
      removeGraphSketch(t) {
        delete this.graphSketches[t];
      }
      addGraphImage(t) {
        t.imageObj.width && t.imageObj.height
          ? (this.graphImages[t.id] = t, this.controller.requestRedrawGraph())
          : ee(t.imageObj).on(
            "load.calc_load",
            () => this.addGraphImage(t),
          );
      }
      removeGraphImage(t) {
        let o = this.graphImages[t];
        o && ee(o.imageObj).off("load.calc_load"),
          delete this.graphImages[t],
          this.controller.requestRedrawGraph();
      }
      setBoxSelectRectangle(t) {
        this.boxSelectRectangle = t, this.controller.requestRedrawGraph();
      }
      getProjection() {
        return this.__projection;
      }
      _setProjection(t) {
        this.__projection = t, this.controller.requestRedrawGraph();
      }
      getAudioTrace() {
        return this.audioGraph;
      }
      getDefaultViewport() {
        let t = this.getProjection();
        return B6(this.settings).squareYAxis(t.screen, this.settings);
      }
      _updateScreenSize(t, o) {
        if (t <= 0 || o <= 0) return;
        let n = this.getProjection().screen;
        if (n.width === t && n.height === o) return;
        let a = new hl(t, o);
        this.viewportController.setScreen(a);
      }
      update() {
        let { top: t, left: o, width: i, height: n } =
            this.controller.computeMajorLayout().grapher,
          a = this.controller.isGraphPaperFocused() &&
            !this.poiController.keyboardAttentionManager
              .getKeyboardAttention() &&
            !this.controller.getSelectedGeoExpression() &&
            !this.geoKeyboardCursorLayer.showCursor() &&
            !this.controller.inAudioTraceMode() && wU();
        this.elt.classList.toggle("dcg-grapher-focused", a),
          this.controller.isThreeDMode() &&
          ({ width: i, height: n } = this.__screenRequested3D),
          i > 0 && n > 0
            ? (this._setIsVisible(true),
              this._updateScreenSize(i, n),
              Wn(this.elt, {
                position: "absolute",
                left: o + "px",
                top: t + "px",
                width: i + "px",
                height: n + "px",
              }))
            : this._setIsVisible(false);
      }
      setActiveToken(t, o) {
        let i = this.lastActiveToken[o];
        this.lastActiveToken[o] = t;
        let n = t && this.getGraphSketch(t),
          a = i && this.getGraphSketch(i);
        a !== n &&
        (a &&
          (o === "selected"
            ? a.tokenSelected = false
            : o === "hovered" && (a.tokenHovered = false)),
          n &&
          (o === "selected"
            ? n.tokenSelected = true
            : o === "hovered" && (n.tokenHovered = true))),
          this.controller.requestRedrawGraph();
      }
      deselectSketch(t) {
        let o = this.getGraphSketch(t);
        o && (o.selected = false, o.showPOI = false, o.showHighlight = false);
      }
      selectSketch(t) {
        let o = this.getGraphSketch(t);
        o &&
          (o.selected = true,
            o.showPOI = this.controller.isTraceEnabled(),
            o.showHighlight = true);
      }
      setSketchHoistedToTop(t, o) {
        let i = this.getGraphSketch(t);
        i && (i.hoistToTop = o);
      }
      updateSketch(t, o) {
        let i = this.getGraphSketch(t);
        if (!o.length) {
          this.removeGraphSketch(t);
          return;
        }
        let n = new BD(t, o);
        o[0].graphMode !== 15 &&
        (n.color = o[0].color, o[0].style && (n.style = o[0].style)),
          i && n.updateFrom(i);
        let a = this.controller.getPropagatedSelectedIds(),
          s = !!a.selected[t],
          l = !!a.hoistedToTop[t];
        n.selected = s,
          n.tokenHovered = t === String(this.lastActiveToken.hovered),
          n.tokenSelected = t === String(this.lastActiveToken.selected),
          n.showPOI = s && this.controller.isTraceEnabled(),
          n.showHighlight = s,
          n.hoistToTop = l,
          this.addGraphSketch(n);
      }
      updateIntersections(t, o) {
        let i = this.getGraphSketch(t);
        i && i.updateIntersections(o);
      }
      _clear() {
        let o = this.getProjection().screen;
        this.canvasLayer.resize(o.width, o.height),
          this.canvasLayer.ctx &&
          (this.canvasLayer.ctx.clearRect(0, 0, o.width, o.height),
            this.controller.isThreeDMode()
              ? this.controller.getInvertedColors() ||
                (this.canvasLayer.ctx.fillStyle = "rgba(255,255,255,0.001961)",
                  this.canvasLayer.ctx.fillRect(0, 0, o.width, o.height))
              : US &&
                (this.controller.getInvertedColors() ||
                  (this.canvasLayer.ctx.fillStyle = "rgb(0,0,0)",
                    this.canvasLayer.ctx.fillRect(
                      0,
                      0,
                      o.width,
                      o.height,
                    ))));
      }
      isDrawingPlaneFor3dMode() {
        return this.controller.showPlane3D() ||
          this.controller.showNumbers3D();
      }
      createDrawContext() {
        if (this.canvasLayer.ctx) {
          return {
            ctx: this.canvasLayer.ctx,
            projection: this.getProjection(),
            transformationPreviewParentData: O6(this.controller),
          };
        }
      }
      _redrawAllLayers() {
        if (
          this.update(), !this.isVisible && !this.isDrawingPlaneFor3dMode()
        ) return;
        this.__redrawRequested = false;
        let t = Date.now();
        this._clear();
        let o = this.createDrawContext();
        this.audioGraph.recomputePoints(),
          this._redrawGrapher(o),
          this._redrawTransformationPreviewLayer(o),
          this._redrawBoxSelectLayer(o),
          this._redrawGeoKeyboardCursorLayer(),
          this._updateCanvasLayerAria(),
          this.events.triggerEvent("redraw", Date.now() - t);
        let i = this.controller.getGrapher3d();
        this.isDrawingPlaneFor3dMode() && i &&
          i.webglLayer.updatePlaneMap();
      }
      _redrawTransformationPreviewLayer(t) {
        t && this.transformationPreviewLayer.redrawToCtx(t);
      }
      _redrawBoxSelectLayer(t) {
        t && this.boxSelectLayer.redrawToCtx(t, this.boxSelectRectangle);
      }
      _redrawGeoKeyboardCursorLayer() {
        this.geoKeyboardCursorLayer.update();
      }
      _updateCanvasLayerAria() {
        let t = 0;
        for (let o in this.graphSketches) {
          ul(this.controller, this.graphSketches[o]) && (t += 1);
        }
        this.canvasLayer.updateAria(this.isVisible, t);
      }
      _redrawGrapher(t) {
        if (!t) return;
        let o = this.controller.isThreeDMode();
        this.clickableObjectsLayer.recomputeClickableObjects(),
          o ||
          (this.imageLayer.recomputeImages(t),
            this.movablePointsLayer.recomputeMovablePoints(t),
            this.poiLabelsLayer.recomputeLabels(
              t,
              this.size(),
              () =>
                this.drawLabelHitMask({
                  projection: this.getProjection(),
                  showMovablePoints: true,
                  includePillboxes: true,
                }),
            ));
        let i = (n) => {
          this.graphsLayer.redrawToCtx(
            t,
            this.graphSketches,
            this.graphImages,
            n.drawOrder,
            this.poiLabelsLayer,
            this.clickableObjectsLayer,
          ),
            o ||
            (this.poiLabelsLayer.copyToCtx(t.ctx, {
              filter: "canvas-labels",
              allowedSketches: n.drawSet,
            }),
              this.movablePointsLayer.redrawToCtx(
                t.ctx,
                t.projection,
                n.drawOrder,
                { showMovablePoints: true, renderForScreenshot: false },
              ));
        };
        for (let n of this.__drawLayers) n.layer < 0 && i(n);
        this.gridLayer.redrawToCtx(t, this.scaleAxis);
        for (let n of this.__drawLayers) n.layer >= 0 && i(n);
        !o && this.showPOIDots &&
          this.poiDotsLayer.redrawToCtx(
            t,
            this.graphSketches,
            this.poiLabelsLayer,
            this.clickableObjectsLayer,
            this.__drawLayers,
          );
      }
      size() {
        let t = this.canvasLayer.ctx;
        if (!t) return { width: 0, height: 0 };
        let o = t.canvas.getBoundingClientRect();
        return { width: o.width, height: o.height };
      }
      _parseScreenshotOpts(t) {
        return yV(t, this.settings, this.getProjection().screen);
      }
      _syncScreenshotReturnCanvas(t) {
        let o = document.createElement("canvas");
        if (t && t.braille) {
          let { embosserModel: i, brailleMode: n } = t.braille, a = uy[i];
          o.width = a.width,
            o.height = a.height,
            t6(o, this, a, i, n, !!t.showMovablePoints);
        } else {
          let i = this._parseScreenshotOpts(t);
          o.width = i.width * i.targetPixelRatio,
            o.height = i.height * i.targetPixelRatio,
            this.screenshotToCanvas(o, t);
        }
        return o;
      }
      screenshot(t) {
        return t && t.showLabels && (t = { ...t, showLabels: false }),
          this._syncScreenshotReturnCanvas(t).toDataURL("image/png");
      }
      asyncScreenshot(t, o) {
        if (t && t.format === "svg") {
          t.transparentBackground &&
            (t = __dcg_shared_module_exports__["Jc"](t),
              t.transparentBackground = false);
          let { width: i, height: n, targetPixelRatio: a } = this
            ._parseScreenshotOpts(t);
          i *= a, n *= a;
          let s = new PK(i, n),
            l = { getContext: () => s, width: i, height: n };
          this.screenshotToCanvas(l, t), o(s.getSerializedSvg());
        } else {
          let i = this._syncScreenshotReturnCanvas(t);
          o(i.toDataURL("image/png"));
        }
      }
      makeScreenshotProjection(t) {
        let { width: o, height: i, settings: n } = this
            ._parseScreenshotOpts(t),
          a = new hl(o, i),
          s = this.getProjection().viewport;
        return this.settings.squareAxes &&
          (s = s.squareCrop(a, this.settings)),
          new Rs(a, s, n);
      }
      drawLabelHitMask(t) {
        let o = t.projection, i = lae;
        i.width = o.screen.width, i.height = o.screen.height;
        let n = i.getContext("2d");
        n.clearRect(0, 0, o.screen.width, o.screen.height);
        let a = {
            ctx: n,
            projection: o,
            transformationPreviewParentData: {
              translationPreviewVectorParents: new Set(),
              translationsWithVisibleVectorParent: new Set(),
              rotationPreviewAngleMarkerParents: new Set(),
              rotationsWithVisibleAndCenteredAngle: new Set(),
            },
          },
          s = [...this.generateMergeDrawOrder()];
        if (
          this.gridLayer.redrawToCtx(a),
            this.graphsLayer.redrawToCtx(
              a,
              this.graphSketches,
              this.graphImages,
              s,
              this.poiLabelsLayer,
              this.clickableObjectsLayer,
            ),
            this.movablePointsLayer.redrawToCtx(a.ctx, a.projection, s, {
              showMovablePoints: t.showMovablePoints,
              renderForScreenshot: true,
            }),
            t.includePillboxes
        ) {
          let l = this.elt.getBoundingClientRect(),
            c = this.controller.findEl(".dcg-overgraph-pillbox-elements"),
            d = this.controller.findEl(".dcg-graphpaper-branding");
          __dcg_shared_module_exports__["g"]([c, d], (p) => {
            if (!p) return;
            let h = p.getBoundingClientRect();
            n.globalAlpha = 1,
              n.fillStyle = "black",
              n.fillRect(
                h.left - l.left,
                h.top - l.top,
                h.width,
                h.height,
              );
          });
        }
        return n;
      }
      screenshotToCanvas(t, o) {
        let i = this._parseScreenshotOpts(o),
          { targetPixelRatio: n, transparentBackground: a } = i,
          s = t.getContext("2d");
        s.scale(n, n);
        let l = this.makeScreenshotProjection(o);
        l.settings.takingScreenshot = true,
          Ja(s, "background"),
          No(s, "dcg-svg-background"),
          a
            ? s.clearRect(0, 0, l.screen.width, l.screen.height)
            : (s.fillStyle = "white",
              s.fillRect(0, 0, l.screen.width, l.screen.height)),
          To(s),
          Qa(s);
        let c = {
          ctx: s,
          projection: l,
          transformationPreviewParentData: {
            translationPreviewVectorParents: new Set(),
            translationsWithVisibleVectorParent: new Set(),
            rotationPreviewAngleMarkerParents: new Set(),
            rotationsWithVisibleAndCenteredAngle: new Set(),
          },
        };
        this.imageLayer.recomputeImages(c);
        let d;
        if (o && "showLabels" in o && o.showLabels) {
          let h = l.screen.width,
            u = l.screen.height,
            f = l.settings.labelSize || 15,
            y = 1;
          (h < 200 || u < 200) && (y = .9);
          let C = f * y + "px", E = document.createElement("div");
          E.classList.add("dcg-calculator-screenshot-labels-container"),
            Hv.mountToNode(mk, E, {
              concreteFontSize: () => C,
              width: () => `${l.screen.width}px`,
              height: () => `${l.screen.height}px`,
            }),
            document.body.append(E);
          let v = Hv.mountToNode(Pb, E.querySelector(".dcg-grapher"), {
            grapher: () => this,
          });
          v.takingScreenshot = true;
          let w = { width: l.screen.width, height: l.screen.height };
          v.recomputeLabels(
            {
              projection: l,
              ctx: s,
              transformationPreviewParentData: {
                translationPreviewVectorParents: new Set(),
                translationsWithVisibleVectorParent: new Set(),
                rotationPreviewAngleMarkerParents: new Set(),
                rotationsWithVisibleAndCenteredAngle: new Set(),
              },
            },
            w,
            () =>
              this.drawLabelHitMask({
                projection: l,
                showMovablePoints: !!o.showMovablePoints,
                includePillboxes: false,
              }),
          ), d = { labelsLayer: v, layersWrapper: E };
        }
        let p = (h) => {
          this.graphsLayer.redrawToCtx(
            c,
            this.graphSketches,
            this.graphImages,
            h.drawOrder,
            this.poiLabelsLayer,
            this.clickableObjectsLayer,
          ),
            d &&
            d.labelsLayer.copyToCtx(s, {
              filter: "canvas-labels",
              allowedSketches: h.drawSet,
            }),
            this.movablePointsLayer.redrawToCtx(
              c.ctx,
              c.projection,
              h.drawOrder,
              {
                showMovablePoints: !!(o != null && o.showMovablePoints),
                renderForScreenshot: true,
              },
            );
        };
        for (let h of this.__drawLayers) h.layer < 0 && p(h);
        this.gridLayer.redrawToCtx(c);
        for (let h of this.__drawLayers) h.layer >= 0 && p(h);
        d &&
          (d.labelsLayer.copyToCtx(s, {
            filter: "above-canvas",
            allowedSketches: new Set([...this.generateMergeDrawOrder()]),
          }),
            d.layersWrapper.remove());
      }
      speakGrapherFocusAriaLabel() {
        this.canvasLayer.speakAriaLabelAgain();
      }
      _afterViewportChange() {}
      setGrapherState(t, o) {
        if (
          (!o || !o.doNotClear) && this.clear(),
            "complex" in t && !this.controller.canEnableComplexMode() &&
            (t = { ...t, complex: false }),
            t = r.copyGraphProperties(t, this.settings),
            "viewport" in t
        ) {
          let i = Br.fromObject(t.viewport);
          this.setUserRequestedViewport(i);
          let n = this.computeConcreteViewport(i);
          this.viewportController.setViewport(n);
        }
        this.controller.requestRedrawGraph();
      }
      computeConcreteViewport(t) {
        let o = this.getProjection().screen;
        return this.settings.squareAxes &&
            !t.isSquare(o, this.controller.getAxisScaleSettings())
          ? t.squareYAxis(o, this.settings)
          : t;
      }
      setCanvasSizeFor3D(t, o) {
        this.__screenRequested3D = new hl(t, o);
      }
      getCanvasNode() {
        return this.canvasLayer.canvasNode;
      }
    };
  function yV(r, e, t) {
    let o, i, n, a, s, l;
    return r
      ? (o = r.width || r.height || t.width,
        i = r.height || r.width || t.height,
        n = r.targetPixelRatio || 1,
        n < 1 && (n = 1),
        a = (o < 256 || i < 256) && !r.preserveAxisNumbers,
        s = Bp.fromObject({ ...e, ...r.settings }),
        l = !!r.transparentBackground)
      : (o = t.width,
        i = t.height,
        n = 1,
        a = false,
        s = Bp.fromObject(e),
        l = false),
      a &&
      (s.setProperty("xAxisNumbers", false),
        s.setProperty("yAxisNumbers", false),
        s.setProperty("polarNumbers", false)),
      {
        width: o,
        height: i,
        targetPixelRatio: n,
        settings: s,
        transparentBackground: l,
      };
  }
  var Ma = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ];
  var xk = Math.PI / 180, xV = 180 / Math.PI;
  function Yl() {
    let r = Math.random() * 4294967295 | 0,
      e = Math.random() * 4294967295 | 0,
      t = Math.random() * 4294967295 | 0,
      o = Math.random() * 4294967295 | 0;
    return (Ma[r & 255] + Ma[r >> 8 & 255] + Ma[r >> 16 & 255] +
      Ma[r >> 24 & 255] + "-" + Ma[e & 255] + Ma[e >> 8 & 255] + "-" +
      Ma[e >> 16 & 15 | 64] + Ma[e >> 24 & 255] + "-" + Ma[t & 63 | 128] +
      Ma[t >> 8 & 255] + "-" + Ma[t >> 16 & 255] + Ma[t >> 24 & 255] +
      Ma[o & 255] + Ma[o >> 8 & 255] + Ma[o >> 16 & 255] +
      Ma[o >> 24 & 255]).toLowerCase();
  }
  function sm(r, e, t) {
    return Math.max(e, Math.min(t, r));
  }
  function wV(r) {
    return (r & r - 1) === 0 && r !== 0;
  }
  function Kv(r, e) {
    switch (e.constructor) {
      case Float32Array:
        return r;
      case Uint32Array:
        return r / 4294967295;
      case Uint16Array:
        return r / 65535;
      case Uint8Array:
        return r / 255;
      case Int32Array:
        return Math.max(r / 2147483647, -1);
      case Int16Array:
        return Math.max(r / 32767, -1);
      case Int8Array:
        return Math.max(r / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function vy(r, e) {
    switch (e.constructor) {
      case Float32Array:
        return r;
      case Uint32Array:
        return Math.round(r * 4294967295);
      case Uint16Array:
        return Math.round(r * 65535);
      case Uint8Array:
        return Math.round(r * 255);
      case Int32Array:
        return Math.round(r * 2147483647);
      case Int16Array:
        return Math.round(r * 32767);
      case Int8Array:
        return Math.round(r * 127);
      default:
        throw new Error("Invalid component type.");
    }
  }
  var U6 = "155";
  var z6 = 0, vV = 1, q6 = 2;
  var Wv = 0, lm = 1, ua = 2;
  var wk = 0,
    hh = 1,
    CV = 2,
    SV = 3,
    EV = 4,
    vk = 5,
    Od = 100,
    H6 = 101,
    K6 = 102,
    W6 = 103,
    $6 = 104,
    Ck = 200,
    Sk = 201,
    j6 = 202,
    Y6 = 203,
    Ek = 204,
    Tk = 205,
    X6 = 206,
    J6 = 207,
    Q6 = 208,
    Z6 = 209,
    eW = 210,
    tW = 0,
    rW = 1,
    oW = 2,
    $v = 3,
    iW = 4,
    nW = 5,
    aW = 6,
    sW = 7;
  var TV = 300;
  var jv = 1e3, cm = 1001, Yv = 1002, Rd = 1003, lW = 1004;
  var DV = 1005;
  var ml = 1006, cW = 1007;
  var Xv = 1008;
  var Vn = 1009,
    dW = 1010,
    pW = 1011,
    Cy = 1012,
    Dk = 1013,
    Ac = 1014,
    Xl = 1015,
    Sy = 1016,
    kk = 1017,
    _k = 1018,
    Fd = 1020,
    uW = 1021,
    Nd = 1023,
    hW = 1024,
    gW = 1025,
    Yp = 1026,
    gh = 1027,
    mW = 1028,
    Ik = 1029,
    fW = 1030,
    Ak = 1031,
    Mk = 1033,
    Gk = 33776,
    Lk = 33777,
    Pk = 33778,
    Vk = 33779,
    kV = 35840,
    _V = 35841,
    IV = 35842,
    AV = 35843,
    bW = 36196,
    MV = 37492,
    GV = 37496,
    LV = 37808,
    PV = 37809,
    VV = 37810,
    OV = 37811,
    RV = 37812,
    FV = 37813,
    NV = 37814,
    BV = 37815,
    UV = 37816,
    zV = 37817,
    qV = 37818,
    HV = 37819,
    KV = 37820,
    WV = 37821,
    $V = 36492,
    jV = 36283,
    YV = 36284,
    XV = 36285,
    JV = 36286;
  var Ey = "", Lo = "srgb", Ga = "srgb-linear";
  var Ok = 7680;
  var yW = 519,
    xW = 512,
    wW = 513,
    vW = 514,
    CW = 515,
    SW = 516,
    EW = 517,
    TW = 518,
    DW = 519,
    kW = 35044;
  var QV = "300 es", Rk = 1035, Jl = 2e3, Jv = 2001;
  var ye = class r {
    constructor(e = 0, t = 0, o = 0) {
      this.x = e, this.y = t, this.z = o;
    }
    set(e, t, o) {
      return o === void 0 && (o = this.z),
        this.x = e,
        this.y = t,
        this.z = o,
        this;
    }
    clone() {
      return new r(this.x, this.y, this.z);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this.z = e.z, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this.z += e.z, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this.z -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this;
    }
    applyMatrix3(e) {
      let t = this.x, o = this.y, i = this.z, n = e.elements;
      return this.x = n[0] * t + n[3] * o + n[6] * i,
        this.y = n[1] * t + n[4] * o + n[7] * i,
        this.z = n[2] * t + n[5] * o + n[8] * i,
        this;
    }
    applyNormalMatrix(e) {
      return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
      let t = this.x,
        o = this.y,
        i = this.z,
        n = e.elements,
        a = 1 / (n[3] * t + n[7] * o + n[11] * i + n[15]);
      return this.x = (n[0] * t + n[4] * o + n[8] * i + n[12]) * a,
        this.y = (n[1] * t + n[5] * o + n[9] * i + n[13]) * a,
        this.z = (n[2] * t + n[6] * o + n[10] * i + n[14]) * a,
        this;
    }
    applyQuaternion(e) {
      let t = this.x,
        o = this.y,
        i = this.z,
        n = e.x,
        a = e.y,
        s = e.z,
        l = e.w,
        c = l * t + a * i - s * o,
        d = l * o + s * t - n * i,
        p = l * i + n * o - a * t,
        h = -n * t - a * o - s * i;
      return this.x = c * l + h * -n + d * -s - p * -a,
        this.y = d * l + h * -a + p * -n - c * -s,
        this.z = p * l + h * -s + c * -a - d * -n,
        this;
    }
    project(e) {
      return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
        e.projectionMatrix,
      );
    }
    transformDirection(e) {
      let t = this.x, o = this.y, i = this.z, n = e.elements;
      return this.x = n[0] * t + n[4] * o + n[8] * i,
        this.y = n[1] * t + n[5] * o + n[9] * i,
        this.z = n[2] * t + n[6] * o + n[10] * i,
        this.normalize();
    }
    min(e) {
      return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z,
      );
    }
    normalize() {
      return this.multiplyScalar(1 / (this.length() || 1));
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this;
    }
    cross(e) {
      return this.crossVectors(this, e);
    }
    crossVectors(e, t) {
      let o = e.x, i = e.y, n = e.z, a = t.x, s = t.y, l = t.z;
      return this.x = i * l - n * s,
        this.y = n * a - o * l,
        this.z = o * s - i * a,
        this;
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      let t = this.x - e.x, o = this.y - e.y, i = this.z - e.z;
      return t * t + o * o + i * i;
    }
    setFromMatrixPosition(e) {
      let t = e.elements;
      return this.x = t[12], this.y = t[13], this.z = t[14], this;
    }
    setFromMatrixColumn(e, t) {
      let o = t * 4, i = e.elements;
      return this.x = i[o], this.y = i[o + 1], this.z = i[o + 2], this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    toArray(e, t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
    }
  };
  var Nt = class r {
      constructor(e, t, o, i, n, a, s, l, c, d, p, h, u, f, y, C) {
        this.isMatrix4 = true;
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
          e !== void 0 &&
          this.set(e, t, o, i, n, a, s, l, c, d, p, h, u, f, y, C);
      }
      set(e, t, o, i, n, a, s, l, c, d, p, h, u, f, y, C) {
        let E = this.elements;
        return E[0] = e,
          E[4] = t,
          E[8] = o,
          E[12] = i,
          E[1] = n,
          E[5] = a,
          E[9] = s,
          E[13] = l,
          E[2] = c,
          E[6] = d,
          E[10] = p,
          E[14] = h,
          E[3] = u,
          E[7] = f,
          E[11] = y,
          E[15] = C,
          this;
      }
      clone() {
        let e = new r(), t = this.elements;
        for (let o = 0; o < 16; o++) e.elements[o] = t[o];
        return e;
      }
      copy(e) {
        let t = this.elements, o = e.elements;
        return t[0] = o[0],
          t[1] = o[1],
          t[2] = o[2],
          t[3] = o[3],
          t[4] = o[4],
          t[5] = o[5],
          t[6] = o[6],
          t[7] = o[7],
          t[8] = o[8],
          t[9] = o[9],
          t[10] = o[10],
          t[11] = o[11],
          t[12] = o[12],
          t[13] = o[13],
          t[14] = o[14],
          t[15] = o[15],
          this;
      }
      setFromMatrix3(e) {
        let t = e.elements;
        return this.set(
          t[0],
          t[3],
          t[6],
          0,
          t[1],
          t[4],
          t[7],
          0,
          t[2],
          t[5],
          t[8],
          0,
          0,
          0,
          0,
          1,
        ),
          this;
      }
      extractRotation(e) {
        let t = this.elements,
          o = e.elements,
          i = 1 / ZV.setFromMatrixColumn(e, 0).length(),
          n = 1 / ZV.setFromMatrixColumn(e, 1).length(),
          a = 1 / ZV.setFromMatrixColumn(e, 2).length();
        return t[0] = o[0] * i,
          t[1] = o[1] * i,
          t[2] = o[2] * i,
          t[3] = 0,
          t[4] = o[4] * n,
          t[5] = o[5] * n,
          t[6] = o[6] * n,
          t[7] = 0,
          t[8] = o[8] * a,
          t[9] = o[9] * a,
          t[10] = o[10] * a,
          t[11] = 0,
          t[12] = 0,
          t[13] = 0,
          t[14] = 0,
          t[15] = 1,
          this;
      }
      makeRotationFromEuler(e) {
        let t = this.elements,
          o = e.x,
          i = e.y,
          n = e.z,
          a = Math.cos(o),
          s = Math.sin(o),
          l = Math.cos(i),
          c = Math.sin(i),
          d = Math.cos(n),
          p = Math.sin(n);
        if (e.order === "XYZ") {
          let h = a * d, u = a * p, f = s * d, y = s * p;
          t[0] = l * d,
            t[4] = -l * p,
            t[8] = c,
            t[1] = u + f * c,
            t[5] = h - y * c,
            t[9] = -s * l,
            t[2] = y - h * c,
            t[6] = f + u * c,
            t[10] = a * l;
        } else if (e.order === "YXZ") {
          let h = l * d, u = l * p, f = c * d, y = c * p;
          t[0] = h + y * s,
            t[4] = f * s - u,
            t[8] = a * c,
            t[1] = a * p,
            t[5] = a * d,
            t[9] = -s,
            t[2] = u * s - f,
            t[6] = y + h * s,
            t[10] = a * l;
        } else if (e.order === "ZYX") {
          let h = a * d, u = a * p, f = s * d, y = s * p;
          t[0] = l * d,
            t[4] = f * c - u,
            t[8] = h * c + y,
            t[1] = l * p,
            t[5] = y * c + h,
            t[9] = u * c - f,
            t[2] = -c,
            t[6] = s * l,
            t[10] = a * l;
        }
        return t[3] = 0,
          t[7] = 0,
          t[11] = 0,
          t[12] = 0,
          t[13] = 0,
          t[14] = 0,
          t[15] = 1,
          this;
      }
      makeRotationFromQuaternion(e) {
        return this.compose(cae, e, dae);
      }
      lookAt(e, t, o) {
        let i = this.elements;
        return fl.subVectors(e, t),
          fl.lengthSq() === 0 && (fl.z = 1),
          fl.normalize(),
          mh.crossVectors(o, fl),
          mh.lengthSq() === 0 &&
          (Math.abs(o.z) === 1 ? fl.x += 1e-4 : fl.z += 1e-4,
            fl.normalize(),
            mh.crossVectors(o, fl)),
          mh.normalize(),
          Fk.crossVectors(fl, mh),
          i[0] = mh.x,
          i[4] = Fk.x,
          i[8] = fl.x,
          i[1] = mh.y,
          i[5] = Fk.y,
          i[9] = fl.y,
          i[2] = mh.z,
          i[6] = Fk.z,
          i[10] = fl.z,
          this;
      }
      multiply(e) {
        return this.multiplyMatrices(this, e);
      }
      multiplyMatrices(e, t) {
        let o = e.elements,
          i = t.elements,
          n = this.elements,
          a = o[0],
          s = o[4],
          l = o[8],
          c = o[12],
          d = o[1],
          p = o[5],
          h = o[9],
          u = o[13],
          f = o[2],
          y = o[6],
          C = o[10],
          E = o[14],
          v = o[3],
          w = o[7],
          S = o[11],
          k = o[15],
          _ = i[0],
          A = i[4],
          P = i[8],
          O = i[12],
          U = i[1],
          z = i[5],
          x = i[9],
          L = i[13],
          V = i[2],
          R = i[6],
          N = i[10],
          M = i[14],
          F = i[3],
          Z = i[7],
          te = i[11],
          Y = i[15];
        return n[0] = a * _ + s * U + l * V + c * F,
          n[4] = a * A + s * z + l * R + c * Z,
          n[8] = a * P + s * x + l * N + c * te,
          n[12] = a * O + s * L + l * M + c * Y,
          n[1] = d * _ + p * U + h * V + u * F,
          n[5] = d * A + p * z + h * R + u * Z,
          n[9] = d * P + p * x + h * N + u * te,
          n[13] = d * O + p * L + h * M + u * Y,
          n[2] = f * _ + y * U + C * V + E * F,
          n[6] = f * A + y * z + C * R + E * Z,
          n[10] = f * P + y * x + C * N + E * te,
          n[14] = f * O + y * L + C * M + E * Y,
          n[3] = v * _ + w * U + S * V + k * F,
          n[7] = v * A + w * z + S * R + k * Z,
          n[11] = v * P + w * x + S * N + k * te,
          n[15] = v * O + w * L + S * M + k * Y,
          this;
      }
      determinant() {
        let e = this.elements,
          t = e[0],
          o = e[4],
          i = e[8],
          n = e[12],
          a = e[1],
          s = e[5],
          l = e[9],
          c = e[13],
          d = e[2],
          p = e[6],
          h = e[10],
          u = e[14],
          f = e[3],
          y = e[7],
          C = e[11],
          E = e[15];
        return f *
            (+n * l * p - i * c * p - n * s * h + o * c * h + i * s * u -
              o * l * u) +
          y *
            (+t * l * u - t * c * h + n * a * h - i * a * u + i * c * d -
              n * l * d) +
          C *
            (+t * c * p - t * s * u - n * a * p + o * a * u + n * s * d -
              o * c * d) +
          E *
            (-i * s * d - t * l * p + t * s * h + i * a * p - o * a * h +
              o * l * d);
      }
      invert() {
        let e = this.elements,
          t = e[0],
          o = e[1],
          i = e[2],
          n = e[3],
          a = e[4],
          s = e[5],
          l = e[6],
          c = e[7],
          d = e[8],
          p = e[9],
          h = e[10],
          u = e[11],
          f = e[12],
          y = e[13],
          C = e[14],
          E = e[15],
          v = p * C * c - y * h * c + y * l * u - s * C * u - p * l * E +
            s * h * E,
          w = f * h * c - d * C * c - f * l * u + a * C * u + d * l * E -
            a * h * E,
          S = d * y * c - f * p * c + f * s * u - a * y * u - d * s * E +
            a * p * E,
          k = f * p * l - d * y * l - f * s * h + a * y * h + d * s * C -
            a * p * C,
          _ = t * v + o * w + i * S + n * k;
        if (_ === 0) {
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        let A = 1 / _;
        return e[0] = v * A,
          e[1] = (y * h * n - p * C * n - y * i * u + o * C * u + p * i * E -
            o * h * E) * A,
          e[2] = (s * C * n - y * l * n + y * i * c - o * C * c - s * i * E +
            o * l * E) * A,
          e[3] = (p * l * n - s * h * n - p * i * c + o * h * c + s * i * u -
            o * l * u) * A,
          e[4] = w * A,
          e[5] = (d * C * n - f * h * n + f * i * u - t * C * u - d * i * E +
            t * h * E) * A,
          e[6] = (f * l * n - a * C * n - f * i * c + t * C * c + a * i * E -
            t * l * E) * A,
          e[7] = (a * h * n - d * l * n + d * i * c - t * h * c - a * i * u +
            t * l * u) * A,
          e[8] = S * A,
          e[9] = (f * p * n - d * y * n - f * o * u + t * y * u + d * o * E -
            t * p * E) * A,
          e[10] = (a * y * n - f * s * n + f * o * c - t * y * c - a * o * E +
            t * s * E) * A,
          e[11] = (d * s * n - a * p * n - d * o * c + t * p * c + a * o * u -
            t * s * u) * A,
          e[12] = k * A,
          e[13] = (d * y * i - f * p * i + f * o * h - t * y * h - d * o * C +
            t * p * C) * A,
          e[14] = (f * s * i - a * y * i - f * o * l + t * y * l + a * o * C -
            t * s * C) * A,
          e[15] = (a * p * i - d * s * i + d * o * l - t * p * l - a * o * h +
            t * s * h) * A,
          this;
      }
      getMaxScaleOnAxis() {
        let e = this.elements,
          t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
          o = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
          i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, o, i));
      }
      makeTranslation(e, t, o) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, o, 0, 0, 0, 1), this;
      }
      makeRotationX(e) {
        let t = Math.cos(e), o = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -o, 0, 0, o, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(e, t) {
        let o = Math.cos(t),
          i = Math.sin(t),
          n = 1 - o,
          a = e.x,
          s = e.y,
          l = e.z,
          c = n * a,
          d = n * s;
        return this.set(
          c * a + o,
          c * s - i * l,
          c * l + i * s,
          0,
          c * s + i * l,
          d * s + o,
          d * l - i * a,
          0,
          c * l - i * s,
          d * l + i * a,
          n * l * l + o,
          0,
          0,
          0,
          0,
          1,
        ),
          this;
      }
      makeScale(e, t, o) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, o, 0, 0, 0, 0, 1), this;
      }
      compose(e, t, o) {
        let i = this.elements,
          n = t._x,
          a = t._y,
          s = t._z,
          l = t._w,
          c = n + n,
          d = a + a,
          p = s + s,
          h = n * c,
          u = n * d,
          f = n * p,
          y = a * d,
          C = a * p,
          E = s * p,
          v = l * c,
          w = l * d,
          S = l * p,
          k = o.x,
          _ = o.y,
          A = o.z;
        return i[0] = (1 - (y + E)) * k,
          i[1] = (u + S) * k,
          i[2] = (f - w) * k,
          i[3] = 0,
          i[4] = (u - S) * _,
          i[5] = (1 - (h + E)) * _,
          i[6] = (C + v) * _,
          i[7] = 0,
          i[8] = (f + w) * A,
          i[9] = (C - v) * A,
          i[10] = (1 - (h + y)) * A,
          i[11] = 0,
          i[12] = e.x,
          i[13] = e.y,
          i[14] = e.z,
          i[15] = 1,
          this;
      }
      makePerspective(e, t, o, i, n, a, s = Jl) {
        let l = this.elements,
          c = 2 * n / (t - e),
          d = 2 * n / (o - i),
          p = (t + e) / (t - e),
          h = (o + i) / (o - i),
          u,
          f;
        if (s === Jl) u = -(a + n) / (a - n), f = -2 * a * n / (a - n);
        else if (s === Jv) u = -a / (a - n), f = -a * n / (a - n);
        else {throw new Error(
            "THREE.Matrix4.makePerspective(): Invalid coordinate system: " +
              s,
          );}
        return l[0] = c,
          l[4] = 0,
          l[8] = p,
          l[12] = 0,
          l[1] = 0,
          l[5] = d,
          l[9] = h,
          l[13] = 0,
          l[2] = 0,
          l[6] = 0,
          l[10] = u,
          l[14] = f,
          l[3] = 0,
          l[7] = 0,
          l[11] = -1,
          l[15] = 0,
          this;
      }
      makeOrthographic(e, t, o, i, n, a, s = Jl) {
        let l = this.elements,
          c = 1 / (t - e),
          d = 1 / (o - i),
          p = 1 / (a - n),
          h = (t + e) * c,
          u = (o + i) * d,
          f,
          y;
        if (s === Jl) f = (a + n) * p, y = -2 * p;
        else if (s === Jv) f = n * p, y = -1 * p;
        else {throw new Error(
            "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
              s,
          );}
        return l[0] = 2 * c,
          l[4] = 0,
          l[8] = 0,
          l[12] = -h,
          l[1] = 0,
          l[5] = 2 * d,
          l[9] = 0,
          l[13] = -u,
          l[2] = 0,
          l[6] = 0,
          l[10] = y,
          l[14] = -f,
          l[3] = 0,
          l[7] = 0,
          l[11] = 0,
          l[15] = 1,
          this;
      }
      equals(e) {
        let t = this.elements, o = e.elements;
        for (let i = 0; i < 16; i++) if (t[i] !== o[i]) return false;
        return true;
      }
      fromArray(e, t = 0) {
        for (let o = 0; o < 16; o++) this.elements[o] = e[o + t];
        return this;
      }
      toArray(e, t = 0) {
        let o = this.elements;
        return e[t] = o[0],
          e[t + 1] = o[1],
          e[t + 2] = o[2],
          e[t + 3] = o[3],
          e[t + 4] = o[4],
          e[t + 5] = o[5],
          e[t + 6] = o[6],
          e[t + 7] = o[7],
          e[t + 8] = o[8],
          e[t + 9] = o[9],
          e[t + 10] = o[10],
          e[t + 11] = o[11],
          e[t + 12] = o[12],
          e[t + 13] = o[13],
          e[t + 14] = o[14],
          e[t + 15] = o[15],
          e;
      }
    },
    ZV = new ye(),
    cae = new ye(0, 0, 0),
    dae = new ye(1, 1, 1),
    mh = new ye(),
    Fk = new ye(),
    fl = new ye();
  var _W = new Nt(),
    Fs = class {
      constructor(e = 0, t = 0, o = 0, i = "XYZ") {
        this._x = e, this._y = t, this._z = o, this._order = i;
      }
      get x() {
        return this._x;
      }
      set x(e) {
        this._x = e, this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        this._y = e, this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        this._z = e, this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(e) {
        this._order = e, this._onChangeCallback();
      }
      set(e, t, o, i = this._order) {
        return this._x = e,
          this._y = t,
          this._z = o,
          this._order = i,
          this._onChangeCallback(),
          this;
      }
      setFromRotationMatrix(e, t = this._order, o = true) {
        let i = e.elements,
          n = i[0],
          a = i[4],
          s = i[8],
          l = i[1],
          c = i[5],
          d = i[9],
          p = i[2],
          h = i[6],
          u = i[10];
        switch (t) {
          case "XYZ":
            this._y = Math.asin(sm(s, -1, 1)),
              Math.abs(s) < .9999999
                ? (this._x = Math.atan2(-d, u), this._z = Math.atan2(-a, n))
                : (this._x = Math.atan2(h, c), this._z = 0);
            break;
          case "YXZ":
            this._x = Math.asin(-sm(d, -1, 1)),
              Math.abs(d) < .9999999
                ? (this._y = Math.atan2(s, u), this._z = Math.atan2(l, c))
                : (this._y = Math.atan2(-p, n), this._z = 0);
            break;
          case "ZYX":
            this._y = Math.asin(-sm(p, -1, 1)),
              Math.abs(p) < .9999999
                ? (this._x = Math.atan2(h, u), this._z = Math.atan2(l, n))
                : (this._x = 0, this._z = Math.atan2(-a, c));
            break;
          default:
            console.warn(
              "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                t,
            );
        }
        return this._order = t, o === true && this._onChangeCallback(), this;
      }
      setFromQuaternion(e, t, o) {
        return _W.makeRotationFromQuaternion(e),
          this.setFromRotationMatrix(_W, t, o);
      }
      toArray(e = [], t = 0) {
        return e[t] = this._x,
          e[t + 1] = this._y,
          e[t + 2] = this._z,
          e[t + 3] = this._order,
          e;
      }
      _onChange(e) {
        return this._onChangeCallback = e, this;
      }
      _onChangeCallback() {}
    };
  var Po = class r {
    constructor(e, t, o, i, n, a, s, l, c) {
      this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, o, i, n, a, s, l, c);
    }
    set(e, t, o, i, n, a, s, l, c) {
      let d = this.elements;
      return d[0] = e,
        d[1] = i,
        d[2] = s,
        d[3] = t,
        d[4] = n,
        d[5] = l,
        d[6] = o,
        d[7] = a,
        d[8] = c,
        this;
    }
    copy(e) {
      let t = this.elements, o = e.elements;
      return t[0] = o[0],
        t[1] = o[1],
        t[2] = o[2],
        t[3] = o[3],
        t[4] = o[4],
        t[5] = o[5],
        t[6] = o[6],
        t[7] = o[7],
        t[8] = o[8],
        this;
    }
    setFromMatrix4(e) {
      let t = e.elements;
      return this.set(
        t[0],
        t[4],
        t[8],
        t[1],
        t[5],
        t[9],
        t[2],
        t[6],
        t[10],
      ),
        this;
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    multiplyMatrices(e, t) {
      let o = e.elements,
        i = t.elements,
        n = this.elements,
        a = o[0],
        s = o[3],
        l = o[6],
        c = o[1],
        d = o[4],
        p = o[7],
        h = o[2],
        u = o[5],
        f = o[8],
        y = i[0],
        C = i[3],
        E = i[6],
        v = i[1],
        w = i[4],
        S = i[7],
        k = i[2],
        _ = i[5],
        A = i[8];
      return n[0] = a * y + s * v + l * k,
        n[3] = a * C + s * w + l * _,
        n[6] = a * E + s * S + l * A,
        n[1] = c * y + d * v + p * k,
        n[4] = c * C + d * w + p * _,
        n[7] = c * E + d * S + p * A,
        n[2] = h * y + u * v + f * k,
        n[5] = h * C + u * w + f * _,
        n[8] = h * E + u * S + f * A,
        this;
    }
    invert() {
      let e = this.elements,
        t = e[0],
        o = e[1],
        i = e[2],
        n = e[3],
        a = e[4],
        s = e[5],
        l = e[6],
        c = e[7],
        d = e[8],
        p = d * a - s * c,
        h = s * l - d * n,
        u = c * n - a * l,
        f = t * p + o * h + i * u;
      if (f === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      let y = 1 / f;
      return e[0] = p * y,
        e[1] = (i * c - d * o) * y,
        e[2] = (s * o - i * a) * y,
        e[3] = h * y,
        e[4] = (d * t - i * l) * y,
        e[5] = (i * n - s * t) * y,
        e[6] = u * y,
        e[7] = (o * l - c * t) * y,
        e[8] = (a * t - o * n) * y,
        this;
    }
    transpose() {
      let e, t = this.elements;
      return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this;
    }
    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }
    equals(e) {
      let t = this.elements, o = e.elements;
      for (let i = 0; i < 9; i++) if (t[i] !== o[i]) return false;
      return true;
    }
    toArray(e, t = 0) {
      let o = this.elements;
      return e[t] = o[0],
        e[t + 1] = o[1],
        e[t + 2] = o[2],
        e[t + 3] = o[3],
        e[t + 4] = o[4],
        e[t + 5] = o[5],
        e[t + 6] = o[6],
        e[t + 7] = o[7],
        e[t + 8] = o[8],
        e;
    }
    clone() {
      let e = new r(), t = this.elements;
      for (let o = 0; o < 9; o++) e.elements[o] = t[o];
      return e;
    }
  };
  var Ql = class r {
    constructor(e = 0, t = 0, o = 0, i = 1) {
      this.isQuaternion = true;
      this._x = e, this._y = t, this._z = o, this._w = i;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x = e, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y = e, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      this._z = e, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(e) {
      this._w = e, this._onChangeCallback();
    }
    set(e, t, o, i) {
      return this._x = e,
        this._y = t,
        this._z = o,
        this._w = i,
        this._onChangeCallback(),
        this;
    }
    clone() {
      return new r(this._x, this._y, this._z, this._w);
    }
    copy(e) {
      return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this;
    }
    setFromEuler(e, t) {
      let o = e._x,
        i = e._y,
        n = e._z,
        a = e._order,
        s = Math.cos,
        l = Math.sin,
        c = s(o / 2),
        d = s(i / 2),
        p = s(n / 2),
        h = l(o / 2),
        u = l(i / 2),
        f = l(n / 2);
      switch (a) {
        case "XYZ":
          this._x = h * d * p + c * u * f,
            this._y = c * u * p - h * d * f,
            this._z = c * d * f + h * u * p,
            this._w = c * d * p - h * u * f;
          break;
        case "YXZ":
          this._x = h * d * p + c * u * f,
            this._y = c * u * p - h * d * f,
            this._z = c * d * f - h * u * p,
            this._w = c * d * p + h * u * f;
          break;
        case "ZYX":
          this._x = h * d * p - c * u * f,
            this._y = c * u * p + h * d * f,
            this._z = c * d * f - h * u * p,
            this._w = c * d * p + h * u * f;
          break;
        default:
          console.warn(
            "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
              a,
          );
      }
      return t !== false && this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e) {
      let t = e.elements,
        o = t[0],
        i = t[4],
        n = t[8],
        a = t[1],
        s = t[5],
        l = t[9],
        c = t[2],
        d = t[6],
        p = t[10],
        h = o + s + p;
      if (h > 0) {
        let u = .5 / Math.sqrt(h + 1);
        this._w = .25 / u,
          this._x = (d - l) * u,
          this._y = (n - c) * u,
          this._z = (a - i) * u;
      } else if (o > s && o > p) {
        let u = 2 * Math.sqrt(1 + o - s - p);
        this._w = (d - l) / u,
          this._x = .25 * u,
          this._y = (i + a) / u,
          this._z = (n + c) / u;
      } else if (s > p) {
        let u = 2 * Math.sqrt(1 + s - o - p);
        this._w = (n - c) / u,
          this._x = (i + a) / u,
          this._y = .25 * u,
          this._z = (l + d) / u;
      } else {
        let u = 2 * Math.sqrt(1 + p - o - s);
        this._w = (a - i) / u,
          this._x = (n + c) / u,
          this._y = (l + d) / u,
          this._z = .25 * u;
      }
      return this._onChangeCallback(), this;
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this;
    }
    dot(e) {
      return this._x * e._x + this._y * e._y + this._z * e._z +
        this._w * e._w;
    }
    length() {
      return Math.sqrt(
        this._x * this._x + this._y * this._y + this._z * this._z +
          this._w * this._w,
      );
    }
    normalize() {
      let e = this.length();
      return e === 0
        ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1)
        : (e = 1 / e,
          this._x = this._x * e,
          this._y = this._y * e,
          this._z = this._z * e,
          this._w = this._w * e),
        this._onChangeCallback(),
        this;
    }
    multiply(e) {
      return this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
      return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
      let o = e._x,
        i = e._y,
        n = e._z,
        a = e._w,
        s = t._x,
        l = t._y,
        c = t._z,
        d = t._w;
      return this._x = o * d + a * s + i * c - n * l,
        this._y = i * d + a * l + n * s - o * c,
        this._z = n * d + a * c + o * l - i * s,
        this._w = a * d - o * s - i * l - n * c,
        this._onChangeCallback(),
        this;
    }
    slerp(e, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(e);
      let o = this._x,
        i = this._y,
        n = this._z,
        a = this._w,
        s = a * e._w + o * e._x + i * e._y + n * e._z;
      if (
        s < 0
          ? (this._w = -e._w,
            this._x = -e._x,
            this._y = -e._y,
            this._z = -e._z,
            s = -s)
          : this.copy(e), s >= 1
      ) return this._w = a, this._x = o, this._y = i, this._z = n, this;
      let l = 1 - s * s;
      if (l <= Number.EPSILON) {
        let u = 1 - t;
        return this._w = u * a + t * this._w,
          this._x = u * o + t * this._x,
          this._y = u * i + t * this._y,
          this._z = u * n + t * this._z,
          this.normalize(),
          this._onChangeCallback(),
          this;
      }
      let c = Math.sqrt(l),
        d = Math.atan2(c, s),
        p = Math.sin((1 - t) * d) / c,
        h = Math.sin(t * d) / c;
      return this._w = a * p + this._w * h,
        this._x = o * p + this._x * h,
        this._y = i * p + this._y * h,
        this._z = n * p + this._z * h,
        this._onChangeCallback(),
        this;
    }
    toArray(e, t = 0) {
      return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e;
    }
    fromBufferAttribute(e, t) {
      return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this;
    }
    _onChange(e) {
      return this._onChangeCallback = e, this;
    }
    _onChangeCallback() {}
  };
  var hs = new ye(),
    ha = class {
      constructor(e, t, o = false) {
        this.isBufferAttribute = true;
        if (Array.isArray(e)) {
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array.",
          );
        }
        this.name = "",
          this.array = e,
          this.itemSize = t,
          this.count = e !== void 0 ? e.length / t : 0,
          this.normalized = o,
          this.usage = kW,
          this.updateRange = { offset: 0, count: -1 },
          this.gpuType = Xl,
          this.version = 0;
      }
      onUploadCallback() {}
      set needsUpdate(e) {
        e === true && this.version++;
      }
      applyMatrix4(e) {
        for (let t = 0, o = this.count; t < o; t++) {
          hs.fromBufferAttribute(this, t),
            hs.applyMatrix4(e),
            this.setXYZ(t, hs.x, hs.y, hs.z);
        }
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, o = this.count; t < o; t++) {
          hs.fromBufferAttribute(this, t),
            hs.applyNormalMatrix(e),
            this.setXYZ(t, hs.x, hs.y, hs.z);
        }
        return this;
      }
      transformDirection(e) {
        for (let t = 0, o = this.count; t < o; t++) {
          hs.fromBufferAttribute(this, t),
            hs.transformDirection(e),
            this.setXYZ(t, hs.x, hs.y, hs.z);
        }
        return this;
      }
      getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Kv(t, this.array)), t;
      }
      getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Kv(t, this.array)), t;
      }
      getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Kv(t, this.array)), t;
      }
      getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Kv(t, this.array)), t;
      }
      setXY(e, t, o) {
        return e *= this.itemSize,
          this.normalized &&
          (t = vy(t, this.array), o = vy(o, this.array)),
          this.array[e + 0] = t,
          this.array[e + 1] = o,
          this;
      }
      setXYZ(e, t, o, i) {
        return e *= this.itemSize,
          this.normalized &&
          (t = vy(t, this.array), o = vy(o, this.array), i = vy(i, this.array)),
          this.array[e + 0] = t,
          this.array[e + 1] = o,
          this.array[e + 2] = i,
          this;
      }
    };
  var fh = class extends ha {
    constructor(e, t, o) {
      super(new Uint16Array(e), t, o);
    }
  };
  var bh = class extends ha {
      constructor(e, t, o) {
        super(new Uint32Array(e), t, o);
      }
    },
    Bo = class extends ha {
      constructor(e, t, o) {
        super(new Float32Array(e), t, o);
      }
    };
  var Ns = class {
    hasEventListener(e, t) {
      if (this._listeners === void 0) return false;
      let o = this._listeners;
      return o[e] !== void 0 && o[e].indexOf(t) !== -1;
    }
    addEventListener(e, t) {
      this._listeners === void 0 && (this._listeners = {});
      let o = this._listeners;
      o[e] === void 0 && (o[e] = []), o[e].indexOf(t) === -1 && o[e].push(t);
    }
    removeEventListener(e, t) {
      if (this._listeners === void 0) return;
      let i = this._listeners[e];
      if (i !== void 0) {
        let n = i.indexOf(t);
        n !== -1 && i.splice(n, 1);
      }
    }
    dispatchEvent(e) {
      if (this._listeners === void 0) return;
      let o = this._listeners[e.type];
      if (o !== void 0) {
        e.target = this;
        let i = o.slice(0);
        for (let n = 0, a = i.length; n < a; n++) i[n].call(this, e);
        e.target = null;
      }
    }
  };
  var Ty = class {
    constructor() {
      this.mask = 1;
    }
    enable(e) {
      this.mask |= 1 << e | 0;
    }
    disableAll() {
      this.mask = 0;
    }
    test(e) {
      return (this.mask & e.mask) !== 0;
    }
  };
  var pae = 0,
    IW = new ye(),
    AW = new Ql(),
    Qv = new Nt(),
    eO = new ye(),
    tO = new ye(),
    uae = new ye(1, 0, 0),
    hae = new ye(0, 1, 0),
    gae = new ye(0, 0, 1),
    mae = { type: "added" },
    fae = { type: "removed" },
    yh = class yh extends Ns {
      constructor() {
        super();
        this.isObject3D = true;
        Object.defineProperty(this, "id", { value: pae++ }),
          this.uuid = Yl(),
          this.name = "",
          this.type = "Object3D",
          this.parent = null,
          this.children = [],
          this.up = yh.DEFAULT_UP.clone();
        let t = new ye(), o = new Fs(), i = new Ql(), n = new ye(1, 1, 1);
        function a() {
          i.setFromEuler(o, false);
        }
        function s() {
          o.setFromQuaternion(i, void 0, false);
        }
        o._onChange(a),
          i._onChange(s),
          Object.defineProperties(this, {
            position: { configurable: true, enumerable: true, value: t },
            rotation: { configurable: true, enumerable: true, value: o },
            quaternion: { configurable: true, enumerable: true, value: i },
            scale: { configurable: true, enumerable: true, value: n },
            modelViewMatrix: { value: new Nt() },
            normalMatrix: { value: new Po() },
          }),
          this.matrix = new Nt(),
          this.matrixWorld = new Nt(),
          this.dcgModelMatrix = new Nt(),
          this.matrixAutoUpdate = yh.DEFAULT_MATRIX_AUTO_UPDATE,
          this.matrixWorldNeedsUpdate = false,
          this.matrixWorldAutoUpdate = yh.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
          this.layers = new Ty(),
          this.visible = true,
          this.frustumCulled = true,
          this.renderOrder = 0,
          this.userData = {};
      }
      setPickingColorArray(t) {
        this.pickingColorArray = t;
        let { repeatColorCounts: o, colors: i } = t, n = [];
        for (let a = 0; a < o.length; a++) {
          let s = i[a], l = o[a];
          for (let c = 0; c < l; c++) n.push(...s);
        }
        this.geometry &&
          this.geometry.setAttribute(
            "vertexPickingColor",
            new ha(new Float32Array(n), 4),
          );
      }
      setRotationFromEuler(t) {
        this.quaternion.setFromEuler(t, true);
      }
      setRotationFromMatrix(t) {
        this.quaternion.setFromRotationMatrix(t);
      }
      translateOnAxis(t, o) {
        return IW.copy(t).applyQuaternion(this.quaternion),
          this.position.add(IW.multiplyScalar(o)),
          this;
      }
      translateX(t) {
        return this.translateOnAxis(uae, t);
      }
      translateY(t) {
        return this.translateOnAxis(hae, t);
      }
      translateZ(t) {
        return this.translateOnAxis(gae, t);
      }
      lookAt(t) {
        eO.copy(t);
        let o = this.parent;
        this.updateWorldMatrix(true, false),
          tO.setFromMatrixPosition(this.matrixWorld),
          this.isCamera || this.isLight
            ? Qv.lookAt(tO, eO, this.up)
            : Qv.lookAt(eO, tO, this.up),
          this.quaternion.setFromRotationMatrix(Qv),
          o &&
          (Qv.extractRotation(o.matrixWorld),
            AW.setFromRotationMatrix(Qv),
            this.quaternion.premultiply(AW.invert()));
      }
      add(t) {
        if (arguments.length > 1) {
          for (let o = 0; o < arguments.length; o++) {
            this.add(arguments[o]);
          }
          return this;
        }
        return t === this
          ? (console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            t,
          ),
            this)
          : (t && t.isObject3D
            ? (t.parent !== null && t.parent.remove(t),
              t.parent = this,
              this.children.push(t),
              t.dispatchEvent(mae))
            : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              t,
            ),
            this);
      }
      remove(t) {
        if (arguments.length > 1) {
          for (let i = 0; i < arguments.length; i++) {
            this.remove(arguments[i]);
          }
          return this;
        }
        let o = this.children.indexOf(t);
        return o !== -1 &&
          (t.parent = null, this.children.splice(o, 1), t.dispatchEvent(fae)),
          this;
      }
      getObjectByName(t) {
        return this.getObjectByProperty("name", t);
      }
      getObjectByProperty(t, o) {
        if (this[t] === o) return this;
        for (let i = 0, n = this.children.length; i < n; i++) {
          let s = this.children[i].getObjectByProperty(t, o);
          if (s !== void 0) return s;
        }
      }
      getObjectsByProperty(t, o) {
        let i = [];
        this[t] === o && i.push(this);
        for (let n = 0, a = this.children.length; n < a; n++) {
          let s = this.children[n].getObjectsByProperty(t, o);
          s.length > 0 && (i = i.concat(s));
        }
        return i;
      }
      traverse(t) {
        t(this);
        let o = this.children;
        for (let i = 0, n = o.length; i < n; i++) o[i].traverse(t);
      }
      traverseVisible(t) {
        if (this.visible === false) return;
        t(this);
        let o = this.children;
        for (let i = 0, n = o.length; i < n; i++) o[i].traverseVisible(t);
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          this.matrixWorldNeedsUpdate = true;
      }
      updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || t) &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix,
            ),
            this.matrixWorldNeedsUpdate = false,
            t = true);
        let o = this.children;
        for (let i = 0, n = o.length; i < n; i++) {
          let a = o[i];
          (a.matrixWorldAutoUpdate === true || t === true) &&
            a.updateMatrixWorld(t);
        }
      }
      updateWorldMatrix(t, o) {
        let i = this.parent;
        if (
          t === true && i !== null && i.matrixWorldAutoUpdate === true &&
          i.updateWorldMatrix(true, false),
            this.matrixAutoUpdate && this.updateMatrix(),
            this.parent === null
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix,
              ),
            o === true
        ) {
          let n = this.children;
          for (let a = 0, s = n.length; a < s; a++) {
            let l = n[a];
            l.matrixWorldAutoUpdate === true &&
              l.updateWorldMatrix(false, true);
          }
        }
      }
    };
  yh.DEFAULT_UP = new ye(0, 1, 0),
    yh.DEFAULT_MATRIX_AUTO_UPDATE = true,
    yh.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
  var Ii = yh;
  var Dy = class extends Ii {
    constructor() {
      super();
      this.isCamera = true;
      this.isCamera = true,
        this.type = "Camera",
        this.matrixWorldInverse = new Nt(),
        this.projectionMatrix = new Nt(),
        this.projectionMatrixInverse = new Nt(),
        this.coordinateSystem = Jl;
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t, o) {
      super.updateWorldMatrix(t, o),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
  };
  var Xp = class extends Dy {
    constructor(e = -1, t = 1, o = 1, i = -1, n = .1, a = 2e3) {
      super(),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = o,
        this.bottom = i,
        this.near = n,
        this.far = a,
        this.updateProjectionMatrix();
    }
    setViewOffset(e, t, o, i, n, a) {
      this.view === null &&
      (this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
        this.view.enabled = true,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = o,
        this.view.offsetY = i,
        this.view.width = n,
        this.view.height = a,
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      let e = (this.right - this.left) / (2 * this.zoom),
        t = (this.top - this.bottom) / (2 * this.zoom),
        o = (this.right + this.left) / 2,
        i = (this.top + this.bottom) / 2,
        n = o - e,
        a = o + e,
        s = i + t,
        l = i - t;
      if (this.view !== null && this.view.enabled) {
        let c = (this.right - this.left) / this.view.fullWidth /
            this.zoom,
          d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        n += c * this.view.offsetX,
          a = n + c * this.view.width,
          s -= d * this.view.offsetY,
          l = s - d * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(
        n,
        a,
        s,
        l,
        this.near,
        this.far,
        this.coordinateSystem,
      ), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  };
  var xh = class extends Dy {
    constructor(e = 50, t = 1, o = .1, i = 2e3) {
      super(),
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = o,
        this.far = i,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix();
    }
    setFocalLength(e) {
      let t = .5 * this.getFilmHeight() / e;
      this.fov = xV * 2 * Math.atan(t), this.updateProjectionMatrix();
    }
    getFocalLength() {
      let e = Math.tan(xk * .5 * this.fov);
      return .5 * this.getFilmHeight() / e;
    }
    getEffectiveFOV() {
      return xV * 2 * Math.atan(Math.tan(xk * .5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(e, t, o, i, n, a) {
      this.aspect = e / t,
        this.view === null &&
        (this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
        this.view.enabled = true,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = o,
        this.view.offsetY = i,
        this.view.width = n,
        this.view.height = a,
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      let e = this.near,
        t = e * Math.tan(xk * .5 * this.fov) / this.zoom,
        o = 2 * t,
        i = this.aspect * o,
        n = -.5 * i,
        a = this.view;
      if (a !== null && a.enabled) {
        let l = a.fullWidth, c = a.fullHeight;
        n += a.offsetX * i / l,
          t -= a.offsetY * o / c,
          i *= a.width / l,
          o *= a.height / c;
      }
      let s = this.filmOffset;
      s !== 0 && (n += e * s / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(
          n,
          n + i,
          t,
          t - o,
          e,
          this.far,
          this.coordinateSystem,
        ),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
  };
  var dm = class {
      constructor(
        e = new ye(1 / 0, 1 / 0, 1 / 0),
        t = new ye(-1 / 0, -1 / 0, -1 / 0),
      ) {
        this.min = e, this.max = t;
      }
      setFromBufferAttribute(e) {
        this.min.x = this.min.y = this.min.z = 1 / 0,
          this.max.x = this.max.y = this.max.z = -1 / 0;
        for (let t = 0, o = e.count; t < o; t++) {
          rO.fromBufferAttribute(e, t), this.min.min(rO), this.max.max(rO);
        }
        return this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y ||
          this.max.z < this.min.z;
      }
      getCenter(e) {
        return this.isEmpty()
          ? e.set(0, 0, 0)
          : e.addVectors(this.min, this.max).multiplyScalar(.5);
      }
      getSize(e) {
        return this.isEmpty()
          ? e.set(0, 0, 0)
          : e.subVectors(this.max, this.min);
      }
    },
    rO = new ye();
  var ky = new ye(),
    oO = new ye(),
    Jp = class {
      constructor(e = new ye(), t = -1) {
        this.center = e, this.radius = t;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this;
      }
      union(e) {
        return e.isEmpty()
          ? this
          : this.isEmpty()
          ? (this.copy(e), this)
          : (this.center.equals(e.center) === true
            ? this.radius = Math.max(this.radius, e.radius)
            : (oO.subVectors(e.center, this.center).setLength(e.radius),
              this.expandByPoint(ky.copy(e.center).add(oO)),
              this.expandByPoint(ky.copy(e.center).sub(oO))),
            this);
      }
      expandByPoint(e) {
        if (this.isEmpty()) {
          return this.center.copy(e), this.radius = 0, this;
        }
        ky.subVectors(e, this.center);
        let t = ky.lengthSq();
        if (t > this.radius * this.radius) {
          let o = Math.sqrt(t), i = (o - this.radius) * .5;
          ky.multiplyScalar(i / o), this.center.add(ky), this.radius += i;
        }
        return this;
      }
      copy(e) {
        return this.center.copy(e.center), this.radius = e.radius, this;
      }
      applyMatrix4(e) {
        return this.center.applyMatrix4(e),
          this.radius = this.radius * e.getMaxScaleOnAxis(),
          this;
      }
    };
  function Nk(r) {
    for (let e = r.length - 1; e >= 0; --e) if (r[e] >= 65535) return true;
    return false;
  }
  function Bk(r) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", r);
  }
  function bae(r) {
    let e = r.getError();
    switch (e) {
      case r.NO_ERROR:
        return "NO_ERROR";
      case r.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
      case r.INVALID_ENUM:
        return "INVALID_ENUM";
      case r.INVALID_VALUE:
        return "INVALID_VALUE";
      case r.INVALID_OPERATION:
        return "INVALID_OPERATION";
      case r.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
      case r.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
      default:
        return typeof e == "number" ? e.toString(16) : e;
    }
  }
  function wt(r, e, t) {
    if (r == null) {
      let o = `Expected ${e} to be defined and not null.`;
      throw t && (o += ` GL Error: ${bae(t)}.`), new Error(o);
    }
  }
  var yae = 0,
    _y = new Nt(),
    MW = new dm(),
    pm = new ye(),
    La = class extends Ns {
      constructor() {
        super();
        this.isBufferGeometry = true;
        Object.defineProperty(this, "id", { value: yae++ }),
          this.uuid = Yl(),
          this.name = "",
          this.type = "BufferGeometry",
          this.index = null,
          this.attributes = {},
          this.groups = [],
          this.boundingSphere = null,
          this.userData = {};
      }
      setIndex(t) {
        return Array.isArray(t)
          ? this.index = new (Nk(t) ? bh : fh)(t, 1)
          : this.index = t,
          this;
      }
      getAttribute(t) {
        return this.attributes[t];
      }
      setAttribute(t, o) {
        return this.attributes[t] = o, this;
      }
      hasAttribute(t) {
        return this.attributes[t] !== void 0;
      }
      addGroup(t, o, i = 0) {
        this.groups.push({ start: t, count: o, materialIndex: i });
      }
      applyMatrix4(t) {
        let o = this.attributes.position;
        o !== void 0 && (o.applyMatrix4(t), o.needsUpdate = true);
        let i = this.attributes.normal;
        if (i !== void 0) {
          let a = new Po().getNormalMatrix(t);
          i.applyNormalMatrix(a), i.needsUpdate = true;
        }
        let n = this.attributes.tangent;
        return n !== void 0 &&
          (n.transformDirection(t), n.needsUpdate = true),
          this.boundingSphere !== null && this.computeBoundingSphere(),
          this;
      }
      rotateX(t) {
        return _y.makeRotationX(t), this.applyMatrix4(_y), this;
      }
      translate(t, o, i) {
        return _y.makeTranslation(t, o, i), this.applyMatrix4(_y), this;
      }
      scale(t, o, i) {
        return _y.makeScale(t, o, i), this.applyMatrix4(_y), this;
      }
      computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Jp());
        let t = this.attributes.position;
        if (t) {
          let o = this.boundingSphere.center;
          MW.setFromBufferAttribute(t), MW.getCenter(o);
          let i = 0;
          for (let n = 0, a = t.count; n < a; n++) {
            pm.fromBufferAttribute(t, n),
              i = Math.max(i, o.distanceToSquared(pm));
          }
          this.boundingSphere.radius = Math.sqrt(i),
            isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
              this,
            );
        }
      }
      computeVertexNormals() {
        let t = this.index, o = this.getAttribute("position");
        if (o !== void 0) {
          let i = this.getAttribute("normal");
          if (i === void 0) {
            i = new ha(new Float32Array(o.count * 3), 3),
              this.setAttribute("normal", i);
          } else {for (let u = 0, f = i.count; u < f; u++) {
              i.setXYZ(u, 0, 0, 0);
            }}
          let n = new ye(),
            a = new ye(),
            s = new ye(),
            l = new ye(),
            c = new ye(),
            d = new ye(),
            p = new ye(),
            h = new ye();
          if (t) {
            for (let u = 0, f = t.count; u < f; u += 3) {
              let y = t.getX(u + 0), C = t.getX(u + 1), E = t.getX(u + 2);
              n.fromBufferAttribute(o, y),
                a.fromBufferAttribute(o, C),
                s.fromBufferAttribute(o, E),
                p.subVectors(s, a),
                h.subVectors(n, a),
                p.cross(h),
                l.fromBufferAttribute(i, y),
                c.fromBufferAttribute(i, C),
                d.fromBufferAttribute(i, E),
                l.add(p),
                c.add(p),
                d.add(p),
                i.setXYZ(y, l.x, l.y, l.z),
                i.setXYZ(C, c.x, c.y, c.z),
                i.setXYZ(E, d.x, d.y, d.z);
            }
          } else {for (let u = 0, f = o.count; u < f; u += 3) {
              n.fromBufferAttribute(o, u + 0),
                a.fromBufferAttribute(o, u + 1),
                s.fromBufferAttribute(o, u + 2),
                p.subVectors(s, a),
                h.subVectors(n, a),
                p.cross(h),
                i.setXYZ(u + 0, p.x, p.y, p.z),
                i.setXYZ(u + 1, p.x, p.y, p.z),
                i.setXYZ(u + 2, p.x, p.y, p.z);
            }}
          this.normalizeNormals(), i.needsUpdate = true;
        }
      }
      normalizeNormals() {
        let t = this.attributes.normal;
        for (let o = 0, i = t.count; o < i; o++) {
          pm.fromBufferAttribute(t, o),
            pm.normalize(),
            t.setXYZ(o, pm.x, pm.y, pm.z);
        }
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    };
  var pn = class r {
    constructor(e = 0, t = 0, o = 0, i = 1) {
      this.x = e, this.y = t, this.z = o, this.w = i;
    }
    set(e, t, o, i) {
      return this.x = e, this.y = t, this.z = o, this.w = i, this;
    }
    clone() {
      return new r(this.x, this.y, this.z, this.w);
    }
    copy(e) {
      return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
    }
    floor() {
      return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z &&
        e.w === this.w;
    }
    fromArray(e, t = 0) {
      return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this;
    }
    toArray(e, t = 0) {
      return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this;
    }
  };
  var Tt = class r {
    constructor(e = 0, t = 0) {
      this.x = e, this.y = t;
    }
    set(e, t) {
      return this.x = e, this.y = t, this;
    }
    clone() {
      return new r(this.x, this.y);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this;
    }
    applyMatrix3(e) {
      let t = this.x, o = this.y, i = e.elements;
      return this.x = i[0] * t + i[3] * o + i[6],
        this.y = i[1] * t + i[4] * o + i[7],
        this;
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    normalize() {
      return this.multiplyScalar(1 / (this.length() || 1));
    }
    distanceTo(e) {
      let t = this.x - e.x, o = this.y - e.y, i = t * t + o * o;
      return Math.sqrt(i);
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    toArray(e, t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this;
    }
  };
  var xae = 0,
    Uk = class {
      constructor(e) {
        this.data = e;
        this.isSource = true;
        this.uuid = Yl();
        this.version = 0;
        Object.defineProperty(this, "id", { value: xae++ });
      }
      set needsUpdate(e) {
        e === true && this.version++;
      }
    };
  var Bd = class {
      constructor(e, t, o) {
        this.width = e;
        this.height = t;
        this.depth = o;
      }
    },
    wae = 0,
    Iy = class Iy extends Ns {
      constructor(
        e,
        t = Iy.DEFAULT_MAPPING,
        o = cm,
        i = cm,
        n = ml,
        a = Xv,
        s = Nd,
        l = Vn,
        c = Iy.DEFAULT_ANISOTROPY,
        d = Ey,
      ) {
        super(),
          this.isTexture = true,
          Object.defineProperty(this, "id", { value: wae++ }),
          this.uuid = Yl(),
          this.name = "",
          this.source = new Uk(e),
          this.mipmaps = [],
          this.mapping = t,
          this.channel = 0,
          this.wrapS = o,
          this.wrapT = i,
          this.magFilter = n,
          this.minFilter = a,
          this.anisotropy = c,
          this.format = s,
          this.internalFormat = null,
          this.type = l,
          this.offset = new Tt(0, 0),
          this.repeat = new Tt(1, 1),
          this.center = new Tt(0, 0),
          this.rotation = 0,
          this.matrixAutoUpdate = true,
          this.matrix = new Po(),
          this.generateMipmaps = true,
          this.premultiplyAlpha = false,
          this.flipY = true,
          this.unpackAlignment = 4,
          this.colorSpace = d,
          this.userData = {},
          this.version = 0,
          this.onUpdate = void 0,
          this.isRenderTargetTexture = false,
          this.needsPMREMUpdate = false;
      }
      get image() {
        return this.source.data;
      }
      set image(e) {
        this.source.data = e;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.name = e.name,
          this.source = e.source,
          this.mipmaps = e.mipmaps.slice(0),
          this.mapping = e.mapping,
          this.channel = e.channel,
          this.wrapS = e.wrapS,
          this.wrapT = e.wrapT,
          this.magFilter = e.magFilter,
          this.minFilter = e.minFilter,
          this.anisotropy = e.anisotropy,
          this.format = e.format,
          this.internalFormat = e.internalFormat,
          this.type = e.type,
          this.offset.copy(e.offset),
          this.repeat.copy(e.repeat),
          this.center.copy(e.center),
          this.rotation = e.rotation,
          this.matrixAutoUpdate = e.matrixAutoUpdate,
          this.matrix.copy(e.matrix),
          this.generateMipmaps = e.generateMipmaps,
          this.premultiplyAlpha = e.premultiplyAlpha,
          this.flipY = e.flipY,
          this.unpackAlignment = e.unpackAlignment,
          this.colorSpace = e.colorSpace,
          this.userData = JSON.parse(JSON.stringify(e.userData)),
          this.needsUpdate = true,
          this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      transformUv(e) {
        if (this.mapping !== TV) return e;
        if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) {
          switch (this.wrapS) {
            case jv:
              e.x = e.x - Math.floor(e.x);
              break;
            case cm:
              e.x = e.x < 0 ? 0 : 1;
              break;
            case Yv:
              Math.abs(Math.floor(e.x) % 2) === 1
                ? e.x = Math.ceil(e.x) - e.x
                : e.x = e.x - Math.floor(e.x);
              break;
          }
        }
        if (e.y < 0 || e.y > 1) {
          switch (this.wrapT) {
            case jv:
              e.y = e.y - Math.floor(e.y);
              break;
            case cm:
              e.y = e.y < 0 ? 0 : 1;
              break;
            case Yv:
              Math.abs(Math.floor(e.y) % 2) === 1
                ? e.y = Math.ceil(e.y) - e.y
                : e.y = e.y - Math.floor(e.y);
              break;
          }
        }
        return this.flipY && (e.y = 1 - e.y), e;
      }
      set needsUpdate(e) {
        e === true && (this.version++, this.source.needsUpdate = true);
      }
    };
  Iy.DEFAULT_ANISOTROPY = 1, Iy.DEFAULT_MAPPING = TV;
  var Bs = Iy;
  var zk = class extends Ns {
    constructor(t = 1, o = 1, i = {}) {
      super();
      this.isRenderTarget = true;
      this.width = t,
        this.height = o,
        this.depth = 1,
        this.scissor = new pn(0, 0, t, o),
        this.scissorTest = false,
        this.viewport = new pn(0, 0, t, o);
      let n = new Bd(t, o, 1);
      this.texture = new Bs(
        n,
        i.mapping,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.colorSpace,
      ),
        this.texture.isRenderTargetTexture = true,
        this.texture.flipY = false,
        this.texture.generateMipmaps = i.generateMipmaps !== void 0
          ? i.generateMipmaps
          : false,
        this.texture.internalFormat = i.internalFormat !== void 0
          ? i.internalFormat
          : null,
        this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : ml,
        this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : true,
        this.stencilBuffer = i.stencilBuffer !== void 0
          ? i.stencilBuffer
          : false,
        this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null,
        this.samples = i.samples !== void 0 ? i.samples : 0;
    }
    setSize(t, o, i = 1) {
      if (this.width !== t || this.height !== o || this.depth !== i) {
        this.width = t, this.height = o, this.depth = i;
        let n = this.texture.image;
        n.width = t, n.height = o, n.depth = i, this.dispose();
      }
      this.viewport.set(0, 0, t, o), this.scissor.set(0, 0, t, o);
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  var wh = class {
    constructor() {
      this.arcLengthDivisions = 200;
      this.needsUpdate = false;
    }
    getPointAt(e, t) {
      let o = this.getUtoTmapping(e);
      return this.getPoint(o, t);
    }
    getPoints(e = 5) {
      let t = [];
      for (let o = 0; o <= e; o++) t.push(this.getPoint(o / e));
      return t;
    }
    getSpacedPoints(e = 5) {
      let t = [];
      for (let o = 0; o <= e; o++) t.push(this.getPointAt(o / e));
      return t;
    }
    getLength() {
      let e = this.getLengths();
      return e[e.length - 1];
    }
    getLengths(e = this.arcLengthDivisions) {
      if (
        this.cacheArcLengths && this.cacheArcLengths.length === e + 1 &&
        !this.needsUpdate
      ) return this.cacheArcLengths;
      this.needsUpdate = false;
      let t = [], o, i = this.getPoint(0), n = 0;
      t.push(0);
      for (let a = 1; a <= e; a++) {
        o = this.getPoint(a / e), n += o.distanceTo(i), t.push(n), i = o;
      }
      return this.cacheArcLengths = t, t;
    }
    updateArcLengths() {
      this.needsUpdate = true, this.getLengths();
    }
    getUtoTmapping(e, t) {
      let o = this.getLengths(), i = 0, n = o.length, a;
      t ? a = t : a = e * o[n - 1];
      let s = 0, l = n - 1, c;
      for (; s <= l;) {
        if (i = Math.floor(s + (l - s) / 2), c = o[i] - a, c < 0) {
          s = i + 1;
        } else if (c > 0) l = i - 1;
        else {
          l = i;
          break;
        }
      }
      if (i = l, o[i] === a) return i / (n - 1);
      let d = o[i], h = o[i + 1] - d, u = (a - d) / h;
      return (i + u) / (n - 1);
    }
    getTangent(e, t) {
      let i = e - 1e-4, n = e + 1e-4;
      i < 0 && (i = 0), n > 1 && (n = 1);
      let a = this.getPoint(i), s = this.getPoint(n), l = t || new Tt();
      return l.copy(s).sub(a).normalize(), l;
    }
    getTangentAt(e, t) {
      let o = this.getUtoTmapping(e);
      return this.getTangent(o, t);
    }
    computeFrenetFrames(e, t) {
      let o = new ye(),
        i = [],
        n = [],
        a = [],
        s = new ye(),
        l = new Nt();
      for (let h = 0; h <= e; h++) {
        let u = h / e, f = this.getTangentAt(u, new Tt());
        i[h] = new ye(f.x, f.y, 0);
      }
      n[0] = new ye(), a[0] = new ye();
      let c = Number.MAX_VALUE,
        d = Math.abs(i[0].x),
        p = Math.abs(i[0].y);
      d <= c && (c = d, o.set(1, 0, 0)),
        p <= c && (c = p, o.set(0, 1, 0)),
        s.crossVectors(i[0], o).normalize(),
        n[0].crossVectors(i[0], s),
        a[0].crossVectors(i[0], n[0]);
      for (let h = 1; h <= e; h++) {
        if (
          n[h] = n[h - 1].clone(),
            a[h] = a[h - 1].clone(),
            s.crossVectors(i[h - 1], i[h]),
            s.length() > Number.EPSILON
        ) {
          s.normalize();
          let u = Math.acos(sm(i[h - 1].dot(i[h]), -1, 1));
          n[h].applyMatrix4(l.makeRotationAxis(s, u));
        }
        a[h].crossVectors(i[h], n[h]);
      }
      if (t === true) {
        let h = Math.acos(sm(n[0].dot(n[e]), -1, 1));
        h /= e, i[0].dot(s.crossVectors(n[0], n[e])) > 0 && (h = -h);
        for (let u = 1; u <= e; u++) {
          n[u].applyMatrix4(l.makeRotationAxis(i[u], h * u)),
            a[u].crossVectors(i[u], n[u]);
        }
      }
      return { tangents: i, normals: n, binormals: a };
    }
  };
  var um = class extends wh {
    constructor(e = new Tt(), t = new Tt()) {
      super(), this.v1 = e, this.v2 = t;
    }
    getPoint(e, t = new Tt()) {
      let o = t;
      return e === 1
        ? o.copy(this.v2)
        : (o.copy(this.v2).sub(this.v1), o.multiplyScalar(e).add(this.v1)),
        o;
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    getTangent(e, t = new Tt()) {
      return t.subVectors(this.v2, this.v1).normalize();
    }
    getTangentAt(e, t) {
      return this.getTangent(e, t);
    }
  };
  var qk = class extends wh {
    constructor() {
      super(...arguments);
      this.curves = [];
      this.autoClose = false;
    }
    add(t) {
      this.curves.push(t);
    }
    closePath() {
      let t = this.curves[0].getPoint(0),
        o = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(o) || this.curves.push(new um(o, t));
    }
    getPoint(t, o) {
      let i = t * this.getLength(), n = this.getCurveLengths(), a = 0;
      for (; a < n.length;) {
        if (n[a] >= i) {
          let s = n[a] - i,
            l = this.curves[a],
            c = l.getLength(),
            d = c === 0 ? 0 : 1 - s / c;
          return l.getPointAt(d, o);
        }
        a++;
      }
    }
    getLength() {
      let t = this.getCurveLengths();
      return t[t.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true,
        this.cacheLengths = void 0,
        this.getCurveLengths();
    }
    getCurveLengths() {
      if (
        this.cacheLengths &&
        this.cacheLengths.length === this.curves.length
      ) return this.cacheLengths;
      let t = [], o = 0;
      for (let i = 0, n = this.curves.length; i < n; i++) {
        o += this.curves[i].getLength(), t.push(o);
      }
      return this.cacheLengths = t, t;
    }
    getSpacedPoints(t = 40) {
      let o = [];
      for (let i = 0; i <= t; i++) o.push(this.getPoint(i / t));
      return this.autoClose && o.push(o[0]), o;
    }
    getPoints(t = 12) {
      let o = [], i;
      for (let n = 0, a = this.curves; n < a.length; n++) {
        let s = a[n], l = s instanceof um ? 1 : t, c = s.getPoints(l);
        for (let d = 0; d < c.length; d++) {
          let p = c[d];
          i && i.equals(p) || (o.push(p), i = p);
        }
      }
      return this.autoClose && o.length > 1 &&
        !o[o.length - 1].equals(o[0]) && o.push(o[0]),
        o;
    }
  };
  function vae(r, e) {
    let t = 1 - r;
    return t * t * e;
  }
  function Cae(r, e) {
    return 2 * (1 - r) * r * e;
  }
  function Sae(r, e) {
    return r * r * e;
  }
  function iO(r, e, t, o) {
    return vae(r, e) + Cae(r, t) + Sae(r, o);
  }
  var Hk = class extends wh {
    constructor(e = new Tt(), t = new Tt(), o = new Tt()) {
      super(), this.v0 = e, this.v1 = t, this.v2 = o;
    }
    getPoint(e, t = new Tt()) {
      let o = t, i = this.v0, n = this.v1, a = this.v2;
      return o.set(iO(e, i.x, n.x, a.x), iO(e, i.y, n.y, a.y)), o;
    }
  };
  var hm = class extends qk {
    constructor(t) {
      super();
      this.currentPoint = new Tt();
      t && this.setFromPoints(t);
    }
    setFromPoints(t) {
      this.moveTo(t[0].x, t[0].y);
      for (let o = 1, i = t.length; o < i; o++) {
        this.lineTo(t[o].x, t[o].y);
      }
      return this;
    }
    moveTo(t, o) {
      return this.currentPoint.set(t, o), this;
    }
    lineTo(t, o) {
      let i = new um(this.currentPoint.clone(), new Tt(t, o));
      return this.curves.push(i), this.currentPoint.set(t, o), this;
    }
    quadraticCurveTo(t, o, i, n) {
      let a = new Hk(
        this.currentPoint.clone(),
        new Tt(t, o),
        new Tt(i, n),
      );
      return this.curves.push(a), this.currentPoint.set(i, n), this;
    }
  };
  var Ay = class extends hm {
    constructor() {
      super(...arguments);
      this.uuid = Yl();
      this.holes = [];
    }
    getPointsHoles(t) {
      let o = [];
      for (let i = 0, n = this.holes.length; i < n; i++) {
        o[i] = this.holes[i].getPoints(t);
      }
      return o;
    }
    extractPoints(t) {
      return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
    }
  };
  var vt = class r {
    constructor(e) {
      this.isColor = true;
      if (e instanceof r) this.copy(e);
      else if (typeof e == "number") this.setHex(e);
      else if (typeof e == "string") {
        let { r: t, g: o, b: i } = __dcg_shared_module_exports__["Nd"](e);
        this.setRGB(t / 255, o / 255, i / 255);
      } else this.r = 1, this.g = 1, this.b = 1;
    }
    setHex(e) {
      return e = Math.floor(e),
        this.setRGB(
          (e >> 16 & 255) / 255,
          (e >> 8 & 255) / 255,
          (e & 255) / 255,
        ),
        this;
    }
    setRGB(e, t, o) {
      return this.r = __dcg_shared_module_exports__["Od"](e),
        this.g = __dcg_shared_module_exports__["Od"](t),
        this.b = __dcg_shared_module_exports__["Od"](o),
        this;
    }
    clone() {
      let e = new r();
      return e.r = this.r, e.g = this.g, e.b = this.b, e;
    }
    copy(e) {
      return this.r = e.r, this.g = e.g, this.b = e.b, this;
    }
    getRGB(e, t) {
      t === Lo
        ? (e.r = __dcg_shared_module_exports__["Pd"](this.r),
          e.g = __dcg_shared_module_exports__["Pd"](this.g),
          e.b = __dcg_shared_module_exports__["Pd"](this.b))
        : (e.r = this.r, e.g = this.g, e.b = this.b);
    }
    multiplyScalar(e) {
      return this.r *= e, this.g *= e, this.b *= e, this;
    }
    equals(e) {
      return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
      return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
    }
    fromBufferAttribute(e, t) {
      return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
    }
  };
  var LW = {
    triangulate: function (r, e, t = 2) {
      let o = e && e.length,
        i = o ? e[0] * t : r.length,
        n = Eae(r, 0, i, t, true),
        a = [];
      if (!n || n.next === n.prev) return a;
      let s, l, c, d, p, h, u;
      if (o) throw new Error("EarCut does not support holes");
      if (r.length > 80 * t) {
        s = c = r[0], l = d = r[1];
        for (let f = t; f < i; f += t) {
          p = r[f],
            h = r[f + 1],
            p < s && (s = p),
            h < l && (l = h),
            p > c && (c = p),
            h > d && (d = h);
        }
        u = Math.max(c - s, d - l), u = u !== 0 ? 32767 / u : 0;
      }
      return Tae(n, a, t, s, l, u, 0), a;
    },
  };
  function Eae(r, e, t, o, i) {
    let n, a;
    if (i === Mae(r, e, t, o) > 0) {
      for (n = e; n < t; n += o) a = GW(n, r[n], r[n + 1], a);
    } else for (n = t - o; n >= e; n -= o) a = GW(n, r[n], r[n + 1], a);
    return a && Aae(a, a.next) && (PW(a), a = a.next), a;
  }
  function Tae(r, e, t, o, i, n, a) {
    if (!r) return;
    !a && n && _ae(r, o, i, n);
    let s = r, l, c;
    for (; r.prev !== r.next;) {
      if (l = r.prev, c = r.next, n ? kae(r, o, i, n) : Dae(r)) {
        e.push(l.i / t | 0),
          e.push(r.i / t | 0),
          e.push(c.i / t | 0),
          PW(r),
          r = c.next,
          s = c.next;
        continue;
      }
      if (r = c, r === s) {
        throw new Error("EarCut does not expect ear === stop");
      }
    }
  }
  function Dae(r) {
    let e = r.prev, t = r, o = r.next;
    if (gm(e, t, o) >= 0) return false;
    let i = e.x,
      n = t.x,
      a = o.x,
      s = e.y,
      l = t.y,
      c = o.y,
      d = i < n ? i < a ? i : a : n < a ? n : a,
      p = s < l ? s < c ? s : c : l < c ? l : c,
      h = i > n ? i > a ? i : a : n > a ? n : a,
      u = s > l ? s > c ? s : c : l > c ? l : c,
      f = o.next;
    for (; f !== e;) {
      if (
        f.x >= d && f.x <= h && f.y >= p && f.y <= u &&
        Zv(i, s, n, l, a, c, f.x, f.y) && gm(f.prev, f, f.next) >= 0
      ) return false;
      f = f.next;
    }
    return true;
  }
  function kae(r, e, t, o) {
    let i = r.prev, n = r, a = r.next;
    if (gm(i, n, a) >= 0) return false;
    let s = i.x,
      l = n.x,
      c = a.x,
      d = i.y,
      p = n.y,
      h = a.y,
      u = s < l ? s < c ? s : c : l < c ? l : c,
      f = d < p ? d < h ? d : h : p < h ? p : h,
      y = s > l ? s > c ? s : c : l > c ? l : c,
      C = d > p ? d > h ? d : h : p > h ? p : h,
      E = nO(u, f, e, t, o),
      v = nO(y, C, e, t, o),
      w = r.prevZ,
      S = r.nextZ;
    for (; w && w.z >= E && S && S.z <= v;) {
      if (
        w.x >= u && w.x <= y && w.y >= f && w.y <= C && w !== i &&
          w !== a && Zv(s, d, l, p, c, h, w.x, w.y) &&
          gm(w.prev, w, w.next) >= 0 ||
        (w = w.prevZ,
          S.x >= u && S.x <= y && S.y >= f && S.y <= C && S !== i &&
          S !== a && Zv(s, d, l, p, c, h, S.x, S.y) &&
          gm(S.prev, S, S.next) >= 0)
      ) return false;
      S = S.nextZ;
    }
    for (; w && w.z >= E;) {
      if (
        w.x >= u && w.x <= y && w.y >= f && w.y <= C && w !== i &&
        w !== a && Zv(s, d, l, p, c, h, w.x, w.y) &&
        gm(w.prev, w, w.next) >= 0
      ) return false;
      w = w.prevZ;
    }
    for (; S && S.z <= v;) {
      if (
        S.x >= u && S.x <= y && S.y >= f && S.y <= C && S !== i &&
        S !== a && Zv(s, d, l, p, c, h, S.x, S.y) &&
        gm(S.prev, S, S.next) >= 0
      ) return false;
      S = S.nextZ;
    }
    return true;
  }
  function _ae(r, e, t, o) {
    let i = r;
    do i.z === 0 && (i.z = nO(i.x, i.y, e, t, o)),
      i.prevZ = i.prev,
      i.nextZ = i.next,
      i = i.next; while (i !== r);
    i.prevZ.nextZ = void 0, i.prevZ = void 0, Iae(i);
  }
  function Iae(r) {
    let e, t, o, i, n, a, s, l, c = 1;
    do {
      for (t = r, r = void 0, n = void 0, a = 0; t;) {
        for (
          a++, o = t, s = 0, e = 0;
          e < c && (s++, o = o.nextZ, !!o);
          e++
        );
        for (l = c; s > 0 || l > 0 && o;) {
          s !== 0 && (l === 0 || !o || t.z <= o.z)
            ? (i = t, t = t.nextZ, s--)
            : (i = o, o = o.nextZ, l--),
            n ? n.nextZ = i : r = i,
            i.prevZ = n,
            n = i;
        }
        t = o;
      }
      n.nextZ = void 0, c *= 2;
    } while (a > 1);
    return r;
  }
  function nO(r, e, t, o, i) {
    return r = (r - t) * i | 0,
      e = (e - o) * i | 0,
      r = (r | r << 8) & 16711935,
      r = (r | r << 4) & 252645135,
      r = (r | r << 2) & 858993459,
      r = (r | r << 1) & 1431655765,
      e = (e | e << 8) & 16711935,
      e = (e | e << 4) & 252645135,
      e = (e | e << 2) & 858993459,
      e = (e | e << 1) & 1431655765,
      r | e << 1;
  }
  function Zv(r, e, t, o, i, n, a, s) {
    return (i - a) * (e - s) >= (r - a) * (n - s) &&
      (r - a) * (o - s) >= (t - a) * (e - s) &&
      (t - a) * (n - s) >= (i - a) * (o - s);
  }
  function gm(r, e, t) {
    return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
  }
  function Aae(r, e) {
    return r.x === e.x && r.y === e.y;
  }
  function GW(r, e, t, o) {
    let i = new aO(r, e, t);
    return o
      ? (i.next = o.next, i.prev = o, o.next.prev = i, o.next = i)
      : (i.prev = i, i.next = i),
      i;
  }
  function PW(r) {
    r.next.prev = r.prev,
      r.prev.next = r.next,
      r.prevZ && (r.prevZ.nextZ = r.nextZ),
      r.nextZ && (r.nextZ.prevZ = r.prevZ);
  }
  var aO = class {
    constructor(e, t, o) {
      this.i = e,
        this.x = t,
        this.y = o,
        this.z = 0,
        this.prevZ = void 0,
        this.nextZ = void 0,
        this.steiner = false;
    }
  };
  function Mae(r, e, t, o) {
    let i = 0;
    for (let n = e, a = t - o; n < t; n += o) {
      i += (r[a] - r[n]) * (r[n + 1] + r[a + 1]), a = n;
    }
    return i;
  }
  var vh = class r {
    static area(e) {
      let t = e.length, o = 0;
      for (let i = t - 1, n = 0; n < t; i = n++) {
        o += e[i].x * e[n].y - e[n].x * e[i].y;
      }
      return o * .5;
    }
    static isClockWise(e) {
      return r.area(e) < 0;
    }
    static triangulateShape(e, t) {
      let o = [], i = [], n = [];
      VW(e), OW(o, e);
      let a = e.length;
      t.forEach(VW);
      for (let l = 0; l < t.length; l++) {
        i.push(a), a += t[l].length, OW(o, t[l]);
      }
      let s = LW.triangulate(o, i);
      for (let l = 0; l < s.length; l += 3) n.push(s.slice(l, l + 3));
      return n;
    }
  };
  function VW(r) {
    let e = r.length;
    e > 2 && r[e - 1].equals(r[0]) && r.pop();
  }
  function OW(r, e) {
    for (let t = 0; t < e.length; t++) r.push(e[t].x), r.push(e[t].y);
  }
  var Kk = class {
    constructor() {
      this.color = new vt();
      this.subPaths = [];
      this.currentPath = new hm();
    }
    moveTo(e, t) {
      return this.currentPath = new hm(),
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this;
    }
    lineTo(e, t) {
      return this.currentPath.lineTo(e, t), this;
    }
    quadraticCurveTo(e, t, o, i) {
      return this.currentPath.quadraticCurveTo(e, t, o, i), this;
    }
    toShapes(e = false) {
      function t(E) {
        let v = [];
        for (let w = 0, S = E.length; w < S; w++) {
          let k = E[w], _ = new Ay();
          _.curves = k.curves, v.push(_);
        }
        return v;
      }
      function o(E, v) {
        let w = v.length, S = false;
        for (let k = w - 1, _ = 0; _ < w; k = _++) {
          let A = v[k], P = v[_], O = P.x - A.x, U = P.y - A.y;
          if (Math.abs(U) > Number.EPSILON) {
            if (
              U < 0 && (A = v[_], O = -O, P = v[k], U = -U),
                E.y < A.y || E.y > P.y
            ) continue;
            if (E.y === A.y) { if (E.x === A.x) return true; }
            else {
              let z = U * (E.x - A.x) - O * (E.y - A.y);
              if (z === 0) return true;
              if (z < 0) continue;
              S = !S;
            }
          } else {
            if (E.y !== A.y) continue;
            if (P.x <= E.x && E.x <= A.x || A.x <= E.x && E.x <= P.x) {
              return true;
            }
          }
        }
        return S;
      }
      let i = vh.isClockWise, n = this.subPaths;
      if (n.length === 0) return [];
      let a, s, l, c = [];
      if (n.length === 1) {
        return s = n[0], l = new Ay(), l.curves = s.curves, c.push(l), c;
      }
      let d = !i(n[0].getPoints());
      d = e ? !d : d;
      let p = [], h = [], u = [], f = 0, y;
      u[f] = [];
      for (let E = 0, v = n.length; E < v; E++) {
        if (s = n[E], y = s.getPoints(), a = i(y), a = e ? !a : a, a) {
          !d && h[f] && f++;
          let w = { s: new Ay(), p: y };
          w.s.curves = s.curves, h[f] = w, d && f++, u[f] = [];
        } else u[f].push({ h: s, p: y[0] });
      }
      if (!h[0]) return t(n);
      if (h.length > 1) {
        let E = false, v = 0;
        for (let w = 0, S = h.length; w < S; w++) p[w] = [];
        for (let w = 0, S = h.length; w < S; w++) {
          let k = u[w];
          for (let _ = 0; _ < k.length; _++) {
            let A = k[_], P = true;
            for (let O = 0; O < h.length; O++) {
              o(A.p, h[O].p) &&
                (w !== O && v++, P ? (P = false, p[O].push(A)) : E = true);
            }
            P && p[w].push(A);
          }
        }
        v > 0 && E === false && (u = p);
      }
      let C;
      for (let E = 0, v = h.length; E < v; E++) {
        l = h[E].s, c.push(l), C = u[E];
        for (let w = 0, S = C.length; w < S; w++) l.holes.push(C[w].h);
      }
      return c;
    }
  };
  var Ud = class extends La {
    constructor(
      e = 1,
      t = 1,
      o = 1,
      i = 32,
      n = 1,
      a = false,
      s = 0,
      l = Math.PI * 2,
    ) {
      super(), this.type = "CylinderGeometry";
      let c = this;
      i = Math.floor(i), n = Math.floor(n);
      let d = [], p = [], h = [], u = [], f = 0, y = [], C = o / 2, E = 0;
      v(),
        a === false && (e > 0 && w(true), t > 0 && w(false)),
        this.setIndex(d),
        this.setAttribute("position", new Bo(p, 3)),
        this.setAttribute("normal", new Bo(h, 3)),
        this.setAttribute("uv", new Bo(u, 2));
      function v() {
        let S = new ye(), k = new ye(), _ = 0, A = (t - e) / o;
        for (let P = 0; P <= n; P++) {
          let O = [], U = P / n, z = U * (t - e) + e;
          for (let x = 0; x <= i; x++) {
            let L = x / i,
              V = L * l + s,
              R = Math.sin(V),
              N = Math.cos(V);
            k.x = z * R,
              k.y = -U * o + C,
              k.z = z * N,
              p.push(k.x, k.y, k.z),
              S.set(R, A, N).normalize(),
              h.push(S.x, S.y, S.z),
              u.push(L, 1 - U),
              O.push(f++);
          }
          y.push(O);
        }
        for (let P = 0; P < i; P++) {
          for (let O = 0; O < n; O++) {
            let U = y[O][P],
              z = y[O + 1][P],
              x = y[O + 1][P + 1],
              L = y[O][P + 1];
            d.push(U, z, L), d.push(z, x, L), _ += 6;
          }
        }
        c.addGroup(E, _, 0), E += _;
      }
      function w(S) {
        let k = f,
          _ = new Tt(),
          A = new ye(),
          P = 0,
          O = S === true ? e : t,
          U = S === true ? 1 : -1;
        for (let x = 1; x <= i; x++) {
          p.push(0, C * U, 0), h.push(0, U, 0), u.push(.5, .5), f++;
        }
        let z = f;
        for (let x = 0; x <= i; x++) {
          let V = x / i * l + s, R = Math.cos(V), N = Math.sin(V);
          A.x = O * N,
            A.y = C * U,
            A.z = O * R,
            p.push(A.x, A.y, A.z),
            h.push(0, U, 0),
            _.x = R * .5 + .5,
            _.y = N * .5 * U + .5,
            u.push(_.x, _.y),
            f++;
        }
        for (let x = 0; x < i; x++) {
          let L = k + x, V = z + x;
          S === true ? d.push(V, V + 1, L) : d.push(V + 1, V, L), P += 3;
        }
        c.addGroup(E, P, S === true ? 1 : 2), E += P;
      }
    }
  };
  var Wk = class extends Ud {
    constructor(
      e = 1,
      t = 1,
      o = 32,
      i = 1,
      n = false,
      a = 0,
      s = Math.PI * 2,
    ) {
      super(0, e, t, o, i, n, a, s), this.type = "ConeGeometry";
    }
  };
  var $k = class extends La {
      constructor(e, t = {}) {
        super(), this.type = "ExtrudeGeometry";
        let o = this, i = [], n = [];
        for (let s = 0, l = e.length; s < l; s++) {
          let c = e[s];
          a(c);
        }
        this.setAttribute("position", new Bo(i, 3)),
          this.setAttribute("uv", new Bo(n, 2)),
          this.computeVertexNormals();
        function a(s) {
          let l = [],
            c = t.curveSegments !== void 0 ? t.curveSegments : 12,
            d = t.steps !== void 0 ? t.steps : 1,
            p = t.depth !== void 0 ? t.depth : 1,
            h = t.bevelEnabled !== void 0 ? t.bevelEnabled : true,
            u = t.bevelThickness !== void 0 ? t.bevelThickness : .2,
            f = t.bevelSize !== void 0 ? t.bevelSize : u - .1,
            y = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
            C = t.bevelSegments !== void 0 ? t.bevelSegments : 3,
            E = t.UVGenerator !== void 0 ? t.UVGenerator : Gae;
          h || (C = 0, u = 0, f = 0, y = 0);
          let v = s.extractPoints(c), w = v.shape, S = v.holes;
          if (!vh.isClockWise(w)) {
            w = w.reverse();
            for (let q = 0, oe = S.length; q < oe; q++) {
              let K = S[q];
              vh.isClockWise(K) && (S[q] = K.reverse());
            }
          }
          let _ = vh.triangulateShape(w, S), A = w;
          for (let q = 0, oe = S.length; q < oe; q++) {
            let K = S[q];
            w = w.concat(K);
          }
          function P(q, oe, K) {
            return oe ||
              console.error("THREE.ExtrudeGeometry: vec does not exist"),
              q.clone().addScaledVector(oe, K);
          }
          let O = w.length, U = _.length;
          function z(q, oe, K) {
            let fe,
              me,
              we,
              Ce = q.x - oe.x,
              _e = q.y - oe.y,
              We = K.x - q.x,
              $ = K.y - q.y,
              W = Ce * Ce + _e * _e,
              ue = Ce * $ - _e * We;
            if (Math.abs(ue) > Number.EPSILON) {
              let Ee = Math.sqrt(W),
                Be = Math.sqrt(We * We + $ * $),
                ce = oe.x - _e / Ee,
                ot = oe.y + Ce / Ee,
                it = K.x - $ / Be,
                Se = K.y + We / Be,
                Lt = ((it - ce) * $ - (Se - ot) * We) /
                  (Ce * $ - _e * We);
              fe = ce + Ce * Lt - q.x, me = ot + _e * Lt - q.y;
              let It = fe * fe + me * me;
              if (It <= 2) return new Tt(fe, me);
              we = Math.sqrt(It / 2);
            } else {
              let Ee = false;
              Ce > Number.EPSILON
                ? We > Number.EPSILON && (Ee = true)
                : Ce < -Number.EPSILON
                ? We < -Number.EPSILON && (Ee = true)
                : Math.sign(_e) === Math.sign($) && (Ee = true),
                Ee
                  ? (fe = -_e, me = Ce, we = Math.sqrt(W))
                  : (fe = Ce, me = _e, we = Math.sqrt(W / 2));
            }
            return new Tt(fe / we, me / we);
          }
          let x = [];
          for (
            let q = 0, oe = A.length, K = oe - 1, fe = q + 1;
            q < oe;
            q++, K++, fe++
          ) {
            K === oe && (K = 0),
              fe === oe && (fe = 0),
              x[q] = z(A[q], A[K], A[fe]);
          }
          let L = [], V, R = x.concat();
          for (let q = 0, oe = S.length; q < oe; q++) {
            let K = S[q];
            V = [];
            for (
              let fe = 0, me = K.length, we = me - 1, Ce = fe + 1;
              fe < me;
              fe++, we++, Ce++
            ) {
              we === me && (we = 0),
                Ce === me && (Ce = 0),
                V[fe] = z(K[fe], K[we], K[Ce]);
            }
            L.push(V), R = R.concat(V);
          }
          for (let q = 0; q < C; q++) {
            let oe = q / C,
              K = u * Math.cos(oe * Math.PI / 2),
              fe = f * Math.sin(oe * Math.PI / 2) + y;
            for (let me = 0, we = A.length; me < we; me++) {
              let Ce = P(A[me], x[me], fe);
              te(Ce.x, Ce.y, -K);
            }
            for (let me = 0, we = S.length; me < we; me++) {
              let Ce = S[me];
              V = L[me];
              for (let _e = 0, We = Ce.length; _e < We; _e++) {
                let $ = P(Ce[_e], V[_e], fe);
                te($.x, $.y, -K);
              }
            }
          }
          let N = f + y;
          for (let q = 0; q < O; q++) {
            let oe = h ? P(w[q], R[q], N) : w[q];
            te(oe.x, oe.y, 0);
          }
          for (let q = 1; q <= d; q++) {
            for (let oe = 0; oe < O; oe++) {
              let K = h ? P(w[oe], R[oe], N) : w[oe];
              te(K.x, K.y, p / d * q);
            }
          }
          for (let q = C - 1; q >= 0; q--) {
            let oe = q / C,
              K = u * Math.cos(oe * Math.PI / 2),
              fe = f * Math.sin(oe * Math.PI / 2) + y;
            for (let me = 0, we = A.length; me < we; me++) {
              let Ce = P(A[me], x[me], fe);
              te(Ce.x, Ce.y, p + K);
            }
            for (let me = 0, we = S.length; me < we; me++) {
              let Ce = S[me];
              V = L[me];
              for (let _e = 0, We = Ce.length; _e < We; _e++) {
                let $ = P(Ce[_e], V[_e], fe);
                te($.x, $.y, p + K);
              }
            }
          }
          M(), F();
          function M() {
            let q = i.length / 3;
            if (h) {
              let oe = 0, K = O * oe;
              for (let fe = 0; fe < U; fe++) {
                let me = _[fe];
                Y(me[2] + K, me[1] + K, me[0] + K);
              }
              oe = d + C * 2, K = O * oe;
              for (let fe = 0; fe < U; fe++) {
                let me = _[fe];
                Y(me[0] + K, me[1] + K, me[2] + K);
              }
            } else {
              for (let oe = 0; oe < U; oe++) {
                let K = _[oe];
                Y(K[2], K[1], K[0]);
              }
              for (let oe = 0; oe < U; oe++) {
                let K = _[oe];
                Y(K[0] + O * d, K[1] + O * d, K[2] + O * d);
              }
            }
            o.addGroup(q, i.length / 3 - q, 0);
          }
          function F() {
            let q = i.length / 3, oe = 0;
            Z(A, oe), oe += A.length;
            for (let K = 0, fe = S.length; K < fe; K++) {
              let me = S[K];
              Z(me, oe), oe += me.length;
            }
            o.addGroup(q, i.length / 3 - q, 1);
          }
          function Z(q, oe) {
            let K = q.length;
            for (; --K >= 0;) {
              let fe = K, me = K - 1;
              me < 0 && (me = q.length - 1);
              for (let we = 0, Ce = d + C * 2; we < Ce; we++) {
                let _e = O * we,
                  We = O * (we + 1),
                  $ = oe + fe + _e,
                  W = oe + me + _e,
                  ue = oe + me + We,
                  Ee = oe + fe + We;
                he($, W, ue, Ee);
              }
            }
          }
          function te(q, oe, K) {
            l.push(q), l.push(oe), l.push(K);
          }
          function Y(q, oe, K) {
            se(q), se(oe), se(K);
            let fe = i.length / 3,
              me = E.generateTopUV(o, i, fe - 3, fe - 2, fe - 1);
            ae(me[0]), ae(me[1]), ae(me[2]);
          }
          function he(q, oe, K, fe) {
            se(q), se(oe), se(fe), se(oe), se(K), se(fe);
            let me = i.length / 3,
              we = E.generateSideWallUV(
                o,
                i,
                me - 6,
                me - 3,
                me - 2,
                me - 1,
              );
            ae(we[0]), ae(we[1]), ae(we[3]), ae(we[1]), ae(we[2]), ae(we[3]);
          }
          function se(q) {
            i.push(l[q * 3 + 0]), i.push(l[q * 3 + 1]), i.push(l[q * 3 + 2]);
          }
          function ae(q) {
            n.push(q.x), n.push(q.y);
          }
        }
      }
    },
    Gae = {
      generateTopUV: function (r, e, t, o, i) {
        let n = e[t * 3],
          a = e[t * 3 + 1],
          s = e[o * 3],
          l = e[o * 3 + 1],
          c = e[i * 3],
          d = e[i * 3 + 1];
        return [new Tt(n, a), new Tt(s, l), new Tt(c, d)];
      },
      generateSideWallUV: function (r, e, t, o, i, n) {
        let a = e[t * 3],
          s = e[t * 3 + 1],
          l = e[t * 3 + 2],
          c = e[o * 3],
          d = e[o * 3 + 1],
          p = e[o * 3 + 2],
          h = e[i * 3],
          u = e[i * 3 + 1],
          f = e[i * 3 + 2],
          y = e[n * 3],
          C = e[n * 3 + 1],
          E = e[n * 3 + 2];
        return Math.abs(s - d) < Math.abs(a - c)
          ? [
            new Tt(a, 1 - l),
            new Tt(c, 1 - p),
            new Tt(h, 1 - f),
            new Tt(y, 1 - E),
          ]
          : [
            new Tt(s, 1 - l),
            new Tt(d, 1 - p),
            new Tt(u, 1 - f),
            new Tt(C, 1 - E),
          ];
      },
    };
  var e0 = class extends La {
    constructor(e = 1, t = 1, o = 1, i = 1) {
      super(), this.type = "PlaneGeometry";
      let n = e / 2,
        a = t / 2,
        s = Math.floor(o),
        l = Math.floor(i),
        c = s + 1,
        d = l + 1,
        p = e / s,
        h = t / l,
        u = [],
        f = [],
        y = [],
        C = [];
      for (let E = 0; E < d; E++) {
        let v = E * h - a;
        for (let w = 0; w < c; w++) {
          let S = w * p - n;
          f.push(S, -v, 0), y.push(0, 0, 1), C.push(w / s), C.push(1 - E / l);
        }
      }
      for (let E = 0; E < l; E++) {
        for (let v = 0; v < s; v++) {
          let w = v + c * E,
            S = v + c * (E + 1),
            k = v + 1 + c * (E + 1),
            _ = v + 1 + c * E;
          u.push(w, S, _), u.push(S, k, _);
        }
      }
      this.setIndex(u),
        this.setAttribute("position", new Bo(f, 3)),
        this.setAttribute("normal", new Bo(y, 3)),
        this.setAttribute("uv", new Bo(C, 2));
    }
  };
  var My = class extends Ii {
    constructor(t, o = 1) {
      super();
      this.isLight = true;
      this.type = "Light", this.color = new vt(t), this.intensity = o;
    }
    dispose() {}
  };
  var Gy = class extends My {
    constructor(t, o) {
      super(t, o);
      this.isAmbientLight = true;
      this.type = "AmbientLight";
    }
  };
  var Ch = class extends My {
    constructor(t, o) {
      super(t, o);
      this.isDirectionalLight = true;
      this.type = "DirectionalLight",
        this.position.copy(Ii.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new Ii();
    }
    dispose() {}
  };
  function Sh(r) {
    let e = {};
    for (let t in r) {
      e[t] = {};
      for (let o in r[t]) {
        let i = r[t][o];
        i &&
          (i instanceof vt || i instanceof Po || i instanceof Nt ||
            i instanceof Tt || i instanceof ye || i instanceof pn ||
            i instanceof Bs || i instanceof Ql)
          ? i.isRenderTargetTexture
            ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().",
            ),
              e[t][o] = null)
            : e[t][o] = i.clone()
          : Array.isArray(i)
          ? e[t][o] = i.slice()
          : e[t][o] = i;
      }
    }
    return e;
  }
  function RW(r) {
    let e = [];
    for (let t = 0; t < r.length; t++) e.push(r[t].clone());
    return e;
  }
  function FW(r) {
    return r.getRenderTarget() === null ? r.outputColorSpace : Ga;
  }
  var Lae = 0,
    Zl = class extends Ns {
      constructor(e) {
        super(),
          Object.defineProperty(this, "id", { value: Lae++ }),
          this.uuid = Yl(),
          this.name = "",
          this.type = "Material",
          this.blending = hh,
          this.side = Wv,
          this.vertexColors = false,
          this.useVertexPickingColors = false,
          this.opacity = 1,
          this.transparent = false,
          this.blendSrc = Ek,
          this.blendDst = Tk,
          this.blendEquation = Od,
          this.blendSrcAlpha = null,
          this.blendDstAlpha = null,
          this.blendEquationAlpha = null,
          this.depthFunc = $v,
          this.depthTest = true,
          this.depthWrite = true,
          this.stencilWriteMask = 255,
          this.stencilFunc = yW,
          this.stencilRef = 0,
          this.stencilFuncMask = 255,
          this.stencilFail = Ok,
          this.stencilZFail = Ok,
          this.stencilZPass = Ok,
          this.stencilWrite = false,
          this.colorWrite = true,
          this.precision = null,
          this.polygonOffset = false,
          this.polygonOffsetFactor = 0,
          this.polygonOffsetUnits = 0,
          this.alphaToCoverage = false,
          this.premultipliedAlpha = false,
          this.forceSinglePass = false,
          this.visible = true,
          this.userData = {},
          this.version = 0,
          this._alphaTest = 0,
          this.defines = {},
          this.uniforms = {},
          this.uniformsGroups = [],
          this.vertexShader = "",
          this.fragmentShader = "",
          this.wireframe = false,
          this.lights = false,
          this.forceSinglePass = true,
          this.exprTooComplex = false,
          this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false,
          },
          this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0],
          },
          this.index0AttributeName = void 0,
          this.uniformsNeedUpdate = false,
          this.glslVersion = null,
          e !== void 0 && this.setValues(e);
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
      }
      onBuild() {}
      customProgramCacheKey() {
        return "no-custom-cache-key";
      }
      setValues(e) {
        if (e !== void 0) {
          for (let t in e) {
            let o = t, i = e[o];
            if (i === void 0) {
              console.warn(
                `THREE.Material: parameter '${o}' has value of undefined.`,
              );
              continue;
            }
            let n = this[o];
            if (n === void 0) {
              console.warn(
                `THREE.Material: '${o}' is not a property of THREE.${this.type}.`,
              );
              continue;
            }
            n && n.isColor
              ? n.set(i)
              : n && n instanceof ye && i && i instanceof ye
              ? n.copy(i)
              : this[o] = i;
          }
        }
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.name = e.name,
          this.blending = e.blending,
          this.side = e.side,
          this.vertexColors = e.vertexColors,
          this.useVertexPickingColors = e.useVertexPickingColors,
          this.opacity = e.opacity,
          this.transparent = e.transparent,
          this.blendSrc = e.blendSrc,
          this.blendDst = e.blendDst,
          this.blendEquation = e.blendEquation,
          this.blendSrcAlpha = e.blendSrcAlpha,
          this.blendDstAlpha = e.blendDstAlpha,
          this.blendEquationAlpha = e.blendEquationAlpha,
          this.depthFunc = e.depthFunc,
          this.depthTest = e.depthTest,
          this.depthWrite = e.depthWrite,
          this.stencilWriteMask = e.stencilWriteMask,
          this.stencilFunc = e.stencilFunc,
          this.stencilRef = e.stencilRef,
          this.stencilFuncMask = e.stencilFuncMask,
          this.stencilFail = e.stencilFail,
          this.stencilZFail = e.stencilZFail,
          this.stencilZPass = e.stencilZPass,
          this.stencilWrite = e.stencilWrite,
          this.colorWrite = e.colorWrite,
          this.precision = e.precision,
          this.polygonOffset = e.polygonOffset,
          this.polygonOffsetFactor = e.polygonOffsetFactor,
          this.polygonOffsetUnits = e.polygonOffsetUnits,
          this.alphaTest = e.alphaTest,
          this.alphaToCoverage = e.alphaToCoverage,
          this.premultipliedAlpha = e.premultipliedAlpha,
          this.forceSinglePass = e.forceSinglePass,
          this.visible = e.visible,
          this.userData = JSON.parse(JSON.stringify(e.userData)),
          this.fragmentShader = e.fragmentShader,
          this.vertexShader = e.vertexShader,
          this.uniforms = Sh(e.uniforms),
          this.uniformsGroups = RW(e.uniformsGroups),
          this.defines = Object.assign({}, e.defines),
          this.wireframe = e.wireframe,
          this.lights = e.lights,
          this.extensions = Object.assign({}, e.extensions),
          this.glslVersion = e.glslVersion,
          this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      set needsUpdate(e) {
        e === true && this.version++;
      }
    };
  var Eh = class extends ha {
    constructor(e, t, o = false, i = 1) {
      super(e, t, o), this.meshPerAttribute = i;
    }
  };
  var Ai = class extends Ii {
    constructor(e, t) {
      super(),
        this.isMesh = true,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t;
    }
  };
  var NW = new Nt(),
    BW = new Jp(),
    Mi = class extends Ai {
      constructor(e, t, o) {
        super(e, t),
          this.instanceMatrix = new Eh(new Float32Array(o * 16), 16),
          this.instanceColor = new Eh(new Float32Array(o * 3), 3),
          this.instancePickingColor = new Eh(new Float32Array(o * 4), 4),
          this.count = o;
      }
      getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3);
      }
      getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16);
      }
      getPickingColorAt(e, t) {
        let o = this.instancePickingColor.array;
        e = e * 4,
          t[0] = o[e + 0],
          t[1] = o[e + 1],
          t[2] = o[e + 2],
          t[3] = o[e + 3];
      }
      setColorAt(e, t) {
        t.toArray(this.instanceColor.array, e * 3);
      }
      setPickingColorAt(e, t) {
        let o = this.instancePickingColor.array, i = e * 4;
        o[i + 0] = t[0], o[i + 1] = t[1], o[i + 2] = t[2], o[i + 3] = t[3];
      }
      setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16);
      }
      computeBoundingSphere() {
        var o, i;
        let e = this.geometry, t = this.count;
        this.boundingSphere || (this.boundingSphere = new Jp()),
          e.boundingSphere || e.computeBoundingSphere(),
          (o = this.boundingSphere) == null || o.makeEmpty();
        for (let n = 0; n < t; n++) {
          this.getMatrixAt(n, NW),
            BW.copy(e.boundingSphere).applyMatrix4(NW),
            (i = this.boundingSphere) == null || i.union(BW);
        }
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    };
  var Qp = class {
    constructor(e = new ye(1, 0, 0), t = 0) {
      this.isPlane = true;
      this.normal = e, this.constant = t;
    }
    setComponents(e, t, o, i) {
      return this.normal.set(e, t, o), this.constant = i, this;
    }
    normalize() {
      let e = 1 / this.normal.length();
      return this.normal.multiplyScalar(e), this.constant *= e, this;
    }
    distanceToPoint(e) {
      return this.normal.dot(e) + this.constant;
    }
  };
  var t0 = new Jp(),
    jk = class {
      constructor(
        e = new Qp(),
        t = new Qp(),
        o = new Qp(),
        i = new Qp(),
        n = new Qp(),
        a = new Qp(),
      ) {
        this.planes = [e, t, o, i, n, a];
      }
      setFromProjectionMatrix(e, t = Jl) {
        let o = this.planes,
          i = e.elements,
          n = i[0],
          a = i[1],
          s = i[2],
          l = i[3],
          c = i[4],
          d = i[5],
          p = i[6],
          h = i[7],
          u = i[8],
          f = i[9],
          y = i[10],
          C = i[11],
          E = i[12],
          v = i[13],
          w = i[14],
          S = i[15];
        if (
          o[0].setComponents(l - n, h - c, C - u, S - E).normalize(),
            o[1].setComponents(l + n, h + c, C + u, S + E).normalize(),
            o[2].setComponents(l + a, h + d, C + f, S + v).normalize(),
            o[3].setComponents(l - a, h - d, C - f, S - v).normalize(),
            o[4].setComponents(l - s, h - p, C - y, S - w).normalize(),
            t === Jl
        ) o[5].setComponents(l + s, h + p, C + y, S + w).normalize();
        else if (t === Jv) o[5].setComponents(s, p, y, w).normalize();
        else {throw new Error(
            "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
              t,
          );}
        return this;
      }
      intersectsObject(e) {
        let t = e.geometry;
        return t
          ? (e instanceof Mi
            ? (e.computeBoundingSphere(),
              t0.copy(e.boundingSphere).applyMatrix4(e.matrixWorld))
            : (t.boundingSphere || t.computeBoundingSphere(),
              t0.copy(t.boundingSphere),
              t0.applyMatrix4(e.dcgModelMatrix),
              t0.applyMatrix4(e.matrixWorld)),
            this.intersectsSphere(t0))
          : false;
      }
      intersectsSphere(e) {
        let t = this.planes, o = e.center, i = -e.radius;
        for (let n = 0; n < 6; n++) {
          if (t[n].distanceToPoint(o) < i) return false;
        }
        return true;
      }
    };
  var r0 = class extends Ii {
    constructor() {
      super(), this.isGroup = true, this.type = "Group";
    }
  };
  var UW = new ye(),
    zW = new ye(),
    Yk = class extends Ii {
      constructor(e, t) {
        super(),
          this.isLine = true,
          this.type = "Line",
          this.geometry = e,
          this.material = t;
      }
      computeLineDistances() {
        let e = this.geometry;
        if (e.index === null) {
          let t = e.attributes.position, o = [0];
          for (let i = 1, n = t.count; i < n; i++) {
            UW.fromBufferAttribute(t, i - 1),
              zW.fromBufferAttribute(t, i),
              o[i] = o[i - 1],
              o[i] += UW.distanceTo(zW);
          }
          e.setAttribute("lineDistance", new Bo(o, 1));
        } else {console.warn(
            "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
          );}
        return this;
      }
    };
  var qW = new ye(),
    HW = new ye(),
    Xk = class extends Yk {
      constructor(e, t) {
        super(e, t), this.isLineSegments = true, this.type = "LineSegments";
      }
      computeLineDistances() {
        let e = this.geometry;
        if (e.index === null) {
          let t = e.attributes.position, o = [];
          for (let i = 0, n = t.count; i < n; i += 2) {
            qW.fromBufferAttribute(t, i),
              HW.fromBufferAttribute(t, i + 1),
              o[i] = i === 0 ? 0 : o[i - 1],
              o[i + 1] = o[i] + qW.distanceTo(HW);
          }
          e.setAttribute("lineDistance", new Bo(o, 1));
        } else {console.warn(
            "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
          );}
        return this;
      }
    };
  var KW = `
vec4 LinearToLinear( in vec4 value ) {
return value;
}

vec4 LinearTosRGB( in vec4 value ) {
return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
`;
  var WW = `
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#define saturate( a ) clamp( a, 0.0, 1.0 )

float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }

#ifdef HIGH_PRECISION
float precisionSafeLength( vec3 v ) { return length( v ); }
#else
float precisionSafeLength( vec3 v ) {
float maxComponent = max3( abs( v ) );
return length( v / maxComponent ) * maxComponent;
}
#endif

struct IncidentLight {
vec3 color;
vec3 direction;
bool visible;
};

struct ReflectedLight {
vec3 directDiffuse;
vec3 directSpecular;
vec3 indirectDiffuse;
vec3 indirectSpecular;
};

struct GeometricContext {
vec3 position;
vec3 normal;
vec3 viewDir;
};

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}

vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
return RECIPROCAL_PI * diffuseColor;
}

vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
`;
  var $W = `
#ifdef USE_MAP
diffuseColor *= texture2D( map, vMapUv );
#endif

#ifdef USE_ALPHATEST
if ( diffuseColor.a < alphaTest ) discard;
#endif
`;
  var jW = `
#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif

gl_FragColor = vec4( outgoingLight, diffuseColor.a );
gl_FragColor = linearToOutputTexel( gl_FragColor );

#ifdef PREMULTIPLIED_ALPHA
// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
gl_FragColor.rgb *= gl_FragColor.a;
#endif
`;
  var YW = `
#ifdef USE_MAP
varying vec2 vMapUv;
uniform sampler2D map;
#endif

#ifdef USE_ALPHATEST
uniform float alphaTest;
#endif

#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
varying vec3 vColor;
#endif

#if defined(USE_INSTANCING_PICKINGCOLOR) || defined(USE_VERTEX_PICKING_COLOR)
varying vec4 vPickingColor;
#endif
`;
  var XW = `
#ifdef USE_MAP
varying vec2 vMapUv;
#endif

#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
varying vec3 vColor;
#endif

#if defined(USE_INSTANCING_PICKINGCOLOR) || defined (USE_VERTEX_PICKING_COLOR)
varying vec4 vPickingColor;
#endif
`;
  var JW = `
#ifdef USE_MAP
vMapUv = ( vec3( MAP_UV, 1 ) ).xy;
#endif

vec3 transformed = vec3( position );
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_INSTANCING
mvPosition = instanceMatrix * mvPosition;
#else
mvPosition = dcgModelMatrix * mvPosition;
#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;

#ifdef USE_COLOR
vColor = color;
#endif

#ifdef USE_INSTANCING_COLOR
vColor = instanceColor;
#endif

#ifdef USE_INSTANCING_PICKINGCOLOR
vPickingColor = instancePickingColor;
#endif

#ifdef USE_VERTEX_PICKING_COLOR
vPickingColor = vertexPickingColor;
#endif

`;
  var QW = `
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );

#ifdef IOR
material.ior = ior;
float specularIntensityFactor = 1.0;
vec3 specularColorFactor = vec3( 1.0 );
material.specularF90 = 1.0;
material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
material.specularF90 = 1.0;
#endif

GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

IncidentLight directLight;

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
DirectionalLight directionalLight;
#pragma unroll_loop_start
for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
directionalLight = directionalLights[ i ];
getDirectionalLightInfo( directionalLight, geometry, directLight );
RE_Direct( directLight, geometry, material, reflectedLight );
}
#pragma unroll_loop_end
#endif

#if defined( RE_IndirectDiffuse )
vec3 iblIrradiance = vec3( 0.0 );
vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
#endif

#if defined( RE_IndirectSpecular )
vec3 radiance = vec3( 0.0 );
vec3 clearcoatRadiance = vec3( 0.0 );
#endif

#if defined( RE_IndirectDiffuse )
RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif

#if defined( RE_IndirectSpecular )
RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif
`;
  var ZW = `
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];

vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
float x = normal.x, y = normal.y, z = normal.z;
vec3 result = shCoefficients[ 0 ] * 0.886227;
result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
return result;
}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
return irradiance;
}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
vec3 irradiance = ambientLightColor;
return irradiance;
}

#if NUM_DIR_LIGHTS > 0
struct DirectionalLight {
vec3 direction;
vec3 color;
};
uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
light.color = directionalLight.color;
light.direction = directionalLight.direction;
light.visible = true;
}
#endif

struct PhysicalMaterial {
vec3 diffuseColor;
float roughness;
vec3 specularColor;
float specularF90;

#ifdef IOR
float ior;
#endif
};

vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );

float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
float a2 = pow2( alpha );
float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
return 0.5 / max( gv + gl, EPSILON );
}

float D_GGX( const in float alpha, const in float dotNH ) {
float a2 = pow2( alpha );
float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1
return RECIPROCAL_PI * a2 / pow2( denom );
}

vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
vec3 f0 = material.specularColor;
float f90 = material.specularF90;
float roughness = material.roughness;
float alpha = pow2( roughness ); // UE4's roughness
vec3 halfDir = normalize( lightDir + viewDir );
float dotNL = saturate( dot( normal, lightDir ) );
float dotNV = saturate( dot( normal, viewDir ) );
float dotNH = saturate( dot( normal, halfDir ) );
float dotVH = saturate( dot( viewDir, halfDir ) );
vec3 F = F_Schlick( f0, f90, dotVH );
float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
float D = D_GGX( alpha, dotNH );
return F * ( V * D );
}

vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
float dotNV = saturate( dot( normal, viewDir ) );
const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
vec4 r = roughness * c0 + c1;
float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
return fab;
}

void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
vec2 fab = DFGApprox( normal, viewDir, roughness );
vec3 Fr = specularColor;
vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
float Ess = fab.x + fab.y;
float Ems = 1.0 - Ess;
vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619; // 1/21
vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
singleScatter += FssEss;
multiScatter += Fms * Ems;
}

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
vec3 irradiance = dotNL * directLight.color;
reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
vec3 singleScattering = vec3( 0.0 );
vec3 multiScattering = vec3( 0.0 );
vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
vec3 totalScattering = singleScattering + multiScattering;
vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
reflectedLight.indirectSpecular += radiance * singleScattering;
reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}

#define RE_Direct RE_Direct_Physical
#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular	RE_IndirectSpecular_Physical
`;
  var un = {
    common: WW,
    colorspace_pars_fragment: KW,
    common_fragment_begin: $W,
    common_fragment_end: jW,
    common_pars_fragment: YW,
    common_pars_vertex: XW,
    common_vertex: JW,
    lights_fragment: QW,
    lights_pars_fragment: ZW,
  };
  var sO = {
    common: {
      diffuse: { value: new vt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      alphaTest: { value: 0 },
    },
    lights: {
      ambientLightColor: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
    },
  };
  var Jk = class {
    constructor(e, t) {
      this.gl = e;
      this.info = t;
    }
    setMode(e) {
      this.mode = e;
    }
    render(e, t) {
      this.gl.drawArrays(this.mode, e, t), this.info.update(t, this.mode, 1);
    }
    renderInstances(e, t, o) {
      o !== 0 &&
        (this.gl.drawArraysInstanced(this.mode, e, t, o),
          this.info.update(t, this.mode, o));
    }
  };
  var Qk = class {
    constructor(e, t, o) {
      let i;
      function n() {
        if (i !== void 0) return i;
        if (t.has("EXT_texture_filter_anisotropic") === true) {
          let A = t.get("EXT_texture_filter_anisotropic");
          i = e.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else i = 0;
        return i || 0;
      }
      function a(A) {
        if (A === "highp") {
          let P = e.getShaderPrecisionFormat(
              e.VERTEX_SHADER,
              e.HIGH_FLOAT,
            ),
            O = e.getShaderPrecisionFormat(
              e.FRAGMENT_SHADER,
              e.HIGH_FLOAT,
            );
          if (
            P !== null && P.precision > 0 && O !== null && O.precision > 0
          ) return "highp";
          A = "mediump";
        }
        if (A === "mediump") {
          let P = e.getShaderPrecisionFormat(
              e.VERTEX_SHADER,
              e.MEDIUM_FLOAT,
            ),
            O = e.getShaderPrecisionFormat(
              e.FRAGMENT_SHADER,
              e.MEDIUM_FLOAT,
            );
          if (
            P !== null && P.precision > 0 && O !== null && O.precision > 0
          ) return "mediump";
        }
        return "lowp";
      }
      let s = typeof WebGL2RenderingContext != "undefined" &&
          e.constructor.name === "WebGL2RenderingContext",
        l = o.precision !== void 0 ? o.precision : "highp",
        c = a(l);
      c !== l &&
        (console.warn(
          "THREE.WebGLRenderer:",
          l,
          "not supported, using",
          c,
          "instead.",
        ),
          l = c);
      let d = s || t.has("WEBGL_draw_buffers"),
        p = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
        h = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        u = e.getParameter(e.MAX_TEXTURE_SIZE),
        f = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
        y = e.getParameter(e.MAX_VERTEX_ATTRIBS),
        C = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
        E = e.getParameter(e.MAX_VARYING_VECTORS),
        v = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
        w = h > 0,
        S = s || t.has("OES_texture_float"),
        k = w && S,
        _ = s ? e.getParameter(e.MAX_SAMPLES) : 0;
      this.isWebGL2 = s,
        this.drawBuffers = d,
        this.getMaxAnisotropy = n,
        this.getMaxPrecision = a,
        this.precision = l,
        this.maxTextures = p,
        this.maxVertexTextures = h,
        this.maxTextureSize = u,
        this.maxCubemapSize = f,
        this.maxAttributes = y,
        this.maxVertexUniforms = C,
        this.maxVaryings = E,
        this.maxFragmentUniforms = v,
        this.vertexTextures = w,
        this.floatFragmentTextures = S,
        this.floatVertexTextures = k,
        this.maxSamples = _;
    }
  };
  var Zk = class {
    constructor(e) {
      let t = {};
      function o(i) {
        if (t[i] !== void 0) return t[i];
        let n;
        switch (i) {
          case "EXT_texture_filter_anisotropic":
            n = e.getExtension("EXT_texture_filter_anisotropic") ||
              e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
              e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            n = e.getExtension("WEBGL_compressed_texture_s3tc") ||
              e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
              e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            n = e.getExtension("WEBGL_compressed_texture_pvrtc") ||
              e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            n = e.getExtension(i);
        }
        return t[i] = n, n;
      }
      this.has = function (i) {
        return o(i) !== null;
      },
        this.init = function () {
          o("EXT_color_buffer_float"),
            o("OES_texture_float_linear"),
            o("EXT_color_buffer_half_float"),
            o("WEBGL_multisampled_render_to_texture");
        },
        this.get = function (i) {
          let n = o(i);
          return n === null &&
            console.warn(
              "THREE.WebGLRenderer: " + i + " extension not supported.",
            ),
            n;
        };
    }
  };
  var Ly = class extends La {
    constructor() {
      super(),
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0;
    }
  };
  var e_ = class {
    constructor(e, t, o, i) {
      let n = {}, a = new WeakMap();
      function s(h) {
        let u = h.target;
        u.index !== null && t.remove(u.index);
        for (let y in u.attributes) t.remove(u.attributes[y]);
        u.removeEventListener("dispose", s), delete n[u.id];
        let f = a.get(u);
        f && (t.remove(f), a.delete(u)),
          i.releaseStatesOfGeometry(u),
          u instanceof Ly && delete u._maxInstanceCount,
          o.memory.geometries--;
      }
      function l(h, u) {
        return n[u.id] === true ||
          (u.addEventListener("dispose", s),
            n[u.id] = true,
            o.memory.geometries++),
          u;
      }
      function c(h) {
        let u = h.attributes;
        for (let f in u) t.update(u[f], e.ARRAY_BUFFER);
      }
      function d(h) {
        let u = [], f = h.index, y = h.attributes.position, C = 0;
        if (f !== null) {
          let w = f.array;
          C = f.version;
          for (let S = 0, k = w.length; S < k; S += 3) {
            let _ = w[S + 0], A = w[S + 1], P = w[S + 2];
            u.push(_, A, A, P, P, _);
          }
        } else if (y !== void 0) {
          let w = y.array;
          C = y.version;
          for (let S = 0, k = w.length / 3 - 1; S < k; S += 3) {
            let _ = S + 0, A = S + 1, P = S + 2;
            u.push(_, A, A, P, P, _);
          }
        } else return;
        let E = new (Nk(u) ? bh : fh)(u, 1);
        E.version = C;
        let v = a.get(h);
        v && t.remove(v), a.set(h, E);
      }
      function p(h) {
        let u = a.get(h);
        if (u) {
          let y = h.index;
          y !== null && u.version < y.version && d(h);
        } else d(h);
        let f = a.get(h);
        return wt(f, "attribute"), f;
      }
      this.get = l, this.update = c, this.getWireframeAttribute = p;
    }
  };
  var t_ = class {
    constructor(e, t) {
      this.gl = e;
      this.info = t;
    }
    setMode(e) {
      this.mode = e;
    }
    setIndex(e) {
      this.type = e.type, this.bytesPerElement = e.bytesPerElement;
    }
    render(e, t) {
      this.gl.drawElements(
        this.mode,
        t,
        this.type,
        e * this.bytesPerElement,
      ), this.info.update(t, this.mode, 1);
    }
    renderInstances(e, t, o) {
      o !== 0 &&
        (this.gl.drawElementsInstanced(
          this.mode,
          t,
          this.type,
          e * this.bytesPerElement,
          o,
        ),
          this.info.update(t, this.mode, o));
    }
  };
  var r_ = class {
    constructor(e) {
      this.gl = e;
      this.autoReset = true;
      this.programs = null;
      this.memory = { geometries: 0, textures: 0 },
        this.render = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0,
        };
    }
    update(e, t, o) {
      let i = this.gl, n = this.render;
      switch (n.calls++, t) {
        case i.TRIANGLES:
          n.triangles += o * (e / 3);
          break;
        case i.LINES:
          n.lines += o * (e / 2);
          break;
        case i.LINE_STRIP:
          n.lines += o * (e - 1);
          break;
        case i.LINE_LOOP:
          n.lines += o * e;
          break;
        case i.POINTS:
          n.points += o * e;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", t);
          break;
      }
    }
    reset() {
      this.render.calls = 0,
        this.render.triangles = 0,
        this.render.points = 0,
        this.render.lines = 0;
    }
  };
  var lO = class {
      constructor() {
        this.lights = {};
      }
      get(e) {
        let t = this.lights, o = t[e.id];
        if (o !== void 0) return o;
        let i = { direction: new ye(), color: new vt() };
        return t[e.id] = i, i;
      }
    },
    Pae = 0,
    o_ = class {
      constructor() {
        let e = new lO();
        this.state = {
          version: 0,
          hash: { directionalLength: -1 },
          ambient: [0, 0, 0],
          directional: [],
        };
        let t = this.state, o = new ye();
        function i(a) {
          let s = 0, l = 0, c = 0, d = 0;
          for (let h = 0, u = a.length; h < u; h++) {
            let f = a[h], y = f.color, C = f.intensity;
            if (f instanceof Gy) s += y.r * C, l += y.g * C, c += y.b * C;
            else if (f instanceof Ch) {
              let E = e.get(f);
              E.color.copy(f.color).multiplyScalar(f.intensity),
                t.directional[d] = E,
                d++;
            }
          }
          t.ambient[0] = s, t.ambient[1] = l, t.ambient[2] = c;
          let p = t.hash;
          p.directionalLength !== d &&
            (t.directional.length = d,
              p.directionalLength = d,
              t.version = Pae++);
        }
        function n(a, s) {
          let l = 0, c = s.matrixWorldInverse;
          for (let d = 0, p = a.length; d < p; d++) {
            let h = a[d];
            if (h instanceof Ch) {
              let u = t.directional[l];
              u.direction.setFromMatrixPosition(h.matrixWorld),
                o.setFromMatrixPosition(h.target.matrixWorld),
                u.direction.sub(o),
                u.direction.transformDirection(c),
                l++;
            }
          }
        }
        this.setup = i, this.setupView = n;
      }
    };
  var i_ = class {
    constructor(e, t, o, i) {
      let n = new WeakMap();
      function a(c) {
        let d = i.render.frame, p = c.geometry, h = t.get(c, p);
        return n.get(h) !== d && (t.update(h), n.set(h, d)),
          c instanceof Mi &&
          (c.hasEventListener("dispose", l) === false &&
            c.addEventListener("dispose", l),
            n.get(c) !== d &&
            (o.update(c.instanceMatrix, e.ARRAY_BUFFER),
              c.instanceColor &&
              o.update(c.instanceColor, e.ARRAY_BUFFER),
              c.instancePickingColor &&
              o.update(c.instancePickingColor, e.ARRAY_BUFFER),
              n.set(c, d))),
          h;
      }
      function s() {
        n = new WeakMap();
      }
      function l(c) {
        let d = c.target;
        d.removeEventListener("dispose", l),
          o.remove(d.instanceMatrix),
          d.instanceColor && o.remove(d.instanceColor),
          d.instancePickingColor && o.remove(d.instancePickingColor);
      }
      this.update = a, this.dispose = s;
    }
  };
  Ss();
  function cO(r, e, t) {
    let o = r.createShader(e);
    if (!o) throw new Error(`Error creating shader (type ${e}): ${t}`);
    return r.shaderSource(o, t), r.compileShader(o), o;
  }
  var a7 = new Bs(new Bd(0, 0));
  function Vae(r) {
    return typeof r[0] == "number";
  }
  function Zp(r) {
    return !Array.isArray(r) && "x" in r;
  }
  var e7 = [],
    t7 = [],
    r7 = new Float32Array(16),
    o7 = new Float32Array(9),
    i7 = new Float32Array(4);
  function Py(r, e, t) {
    if (Vae(r)) return r;
    let o = e * t, i = e7[o];
    if (i === void 0 && (i = new Float32Array(o), e7[o] = i), e !== 0) {
      r[0].toArray(i, 0);
      for (let n = 1, a = 0; n !== e; ++n) a += t, r[n].toArray(i, a);
    }
    return i;
  }
  function Pa(r, e) {
    if (r.length !== e.length) return false;
    for (let t = 0, o = r.length; t < o; t++) {
      if (r[t] !== e[t]) return false;
    }
    return true;
  }
  function Va(r, e) {
    for (let t = 0, o = e.length; t < o; t++) r[t] = e[t];
  }
  function Oae(r, e) {
    let t = t7[e];
    t === void 0 && (t = new Int32Array(e), t7[e] = t);
    for (let o = 0; o !== e; ++o) t[o] = r.allocateTextureUnit();
    return t;
  }
  function Rae(r, e) {
    let t = this.cache;
    t[0] !== e && (r.uniform1f(this.addr, e), t[0] = e);
  }
  function Fae(r, e) {
    let t = this.cache;
    if (Zp(e)) {
      (t[0] !== e.x || t[1] !== e.y) &&
        (r.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    } else {
      if (Pa(t, e)) return;
      r.uniform2fv(this.addr, e), Va(t, e);
    }
  }
  function Nae(r, e) {
    let t = this.cache;
    if (Zp(e)) {
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
        (r.uniform3f(this.addr, e.x, e.y, e.z),
          t[0] = e.x,
          t[1] = e.y,
          t[2] = e.z);
    } else if (e instanceof vt) {
      (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
        (r.uniform3f(this.addr, e.r, e.g, e.b),
          t[0] = e.r,
          t[1] = e.g,
          t[2] = e.b);
    } else {
      if (Pa(t, e)) return;
      r.uniform3fv(this.addr, e), Va(t, e);
    }
  }
  function Bae(r, e) {
    let t = this.cache;
    if (Zp(e)) {
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
        (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
          t[0] = e.x,
          t[1] = e.y,
          t[2] = e.z,
          t[3] = e.w);
    } else {
      if (Pa(t, e)) return;
      r.uniform4fv(this.addr, e), Va(t, e);
    }
  }
  function Uae(r, e) {
    let t = this.cache;
    if (Array.isArray(e)) {
      if (Pa(t, e)) return;
      r.uniformMatrix2fv(this.addr, false, e), Va(t, e);
    } else {
      let o = e.elements;
      if (Pa(t, o)) return;
      i7.set(o), r.uniformMatrix2fv(this.addr, false, i7), Va(t, o);
    }
  }
  function zae(r, e) {
    let t = this.cache;
    if (Array.isArray(e)) {
      if (Pa(t, e)) return;
      r.uniformMatrix3fv(this.addr, false, e), Va(t, e);
    } else {
      let o = e.elements;
      if (Pa(t, o)) return;
      o7.set(o), r.uniformMatrix3fv(this.addr, false, o7), Va(t, o);
    }
  }
  function qae(r, e) {
    let t = this.cache;
    if (Array.isArray(e)) {
      if (Pa(t, e)) return;
      r.uniformMatrix4fv(this.addr, false, e), Va(t, e);
    } else {
      let o = e.elements;
      if (Pa(t, o)) return;
      r7.set(o), r.uniformMatrix4fv(this.addr, false, r7), Va(t, o);
    }
  }
  function Hae(r, e) {
    let t = this.cache;
    t[0] !== e && (r.uniform1i(this.addr, e), t[0] = e);
  }
  function Kae(r, e) {
    let t = this.cache;
    if (Zp(e)) {
      (t[0] !== e.x || t[1] !== e.y) &&
        (r.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    } else {
      if (Pa(t, e)) return;
      r.uniform2iv(this.addr, e), Va(t, e);
    }
  }
  function Wae(r, e) {
    let t = this.cache;
    if (Zp(e)) {
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
        (r.uniform3i(this.addr, e.x, e.y, e.z),
          t[0] = e.x,
          t[1] = e.y,
          t[2] = e.z);
    } else {
      if (Pa(t, e)) return;
      r.uniform3iv(this.addr, e), Va(t, e);
    }
  }
  function $ae(r, e) {
    let t = this.cache;
    if (Zp(e)) {
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
        (r.uniform4i(this.addr, e.x, e.y, e.z, e.w),
          t[0] = e.x,
          t[1] = e.y,
          t[2] = e.z,
          t[3] = e.w);
    } else {
      if (Pa(t, e)) return;
      r.uniform4iv(this.addr, e), Va(t, e);
    }
  }
  function jae(r, e) {
    let t = this.cache;
    t[0] !== e && (r.uniform1ui(this.addr, e), t[0] = e);
  }
  function Yae(r, e) {
    let t = this.cache;
    if (Zp(e)) {
      (t[0] !== e.x || t[1] !== e.y) &&
        (r.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    } else {
      if (Pa(t, e)) return;
      r.uniform2uiv(this.addr, e), Va(t, e);
    }
  }
  function Xae(r, e) {
    let t = this.cache;
    if (Zp(e)) {
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
        (r.uniform3ui(this.addr, e.x, e.y, e.z),
          t[0] = e.x,
          t[1] = e.y,
          t[2] = e.z);
    } else {
      if (Pa(t, e)) return;
      r.uniform3uiv(this.addr, e), Va(t, e);
    }
  }
  function Jae(r, e) {
    let t = this.cache;
    if (Zp(e)) {
      (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
        (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
          t[0] = e.x,
          t[1] = e.y,
          t[2] = e.z,
          t[3] = e.w);
    } else {
      if (Pa(t, e)) return;
      r.uniform4uiv(this.addr, e), Va(t, e);
    }
  }
  function Qae(r, e, t) {
    let o = this.cache, i = t.allocateTextureUnit();
    o[0] !== i && (r.uniform1i(this.addr, i), o[0] = i),
      t.setTexture2D(e || a7, i);
  }
  function Zae(r) {
    switch (r) {
      case 5126:
        return Rae;
      case 35664:
        return Fae;
      case 35665:
        return Nae;
      case 35666:
        return Bae;
      case 35674:
        return Uae;
      case 35675:
        return zae;
      case 35676:
        return qae;
      case 5124:
      case 35670:
        return Hae;
      case 35667:
      case 35671:
        return Kae;
      case 35668:
      case 35672:
        return Wae;
      case 35669:
      case 35673:
        return $ae;
      case 5125:
        return jae;
      case 36294:
        return Yae;
      case 36295:
        return Xae;
      case 36296:
        return Jae;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
        return Qae;
      case 35679:
      case 36299:
      case 36307:
        throw new Error(
          "THREE.WebGLUniforms: sampler3D support is not implemented.",
        );
      case 35680:
      case 36300:
      case 36308:
        throw new Error(
          "THREE.WebGLUniforms: samplerCube support is not implemented.",
        );
      case 36289:
      case 36303:
      case 36311:
        throw new Error(
          "THREE.WebGLUniforms: sampler2DArray support is not implemented.",
        );
    }
    throw new Error(`Unknown uniform type: ${r}`);
  }
  function ese(r, e) {
    r.uniform1fv(this.addr, e);
  }
  function tse(r, e) {
    let t = Py(e, this.size, 2);
    r.uniform2fv(this.addr, t);
  }
  function rse(r, e) {
    let t = Py(e, this.size, 3);
    r.uniform3fv(this.addr, t);
  }
  function ose(r, e) {
    let t = Py(e, this.size, 4);
    r.uniform4fv(this.addr, t);
  }
  function ise(r, e) {
    let t = Py(e, this.size, 4);
    r.uniformMatrix2fv(this.addr, false, t);
  }
  function nse(r, e) {
    let t = Py(e, this.size, 9);
    r.uniformMatrix3fv(this.addr, false, t);
  }
  function ase(r, e) {
    let t = Py(e, this.size, 16);
    r.uniformMatrix4fv(this.addr, false, t);
  }
  function sse(r, e) {
    r.uniform1iv(this.addr, e);
  }
  function lse(r, e) {
    r.uniform2iv(this.addr, e);
  }
  function cse(r, e) {
    r.uniform3iv(this.addr, e);
  }
  function dse(r, e) {
    r.uniform4iv(this.addr, e);
  }
  function pse(r, e) {
    r.uniform1uiv(this.addr, e);
  }
  function use(r, e) {
    r.uniform2uiv(this.addr, e);
  }
  function hse(r, e) {
    r.uniform3uiv(this.addr, e);
  }
  function gse(r, e) {
    r.uniform4uiv(this.addr, e);
  }
  function mse(r, e, t) {
    let o = this.cache, i = e.length, n = Oae(t, i);
    Pa(o, n) || (r.uniform1iv(this.addr, n), Va(o, n));
    for (let a = 0; a !== i; ++a) t.setTexture2D(e[a] || a7, n[a]);
  }
  function fse(r) {
    switch (r) {
      case 5126:
        return ese;
      case 35664:
        return tse;
      case 35665:
        return rse;
      case 35666:
        return ose;
      case 35674:
        return ise;
      case 35675:
        return nse;
      case 35676:
        return ase;
      case 5124:
      case 35670:
        return sse;
      case 35667:
      case 35671:
        return lse;
      case 35668:
      case 35672:
        return cse;
      case 35669:
      case 35673:
        return dse;
      case 5125:
        return pse;
      case 36294:
        return use;
      case 36295:
        return hse;
      case 36296:
        return gse;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
        return mse;
      case 35679:
      case 36299:
      case 36307:
        throw new Error(
          "THREE.WebGLUniforms: sampler3DArray support is not implemented.",
        );
      case 35680:
      case 36300:
      case 36308:
        throw new Error(
          "THREE.WebGLUniforms: samplerCube support is not implemented.",
        );
      case 36289:
      case 36303:
      case 36311:
        throw new Error(
          "THREE.WebGLUniforms: sampler2DArray support is not implemented.",
        );
    }
    throw new Error(`Unrecognized uniform type: ${r}`);
  }
  var pO = class {
      constructor(e, t, o) {
        this.id = e,
          this.addr = o,
          this.cache = [],
          this.setValue = Zae(t.type);
      }
    },
    uO = class {
      constructor(e, t, o) {
        this.id = e,
          this.addr = o,
          this.cache = [],
          this.size = t.size,
          this.setValue = fse(t.type);
      }
    },
    n_ = class {
      constructor(e) {
        this.id = e, this.seq = [], this.map = {};
      }
      setValue(e, t, o) {
        let i = this.seq;
        for (let n = 0, a = i.length; n !== a; ++n) {
          let s = i[n];
          s.setValue(e, t[s.id], o);
        }
      }
    },
    dO = /(\w+)(\])?(\[|\.)?/g;
  function n7(r, e) {
    r.seq.push(e), r.map[e.id] = e;
  }
  function bse(r, e, t) {
    let o = r.name, i = o.length;
    for (dO.lastIndex = 0;;) {
      let n = dO.exec(o), a = dO.lastIndex;
      wt(n, "parseUniform match");
      let s = n[1], l = n[2] === "]", c = n[3];
      if (l && (s = s | 0), c === void 0 || c === "[" && a + 2 === i) {
        n7(t, c === void 0 ? new pO(s, r, e) : new uO(s, r, e));
        break;
      } else {
        let p = t.map[s];
        if (
          p === void 0 && (p = new n_(s), n7(t, p)), !(p instanceof n_)
        ) {
          throw new Error(
            `THREE.WebGLUniforms: Programming error: expected ${s} to be a StructuredUniform`,
          );
        }
        t = p;
      }
    }
  }
  var Th = class {
    constructor(e, t) {
      this.seq = [], this.map = {};
      let o = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
      for (let i = 0; i < o; ++i) {
        let n = e.getActiveUniform(t, i);
        wt(n, "active info", e);
        let a = e.getUniformLocation(t, n.name);
        bse(n, a, this);
      }
    }
    setValue(e, t, o, i) {
      let n = this.map[t];
      n !== void 0 && n.setValue(e, o, i);
    }
    setOptional(e, t, o, i) {
      let n = t[o];
      n !== void 0 && this.setValue(e, o, n, i);
    }
    static upload(e, t, o, i) {
      for (let n = 0, a = t.length; n !== a; ++n) {
        let s = t[n], l = o[s.id];
        l.needsUpdate !== false && s.setValue(e, l.value, i);
      }
    }
    static seqWithValue(e, t) {
      let o = [];
      for (let i = 0, n = e.length; i !== n; ++i) {
        let a = e[i];
        a.id in t && o.push(a);
      }
      return o;
    }
  };
  var yse = 0;
  function xse(r, e) {
    if (r === null) throw new Error("Shader source is undefined.");
    let t = r.split(`
`),
      o = [],
      i = Math.max(e - 6, 0),
      n = Math.min(e + 6, t.length);
    for (let a = i; a < n; a++) {
      let s = a + 1;
      o.push(`${s === e ? ">" : " "} ${s}: ${t[a]}`);
    }
    return o.join(`
`);
  }
  function wse(r) {
    switch (r) {
      case Ga:
        return ["Linear", "( value )"];
      case Lo:
        return ["sRGB", "( value )"];
      default:
        return console.warn(
          "THREE.WebGLProgram: Unsupported color space:",
          r,
        ),
          ["Linear", "( value )"];
    }
  }
  function s7(r, e, t) {
    let o = r.getShaderParameter(e, r.COMPILE_STATUS),
      i = r.getShaderInfoLog(e);
    wt(i, "shader info", r);
    let n = i.trim() || "";
    if (o && n === "") return "";
    let a = /ERROR: 0:(\d+)/.exec(n);
    if (a) {
      let s = parseInt(a[1]);
      return t.toUpperCase() + `

` + n + `

` + xse(r.getShaderSource(e), s);
    } else return n;
  }
  function vse(r, e) {
    let t = wse(e);
    return "vec4 " + r + "( vec4 value ) { return LinearTo" + t[0] +
      t[1] + "; }";
  }
  function Cse(r) {
    let e = [];
    for (let t in r) {
      let o = r[t];
      o !== false && e.push("#define " + t + " " + o);
    }
    return e.join(`
`);
  }
  function Sse(r, e) {
    let t = {}, o = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < o; i++) {
      let n = r.getActiveAttrib(e, i);
      if (!n) {
        throw new Error(
          "THREE.WebGLProgram: Error fetching attribute info.",
        );
      }
      let a = n.name, s = 1;
      n.type === r.FLOAT_MAT2 && (s = 2),
        n.type === r.FLOAT_MAT3 && (s = 3),
        n.type === r.FLOAT_MAT4 && (s = 4),
        t[a] = {
          type: n.type,
          location: r.getAttribLocation(e, a),
          locationSize: s,
        };
    }
    return t;
  }
  function l7(r) {
    return r !== "";
  }
  function c7(r, e) {
    return r.replace(/NUM_DIR_LIGHTS/g, "" + e.numDirLights);
  }
  var Ese =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function d7(r) {
    return r.replace(Ese, Tse);
  }
  function Tse(r, e, t, o) {
    let i = "";
    for (let n = parseInt(e); n < parseInt(t); n++) {
      i += o.replace(/\[\s*i\s*\]/g, "[ " + n + " ]").replace(
        /UNROLLED_LOOP_INDEX/g,
        "" + n,
      );
    }
    return i;
  }
  function p7(r) {
    let e = "precision " + r.precision + ` float;
precision ` + r.precision + " int;";
    return r.precision === "highp"
      ? e += `
#define HIGH_PRECISION`
      : r.precision === "mediump"
      ? e += `
#define MEDIUM_PRECISION`
      : r.precision === "lowp" && (e += `
#define LOW_PRECISION`),
      e;
  }
  var a_ = class {
    constructor(e, t, o, i) {
      var S, k, _;
      let n = e.getContext(),
        a = o.defines,
        s = o.vertexShader,
        l = o.fragmentShader,
        c = Cse(a),
        d = n.createProgram();
      if (!d) {
        throw new Error("THREE.WebGLProgram: Unable to create program.");
      }
      let p,
        h,
        u = o.glslVersion
          ? "#version " + o.glslVersion + `
`
          : "";
      p = [
        p7(o),
        "#define SHADER_TYPE " + o.shaderType,
        "#define SHADER_NAME " + o.shaderName,
        c,
        o.instancing ? "#define USE_INSTANCING" : "",
        o.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        o.instancingPickingColor ? "#define USE_INSTANCING_PICKINGCOLOR" : "",
        o.vertexPickingColor ? "#define USE_VERTEX_PICKING_COLOR" : "",
        o.map ? "#define USE_MAP" : "",
        o.mapUv ? "#define MAP_UV " + o.mapUv : "",
        o.vertexColors ? "#define USE_COLOR" : "",
        o.vertexUv1s ? "#define USE_UV1" : "",
        o.vertexUv2s ? "#define USE_UV2" : "",
        o.vertexUv3s ? "#define USE_UV3" : "",
        o.doubleSided ? "#define DOUBLE_SIDED" : "",
        o.flipSided ? "#define FLIP_SIDED" : "",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_COLOR",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_PICKINGCOLOR",
        "	attribute vec4 instancePickingColor;",
        "#endif",
        "#ifdef USE_VERTEX_PICKING_COLOR",
        " attribute vec4 vertexPickingColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        `
`,
      ].filter(l7).join(`
`),
        h = [
          p7(o),
          "#define SHADER_TYPE " + o.shaderType,
          "#define SHADER_NAME " + o.shaderName,
          c,
          o.map ? "#define USE_MAP" : "",
          o.alphaTest ? "#define USE_ALPHATEST" : "",
          o.vertexColors ? "#define USE_COLOR" : "",
          o.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          o.instancingPickingColor ? "#define USE_INSTANCING_PICKINGCOLOR" : "",
          o.vertexPickingColor ? "#define USE_VERTEX_PICKING_COLOR" : "",
          o.vertexUv1s ? "#define USE_UV1" : "",
          o.vertexUv2s ? "#define USE_UV2" : "",
          o.vertexUv3s ? "#define USE_UV3" : "",
          o.doubleSided ? "#define DOUBLE_SIDED" : "",
          o.flipSided ? "#define FLIP_SIDED" : "",
          o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          o.opaque ? "#define OPAQUE" : "",
          un.colorspace_pars_fragment,
          vse("linearToOutputTexel", o.outputColorSpace),
          `
`,
        ].filter(l7).join(`
`),
        s = c7(s, o),
        l = c7(l, o),
        s = d7(s),
        l = d7(l),
        u = `#version 300 es
`,
        p = [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) + `
` + p,
        h = [
          "#define varying in",
          o.glslVersion === QV
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          o.glslVersion === QV ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) + `
` + h;
      let f = u + p + s,
        y = u + h + l,
        C = cO(n, n.VERTEX_SHADER, f),
        E = cO(n, n.FRAGMENT_SHADER, y);
      if (
        n.attachShader(d, C),
          n.attachShader(d, E),
          o.index0AttributeName !== void 0 &&
          n.bindAttribLocation(d, 0, o.index0AttributeName),
          n.linkProgram(d),
          e.debug.checkShaderErrors
      ) {
        let A = (S = n.getProgramInfoLog(d)) == null ? void 0 : S.trim(),
          P = (k = n.getShaderInfoLog(C)) == null ? void 0 : k.trim(),
          O = (_ = n.getShaderInfoLog(E)) == null ? void 0 : _.trim();
        wt(A, "program lob", n),
          wt(P, "vertex log", n),
          wt(O, "fragment log", n);
        let U = true, z = true, x = false;
        if (n.getProgramParameter(d, n.LINK_STATUS) === false) {
          if (U = false, typeof e.debug.onShaderError == "function") {
            e.debug.onShaderError(n, d, C, E);
          } else {
            let L = s7(n, C, "vertex"),
              V = s7(n, E, "fragment"),
              R = n.getError();
            x = V.includes("Expression too complex"),
              x ||
              (console.error(
                "THREE.WebGLProgram: Shader Error " + R +
                  " - VALIDATE_STATUS " +
                  n.getProgramParameter(d, n.VALIDATE_STATUS) + `

Program Info Log: ` + A + `
` + L + `
` + V,
              ),
                R && R != 1282 || L || V || A && R != 1282
                  ? So("Shader error", {
                    metaData: {
                      glError: R,
                      glProgramParameter: n.getProgramParameter(
                        d,
                        n.VALIDATE_STATUS,
                      ),
                      glProgramLog: A,
                      glVertexErrors: L,
                      glFragmentError: V,
                      vertexShader: f,
                      fragmentShader: y,
                    },
                  })
                  : So(
                    "WebGL program link failure with no error reported",
                    { metaData: { vertexShader: f, fragmentShader: y } },
                  ));
          }
        } else {A !== ""
            ? console.warn("THREE.WebGLProgram: Program Info Log:", A)
            : (P === "" || O === "") && (z = false);}
        z &&
          (this.diagnostics = {
            runnable: U,
            exprTooComplex: x,
            programLog: A,
            vertexShader: { log: P, prefix: p },
            fragmentShader: { log: O, prefix: h },
          });
      }
      n.deleteShader(C), n.deleteShader(E);
      let v;
      this.getUniforms = function () {
        return v === void 0 && (v = new Th(n, d)), v;
      };
      let w;
      this.getAttributes = function () {
        return w === void 0 && (w = Sse(n, d)), w;
      },
        this.destroy = function () {
          i.releaseStatesOfProgram(this),
            n.deleteProgram(d),
            this.program = void 0;
        },
        this.type = o.shaderType,
        this.name = o.shaderName,
        this.id = yse++,
        this.cacheKey = t,
        this.usedTimes = 1,
        this.program = d,
        this.vertexShader = C,
        this.fragmentShader = E;
    }
  };
  var Dse = 0,
    s_ = class {
      constructor() {
        this.shaderCache = new Map(), this.materialCache = new Map();
      }
      update(e) {
        let t = e.vertexShader,
          o = e.fragmentShader,
          i = this._getShaderStage(t),
          n = this._getShaderStage(o),
          a = this._getShaderCacheForMaterial(e);
        return a.has(i) === false && (a.add(i), i.usedTimes++),
          a.has(n) === false && (a.add(n), n.usedTimes++),
          this;
      }
      remove(e) {
        let t = this.materialCache.get(e);
        for (let o of t || []) {
          o.usedTimes--, o.usedTimes === 0 && this.shaderCache.delete(o.code);
        }
        return this.materialCache.delete(e), this;
      }
      getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id;
      }
      getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id;
      }
      dispose() {
        this.shaderCache.clear(), this.materialCache.clear();
      }
      _getShaderCacheForMaterial(e) {
        let t = this.materialCache, o = t.get(e);
        return o === void 0 && (o = new Set(), t.set(e, o)), o;
      }
      _getShaderStage(e) {
        let t = this.shaderCache, o = t.get(e);
        return o === void 0 && (o = new hO(e), t.set(e, o)), o;
      }
    },
    hO = class {
      constructor(e) {
        this.id = Dse++, this.code = e, this.usedTimes = 0;
      }
    };
  var l_ = class {
    constructor(e, t, o) {
      let i = new Ty(),
        n = new s_(),
        a = [],
        s = t.vertexTextures,
        l = t.precision;
      function c(v) {
        return v === 0 ? "uv" : `uv${v}`;
      }
      function d(v, w, S, k) {
        var M, F, Z, te;
        let _ = k.geometry;
        v.precision !== null &&
          (l = t.getMaxPrecision(v.precision),
            l !== v.precision &&
            console.warn(
              "THREE.WebGLProgram.getParameters:",
              v.precision,
              "not supported, using",
              l,
              "instead.",
            ));
        let A = v.vertexShader, P = v.fragmentShader;
        n.update(v);
        let O = n.getVertexShaderID(v),
          U = n.getFragmentShaderID(v),
          z = e.getRenderTarget(),
          x = k instanceof Mi,
          L = !!_.attributes.uv1,
          V = !!_.attributes.uv2,
          R = !!_.attributes.uv3;
        return {
          shaderType: v.type,
          shaderName: v.name,
          vertexShader: A,
          fragmentShader: P,
          defines: v.defines,
          customVertexShaderID: O,
          customFragmentShaderID: U,
          glslVersion: v.glslVersion,
          precision: l,
          instancing: x,
          instancingColor: x && !!k.instanceColor,
          instancingPickingColor: x && !!k.instancePickingColor,
          vertexPickingColor: !!k.pickingColorArray,
          supportsVertexTextures: s,
          outputColorSpace: z === null ? e.outputColorSpace : Ga,
          map: !!v.map,
          opaque: v.transparent === false && v.blending === hh,
          alphaTest: v.alphaTest > 0,
          mapUv: !!v.map && c(v.map.channel),
          vertexColors: v.vertexColors,
          vertexUv1s: L,
          vertexUv2s: V,
          vertexUv3s: R,
          numDirLights: w.directional.length,
          premultipliedAlpha: v.premultipliedAlpha,
          doubleSided: v.side === ua,
          flipSided: v.side === lm,
          index0AttributeName: v.index0AttributeName,
          extensionDerivatives:
            ((M = v.extensions) == null ? void 0 : M.derivatives) === true,
          extensionFragDepth:
            ((F = v.extensions) == null ? void 0 : F.fragDepth) === true,
          extensionDrawBuffers:
            ((Z = v.extensions) == null ? void 0 : Z.drawBuffers) === true,
          extensionShaderTextureLOD:
            ((te = v.extensions) == null ? void 0 : te.shaderTextureLOD) ===
              true,
          rendererExtensionFragDepth: true,
          rendererExtensionDrawBuffers: true,
          rendererExtensionShaderTextureLod: true,
          customProgramCacheKey: v.customProgramCacheKey(),
        };
      }
      function p(v) {
        let w = [];
        if (
          w.push(v.customVertexShaderID),
            w.push(v.customFragmentShaderID),
            v.defines !== void 0
        ) { for (let S in v.defines) w.push(S), w.push(v.defines[S]); }
        return h(w, v),
          u(w, v),
          w.push(e.outputColorSpace),
          w.push(v.customProgramCacheKey),
          w.join();
      }
      function h(v, w) {
        v.push(w.precision),
          v.push(w.outputColorSpace),
          v.push(w.mapUv),
          v.push(w.numDirLights);
      }
      function u(v, w) {
        i.disableAll(),
          i.enable(0),
          w.instancing && i.enable(2),
          w.instancingColor && i.enable(3),
          w.instancingPickingColor && i.enable(4),
          w.vertexPickingColor && i.enable(5),
          w.supportsVertexTextures && i.enable(1),
          w.alphaTest && i.enable(10),
          w.vertexColors && i.enable(11),
          w.vertexUv1s && i.enable(13),
          w.vertexUv2s && i.enable(14),
          w.vertexUv3s && i.enable(15),
          v.push(i.mask),
          i.disableAll(),
          w.premultipliedAlpha && i.enable(8),
          w.doubleSided && i.enable(11),
          w.flipSided && i.enable(12),
          w.opaque && i.enable(17),
          v.push(i.mask);
      }
      function f(v, w) {
        let S;
        for (let k = 0, _ = a.length; k < _; k++) {
          let A = a[k];
          if (A.cacheKey === w) {
            S = A, ++S.usedTimes;
            break;
          }
        }
        return S === void 0 && (S = new a_(e, w, v, o), a.push(S)), S;
      }
      function y(v) {
        if (--v.usedTimes === 0) {
          let w = a.indexOf(v);
          a[w] = a[a.length - 1], a.pop(), v.destroy();
        }
      }
      function C(v) {
        n.remove(v);
      }
      function E() {
        n.dispose();
      }
      this.getParameters = d,
        this.getProgramCacheKey = p,
        this.getUniforms = (v) => v.uniforms,
        this.acquireProgram = f,
        this.releaseProgram = y,
        this.releaseShaderCache = C,
        this.programs = a,
        this.dispose = E;
    }
  };
  var c_ = class {
    constructor() {
      let e = new WeakMap();
      function t(a) {
        let s = e.get(a);
        return s === void 0 && (s = {}, e.set(a, s)), s;
      }
      function o(a) {
        e.delete(a);
      }
      function i(a, s, l) {
        e.get(a)[s] = l;
      }
      function n() {
        e = new WeakMap();
      }
      this.get = t, this.remove = o, this.update = i, this.dispose = n;
    }
  };
  var d_ = class {
      constructor() {
        let e = [], t = 0, o = [], i = [];
        function n() {
          t = 0, o.length = 0, i.length = 0;
        }
        function a(p, h, u, f, y, C) {
          let E = e[t];
          return E === void 0
            ? (E = {
              id: p.id,
              object: p,
              geometry: h,
              material: u,
              groupOrder: f,
              renderOrder: p.renderOrder,
              z: y,
              group: C,
            },
              e[t] = E)
            : (E.id = p.id,
              E.object = p,
              E.geometry = h,
              E.material = u,
              E.groupOrder = f,
              E.renderOrder = p.renderOrder,
              E.z = y,
              E.group = C),
            t++,
            E;
        }
        function s(p, h, u, f, y, C) {
          let E = a(p, h, u, f, y, C);
          u.transparent === true ? i.push(E) : o.push(E);
        }
        function l(p, h, u, f, y, C) {
          let E = a(p, h, u, f, y, C);
          u.transparent === true ? i.unshift(E) : o.unshift(E);
        }
        function c(p, h) {
          o.length > 1 && o.sort(p || kse), i.length > 1 && i.sort(h || _se);
        }
        function d() {
          for (let p = t, h = e.length; p < h; p++) {
            let u = e[p];
            if (u.id === null) break;
            u.id = null,
              u.object = null,
              u.geometry = null,
              u.material = null,
              u.group = null;
          }
        }
        this.opaque = o,
          this.transparent = i,
          this.init = n,
          this.push = s,
          this.unshift = l,
          this.finish = d,
          this.sort = c;
      }
    },
    p_ = class {
      constructor() {
        let e = new WeakMap();
        function t(i, n) {
          let a = e.get(i), s;
          return a === void 0
            ? (s = new d_(), e.set(i, [s]))
            : n >= a.length
            ? (s = new d_(), a.push(s))
            : s = a[n],
            s;
        }
        function o() {
          e = new WeakMap();
        }
        this.get = t, this.dispose = o;
      }
    };
  function kse(r, e) {
    return r.groupOrder !== e.groupOrder
      ? r.groupOrder - e.groupOrder
      : r.renderOrder !== e.renderOrder
      ? r.renderOrder - e.renderOrder
      : r.material.id !== e.material.id
      ? r.material.id - e.material.id
      : r.z !== e.z
      ? r.z - e.z
      : r.id - e.id;
  }
  function _se(r, e) {
    return r.groupOrder !== e.groupOrder
      ? r.groupOrder - e.groupOrder
      : r.renderOrder !== e.renderOrder
      ? r.renderOrder - e.renderOrder
      : r.z !== e.z
      ? e.z - r.z
      : r.id - e.id;
  }
  var u_ = class {
    constructor(e) {
      function t() {
        let Q = false, j = new pn(), Ge = null, de = new pn(0, 0, 0, 0);
        return {
          setMask: function (Ye) {
            Ge !== Ye && !Q && (e.colorMask(Ye, Ye, Ye, Ye), Ge = Ye);
          },
          setLocked: function (Ye) {
            Q = Ye;
          },
          setClear: function (Ye, Ve, Qr, st, Bn) {
            Bn === true && (Ye *= st, Ve *= st, Qr *= st),
              j.set(Ye, Ve, Qr, st),
              de.equals(j) === false &&
              (e.clearColor(Ye, Ve, Qr, st), de.copy(j));
          },
          reset: function () {
            Q = false, Ge = null, de.set(-1, 0, 0, 0);
          },
        };
      }
      function o() {
        let Q = false, j = null, Ge = null, de = null;
        return {
          setTest: function (Ye) {
            Ye ? q(e.DEPTH_TEST) : oe(e.DEPTH_TEST);
          },
          setMask: function (Ye) {
            j !== Ye && !Q && (e.depthMask(Ye), j = Ye);
          },
          setFunc: function (Ye) {
            if (Ge !== Ye) {
              switch (Ye) {
                case tW:
                  e.depthFunc(e.NEVER);
                  break;
                case rW:
                  e.depthFunc(e.ALWAYS);
                  break;
                case oW:
                  e.depthFunc(e.LESS);
                  break;
                case $v:
                  e.depthFunc(e.LEQUAL);
                  break;
                case iW:
                  e.depthFunc(e.EQUAL);
                  break;
                case nW:
                  e.depthFunc(e.GEQUAL);
                  break;
                case aW:
                  e.depthFunc(e.GREATER);
                  break;
                case sW:
                  e.depthFunc(e.NOTEQUAL);
                  break;
                default:
                  e.depthFunc(e.LEQUAL);
              }
              Ge = Ye;
            }
          },
          setLocked: function (Ye) {
            Q = Ye;
          },
          setClear: function (Ye) {
            de !== Ye && (e.clearDepth(Ye), de = Ye);
          },
          reset: function () {
            Q = false, j = null, Ge = null, de = null;
          },
        };
      }
      function i() {
        let Q = false,
          j = null,
          Ge = null,
          de = null,
          Ye = null,
          Ve = null,
          Qr = null,
          st = null,
          Bn = null;
        return {
          setTest: function (co) {
            Q || (co ? q(e.STENCIL_TEST) : oe(e.STENCIL_TEST));
          },
          setMask: function (co) {
            j !== co && !Q && (e.stencilMask(co), j = co);
          },
          setFunc: function (co, Vo, Ue) {
            (Ge !== co || de !== Vo || Ye !== Ue) &&
              (e.stencilFunc(co, Vo, Ue), Ge = co, de = Vo, Ye = Ue);
          },
          setOp: function (co, Vo, Ue) {
            (Ve !== co || Qr !== Vo || st !== Ue) &&
              (e.stencilOp(co, Vo, Ue), Ve = co, Qr = Vo, st = Ue);
          },
          setLocked: function (co) {
            Q = co;
          },
          setClear: function (co) {
            Bn !== co && (e.clearStencil(co), Bn = co);
          },
          reset: function () {
            Q = false,
              j = null,
              Ge = null,
              de = null,
              Ye = null,
              Ve = null,
              Qr = null,
              st = null,
              Bn = null;
          },
        };
      }
      let n = t(),
        a = o(),
        s = i(),
        l = new WeakMap(),
        c = new WeakMap(),
        d = {},
        p = {},
        h = new WeakMap(),
        u = [],
        f = null,
        y = false,
        C = null,
        E = null,
        v = null,
        w = null,
        S = null,
        k = null,
        _ = null,
        A = false,
        P = null,
        O = null,
        U = null,
        z = null,
        x = null,
        L = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
        V = false,
        R = 0,
        N = e.getParameter(e.VERSION);
      if (N.indexOf("WebGL") !== -1) {
        let Q = /^WebGL (\d)/.exec(N);
        wt(Q, "webgl version match", e), R = parseFloat(Q[1]), V = R >= 1;
      } else if (N.indexOf("OpenGL ES") !== -1) {
        let Q = /^OpenGL ES (\d)/.exec(N);
        wt(Q, "opengl es version match", e), R = parseFloat(Q[1]), V = R >= 2;
      }
      let M = null,
        F = {},
        Z = e.getParameter(e.SCISSOR_BOX),
        te = e.getParameter(e.VIEWPORT),
        Y = new pn().fromArray(Z),
        he = new pn().fromArray(te);
      function se(Q, j, Ge, de) {
        let Ye = new Uint8Array(4), Ve = e.createTexture();
        e.bindTexture(Q, Ve),
          e.texParameteri(Q, e.TEXTURE_MIN_FILTER, e.NEAREST),
          e.texParameteri(Q, e.TEXTURE_MAG_FILTER, e.NEAREST);
        for (let Qr = 0; Qr < Ge; Qr++) {
          Q === e.TEXTURE_3D || Q === e.TEXTURE_2D_ARRAY
            ? (wt(de, "dimensions"),
              e.texImage3D(
                j,
                0,
                e.RGBA,
                1,
                1,
                de,
                0,
                e.RGBA,
                e.UNSIGNED_BYTE,
                Ye,
              ))
            : e.texImage2D(
              j + Qr,
              0,
              e.RGBA,
              1,
              1,
              0,
              e.RGBA,
              e.UNSIGNED_BYTE,
              Ye,
            );
        }
        return Ve;
      }
      let ae = {
        [e.TEXTURE_2D]: se(e.TEXTURE_2D, e.TEXTURE_2D, 1),
        [e.TEXTURE_CUBE_MAP]: se(
          e.TEXTURE_CUBE_MAP,
          e.TEXTURE_CUBE_MAP_POSITIVE_X,
          6,
        ),
        [e.TEXTURE_2D_ARRAY]: se(
          e.TEXTURE_2D_ARRAY,
          e.TEXTURE_2D_ARRAY,
          1,
          1,
        ),
        [e.TEXTURE_3D]: se(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1),
      };
      n.setClear(0, 0, 0, 1),
        a.setClear(1),
        s.setClear(0),
        q(e.DEPTH_TEST),
        a.setFunc($v),
        $(false),
        W(vV),
        q(e.CULL_FACE),
        _e(wk);
      function q(Q) {
        d[Q] !== true && (e.enable(Q), d[Q] = true);
      }
      function oe(Q) {
        d[Q] !== false && (e.disable(Q), d[Q] = false);
      }
      function K(Q, j) {
        return p[Q] !== j
          ? (e.bindFramebuffer(Q, j),
            p[Q] = j,
            Q === e.DRAW_FRAMEBUFFER && (p[e.FRAMEBUFFER] = j),
            Q === e.FRAMEBUFFER && (p[e.DRAW_FRAMEBUFFER] = j),
            true)
          : false;
      }
      function fe(Q, j) {
        let Ge = u, de = false;
        Q
          ? (wt(j, "framebuffer", e),
            Ge = h.get(j),
            Ge === void 0 && (Ge = [], h.set(j, Ge)),
            Ge[0] !== e.COLOR_ATTACHMENT0 &&
            (Ge[0] = e.COLOR_ATTACHMENT0, de = true))
          : Ge[0] !== e.BACK && (Ge[0] = e.BACK, de = true),
          de && e.drawBuffers(Ge);
      }
      function me(Q) {
        return f !== Q
          ? (wt(Q, "program", e), e.useProgram(Q), f = Q, true)
          : false;
      }
      let we = {
          [Od]: e.FUNC_ADD,
          [H6]: e.FUNC_SUBTRACT,
          [K6]: e.FUNC_REVERSE_SUBTRACT,
          [W6]: e.MIN,
          [$6]: e.MAX,
        },
        Ce = {
          [Ck]: e.ZERO,
          [Sk]: e.ONE,
          [j6]: e.SRC_COLOR,
          [Ek]: e.SRC_ALPHA,
          [eW]: e.SRC_ALPHA_SATURATE,
          [Q6]: e.DST_COLOR,
          [X6]: e.DST_ALPHA,
          [Y6]: e.ONE_MINUS_SRC_COLOR,
          [Tk]: e.ONE_MINUS_SRC_ALPHA,
          [Z6]: e.ONE_MINUS_DST_COLOR,
          [J6]: e.ONE_MINUS_DST_ALPHA,
        };
      function _e(Q, j, Ge, de, Ye, Ve, Qr, st) {
        if (Q === wk) {
          y === true && (oe(e.BLEND), y = false);
          return;
        }
        if (y === false && (q(e.BLEND), y = true), Q !== vk) {
          if (Q !== C || st !== A) {
            if (
              (E !== Od || S !== Od) &&
              (e.blendEquation(e.FUNC_ADD), E = Od, S = Od), st
            ) {
              switch (Q) {
                case hh:
                  e.blendFuncSeparate(
                    e.ONE,
                    e.ONE_MINUS_SRC_ALPHA,
                    e.ONE,
                    e.ONE_MINUS_SRC_ALPHA,
                  );
                  break;
                case CV:
                  e.blendFunc(e.ONE, e.ONE);
                  break;
                case SV:
                  e.blendFuncSeparate(
                    e.ZERO,
                    e.ONE_MINUS_SRC_COLOR,
                    e.ZERO,
                    e.ONE,
                  );
                  break;
                case EV:
                  e.blendFuncSeparate(
                    e.ZERO,
                    e.SRC_COLOR,
                    e.ZERO,
                    e.SRC_ALPHA,
                  );
                  break;
                default:
                  console.error(
                    "THREE.WebGLState: Invalid blending: ",
                    Q,
                  );
                  break;
              }
            } else {switch (Q) {
                case hh:
                  e.blendFuncSeparate(
                    e.SRC_ALPHA,
                    e.ONE_MINUS_SRC_ALPHA,
                    e.ONE,
                    e.ONE_MINUS_SRC_ALPHA,
                  );
                  break;
                case CV:
                  e.blendFunc(e.SRC_ALPHA, e.ONE);
                  break;
                case SV:
                  e.blendFuncSeparate(
                    e.ZERO,
                    e.ONE_MINUS_SRC_COLOR,
                    e.ZERO,
                    e.ONE,
                  );
                  break;
                case EV:
                  e.blendFunc(e.ZERO, e.SRC_COLOR);
                  break;
                default:
                  console.error(
                    "THREE.WebGLState: Invalid blending: ",
                    Q,
                  );
                  break;
              }}
            v = null, w = null, k = null, _ = null, C = Q, A = st;
          }
          return;
        }
        Ye = Ye || j,
          Ve = Ve || Ge,
          Qr = Qr || de,
          (j !== E || Ye !== S) &&
          (wt(j, "blendEquation"),
            wt(Ye, "blendEquationAlpha"),
            e.blendEquationSeparate(we[j], we[Ye]),
            E = j,
            S = Ye),
          (Ge !== v || de !== w || Ve !== k || Qr !== _) &&
          (wt(Ge, "blendSrc"),
            wt(de, "blendDst"),
            wt(Ve, "blendSrcAlpha"),
            wt(Qr, "blendDstAlpha"),
            e.blendFuncSeparate(Ce[Ge], Ce[de], Ce[Ve], Ce[Qr]),
            v = Ge,
            w = de,
            k = Ve,
            _ = Qr),
          C = Q,
          A = false;
      }
      function We(Q, j) {
        Q.side === ua ? oe(e.CULL_FACE) : q(e.CULL_FACE);
        let Ge = Q.side === lm;
        j && (Ge = !Ge),
          $(Ge),
          Q.blending === hh && Q.transparent === false ? _e(wk) : _e(
            Q.blending,
            Q.blendEquation,
            Q.blendSrc,
            Q.blendDst,
            Q.blendEquationAlpha,
            Q.blendSrcAlpha,
            Q.blendDstAlpha,
            Q.premultipliedAlpha,
          ),
          a.setFunc(Q.depthFunc),
          a.setTest(Q.depthTest),
          a.setMask(Q.depthWrite),
          n.setMask(Q.colorWrite);
        let de = Q.stencilWrite;
        s.setTest(de),
          de &&
          (s.setMask(Q.stencilWriteMask),
            s.setFunc(Q.stencilFunc, Q.stencilRef, Q.stencilFuncMask),
            s.setOp(Q.stencilFail, Q.stencilZFail, Q.stencilZPass)),
          Ee(
            Q.polygonOffset,
            Q.polygonOffsetFactor,
            Q.polygonOffsetUnits,
          ),
          Q.alphaToCoverage === true
            ? q(e.SAMPLE_ALPHA_TO_COVERAGE)
            : oe(e.SAMPLE_ALPHA_TO_COVERAGE);
      }
      function $(Q) {
        P !== Q && (Q ? e.frontFace(e.CW) : e.frontFace(e.CCW), P = Q);
      }
      function W(Q) {
        Q !== z6
          ? (q(e.CULL_FACE),
            Q !== O &&
            (Q === vV
              ? e.cullFace(e.BACK)
              : Q === q6
              ? e.cullFace(e.FRONT)
              : e.cullFace(e.FRONT_AND_BACK)))
          : oe(e.CULL_FACE), O = Q;
      }
      function ue(Q) {
        Q !== U && (V && e.lineWidth(Q), U = Q);
      }
      function Ee(Q, j, Ge) {
        Q
          ? (q(e.POLYGON_OFFSET_FILL),
            (z !== j || x !== Ge) &&
            (wt(j, "factor"),
              wt(Ge, "units"),
              e.polygonOffset(j, Ge),
              z = j,
              x = Ge))
          : oe(e.POLYGON_OFFSET_FILL);
      }
      function Be(Q) {
        Q ? q(e.SCISSOR_TEST) : oe(e.SCISSOR_TEST);
      }
      function ce(Q) {
        Q === void 0 && (Q = e.TEXTURE0 + L - 1),
          M !== Q && (e.activeTexture(Q), M = Q);
      }
      function ot(Q, j, Ge) {
        Ge === void 0 && (M === null ? Ge = e.TEXTURE0 + L - 1 : Ge = M);
        let de = F[Ge];
        de === void 0 &&
        (de = { type: void 0, texture: void 0 }, F[Ge] = de),
          (de.type !== Q || de.texture !== j) &&
          (M !== Ge && (e.activeTexture(Ge), M = Ge),
            e.bindTexture(Q, j || ae[Q]),
            de.type = Q,
            de.texture = j);
      }
      function it() {
        if (M === null) {
          throw new Error(
            "THREE.WebGLState: Trying to unbind a texture that was never bound",
          );
        }
        let Q = F[M];
        Q !== void 0 && Q.type !== void 0 &&
          (e.bindTexture(Q.type, null), Q.type = void 0, Q.texture = void 0);
      }
      this.compressedTexImage2D = function () {
        try {
          e.compressedTexImage2D.apply(e, arguments);
        } catch (j) {
          console.error("THREE.WebGLState:", j);
        }
      },
        this.compressedTexImage3D = function () {
          try {
            e.compressedTexImage3D.apply(e, arguments);
          } catch (j) {
            console.error("THREE.WebGLState:", j);
          }
        },
        this.texSubImage2D = function () {
          try {
            e.texSubImage2D.apply(e, arguments);
          } catch (j) {
            console.error("THREE.WebGLState:", j);
          }
        },
        this.texSubImage3D = function () {
          try {
            e.texSubImage3D.apply(e, arguments);
          } catch (j) {
            console.error("THREE.WebGLState:", j);
          }
        },
        this.compressedTexSubImage2D = function () {
          try {
            e.compressedTexSubImage2D.apply(e, arguments);
          } catch (j) {
            console.error("THREE.WebGLState:", j);
          }
        },
        this.compressedTexSubImage3D = function () {
          try {
            e.compressedTexSubImage3D.apply(e, arguments);
          } catch (j) {
            console.error("THREE.WebGLState:", j);
          }
        },
        this.texStorage2D = function () {
          try {
            e.texStorage2D.apply(e, arguments);
          } catch (j) {
            console.error("THREE.WebGLState:", j);
          }
        },
        this.texStorage3D = function () {
          try {
            e.texStorage3D.apply(e, arguments);
          } catch (j) {
            console.error("THREE.WebGLState:", j);
          }
        },
        this.texImage2D = function () {
          try {
            e.texImage2D.apply(e, arguments);
          } catch (j) {
            console.error("THREE.WebGLState:", j);
          }
        },
        this.texImage3D = function () {
          try {
            e.texImage3D.apply(e, arguments);
          } catch (j) {
            console.error("THREE.WebGLState:", j);
          }
        };
      function Se(Q) {
        Y.equals(Q) === false && (e.scissor(Q.x, Q.y, Q.z, Q.w), Y.copy(Q));
      }
      function Lt(Q) {
        he.equals(Q) === false &&
          (e.viewport(Q.x, Q.y, Q.z, Q.w), he.copy(Q));
      }
      function It(Q, j) {
        let Ge = c.get(j);
        Ge === void 0 && (Ge = new WeakMap(), c.set(j, Ge));
        let de = Ge.get(Q);
        de === void 0 &&
          (de = e.getUniformBlockIndex(j, Q.name), Ge.set(Q, de));
      }
      function Dt(Q, j) {
        let de = c.get(j).get(Q);
        l.get(j) !== de &&
          (e.uniformBlockBinding(j, de, Q.__bindingPointIndex), l.set(j, de));
      }
      function Mr() {
        e.disable(e.BLEND),
          e.disable(e.CULL_FACE),
          e.disable(e.DEPTH_TEST),
          e.disable(e.POLYGON_OFFSET_FILL),
          e.disable(e.SCISSOR_TEST),
          e.disable(e.STENCIL_TEST),
          e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
          e.blendEquation(e.FUNC_ADD),
          e.blendFunc(e.ONE, e.ZERO),
          e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
          e.colorMask(true, true, true, true),
          e.clearColor(0, 0, 0, 0),
          e.depthMask(true),
          e.depthFunc(e.LESS),
          e.clearDepth(1),
          e.stencilMask(4294967295),
          e.stencilFunc(e.ALWAYS, 0, 4294967295),
          e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
          e.clearStencil(0),
          e.cullFace(e.BACK),
          e.frontFace(e.CCW),
          e.polygonOffset(0, 0),
          e.activeTexture(e.TEXTURE0),
          e.bindFramebuffer(e.FRAMEBUFFER, null),
          e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
          e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
          e.useProgram(null),
          e.lineWidth(1),
          e.scissor(0, 0, e.canvas.width, e.canvas.height),
          e.viewport(0, 0, e.canvas.width, e.canvas.height),
          d = {},
          M = null,
          F = {},
          p = {},
          h = new WeakMap(),
          u = [],
          f = null,
          y = false,
          C = null,
          E = null,
          v = null,
          w = null,
          S = null,
          k = null,
          _ = null,
          A = false,
          P = null,
          O = null,
          U = null,
          z = null,
          x = null,
          Y.set(0, 0, e.canvas.width, e.canvas.height),
          he.set(0, 0, e.canvas.width, e.canvas.height),
          n.reset(),
          a.reset(),
          s.reset();
      }
      this.buffers = { color: n, depth: a, stencil: s },
        this.enable = q,
        this.disable = oe,
        this.bindFramebuffer = K,
        this.drawBuffers = fe,
        this.useProgram = me,
        this.setBlending = _e,
        this.setMaterial = We,
        this.setFlipSided = $,
        this.setCullFace = W,
        this.setLineWidth = ue,
        this.setPolygonOffset = Ee,
        this.setScissorTest = Be,
        this.activeTexture = ce,
        this.bindTexture = ot,
        this.unbindTexture = it,
        this.updateUBOMapping = It,
        this.uniformBlockBinding = Dt,
        this.scissor = Se,
        this.viewport = Lt,
        this.reset = Mr;
    }
  };
  var mm = class extends Bs {
    constructor(t, o, i, n, a, s, l, c, d, p) {
      if (p = p !== void 0 ? p : Yp, p !== Yp && p !== gh) {
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
        );
      }
      i === void 0 && p === Yp && (i = Ac),
        i === void 0 && p === gh && (i = Fd);
      let h = new Bd(t, o);
      super(h, n, a, s, l, c, p, i, d);
      this.isDepthTexture = true;
      this.isDepthTexture = true,
        this.image = h,
        this.magFilter = l !== void 0 ? l : Rd,
        this.minFilter = c !== void 0 ? c : Rd,
        this.flipY = false,
        this.generateMipmaps = false,
        this.compareFunction = null;
    }
    copy(t) {
      return super.copy(t), this.compareFunction = t.compareFunction, this;
    }
  };
  var h_ = class {
    constructor(e, t, o, i, n, a, s) {
      let l = n.maxTextures,
        c = n.maxTextureSize,
        d = n.maxSamples,
        p = t.has("WEBGL_multisampled_render_to_texture")
          ? t.get("WEBGL_multisampled_render_to_texture")
          : null,
        h = typeof navigator == "undefined"
          ? false
          : /OculusBrowser/g.test(navigator.userAgent),
        u,
        f = new WeakMap(),
        y = false;
      try {
        y = typeof OffscreenCanvas != "undefined" &&
          new OffscreenCanvas(1, 1).getContext("2d") !== null;
      } catch ($) {}
      function C($, W) {
        return y ? new OffscreenCanvas($, W) : Bk("canvas");
      }
      function E($, W) {
        let ue = 1;
        if (
          ($.width > W || $.height > W) &&
          (ue = W / Math.max($.width, $.height)), ue < 1
        ) {
          if (
            typeof HTMLImageElement != "undefined" &&
              $ instanceof HTMLImageElement ||
            typeof HTMLCanvasElement != "undefined" &&
              $ instanceof HTMLCanvasElement ||
            typeof ImageBitmap != "undefined" && $ instanceof ImageBitmap
          ) {
            let Ee = Math.floor(ue * $.width),
              Be = Math.floor(ue * $.height);
            u === void 0 && (u = C(Ee, Be)), u.width = Ee, u.height = Be;
            let ce = u.getContext("2d");
            if (
              wt(ce, "2d context"),
                !(ce instanceof OffscreenCanvasRenderingContext2D ||
                  ce instanceof CanvasRenderingContext2D)
            ) throw new Error("Expected a 2d rendering context");
            return ce.drawImage($, 0, 0, Ee, Be),
              console.warn(
                "THREE.WebGLRenderer: Texture has been resized from (" +
                  $.width + "x" + $.height + ") to (" + Ee + "x" + Be +
                  ").",
              ),
              u;
          } else {return "data" in $ &&
              console.warn(
                "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  $.width + "x" + $.height + ").",
              ),
              $;}
        }
        return $;
      }
      function v($) {
        return wV($.width) && wV($.height);
      }
      function w($) {
        return $.generateMipmaps && $.minFilter !== Rd &&
          $.minFilter !== ml;
      }
      function S($) {
        e.generateMipmap($);
      }
      function k($, W, ue, Ee, Be = false) {
        if ($ !== null) {
          if (e[$] !== void 0) return e[$];
          console.warn(
            "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
              $ + "'",
          );
        }
        let ce = W;
        return W === e.RED &&
          (ue === e.FLOAT && (ce = e.R32F),
            ue === e.HALF_FLOAT && (ce = e.R16F),
            ue === e.UNSIGNED_BYTE && (ce = e.R8)),
          W === e.RED_INTEGER &&
          (ue === e.UNSIGNED_BYTE && (ce = e.R8UI),
            ue === e.UNSIGNED_SHORT && (ce = e.R16UI),
            ue === e.UNSIGNED_INT && (ce = e.R32UI),
            ue === e.BYTE && (ce = e.R8I),
            ue === e.SHORT && (ce = e.R16I),
            ue === e.INT && (ce = e.R32I)),
          W === e.RG &&
          (ue === e.FLOAT && (ce = e.RG32F),
            ue === e.HALF_FLOAT && (ce = e.RG16F),
            ue === e.UNSIGNED_BYTE && (ce = e.RG8)),
          W === e.RGBA &&
          (ue === e.FLOAT && (ce = e.RGBA32F),
            ue === e.HALF_FLOAT && (ce = e.RGBA16F),
            ue === e.UNSIGNED_BYTE &&
            (ce = Ee === Lo && Be === false ? e.SRGB8_ALPHA8 : e.RGBA8),
            ue === e.UNSIGNED_SHORT_4_4_4_4 && (ce = e.RGBA4),
            ue === e.UNSIGNED_SHORT_5_5_5_1 && (ce = e.RGB5_A1)),
          (ce === e.R16F || ce === e.R32F || ce === e.RG16F ||
            ce === e.RG32F || ce === e.RGBA16F || ce === e.RGBA32F) &&
          t.get("EXT_color_buffer_float"),
          ce;
      }
      function _($, W) {
        return w($) === true
          ? Math.log2(Math.max(W.width, W.height)) + 1
          : $.mipmaps !== void 0 && $.mipmaps.length > 0
          ? $.mipmaps.length
          : 1;
      }
      function A($) {
        let W = $.target;
        W.removeEventListener("dispose", A), O(W);
      }
      function P($) {
        let W = $.target;
        W.removeEventListener("dispose", P), z(W);
      }
      function O($) {
        let W = i.get($);
        if (W.__webglInit === void 0) return;
        let ue = $.source, Ee = f.get(ue);
        if (Ee) {
          let Be = Ee[W.__cacheKey];
          Be.usedTimes--,
            Be.usedTimes === 0 && U($),
            Object.keys(Ee).length === 0 && f.delete(ue);
        }
        i.remove($);
      }
      function U($) {
        let W = i.get($);
        e.deleteTexture(W.__webglTexture);
        let ue = $.source, Ee = f.get(ue);
        wt(Ee, "webglTextures"), delete Ee[W.__cacheKey], s.memory.textures--;
      }
      function z($) {
        let W = $.texture, ue = i.get($), Ee = i.get(W);
        Ee.__webglTexture !== void 0 &&
        (e.deleteTexture(Ee.__webglTexture), s.memory.textures--),
          $.depthTexture && $.depthTexture.dispose();
        let Be = ue.__webglFramebuffer;
        if (Array.isArray(Be)) {
          for (let ce = 0; ce < Be.length; ce++) {
            e.deleteFramebuffer(Be[ce]);
          }
        } else Be && e.deleteFramebuffer(Be);
        if (
          ue.__webglDepthbuffer &&
          e.deleteRenderbuffer(ue.__webglDepthbuffer),
            ue.__webglMultisampledFramebuffer &&
            e.deleteFramebuffer(ue.__webglMultisampledFramebuffer),
            ue.__webglColorRenderbuffer
        ) {
          for (
            let ce = 0;
            ce < ue.__webglColorRenderbuffer.length;
            ce++
          ) {
            ue.__webglColorRenderbuffer[ce] &&
              e.deleteRenderbuffer(ue.__webglColorRenderbuffer[ce]);
          }
        }
        ue.__webglDepthRenderbuffer &&
        e.deleteRenderbuffer(ue.__webglDepthRenderbuffer),
          i.remove(W),
          i.remove($);
      }
      let x = 0;
      function L() {
        x = 0;
      }
      function V() {
        let $ = x;
        return $ >= l &&
          console.warn(
            "THREE.WebGLTextures: Trying to use " + $ +
              " texture units while this GPU supports only " + l,
          ),
          x += 1,
          $;
      }
      function R($) {
        let W = [];
        return W.push($.wrapS),
          W.push($.wrapT),
          W.push($.magFilter),
          W.push($.minFilter),
          W.push($.anisotropy),
          W.push($.internalFormat),
          W.push($.format),
          W.push($.type),
          W.push($.generateMipmaps),
          W.push($.premultiplyAlpha),
          W.push($.flipY),
          W.push($.unpackAlignment),
          W.push($.colorSpace),
          W.join();
      }
      function N($, W) {
        let ue = i.get($);
        if (
          $.isRenderTargetTexture === false && $.version > 0 &&
          ue.__version !== $.version
        ) {
          if ($.image.complete === false) {
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
            );
          } else {
            he(ue, $, W);
            return;
          }
        }
        o.bindTexture(e.TEXTURE_2D, ue.__webglTexture, e.TEXTURE0 + W);
      }
      let M = {
          [jv]: e.REPEAT,
          [cm]: e.CLAMP_TO_EDGE,
          [Yv]: e.MIRRORED_REPEAT,
        },
        F = {
          [Rd]: e.NEAREST,
          [lW]: e.NEAREST_MIPMAP_NEAREST,
          [DV]: e.NEAREST_MIPMAP_LINEAR,
          [ml]: e.LINEAR,
          [cW]: e.LINEAR_MIPMAP_NEAREST,
          [Xv]: e.LINEAR_MIPMAP_LINEAR,
        },
        Z = {
          [xW]: e.NEVER,
          [DW]: e.ALWAYS,
          [wW]: e.LESS,
          [CW]: e.LEQUAL,
          [vW]: e.EQUAL,
          [TW]: e.GEQUAL,
          [SW]: e.GREATER,
          [EW]: e.NOTEQUAL,
        };
      function te($, W) {
        if (
          e.texParameteri($, e.TEXTURE_WRAP_S, M[W.wrapS]),
            e.texParameteri($, e.TEXTURE_WRAP_T, M[W.wrapT]),
            e.texParameteri($, e.TEXTURE_MAG_FILTER, F[W.magFilter]),
            e.texParameteri($, e.TEXTURE_MIN_FILTER, F[W.minFilter]),
            W.compareFunction &&
            (e.texParameteri(
              $,
              e.TEXTURE_COMPARE_MODE,
              e.COMPARE_REF_TO_TEXTURE,
            ),
              e.texParameteri(
                $,
                e.TEXTURE_COMPARE_FUNC,
                Z[W.compareFunction],
              )),
            t.has("EXT_texture_filter_anisotropic") === true
        ) {
          let ue = t.get("EXT_texture_filter_anisotropic");
          if (
            W.magFilter === Rd ||
            W.minFilter !== DV && W.minFilter !== Xv ||
            W.type === Xl && t.has("OES_texture_float_linear") === false
          ) return;
          (W.anisotropy > 1 || i.get(W).__currentAnisotropy) &&
            (e.texParameterf(
              $,
              ue.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(W.anisotropy, n.getMaxAnisotropy()),
            ),
              i.get(W).__currentAnisotropy = W.anisotropy);
        }
      }
      function Y($, W) {
        let ue = false;
        $.__webglInit === void 0 &&
          ($.__webglInit = true, W.addEventListener("dispose", A));
        let Ee = W.source, Be = f.get(Ee);
        Be === void 0 && (Be = {}, f.set(Ee, Be));
        let ce = R(W);
        if (ce !== $.__cacheKey) {
          Be[ce] === void 0 &&
          (Be[ce] = {
            texture: e.createTexture() || void 0,
            usedTimes: 0,
          },
            s.memory.textures++,
            ue = true), Be[ce].usedTimes++;
          let ot = $.__cacheKey ? Be[$.__cacheKey] : void 0;
          ot !== void 0 &&
          (Be[$.__cacheKey].usedTimes--, ot.usedTimes === 0 && U(W)),
            $.__cacheKey = ce,
            $.__webglTexture = Be[ce].texture;
        }
        return ue;
      }
      function he($, W, ue) {
        let Ee = e.TEXTURE_2D, Be = Y($, W), ce = W.source;
        o.bindTexture(Ee, $.__webglTexture, e.TEXTURE0 + ue);
        let ot = i.get(ce);
        if (ce.version !== ot.__version || Be === true) {
          o.activeTexture(e.TEXTURE0 + ue),
            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, W.flipY),
            e.pixelStorei(
              e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              W.premultiplyAlpha,
            ),
            e.pixelStorei(e.UNPACK_ALIGNMENT, W.unpackAlignment),
            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE);
          let it = E(W.image, c);
          it = We(W, it);
          let Se = v(it),
            Lt = a.convert(W.format, W.colorSpace),
            It = a.convert(W.type),
            Dt = k(W.internalFormat, Lt, It, W.colorSpace);
          te(Ee, W);
          let Mr,
            Q = W.mipmaps,
            j = ot.__version === void 0 || Be === true,
            Ge = _(W, it);
          if (W instanceof mm) {
            Dt = e.DEPTH_COMPONENT,
              W.type === Xl
                ? Dt = e.DEPTH_COMPONENT32F
                : W.type === Ac
                ? Dt = e.DEPTH_COMPONENT24
                : W.type === Fd
                ? Dt = e.DEPTH24_STENCIL8
                : Dt = e.DEPTH_COMPONENT16,
              W.format === Yp && Dt === e.DEPTH_COMPONENT &&
              W.type !== Cy && W.type !== Ac &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.",
              ),
                W.type = Ac,
                It = a.convert(W.type)),
              W.format === gh && Dt === e.DEPTH_COMPONENT &&
              (Dt = e.DEPTH_STENCIL,
                W.type !== Fd &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.",
                ),
                  W.type = Fd,
                  It = a.convert(W.type))),
              j &&
              o.texStorage2D(e.TEXTURE_2D, 1, Dt, it.width, it.height);
          } else if (Q.length > 0 && Se) {
            j &&
              o.texStorage2D(
                e.TEXTURE_2D,
                Ge,
                Dt,
                Q[0].width,
                Q[0].height,
              );
            for (let de = 0, Ye = Q.length; de < Ye; de++) {
              Mr = Q[de], o.texSubImage2D(e.TEXTURE_2D, de, 0, 0, Lt, It, Mr);
            }
            W.generateMipmaps = false;
          } else {
            if (
              j &&
              o.texStorage2D(e.TEXTURE_2D, Ge, Dt, it.width, it.height),
                it instanceof Bd
            ) {
              throw new Error(
                "Texture does not have any image data to upload.",
              );
            }
            o.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, Lt, It, it);
          }
          w(W) && S(Ee), ot.__version = ce.version, W.onUpdate && W.onUpdate(W);
        }
        $.__version = W.version;
      }
      function se($, W, ue, Ee, Be, ce) {
        if (!$ || Array.isArray($)) {
          throw new Error(
            "THREE.WebGLTextures: expected non-array framebuffer",
          );
        }
        let ot = a.convert(ue.format, ue.colorSpace),
          it = a.convert(ue.type),
          Se = k(ue.internalFormat, ot, it, ue.colorSpace);
        if (!i.get(W).__hasExternalTextures) {
          let It = Math.max(1, W.width >> ce),
            Dt = Math.max(1, W.height >> ce);
          o.texImage2D(Be, ce, Se, It, Dt, 0, ot, it, null);
        }
        if (o.bindFramebuffer(e.FRAMEBUFFER, $), _e(W)) {
          p.framebufferTexture2DMultisampleEXT(
            e.FRAMEBUFFER,
            Ee,
            Be,
            i.get(ue).__webglTexture,
            0,
            Ce(W),
          );
        } else if (
          Be === e.TEXTURE_2D ||
          Be >= e.TEXTURE_CUBE_MAP_POSITIVE_X &&
            Be <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z
        ) {
          let It = i.get(ue).__webglTexture;
          wt(It, "webglTexture"),
            e.framebufferTexture2D(e.FRAMEBUFFER, Ee, Be, It, ce);
        }
        o.bindFramebuffer(e.FRAMEBUFFER, null);
      }
      function ae($, W, ue) {
        if (
          e.bindRenderbuffer(e.RENDERBUFFER, $ || null),
            W.depthBuffer && !W.stencilBuffer
        ) {
          let Ee = e.DEPTH_COMPONENT16;
          if (ue || _e(W)) {
            let Be = W.depthTexture;
            Be && Be.isDepthTexture &&
              (Be.type === Xl
                ? Ee = e.DEPTH_COMPONENT32F
                : Be.type === Ac && (Ee = e.DEPTH_COMPONENT24));
            let ce = Ce(W);
            _e(W)
              ? p.renderbufferStorageMultisampleEXT(
                e.RENDERBUFFER,
                ce,
                Ee,
                W.width,
                W.height,
              )
              : e.renderbufferStorageMultisample(
                e.RENDERBUFFER,
                ce,
                Ee,
                W.width,
                W.height,
              );
          } else {e.renderbufferStorage(
              e.RENDERBUFFER,
              Ee,
              W.width,
              W.height,
            );}
          e.framebufferRenderbuffer(
            e.FRAMEBUFFER,
            e.DEPTH_ATTACHMENT,
            e.RENDERBUFFER,
            $ || null,
          );
        } else if (W.depthBuffer && W.stencilBuffer) {
          let Ee = Ce(W);
          ue && _e(W) === false
            ? e.renderbufferStorageMultisample(
              e.RENDERBUFFER,
              Ee,
              e.DEPTH24_STENCIL8,
              W.width,
              W.height,
            )
            : _e(W)
            ? p.renderbufferStorageMultisampleEXT(
              e.RENDERBUFFER,
              Ee,
              e.DEPTH24_STENCIL8,
              W.width,
              W.height,
            )
            : e.renderbufferStorage(
              e.RENDERBUFFER,
              e.DEPTH_STENCIL,
              W.width,
              W.height,
            ),
            e.framebufferRenderbuffer(
              e.FRAMEBUFFER,
              e.DEPTH_STENCIL_ATTACHMENT,
              e.RENDERBUFFER,
              $ || null,
            );
        } else {
          let Ee = [W.texture];
          for (let Be = 0; Be < Ee.length; Be++) {
            let ce = Ee[Be],
              ot = a.convert(ce.format, ce.colorSpace),
              it = a.convert(ce.type),
              Se = k(ce.internalFormat, ot, it, ce.colorSpace),
              Lt = Ce(W);
            ue && _e(W) === false
              ? e.renderbufferStorageMultisample(
                e.RENDERBUFFER,
                Lt,
                Se,
                W.width,
                W.height,
              )
              : _e(W)
              ? p.renderbufferStorageMultisampleEXT(
                e.RENDERBUFFER,
                Lt,
                Se,
                W.width,
                W.height,
              )
              : e.renderbufferStorage(
                e.RENDERBUFFER,
                Se,
                W.width,
                W.height,
              );
          }
        }
        e.bindRenderbuffer(e.RENDERBUFFER, null);
      }
      function q($, W) {
        if (
          o.bindFramebuffer(e.FRAMEBUFFER, $),
            !(W.depthTexture && W.depthTexture.isDepthTexture)
        ) {
          throw new Error(
            "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
          );
        }
        (!i.get(W.depthTexture).__webglTexture ||
          W.depthTexture.image.width !== W.width ||
          W.depthTexture.image.height !== W.height) &&
        (W.depthTexture.image.width = W.width,
          W.depthTexture.image.height = W.height,
          W.depthTexture.needsUpdate = true), N(W.depthTexture, 0);
        let ue = i.get(W.depthTexture).__webglTexture;
        wt(ue, "webglDepthTexture");
        let Ee = Ce(W);
        if (W.depthTexture.format === Yp) {
          _e(W)
            ? p.framebufferTexture2DMultisampleEXT(
              e.FRAMEBUFFER,
              e.DEPTH_ATTACHMENT,
              e.TEXTURE_2D,
              ue,
              0,
              Ee,
            )
            : e.framebufferTexture2D(
              e.FRAMEBUFFER,
              e.DEPTH_ATTACHMENT,
              e.TEXTURE_2D,
              ue,
              0,
            );
        } else if (W.depthTexture.format === gh) {
          _e(W)
            ? p.framebufferTexture2DMultisampleEXT(
              e.FRAMEBUFFER,
              e.DEPTH_STENCIL_ATTACHMENT,
              e.TEXTURE_2D,
              ue,
              0,
              Ee,
            )
            : e.framebufferTexture2D(
              e.FRAMEBUFFER,
              e.DEPTH_STENCIL_ATTACHMENT,
              e.TEXTURE_2D,
              ue,
              0,
            );
        } else throw new Error("Unknown depthTexture format");
      }
      function oe($) {
        let W = i.get($), ue = gO(W);
        $.depthTexture && !W.__autoAllocateDepthBuffer
          ? q(ue, $)
          : (o.bindFramebuffer(e.FRAMEBUFFER, ue),
            W.__webglDepthbuffer = e.createRenderbuffer() || void 0,
            ae(W.__webglDepthbuffer, $, false)),
          o.bindFramebuffer(e.FRAMEBUFFER, null);
      }
      function K($, W, ue) {
        let Ee = i.get($), Be = gO(Ee);
        W !== void 0 &&
        se(Be, $, $.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
          ue !== void 0 && oe($);
      }
      function fe($) {
        let W = $.texture, ue = i.get($), Ee = i.get(W);
        if (
          $.addEventListener("dispose", P),
            Ee.__webglTexture === void 0 &&
            (Ee.__webglTexture = e.createTexture() || void 0),
            Ee.__version = W.version,
            s.memory.textures++,
            W.mipmaps && W.mipmaps.length > 0
        ) {
          let ce = [];
          ue.__webglFramebuffer = ce;
          for (let ot = 0; ot < W.mipmaps.length; ot++) {
            let it = e.createFramebuffer();
            wt(it, "framebuffer", e), ce[ot] = it;
          }
        } else {
          let ce = e.createFramebuffer();
          ue.__webglFramebuffer = ce || void 0;
        }
        if ($.samples > 0 && _e($) === false) {
          let ce = [W], ot = e.createFramebuffer();
          wt(ot, "framebuffer", e),
            ue.__webglMultisampledFramebuffer = ot,
            ue.__webglColorRenderbuffer = [],
            o.bindFramebuffer(
              e.FRAMEBUFFER,
              ue.__webglMultisampledFramebuffer,
            );
          for (let it = 0; it < ce.length; it++) {
            let Se = ce[it], Lt = e.createRenderbuffer();
            wt(Lt, "renderbuffer", e),
              ue.__webglColorRenderbuffer[it] = Lt,
              e.bindRenderbuffer(
                e.RENDERBUFFER,
                ue.__webglColorRenderbuffer[it],
              );
            let It = a.convert(Se.format, Se.colorSpace),
              Dt = a.convert(Se.type),
              Mr = k(Se.internalFormat, It, Dt, Se.colorSpace, false),
              Q = Ce($);
            e.renderbufferStorageMultisample(
              e.RENDERBUFFER,
              Q,
              Mr,
              $.width,
              $.height,
            ),
              e.framebufferRenderbuffer(
                e.FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + it,
                e.RENDERBUFFER,
                ue.__webglColorRenderbuffer[it],
              );
          }
          if (e.bindRenderbuffer(e.RENDERBUFFER, null), $.depthBuffer) {
            let it = e.createRenderbuffer();
            wt(it, "renderbuffer", e),
              ue.__webglDepthRenderbuffer = it,
              ae(ue.__webglDepthRenderbuffer, $, true);
          }
          o.bindFramebuffer(e.FRAMEBUFFER, null);
        }
        let Be = e.TEXTURE_2D;
        if (
          o.bindTexture(Be, Ee.__webglTexture),
            te(Be, W),
            W.mipmaps && W.mipmaps.length > 0
        ) {
          let ce = Ise(ue);
          for (let ot = 0; ot < W.mipmaps.length; ot++) {
            se(ce[ot], $, W, e.COLOR_ATTACHMENT0, Be, ot);
          }
        } else {se(
            ue.__webglFramebuffer,
            $,
            W,
            e.COLOR_ATTACHMENT0,
            Be,
            0,
          );}
        w(W) && S(Be), o.unbindTexture(), $.depthBuffer && oe($);
      }
      function me($) {
        let W = [$.texture];
        for (let ue = 0, Ee = W.length; ue < Ee; ue++) {
          let Be = W[ue];
          if (w(Be)) {
            let ce = e.TEXTURE_2D, ot = i.get(Be).__webglTexture;
            o.bindTexture(ce, ot), S(ce), o.unbindTexture();
          }
        }
      }
      function we($) {
        if ($.samples > 0 && _e($) === false) {
          let W = [$.texture],
            ue = $.width,
            Ee = $.height,
            Be = e.COLOR_BUFFER_BIT,
            ce = [],
            ot = $.stencilBuffer
              ? e.DEPTH_STENCIL_ATTACHMENT
              : e.DEPTH_ATTACHMENT,
            it = i.get($);
          wt(
            it.__webglMultisampledFramebuffer,
            "__webglMultisampledFramebuffer",
          ),
            o.bindFramebuffer(
              e.READ_FRAMEBUFFER,
              it.__webglMultisampledFramebuffer,
            ),
            o.bindFramebuffer(e.DRAW_FRAMEBUFFER, gO(it));
          for (let Se = 0; Se < W.length; Se++) {
            ce.push(e.COLOR_ATTACHMENT0 + Se), $.depthBuffer && ce.push(ot);
            let Lt = it.__ignoreDepthValues !== void 0
              ? it.__ignoreDepthValues
              : false;
            Lt === false &&
            ($.depthBuffer && (Be |= e.DEPTH_BUFFER_BIT),
              $.stencilBuffer && (Be |= e.STENCIL_BUFFER_BIT)),
              Lt === true &&
              (e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [ot]),
                e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [ot])),
              e.blitFramebuffer(
                0,
                0,
                ue,
                Ee,
                0,
                0,
                ue,
                Ee,
                Be,
                e.NEAREST,
              ),
              h && e.invalidateFramebuffer(e.READ_FRAMEBUFFER, ce);
          }
          o.bindFramebuffer(e.READ_FRAMEBUFFER, null),
            o.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
            o.bindFramebuffer(
              e.DRAW_FRAMEBUFFER,
              it.__webglMultisampledFramebuffer,
            );
        }
      }
      function Ce($) {
        return Math.min(d, $.samples);
      }
      function _e($) {
        let W = i.get($);
        return $.samples > 0 &&
          t.has("WEBGL_multisampled_render_to_texture") === true &&
          W.__useRenderToTexture !== false;
      }
      function We($, W) {
        let ue = $.colorSpace, Ee = $.format, Be = $.type;
        return $.format === Rk ||
          ue !== Ga && ue !== Ey &&
            (ue === Lo
              ? (Ee !== Nd || Be !== Vn) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
                )
              : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                ue,
              )),
          W;
      }
      this.allocateTextureUnit = V,
        this.resetTextureUnits = L,
        this.setTexture2D = N,
        this.rebindTextures = K,
        this.setupRenderTarget = fe,
        this.updateRenderTargetMipmap = me,
        this.updateMultisampleRenderTarget = we,
        this.useMultisampledRTT = _e;
    }
  };
  function gO(r) {
    let e = r.__webglFramebuffer;
    if (!e || Array.isArray(e)) {
      throw new Error(
        "THREE.WebGLTextures: expected non-array framebuffer",
      );
    }
    return e;
  }
  function Ise(r) {
    let e = r.__webglFramebuffer;
    if (!e || !Array.isArray(e)) {
      throw new Error("THREE.WebGLTextures: expected array framebuffer");
    }
    return e;
  }
  var g_ = class {
    constructor(e, t, o) {
      let i = {},
        n = {},
        a = [],
        s = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
      function l(v, w) {
        let S = w.program;
        wt(S, "webglProgram"), o.uniformBlockBinding(v, S);
      }
      function c(v, w) {
        let S = i[v.id];
        S === void 0 &&
          (f(v), S = d(v), i[v.id] = S, v.addEventListener("dispose", C));
        let k = w.program;
        wt(k, "webglProgram"), o.updateUBOMapping(v, k);
        let _ = t.render.frame;
        n[v.id] !== _ && (h(v), n[v.id] = _);
      }
      function d(v) {
        let w = p();
        v.__bindingPointIndex = w;
        let S = e.createBuffer(), k = v.__size, _ = v.usage;
        return e.bindBuffer(e.UNIFORM_BUFFER, S),
          e.bufferData(e.UNIFORM_BUFFER, k, _),
          e.bindBuffer(e.UNIFORM_BUFFER, null),
          e.bindBufferBase(e.UNIFORM_BUFFER, w, S),
          S;
      }
      function p() {
        for (let v = 0; v < s; v++) {
          if (a.indexOf(v) === -1) return a.push(v), v;
        }
        return console.error(
          "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.",
        ),
          0;
      }
      function h(v) {
        let w = i[v.id], S = v.uniforms, k = v.__cache;
        if (w === void 0) {
          throw new Error(
            "THREE.WebGLUniformsGroups: buffer is undefined",
          );
        }
        e.bindBuffer(e.UNIFORM_BUFFER, w);
        for (let _ = 0, A = S.length; _ < A; _++) {
          let P = S[_];
          if (u(P, _, k) === true) {
            let O = P.__offset,
              U = Array.isArray(P.value) ? P.value : [P.value],
              z = 0;
            for (let x = 0; x < U.length; x++) {
              let L = U[x], V = y(L);
              typeof L == "number"
                ? (P.__data[0] = L,
                  e.bufferSubData(e.UNIFORM_BUFFER, O + z, P.__data))
                : L instanceof Po
                ? (P.__data[0] = L.elements[0],
                  P.__data[1] = L.elements[1],
                  P.__data[2] = L.elements[2],
                  P.__data[3] = L.elements[0],
                  P.__data[4] = L.elements[3],
                  P.__data[5] = L.elements[4],
                  P.__data[6] = L.elements[5],
                  P.__data[7] = L.elements[0],
                  P.__data[8] = L.elements[6],
                  P.__data[9] = L.elements[7],
                  P.__data[10] = L.elements[8],
                  P.__data[11] = L.elements[0])
                : (L.toArray(P.__data, z),
                  z += V.storage / Float32Array.BYTES_PER_ELEMENT);
            }
            e.bufferSubData(e.UNIFORM_BUFFER, O, P.__data);
          }
        }
        e.bindBuffer(e.UNIFORM_BUFFER, null);
      }
      function u(v, w, S) {
        let k = v.value;
        if (S[w] === void 0) {
          if (typeof k == "number") S[w] = k;
          else {
            let _ = Array.isArray(k) ? k : [k], A = [];
            for (let P = 0; P < _.length; P++) {
              let O = _[P];
              A.push(typeof O == "number" ? O : O.clone());
            }
            S[w] = A;
          }
          return true;
        } else if (typeof k == "number") {
          if (S[w] !== k) return S[w] = k, true;
        } else {
          let _ = S[w],
            A = Array.isArray(_) ? _ : [_],
            P = Array.isArray(k) ? k : [k];
          for (let O = 0; O < A.length; O++) {
            let U = A[O];
            if (U.equals(P[O]) === false) return U.copy(P[O]), true;
          }
        }
        return false;
      }
      function f(v) {
        let w = v.uniforms, S = 0, k = 16, _ = 0;
        for (let A = 0, P = w.length; A < P; A++) {
          let O = w[A],
            U = { boundary: 0, storage: 0 },
            z = Array.isArray(O.value) ? O.value : [O.value];
          for (let x = 0, L = z.length; x < L; x++) {
            let V = z[x], R = y(V);
            U.boundary += R.boundary, U.storage += R.storage;
          }
          if (
            O.__data = new Float32Array(
              U.storage / Float32Array.BYTES_PER_ELEMENT,
            ),
              O.__offset = S,
              A > 0
          ) {
            _ = S % k;
            let x = k - _;
            _ !== 0 && x - U.boundary < 0 && (S += k - _, O.__offset = S);
          }
          S += U.storage;
        }
        _ = S % k, _ > 0 && (S += k - _), v.__size = S, v.__cache = {};
      }
      function y(v) {
        let w = { boundary: 0, storage: 0 };
        return typeof v == "number"
          ? (w.boundary = 4, w.storage = 4)
          : v instanceof Tt
          ? (w.boundary = 8, w.storage = 8)
          : v instanceof ye || v instanceof vt
          ? (w.boundary = 16, w.storage = 12)
          : v instanceof pn
          ? (w.boundary = 16, w.storage = 16)
          : v instanceof Po
          ? (w.boundary = 48, w.storage = 48)
          : v instanceof Nt
          ? (w.boundary = 64, w.storage = 64)
          : v instanceof Bs
          ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.",
          )
          : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            v,
          ),
          w;
      }
      function C(v) {
        let w = v.target;
        w.removeEventListener("dispose", C);
        let S = a.indexOf(w.__bindingPointIndex);
        a.splice(S, 1);
        let k = i[w.id];
        k !== void 0 && e.deleteBuffer(k), delete i[w.id], delete n[w.id];
      }
      function E() {
        for (let v in i) {
          let w = i[v];
          w !== void 0 && e.deleteBuffer(w);
        }
        a = [], i = {}, n = {};
      }
      this.bind = l, this.update = c, this.dispose = E;
    }
  };
  var m_ = class {
    constructor(e, t) {
      function o(i, n = Ey) {
        let a;
        if (i === Vn) return e.UNSIGNED_BYTE;
        if (i === kk) return e.UNSIGNED_SHORT_4_4_4_4;
        if (i === _k) return e.UNSIGNED_SHORT_5_5_5_1;
        if (i === dW) return e.BYTE;
        if (i === pW) return e.SHORT;
        if (i === Cy) return e.UNSIGNED_SHORT;
        if (i === Dk) return e.INT;
        if (i === Ac) return e.UNSIGNED_INT;
        if (i === Xl) return e.FLOAT;
        if (i === Sy) return e.HALF_FLOAT;
        if (i === uW) return e.ALPHA;
        if (i === Nd) return e.RGBA;
        if (i === hW) return e.LUMINANCE;
        if (i === gW) return e.LUMINANCE_ALPHA;
        if (i === Yp) return e.DEPTH_COMPONENT;
        if (i === gh) return e.DEPTH_STENCIL;
        if (i === Rk) {
          return a = t.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
        }
        if (i === mW) return e.RED;
        if (i === Ik) return e.RED_INTEGER;
        if (i === fW) return e.RG;
        if (i === Ak) return e.RG_INTEGER;
        if (i === Mk) return e.RGBA_INTEGER;
        if (i === Gk || i === Lk || i === Pk || i === Vk) {
          if (n === Lo) {
            if (
              a = t.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null
            ) {
              if (i === Gk) {
                return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
              }
              if (i === Lk) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
              if (i === Pk) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
              if (i === Vk) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else return null;
          } else if (
            a = t.get("WEBGL_compressed_texture_s3tc"), a !== null
          ) {
            if (i === Gk) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (i === Lk) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (i === Pk) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (i === Vk) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else return null;
        }
        if (i === kV || i === _V || i === IV || i === AV) {
          if (a = t.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
            if (i === kV) {
              return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            }
            if (i === _V) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (i === IV) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (i === AV) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          } else return null;
        }
        if (i === bW) {
          return a = t.get("WEBGL_compressed_texture_etc1"),
            a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
        }
        if (i === MV || i === GV) {
          if (a = t.get("WEBGL_compressed_texture_etc"), a !== null) {
            if (i === MV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ETC2
                : a.COMPRESSED_RGB8_ETC2;
            }
            if (i === GV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                : a.COMPRESSED_RGBA8_ETC2_EAC;
            }
          } else return null;
        }
        if (
          i === LV || i === PV || i === VV || i === OV || i === RV ||
          i === FV || i === NV || i === BV || i === UV || i === zV ||
          i === qV || i === HV || i === KV || i === WV
        ) {
          if (a = t.get("WEBGL_compressed_texture_astc"), a !== null) {
            if (i === LV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
            }
            if (i === PV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
            }
            if (i === VV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
            }
            if (i === OV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
            }
            if (i === RV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
            }
            if (i === FV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
            }
            if (i === NV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
            }
            if (i === BV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
            }
            if (i === UV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
            }
            if (i === zV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
            }
            if (i === qV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
            }
            if (i === HV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
            }
            if (i === KV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
            }
            if (i === WV) {
              return n === Lo
                ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
          } else return null;
        }
        if (i === $V) {
          if (a = t.get("EXT_texture_compression_bptc"), a !== null) {
            if (i === $V) {
              return n === Lo
                ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            }
          } else return null;
        }
        if (i === jV || i === YV || i === XV || i === JV) {
          if (a = t.get("EXT_texture_compression_rgtc"), a !== null) {
            if (i === jV) {
              return a.COMPRESSED_RED_RGTC1_EXT;
            }
            if (i === YV) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (i === XV) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (i === JV) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
          } else return null;
        }
        return i === Fd ? e.UNSIGNED_INT_24_8 : e[i] !== void 0 ? e[i] : null;
      }
      this.convert = o;
    }
  };
  var eu = class extends Ii {
    constructor() {
      super();
      this.isScene = true;
      this.isScene = true,
        this.type = "Scene",
        this.background = null,
        this.overrideMaterial = null;
    }
  };
  var f_ = class {
    constructor(e) {
      let t = new WeakMap();
      function o(l, c) {
        let d = l.array, p = l.usage, h = e.createBuffer();
        e.bindBuffer(c, h), e.bufferData(c, d, p), l.onUploadCallback();
        let u;
        if (d instanceof Float32Array) u = e.FLOAT;
        else if (d instanceof Uint16Array) u = e.UNSIGNED_SHORT;
        else if (d instanceof Int16Array) u = e.SHORT;
        else if (d instanceof Uint32Array) u = e.UNSIGNED_INT;
        else if (d instanceof Int32Array) u = e.INT;
        else if (d instanceof Int8Array) u = e.BYTE;
        else if (d instanceof Uint8Array) u = e.UNSIGNED_BYTE;
        else {throw new Error(
            "THREE.WebGLAttributes: Unsupported buffer data format: " + d,
          );}
        return {
          buffer: h,
          type: u,
          bytesPerElement: d.BYTES_PER_ELEMENT,
          version: l.version,
        };
      }
      function i(l, c, d) {
        let p = c.array, h = c.updateRange;
        e.bindBuffer(d, l),
          h.count === -1 ? e.bufferSubData(d, 0, p) : (e.bufferSubData(
            d,
            h.offset * p.BYTES_PER_ELEMENT,
            p,
            h.offset,
            h.count,
          ),
            h.count = -1),
          c.onUploadCallback();
      }
      function n(l) {
        return t.get(l);
      }
      function a(l) {
        let c = t.get(l);
        c && (e.deleteBuffer(c.buffer), t.delete(l));
      }
      function s(l, c) {
        let d = t.get(l);
        d === void 0 ? t.set(l, o(l, c)) : d.version < l.version &&
          (i(d.buffer, l, c), d.version = l.version);
      }
      this.get = n, this.remove = a, this.update = s;
    }
  };
  var b_ = new vt(0),
    y_ = class {
      constructor(e, t, o, i, n) {
        let a = new vt(0), s = i === true ? 0 : 1;
        function l(d, p) {
          let h = false, u = p.isScene === true ? p.background : null;
          u === null ? c(a, s) : u && u.isColor && (c(u, 1), h = true),
            (e.autoClear || h) &&
            e.clear(
              e.autoClearColor,
              e.autoClearDepth,
              e.autoClearStencil,
            );
        }
        function c(d, p) {
          d.getRGB(b_, FW(e)), t.buffers.color.setClear(b_.r, b_.g, b_.b, p, n);
        }
        this.getClearColor = function () {
          return a;
        },
          this.setClearColor = function (d, p = 1) {
            a.copy(d), s = p, c(a, s);
          },
          this.getClearAlpha = function () {
            return s;
          },
          this.setClearAlpha = function (d) {
            s = d, c(a, s);
          },
          this.render = l;
      }
    };
  var x_ = class {
    constructor(e, t) {
      let o = e.getParameter(e.MAX_VERTEX_ATTRIBS),
        i = true,
        n = {},
        a = f(null),
        s = a,
        l = false;
      function c(x, L, V, R, N) {
        let M = false;
        if (i) {
          let F = u(R, V, L);
          s !== F && (s = F, p(s.object)),
            M = y(x, R, V, N),
            M && C(x, R, V, N);
        } else {
          let F = L.wireframe === true;
          (s.geometry !== R.id || s.program !== V.id ||
            s.wireframe !== F) &&
            (s.geometry = R.id, s.program = V.id, s.wireframe = F, M = true);
        }
        if (
          N !== null && t.update(N, e.ELEMENT_ARRAY_BUFFER),
            (M || l) && (l = false, _(x, L, V, R), N !== null)
        ) {
          let F = t.get(N);
          wt(F, "indexAttributes"),
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, F.buffer);
        }
      }
      function d() {
        return e.createVertexArray();
      }
      function p(x) {
        e.bindVertexArray(x);
      }
      function h(x) {
        return e.deleteVertexArray(x);
      }
      function u(x, L, V) {
        let R = V.wireframe === true ? "true" : "false", N = n[x.id];
        N === void 0 && (N = {}, n[x.id] = N);
        let M = N[L.id];
        M === void 0 && (M = {}, N[L.id] = M);
        let F = M[R];
        return F === void 0 && (F = f(d()), M[R] = F), F;
      }
      function f(x) {
        let L = [], V = [], R = [];
        for (let N = 0; N < o; N++) L[N] = 0, V[N] = 0, R[N] = 0;
        return {
          geometry: null,
          program: null,
          wireframe: false,
          newAttributes: L,
          enabledAttributes: V,
          attributeDivisors: R,
          object: x,
          attributes: {},
          index: null,
        };
      }
      function y(x, L, V, R) {
        let N = s.attributes,
          M = L.attributes,
          F = 0,
          Z = V.getAttributes();
        for (let te in Z) {
          if (Z[te].location >= 0) {
            let he = N[te], se = M[te];
            if (
              se === void 0 && x instanceof Mi &&
              (te === "instanceMatrix" && x.instanceMatrix &&
                (se = x.instanceMatrix),
                te === "instanceColor" && x.instanceColor &&
                (se = x.instanceColor),
                te === "instancePickingColor" && x.instancePickingColor &&
                (se = x.instancePickingColor)),
                he === void 0 || he.attribute !== se ||
                se && he.data !== se.data
            ) return true;
            F++;
          }
        }
        return s.attributesNum !== F || s.index !== R;
      }
      function C(x, L, V, R) {
        let N = {}, M = L.attributes, F = 0, Z = V.getAttributes();
        for (let te in Z) {
          if (Z[te].location >= 0) {
            let he = M[te];
            he === void 0 && x instanceof Mi &&
              (te === "instanceMatrix" && x.instanceMatrix &&
                (he = x.instanceMatrix),
                te === "instanceColor" && x.instanceColor &&
                (he = x.instanceColor),
                te === "instancePickingColor" && x.instancePickingColor &&
                (he = x.instancePickingColor));
            let se = { attribute: he };
            he && "data" in he && he.data && (se.data = he.data),
              N[te] = se,
              F++;
          }
        }
        s.attributes = N, s.attributesNum = F, s.index = R;
      }
      function E() {
        let x = s.newAttributes;
        for (let L = 0, V = x.length; L < V; L++) x[L] = 0;
      }
      function v(x) {
        w(x, 0);
      }
      function w(x, L) {
        let V = s.newAttributes,
          R = s.enabledAttributes,
          N = s.attributeDivisors;
        V[x] = 1,
          R[x] === 0 && (e.enableVertexAttribArray(x), R[x] = 1),
          N[x] !== L && (e.vertexAttribDivisor(x, L), N[x] = L);
      }
      function S() {
        let x = s.newAttributes, L = s.enabledAttributes;
        for (let V = 0, R = L.length; V < R; V++) {
          L[V] !== x[V] && (e.disableVertexAttribArray(V), L[V] = 0);
        }
      }
      function k(x, L, V, R, N, M, F) {
        F === true
          ? e.vertexAttribIPointer(x, L, V, N, M)
          : e.vertexAttribPointer(x, L, V, R, N, M);
      }
      function _(x, L, V, R) {
        E();
        let N = R.attributes,
          M = V.getAttributes(),
          F = L.defaultAttributeValues;
        for (let Z in M) {
          let te = M[Z];
          if (te.location >= 0) {
            let Y = N[Z];
            if (
              Y === void 0 && x instanceof Mi &&
              (Z === "instanceMatrix" && x.instanceMatrix &&
                (Y = x.instanceMatrix),
                Z === "instanceColor" && x.instanceColor &&
                (Y = x.instanceColor),
                Z === "instancePickingColor" && x.instancePickingColor &&
                (Y = x.instancePickingColor)), Y !== void 0
            ) {
              let he = Y.normalized, se = Y.itemSize, ae = t.get(Y);
              if (ae === void 0) continue;
              let q = ae.buffer,
                oe = ae.type,
                K = ae.bytesPerElement,
                fe = oe === e.INT || oe === e.UNSIGNED_INT ||
                  Y.gpuType === Dk;
              if (Y instanceof Eh) {
                for (let me = 0; me < te.locationSize; me++) {
                  w(
                    te.location + me,
                    Y.meshPerAttribute,
                  );
                }
                !(x instanceof Mi) && R._maxInstanceCount === void 0 &&
                  (R._maxInstanceCount = Y.meshPerAttribute * Y.count);
              } else {for (let me = 0; me < te.locationSize; me++) {
                  v(
                    te.location + me,
                  );
                }}
              e.bindBuffer(e.ARRAY_BUFFER, q);
              for (let me = 0; me < te.locationSize; me++) {
                k(
                  te.location + me,
                  se / te.locationSize,
                  oe,
                  he,
                  se * K,
                  se / te.locationSize * me * K,
                  fe,
                );
              }
            } else if (F !== void 0) {
              let he = F[Z];
              if (he !== void 0) {
                switch (he.length) {
                  case 2:
                    e.vertexAttrib2fv(te.location, he);
                    break;
                  case 3:
                    e.vertexAttrib3fv(te.location, he);
                    break;
                  case 4:
                    e.vertexAttrib4fv(te.location, he);
                    break;
                  default:
                    e.vertexAttrib1fv(te.location, he);
                }
              }
            }
          }
        }
        S();
      }
      function A() {
        U();
        for (let x in n) {
          let L = n[x];
          for (let V in L) {
            let R = L[V];
            for (let N in R) {
              let M = R[N];
              wt(M, "state"), h(M.object), delete R[N];
            }
            delete L[V];
          }
          delete n[x];
        }
      }
      function P(x) {
        if (n[x.id] === void 0) return;
        let L = n[x.id];
        for (let V in L) {
          let R = L[V];
          for (let N in R) {
            let M = R[N];
            wt(M, "state"), h(M.object), delete R[N];
          }
          delete L[V];
        }
        delete n[x.id];
      }
      function O(x) {
        for (let L in n) {
          let V = n[L];
          if (wt(V, "programMap"), V[x.id] === void 0) continue;
          let R = V[x.id];
          for (let N in R) {
            let M = R[N];
            wt(M, "state"), h(M.object), delete R[N];
          }
          delete V[x.id];
        }
      }
      function U() {
        z(), l = true, s !== a && (s = a, p(s.object));
      }
      function z() {
        a.geometry = null, a.program = null, a.wireframe = false;
      }
      this.setup = c,
        this.reset = U,
        this.resetDefaultState = z,
        this.dispose = A,
        this.releaseStatesOfGeometry = P,
        this.releaseStatesOfProgram = O,
        this.initAttributes = E,
        this.enableAttribute = v,
        this.disableUnusedAttributes = S;
    }
  };
  var w_ = class {
      constructor() {
        let e = new o_(), t = [];
        function o() {
          t.length = 0;
        }
        function i(s) {
          t.push(s);
        }
        function n() {
          e.setup(t);
        }
        function a(s) {
          e.setupView(t, s);
        }
        this.state = { lightsArray: t, lights: e },
          this.init = o,
          this.pushLight = i,
          this.setupLights = n,
          this.setupLightsView = a;
      }
    },
    v_ = class {
      constructor() {
        let e = new WeakMap();
        this.get = function (o, i = 0) {
          let n = e.get(o), a;
          return n === void 0
            ? (a = new w_(), e.set(o, [a]))
            : i >= n.length
            ? (a = new w_(), n.push(a))
            : a = n[i],
            a;
        },
          this.dispose = function () {
            e = new WeakMap();
          };
      }
    };
  function u7(r) {
    return r instanceof pn;
  }
  function h7(r) {
    return r.isLight;
  }
  function Ase(r) {
    return r.isScene;
  }
  function C_(r) {
    return r.isMesh;
  }
  function mO(r) {
    return r.isLine;
  }
  function Mse(r) {
    return r.isLineSegments;
  }
  function Gse() {
    let r = Bk("canvas");
    return r.style.display = "block", r;
  }
  var Vy = class {
    constructor(e = {}) {
      let {
        canvas: t = Gse(),
        context: o = null,
        depth: i = true,
        stencil: n = true,
        alpha: a = false,
        antialias: s = false,
        premultipliedAlpha: l = true,
        preserveDrawingBuffer: c = false,
        powerPreference: d = "default",
        failIfMajorPerformanceCaveat: p = false,
      } = e;
      this.isWebGLRenderer = true;
      let h;
      o !== null ? h = o.getContextAttributes().alpha : h = a;
      let u = new Uint32Array(4),
        f = new Int32Array(4),
        y = null,
        C = null,
        E = [],
        v = [];
      this.domElement = t,
        this.debug = { checkShaderErrors: true, onShaderError: null },
        this.autoClear = true,
        this.autoClearColor = true,
        this.autoClearDepth = true,
        this.autoClearStencil = true,
        this.sortObjects = true,
        this.outputColorSpace = Lo;
      let w = this,
        S = false,
        k = 0,
        _ = 0,
        A = null,
        P = -1,
        O = null,
        U = new pn(),
        z = new pn(),
        x = null,
        L = t.width,
        V = t.height,
        R = 1,
        N = null,
        M = null,
        F = new pn(0, 0, L, V),
        Z = new pn(0, 0, L, V),
        te = false,
        Y = new jk(),
        he = new Nt(),
        se = new ye(),
        ae = new eu();
      function q() {
        return A === null ? R : 1;
      }
      let oe = {
        alpha: true,
        depth: i,
        stencil: n,
        antialias: s,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: d,
        failIfMajorPerformanceCaveat: p,
      };
      "setAttribute" in t &&
      t.setAttribute("data-engine", `three.js r${U6}`),
        t.addEventListener("webglcontextlost", Q, false),
        t.addEventListener("webglcontextrestored", j, false),
        t.addEventListener("webglcontextcreationerror", Ge, false);
      let K = (() => {
          let J = o || t.getContext("webgl2", oe);
          if (J === null) {
            throw new Error(
              "THREE.WebGLRenderer: Error creating WebGL context with your selected attributes.",
            );
          }
          return J;
        })(),
        fe,
        me,
        we,
        Ce,
        _e,
        We,
        $,
        W,
        ue,
        Ee,
        Be,
        ce,
        ot,
        it,
        Se,
        Lt,
        It,
        Dt;
      function Mr() {
        wt(K, "gl context"),
          fe = new Zk(K),
          me = new Qk(K, fe, e),
          fe.init(),
          Lt = new m_(K, fe),
          we = new u_(K),
          Ce = new r_(K),
          _e = new c_(),
          We = new h_(K, fe, we, _e, me, Lt, Ce),
          $ = new f_(K),
          It = new x_(K, $),
          W = new e_(K, $, Ce, It),
          ue = new i_(K, W, $, Ce),
          Ee = new l_(w, me, It),
          Be = new p_(),
          ce = new v_(),
          ot = new y_(w, we, ue, h, l),
          Dt = new g_(K, Ce, we),
          it = new Jk(K, Ce),
          Se = new t_(K, Ce),
          Ce.programs = Ee.programs,
          w.capabilities = me,
          w.extensions = fe,
          w.properties = _e,
          w.renderLists = Be,
          w.state = we,
          w.info = Ce;
      }
      Mr(),
        this.getContext = function () {
          return K;
        },
        this.getContextAttributes = function () {
          return K.getContextAttributes();
        },
        this.forceContextLoss = function () {
          let J = fe.get("WEBGL_lose_context");
          J && J.loseContext();
        },
        this.forceContextRestore = function () {
          let J = fe.get("WEBGL_lose_context");
          J && J.restoreContext();
        },
        this.getPixelRatio = function () {
          return R;
        },
        this.setPixelRatio = function (J) {
          J !== void 0 && (R = J, this.setSize(L, V, false));
        },
        this.getSize = function (J) {
          return J.set(L, V);
        },
        this.setSize = function (J, pe, Ne = true) {
          L = J,
            V = pe,
            t.width = Math.floor(J * R),
            t.height = Math.floor(pe * R),
            Ne === true &&
            (t.style.width = J + "px", t.style.height = pe + "px"),
            this.setViewport(0, 0, J, pe);
        },
        this.getDrawingBufferSize = function (J) {
          return J.set(L * R, V * R).floor();
        },
        this.setDrawingBufferSize = function (J, pe, Ne) {
          L = J,
            V = pe,
            R = Ne,
            t.width = Math.floor(J * Ne),
            t.height = Math.floor(pe * Ne),
            this.setViewport(0, 0, J, pe);
        },
        this.getCurrentViewport = function (J) {
          return J.copy(U);
        },
        this.getViewport = function (J) {
          return J.copy(F);
        },
        this.setViewport = function (J, pe, Ne, Te) {
          u7(J) ? F.set(J.x, J.y, J.z, J.w) : F.set(J, pe, Ne, Te),
            we.viewport(U.copy(F).multiplyScalar(R).floor());
        },
        this.getScissor = function (J) {
          return J.copy(Z);
        },
        this.setScissor = function (J, pe, Ne, Te) {
          u7(J) ? Z.set(J.x, J.y, J.z, J.w) : Z.set(J, pe, Ne, Te),
            we.scissor(z.copy(Z).multiplyScalar(R).floor());
        },
        this.getScissorTest = function () {
          return te;
        },
        this.setScissorTest = function (J) {
          we.setScissorTest(te = J);
        },
        this.setOpaqueSort = function (J) {
          N = J;
        },
        this.setTransparentSort = function (J) {
          M = J;
        },
        this.getClearColor = function (J) {
          return J.copy(ot.getClearColor());
        },
        this.setClearColor = function (...J) {
          ot.setClearColor.apply(ot, J);
        },
        this.getClearAlpha = function () {
          return ot.getClearAlpha();
        },
        this.setClearAlpha = function (...J) {
          ot.setClearAlpha.apply(ot, J);
        },
        this.clear = function (J = true, pe = true, Ne = true) {
          let Te = 0;
          if (J) {
            let dt = false;
            if (A !== null) {
              let ut = A.texture.format;
              dt = ut === Mk || ut === Ak || ut === Ik;
            }
            if (dt) {
              wt(A, "render target");
              let ut = A.texture.type,
                kt = ut === Vn || ut === Ac || ut === Cy || ut === Fd ||
                  ut === kk || ut === _k,
                Qt = ot.getClearColor(),
                Gt = ot.getClearAlpha(),
                Vt = Qt.r,
                Ct = Qt.g,
                xr = Qt.b;
              kt
                ? (u[0] = Vt,
                  u[1] = Ct,
                  u[2] = xr,
                  u[3] = Gt,
                  K.clearBufferuiv(K.COLOR, 0, u))
                : (f[0] = Vt,
                  f[1] = Ct,
                  f[2] = xr,
                  f[3] = Gt,
                  K.clearBufferiv(K.COLOR, 0, f));
            } else Te |= K.COLOR_BUFFER_BIT;
          }
          pe && (Te |= K.DEPTH_BUFFER_BIT),
            Ne && (Te |= K.STENCIL_BUFFER_BIT),
            K.clear(Te);
        },
        this.clearColor = function () {
          this.clear(true, false, false);
        },
        this.clearDepth = function () {
          this.clear(false, true, false);
        },
        this.clearStencil = function () {
          this.clear(false, false, true);
        },
        this.dispose = function () {
          t.removeEventListener("webglcontextlost", Q, false),
            t.removeEventListener("webglcontextrestored", j, false),
            t.removeEventListener("webglcontextcreationerror", Ge, false),
            Be.dispose(),
            ce.dispose(),
            _e.dispose(),
            ue.dispose(),
            It.dispose(),
            Dt.dispose(),
            Ee.dispose();
        };
      function Q(J) {
        J.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          S = true;
      }
      function j() {
        console.log("THREE.WebGLRenderer: Context Restored."), S = false;
        let J = Ce.autoReset;
        Mr(), Ce.autoReset = J;
      }
      function Ge(J) {
        console.error(
          "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
          J.statusMessage,
        );
      }
      function de(J) {
        let pe = J.target;
        pe.removeEventListener("dispose", de), Ye(pe);
      }
      function Ye(J) {
        Ve(J), _e.remove(J);
      }
      function Ve(J) {
        let pe = _e.get(J).programs;
        pe !== void 0 && (pe.forEach((Ne) => {
          Ee.releaseProgram(Ne);
        }),
          Ee.releaseShaderCache(J));
      }
      this.renderBufferDirect = function (J, pe, Ne, Te, dt, ut) {
        pe === null && (pe = ae);
        let kt = !!C_(dt) && dt.matrixWorld.determinant() < 0,
          Qt = at(J, pe, Te, dt);
        we.setMaterial(Te, kt);
        let Gt = Ne.index, Vt = 1;
        if (Te.wireframe === true) {
          if (Gt = W.getWireframeAttribute(Ne), Gt === void 0) return;
          Vt = 2;
        }
        let Ct = Ne.attributes.position, xr = 0, Zt = 1 / 0 * Vt;
        ut !== null &&
        (xr = Math.max(xr, ut.start * Vt),
          Zt = Math.min(Zt, (ut.start + ut.count) * Vt)),
          Gt !== null
            ? (xr = Math.max(xr, 0), Zt = Math.min(Zt, Gt.count))
            : Ct != null &&
              (xr = Math.max(xr, 0), Zt = Math.min(Zt, Ct.count));
        let Xo = Zt - xr;
        if (Xo < 0 || Xo === 1 / 0) return;
        wt(Qt, "program"), It.setup(dt, Te, Qt, Ne, Gt);
        let Zi, na = it;
        if (
          Gt !== null &&
          (Zi = $.get(Gt), na = Se, wt(Zi, "attribute"), Se.setIndex(Zi)),
            C_(dt)
              ? Te.wireframe === true
                ? (we.setLineWidth(q()), na.setMode(K.LINES))
                : na.setMode(K.TRIANGLES)
              : mO(dt) &&
                (we.setLineWidth(q()),
                  Mse(dt) ? na.setMode(K.LINES) : na.setMode(K.LINE_STRIP)),
            dt instanceof Mi
        ) na.renderInstances(xr, Xo, dt.count);
        else if (Ne instanceof Ly) {
          let xn = Ne._maxInstanceCount !== void 0
              ? Ne._maxInstanceCount
              : 1 / 0,
            Ho = Math.min(Ne.instanceCount, xn);
          na.renderInstances(xr, Xo, Ho);
        } else na.render(xr, Xo);
      },
        this.compile = function (J, pe) {
          function Ne(Te, dt, ut) {
            Te.transparent === true && Te.side === ua &&
              Te.forceSinglePass === false
              ? (Te.side = lm,
                Te.needsUpdate = true,
                Vo(Te, dt, ut),
                Te.side = Wv,
                Te.needsUpdate = true,
                Vo(Te, dt, ut),
                Te.side = ua)
              : Vo(Te, dt, ut);
          }
          C = ce.get(J),
            C.init(),
            v.push(C),
            J.traverseVisible((Te) => {
              wt(C, "render state"),
                h7(Te) && Te.layers.test(pe.layers) && C.pushLight(Te);
            }),
            C.setupLights(),
            J.traverse((Te) => {
              let dt = Te.material;
              if (dt) {
                if (!C_(Te) && !mO(Te)) {
                  throw new Error(
                    `THREE.WebGLRenderer: Object of type ${Te.type} has material but no geometry.`,
                  );
                }
                if (Array.isArray(dt)) {
                  for (let ut = 0; ut < dt.length; ut++) {
                    let kt = dt[ut];
                    Ne(kt, J, Te);
                  }
                } else Ne(dt, J, Te);
              }
            }),
            v.pop(),
            C = null;
        },
        this.render = function (J, pe) {
          if (pe !== void 0 && pe.isCamera !== true) {
            console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
            );
            return;
          }
          S !== true &&
            (J.matrixWorldAutoUpdate === true && J.updateMatrixWorld(),
              pe.parent === null && pe.matrixWorldAutoUpdate === true &&
              pe.updateMatrixWorld(),
              C = ce.get(J, v.length),
              C.init(),
              v.push(C),
              he.multiplyMatrices(
                pe.projectionMatrix,
                pe.matrixWorldInverse,
              ),
              Y.setFromProjectionMatrix(he),
              y = Be.get(J, E.length),
              y.init(),
              E.push(y),
              Qr(J, pe, 0, w.sortObjects),
              y.finish(),
              w.sortObjects === true && y.sort(N, M),
              this.info.render.frame++,
              this.info.autoReset === true && this.info.reset(),
              ot.render(y, J),
              C.setupLights(),
              st(y, J, pe),
              A !== null &&
              (We.updateMultisampleRenderTarget(A),
                We.updateRenderTargetMipmap(A)),
              It.resetDefaultState(),
              P = -1,
              O = null,
              v.pop(),
              v.length > 0 ? C = v[v.length - 1] : C = null,
              E.pop(),
              E.length > 0 ? y = E[E.length - 1] : y = null);
        };
      function Qr(J, pe, Ne, Te) {
        if (J.visible === false) return;
        if (J.layers.test(pe.layers)) {
          if (wt(C, "render state"), J.isGroup) {
            Ne = J.renderOrder;
          } else if (h7(J)) C.pushLight(J);
          else if (
            (C_(J) || mO(J)) &&
            (wt(y, "render list"), !J.frustumCulled || Y.intersectsObject(J))
          ) {
            let kt = ue.update(J), Qt = J.material;
            if (
              wt(Qt, "material"),
                Te &&
                (kt.boundingSphere === null && kt.computeBoundingSphere(),
                  se.copy(kt.boundingSphere.center),
                  se.applyMatrix4(J.matrixWorld).applyMatrix4(he)),
                Array.isArray(Qt)
            ) {
              let Gt = kt.groups;
              for (let Vt = 0, Ct = Gt.length; Vt < Ct; Vt++) {
                let xr = Gt[Vt],
                  Zt = xr.materialIndex && Qt[xr.materialIndex];
                Zt && Zt.visible && y.push(J, kt, Zt, Ne, se.z, xr);
              }
            } else Qt.visible && y.push(J, kt, Qt, Ne, se.z, null);
          }
        }
        let ut = J.children;
        for (let kt = 0, Qt = ut.length; kt < Qt; kt++) {
          Qr(ut[kt], pe, Ne, Te);
        }
      }
      function st(J, pe, Ne, Te) {
        let dt = J.opaque, ut = J.transparent;
        wt(C, "render state"),
          C.setupLightsView(Ne),
          Te && we.viewport(U.copy(Te)),
          dt.length > 0 && Bn(dt, pe, Ne),
          ut.length > 0 && Bn(ut, pe, Ne),
          we.buffers.depth.setTest(true),
          we.buffers.depth.setMask(true),
          we.buffers.color.setMask(true),
          we.setPolygonOffset(false);
      }
      function Bn(J, pe, Ne) {
        let Te = Ase(pe) ? pe.overrideMaterial : null;
        for (let dt = 0, ut = J.length; dt < ut; dt++) {
          let kt = J[dt],
            Qt = kt.object,
            Gt = kt.geometry,
            Vt = Te === null ? kt.material : Te,
            Ct = kt.group;
          Qt.layers.test(Ne.layers) && co(Qt, pe, Ne, Gt, Vt, Ct);
        }
      }
      function co(J, pe, Ne, Te, dt, ut) {
        J.modelViewMatrix.multiplyMatrices(
          Ne.matrixWorldInverse,
          J.matrixWorld,
        ),
          J.normalMatrix.getNormalMatrix(J.modelViewMatrix),
          dt.transparent === true && dt.side === ua &&
            dt.forceSinglePass === false
            ? (dt.side = lm,
              dt.needsUpdate = true,
              w.renderBufferDirect(Ne, pe, Te, dt, J, ut),
              dt.side = Wv,
              dt.needsUpdate = true,
              w.renderBufferDirect(Ne, pe, Te, dt, J, ut),
              dt.side = ua)
            : w.renderBufferDirect(Ne, pe, Te, dt, J, ut);
      }
      function Vo(J, pe, Ne) {
        pe.isScene !== true && (pe = ae);
        let Te = _e.get(J);
        wt(C, "render state");
        let dt = C.state.lights,
          ut = dt.state.version,
          kt = Ee.getParameters(J, dt.state, pe, Ne),
          Qt = Ee.getProgramCacheKey(kt),
          Gt = Te.programs;
        Gt === void 0 &&
          (J.addEventListener("dispose", de), Gt = new Map(), Te.programs = Gt);
        let Vt = Gt.get(Qt);
        if (Vt !== void 0) {
          if (Te.currentProgram === Vt && Te.lightsStateVersion === ut) {
            return Ue(J, kt), Vt;
          }
        } else {kt.uniforms = Ee.getUniforms(J),
            Vt = Ee.acquireProgram(kt, Qt),
            Gt.set(Qt, Vt),
            Te.uniforms = kt.uniforms;}
        let Ct = Te.uniforms;
        wt(Ct, "uniforms"),
          Ue(J, kt),
          Te.needsLights = be(J),
          Te.lightsStateVersion = ut,
          Te.needsLights &&
          (Ct.ambientLightColor.value = dt.state.ambient,
            Ct.directionalLights.value = dt.state.directional);
        let xr = Vt.getUniforms(), Zt = Th.seqWithValue(xr.seq, Ct);
        return Te.currentProgram = Vt, Te.uniformsList = Zt, Vt;
      }
      function Ue(J, pe) {
        let Ne = _e.get(J);
        Ne.outputColorSpace = pe.outputColorSpace,
          Ne.instancing = pe.instancing,
          Ne.instancingColor = pe.instancingColor,
          Ne.instancingPickingColor = pe.instancingPickingColor;
      }
      function at(J, pe, Ne, Te) {
        var na;
        pe.isScene !== true && (pe = ae), We.resetTextureUnits();
        let dt = A === null ? w.outputColorSpace : Ga, ut = _e.get(Ne);
        wt(C, "render state");
        let kt = C.state.lights, Qt = false;
        Ne.version === ut.__version
          ? (ut.needsLights &&
              ut.lightsStateVersion !== kt.state.version ||
            ut.outputColorSpace !== dt ||
            Te instanceof Mi != !!ut.instancing) && (Qt = true)
          : (Qt = true, ut.__version = Ne.version);
        let Gt = ut.currentProgram;
        Qt === true && (Gt = Vo(Ne, pe, Te)),
          Ne.exprTooComplex =
            ((na = Gt == null ? void 0 : Gt.diagnostics) == null
              ? void 0
              : na.exprTooComplex) === true;
        let Vt = false, Ct = false, xr = false;
        wt(Gt, "program");
        let Zt = Gt.getUniforms(), Xo = ut.uniforms;
        if (
          we.useProgram(Gt.program) && (Vt = true, Ct = true, xr = true),
            Ne.id !== P && (P = Ne.id, Ct = true),
            Vt || O !== J
        ) {
          Zt.setValue(K, "projectionMatrix", J.projectionMatrix, We),
            O !== J && (O = J, Ct = true, xr = true);
          let xn = Zt.map.cameraPosition;
          xn !== void 0 &&
          xn.setValue(K, se.setFromMatrixPosition(J.matrixWorld), We),
            Zt.setValue(K, "isOrthographic", J instanceof Xp, We),
            Zt.setValue(K, "viewMatrix", J.matrixWorldInverse, We);
        }
        Ct &&
        (ut.needsLights && (wt(Xo, "m_uniforms"), ft(Xo, xr)),
          Ne.uniformsNeedUpdate = false,
          wt(ut.uniformsList, "uniformsList"),
          wt(Xo, "m_uniforms"),
          Th.upload(K, ut.uniformsList, Xo, We)),
          Ne.uniformsNeedUpdate === true &&
          (wt(ut.uniformsList, "uniformsList"),
            wt(Xo, "m_uniforms"),
            Th.upload(K, ut.uniformsList, Xo, We),
            Ne.uniformsNeedUpdate = false),
          Zt.setValue(K, "dcgModelMatrix", Te.dcgModelMatrix, We),
          Zt.setValue(K, "modelViewMatrix", Te.modelViewMatrix, We),
          Zt.setValue(
            K,
            "pickingColor",
            Te.pickingColor || [0, 0, 0, 0],
            We,
          ),
          Zt.setValue(K, "normalMatrix", Te.normalMatrix, We);
        let Zi = Ne.uniformsGroups;
        for (let xn = 0, Ho = Zi.length; xn < Ho; xn++) {
          let en = Zi[xn];
          Dt.update(en, Gt), Dt.bind(en, Gt);
        }
        return Gt;
      }
      function ft(J, pe) {
        J.ambientLightColor.needsUpdate = pe,
          J.directionalLights.needsUpdate = pe;
      }
      function be(J) {
        return J.lights === true;
      }
      this.getActiveCubeFace = function () {
        return k;
      },
        this.getActiveMipmapLevel = function () {
          return _;
        },
        this.getRenderTarget = function () {
          return A;
        },
        this.setRenderTarget = function (J, pe = 0, Ne = 0) {
          A = J, k = pe, _ = Ne;
          let Te = true, dt = null;
          if (J) {
            let kt = _e.get(J);
            kt.__useDefaultFramebuffer !== void 0
              ? (we.bindFramebuffer(K.FRAMEBUFFER, null), Te = false)
              : kt.__webglFramebuffer === void 0
              ? We.setupRenderTarget(J)
              : kt.__hasExternalTextures && J.depthTexture &&
                We.rebindTextures(
                  J,
                  _e.get(J.texture).__webglTexture,
                  _e.get(J.depthTexture).__webglTexture,
                );
            let Qt = _e.get(J).__webglFramebuffer;
            J.samples > 0 && We.useMultisampledRTT(J) === false
              ? dt = _e.get(J).__webglMultisampledFramebuffer
              : Array.isArray(Qt)
              ? dt = Qt[Ne]
              : dt = Qt,
              U.copy(J.viewport),
              z.copy(J.scissor),
              x = J.scissorTest;
          } else {U.copy(F).multiplyScalar(R).floor(),
              z.copy(Z).multiplyScalar(R).floor(),
              x = te;}
          we.bindFramebuffer(K.FRAMEBUFFER, dt) && me.drawBuffers && Te &&
          we.drawBuffers(J, dt),
            we.viewport(U),
            we.scissor(z),
            we.setScissorTest(x),
            P = -1;
        },
        this.readRenderTargetPixels = function (
          J,
          pe,
          Ne,
          Te,
          dt,
          ut,
          kt,
        ) {
          if (!(J && J.isWebGLRenderTarget)) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
            );
            return;
          }
          let Qt = _e.get(J).__webglFramebuffer;
          if (Qt) {
            we.bindFramebuffer(K.FRAMEBUFFER, Qt);
            try {
              let Gt = J.texture, Vt = Gt.format, Ct = Gt.type;
              if (
                Vt !== Nd &&
                Lt.convert(Vt) !==
                  K.getParameter(K.IMPLEMENTATION_COLOR_READ_FORMAT)
              ) {
                console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
                );
                return;
              }
              let xr = Ct === Sy &&
                (fe.has("EXT_color_buffer_half_float") ||
                  fe.has("EXT_color_buffer_float"));
              if (
                Ct !== Vn &&
                Lt.convert(Ct) !==
                  K.getParameter(K.IMPLEMENTATION_COLOR_READ_TYPE) &&
                Ct !== Xl && !xr
              ) {
                console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
                );
                return;
              }
              pe >= 0 && pe <= J.width - Te && Ne >= 0 &&
                Ne <= J.height - dt &&
                K.readPixels(
                  pe,
                  Ne,
                  Te,
                  dt,
                  Lt.convert(Vt),
                  Lt.convert(Ct),
                  ut,
                );
            } finally {
              let Gt = A !== null ? _e.get(A).__webglFramebuffer : null;
              we.bindFramebuffer(K.FRAMEBUFFER, Gt || null);
            }
          }
        },
        this.copyFramebufferToTexture = function (J, pe, Ne = 0) {
          let Te = Math.pow(2, -Ne),
            dt = Math.floor(pe.image.width * Te),
            ut = Math.floor(pe.image.height * Te);
          We.setTexture2D(pe, 0),
            K.copyTexSubImage2D(K.TEXTURE_2D, Ne, 0, 0, J.x, J.y, dt, ut),
            we.unbindTexture();
        },
        this.copyTextureToTexture = function (J, pe, Ne, Te = 0) {
          let dt = Lt.convert(Ne.format), ut = Lt.convert(Ne.type);
          We.setTexture2D(Ne, 0),
            K.pixelStorei(K.UNPACK_FLIP_Y_WEBGL, Ne.flipY),
            K.pixelStorei(
              K.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              Ne.premultiplyAlpha,
            ),
            K.pixelStorei(K.UNPACK_ALIGNMENT, Ne.unpackAlignment),
            K.texSubImage2D(K.TEXTURE_2D, Te, J.x, J.y, dt, ut, pe.image),
            Te === 0 && Ne.generateMipmaps &&
            K.generateMipmap(K.TEXTURE_2D),
            we.unbindTexture();
        },
        this.initTexture = function (J) {
          We.setTexture2D(J, 0), we.unbindTexture();
        },
        this.resetState = function () {
          k = 0, _ = 0, A = null, we.reset(), It.reset();
        };
    }
    get coordinateSystem() {
      return Jl;
    }
  };
  var Oa = class extends zk {
    constructor(t = 1, o = 1, i = {}) {
      super(t, o, i);
      this.isWebGLRenderTarget = true;
    }
  };
  var S_ = class extends Bs {
    constructor(t, o, i, n, a, s, l, c, d) {
      super(t, o, i, n, a, s, l, c, d);
      this.isCanvasTexture = true;
      this.needsUpdate = true;
    }
  };
  var o0 = class extends $k {
    constructor(e, t) {
      let i = t.font.generateShapes(e, t.size),
        n = { ...t, depth: t.height !== void 0 ? t.height : 50 };
      n.bevelThickness === void 0 && (n.bevelThickness = 10),
        n.bevelSize === void 0 && (n.bevelSize = 8),
        n.bevelEnabled === void 0 && (n.bevelEnabled = false),
        super(i, n);
    }
  };
  var i0 = class {
    constructor(e) {
      this.data = e;
    }
    generateShapes(e, t = 100) {
      let o = [], i = Lse(e, t, this.data);
      for (let n = 0, a = i.length; n < a; n++) {
        o.push(...i[n].toShapes());
      }
      return o;
    }
  };
  function Lse(r, e, t) {
    let o = Array.from(r),
      i = e / t.resolution,
      n = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) *
        i,
      a = [],
      s = 0,
      l = 0;
    for (let c = 0; c < o.length; c++) {
      let d = o[c];
      if (
        d === `
`
      ) s = 0, l -= n;
      else {
        let p = Pse(d, i, s, l, t);
        s += p.offsetX, a.push(p.path);
      }
    }
    return a;
  }
  function Pse(r, e, t, o, i) {
    let n = i.glyphs[r] || i.glyphs["?"];
    if (!n) {
      throw new Error(
        'THREE.Font: character "' + r +
          '" does not exists in font family ' + i.familyName + ".",
      );
    }
    let a = new Kk(), s, l, c, d, p, h;
    if (n.o) {
      let u = n._cachedOutline || (n._cachedOutline = n.o.split(" "));
      for (let f = 0, y = u.length; f < y;) {
        let C = u[f++];
        switch (C) {
          case "m":
            s = u[f++] * e + t, l = u[f++] * e + o, a.moveTo(s, l);
            break;
          case "l":
            s = u[f++] * e + t, l = u[f++] * e + o, a.lineTo(s, l);
            break;
          case "q":
            c = u[f++] * e + t,
              d = u[f++] * e + o,
              p = u[f++] * e + t,
              h = u[f++] * e + o,
              a.quadraticCurveTo(p, h, c, d);
            break;
          default:
            if (C) throw new Error("unrecognized action: " + C);
        }
      }
    }
    return { offsetX: n.ha * e, path: a };
  }
  qt();
  var { abs: g7, PI: m7 } = Math;
  function x7(r, e, t, o) {
    let i = f7(r, t, o), n = f7(e, t, o);
    return v7(i, n);
  }
  function f7(r, e, t) {
    let o = { x: (r.x - e.x) / t, y: -(r.y - e.y) / t },
      i = o.x * o.x + o.y * o.y,
      n = Math.sqrt(i);
    return i < 1
      ? new ye(o.x, -o.y, Math.sqrt(1 - i))
      : new ye(o.x / n, -o.y / n, 0);
  }
  function w7(r, e, t) {
    let o = b7(r, t), i = b7(e, t);
    return v7(o, i);
  }
  function b7(r, e) {
    let t = { x: r.x - e.x, y: r.y - e.y }, o = Math.hypot(t.x, t.y);
    return o === 0 ? new ye(1, 0, 0) : new ye(t.x / o, t.y / o, 0);
  }
  function Vse(r) {
    let e = r.elements,
      t = new ye(e[3], e[4], e[5]).normalize(),
      o = new ye(e[6], e[7], e[8]),
      i = new ye().crossVectors(t, o).normalize();
    o.crossVectors(i, t).normalize();
    let n = new Po();
    return n.set(i.x, t.x, o.x, i.y, t.y, o.y, i.z, t.z, o.z), n;
  }
  function Oy(r, e) {
    let t = r.clone().transpose(),
      o = new Po().multiplyMatrices(t, e),
      i = new Po().multiplyMatrices(o, r);
    return Vse(i);
  }
  function v7(r, e) {
    let t = e.clone();
    t.cross(r);
    let o = t.length(), i = e.dot(r), n = 1 - i;
    o > 0 && (t.x = t.x / o, t.y = t.y / o, t.z = t.z / o);
    let a = new Po();
    return a.set(
      n * t.z * t.z + i,
      n * t.z * t.x - o * t.y,
      n * t.y * t.z + o * t.x,
      n * t.z * t.x + o * t.y,
      n * t.x * t.x + i,
      n * t.y * t.x - o * t.z,
      n * t.y * t.z - o * t.x,
      n * t.y * t.x + o * t.z,
      n * t.y * t.y + i,
    ),
      a;
  }
  var { sin: n0, cos: E_ } = Math;
  function zd() {
    let r = Ry(-(11 * Math.PI) / 16);
    return fm(Math.PI / 8).multiply(r);
  }
  function T_() {
    let r = Ry(-Math.PI / 2);
    return fm(Math.PI / 2).multiply(r);
  }
  function Ry(r) {
    let e = new Po();
    return e.set(E_(r), -n0(r), 0, n0(r), E_(r), 0, 0, 0, 1), e;
  }
  function fm(r) {
    let e = new Po();
    return e.set(E_(r), 0, -n0(r), 0, 1, 0, n0(r), 0, E_(r)), e;
  }
  function fO(r) {
    let e = r.elements, t = e[0] + e[4] + e[8];
    if (t < 3) {
      let o = Math.acos(.5 * (t - 1)),
        i = 2 * n0(o),
        n = (e[5] - e[7]) / i,
        a = (e[6] - e[2]) / i,
        s = (e[1] - e[3]) / i;
      return { axis: new ye(n, a, s), angle: o };
    }
    return { axis: new ye(0, 0, -1), angle: 0 };
  }
  function C7(r, e) {
    let t = __dcg_shared_module_exports__["dd"](r, e), o = new Po();
    return o.elements = t, o;
  }
  function y7(r, e) {
    return e * Math.floor(r / e + .5);
  }
  function D_(r) {
    let e = Df ? .06 : .03,
      t = new Nt().setFromMatrix3(r),
      { y: o, z: i } = new Fs(0, 0, 0, "YXZ").setFromRotationMatrix(t),
      n = y7(o, m7 / 2),
      a = y7(i, m7 / 2),
      s = g7(o - n) < e,
      l = g7(i - a) < e,
      c;
    if (s || l) {
      let d = s ? n : o,
        p = l ? a : i,
        h = new Fs(0, d, p, "YXZ"),
        u = new Nt().makeRotationFromEuler(h);
      c = new Po().setFromMatrix4(u);
    } else c = r;
    return { matrix: c, isXYsnapped: l, isZsnapped: s };
  }
  qt();
  var Ose = .1,
    __ = class {
      constructor(e, t) {
        this.viewport = e;
        this.grapher3d = t;
        this.s = Ip(() => this.grapher3d.settings.config.language);
      }
      isDefaultViewportRestored() {
        return this.grapher3d.isDefaultDomain();
      }
      getCurrentDomain() {
        var e, t;
        return {
          xmin: this.viewport.xmin,
          xmax: this.viewport.xmax,
          ymin: this.viewport.ymin,
          ymax: this.viewport.ymax,
          zmin: (e = this.viewport.zmin) != null
            ? e
            : __dcg_shared_module_exports__["xc"].zmin,
          zmax: (t = this.viewport.zmax) != null
            ? t
            : __dcg_shared_module_exports__["xc"].zmax,
        };
      }
      animateToDomain(e) {
        let t = this.getCurrentDomain(), o = this.grapher3d.transition;
        o.isZooming ||
          (o.isZooming = true,
            o.startTime = window.performance.now(),
            o.duration = 150,
            o.zoom0 = t,
            o.zoom1 = e,
            this.grapher3d.startZoom());
      }
      setDefaultViewport() {
        this.animateToDomain(new __dcg_shared_module_exports__["Yd"]()),
          xe(this.s("graphing-calculator-narration-viewport-default"));
      }
      setViewport(e) {
        var n, a;
        if (
          !e.isValid({ xAxisScale: "linear", yAxisScale: "linear" }) ||
          !e.isZValid()
        ) return;
        let o = e.toObject();
        e = Br.fromObject(
          Nse({
            ...o,
            zmin: (n = o.zmin) != null
              ? n
              : __dcg_shared_module_exports__["xc"].zmin,
            zmax: (a = o.zmax) != null
              ? a
              : __dcg_shared_module_exports__["xc"].zmax,
          }),
        ),
          this.grapher3d.controller.getGrapher2d().viewportController
            .setViewport(e),
          this.viewport = e,
          this.grapher3d.controller.requestRedrawGraph();
      }
      getViewport() {
        return this.viewport;
      }
      setScreen() {}
      zoom(e) {
        let t = this.getCurrentDomain(), o = this.grapher3d.transition;
        switch (e) {
          case "in":
            {
              if (o.isZooming) return;
              o.isZooming = true,
                o.startTime = window.performance.now(),
                o.duration = 150,
                o.zoom0 = t,
                o.zoom1 = a0(t, 1 / 2),
                this.grapher3d.startZoom(),
                xe(
                  this.s(
                    "graphing-calculator-narration-viewport-zoom-in",
                  ),
                );
            }
            break;
          case "out":
            {
              if (o.isZooming) return;
              o.isZooming = true,
                o.startTime = window.performance.now(),
                o.duration = 150,
                o.zoom0 = t,
                o.zoom1 = yO(t, 2, Ose),
                this.grapher3d.startZoom(),
                xe(
                  this.s(
                    "graphing-calculator-narration-viewport-zoom-out",
                  ),
                );
            }
            break;
          case "square":
            this.grapher3d.settings.setProperty("squareAxes", true),
              this.animateToDomain(Rse(this.getCurrentDomain())),
              xe(
                this.s(
                  "graphing-calculator-narration-viewport-zoom-square",
                ),
              );
            break;
          case "default":
            this.setDefaultViewport();
            break;
          case "default3dOrientation":
            this.animateToOrientation(zd()),
              xe(
                this.s(
                  "graphing-calculator-narration-viewport-zoom-3d-default",
                ),
              );
            break;
          case "xy3dOrientation":
            this.animateToOrientation(T_()),
              xe(
                this.s(
                  "graphing-calculator-narration-viewport-zoom-3d-xy",
                ),
              );
            break;
          case "recenter":
            this.animateToDomain(Fse(this.getCurrentDomain())),
              xe(
                this.s(
                  "graphing-calculator-narration-viewport-zoom-recenter",
                ),
              );
            break;
          default:
        }
      }
      animateToOrientation(e) {
        this.grapher3d.settings.setProperty("speed3D", 0),
          this.grapher3d.settings.setProperty("worldRotation3D", [
            ...e.elements,
          ]),
          this.grapher3d.controls.animateToOrientation(e);
      }
      zoomSquareImmediately() {}
      remove() {}
      beginPanning() {}
      zoomCustom(e) {}
      getProjection() {
        return this.grapher3d.getProjection();
      }
      panFromKeyboard(e) {}
    };
  function a0(r, e, t) {
    let { xwidth: o, ywidth: i, zwidth: n } = Bse(r);
    return S7(r, { xwidth: o * e, ywidth: i * e, zwidth: n * e }, t);
  }
  function yO(r, e, t, o = new ye(0, 0, 0)) {
    let i = new ye(
        (r.xmax + r.xmin) / 2,
        (r.ymax + r.ymin) / 2,
        (r.zmax + r.zmin) / 2,
      ),
      n = new ye(
        o.x < i.x ? r.xmax : r.xmin,
        o.y < i.y ? r.ymax : r.ymin,
        o.z < i.z ? r.zmax : r.zmin,
      ),
      a = 0;
    for (let d of ["x", "y", "z"]) {
      Math.abs(n[d] - o[d]) > Math.abs(a) && i[d] !== o[d] &&
        (a = (n[d] - o[d]) / (i[d] - o[d]));
    }
    let s = i.clone().sub(o).multiplyScalar(a).add(o);
    s.lerp(i, 1 - t);
    for (let d of ["x", "y", "z"]) {
      let p = r[`${d}min`], h = r[`${d}max`];
      p === 0 || h === 0 ? s[d] = 0 : p === -h && (s[d] = i[d]);
    }
    let l = a0(r, e, s),
      c = new ye(
        (l.xmax + l.xmin) / 2,
        (l.ymax + l.ymin) / 2,
        (l.zmax + l.zmin) / 2,
      );
    return c.x < o.x != i.x < o.x &&
      (l.xmax = .5 * (l.xmax - l.xmin), l.xmin = -l.xmax),
      c.y < o.y != i.y < o.y &&
      (l.ymax = .5 * (l.ymax - l.ymin), l.ymin = -l.ymax),
      c.z < o.z != i.z < o.z &&
      (l.zmax = .5 * (l.zmax - l.zmin), l.zmin = -l.zmax),
      l;
  }
  function Rse(r) {
    let e = r.xmax - r.xmin;
    return S7(r, { xwidth: e, ywidth: e, zwidth: e });
  }
  function S7(r, { xwidth: e, ywidth: t, zwidth: o }, i) {
    let n = new __dcg_shared_module_exports__["Yd"]();
    return [n.xmin, n.xmax] = bO(
      r.xmin,
      r.xmax,
      e,
      i == null ? void 0 : i.x,
    ),
      [n.ymin, n.ymax] = bO(r.ymin, r.ymax, t, i == null ? void 0 : i.y),
      [n.zmin, n.zmax] = bO(r.zmin, r.zmax, o, i == null ? void 0 : i.z),
      n;
  }
  function Fse(r) {
    let e = new __dcg_shared_module_exports__["Yd"]();
    return e.xmax = .5 * (r.xmax - r.xmin),
      e.xmin = -e.xmax,
      e.ymax = .5 * (r.ymax - r.ymin),
      e.ymin = -e.ymax,
      e.zmax = .5 * (r.zmax - r.zmin),
      e.zmin = -e.zmax,
      e;
  }
  function Nse(r) {
    let e = new __dcg_shared_module_exports__["Yd"]();
    return [e.xmin, e.xmax] = k_(r.xmin, r.xmax),
      [e.ymin, e.ymax] = k_(r.ymin, r.ymax),
      [e.zmin, e.zmax] = k_(r.zmin, r.zmax),
      e;
  }
  var Mc = 134e3, E7 = 134e-6;
  function T7(r, e, t, o) {
    return t = __dcg_shared_module_exports__["clamp"](t, E7, Mc),
      o = o != null ? o : r === 0 || e === 0 ? 0 : (r + e) / 2,
      r = o + (r - o) / (e - r) * t,
      e = r + t,
      [r, e];
  }
  function bO(r, e, t, o) {
    return [r, e] = T7(r, e, t, o), k_(r, e);
  }
  function k_(r, e) {
    r < -Mc / 2 &&
    (e < -Mc / 4 && (e += -Mc / 2 - r, e = Math.min(Mc / 2, e)), r = -Mc / 2),
      e > Mc / 2 &&
      (r > Mc / 4 && (r += Mc / 2 - e, r = Math.max(-Mc / 2, r)), e = Mc / 2);
    let t = E7 * Math.max(1, Math.abs(r), Math.abs(e));
    return e - r < t ? T7(r, e, t) : [r, e];
  }
  function Bse(r) {
    let { xmin: e, xmax: t, ymin: o, ymax: i, zmin: n, zmax: a } = r;
    return { xwidth: t - e, ywidth: i - o, zwidth: a - n };
  }
  var { abs: Gc, min: I7, acos: D7, hypot: A7, PI: Lc } = Math,
    Use = 1e3,
    zse = .2,
    tu = { NONE: -1, ROTATE: 0 },
    qse = { type: "start" },
    Hse = { type: "end" },
    k7 = 50,
    Kse = 5 * Math.PI / 180,
    I_ = class extends Ns {
      constructor(t, o, i) {
        super();
        this.worldRotation3D = zd();
        this.unsnappedRotation = new Po();
        this.axis3D = [0, 0, 1];
        this.speed3D = 0;
        this.touches = [];
        this.spinningWorld = t,
          this.copyWorldRotationToWorld(),
          this.domElement = i !== void 0 ? i : document,
          this.grapher3d = o,
          this.state = tu.NONE,
          this.lastMovedTime = 0,
          this.lastRotateTime = 0,
          this.lastWheelEventTime = 0,
          this.keyStillDown = false,
          this.lastAngle = 0,
          this.useVirtualSphere = false,
          this.startedOutsideVirtualSphere = false,
          this.isXYsnapped = false,
          this.isZsnapped = false,
          this.dimensions = () => {
            let a = this.domElement === document
                ? this.domElement.body
                : this.domElement,
              s = a.clientWidth,
              l = a.clientHeight,
              c = new Tt(s / 2, l / 2),
              d = Math.min(s, l) / 2;
            return { center: c, radius: d, height: l, width: s };
          },
          this.onContextMenu = (a) => {
            this.grapher3d.controller.dispatch({
              type: "blur-focus-location",
              location: this.grapher3d.controller.getFocusLocation(),
            });
          },
          this.onTapStart = (a) => {
            var v, w;
            let s = a, l = Object.keys(this.touches).length;
            this.touches = xO(s.touches);
            let c = Object.keys(this.touches).length,
              d = o.webglLayer.getPressedAction() !== void 0;
            if (l < 2 && c === 2 && !d) {
              this.startPinchZoom();
              return;
            }
            if (c > 1) return;
            let { top: p, left: h } = Gl(this.grapher3d.elt),
              u = this.touches[0].pageX - h,
              f = this.touches[0].pageY - p;
            if (
              this.isPinchZooming() ||
              (v = this.grapher3d) != null && v.transition.isOrienting
            ) return;
            this.grapher3d.controller.dispatch({
              type: "set-none-selected",
            }),
              o.webglLayer.setMouse({ x: u, y: f }),
              o.webglLayer.pickAtMouseAndReadResults();
            let y = (w = o.webglLayer.getPickResult()) == null ? void 0 : w.id;
            if (y) {
              let S = o.controller.getItemModel(y);
              if (S && S.type === "expression" && $n(S)) return;
            }
            this.state = tu.ROTATE, this.speed3D = 0, this.invert = void 0;
            let { center: C, radius: E } = this.dimensions();
            this.startedOutsideVirtualSphere = A7(u - C.x, f - C.y) >= E,
              this.unsnappedRotation.copy(this.worldRotation3D),
              this.useVirtualSphere =
                s.shiftKey && this.grapher3d.settings.config.beta3d ||
                !this.isHorizonLevel(),
              this.state !== tu.NONE &&
              (this.grapher3d.isDragging = true,
                ee(document).on("dcg-tapmove", this.onTapMove),
                ee(document).on("dcg-tapend", this.onTapUp),
                ee(document).on("dcg-tapcancel", this.onTapUp),
                this.dispatchEvent(qse));
          },
          this.onTapMove = (a) => {
            var E;
            let s = a,
              l = s.changedTouches[0].identifier,
              c = s.changedTouches[0],
              d = this.touches.find((v) => v.identifier === l) || c;
            this.touches = xO(s.touches);
            let { top: p, left: h } = Gl(this.grapher3d.elt),
              u = new Tt(d.pageX - h, d.pageY - p),
              f = new Tt(c.pageX - h, c.pageY - p);
            if (this.isPinchZooming()) {
              this.updatePinchZoom();
              return;
            }
            if (
              (E = this.grapher3d) != null && E.transition.isOrienting ||
              this.state != tu.ROTATE
            ) return;
            let y = f.x - u.x, C = f.y - u.y;
            if (y !== 0 || C !== 0) {
              let v,
                { center: w, radius: S, height: k, width: _ } = this
                  .dimensions();
              if (this.useVirtualSphere) {
                v = this.startedOutsideVirtualSphere
                  ? w7(f, u, w)
                  : x7(f, u, w, S),
                  v = Oy(this.worldRotation3D, v),
                  this.setWorldRotation(this.worldRotation3D.multiply(v));
              } else {
                if (this.invert === void 0) {
                  this.invert = f.y > w.y ? 1 : -1;
                  let Z = new ye(0, 0, 1).applyMatrix3(
                    this.worldRotation3D,
                  );
                  Z.x > .7 && (this.invert *= -1),
                    Gc(Z.x) < .7 && (this.invert = Z.z < -.7 ? -1 : 1);
                }
                let x = y / _ * Lc * this.invert,
                  L = C / k * Lc,
                  V = Ry(x),
                  R = fm(L);
                R = Oy(this.unsnappedRotation, R),
                  Gc(C) > 2 * Gc(y)
                    ? this.unsnappedRotation.multiply(R)
                    : Gc(y) > 2 * Gc(C)
                    ? this.unsnappedRotation.multiply(V)
                    : this.unsnappedRotation.multiply(R).multiply(V);
                let { matrix: N, isXYsnapped: M, isZsnapped: F } = D_(
                  this.unsnappedRotation,
                );
                this.setWorldRotation(N),
                  this.isXYsnapped = M,
                  this.isZsnapped = F,
                  R = fm(L),
                  R = Oy(this.worldRotation3D, R),
                  v = Gc(C) > Gc(y) ? R : V;
              }
              let { axis: A, angle: P } = fO(v),
                O = s.timeStamp,
                U = (O - this.lastMovedTime) * .001;
              this.axis3D = [A.x, A.y, A.z],
                this.useVirtualSphere && this.snapSpinAxisIfClose();
              let z = 240 * (Lc / 180);
              this.speed3D = __dcg_shared_module_exports__["clamp"](
                P / U,
                -z,
                z,
              ),
                this.lastAngle = 0,
                this.lastMovedTime = O,
                Gc(this.speed3D) < Kse && (this.speed3D = 0);
            } else {this.lastMovedTime + k7 < s.timeStamp &&
                (this.speed3D = 0);}
          },
          this.onTapUp = (a) => {
            var d;
            let s = a, l = Object.keys(this.touches).length;
            this.touches = xO(s.touches);
            let c = Object.keys(this.touches).length;
            l === 2 && c < 2 && this.isPinchZooming() &&
            this.stopPinchZoom(),
              !((d = this.grapher3d) != null &&
                d.transition.isOrienting) &&
              (c > 0 ||
                (this.lastMovedTime + k7 < s.timeStamp &&
                  !this.isPinchZooming() && (this.speed3D = 0),
                  this.grapher3d.isDragging = false,
                  ee(document).off("dcg-tapmove", this.onTapMove),
                  ee(document).off("dcg-tapend", this.onTapUp),
                  ee(document).off("dcg-tapcancel", this.onTapUp),
                  this.dispatchEvent(Hse),
                  this.grapher3d.debounceUserRequestedRotationChange(),
                  this.state = tu.NONE,
                  this.grapher3d.controller.dispatch({
                    type: "render",
                  })));
          },
          this.onMouseWheel = (a) => {
            var S, k;
            let s = a;
            if (
              this.state !== tu.NONE || this.isLocked() || s.deltaY === 0
            ) return;
            s.preventDefault(),
              this.lastWheelEventTime === 0 && this.grapher3d.startZoom(),
              this.lastWheelEventTime = window.performance.now();
            let l = this.grapher3d.webglLayer.domain(),
              c = this.grapher3d.webglLayer.getMouse(),
              d = Date.now(),
              p = this.speed3D !== 0,
              h = s.deltaY < 0 ? "in" : "out",
              u = this.currentZoomAction &&
                d - this.currentZoomAction.lastChangeTime > Use;
            if (
              !this.currentZoomAction ||
              this.currentZoomAction.input.type !== "pointer" ||
              this.currentZoomAction.input.x !==
                (c == null ? void 0 : c.x) ||
              this.currentZoomAction.input.y !==
                (c == null ? void 0 : c.y) ||
              this.currentZoomAction.isSpinning !== p ||
              h === "in" &&
                this.currentZoomAction.initialDirection === "out" ||
              u
            ) {
              let _ = h === "in"
                ? (S = this.grapher3d.webglLayer
                    .getZoomScrollWheelPickResult()) == null
                  ? void 0
                  : S.point
                : void 0;
              this.currentZoomAction = {
                lastChangeTime: d,
                start: l,
                input: { type: "pointer", ...c },
                isSpinning: p,
                center: _ == null ? void 0 : _.clone(),
                initialDirection: h,
              };
            } else {this.currentZoomAction &&
                (this.currentZoomAction.lastChangeTime = d);}
            let f = (k = this.currentZoomAction) == null ? void 0 : k.center,
              y = this.currentZoomAction.start.xmax -
                this.currentZoomAction.start.xmin,
              C = l.xmax - l.xmin;
            if (
              this.currentZoomAction.initialDirection === "in" &&
              h === "out" && C >= y
            ) {
              let _ = this.currentZoomAction.start;
              delete this.currentZoomAction, l = _, f = void 0;
            }
            if (!f) {
              let _ = l.xmin <= 0 && l.xmax >= 0,
                A = l.ymin <= 0 && l.ymax >= 0,
                P = l.zmin <= 0 && l.zmax >= 0;
              _ && A && P && (f = new ye(0, 0, 0));
            }
            let E = 1.05, v;
            h === "out" && (!f || f.lengthSq() === 0)
              ? v = yO(l, E, zse)
              : v = a0(l, s.deltaY < 0 ? 1 / E : E, f);
            let w = new Br(
              v.xmin,
              v.xmax,
              v.ymin,
              v.ymax,
              v.zmin,
              v.zmax,
            );
            this.updateViewport(w),
              this.copyWorldRotationToWorld(),
              this.grapher3d.webglLayer.updateAxes(),
              this.grapher3d.controller.dispatch({ type: "render" });
          };
        let n = { passive: false };
        this.onTouchStart = (a) => {
          a.preventDefault();
        },
          this.domElement.addEventListener(
            "touchstart",
            this.onTouchStart,
            n,
          ),
          ee(this.domElement).on("dcg-tapstart", this.onTapStart),
          ee(this.domElement).on("contextmenu", this.onContextMenu),
          this.domElement.addEventListener("wheel", this.onMouseWheel);
      }
      keyUp() {
        this.keyStillDown = false,
          this.speed3D &&
          xe(
            this.grapher3d.controller.s(
              "graphing-calculator-narration-3d-rotation-speed",
              { speed: Math.ceil(this.speed3D * 180 / Lc) },
            ),
          );
      }
      applyTiltFromKeyboard(t, o) {
        var d;
        if (
          this.isPinchZooming() ||
          (d = this.grapher3d) != null && d.transition.isOrienting
        ) return;
        this.grapher3d.controller.dispatch({ type: "set-none-selected" });
        let i = {
            Up: this.grapher3d.controller.s(
              "graphing-calculator-narration-3d-rotate-up",
            ),
            Down: this.grapher3d.controller.s(
              "graphing-calculator-narration-3d-rotate-down",
            ),
            Left: this.grapher3d.controller.s(
              "graphing-calculator-narration-3d-rotate-left",
            ),
            Right: this.grapher3d.controller.s(
              "graphing-calculator-narration-3d-rotate-right",
            ),
          },
          n = (p) => {
            let h = fm(p);
            h = Oy(this.unsnappedRotation, h),
              this.unsnappedRotation.multiply(h);
          },
          a = (p) => {
            this.unsnappedRotation.multiply(Ry(p));
          },
          s = (p) => {
            let h = fm(p);
            return Oy(this.worldRotation3D, h);
          },
          l = (p) => Ry(p);
        if (t === this.lastKeyboardDirection && this.keyStillDown) {
          if (this.speed3D === 0) {
            let p, h = 2 * Lc / 180;
            switch (t) {
              case "Up":
                p = s(-h);
                break;
              case "Down":
                p = s(+h);
                break;
              case "Left":
                p = l(-h);
                break;
              case "Right":
                p = l(+h);
                break;
            }
            let { axis: u, angle: f } = fO(p);
            this.axis3D = [u.x, u.y, u.z], this.speed3D = f;
          } else {
            let p = 240 * (Lc / 180);
            this.speed3D = __dcg_shared_module_exports__["clamp"](
              this.speed3D * 1.1,
              -p,
              p,
            );
          }
        } else if (this.speed3D) {
          this.lastKeyboardDirection = void 0,
            this.keyStillDown = true,
            this.speed3D = 0,
            xe(
              this.grapher3d.controller.s(
                "graphing-calculator-narration-3d-rotation-stopped",
              ),
            );
        } else {
          this.lastKeyboardDirection = t, this.keyStillDown = true, xe(i[t]);
          let p = Lc / 180;
          switch (t) {
            case "Up":
              n(-p);
              break;
            case "Down":
              n(+p);
              break;
            case "Left":
              a(-p);
              break;
            case "Right":
              a(+p);
              break;
          }
          let { matrix: h, isXYsnapped: u, isZsnapped: f } = D_(
            this.unsnappedRotation,
          );
          this.setWorldRotation(h),
            this.isXYsnapped = u,
            this.isZsnapped = f,
            this.lastAngle = 0;
        }
      }
      isPinchZooming() {
        var t;
        return ((t = this.currentZoomAction) == null
          ? void 0
          : t.input.type) === "pinch";
      }
      startPinchZoom() {
        if (this.isLocked() || this.isPinchZooming()) return;
        let t = __dcg_shared_module_exports__["Jc"](this.touches);
        this.grapher3d.controller.dispatch({ type: "set-none-selected" }),
          this.grapher3d.startZoom(),
          this.currentZoomAction = {
            lastChangeTime: Date.now(),
            start: this.grapher3d.webglLayer.domain(),
            center: void 0,
            input: { type: "pinch", pinchZoomStartPositions: t },
            isSpinning: this.speed3D !== 0,
            initialDirection: void 0,
          };
      }
      stopPinchZoom() {
        this.isPinchZooming() &&
          (this.currentZoomAction = void 0,
            this.grapher3d.endZoom(),
            this.grapher3d.controller.dispatch({ type: "render" }));
      }
      updatePinchZoom() {
        var s;
        if (
          ((s = this.currentZoomAction) == null ? void 0 : s.input.type) !==
            "pinch"
        ) return;
        let t = _7(this.currentZoomAction.input.pinchZoomStartPositions),
          i = _7(this.touches) / t;
        if (!isFinite(i)) return;
        let n = a0(this.currentZoomAction.start, 1 / i),
          a = new Br(n.xmin, n.xmax, n.ymin, n.ymax, n.zmin, n.zmax);
        this.updateViewport(a), this.copyWorldRotationToWorld();
      }
      snapSpinAxisIfClose() {
        if (!this.grapher3d.settings.showAxis3D) return;
        let [t, o, i] = this.axis3D, n = .97;
        t > n && (this.axis3D = [1, 0, 0]),
          o > n && (this.axis3D = [0, 1, 0]),
          i > n && (this.axis3D = [0, 0, 1]),
          t < -n && (this.axis3D = [-1, 0, 0]),
          o < -n && (this.axis3D = [0, -1, 0]),
          i < -n && (this.axis3D = [0, 0, -1]);
      }
      copyWorldRotationToWorld() {
        this.spinningWorld.setRotationFromMatrix(
          new Nt().setFromMatrix3(this.worldRotation3D),
        );
      }
      update() {
        return true;
      }
      dispose() {
        ee(this.domElement).off("dcg-tapstart", this.onTapStart),
          ee(document).off("dcg-tapmove", this.onTapMove),
          ee(document).off("dcg-tapend", this.onTapUp),
          ee(document).off("dcg-tapcancel", this.onTapUp),
          this.domElement.removeEventListener("wheel", this.onMouseWheel),
          this.domElement.removeEventListener(
            "touchstart",
            this.onTouchStart,
          );
      }
      setWorldRotation(t) {
        this.worldRotation3D = t, this.copyWorldRotationToWorld();
        let { isXYsnapped: o, isZsnapped: i } = D_(t);
        this.isXYsnapped = o, this.isZsnapped = i;
      }
      isHorizonLevel() {
        let t = new ye(0, 0, 1).applyMatrix3(this.worldRotation3D);
        return Gc(t.y) < 1e-4;
      }
      compareWorldRotationTo(t) {
        let o = new Nt().setFromMatrix3(this.worldRotation3D),
          i = new Nt().setFromMatrix3(t),
          n = new Fs(0, 0, 0, "YXZ").setFromRotationMatrix(o),
          a = new Fs().setFromRotationMatrix(i),
          s = new Ql().setFromEuler(n).normalize(),
          l = new Ql().setFromEuler(a).normalize(),
          c = I7(Gc(s.dot(l)), 1);
        return 2 * D7(c) * (180 / Lc);
      }
      isDefaultOrientation() {
        let t = this.compareWorldRotationTo(zd());
        return this.speed3D === 0 && t < 1;
      }
      isXYPlaneOrientation() {
        let t = this.compareWorldRotationTo(T_());
        return this.speed3D === 0 && t < .001;
      }
      animateToOrientation(t) {
        let o = this.grapher3d;
        this.speed3D = 0;
        let i = o.transition,
          n = new Nt().setFromMatrix3(this.worldRotation3D),
          a = new Nt().setFromMatrix3(t),
          s = new Fs().setFromRotationMatrix(a),
          l = new Fs(0, 0, 0, "YXZ").setFromRotationMatrix(n);
        i.q0.setFromEuler(l), i.q1.setFromEuler(s);
        let c = i.q0.clone().normalize(),
          d = i.q1.clone().normalize(),
          p = 2 * D7(Gc(c.dot(d))) * (180 / Lc);
        i.isOrienting = true,
          i.startTime = window.performance.now(),
          i.duration = 150 *
            __dcg_shared_module_exports__["clamp"](p / 30, 1, 3);
      }
      updateViewport(t) {
        let o = this.grapher3d, i = o.controller.getGrapher2d();
        o.viewportController.setViewport(t),
          o.debounceUserRequestedViewportChange(),
          i.viewportController.setViewport(t),
          i.redrawAllLayersSynchronously(),
          o.webglLayer.updatePlaneMap(),
          o.webglLayer.updateDomainObjects();
      }
      isLocked() {
        return this.grapher3d.controller.getGraphSettings()
          .userLockedViewport;
      }
    },
    A_ = class {
      constructor() {
        this.isZooming = false;
        this.zoom0 = new __dcg_shared_module_exports__["Yd"]();
        this.zoom1 = new __dcg_shared_module_exports__["Yd"]();
        this.isOrienting = false;
        this.q0 = new Ql();
        this.q1 = new Ql();
        this.objectIdExtendingTo3D = void 0;
        this.startTime = 0;
        this.duration = 0;
      }
    };
  function M7(r) {
    let e = r.grapher3d, t = e.transition;
    if (e.settings.threeDMode) {
      if (
        r.lastWheelEventTime != 0 &&
        (window.performance.now() - r.lastWheelEventTime) * .001 > .1 &&
        (r.lastWheelEventTime = 0, e.endZoom()), t.isZooming
      ) {
        let { zoom0: o, zoom1: i } = t,
          n = window.performance.now(),
          a = I7(1, (n - t.startTime) / t.duration),
          s = new Br(
            a * i.xmin + (1 - a) * o.xmin,
            a * i.xmax + (1 - a) * o.xmax,
            a * i.ymin + (1 - a) * o.ymin,
            a * i.ymax + (1 - a) * o.ymax,
            a * i.zmin + (1 - a) * o.zmin,
            a * i.zmax + (1 - a) * o.zmax,
          );
        a >= 1 && (e.endZoom(), t.isZooming = false), r.updateViewport(s);
      }
      if (t.isOrienting) {
        let i = (window.performance.now() - t.startTime) / t.duration;
        if (i >= 1) {
          let n = new Nt().makeRotationFromQuaternion(t.q1);
          r.setWorldRotation(new Po().setFromMatrix4(n)),
            t.isOrienting = false,
            e.controller.dispatch({ type: "render" });
        } else {
          let n = t.q0.clone().slerp(t.q1, i),
            a = new Nt().makeRotationFromQuaternion(n);
          r.setWorldRotation(new Po().setFromMatrix4(a)),
            r.unsnappedRotation.copy(r.worldRotation3D);
        }
      }
      if (t.objectIdExtendingTo3D && t.startTime > 0) {
        let o = r.grapher3d.webglLayer,
          i = t.objectIdExtendingTo3D,
          n = o.domain(),
          { zmin: a, zmax: s } = n,
          c = (window.performance.now() - t.startTime) / t.duration;
        c >= 1
          ? (o.setZboundsOnSurfaces(i, -1 / 0, 1 / 0),
            t.objectIdExtendingTo3D = void 0)
          : o.setZboundsOnSurfaces(i, c * a, c * s),
          e.controller.requestRedrawGraph();
      }
      if (r.speed3D === 0) r.lastRotateTime = window.performance.now();
      else {
        let o = window.performance.now(),
          i = (o - r.lastRotateTime) * .001,
          n = r.lastRotateTime != 0 && i < 2 ? i * r.speed3D : 0;
        if (
          n > 20 * Lc / 180 && (n = 20 * Lc / 180), r.state === tu.NONE
        ) {
          let a = r.axis3D, s = new ye(a[0], a[1], a[2]), l = C7(s, n);
          r.setWorldRotation(r.worldRotation3D.multiply(l)),
            r.unsnappedRotation.copy(r.worldRotation3D);
        }
        r.lastRotateTime = o, r.lastAngle = n;
      }
    }
  }
  function _7(r) {
    return r.length !== 2
      ? NaN
      : A7(r[0].pageX - r[1].pageX, r[0].pageY - r[1].pageY);
  }
  function xO(r) {
    return __dcg_shared_module_exports__["Jc"](r);
  }
  function G7(r, e = .01 * (r.xmax - r.xmin)) {
    return e *= 2,
      Math.abs(r.xmin + r.xmax) <= e && Math.abs(r.ymin + r.ymax) <= e &&
      Math.abs(r.zmin + r.zmax) <= e;
  }
  Ss();
  var wO = [];
  function L7(r) {
    return wO[r] === void 0 && (wO[r] = Wse(r)), wO[r];
  }
  function Wse(r) {
    let e = Math.SQRT1_2,
      t = [0, 0, 1, 0, 0, -1, -e, -e, 0, e, -e, 0, e, e, 0, -e, e, 0],
      o = [
        0,
        3,
        4,
        0,
        4,
        5,
        0,
        5,
        2,
        0,
        2,
        3,
        1,
        4,
        3,
        1,
        5,
        4,
        1,
        2,
        5,
        1,
        3,
        2,
      ];
    function i(n) {
      let a = t.length / 3;
      for (let s = 0; s < a; s++) {
        if (
          n.x === t[3 * s + 0] && n.y === t[3 * s + 1] &&
          n.z === t[3 * s + 2]
        ) return s;
      }
      return t.push(n.x, n.y, n.z), a;
    }
    for (let n = 0; n < r; n++) {
      let a = o.length / 3;
      for (let s = 0; s < a; s++) {
        let l = o[3 * s + 0],
          c = o[3 * s + 1],
          d = o[3 * s + 2],
          p = new __dcg_shared_module_exports__["cd"](
            t[3 * l + 0],
            t[3 * l + 1],
            t[3 * l + 2],
          ),
          h = new __dcg_shared_module_exports__["cd"](
            t[3 * c + 0],
            t[3 * c + 1],
            t[3 * c + 2],
          ),
          u = new __dcg_shared_module_exports__["cd"](
            t[3 * d + 0],
            t[3 * d + 1],
            t[3 * d + 2],
          ),
          f = new __dcg_shared_module_exports__["cd"]().addVectors(p, h)
            .multiply(.5).normalize(),
          y = new __dcg_shared_module_exports__["cd"]().addVectors(h, u)
            .multiply(.5).normalize(),
          C = new __dcg_shared_module_exports__["cd"]().addVectors(u, p)
            .multiply(.5).normalize(),
          E = i(f),
          v = i(y),
          w = i(C);
        o.push(l, E, w, E, c, v, v, d, w),
          o[3 * s + 0] = E,
          o[3 * s + 1] = v,
          o[3 * s + 2] = w;
      }
    }
    return { vertices: new Float32Array(t), indices: new Uint16Array(o) };
  }
  var P7 = {
    name: "FillShader",
    defines: {},
    uniforms: {
      color: { value: new vt(16777215) },
      opacity: { value: 1 },
    },
    vertexShader: `
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    fragmentShader: `
uniform vec3 color;
uniform float opacity;
void main() {
    gl_FragColor = vec4( color, opacity );
}`,
  };
  var M_ = class {
      constructor() {}
      setSize(e, t) {}
      dispose() {}
    },
    $se = new Xp(-1, 1, 1, -1, 0, 1),
    G_ = class {
      constructor(e) {
        let t = new La();
        t.setAttribute(
          "position",
          new Bo([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3),
        ),
          t.setAttribute("uv", new Bo([0, 2, 0, 0, 2, 0], 2)),
          this._mesh = new Ai(t, e);
      }
      dispose() {
        this._mesh.geometry.dispose();
      }
      render(e) {
        e.render(this._mesh, $se);
      }
      get material() {
        return this._mesh.material;
      }
      set material(e) {
        this._mesh.material = e;
      }
    };
  var bl = class extends M_ {
    constructor(t, o = {}, i = "tDiffuse") {
      super();
      this.inputTextureName = i;
      this.uniforms = Sh(t.uniforms),
        this.defines = t.defines ? { ...t.defines } : {},
        this.material = new Zl({
          ...o,
          name: t.name !== void 0 ? t.name : "unspecified",
          defines: this.defines,
          uniforms: this.uniforms,
          vertexShader: t.vertexShader,
          fragmentShader: t.fragmentShader,
        }),
        this.fsTriangle = new G_(this.material);
    }
    render(t, o, i) {
      this.renderFromTexture(t, o, i.texture);
    }
    renderFromTexture(t, o, i) {
      this.uniforms[this.inputTextureName] &&
      (this.uniforms[this.inputTextureName].value = i),
        this.fsTriangle.material = this.material,
        t.setRenderTarget(o),
        this.fsTriangle.render(t);
    }
    dispose() {
      this.material.dispose(), this.fsTriangle.dispose();
    }
  };
  function L_(
    r,
    e,
    t = 0,
    o = 0,
    i = e.width,
    n = e.height,
    a = new Uint8ClampedArray(4 * i * n),
  ) {
    return r.readRenderTargetPixels(e, t, o, i, n, a), a;
  }
  function l0(r, e, t, o) {
    let i = 4 * (o * e + t);
    return [r[i], r[i + 1], r[i + 2], r[i + 3]];
  }
  var s0 = new Uint8Array(4), jse = new Float32Array(s0.buffer);
  function P_([r, e, t, o]) {
    return s0[0] = o, s0[1] = t, s0[2] = e, s0[3] = r, jse[0];
  }
  function Yse(r) {
    let e = r.getContext();
    if (!(e instanceof WebGL2RenderingContext)) {
      throw new Error("WebGL2 is required for waitForFullFlush");
    }
    return e;
  }
  async function V7(r) {
    let e = Yse(r), t = e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE, 0);
    if (!t) throw new Error("Failed to create sync object");
    e.flush();
    let o = await O7(e, t, 0, 0);
    return e.deleteSync(t), o;
  }
  function O7(r, e, t, o) {
    let i = performance.now();
    return new Promise((n, a) => {
      function s() {
        let l = r.clientWaitSync(e, t, 0);
        if (l === r.WAIT_FAILED) {
          a();
          return;
        }
        if (l === r.TIMEOUT_EXPIRED) {
          i = performance.now(), setTimeout(s, o);
          return;
        }
        n([i, performance.now()]);
      }
      s();
    });
  }
  async function Xse(r, e, t, o, i, n, a) {
    let s = r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE, 0);
    if (!s) throw new Error("Failed to create sync object");
    r.flush(),
      await O7(r, s, 0, 10),
      r.deleteSync(s),
      r.bindBuffer(e, t),
      r.getBufferSubData(e, o, i, n, a),
      r.bindBuffer(e, null);
  }
  async function R7(r, e, t, o, i, n, a, s) {
    let l = r.createBuffer();
    if (!l) throw new Error("Failed to create buffer");
    return r.bindBuffer(r.PIXEL_PACK_BUFFER, l),
      r.bufferData(r.PIXEL_PACK_BUFFER, s.byteLength, r.STREAM_READ),
      r.readPixels(e, t, o, i, n, a, 0),
      r.bindBuffer(r.PIXEL_PACK_BUFFER, null),
      await Xse(r, r.PIXEL_PACK_BUFFER, l, 0, s),
      r.deleteBuffer(l),
      s;
  }
  var vO;
  function F7() {
    if (vO) return vO;
    let r = new bl(P7), e = 1, t = 1, o = 1, i = 0, n = r.material;
    n.uniforms.color.value = new vt().setRGB(e, t, o),
      n.uniforms.opacity.value = i,
      n.blending = vk,
      n.blendEquation = Od,
      n.blendSrc = Sk,
      n.blendDst = Ck;
    let a = new Vy(),
      s = a.getContext(),
      l = [Xl, Sy, Vn],
      c = [s.FLOAT, s.HALF_FLOAT, s.UNSIGNED_BYTE],
      d = [new Float32Array(4), new Uint16Array(4), new Uint8Array(4)],
      p = [1, 15360, 255],
      h = [];
    for (let u = 0; u < l.length; u++) {
      let f = new Oa(1, 1, {
        minFilter: Rd,
        magFilter: Rd,
        type: l[u],
        format: Nd,
        stencilBuffer: false,
        depthBuffer: true,
      });
      r.render(a, f, new Oa()), s.readPixels(0, 0, 1, 1, s.RGBA, c[u], d[u]);
      let y = [...d[u]];
      y[0] /= p[u], y[1] /= p[u], y[2] /= p[u], y[3] /= p[u];
      let C = (v, w, S = .01) => v < w + S && v > w - S,
        E = s.checkFramebufferStatus(s.FRAMEBUFFER) ===
          s.FRAMEBUFFER_COMPLETE;
      E = E && C(y[0], e),
        E = E && C(y[1], t),
        E = E && C(y[2], o),
        E = E && C(y[3], i),
        E = E || u === l.length - 1,
        f.dispose(),
        E && h.push(l[u]);
    }
    return r.dispose && r.dispose(), vO = h, h;
  }
  var CO;
  function Jse() {
    if (!CO) {
      let r = document.createElement("div");
      r.className = "dcg-3d-debug-root", document.body.appendChild(r), CO = r;
    }
    return CO;
  }
  var V_ = class {
      constructor({ filter: e }) {
        this.canvases = {};
        e
          ? (this.enabled = true, this.filter = new RegExp(e))
          : this.enabled = false;
      }
      removeUnused() {
        for (let e in this.canvases) {
          this.canvases[e].used
            ? this.canvases[e].used = false
            : (this.canvases[e].container.remove(), delete this.canvases[e]);
        }
      }
      get(e, t) {
        let o = t ? `${e} ${t}` : e;
        if (!(!this.enabled || !this.filter.test(o))) {
          return this.canvases[e] || (this.canvases[e] = new SO()),
            this.canvases[e].setLabel(o),
            this.canvases[e].used = true,
            this.canvases[e];
        }
      }
    },
    SO = class {
      constructor() {
        this.container = document.createElement("div"),
          this.container.className = "dcg-3d-debug-container",
          this.canvas = document.createElement("canvas"),
          this.container.appendChild(this.canvas),
          Jse().appendChild(this.container);
      }
      setLabel(e) {
        this.container.setAttribute("dcg-label", e);
      }
      renderRawData(e, t, o, i) {
        var a;
        let n = new ImageData(e, t, o);
        this.canvas.width = t,
          this.canvas.height = o,
          this.container.style.width = t * i + "px",
          this.container.style.height = o * i + "px",
          (a = this.canvas.getContext("2d")) == null ||
          a.putImageData(n, 0, 0);
      }
      renderFromTarget(e, t, o) {
        this.renderRawData(L_(e, t), t.width, t.height, o);
      }
    };
  var N7 = `{
"glyphs": {
"x": {
"x_min": 0,
"x_max": 675,
"ha": 764,
"o": "m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 "
},
"y": {
"x_min": 0,
"x_max": 684.78125,
"ha": 771,
"o": "m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 "
},
"z": {
"x_min": -0.015625,
"x_max": 613.890625,
"ha": 697,
"o": "m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 "
}
},
"cssFontWeight": "normal",
"ascender": 1189,
"underlinePosition": -100,
"cssFontStyle": "normal",
"boundingBox": { "yMin": -334, "xMin": -111, "yMax": 1189, "xMax": 1672 },
"resolution": 1000,
"original_font_information": {
"postscript_name": "Helvetiker-Regular",
"version_string": "Version 1.00 2004 initial release",
"vendor_url": "http://www.magenta.gr/",
"full_font_name": "Helvetiker",
"font_family_name": "Helvetiker",
"copyright": "Copyright (c) \u039Cagenta ltd, 2004",
"description": "",
"trademark": "",
"designer": "",
"designer_url": "",
"unique_font_identifier": "\u039Cagenta ltd:Helvetiker:22-10-104",
"license_url": "http://www.ellak.gr/fonts/MgOpen/license.html",
"license_description": "Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\\"Fonts\\") and associated documentation files (the \\"Font Software\\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \\r\\n\\r\\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\\r\\n\\r\\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \\"MgOpen\\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\\r\\n\\r\\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \\"MgOpen\\" name.\\r\\n\\r\\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \\r\\n\\r\\nTHE FONT SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.",
"manufacturer_name": "\u039Cagenta ltd",
"font_sub_family_name": "Regular"
},
"descender": -334,
"familyName": "Helvetiker",
"lineHeight": 1522,
"underlineThickness": 50
}
`;
  var B7 = `// License: MIT License (c) 2014 Mikola Lysenko
// https://github.com/mikolalysenko/glsl-read-float/blob/master/index.glsl

#define FLOAT_MAX  1.70141184e38
#define FLOAT_MIN  1.17549435e-38

lowp vec4 encode_float(highp float v) {
highp float av = abs(v);

//Handle special cases
if(av < FLOAT_MIN) {
return vec4(0.0, 0.0, 0.0, 0.0);
} else if(v > FLOAT_MAX) {
return vec4(127.0, 128.0, 0.0, 0.0) / 255.0;
} else if(v < -FLOAT_MAX) {
return vec4(255.0, 128.0, 0.0, 0.0) / 255.0;
}

highp vec4 c = vec4(0,0,0,0);

//Compute exponent and mantissa
highp float e = floor(log2(av));
highp float m = av * pow(2.0, -e) - 1.0;

//Unpack mantissa
c[1] = floor(128.0 * m);
m -= c[1] / 128.0;
c[2] = floor(32768.0 * m);
m -= c[2] / 32768.0;
c[3] = floor(8388608.0 * m);

//Unpack exponent
highp float ebias = e + 127.0;
c[0] = floor(ebias / 2.0);
ebias -= c[0] * 2.0;
c[1] += floor(ebias) * 128.0;

//Unpack sign bit
c[0] += 128.0 * step(0.0, -v);

//Scale back to range
return c / 255.0;
}
`;
  var Fy = `
uniform int uDepthPeel; // 1 or 0
uniform vec2 uInverseScreenSize;
uniform highp sampler2D uOpaqueDepthTexture;
uniform highp sampler2D uPrevDepthTexture;
uniform int uDepthPeelLayer;
uniform float uDepthOffset;
`,
    Ny = `
if (uDepthPeel != 0) {
vec2 screenPos = gl_FragCoord.xy * uInverseScreenSize;
float opaqueDepth = texture2D(uOpaqueDepthTexture, screenPos).x;
if (opaqueDepth + uDepthOffset - gl_FragCoord.z < 0.0) {
discard;
}

if(uDepthPeelLayer != 0){
vec4 texel = texture2D(uPrevDepthTexture,screenPos);
float prevDepth = texel.x;
if(prevDepth + uDepthOffset - gl_FragCoord.z >= 0. ){
discard;
}
}
}
`;
  var gs = {
    Default: 0,
    PickingObjectId: 1,
    PickingX: 2,
    PickingY: 3,
    PickingZ: 4,
    Depth: 5,
  };
  function O_() {
    return {
      zMinForAnimation: { value: -1 / 0 },
      zMaxForAnimation: { value: 1 / 0 },
      clip_x: { value: true },
      clip_y: { value: true },
      clip_z: { value: true },
      NaN: { value: NaN },
      Infinity: { value: 1 / 0 },
    };
  }
  var EO = `
#ifdef DCG_SUPPORTS_PICKING
uniform vec4 pickingColor;
${B7}
#endif
`,
    R_ = `#ifdef DCG_SUPPORTS_PICKING
if (dcgRenderMode == ${gs.PickingObjectId}) {
#if defined(USE_INSTANCING_PICKINGCOLOR) || defined(USE_VERTEX_PICKING_COLOR)
gl_FragColor = vPickingColor;
#else
gl_FragColor = pickingColor;
#endif
return;
} else if (dcgRenderMode == ${gs.PickingX}) {
gl_FragColor = encode_float(vPosition.x);
return;
} else if (dcgRenderMode == ${gs.PickingY}) {
gl_FragColor = encode_float(vPosition.y);
return;
} else if (dcgRenderMode == ${gs.PickingZ}) {
gl_FragColor = encode_float(vPosition.z);
return;
}
#endif
`,
    ele = `  varying vec3 vPosition;
uniform bool clip_x;
uniform bool clip_y;
uniform bool clip_z;
uniform float xMin;
uniform float xMax;
uniform float yMin;
uniform float yMax;
uniform float zMin;
uniform float zMax;
uniform float zMinForAnimation;
uniform float zMaxForAnimation;
uniform int dcgRenderMode;

${EO}
`,
    tle =
      `  if (clip_x && (vPosition.x < xMin || vPosition.x > xMax)) {discard;}
if (clip_y && (vPosition.y < yMin || vPosition.y > yMax)) {discard;}
if (clip_z && (vPosition.z < zMin || vPosition.z > zMax)) {discard;}
if ((vPosition.z < zMinForAnimation) || (vPosition.z > zMaxForAnimation)) {discard;}
`,
    Dh = `  gl_FragColor = LinearTosRGB( gl_FragColor );
`;
  function F_(
    { variant: r, uvArgs: e, extraMeshArgs: t, restrictionShader: o },
  ) {
    let i;
    r.type === "colorFunc"
      ? i = `      vec3 color = getColor();
if (isnan(color.x) || isnan(color.y) || isnan(color.z)) {discard;}
vec4 diffuseColor = vec4(color.x, color.y, color.z, opacity );`
      : i = "vec4 diffuseColor = vec4( diffuse, opacity );";
    let n = r.type === "colorFunc"
        ? __dcg_shared_module_exports__["Gc"]`vec3 getColor() {
    ${U7(e, r.colorShader.source)}
    ${z7(t, r.colorShader.source)}
    ${r.colorShader.source}
    }\n`
        : "",
      a = [o].concat(r.type === "colorFunc" ? [r.colorShader] : []),
      s = __dcg_shared_module_exports__["Hc"](
        ...a.map((k) => k == null ? void 0 : k.shaderFunctions),
      ) + `
` + n + rle(o, U7(e, o == null ? void 0 : o.source), t),
      l = ole(o) + Ny + i,
      c = /\bvUV\b/.test(s) || /\bvUV\b/.test(l),
      d = [void 0, "float", "vec2", "vec3"][t.length],
      p = d && (/\bvExtras\b/.test(s) || /\bvExtras\b/.test(l)),
      h = __dcg_shared_module_exports__["Ic"](
        o == null ? void 0 : o.shaderUniforms,
      ),
      u = h.uniforms,
      f = h.declarations,
      y = `    ${__dcg_shared_module_exports__["Fc"]}
${f}
${
        c
          ? `varying vec2 vUV;
`
          : ""
      }
${
        p
          ? `varying ${d} vExtras;
`
          : ""
      }
${Fy}
${s}
`,
      C = (c
        ? `varying vec2 vUV;
`
        : "") +
        (p
          ? `attribute ${d} extras;
`
          : "") +
        (p
          ? `varying ${d} vExtras;
`
          : "") +
        `varying vec3 vPosition;
uniform mat4 dcgModelMatrix;
`,
      E = `    ${p ? "  vExtras = extras; " : ""}
${c ? "  vUV = uv; " : ""}
#ifdef USE_INSTANCING
vPosition = (instanceMatrix * vec4( position, 1.0 )).xyz;
#else
vPosition = (dcgModelMatrix * vec4( position, 1.0 )).xyz;
#endif
`,
      v = r.type === "colorFunc"
        ? "color::" + r.colorCacheKey + "::" + e.join(",")
        : r.type,
      w = o ? "::" + o.source : "",
      S = v + w;
    return {
      fragmentDeclarations: ele + y,
      fragmentColorChunk: tle + l,
      vertexDeclarations: C,
      vertexPositionChunk: E,
      cacheKey: S,
      glslUniforms: u,
    };
  }
  function U7(r, e) {
    let t = (c) => c === "x" || c === "y" || c === "z",
      o = r[0],
      i = r[1],
      n = new RegExp(`\\b${o}\\b`),
      a = new RegExp(`\\b${i}\\b`),
      s = o !== void 0 && !t(o) && e && n.test(e),
      l = i !== void 0 && !t(i) && e && a.test(e);
    return (s ? [`float ${o} = vUV.x;`] : []).concat(
      l ? [`float ${i} = vUV.y;`] : [],
    ).join(`
`);
  }
  function z7(r, e) {
    let t = (o) => new RegExp(`\\b${o}\\b`).test(e);
    return [
      "float x = vPosition.x;",
      "float y = vPosition.y;",
      "float z = vPosition.z;",
    ].concat(
      r.length === 1
        ? t(r[0]) ? `float ${r[0]} = vExtras;` : ""
        : r.map((o, i) => t(o) ? `float ${o} = vExtras.${"xyz"[i]};` : ""),
    ).join(`
`);
  }
  function rle(r, e, t) {
    return r
      ? __dcg_shared_module_exports__["Gc"]`bool restriction() {
${e}
${z7(t, r.source)}
${r.source}
}\n`
      : "";
  }
  function ole(r) {
    return r ? "if (!restriction()) {discard;}" : "";
  }
  function q7(r) {
    let {
        cacheKey: e,
        vertexPositionChunk: t,
        vertexDeclarations: o,
        fragmentColorChunk: i,
        fragmentDeclarations: n,
        glslUniforms: a,
      } = F_(r),
      s = `
varying vec3 vViewPosition;
varying vec3 vNormal;

${un.common}
${un.common_pars_vertex}

${o}

void main() {

${un.common_vertex}

vViewPosition = - mvPosition.xyz;
vec3 transformedNormal = vec3( normal );

#ifdef USE_INSTANCING
mat3 m = mat3( instanceMatrix );
#else
mat3 m = mat3( dcgModelMatrix );
#endif
transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
transformedNormal = m * transformedNormal;

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED
transformedNormal = - transformedNormal;
#endif
vNormal = normalize( transformedNormal );

${t}
}
`,
      l = `
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
varying vec3 vNormal;

#ifdef IOR
uniform float ior;
#endif

varying vec3 vViewPosition;

${un.common}
${un.common_pars_fragment}
${un.lights_pars_fragment}

${n}

void main() {

${i}

#if defined( USE_COLOR  ) || defined( USE_INSTANCING_COLOR  )
diffuseColor.rgb = vColor;
#endif

${r.disableLighting.value ? "vec4 dcgRawColor = diffuseColor;" : ""}

ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
vec3 totalEmissiveRadiance = emissive;

${un.common_fragment_begin}
float roughnessFactor = roughness;
float metalnessFactor = metalness;
float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
vec3 normal = normalize( vNormal );
#ifdef DOUBLE_SIDED
normal *= faceDirection;
#endif

// non perturbed normal for clearcoat among others
vec3 geometryNormal = normal;

// accumulation
${un.lights_fragment}

// modulation

vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

${R_}

${un.common_fragment_end}

${r.disableLighting.value ? "gl_FragColor.rgb = dcgRawColor.rgb;" : ""}

${Dh}

if (uDepthPeel == 1) {
// When depth peeling, we render with transparent: false, which causes <opaque_fragment> to set gl_FragColor.a = 1.
// We need to set it back to the correct value so that it can be respsected in compositing.
gl_FragColor.a = opacity;
}
}
`;
    return { vertex: s, fragment: l, cacheKey: e, glslUniforms: a };
  }
  var ile = {
      ...Sh(sO.common),
      ...Sh(sO.lights),
      roughness: { value: .4 },
      metalness: { value: 0 },
      emissive: { value: new vt(0) },
    },
    kh = class extends Zl {
      constructor(t) {
        let { vertex: o, fragment: i, cacheKey: n, glslUniforms: a } = q7(
            { ...t, disableLighting: t.globalUniforms.disableLighting },
          ),
          s = typeof t.color == "string" &&
              __dcg_shared_module_exports__["Xd"](t.color)
            ? "#808080"
            : t.color,
          l = {
            ...Sh(ile),
            ...O_(),
            ...t.graphUniforms,
            ...t.globalUniforms,
            opacity: { value: t.opacity },
            diffuse: { value: new vt(s) },
            map: { value: t.map },
            ...a,
          };
        super({
          name: "GraphSurfaceMaterial",
          wireframe: t.wireframe,
          vertexShader: o,
          fragmentShader: i,
          opacity: t.opacity,
          side: ua,
          lights: true,
          uniforms: l,
        });
        this.defines = { DCG_SUPPORTS_PICKING: false };
        this.vertexColors = t.vertexColors,
          this.useVertexPickingColors = t.useVertexPickingColors,
          this.map = t.map,
          this.defines.DCG_SUPPORTS_PICKING = true,
          this.cacheKey = n;
      }
      setEmissiveIntensity(t) {
        let o = new vt(16777215);
        o.multiplyScalar(t), this.uniforms.emissive.value.copy(o);
      }
      customProgramCacheKey() {
        return this.cacheKey;
      }
    };
  function H7(r) {
    let {
        cacheKey: e,
        vertexPositionChunk: t,
        vertexDeclarations: o,
        fragmentColorChunk: i,
        fragmentDeclarations: n,
        glslUniforms: a,
      } = F_(r),
      s = `
${un.common}
${un.common_pars_vertex}

${o}

void main() {
${un.common_vertex}

${t}
}
`,
      l = `
uniform vec3 diffuse;
uniform float opacity;
varying vec3 vNormal;

${un.common}
${un.common_pars_fragment}

${n}

void main() {

${i}

${un.common_fragment_begin}
float specularStrength = 1.0;

ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

// accumulation (baked indirect lighting only)
reflectedLight.indirectDiffuse += vec3( 1.0 );

// modulation

reflectedLight.indirectDiffuse *= diffuseColor.rgb;

vec3 outgoingLight = reflectedLight.indirectDiffuse;

${un.common_fragment_end}

${Dh}
}
`;
    return { vertex: s, fragment: l, cacheKey: e, glslUniforms: a };
  }
  var N_ = class extends Zl {
    constructor(e) {
      let { vertex: t, fragment: o, cacheKey: i, glslUniforms: n } = H7({
          extraMeshArgs: [],
          restrictionShader: void 0,
          uvArgs: [],
          variant: { type: "zClip" },
          disableLighting: e.globalUniforms.disableLighting,
        }),
        a = typeof e.color == "string" &&
            __dcg_shared_module_exports__["Xd"](e.color)
          ? "#808080"
          : e.color,
        s = {
          ...O_(),
          ...e.graphUniforms,
          ...e.globalUniforms,
          roughness: { value: .4 },
          metalness: { value: 0 },
          opacity: { value: e.opacity },
          diffuse: { value: new vt(a) },
          ...n,
        };
      super({
        name: "LineMaterial",
        vertexShader: t,
        fragmentShader: o,
        opacity: e.opacity,
        side: ua,
        uniforms: s,
      }), this.cacheKey = i;
    }
    setColor(e) {
      this.uniforms.diffuse.value.copy(e);
    }
    setOpacity(e) {
      this.opacity = this.uniforms.opacity.value = e;
    }
    customProgramCacheKey() {
      return this.cacheKey;
    }
  };
  var { abs: By, min: K7, max: $7 } = Math,
    j7 = 11184810,
    nle = 3355443,
    B_ = "#444444",
    U_ = "#bbbbbb",
    ale = 1e-4;
  function Y7(r) {
    let e = new vt(j7), t = new vt(nle);
    return { axisMaterial: W7(e, r), tickMaterial: W7(t, r) };
  }
  function TO(r, e, t) {
    return new q_(
      new dm(
        new ye(r.xmin, r.ymin, r.zmin),
        new ye(r.xmax, r.ymax, r.zmax),
      ),
      new vt(e),
      t,
    );
  }
  function X7(r, e) {
    let t = r.box;
    t.min.x = e.xmin,
      t.max.x = e.xmax,
      t.min.y = e.ymin,
      t.max.y = e.ymax,
      t.min.z = e.zmin,
      t.max.z = e.zmax,
      r.updateMatrixWorld();
  }
  function DO(r) {
    r.dispose();
  }
  var sle = new i0(JSON.parse(N7));
  function W7(r, e) {
    let t = new kh({
      color: r,
      extraMeshArgs: [],
      map: void 0,
      opacity: 1,
      restrictionShader: void 0,
      uvArgs: [],
      variant: { type: "zClip" },
      wireframe: false,
      vertexColors: false,
      useVertexPickingColors: false,
      globalUniforms: e,
      graphUniforms: {
        clip_x: { value: false },
        clip_y: { value: false },
        clip_z: { value: false },
      },
    });
    return t.customProgramCacheKey = () => "axis-material", t;
  }
  function J7(r, e) {
    let { xmin: t, xmax: o, ymin: i, ymax: n, zmin: a, zmax: s } = r,
      l = K7(e.width, e.height),
      c = .05 * (l > 360 ? 1 : l > 120 ? 360 / l : 4 - l / 120),
      d = 4,
      p = d * c / .08,
      h = __dcg_shared_module_exports__["clamp"](0, t, o),
      u = __dcg_shared_module_exports__["clamp"](0, i, n),
      f = __dcg_shared_module_exports__["clamp"](0, a, s),
      y = o - t,
      C = n - i,
      E = s - a,
      v = 4 * ((h - t) / y - .5),
      w = 4 * ((u - i) / C - .5),
      S = 4 * ((f - a) / E - .5),
      k = s <= 0 ? -4 : K7(4 * s / E, 4);
    return { textSize: c, scale: d, delta: p, zLen: k, x: v, y: w, z: S };
  }
  var Q7 = .02, qd = 7 * Q7;
  function Z7(r, e, t, { axisMaterial: o }) {
    let { xmin: i, xmax: n, ymin: a, ymax: s, zmin: l, zmax: c } = r,
      d = n - i,
      p = s - a,
      h = c - l,
      u = (n + i) / 2,
      f = (s + a) / 2,
      y = (c + l) / 2,
      C = new Ii(),
      E = Math.PI,
      v = Q7,
      { textSize: w, scale: S, delta: k, zLen: _, x: A, y: P, z: O } = J7(
        r,
        e,
      );
    function U(V) {
      return new Ai(new Ud(.8 * v, .8 * v, V, 10), o);
    }
    function z() {
      return new Ai(new Wk(2 * v, qd, 16), o);
    }
    function x(V, R, N, M = 1) {
      return V.position.set(N[0], N[1], N[2]),
        V.setRotationFromEuler(ym(R[0], R[1], R[2])),
        V.scale.set(M, M, M),
        V.name = "axes",
        C.add(V),
        V;
    }
    function L(V, R, N = 1) {
      let M = ule(V, o);
      M.translateX(-R[0] * k),
        M.translateY(-R[1] * k),
        M.scale.set(N, N, N),
        M.name = "axes";
      let F = i9(M);
      F.name = V, C.add(F);
    }
    return x(U(4 - 6 * v), [0, 0, E / 2], [-qd / 2, P, O]),
      x(U(4 - 6 * v), [0, 0, 0], [A, -qd / 2, O]),
      x(U(4 - 6 * v), [-E / 2, 0, 0], [A, P, -qd / 2]),
      x(z(), [0, 0, -E / 2], [2 - qd / 2, P, O]),
      x(z(), [0, 0, 0], [A, 2 - qd / 2, O]),
      x(z(), [E / 2, 0, 0], [A, P, O + $7(_, 0) - qd / 2]),
      t &&
      (L("x", [.027, .03], w * S),
        L("y", [.025, .02], w * S),
        L("z", [.025, .03], w * S)),
      C.scale.set(d / 4, p / 4, h / 4),
      C.position.set(u, f, y),
      C;
  }
  function kO(r) {
    for (let e of r.getObjectsByProperty("name", "axes")) {
      e.geometry.dispose();
    }
  }
  function e9(r) {
    r.axisMaterial.dispose(), r.tickMaterial.dispose();
  }
  function t9(
    {
      axes: r,
      plane: e,
      domain: t,
      screen: o,
      controls: i,
      invertedColors: n,
      isDepthPeelingActive: a,
    },
  ) {
    let s = i.worldRotation3D,
      { xmax: l, ymax: c, zmax: d } = t,
      { scale: p, delta: h, zLen: u, x: f, y, z: C } = J7(t, o);
    if (r === void 0) return;
    let E = Math.PI,
      v = r.getObjectByName("x"),
      w = r.getObjectByName("y"),
      S = r.getObjectByName("z"),
      k = new ye(1, 0, 0).applyMatrix3(s),
      _ = new ye(0, 1, 0).applyMatrix3(s),
      A = new ye(0, 0, 1).applyMatrix3(s);
    function P(Ce, _e, We) {
      Ce == null || Ce.setRotationFromEuler(ym(_e[0], _e[1], _e[2])),
        Ce == null || Ce.position.set(We[0], We[1], We[2]);
    }
    function O(Ce) {
      return Math.acos(__dcg_shared_module_exports__["clamp"](Ce, -1, 1));
    }
    let U = l <= 0 ? -1 : 1,
      z = c <= 0 ? -1 : 1,
      x = d <= 0 ? -1 : 1,
      L = [U * (.5 * p + .05 * h), y, C],
      V = [f, z * (.5 * p + .05 * h), C],
      R = [f, y, x * (C + $7(u, 0) + .04 * h)],
      N = i.speed3D === 0 || i.grapher3d.isDragging,
      M = By(i.axis3D[0]) > .99,
      F = By(i.axis3D[1]) > .99,
      Z = By(i.axis3D[2]) > .99,
      te = N || M,
      Y = N || F,
      he = N || Z,
      { isXYsnapped: se, isZsnapped: ae } = i,
      q = By(k.y) > .99 && se && te,
      oe = By(_.y) > .99 && se && Y;
    if (By(A.z) < .001 && ae && he) {
      P(v, [E, 0, E], L), P(w, [E, E, E], V), P(S, [E / 2, 0, 0], R);
    } else {
      let Ce = A.z < 0 ? 1 : -1,
        _e = _.y < 0 ? 1 : -1,
        We = -Ce * (E / 2),
        W = (_.x * k.y < 0 ? 1 : -1) * O(_.z),
        ue = -Ce * O(-_e * k.z),
        Ee = q ? W : E / 2,
        Be = oe ? ue : We,
        ce = (_.y < 0 ? -1 : 1) * O(k.y) + E,
        ot = _e * E / 2;
      P(v, [Ee, 0, 0], L), P(w, [Be, 0, ot], V), P(S, [We, 0, ce], R);
      let it = e == null ? void 0 : e.getObjectByName("z plane");
      it == null || it.setRotationFromEuler(ym(E / 2, 0, ce));
    }
    let me = new ye(0, 0, 1).applyMatrix3(i.worldRotation3D).x;
    e == null || e.updateZOffsets(me < 0);
    let we;
    e != null && e.xyPlane &&
    (we = e.xyPlane.material,
      we.uniforms.diffuse.value = new vt(n ? 0 : 16777215)),
      ple({
        invertedColors: n,
        obliqueness: me,
        domainPlaneMaterial: we,
        isDepthPeelingActive: a,
      });
  }
  var z_ = class extends r0 {
    constructor(e, t, o, i, n) {
      super();
      let { showNumbers3D: a, showPlane3D: s } = o.settings,
        { xmin: l, xmax: c, ymin: d, ymax: p, zmin: h, zmax: u } = e,
        [f, y, C] = [c - l, p - d, u - h],
        E = __dcg_shared_module_exports__["clamp"](0, h, u);
      this.basePosition = new ye((c + l) / 2, (p + d) / 2, E),
        this.zOffset = ale * (u - h);
      let v = new e0(f, y);
      if (
        this.xyNumbersPlane = new Ai(v, t.xyNumbersMaterial),
          this.xyNumbersPlane.name = "xy numbers plane",
          this.xyPlane = new Ai(v, t.xyPlaneMaterial),
          this.xyPlane.name = "xy plane",
          s
      ) {
        this.add(this.xyPlane);
        let w = new q_(
          new dm(new ye(l, d, E), new ye(c, p, E)),
          new vt(j7),
          n,
        );
        w.name = "xy border", this.add(w);
      }
      if (a) {
        this.add(this.xyNumbersPlane), this.add(dle(o, e, i));
        let w = new e0(4, 4),
          S = new Ai(w, t.zMaterial),
          k = i9(S),
          [_, A] = [
            __dcg_shared_module_exports__["clamp"](0, l, c),
            __dcg_shared_module_exports__["clamp"](0, d, p),
          ];
        S.setRotationFromEuler(ym(Math.PI / 2, 0, 0)),
          S.name = "z plane",
          k.scale.set(f / 4, y / 4, C / 4),
          k.position.set(_, A, (u + h) / 2),
          lle(t.zCanvas, o, e),
          t.zMaterial.uniforms.map.value.needsUpdate = true,
          this.add(k);
      }
    }
    updateZOffsets(e) {
      var a, s;
      let { x: t, y: o, z: i } = this.basePosition,
        n = e ? this.zOffset : -this.zOffset;
      this.xyPlane &&
      ((a = this.xyPlane) == null || a.position.set(t, o, i - n),
        this.xyPlane.renderOrder = 0),
        this.xyNumbersPlane &&
        ((s = this.xyNumbersPlane) == null ||
          s.position.set(t, o, i + 2 * n),
          this.xyNumbersPlane.renderOrder = 2);
    }
  };
  function lle(r, e, t) {
    let o = r.getContext("2d");
    if (o === null) return;
    let i = r9(e, t),
      n = e.settings.labelSize,
      { xmin: a, xmax: s, zmin: l, zmax: c } = t,
      d = [];
    for (let w of i) {
      let S = __dcg_shared_module_exports__["OoLabel"].value(w, c - l);
      d.push(new _a(S, n));
    }
    o.save(),
      o.scale(window.devicePixelRatio, window.devicePixelRatio),
      o.clearRect(0, 0, e.screen.width, e.screen.height),
      o.fillStyle = `rgba(${
        e.settings.config.invertedColors ? "0,0,0" : "255,255,255"
      },0.001961)`,
      o.fillRect(0, 0, e.screen.width, e.screen.height),
      o.lineWidth = 1.5,
      o.miterLimit = 2,
      o.strokeStyle = e.settings.getBackgroundColor({ invertWhite: true });
    let p = 5,
      h = e.settings.getTextColor({ invertBlack: true }),
      u = e.screen.width,
      f = e.screen.height,
      y = { left: 3, top: 3, right: u - 3, bottom: f - 3 },
      C = new Br(a, s, l, c, l, c),
      E = new Rs(e.screen, C, e.settings),
      v = r.width / window.devicePixelRatio / 2;
    for (let w of d) {
      let S = { x: v - p - w.getRect().right, y: E.mapy(w.getValue()) },
        k = w.clampBoundsWithinRect(S, y);
      o.fillStyle = h, w.drawCenteredAt(o, k, "");
    }
    o.restore();
  }
  function r9(r, e) {
    let { zmin: t, zmax: o } = e,
      i = { ...r.viewport, ymin: t, ymax: o },
      n = { ...r, viewport: i },
      { majorStepY: a } = gl(n),
      s = ds(t, o, a);
    return o > 0 && (s = s.filter((l) => l != 0)), s;
  }
  function cle(r, e) {
    let { zmin: t, zmax: o } = e;
    return r9(r, e).filter((n) => n <= o - qd / 4 * (o - t));
  }
  function dle(r, e, { tickMaterial: t }) {
    let { xmin: o, xmax: i, ymin: n, ymax: a, zmin: s, zmax: l } = e,
      c = __dcg_shared_module_exports__["clamp"](0, o, i),
      d = __dcg_shared_module_exports__["clamp"](0, n, a),
      p = __dcg_shared_module_exports__["clamp"](0, s, l),
      h = Math.PI,
      u = .004,
      f = u * (i - o),
      y = u * (a - n),
      C = u * (l - s),
      E = new r0(),
      v = .4;
    for (let k of cle(r, e)) {
      let _ = new Ud(), A = new Ai(_, t);
      A.position.set(c, d, k),
        A.scale.set(f, v * C, y),
        A.setRotationFromEuler(ym(h / 2, 0, 0)),
        A.name = "ticks",
        E.add(A);
    }
    let { majorStepX: w, majorStepY: S } = gl(r);
    for (let k of ds(o, i, w)) {
      if (k > i - qd / 4 * (i - o)) continue;
      let _ = new Ud(), A = new Ai(_, t);
      A.position.set(k, d, p),
        A.scale.set(y, v * f, C),
        A.setRotationFromEuler(ym(0, 0, h / 2)),
        A.name = "ticks",
        E.add(A);
    }
    for (let k of ds(n, a, S)) {
      if (k > a - qd / 4 * (a - n)) continue;
      let _ = new Ud(), A = new Ai(_, t);
      A.position.set(c, k, p),
        A.scale.set(C, v * y, f),
        A.setRotationFromEuler(ym(0, h / 2, 0)),
        A.name = "ticks",
        E.add(A);
    }
    return E;
  }
  function ple(
    { obliqueness: r, domainPlaneMaterial: e, invertedColors: t },
  ) {
    if (!e) return;
    e.uniforms.obliqueness.value = Math.abs(r);
    let o = t ? __dcg_shared_module_exports__["Md"](B_) : B_,
      i = t ? __dcg_shared_module_exports__["Md"](U_) : U_;
    e.setGridColors({ major: o, minor: i });
  }
  function o9(r) {
    var o, i, n, a;
    let e = (s) => r.getObjectByName(s);
    (o = e("xy numbers plane")) == null || o.geometry.dispose(),
      (i = e("xy plane")) == null || i.geometry.dispose(),
      (n = e("z plane")) == null || n.geometry.dispose(),
      (a = e("xy border")) == null || a.dispose();
    let t = r.getObjectsByProperty("name", "ticks");
    for (let s of t) s.geometry.dispose();
  }
  function _O(r) {
    r.uniforms.map.value.dispose(), r.dispose();
  }
  function i9(r) {
    let e = new Ii();
    return e.add(r), e;
  }
  function ule(r, e) {
    let t = new o0(r, {
      font: sle,
      size: 1,
      height: .02,
      curveSegments: 12,
      bevelEnabled: true,
      bevelThickness: .04,
      bevelSize: .04,
      bevelOffset: 0,
      bevelSegments: 5,
    });
    return new Ai(t, e);
  }
  var ym = (r, e, t) => new Fs(r, e, t, "ZYX"),
    q_ = class extends Xk {
      constructor(t, o, i) {
        let n = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7,
          ]),
          a = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            -1,
          ],
          s = new La();
        s.setIndex(new ha(n, 1)), s.setAttribute("position", new Bo(a, 3));
        super(
          s,
          new N_({
            color: o,
            opacity: 1,
            graphUniforms: {
              clip_x: { value: false },
              clip_y: { value: false },
              clip_z: { value: false },
            },
            globalUniforms: i,
          }),
        );
        this.type = "Box3Helper";
        this.box = t, this.geometry.computeBoundingSphere();
      }
      updateMatrixWorld(t) {
        let o = this.box;
        o.isEmpty() ||
          (o.getCenter(this.position),
            o.getSize(this.scale),
            this.scale.multiplyScalar(.5),
            super.updateMatrixWorld(t));
      }
      dispose() {
        this.geometry.dispose(), this.material.dispose();
      }
    };
  var xm = class extends Zl {
    constructor(e, t) {
      super({
        name: "DomainPlaneMaterial",
        side: ua,
        transparent: e.transparent,
        vertexShader: `
varying vec3 vPosition;
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    vPosition = position;
}
`,
        fragmentShader: `
uniform mat4 projectionMatrix;
uniform mat4 modelViewMatrix;

varying vec3 vPosition;
uniform int dcgRenderMode;
uniform vec2 uScreenSize;
uniform float xMin;
uniform float xMax;
uniform float yMin;
uniform float yMax;

uniform vec3 diffuse;
uniform float opacity;

uniform float xMinorStep;
uniform float yMinorStep;
uniform float xMajorStep;
uniform float yMajorStep;
uniform vec3 majorGridColor;
uniform vec3 minorGridColor;
uniform float obliqueness;

${Fy}
${EO}

float getNearestStep(float t, float step) {
    float prev = step * floor(t / step);
    float next = prev + step;
    return abs(t - prev) < abs(t - next) ? prev : next;
}

vec2 projectToScreen(vec3 p) {
    vec4 pNDC = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
    pNDC /= pNDC.w;
    return 0.5 * (pNDC.xy + 1.0) * uScreenSize;
}

bool isMajorStep(float s, float minorStep, float majorStep) {
    return mod(s, majorStep) < minorStep * 0.125;
}

void main() {
    ${Ny}
    ${R_}
    // the xyPlane geometry is shifted in domain3d-objects to reduce cancellation error
    float x0 = (xMin + xMax) / 2.;
    float y0 = (yMin + yMax) / 2.;
    float xNearest = getNearestStep(vPosition.x + x0, xMinorStep);
    float yNearest = getNearestStep(vPosition.y + y0, yMinorStep);
    bool xIsMajor = isMajorStep(xNearest, xMinorStep, xMajorStep);
    bool yIsMajor = isMajorStep(yNearest, yMinorStep, yMajorStep);
    vec2 xNearestScreen = projectToScreen(vec3(xNearest - x0, vPosition.y, vPosition.z));
    vec2 yNearestScreen = projectToScreen(vec3(vPosition.x, yNearest - y0, vPosition.z));
    float xDist = distance(gl_FragCoord.xy, xNearestScreen);
    float yDist = distance(gl_FragCoord.xy, yNearestScreen);
    float minDist = xDist < yDist ? xDist : yDist;
    bool isMajor = xDist < yDist ? xIsMajor : yIsMajor;

    vec4 grid = vec4(0.0);
    float baseWidth = 0.0;
    float feather = 2.0;
    if (obliqueness < FADE_THRESHOLD) {
    baseWidth = 3.0 * (1.0 - obliqueness / FADE_THRESHOLD);
    feather = 2.0 * obliqueness / FADE_THRESHOLD;
    }
    if (minDist <= baseWidth + feather) {
    vec3 gridColor = isMajor ? majorGridColor : minorGridColor;
    // We want integral of blurFactor to be 1.0 over the whole region
    //
    //   baseWidth
    //   --------------
    //   |            |            //   |            |             // h |            |              //   |            |               //   |            |                //   -------------|-----
    //               feather (2.0)
    // h * baseWidth + h * feather / 2 = 1
    // h = 1 / (baseWidth + feather / 2)
    float h = 1.0 / (baseWidth + feather / 2.0);
    float blurFactor = h - max(0.0, (minDist - baseWidth)) / feather;
    grid = vec4(gridColor, blurFactor);
    }

    // Composite the grid color ("grid") onto the domain plane color (diffuse, opacity)
    float composedAlpha = mix(opacity, grid.a, grid.a);
    vec3 composedColor = mix(diffuse*opacity, grid.rgb*grid.a, grid.a) / composedAlpha;
    gl_FragColor = vec4(composedColor, composedAlpha);

    ${Dh}
}
`,
        defines: { DCG_SUPPORTS_PICKING: true, FADE_THRESHOLD: .4 },
        uniforms: {
          opacity: { value: e.opacity },
          diffuse: { value: e.color },
          majorGridColor: { value: new vt(B_) },
          minorGridColor: { value: new vt(U_) },
          obliqueness: { value: 1 },
          ...t,
        },
      });
    }
    setGridColors({ major: e, minor: t }) {
      this.uniforms.majorGridColor.value = new vt(e),
        this.uniforms.minorGridColor.value = new vt(t);
    }
  };
  var wm = class extends Zl {
    constructor(e, t) {
      let o = new S_(e.canvas);
      super({
        name: "DomainPlaneNumbersMaterial",
        side: ua,
        transparent: e.transparent,
        vertexShader: `
varying vec2 vUv;

void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`,
        fragmentShader: `

uniform sampler2D map;
uniform float opacity;
varying vec2 vUv;
uniform int dcgRenderMode;

${Fy}

uniform float alphaTest;

void main() {
    ${Ny}

    vec4 sampleColor = texture2D( map, vUv );

    // When we're only showing numbers, we clear the canvas with a low alpha and discard it here.
    if ( sampleColor.a < alphaTest ) {
    discard;
    }

    #ifdef OPAQUE
    if (uDepthPeel == 0) {
    sampleColor.a = 1.0;
    }
    #endif

    gl_FragColor = sampleColor;

    ${Dh}
}
`,
        uniforms: { map: { value: o }, alphaTest: { value: .1 }, ...t },
      }),
        this.canvas = e.canvas,
        this.texture = o;
    }
    dispose() {
      super.dispose(), this.texture.dispose();
    }
  };
  var hle = {
      name: "DepthPeelLayerAddJittersShader",
      uniforms: {
        uCompositeType: { value: 0 },
        uTextureA: { value: null },
        uTextureB: { value: null },
        weight: { value: 1 },
      },
      defines: {},
      vertexShader: `
varying vec2 vUv;
void main(){
vUv = uv;
gl_Position = vec4(position.xy,0.,1.);
}
`,
      fragmentShader: `
varying vec2 vUv;
uniform sampler2D uTextureA;
uniform sampler2D uTextureB;
uniform int uCompositeType;
uniform float weight;
void main() {
vec4 src = texture2D(uTextureA,vUv);
src.a *= weight;
vec4 dst = uCompositeType == 1 ? texture2D(uTextureB,vUv) : vec4(0.0);
// Convert src, dst to premultiplied, and do the addition in premultiplied space.
// We don't want to store the buffers premultiplied since that loses dynamic range.
src.rgb *= src.a;
dst.rgb *= dst.a;
gl_FragColor = src + dst;
// Convert output back to non-premultiplied
// Don't need to check for division by zero, since it gets converted to a buffer 0-255 (an integer, not NaN),
// which we will then multiply by 0 (the alpha).
gl_FragColor.rgb /= gl_FragColor.a;
}
`,
    },
    H_ = class {
      constructor() {
        this.shaderPass = new bl(hle, {
          depthTest: false,
          depthWrite: false,
          transparent: false,
        }, "uTextureA");
      }
      dispose() {
        this.shaderPass.dispose();
      }
      addInPremultiplied(e, t, o, i, n) {
        this.shaderPass.uniforms.weight.value = i,
          n instanceof vt
            ? (this.shaderPass.uniforms.uCompositeType.value = 0,
              this.shaderPass.uniforms.uTextureB.value = null)
            : (this.shaderPass.uniforms.uTextureB.value = n.texture,
              this.shaderPass.uniforms.uCompositeType.value = 1),
          this.shaderPass.renderFromTexture(e, t, o.texture);
      }
    };
  var gle = {
      name: "DepthPeelLayerCompositeShader",
      uniforms: {
        uTopTexture: { value: null },
        uBottomTexture: { value: null },
        uBackgroundColor: { value: new vt(0) },
        uCompositeType: { value: 0 },
      },
      defines: {},
      vertexShader: `
varying vec2 vUv;
void main(){
vUv = uv;
gl_Position = vec4(position.xy,0.,1.);
}
`,
      fragmentShader: `
varying vec2 vUv;
uniform sampler2D uTopTexture;
uniform sampler2D uBottomTexture;
uniform vec3 uBackgroundColor;
uniform int uCompositeType;
void main() {
vec4 top = texture2D(uTopTexture,vUv);
vec4 bot = uCompositeType == 1 ? texture2D(uBottomTexture,vUv) : vec4(uBackgroundColor, 1.0);
// Convert top, bot to premultiplied, and do the addition in premultiplied space.
// We don't want to store the buffers premultiplied since that loses dynamic range.
top.rgb *= top.a;
bot.rgb *= bot.a;
gl_FragColor = top + bot * (1. - top.a);
// Convert output back to non-premultiplied
gl_FragColor.rgb /= gl_FragColor.a;
}
`,
    },
    K_ = class {
      constructor() {
        this.shaderPass = new bl(gle, {
          depthTest: false,
          depthWrite: false,
          transparent: false,
        }, "uTopTexture");
      }
      dispose() {
        this.shaderPass.dispose();
      }
      composite(e, t, o, i) {
        i instanceof vt
          ? (this.shaderPass.uniforms.uCompositeType.value = 0,
            this.shaderPass.uniforms.uBackgroundColor.value = i,
            this.shaderPass.uniforms.uBottomTexture.value = null)
          : (this.shaderPass.uniforms.uCompositeType.value = 1,
            this.shaderPass.uniforms.uBackgroundColor.value = new vt(0),
            this.shaderPass.uniforms.uBottomTexture.value = i.texture),
          this.shaderPass.renderFromTexture(e, t, o.texture);
      }
    };
  var c0 = 4,
    mle = {
      name: "MaxWindow",
      uniforms: {
        tDiffuse: { value: null },
        sourcePixelSize: { value: new Tt(1, 1) },
        destPixelSize: { value: new Tt(1, 1) },
      },
      defines: {},
      vertexShader: `
varying vec2 vUv;

void main() {
vUv = uv;
gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
      fragmentShader: `
uniform float weight;
uniform sampler2D tDiffuse;
uniform vec2 sourcePixelSize;
uniform vec2 destPixelSize;
varying vec2 vUv;

void main() {
vec2 demi = vec2(0.5,0.5);
vec2 xy = destPixelSize * vUv - demi;
vec4 maxAccum = vec4(0.);
for (float i=0.; i < ${c0}.0; i+=1.) {
for (float j=0.; j < ${c0}.0; j+=1.) {
vec2 xySample = min(
    xy * ${c0}.0 + vec2(i,j) + demi,
    sourcePixelSize
);
vec2 uvSample = xySample / sourcePixelSize;
vec4 val = texture2D(tDiffuse, uvSample);
maxAccum = max(maxAccum, val);
}
}
gl_FragColor = maxAccum;
}`,
    },
    IO = class {
      constructor() {
        this.shaderPass = new bl(mle, {
          depthTest: false,
          depthWrite: false,
          transparent: true,
        });
      }
      dispose() {
        this.shaderPass.dispose();
      }
      render(e, t, o) {
        this.shaderPass.uniforms.sourcePixelSize = {
          value: new Tt(o.width, o.height),
        },
          this.shaderPass.uniforms.destPixelSize = {
            value: new Tt(t.width, t.height),
          },
          e.setRenderTarget(t),
          e.setClearColor(new vt(0), 0),
          e.clear(),
          this.shaderPass.render(e, t, o);
      }
    },
    W_ = class {
      constructor(e, t) {
        this.targetType = t;
        this.maxPass = new IO();
        this.maxMipmapTargets = [];
        let o = e.x, i = e.y;
        for (
          let n = 0;
          o = Math.ceil(o / c0), i = Math.ceil(i / c0), o > 1 || i > 1;
          n++
        ) this.maxMipmapTargets[n] = this.createTarget(o, i);
      }
      dispose() {
        for (let e of this.maxMipmapTargets) e.dispose();
        this.maxPass.dispose();
      }
      createTarget(e, t) {
        return new Oa(e, t, {
          minFilter: ml,
          magFilter: ml,
          type: this.targetType,
          colorSpace: Ga,
        });
      }
      renderMax(e, t, o, i, n, a) {
        var s;
        for (let l = 0; l <= this.maxMipmapTargets.length; l++) {
          let c = l === 0 ? o : this.maxMipmapTargets[l - 1],
            d = l < this.maxMipmapTargets.length ? this.maxMipmapTargets[l] : t;
          this.maxPass.render(e, d, c);
        }
        for (let l = 0; l < this.maxMipmapTargets.length; l++) {
          let c = this.maxMipmapTargets[l];
          (s = i.get(`max-mm-p${n}-${l}`, `${c.width}x${c.height}`)) ==
              null ||
            s.renderFromTarget(
              e,
              c,
              a * Math.min(o.width / c.width, o.height / c.height),
            );
        }
      }
    };
  var $_ = class {
    constructor(e, t, o, i, n, a) {
      this.controller = e;
      this.renderer = t;
      this.materialManager = o;
      this.scene = i;
      this.camera = n;
      this.debug = a;
      this.triangles = 0;
      this.pixelRatio = t.getPixelRatio();
      let s = t.getSize(new Tt()).multiplyScalar(this.pixelRatio);
      this.size = s, this.init();
    }
    init() {
      this.samples = 1;
      let e = this.controller.getGraphSettings().config.peelUpsample;
      e
        ? this.samples = e
        : this.pixelRatio < 1.5
        ? this.samples = 3
        : this.pixelRatio < 2.5
        ? this.samples = 2
        : this.samples = 1;
      let t = this.controller.getGraphSettings().config.peelFloatTexture
          ? F7()[0]
          : Vn,
        o = () =>
          new Oa(this.size.x, this.size.y, {
            minFilter: ml,
            magFilter: ml,
            type: t,
            colorSpace: Ga,
          });
      this.peelSampleTargets = [],
        this.peelResultTarget = o(),
        this.secondPeelResultTarget = o(),
        this.compositingTargets = [o(), o()],
        this.maxPass = new W_(this.size, t),
        this.finalMipmapTargets = [
          this.maxPass.createTarget(1, 1),
          this.maxPass.createTarget(1, 1),
        ],
        this.opaqueBackgroundTargets = [];
      for (let n = 0; n < this.samples; n++) {
        let a = o();
        a.depthTexture = new mm(this.size.x, this.size.y),
          this.opaqueBackgroundTargets.push(a);
      }
      this.combinedOpaqueBackgroundTarget = o();
      let i = 2 * this.samples;
      for (let n = 0; n < i; n++) {
        let a = o();
        a.depthTexture = new mm(this.size.x, this.size.y),
          this.peelSampleTargets.push(a);
      }
      this.compositePass = new K_(),
        this.addPremultipliedPass = new H_(),
        this.materialManager.setScreenSize(this.size.x, this.size.y);
    }
    dispose() {
      this.peelSampleTargets.forEach((e) => e.dispose()),
        this.compositingTargets.forEach((e) => e.dispose()),
        this.peelResultTarget.dispose(),
        this.compositePass.dispose(),
        this.addPremultipliedPass.dispose(),
        this.maxPass.dispose();
    }
    getDebugScale() {
      return this.controller.getGraphSettings().config.debugScale;
    }
    render(e) {
      var y;
      let t = this.renderer,
        o = t.getPixelRatio(),
        i = t.getSize(new Tt()).multiplyScalar(o);
      (o !== this.pixelRatio || this.size.x !== i.x ||
        this.size.y !== i.y) &&
        (this.size.copy(i), this.dispose(), this.init());
      let n = t.getClearColor(new vt()), a = t.autoClear;
      t.autoClear = false,
        t.setClearColor(new vt(0), 1),
        t.clear(),
        this.materialManager.setGlobalUniform(
          "dcgRenderMode",
          gs.Default,
        );
      let s = fle(this.scene);
      yle(this.scene),
        this.renderOpaqueBackground(),
        s9(this.scene, s),
        this.materialManager.setGlobalUniform("uDepthPeel", 1),
        this.materialManager.setGlobalUniform("uDepthPeelLayer", 0),
        this.materialManager.setGlobalUniform("uPrevDepthTexture", null);
      let l,
        c = this.peelSampleTargets.slice(0, this.samples),
        d = this.peelSampleTargets.slice(this.samples, 2 * this.samples),
        p = this.compositingTargets[0],
        h = this.compositingTargets[1];
      xle(this.scene);
      let u = [];
      this.renderTransparentLayer(c, void 0, 0, p),
        e === 1 &&
        u.push(
          this.queryNonemptyPixels(0, p, this.finalMipmapTargets[0]),
        ),
        l = p;
      for (let C = 0; C < e; C++) {
        let E = C + 1;
        this.renderTransparentLayer(d, c, E, this.peelResultTarget),
          this.compositePass.composite(
            this.renderer,
            h,
            p,
            this.peelResultTarget,
          ),
          (y = this.debug.get(`peel-c${E}`)) == null ||
          y.renderFromTarget(this.renderer, h, this.getDebugScale()),
          C >= e - 2 &&
          u.push(
            this.queryNonemptyPixels(
              E,
              this.peelResultTarget,
              this.finalMipmapTargets[C === e - 2 ? 0 : 1],
            ),
          ),
          l = h,
          [d, c] = [c, d],
          [h, p] = [p, h];
      }
      let f = this.renderer.info.render.frame;
      Promise.all(u).then((C) => {
        if (C.length !== 2) {
          throw new Error(
            `Programming error: expected 2 nonempty pixel query results, got ${C.length}`,
          );
        }
        let E = C[0][3] > 0, w = C[1][3] > 0 ? 1 : E ? 2 : 0;
        this.controller.setAdaptiveDepthPeelingInfo({
          frame: f,
          peelLayers: e,
          status: w,
        });
      }),
        s9(this.scene, s),
        this.compositePass.composite(
          this.renderer,
          null,
          l,
          this.combinedOpaqueBackgroundTarget,
        ),
        t.setClearColor(n),
        t.autoClear = a,
        this.materialManager.setGlobalUniform("uPrevDepthTexture", null),
        this.materialManager.setGlobalUniform("uDepthPeel", 0);
    }
    renderOpaqueBackground() {
      this.materialManager.setGlobalUniform("uDepthPeel", 0),
        this.materialManager.setGlobalUniform(
          "uOpaqueDepthTexture",
          null,
        );
      let e = this.combinedOpaqueBackgroundTarget,
        t = this.secondPeelResultTarget;
      this.samples % 2 === 0 && ([t, e] = [e, t]);
      for (let o = 0; o < this.samples; o++) {
        let i = this.opaqueBackgroundTargets[o];
        this.renderer.setRenderTarget(i),
          this.setJitterOffset(o),
          this.renderer.setClearColor(new vt(0), 0),
          this.renderer.clear(),
          this.renderer.render(this.scene, this.camera),
          this.addPremultipliedPass.addInPremultiplied(
            this.renderer,
            e,
            i,
            n9(this.samples, o),
            o === 0 ? new vt(0) : t,
          ),
          [e, t] = [t, e];
      }
      this.camera.clearViewOffset();
    }
    renderTransparentLayer(e, t, o, i) {
      var a, s;
      let n = this.secondPeelResultTarget;
      e.length % 2 === 0 && ([n, i] = [i, n]);
      for (let l = 0; l < e.length; l++) {
        let c = e[l];
        this.materialManager.setGlobalUniform(
          "uOpaqueDepthTexture",
          this.opaqueBackgroundTargets[l].depthTexture,
        ),
          t &&
          this.materialManager.setGlobalUniform(
            "uPrevDepthTexture",
            t[l].depthTexture,
          ),
          this.setJitterOffset(l),
          this.materialManager.setGlobalUniform("uDepthPeelLayer", o),
          this.materialManager.setGlobalUniform(
            "dcgRenderMode",
            gs.Default,
          ),
          this.renderer.setClearColor(new vt(0), 0),
          this.renderer.setRenderTarget(c),
          this.renderer.clear(true, true);
        let d = this.scene.background;
        this.scene.background = null,
          this.renderer.render(this.scene, this.camera),
          this.scene.background = d,
          this.triangles = this.renderer.info.render.triangles,
          (a = this.debug.get(`peel-p${o}-s${l}`)) == null ||
          a.renderFromTarget(this.renderer, c, this.getDebugScale()),
          this.addPremultipliedPass.addInPremultiplied(
            this.renderer,
            i,
            c,
            n9(this.samples, l),
            l === 0 ? new vt(0) : n,
          ),
          (s = this.debug.get(`peel-p${o}-s${l}-combined`)) == null ||
          s.renderFromTarget(this.renderer, i, this.getDebugScale()),
          [i, n] = [n, i];
      }
      this.camera.clearViewOffset();
    }
    setJitterOffset(e) {
      if (!a9[this.samples]) {
        throw new Error(`Unsupported sample count: ${this.samples}`);
      }
      let t = a9[this.samples];
      this.camera.setViewOffset(
        this.size.x,
        this.size.y,
        t[e][0] * .0625,
        t[e][1] * .0625,
        this.size.x,
        this.size.y,
      );
    }
    queryNonemptyPixels(e, t, o) {
      var s, l;
      (s = this.debug.get(`max-mm-p${e}-start`)) == null ||
      s.renderFromTarget(this.renderer, t, this.getDebugScale()),
        this.maxPass.renderMax(
          this.renderer,
          o,
          t,
          this.debug,
          e,
          this.getDebugScale(),
        );
      let i = this.renderer.getContext(),
        n = new Uint8Array(4 * o.width * o.height),
        a = R7(i, 0, 0, o.width, o.height, i.RGBA, i.UNSIGNED_BYTE, n)
          .then(() => [...n]);
      return (l = this.debug.get(
            `max-mm-p${e}-end`,
            `${o.width}x${o.height}`,
          )) == null ||
        l.renderFromTarget(
          this.renderer,
          o,
          this.getDebugScale() *
            Math.min(t.width / o.width, t.height / o.height),
        ),
        a;
    }
  };
  function n9(r, e) {
    let t = 1 / r, o = 1 / 32, i = -.5 + (e + .5) / r;
    return t + o * i;
  }
  var a9 = {
    1: [[0, 0]],
    2: [[4, 4], [-4, -4]],
    3: [[3.323, 3.323], [-4.54, 1.216], [1.216, -4.54]],
    4: [[-2, -6], [6, -2], [-6, 2], [2, 6]],
  };
  function fle(r) {
    let e = new Map();
    return r.traverse((t) => {
      e.set(t, t.visible);
    }),
      e;
  }
  function s9(r, e) {
    r.traverse((t) => {
      t.visible = e.get(t);
    });
  }
  var ble = .999;
  function yle(r) {
    r.traverse((e) => {
      l9(e) === "transparent" && (e.visible = false);
    });
  }
  function xle(r) {
    r.traverse((e) => {
      l9(e) === "opaque" && (e.visible = false);
    });
  }
  function l9(r) {
    let e = r.material;
    if (e) {
      return e instanceof xm || e instanceof wm || e.opacity < ble
        ? "transparent"
        : "opaque";
    }
  }
  var j_ = class {
    constructor() {
      this.materialCache = {};
      this.globalUniforms = {
        dcgRenderMode: gs.Default,
        xMin: 0,
        xMax: 0,
        yMin: 0,
        yMax: 0,
        zMin: 0,
        zMax: 0,
        xMajorStep: 0,
        xMinorStep: 0,
        yMajorStep: 0,
        yMinorStep: 0,
        uDepthPeel: 0,
        uDepthPeelLayer: 0,
        uOpaqueDepthTexture: null,
        uPrevDepthTexture: null,
        uScreenSize: new Tt(1, 1),
        uInverseScreenSize: new Tt(1, 1),
        uDepthOffset: 1e-6,
        disableLighting: true,
      };
    }
    setGlobalUniform(e, t) {
      this.globalUniforms[e] = t;
    }
    disposeAllMaterials() {
      this.disposeMaterialsNotInScene(new eu());
    }
    disposeMaterialsNotInScene(e) {
      var o;
      let t = {};
      e.traverse((i) => {
        if ("material" in i) {
          let n = i.material, a;
          Array.isArray(i.material) ? a = n : a = [n],
            a.forEach((s) => {
              d9(s) && (t[s.dcgMaterialCacheKey] = true);
            });
        }
      });
      for (let i in this.materialCache) {
        if (!t[i]) {
          let n = this.materialCache[i];
          n.dispose(),
            (o = n.map) == null || o.dispose(),
            delete this.materialCache[i];
        }
      }
    }
    getOrMakeMaterial(e) {
      let t = wle(e.spec), o = this.materialCache[t];
      if (o) {
        switch (e.type) {
          case "surface-graph":
            c9(o.uniforms, e.uniforms);
            break;
          case "domain-plane":
            break;
          default:
            throw new Error(`Unexpected type ${e.type}`);
        }
      } else {
        switch (e.type) {
          case "surface-graph":
            o = this._buildSurfaceMaterial(e.spec, e.uniforms);
            break;
          case "domain-plane":
            o = this.buildDomainPlaneMaterial(e.spec);
            break;
          default:
            throw new Error(`Unexpected type ${e.type}`);
        }
        this.materialCache[t] = o, o.dcgMaterialCacheKey = t;
      }
      return o;
    }
    setScreenSize(e, t) {
      this.globalUniforms.uScreenSize.set(e, t),
        this.globalUniforms.uInverseScreenSize.set(1 / e, 1 / t);
    }
    setDomain(e, t) {
      let { xmin: o, xmax: i, ymin: n, ymax: a, zmin: s, zmax: l } = e,
        c = 1e-5,
        d = (i - o) * c,
        p = (a - n) * c,
        h = (l - s) * c;
      this.globalUniforms.xMin = o - d,
        this.globalUniforms.xMax = i + d,
        this.globalUniforms.yMin = n - p,
        this.globalUniforms.yMax = a + p,
        this.globalUniforms.zMin = s - h,
        this.globalUniforms.zMax = l + h;
      let u = gl(t);
      this.globalUniforms.xMinorStep = u.minorStepX,
        this.globalUniforms.xMajorStep = u.majorStepX,
        this.globalUniforms.yMinorStep = u.minorStepY,
        this.globalUniforms.yMajorStep = u.majorStepY;
    }
    setDisableLighting(e) {
      this.globalUniforms.disableLighting = e;
    }
    setZBoundsUniform(e, t) {
      if (!d9(e)) {
        throw new Error(
          "Cannot update zBoundsForAnimation on a material that is not managed by MaterialManager",
        );
      }
      e instanceof xm || e instanceof wm || p9(e.uniforms, t);
    }
    _buildSurfaceMaterial(e, t) {
      var d, p;
      let o = e.color,
        i = (d = e.uvArgs) != null ? d : [],
        n = (p = e.extraMeshArgs) != null ? p : [],
        a = e.restrictionShader,
        s = o.startsWith("wireframe:");
      s && (o = o.slice(10));
      let l = this.getVariant(o, e.colorShader),
        c = new kh({
          color: __dcg_shared_module_exports__["Xd"](o) ? "#808080" : o,
          wireframe: s,
          opacity: e.opacity,
          extraMeshArgs: n,
          map: void 0,
          variant: l,
          vertexColors: e.vertexColors || false,
          useVertexPickingColors: e.useVertexPickingColors || false,
          restrictionShader: a,
          uvArgs: i,
          globalUniforms: this.getGlobalUniforms(),
        });
      return c9(c.uniforms, t), c;
    }
    buildDomainPlaneMaterial(e) {
      let t;
      return e.type === "domain-plane-numbers-material"
        ? t = new wm(e, this.getGlobalUniforms())
        : t = new xm(e, this.getGlobalUniforms()),
        this.setupGlobalUniforms(t.uniforms),
        t;
    }
    getVariant(e, t) {
      return e.startsWith("shader:")
        ? !t || !t.source ? { type: "zClip" } : {
          type: "colorFunc",
          colorShader: t,
          colorCacheKey: JSON.stringify(t),
        }
        : { type: "zClip" };
    }
    getGlobalUniforms() {
      let e = {};
      return this.setupGlobalUniforms(e), e;
    }
    setupGlobalUniforms(e) {
      let t = this;
      for (let o in this.globalUniforms) {
        let i = o;
        e[i] = {
          get value() {
            return t.globalUniforms[i];
          },
        };
      }
    }
  };
  function c9(r, e) {
    let { clip: t, zBoundsForAnimation: o } = e;
    p9(r, o),
      r.clip_x = { value: t.x },
      r.clip_y = { value: t.y },
      r.clip_z = { value: t.z },
      r.NaN = { value: NaN },
      r.Infinity = { value: 1 / 0 };
  }
  function p9(r, e) {
    r.zMinForAnimation = { value: e.zMinForAnimation },
      r.zMaxForAnimation = { value: e.zMaxForAnimation };
  }
  function wle(r) {
    return r.type === "domain-plane-numbers-material"
      ? (r.canvas.hasAttribute("dcg-material-manager-id") ||
        r.canvas.setAttribute(
          "dcg-material-manager-id",
          Math.random() + "",
        ),
        JSON.stringify({
          ...r,
          canvas: r.canvas.getAttribute("dcg-material-manager-id"),
        }))
      : JSON.stringify(r);
  }
  function d9(r) {
    return "dcgMaterialCacheKey" in r;
  }
  function u9(r, e, t) {
    var R, N, M;
    let o = __dcg_shared_module_exports__["clamp"](
        Math.floor(8 + 30 * e),
        8,
        20,
      ),
      { xmin: i, xmax: n, ymin: a, ymax: s, zmin: l, zmax: c } = t,
      d = (n - i) / 2,
      p = (s - a) / 2,
      h = (c - l) / 2,
      u = 30,
      f = {
        xmin: i - u * d,
        xmax: n + u * d,
        ymin: a - u * p,
        ymax: s + u * p,
        zmin: l - u * h,
        zmax: c + u * h,
      };
    function y(F, Z, te) {
      return f.xmin <= F && F <= f.xmax && f.ymin <= Z && Z <= f.ymax &&
        f.zmin <= te && te <= f.zmax;
    }
    for (let F = 0; F < r.length / 3; F++) {
      let Z = r[3 * F + 0], te = r[3 * F + 1], Y = r[3 * F + 2];
      if (y(Z, te, Y) || !z(F)) continue;
      let se = F === r.length / 3 - 1 || !z(F + 1) ? F - 1 : F + 1;
      if (!z(se)) continue;
      let ae = r[3 * se + 0] - Z,
        q = r[3 * se + 1] - te,
        oe = r[3 * se + 2] - Y,
        K = vle(f, Z, te, Y, ae, q, oe);
      r[3 * F + 0] = (R = K == null ? void 0 : K.x) != null ? R : NaN,
        r[3 * F + 1] = (N = K == null ? void 0 : K.y) != null ? N : NaN,
        r[3 * F + 2] = (M = K == null ? void 0 : K.z) != null ? M : NaN;
    }
    for (let F = 0; F < r.length / 3 - 1; F++) {
      if (z(F) && z(F + 1)) {
        r = r.slice(3 * F);
        break;
      }
    }
    if (!(z(0) && z(1))) return [[], [], []];
    let E = r.length / 3 - 1,
      v = new ye(),
      w = new ye(),
      S = [],
      k = [],
      _ = [],
      A = V();
    for (let F = 0; F <= E; F++) P(F);
    return O(), [S, k, _];
    function P(F) {
      w.x = r[3 * F + 0], w.y = r[3 * F + 1], w.z = r[3 * F + 2];
      let Z = A.normals[F], te = A.binormals[F];
      if (L(F)) {
        for (let Y = 0; Y <= o; Y++) {
          let he = Y / o * Math.PI * 2,
            se = Math.sin(he),
            ae = -Math.cos(he);
          v.x = d * e * (ae * Z.x + se * te.x),
            v.y = p * e * (ae * Z.y + se * te.y),
            v.z = h * e * (ae * Z.z + se * te.z),
            S.push(w.x + v.x, w.y + v.y, w.z + v.z),
            v.normalize(),
            k.push(v.x, v.y, v.z);
        }
      } else {for (let Y = 0; Y <= o; Y++) {
          S.push(0, 0, 0), k.push(0, 0, 0);
        }}
    }
    function O() {
      for (let F = 1; F <= E; F++) {
        if (L(F - 1) && L(F)) {
          for (let Z = 1; Z <= o; Z++) {
            let te = (o + 1) * (F - 1) + (Z - 1),
              Y = (o + 1) * F + (Z - 1),
              he = (o + 1) * F + Z,
              se = (o + 1) * (F - 1) + Z;
            _.push(te, Y, se, Y, he, se);
          }
        }
      }
    }
    function U(F) {
      return new ye(r[3 * F + 0], r[3 * F + 1], r[3 * F + 2]);
    }
    function z(F) {
      return isFinite(Math.fround(r[3 * F + 0])) &&
        isFinite(Math.fround(r[3 * F + 1])) &&
        isFinite(Math.fround(r[3 * F + 2]));
    }
    function x(F) {
      return isFinite(F.x) && isFinite(F.y) && isFinite(F.z);
    }
    function L(F) {
      return z(F) && x(A.normals[F]) && x(A.binormals[F]);
    }
    function V() {
      let F = new ye(),
        Z = [],
        te = [],
        Y = [],
        he = new ye(),
        se = new Nt();
      for (let ae = 0; ae <= E; ae++) {
        let [q, oe] = ae < E ? [ae + 1, ae] : [ae, ae - 1],
          K = U(q).sub(U(oe)).normalize();
        x(K) ? Z[ae] = K : ae > 0 && (Z[ae] = Z[ae - 1]);
      }
      for (let ae = 0; ae <= E; ae++) {
        if (ae === 0 || !z(ae - 1)) {
          te[ae] = new ye(), Y[ae] = new ye();
          let q = Number.MAX_VALUE,
            oe = Math.abs(Z[ae].x),
            K = Math.abs(Z[ae].y),
            fe = Math.abs(Z[ae].z);
          oe <= q && (q = oe, F.set(1, 0, 0)),
            K <= q && (q = K, F.set(0, 1, 0)),
            fe <= q && F.set(0, 0, 1),
            he.crossVectors(Z[ae], F).normalize(),
            te[ae].crossVectors(Z[ae], he),
            Y[ae].crossVectors(Z[ae], te[ae]);
        } else {
          if (
            te[ae] = te[ae - 1].clone(),
              Y[ae] = Y[ae - 1].clone(),
              he.crossVectors(Z[ae - 1], Z[ae]),
              he.length() > Number.EPSILON
          ) {
            he.normalize();
            let oe = Math.acos(
              __dcg_shared_module_exports__["clamp"](
                Z[ae - 1].dot(Z[ae]),
                -1,
                1,
              ),
            );
            te[ae].applyMatrix4(se.makeRotationAxis(he, oe));
          }
          let q = ae > 0 &&
              Z[ae - 1].dot(Z[ae]) >
                -.999999 * Z[ae - 1].length() * Z[ae].length()
            ? Z[ae].clone().add(Z[ae - 1]).normalize()
            : Z[ae];
          Y[ae].crossVectors(q, te[ae]).normalize();
        }
      }
      return { normals: te, binormals: Y };
    }
  }
  function vle(r, e, t, o, i, n, a) {
    let s, l, c, d, p, h, u = 1 / i, f = 1 / n, y = 1 / a;
    if (
      u >= 0
        ? (s = (r.xmin - e) * u, l = (r.xmax - e) * u)
        : (s = (r.xmax - e) * u, l = (r.xmin - e) * u),
        f >= 0
          ? (c = (r.ymin - t) * f, d = (r.ymax - t) * f)
          : (c = (r.ymax - t) * f, d = (r.ymin - t) * f),
        s > d || c > l ||
        ((c > s || isNaN(s)) && (s = c),
          (d < l || isNaN(l)) && (l = d),
          y >= 0
            ? (p = (r.zmin - o) * y, h = (r.zmax - o) * y)
            : (p = (r.zmax - o) * y, h = (r.zmin - o) * y),
          s > h || p > l) ||
        ((p > s || s !== s) && (s = p), (h < l || l !== l) && (l = h), l < 0)
    ) return;
    let C = s >= 0 ? s : l;
    return { x: e + C * i, y: t + C * n, z: o + C * a };
  }
  Ss();
  var h9 = new Set();
  h9.add("(0,0,0,0)");
  var Y_ = class {
    constructor() {
      this.pickingColorToData = new Map();
      this.idToPickingColor = new Map();
      this.testingLastHashCollisionCount = 0;
    }
    setPickingColorForMesh(e) {
      let { mesh: t, branchId: o } = e;
      if (t instanceof Mi) {
        for (let i = 0; i < t.count; i++) {
          let n = o + ":" + i,
            a = this._getOrCreatePickingColor({
              mesh: t,
              index: i,
              isPoint: e.isPoint,
              blocksPicking: e.blocksPicking,
              forceOpaque: false,
              pickingId: n,
            });
          t.setPickingColorAt(i, a);
        }
      } else if (e.pickingColorVertexCounts) {
        let i = [], { pickingColorVertexCounts: n } = e;
        for (let a = 0; a < n.length; a++) {
          let l = MO(o) + ":" + a,
            c = this._getOrCreatePickingColor({
              mesh: t,
              index: a,
              isPoint: e.isPoint,
              blocksPicking: e.blocksPicking,
              forceOpaque: false,
              pickingId: l,
            });
          i.push(c);
        }
        t.setPickingColorArray({ colors: i, repeatColorCounts: n });
      } else {
        let i = o;
        t.pickingColor = this._getOrCreatePickingColor({
          mesh: t,
          index: 0,
          isPoint: e.isPoint,
          blocksPicking: e.blocksPicking,
          forceOpaque: e.forceOpaque,
          pickingId: i,
        });
      }
    }
    _getOrCreatePickingColor(e) {
      let t = e.pickingId, o = this.idToPickingColor.get(t);
      if (o) {
        let l = o.key;
        return this.pickingColorToData.set(l, e), o.color;
      }
      let i = Ele(e.pickingId), n, a, s = 0;
      for (;;) {
        let l = i + s ** 2,
          c = l >> 24 & 255,
          d = l >> 16 & 255,
          p = l >> 8 & 255,
          h = e.forceOpaque ? 255 : l & 255;
        if (
          n = `(${c},${d},${p},${h})`,
            a = [c / 255, d / 255, p / 255, h / 255],
            !h9.has(n) && !this.pickingColorToData.has(n)
        ) break;
        if (s++, s > 100) {
          So(
            new Error(
              `PickingColorManager.getOrCreatePickingColor: too many collisions for id ${t}`,
            ),
          ),
            n = "(0,0,0,0)",
            a = [0, 0, 0, 0];
          break;
        }
      }
      return this.testingLastHashCollisionCount = s,
        this.pickingColorToData.set(n, e),
        this.idToPickingColor.set(t, { key: n, color: a }),
        a;
    }
    getDataForPickingColor(e) {
      let t = `(${e.join(",")})`;
      return this.pickingColorToData.get(t);
    }
    disposeColorsNotInScene(e) {
      let t = new Set();
      e.traverse((o) => {
        if (o instanceof Mi) {
          let i = [0, 0, 0, 0];
          for (let n = 0; n < o.count; n++) {
            o.getPickingColorAt(n, i), t.add(AO(i));
          }
        } else if (o.pickingColorArray) {
          let i = o.pickingColorArray.colors;
          if (i) { for (let n of i) t.add(AO(n)); }
        } else {
          let i = o.pickingColor;
          i && t.add(AO(i));
        }
      });
      for (let o of this.pickingColorToData.keys()) {
        if (!t.has(o)) {
          let i = this.pickingColorToData.get(o);
          this.idToPickingColor.delete(i.pickingId),
            this.pickingColorToData.delete(o);
        }
      }
    }
  };
  function AO(r) {
    return "(" + Math.round(r[0] * 255) + "," + Math.round(r[1] * 255) +
      "," + Math.round(r[2] * 255) + "," + Math.round(r[3] * 255) + ")";
  }
  var Cle = 2166136261, Sle = 16777619;
  function Ele(r) {
    let e = Cle;
    for (let t = 0; t < r.length; t++) e ^= r.charCodeAt(t), e *= Sle;
    return e >>> 0;
  }
  var g9 = {
    name: "ConcatShader",
    uniforms: {
      t0: { value: null },
      t1: { value: null },
      t2: { value: null },
      t3: { value: null },
    },
    defines: {},
    vertexShader: `
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    fragmentShader: `
uniform sampler2D t0;
uniform sampler2D t1;
uniform sampler2D t2;
uniform sampler2D t3;

uniform float opacity;
uniform sampler2D tDiffuse;
varying vec2 vUv;

void main() {
int index = int(vUv.x * 4.0);
float x = vUv.x * 4.0 - float(index);
vec2 uv = vec2(x, vUv.y);
if (index == 0) {
gl_FragColor = texture2D( t0, uv );
} else if (index == 1) {
gl_FragColor = texture2D( t1, uv );
} else if (index == 2) {
gl_FragColor = texture2D( t2, uv );
} else if (index == 3) {
gl_FragColor = texture2D( t3, uv );
}
}`,
  };
  var m9 = {
    name: "CopyShader",
    uniforms: { tDiffuse: { value: null }, weight: { value: 1 } },
    defines: { SRGB_COLOR_SPACE: true },
    vertexShader: `
varying vec2 vUv;

void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    fragmentShader: `
uniform float weight;
uniform sampler2D tDiffuse;
varying vec2 vUv;

void main() {
    vec4 texel = texture2D( tDiffuse, vUv );
    gl_FragColor = weight * texel;
#ifdef SRGB_COLOR_SPACE
gl_FragColor = LinearTosRGB( gl_FragColor );
#endif
}`,
  };
  var { abs: GO, floor: Tle, sin: f9, cos: b9 } = Math;
  function y9(r, e, t, o) {
    if (!V(r) || !V(e) || !isFinite(t) || r.equals(e) || t === 0) {
      return [[], [], []];
    }
    let i = e.clone().sub(r).normalize(),
      n = i.clone().negate(),
      a = new ye(),
      s = new ye(),
      l = new ye(),
      c = Number.MAX_VALUE,
      d = GO(i.x),
      p = GO(i.y),
      h = GO(i.z);
    d <= c && (c = d, a.set(1, 0, 0)),
      p <= c && (c = p, a.set(0, 1, 0)),
      h <= c && a.set(0, 0, 1),
      l.crossVectors(i, a).normalize(),
      a.crossVectors(i, l),
      s.crossVectors(i, a);
    let u = new ye(),
      f = (o.xmax - o.xmin) / 2,
      y = (o.ymax - o.ymin) / 2,
      C = (o.zmax - o.zmin) / 2,
      E = [],
      v = [],
      w = [],
      S = e.clone().sub(r),
      _ = new ye(S.x / f, S.y / y, S.z / C).length();
    t > _ / 6 && (t = _ / 6);
    let A = 6 * t,
      P = 1 - Math.min(1, A / _),
      O = r.clone().add(S.clone().multiplyScalar(P)),
      U = __dcg_shared_module_exports__["clamp"](Tle(8 + 80 * t), 8, 30);
    x(r, t), x(O, t), L();
    let z = E.length / 3;
    E.push(r.x, r.y, r.z), v.push(n.x, n.y, n.z), x(r, t, n);
    for (let R = 1; R <= U; R++) w.push(z, z + R, z + R + 1);
    z = E.length / 3,
      E.push(O.x, O.y, O.z),
      v.push(n.x, n.y, n.z),
      x(O, 2 * t, n);
    for (let R = 1; R <= U; R++) w.push(z, z + R, z + R + 1);
    z = E.length / 3;
    for (let R = 0; R <= U; R++) {
      let N = R / U * Math.PI * 2, M = f9(N), F = -b9(N);
      u.x = f * 2 * t * (F * a.x + M * s.x),
        u.y = y * 2 * t * (F * a.y + M * s.y),
        u.z = C * 2 * t * (F * a.z + M * s.z),
        E.push(O.x + u.x, O.y + u.y, O.z + u.z),
        E.push(e.x, e.y, e.z);
      let Z = 1 / 3,
        te = new ye(
          F * a.x + M * s.x + Z * i.x,
          F * a.y + M * s.y + Z * i.y,
          F * a.z + M * s.z + Z * i.z,
        ).normalize();
      v.push(te.x, te.y, te.z, te.x, te.y, te.z);
    }
    for (let R = 0; R < U; R++) {
      w.push(z + 2 * R, z + 2 * R + 1, z + 2 * R + 2);
    }
    return [E, v, w];
    function x(R, N, M) {
      for (let F = 0; F <= U; F++) {
        let Z = F / U * Math.PI * 2, te = f9(Z), Y = -b9(Z);
        u.x = f * N * (Y * a.x + te * s.x),
          u.y = y * N * (Y * a.y + te * s.y),
          u.z = C * N * (Y * a.z + te * s.z),
          E.push(R.x + u.x, R.y + u.y, R.z + u.z),
          u.normalize(),
          M === void 0 ? v.push(u.x, u.y, u.z) : v.push(M.x, M.y, M.z);
      }
    }
    function L() {
      for (let R = 1; R <= U; R++) {
        let N = R - 1, M = U + R, F = U + R + 1, Z = R;
        w.push(N, M, Z, M, F, Z);
      }
    }
    function V(R) {
      return isFinite(R.x) && isFinite(R.y) && isFinite(R.z);
    }
  }
  var {
      abs: Q_,
      min: X_,
      max: d0,
      sqrt: Lle,
      round: v9,
      log10: C9,
      tan: PO,
      atan: S9,
      PI: Ple,
    } = Math,
    tI = 50,
    E9 = 6.75,
    yl = 1,
    Uy = 1,
    p0 = .002,
    zy = 30,
    u0 = class {
      constructor(e, t) {
        this.pickingColorManager = new Y_();
        this.perspective = 1;
        this.lastFrameExpressionTooComplexIDs = new Set();
        this.debugOnlyMeasureGPUTiming = false;
        this.lastRenderInfo = {
          peelLayers: 0,
          triangles: 0,
          bufferUploads: 0,
          bufferUploadItems: 0,
          startTimeCPU: 0,
          durationCPU: 0,
        };
        this.mainCopyOutputPass = new bl(m9);
        this.concatPass = new bl(g9);
        this.pickingPassCacheKey = "";
        this.pickResult = { pickingReadCacheKey: "" };
        this.worldViewCacheKeyInfo = {
          math: [
            new ye(0, 0, 0),
            new ye(1, 0, 0),
            new ye(0, 1, 0),
            new ye(0, 0, 1),
          ],
          clip: [
            new ye(0, 0, 0),
            new ye(1, 0, 0),
            new ye(0, 1, 0),
            new ye(0, 0, 1),
          ],
        };
        this.domainObjectUpdates = 0;
        var l, c;
        let { config: o } = t.getGraphSettings();
        this.debug = new V_({
          filter: (l = o.debug3dRender) != null ? l : null,
        }),
          (c = o.debug3dRender) != null && c.includes("pick") &&
          (Uy = 5, yl = 5),
          this.surfaces = {},
          this.renderedTabTargets = {},
          this.renderedTabTargetOrder = [],
          this.isTrackingPressedAction = false,
          this.scene = new eu(),
          this.spinningWorld = new Ii(),
          this.world = new Ii(),
          this.spinningWorld.add(this.world),
          this.scene.add(this.spinningWorld),
          this.controller = t,
          this.materialManager = new j_(),
          this.cameraDistance = tI,
          this.camera = new xh(),
          this.axesMaterials = Y7(
            this.materialManager.getGlobalUniforms(),
          ),
          this.setBackgroundColor(t.getGraphSettings().backgroundColor3d),
          this.canvas = e,
          this.renderer = Vle(this.canvas),
          this.mainRenderTarget = new Oa(
            this.canvas.width,
            this.canvas.height,
            { colorSpace: Ga, samples: 4 },
          ),
          this.mainCopyOutputPass.defines.SRGB_COLOR_SPACE = false;
        let i = new Gy(4210752, Math.PI);
        this.scene.add(i);
        let n = 2.8, a = new Ch(16777215, n);
        a.position.set(-1, 1, 1), this.scene.add(a);
        let s = new Ch(16777215, n);
        s.position.set(-1, -1, 0),
          this.scene.add(s),
          this.controller.getGraphSettings().config.observeAndSync(
            "disableLighting",
            () => {
              this.materialManager.setDisableLighting(
                this.controller.getGraphSettings().config.disableLighting,
              );
            },
          ),
          this.initDepthPeel(),
          this.updateDomainObjects(),
          this.initPickingTargets();
      }
      getNumberOfSurfaces() {
        return Object.keys(this.surfaces).length;
      }
      showPlane(e) {
        this.domainPlane !== void 0 &&
          (e
            ? this.world.add(this.domainPlane)
            : this.world.remove(this.domainPlane));
      }
      showBox(e) {
        e ? this.world.add(this.domainBox) : this.world.remove(this.domainBox);
        for (let t in this.surfaces) this.deleteSurface(t);
      }
      showAxes(e) {
        e
          ? this.world.add(this.domainAxes)
          : this.world.remove(this.domainAxes);
      }
      updateCamera() {
        let e = this.canvas.width / this.canvas.height,
          t = this.controller.getPerspectiveDistortion();
        if (
          t === 0 && !(this.camera instanceof Xp)
            ? this.depthPeel.camera = this.camera = new Xp()
            : t !== 0 && !(this.camera instanceof xh) &&
              (this.depthPeel.camera = this.camera = new xh()),
            this.camera instanceof xh
        ) {
          let o = Ple / 360, i = E9 / X_(e, 1);
          this.cameraDistance = tI / t,
            this.camera.position.set(-this.cameraDistance, 0, 0),
            this.camera.fov = S9(t * PO(o * i)) / o;
        } else {this.cameraDistance = 50,
            this.camera.position.set(-this.cameraDistance, 0, 0),
            e > 1
              ? (this.camera.left = -2.95 * e,
                this.camera.right = 2.95 * e,
                this.camera.bottom = -2.95,
                this.camera.top = 2.95)
              : (this.camera.left = -2.95,
                this.camera.right = 2.95,
                this.camera.bottom = -2.95 / e,
                this.camera.top = 2.95 / e);}
        this.camera.up.set(0, 0, 1),
          this.camera.lookAt(new ye(0, 0, 0)),
          this.camera.updateProjectionMatrix(),
          this.perspective = t;
      }
      initDepthPeel() {
        this.depthPeel = new $_(
          this.controller,
          this.renderer,
          this.materialManager,
          this.scene,
          this.camera,
          this.debug,
        );
      }
      initPickingTargets() {
        let e = yl, t = Uy;
        this.pickingTargets = {
          id: new Oa(e, t, { type: Vn }),
          x: new Oa(e, t, { type: Vn }),
          y: new Oa(e, t, { type: Vn }),
          z: new Oa(e, t, { type: Vn }),
          combined: new Oa(e * 4, t, { type: Vn }),
        };
      }
      debugOnlyTrackBufferUploads() {
        let e = this;
        ha.prototype.onUploadCallback = function () {
          e.lastRenderInfo.bufferUploads++,
            e.lastRenderInfo.bufferUploadItems += this.array.length;
        };
      }
      debugGetPrograms() {
        return this.renderer.info.programs || [];
      }
      getClipAxes(e) {
        return this.controller.getGraphSettings().showBox3D
          ? { x: true, y: true, z: true }
          : e != null
          ? e
          : { x: false, y: false, z: false };
      }
      setBackgroundColor(e) {
        this.backgroundColor = new vt(e), this.updateBackgroundColor();
      }
      updateBackgroundColor() {
        if (this.controller.invertSwatches()) {
          let { r: e, g: t, b: o } = this.backgroundColor;
          this.scene.background = new vt(),
            this.scene.background.setRGB(1 - e, 1 - t, 1 - o);
        } else this.scene.background = this.backgroundColor;
      }
      domain() {
        var t, o;
        let e = this.controller.getGrapher3d();
        if (e) {
          let i = e.viewportController.getViewport(),
            n = i.xmin,
            a = i.xmax,
            s = i.ymin,
            l = i.ymax,
            c = (t = i.zmin) != null ? t : -2,
            d = (o = i.zmax) != null ? o : 2;
          return { xmin: n, xmax: a, ymin: s, ymax: l, zmin: c, zmax: d };
        } else return new __dcg_shared_module_exports__["Yd"]();
      }
      updateAxes() {
        this.domainAxes !== void 0 &&
        (this.world.remove(this.domainAxes), kO(this.domainAxes)),
          this.domainAxes = Z7(
            this.domain(),
            this.controller.get2dProjection().screen,
            this.controller.getGraphSettings().showAxisLabels3D,
            this.axesMaterials,
          ),
          this.controller.getGraphSettings().showAxis3D &&
          this.world.add(this.domainAxes);
      }
      updateBox() {
        let e = this.domain();
        this.domainBox
          ? (this.updateDomainBoxColor(), X7(this.domainBox, e))
          : this.domainBox = TO(
            e,
            this.getDomainBoxColor(),
            this.materialManager.getGlobalUniforms(),
          );
        let t = this.controller.getGraphSettings().showBox3D,
          o = this.domainBox.parent === this.world;
        t !== o &&
          (t
            ? this.world.add(this.domainBox)
            : this.world.remove(this.domainBox));
      }
      getDomainBoxColor() {
        var t;
        return this.controller.isGraphPaperFocused() &&
            !((t = this.controller.getGrapher3d()) != null &&
              t.isDragging) &&
            this.controller.getGrapher2d().poiController
                .keyboardAttentionManager.getKeyboardAttention() ===
              void 0
          ? this.controller.getInvertedColors() ? 16777215 : 0
          : 11184810;
      }
      updateDomainBoxColor() {
        let { showBox3D: e } = this.controller.getGraphSettings();
        if (!e || !this.domainBox) return;
        let t = this.getDomainBoxColor();
        t !== this.domainBoxColor &&
          (this.domainBoxColor = t,
            this.world.remove(this.domainBox),
            DO(this.domainBox),
            this.domainBox = TO(
              this.domain(),
              t,
              this.materialManager.getGlobalUniforms(),
            ),
            this.world.add(this.domainBox));
      }
      updatePlaneMap() {
        this.disposePlaneTextureIfResized(),
          this.domainPlaneMaterials !== void 0 &&
          (this.domainPlaneMaterials.xyNumbersMaterial.uniforms.map.value
            .needsUpdate = true,
            this.domainPlaneMaterials.zMaterial.uniforms.map.value
              .needsUpdate = true);
      }
      disposePlaneTextureIfResized() {
        let e = this.controller.getGrapher2d().getCanvasNode();
        this.domainPlaneMaterials &&
          (e.width !== this.domainPlaneMaterials.width ||
            e.height !== this.domainPlaneMaterials.height) &&
          (_O(this.domainPlaneMaterials.xyNumbersMaterial),
            _O(this.domainPlaneMaterials.zMaterial),
            this.domainPlaneMaterials = void 0);
      }
      disposePlane() {
        this.domainPlane !== void 0 &&
          (this.world.remove(this.domainPlane),
            o9(this.domainPlane),
            this.domainPlane = void 0);
      }
      updatePlane() {
        this.disposePlaneTextureIfResized(),
          this.disposePlane(),
          this.domainPlaneMaterials = this.constructDomainMaterials(),
          this.domainPlaneMaterials &&
          (this.domainPlane = new z_(
            this.domain(),
            this.domainPlaneMaterials,
            this.controller.getGrapher2d().getProjection(),
            this.axesMaterials,
            this.materialManager.getGlobalUniforms(),
          ),
            this.domainPlane.xyPlane &&
            this.pickingColorManager.setPickingColorForMesh({
              mesh: this.domainPlane.xyPlane,
              isPoint: false,
              blocksPicking: true,
              forceOpaque: true,
              branchId: "**dcg_domain_plane_picking_id**",
            }),
            (this.controller.showPlane3D() ||
              this.controller.showNumbers3D()) &&
            this.world.add(this.domainPlane));
      }
      constructDomainMaterials() {
        var p, h, u, f, y;
        let { showNumbers3D: e, showPlane3D: t } = this.controller
            .getGraphSettings(),
          o = this.computeDepthPeelLayers() > 0;
        if (
          this.domainPlaneMaterials !== void 0 &&
          this.domainPlaneMaterials.showPlane3D === t &&
          this.domainPlaneMaterials.showNumbers3D === e &&
          this.domainPlaneMaterials.depthPeelingActive === o
        ) return this.domainPlaneMaterials;
        (h = (p = this.domainPlaneMaterials) == null
            ? void 0
            : p.xyNumbersMaterial) == null || h.dispose(),
          (u = this.domainPlaneMaterials) == null ||
          u.xyPlaneMaterial.dispose(),
          (y = (f = this.domainPlaneMaterials) == null
              ? void 0
              : f.zMaterial) == null || y.dispose();
        let i = this.controller.getGrapher2d().getCanvasNode();
        if (i.width === 0 || i.height === 0) return;
        let n = this.materialManager.getOrMakeMaterial({
            type: "domain-plane",
            spec: {
              type: "domain-plane-numbers-material",
              canvas: i,
              showNumbers: e,
              transparent: t && !o,
            },
          }),
          a = document.createElement("canvas");
        a.width = i.width, a.height = i.height;
        let s = this.materialManager.getOrMakeMaterial({
            type: "domain-plane",
            spec: {
              type: "domain-plane-numbers-material",
              canvas: a,
              showNumbers: e,
              transparent: false,
            },
          }),
          l = this.controller.getGraphSettings().plane3dOpacity,
          c = Number(l);
        if (
          (l === "" || isNaN(c)) && (c = .5),
            c = __dcg_shared_module_exports__["clamp"](c, 0, 1),
            c < p0
        ) return;
        let d = this.materialManager.getOrMakeMaterial({
          type: "domain-plane",
          spec: {
            type: "domain-plane-material",
            opacity: c,
            transparent: !o,
            color: new vt(16777215),
          },
        });
        return {
          zCanvas: a,
          zMaterial: s,
          xyNumbersMaterial: n,
          xyPlaneMaterial: d,
          width: i.width,
          height: i.height,
          showNumbers3D: e,
          showPlane3D: t,
          depthPeelingActive: o,
        };
      }
      computeDepthPeelLayers() {
        let e = this.computeDesiredDepthPeelLayersFromGeometry(),
          t = X_(e, zy);
        if (e === 0) return 0;
        if (!this.getConfig().adaptivePeeling) return t;
        let o = this.controller.getAdaptiveDepthPeelingInfo(), i = e;
        if (o) {
          let { peelLayers: n, status: a } = o;
          if (a === 1) {
            let s = Math.ceil(zy / 3);
            i = (Math.floor(n / s) + 1) * s;
          } else a === 0 ? i = n - 1 : i = n;
        }
        return __dcg_shared_module_exports__["clamp"](i, 1, t);
      }
      getConfig() {
        return this.controller.getGraphSettings().config;
      }
      computeDesiredDepthPeelLayersFromGeometry() {
        let { debugPeelLayers: e } = this.getConfig();
        if (e !== void 0) return e;
        let t = 1, o = 0;
        for (let n in this.surfaces) {
          let a = this.surfaces[n];
          if (a.isTransparent) {
            let s = __dcg_shared_module_exports__["clamp"](
              a.mesh.material.opacity,
              0,
              1,
            );
            if (s < p0) continue;
            s < t && (t = s),
              a.shape === "plane"
                ? o += 1
                : a.shape === "sphere"
                ? o += 2
                : o += v9(-2 / C9(1 - s));
          }
        }
        if (t === 1) return 0;
        let i = X_(o, v9(-2 / C9(1 - t)));
        return this.controller.showPlane3D() && (i += 1), d0(1, i);
      }
      updateDomainObjects() {
        this.domainObjectUpdates++,
          this.updateAxes(),
          this.updateBox(),
          this.updatePlane();
        let e = this.domain(),
          { xmin: t, xmax: o, ymin: i, ymax: n, zmin: a, zmax: s } = e;
        this.spinningWorld.scale.set(
          4 / (o - t),
          4 / (n - i),
          4 / (s - a),
        ),
          this.world.position.set(
            -(o + t) / 2,
            -(n + i) / 2,
            -(s + a) / 2,
          ),
          this.materialManager.setDomain(
            e,
            this.controller.getGrapher2d().getProjection(),
          ),
          this.updateDomainObjectsFromCamera();
      }
      getZBoundsForAnimationForNewSurface(e) {
        var s;
        let t = (s = this.controller.getGrapher3d()) == null
            ? void 0
            : s.transition,
          o = t == null ? void 0 : t.objectIdExtendingTo3D,
          { zmin: i, zmax: n } = this.domain(),
          a = window.performance.now();
        if (o && e.startsWith(o + ":")) {
          t.startTime < 0 && (t.startTime = a);
          let l = (a - t.startTime) / t.duration;
          return l >= 1
            ? _h
            : { zMinForAnimation: l * i, zMaxForAnimation: l * n };
        }
        return _h;
      }
      setZboundsOnSurfaces(e, t, o) {
        for (let i in this.surfaces) {
          if (i.startsWith(e + ":")) {
            let a = this.surfaces[i].mesh.material;
            this.materialManager.setZBoundsUniform(a, {
              zMinForAnimation: t,
              zMaxForAnimation: o,
            });
          }
        }
      }
      deleteSurface(e) {
        let t = this.surfaces[e];
        if (!t) return;
        this.world.remove(t.mesh);
        let o = t.mesh.geometry;
        Ole(o) || o.dispose(), delete this.surfaces[e];
      }
      getColorShader(e) {
        if (e.startsWith("shader:")) {
          return this.controller.getShader(e.slice(7));
        }
      }
      renderPoint3D(e, t, o) {
        let { position: i, radius: n, guid: a } = e;
        if (n <= 0 || !isFinite(n)) return;
        let s = this.domain(),
          { xmin: l, xmax: c, ymin: d, ymax: p, zmin: h, zmax: u } = s,
          f = this.makeCacheKey(a, s);
        this.surfaces[t] &&
          (this.surfaces[t].cacheKey !== f ||
            this.surfaces[t].materialColor != o) &&
          this.deleteSurface(t);
        let [y, C, E] = i,
          v = n * (c - l) / 4,
          w = n * (p - d) / 4,
          S = n * (u - h) / 4;
        if (!this.surfaces[t]) {
          let k = this.materialManager.getOrMakeMaterial({
              type: "surface-graph",
              spec: {
                type: "surface-material",
                objectId: t,
                color: o,
                opacity: 1,
                colorShader: this.getColorShader(o),
              },
              uniforms: {
                domain: s,
                clip: this.getClipAxes(),
                zBoundsForAnimation: _h,
              },
            }),
            _ = J_(n),
            A = new Ai(_, k);
          A.dcgModelMatrix = new Nt().makeTranslation(y, C, E).multiply(
            new Nt().makeScale(v, w, S),
          ),
            this.surfaces[t] = {
              mesh: A,
              cacheKey: f,
              isNotInSketchOrder: false,
              materialColor: o,
              isTransparent: false,
              isPoint: true,
            },
            this.world.add(A);
        }
        this.surfaces[t].isNotInSketchOrder = false;
      }
      makeCacheKey(e, t) {
        return e + ":" + JSON.stringify(t);
      }
      renderPointList3D(e, t) {
        let o = this.domain(),
          { xmin: i, xmax: n, ymin: a, ymax: s, zmin: l, zmax: c } = o,
          { pressedId: d } = this.pressedActionData(),
          p = this.highlightedIndex(e),
          h = t.map((f) => f.color + "_" + f.guid).join(":") +
            `:${p}:${e === d}`,
          u = this.makeCacheKey(h, o);
        if (
          this.surfaces[e] && this.surfaces[e].cacheKey !== u &&
          this.deleteSurface(e), !this.surfaces[e]
        ) {
          let f = "",
            y = this.materialManager.getOrMakeMaterial({
              type: "surface-graph",
              spec: {
                type: "surface-material",
                objectId: e,
                color: f,
                opacity: 1,
                colorShader: this.getColorShader(f),
              },
              uniforms: {
                domain: o,
                clip: this.getClipAxes(),
                zBoundsForAnimation: _h,
              },
            }),
            C = t[0];
          if (C.graphMode !== 114) return;
          let E = J_(C.radius), v = new Mi(E, y, t.length);
          for (let w = 0; w < t.length; w++) {
            let S = t[w];
            if (S.graphMode !== 114) return;
            let [k, _, A] = S.position,
              P = S.radius,
              O = this.needsHighlighting(e, w)
                ? vm(S.color, this.highlightAmount(e, w))
                : S.color,
              U = P * (n - i) / 4,
              z = P * (s - a) / 4,
              x = P * (c - l) / 4;
            if (P <= 0 || !isFinite(P) || J_(P) !== E) return;
            let V = new Nt().makeTranslation(k, _, A).multiply(
              new Nt().makeScale(U, z, x),
            );
            v.setMatrixAt(w, V), v.setColorAt(w, new vt(O));
          }
          this.surfaces[e] = {
            mesh: v,
            cacheKey: u,
            isNotInSketchOrder: false,
            materialColor: f,
            isTransparent: false,
            isPoint: true,
          }, this.world.add(v);
        }
        return this.surfaces[e].isNotInSketchOrder = false, this.surfaces[e];
      }
      renderSphere3D(e, t, o) {
        var U, z;
        let { position: i, radius: n, restrictionShader: a, guid: s } = e,
          l = e.surfaceOpacity;
        if (
          !this.getConfig().beta3d &&
          !this.controller.getTranslucentSurfaces() && (l = 1), l < p0
        ) return;
        let c = ((U = this.getColorShader(o)) == null ? void 0 : U.source) ||
          "";
        this.surfaces[t] &&
          (this.surfaces[t].cacheKey !== s ||
            this.surfaces[t].materialColor != o ||
            c != ((z = this.surfaces[t].shader) != null ? z : "")) &&
          this.deleteSurface(t);
        let [d, p, h] = i,
          [u, f, y] = [Q_(n[0]), Q_(n[1]), Q_(n[2])],
          { xmin: C, xmax: E, ymin: v, ymax: w, zmin: S, zmax: k } = this
            .domain(),
          [_, A, P] = [E - C, w - v, k - S],
          O = 2 * d0(u / _, f / A, y / P);
        if (!this.surfaces[t]) {
          let x = this.materialManager.getOrMakeMaterial({
              type: "surface-graph",
              spec: {
                type: "surface-material",
                objectId: t,
                color: o,
                opacity: l,
                colorShader: this.getColorShader(o),
                restrictionShader: a,
              },
              uniforms: {
                domain: this.domain(),
                clip: this.getClipAxes(),
                zBoundsForAnimation: _h,
              },
            }),
            L = J_(O),
            V = new Ai(L, x);
          V.dcgModelMatrix = new Nt().makeTranslation(d, p, h).multiply(
            new Nt().makeScale(u, f, y),
          ),
            this.surfaces[t] = {
              mesh: V,
              material: x,
              cacheKey: s,
              isNotInSketchOrder: false,
              materialColor: o,
              isTransparent: l < 1,
              shape: "sphere",
              shader: c,
            },
            this.world.add(V);
        }
        this.surfaces[t].isNotInSketchOrder = false;
      }
      renderCurve3D(e, t, o) {
        var h, u;
        let { points: i, thickness: n, guid: a } = e, s = VO(e.graphMode);
        if (n < 0 || !isFinite(n)) return;
        let l = this.domain(),
          c = a + ":" + JSON.stringify(n) + ":" + JSON.stringify(l),
          d = this.surfaces[t],
          p = ((h = this.getColorShader(o)) == null ? void 0 : h.source) ||
            "";
        if (
          d &&
          (d.cacheKey !== c || d.materialColor != o ||
            p != ((u = d.shader) != null ? u : "")) &&
          this.deleteSurface(t), !(i === void 0 || i.length === 0 || n === 0)
        ) {
          if (!this.surfaces[t]) {
            let f = this.materialManager.getOrMakeMaterial({
                type: "surface-graph",
                spec: {
                  type: "surface-material",
                  objectId: t,
                  color: o,
                  opacity: 1,
                  colorShader: this.getColorShader(o),
                },
                uniforms: {
                  domain: l,
                  clip: this.getClipAxes(s),
                  zBoundsForAnimation: _h,
                },
              }),
              y = .01 * n,
              [C, E, v] = u9(i, y, l),
              w = Z_(
                new Float32Array(C),
                new Float32Array(E),
                new Uint32Array(v),
              ),
              S = new Ai(w, f);
            this.surfaces[t] = {
              mesh: S,
              cacheKey: c,
              isNotInSketchOrder: false,
              isTransparent: false,
              materialColor: o,
            }, this.world.add(S);
          }
          this.surfaces[t].isNotInSketchOrder = false;
        }
      }
      renderVector3D(e, t, o, i) {
        var _, A;
        let n = this.isClickable(t),
          a = t === this.pressedActionData().pressedId,
          s = this.highlightedIndex(t),
          l = t + `:${o}`,
          { points: c, thickness: d, guid: p } = e,
          h = VO(e.graphMode),
          u = this.domain(),
          f = JSON.stringify(u),
          y = `${p}:${f}:${d}:${s}:${a}`,
          C = this.surfaces[l],
          E = ((_ = this.getColorShader(i)) == null ? void 0 : _.source) ||
            "";
        if (
          C &&
          (C.cacheKey !== y || C.materialColor != i ||
            E != ((A = C.shader) != null ? A : "")) &&
          this.deleteSurface(l),
            c === void 0 || c.length < 6 || c.length % 6 != 0
        ) return;
        this.needsHighlighting(t, o) && c.length === 6 &&
          (i = vm(i, this.highlightAmount(t, o)));
        let v = s !== void 0 && c.length > 6,
          w = vm(i, this.highlightAmount(t, s)),
          S = __dcg_shared_module_exports__["Qd"](i),
          k = __dcg_shared_module_exports__["Qd"](w);
        if (!this.surfaces[l]) {
          let P = c.length > 6 && n,
            O = this.materialManager.getOrMakeMaterial({
              type: "surface-graph",
              spec: {
                type: "surface-material",
                objectId: l,
                color: i,
                opacity: 1,
                colorShader: this.getColorShader(i),
                vertexColors: v,
                useVertexPickingColors: P,
              },
              uniforms: {
                domain: u,
                clip: this.getClipAxes(h),
                zBoundsForAnimation: _h,
              },
            }),
            U = P ? [] : void 0,
            z = .01 * d,
            x = [],
            L = [],
            V = [],
            R = [];
          for (let F = 0; F < c.length; F += 6) {
            let Z = new ye(c[F], c[F + 1], c[F + 2]),
              te = new ye(c[F + 3], c[F + 4], c[F + 5]),
              [Y, he, se] = y9(Z, te, z, u),
              ae = x.length / 3;
            if (
              x.push(...Y),
                L.push(...he),
                V.push(...se.map((q) => q + ae)),
                U == null || U.push(Y.length / 3),
                v
            ) {
              let q = F / 6 === s ? k : S;
              for (let oe = 0; oe < Y.length / 3; oe++) {
                R.push(q[0], q[1], q[2]);
              }
            }
          }
          let N = Z_(
            new Float32Array(x),
            new Float32Array(L),
            new Uint32Array(V),
          );
          v && N.setAttribute("color", new ha(new Float32Array(R), 3));
          let M = new Ai(N, O);
          this.surfaces[l] = {
            mesh: M,
            cacheKey: y,
            isNotInSketchOrder: false,
            isTransparent: false,
            materialColor: i,
            pickingColorVertexCounts: U,
          }, this.world.add(M);
        }
        this.surfaces[l].isNotInSketchOrder = false;
      }
      renderTriangle3D(e, t, o, i) {
        if (e.surfaceOpacity < p0) return;
        let n = this.isClickable(t),
          a = t + `:${o}`,
          s = t === this.pressedActionData().pressedId,
          l = this.highlightedIndex(t),
          c = `:${l}:${s}`,
          d = e.meshData.faces.length / 3,
          { meshData: p } = e,
          h = vm(i, this.highlightAmount(t, l)),
          u = __dcg_shared_module_exports__["Qd"](i),
          f = __dcg_shared_module_exports__["Qd"](h),
          y = [],
          C = d > 1 && n;
        if (
          this.needsHighlighting(t, o) && d === 1 &&
          (i = vm(i, this.highlightAmount(t, o))), l !== void 0 && d > 1
        ) {
          if (p.colors && l != null) {
            let w = p.colors,
              S = new Float32Array(w),
              k = 9 * l,
              _ = 255 * __dcg_shared_module_exports__["Pd"](w[k]),
              A = 255 * __dcg_shared_module_exports__["Pd"](w[k + 1]),
              P = 255 * __dcg_shared_module_exports__["Pd"](w[k + 2]),
              O = __dcg_shared_module_exports__["Ld"](_, A, P),
              U = vm(O, this.highlightAmount(t, o)),
              z = __dcg_shared_module_exports__["Qd"](U);
            S.set([...z, ...z, ...z], k),
              e = { ...e, meshData: { ...e.meshData, colors: S } };
          } else {
            for (let S = 0; S < p.faces.length; S += 3) {
              let k = S / 3 === l ? f : u;
              y.push(
                k[0],
                k[1],
                k[2],
                k[0],
                k[1],
                k[2],
                k[0],
                k[1],
                k[2],
              );
            }
            let w = new Float32Array(y);
            e = { ...e, meshData: { ...e.meshData, colors: w } };
          }
        }
        let v = this.renderSurface(e, a, i, C, c);
        if (C) {
          let w = [];
          for (let S = 0; S < d; S++) w.push(3);
          v && (v.pickingColorVertexCounts = w);
        }
      }
      renderSurface(e, t, o, i = false, n = "") {
        var y, C, E;
        this.getConfig().wireframe && (o = "wireframe:" + o);
        let { meshData: a, surfaceOpacity: s } = e;
        if (
          !this.getConfig().beta3d &&
          !this.controller.getTranslucentSurfaces() && (s = 1), s < p0
        ) return;
        let { uvArgs: l, restrictionShader: c } = e,
          d = (y = e.extraMeshArgs) != null ? y : [],
          p = VO(e.graphMode),
          h = ((C = this.getColorShader(o)) == null ? void 0 : C.source) ||
            "",
          u = this.domain(),
          f = a.guid + n;
        if (
          this.surfaces[t] &&
          (this.surfaces[t].cacheKey !== f ||
            this.surfaces[t].materialColor != o ||
            h != ((E = this.surfaces[t].shader) != null ? E : "") ||
            a.isDomainCube && !Rle(u, this.surfaces[t].domain)) &&
          this.deleteSurface(t), !this.surfaces[t]
        ) {
          let v = this.materialManager.getOrMakeMaterial({
            type: "surface-graph",
            spec: {
              type: "surface-material",
              objectId: t,
              color: o,
              opacity: s,
              colorShader: this.getColorShader(o),
              vertexColors: !!a.colors,
              useVertexPickingColors: i,
              restrictionShader: c,
              uvArgs: l,
              extraMeshArgs: d,
            },
            uniforms: {
              domain: u,
              clip: this.getClipAxes(p),
              zBoundsForAnimation: a.isDomainCube
                ? _h
                : this.getZBoundsForAnimationForNewSurface(t),
            },
          });
          if (a.isDomainCube) {
            let k = u, A = this.controller.getGrapher3d().transition;
            if (A.objectIdExtendingTo3D && A.startTime > 0) {
              let P = A.objectIdExtendingTo3D;
              if (P && t.startsWith(P + ":")) {
                let O = this.domain(),
                  { zmin: U, zmax: z } = O,
                  L = (window.performance.now() - A.startTime) /
                    A.duration;
                L < 1 && (k.zmin = L * U, k.zmax = L * z);
              }
            }
            a.positions = __dcg_shared_module_exports__["Wd"](k).positions;
          }
          let w = Z_(a.positions, a.normals, a.faces);
          w.setAttribute("uv", new Bo(a.uvs, 2)),
            d.length > 0 &&
            w.setAttribute("extras", new Bo(a.extraAttrs, d.length)),
            a.colors && w.setAttribute("color", new ha(a.colors, 3));
          let S = new Ai(w, v);
          this.surfaces[t] = {
            mesh: S,
            material: v,
            cacheKey: f,
            isNotInSketchOrder: false,
            materialColor: o,
            shader: h,
            isTransparent: s < 1,
            shape: Fle(a, u) ? "plane" : void 0,
            domain: u,
          }, this.world.add(S);
        }
        return this.surfaces[t].isNotInSketchOrder = false, this.surfaces[t];
      }
      projectMathCoordinates(e, t = new ye()) {
        return t.copy(e).applyMatrix4(this.world.matrixWorld).project(
          this.camera,
        );
      }
      finalizeSurface(e) {
        let {
          branchId: t,
          surface: o,
          renderOrder: i,
          isSurfaceSelected: n,
        } = e;
        this.pickingColorManager.setPickingColorForMesh({
          branchId: t,
          mesh: o.mesh,
          isPoint: !!o.isPoint,
          blocksPicking: false,
          forceOpaque: false,
          pickingColorVertexCounts: o.pickingColorVertexCounts,
        });
        let a = o == null ? void 0 : o.mesh.material;
        o && a instanceof kh &&
          (o.mesh.renderOrder = i, a.setEmissiveIntensity(n ? .015 : 0));
      }
      needsHighlighting(e, t) {
        if (!this.isClickable(e)) return false;
        let { keyboardFocusId: o, keyboardFocusIndex: i } = this
            .getKeyboardFocus(),
          { pressedId: n, pressedIndex: a } = this.pressedActionData(),
          s = this.getPickResult(),
          l = s == null ? void 0 : s.id,
          c = s == null ? void 0 : s.index;
        return e === l && t === c || e === o && t === i ||
          e === n && t === a;
      }
      highlightedIndex(e) {
        if (!this.isClickable(e)) return;
        let { keyboardFocusId: t, keyboardFocusIndex: o } = this
            .getKeyboardFocus(),
          { pressedId: i, pressedIndex: n } = this.pressedActionData(),
          a = this.getPickResult(),
          s = a == null ? void 0 : a.id,
          l = a == null ? void 0 : a.index;
        if (e === s) return l;
        if (e === t) return o;
        if (e === i) return n;
      }
      highlightAmount(e, t) {
        let { pressedId: o, pressedIndex: i } = this.pressedActionData();
        return e === o && t === i ? .16 : .24;
      }
      redraw(e, t) {
        var x, L, V;
        (x = this.debug) == null || x.removeUnused();
        let o = this.controller.getGrapher3d();
        if (o === void 0) return;
        this.renderedTabTargets = {}, this.renderedTabTargetOrder = [];
        let i = this.canvas,
          n = performance.now(),
          a = this.lastRenderInfo = {
            peelLayers: 0,
            bufferUploadItems: 0,
            bufferUploads: 0,
            triangles: 0,
            startTimeCPU: n,
            durationCPU: 0,
          },
          s = this.renderer;
        s.setRenderTarget(this.mainRenderTarget),
          this.updateBackgroundColor(),
          this.updateDomainObjectsFromCamera(),
          this.updateCamera();
        let l = window.devicePixelRatio || 1;
        l !== s.getPixelRatio() &&
        (s.setPixelRatio(l),
          o.controls.updateViewport(o.viewportController.getViewport())),
          this.camera.setViewOffset(
            i.width / l,
            i.height / l,
            0,
            0,
            i.width / l,
            i.height / l,
          ),
          s.setSize(i.width / l, i.height / l);
        for (let R in this.surfaces) {
          this.surfaces[R].isNotInSketchOrder = true;
        }
        let c = this.getPickResult();
        this.isClickable(c == null ? void 0 : c.id)
          ? o.setLayerClass(
            "clickableObjects",
            "dcg-mouse-over-clickable-object",
          )
          : o.setLayerClass("clickableObjects", void 0);
        let d = 0;
        for (let R of Rv(t)) {
          let N = e[R];
          if (!N || !N.branches) continue;
          let M = this.controller.isItemSelected(R),
            F = this.controller.getItemModel(R),
            Z = this.isClickable(R);
          if (
            (F == null ? void 0 : F.type) === "expression" &&
            (Lg(F) || $u(F))
          ) {
            let te = this.renderPointList3D(R, N.branches);
            if (te) {
              if (
                d += 1,
                  this.finalizeSurface({
                    branchId: R,
                    surface: te,
                    renderOrder: d,
                    isSurfaceSelected: M,
                  }),
                  Z
              ) {
                for (let Y = 0; Y < N.branches.length; Y++) {
                  this.addTabTarget(F, Y);
                }
              }
              continue;
            }
          }
          for (let te in N.branches) {
            d += 1;
            let Y = N.branches[te],
              he = R + ":" + te,
              se = Y.color,
              ae = parseInt(te);
            this.needsHighlighting(R, ae) &&
            (se = vm(se, this.highlightAmount(R, ae))),
              Y.graphMode === 130 || Y.graphMode === 103 ||
                Y.graphMode === 106 || Y.graphMode === 107 ||
                Y.graphMode === 108 || Y.graphMode === 109 ||
                Y.graphMode === 110 || Y.graphMode === 111 ||
                Y.graphMode === 112 || Y.graphMode === 113 ||
                Y.graphMode === 210
                ? this.renderSurface(Y, he, se)
                : Y.graphMode === 100 || Y.graphMode === 119 ||
                    Y.graphMode === 128
                ? this.renderCurve3D(Y, he, se)
                : Y.graphMode === 114
                ? this.renderPoint3D(Y, he, se)
                : Y.graphMode === 118
                ? this.renderSphere3D(Y, he, se)
                : Y.graphMode === 117
                ? this.renderTriangle3D(Y, R, ae, Y.color)
                : Y.graphMode === 129 &&
                  this.renderVector3D(Y, R, ae, Y.color);
            let q = this.surfaces[he];
            if (
              q &&
              (this.finalizeSurface({
                branchId: he,
                surface: q,
                renderOrder: d,
                isSurfaceSelected: M,
              }),
                Z)
            ) {
              if (Y.graphMode === 117) {
                let oe = Y.meshData.faces.length / 3;
                for (let K = 0; K < oe; K++) this.addTabTarget(F, K);
              } else if (Y.graphMode === 129 && ae === 0) {
                let oe = Y.points.length / 6;
                for (let K = 0; K < oe; K++) this.addTabTarget(F, K);
              } else this.addTabTarget(F, ae);
            }
          }
        }
        let p = 2.0001 * Lle(3),
          { xmin: h, xmax: u, ymin: f, ymax: y, zmin: C, zmax: E } = this
            .domain(),
          v = new ye((u + h) / 2, (y + f) / 2, (E + C) / 2),
          w = 4 / d0(u - h, y - f, E - C);
        for (let R in this.surfaces) {
          if (this.surfaces[R].isNotInSketchOrder) this.deleteSurface(R);
          else if (!this.controller.getGraphSettings().showBox3D) {
            let N = this.surfaces[R].mesh.geometry;
            N.boundingSphere === null && N.computeBoundingSphere();
            let M = N.boundingSphere;
            if (M === null) continue;
            let Z = (new ye().subVectors(v, M.center).length() + M.radius) * w;
            p = d0(p, Z);
          }
        }
        let S = this.computeDepthPeelLayers();
        S > 0 !==
            ((L = this.domainPlaneMaterials) == null
              ? void 0
              : L.depthPeelingActive) && this.updateDomainObjects();
        let _ = this.controller.getPerspectiveDistortion(),
          A = 1e3 / (0 < _ && _ < 1 ? _ : 1),
          P = d0(.001, this.cameraDistance - p),
          O = X_(A, this.cameraDistance + p);
        this.camera.near = P,
          this.camera.far = O,
          this.camera.updateProjectionMatrix(),
          this.materialManager.setGlobalUniform(
            "dcgRenderMode",
            gs.Default,
          ),
          this.mainRenderTarget.setSize(i.width, i.height),
          this.renderer.setRenderTarget(this.mainRenderTarget),
          this.materialManager.setScreenSize(i.width, i.height),
          a.peelLayers = S,
          S > 0
            ? (this.depthPeel.render(S), a.triangles = this.depthPeel.triangles)
            : (s.render(this.scene, this.camera),
              a.triangles = this.renderer.info.render.triangles),
          S == 0 &&
          this.mainCopyOutputPass.render(s, null, this.mainRenderTarget),
          this.debugOnlyMeasureGPUTiming &&
          V7(this.renderer).then((R) => {
            a.endTimeGPU = R;
          }),
          a.durationCPU = performance.now() - n,
          this.materialManager.disposeMaterialsNotInScene(this.scene),
          this.pickingColorManager.disposeColorsNotInScene(this.scene);
        let U = new Set();
        for (let R in this.surfaces) {
          (V = this.surfaces[R].material) != null && V.exprTooComplex &&
            U.add(MO(R));
        }
        let z = [];
        for (let R of this.lastFrameExpressionTooComplexIDs) {
          U.has(R) || z.push(R);
        }
        (U.size > 0 || z.length > 0) &&
        this.controller.dispatch({
          type: "mark-too-complex-for-gl",
          errors: U,
          fixed: z,
        }),
          this.lastFrameExpressionTooComplexIDs = U,
          this.onRenderSpy && this.onRenderSpy();
      }
      updateDomainObjectsFromCamera() {
        let e = this.controller.getGrapher3d();
        e && t9({
          axes: this.domainAxes,
          plane: this.domainPlane,
          domain: this.domain(),
          screen: this.controller.get2dProjection().screen,
          controls: e.controls,
          invertedColors: this.controller.getInvertedColors(),
          isDepthPeelingActive: this.computeDepthPeelLayers() > 0,
        });
      }
      pickAtMouseAndReadResults() {
        this.pickingPass(), this.readPickingOutputFromGPU();
      }
      getAllSurfaceGeoemtriesCacheKey() {
        let e = "";
        for (let t in this.surfaces) {
          let o = this.surfaces[t];
          e += o.cacheKey;
        }
        return e += "|domainUpdates:" + this.domainObjectUpdates, e;
      }
      getPickingCacheKey() {
        var e, t;
        return `world:${this.getWorldViewCacheKey()}:mouse:${
          (e = this.mouse) == null ? void 0 : e.x
        },${
          (t = this.mouse) == null ? void 0 : t.y
        }:surfaces:${this.getAllSurfaceGeoemtriesCacheKey()}`;
      }
      pickingPass() {
        if (this.controller.getGrapher3d() === void 0) return;
        let t = this.mouse;
        if (!t) return;
        let o = this.pickingPassCacheKey, i = this.getPickingCacheKey();
        if (o === i) return;
        this.pickingPassCacheKey = i;
        let n = this.scene.background,
          a = this.renderer.getClearColor(new vt()),
          s = new Map();
        this.world.children.forEach((u) => {
          var f;
          if (s.set(u, u.visible), u instanceof Ai) {
            let y = u.material;
            u.visible = !!((f = y.defines) != null && f.DCG_SUPPORTS_PICKING);
          } else u.visible = false;
        }),
          this.domainPlane && s.get(this.domainPlane) &&
          (this.domainPlane.visible = true,
            this.domainPlane.children.forEach((u) => {
              s.set(u, u.visible), u.visible = u.name === "xy plane";
            }));
        let l = window.devicePixelRatio,
          c = Math.floor(yl / 2),
          d = Math.floor(Uy / 2),
          [p, h] = [Math.floor(t.x * l) - c, Math.floor(t.y * l) - d];
        this.camera.setViewOffset(
          this.renderer.domElement.width,
          this.renderer.domElement.height,
          p,
          h,
          yl,
          Uy,
        ),
          this.renderer.setClearColor(new vt(0), 0),
          this.scene.background = null,
          this.materialManager.setGlobalUniform(
            "dcgRenderMode",
            gs.PickingObjectId,
          ),
          this.renderer.setRenderTarget(this.pickingTargets.id),
          this.renderer.clearColor(),
          this.renderer.render(this.scene, this.camera),
          this.materialManager.setGlobalUniform(
            "dcgRenderMode",
            gs.PickingX,
          ),
          this.renderer.setRenderTarget(this.pickingTargets.x),
          this.renderer.clearColor(),
          this.renderer.render(this.scene, this.camera),
          this.materialManager.setGlobalUniform(
            "dcgRenderMode",
            gs.PickingY,
          ),
          this.renderer.setRenderTarget(this.pickingTargets.y),
          this.renderer.clearColor(),
          this.renderer.render(this.scene, this.camera),
          this.materialManager.setGlobalUniform(
            "dcgRenderMode",
            gs.PickingZ,
          ),
          this.renderer.setRenderTarget(this.pickingTargets.z),
          this.renderer.clearColor(),
          this.renderer.render(this.scene, this.camera),
          this.concatPass.uniforms.t0 = {
            value: this.pickingTargets.id.texture,
          },
          this.concatPass.uniforms.t1 = {
            value: this.pickingTargets.x.texture,
          },
          this.concatPass.uniforms.t2 = {
            value: this.pickingTargets.y.texture,
          },
          this.concatPass.uniforms.t3 = {
            value: this.pickingTargets.z.texture,
          },
          this.camera.clearViewOffset(),
          this.renderer.setClearColor(a),
          this.scene.background = n,
          s.forEach((u, f) => {
            f.visible = u;
          }),
          this.concatPass.render(
            this.renderer,
            this.pickingTargets.combined,
            this.pickingTargets.combined,
          );
      }
      readPickingOutputFromGPU() {
        var v, w, S;
        let e = this.getPickingCacheKey();
        if (this.pickResult.pickingReadCacheKey === e) return;
        let t = Math.floor(yl / 2),
          o = Math.floor(Uy / 2),
          i = L_(
            this.renderer,
            this.pickingTargets.combined,
            0,
            0,
            yl * 4,
            Uy,
          ),
          n = l0(i, yl * 4, t, o),
          a = l0(i, yl * 4, yl + t, o),
          s = l0(i, yl * 4, 2 * yl + t, o),
          l = l0(i, yl * 4, 3 * yl + t, o),
          c = P_(a),
          d = P_(s),
          p = P_(l);
        if (
          (v = this.debug.get("pick-combined")) == null ||
          v.renderFromTarget(
            this.renderer,
            this.pickingTargets.combined,
            10,
          ), n.every((k) => k === 0)
        ) {
          this.pickResult = { pickingReadCacheKey: e };
          return;
        }
        let h = this.pickingColorManager.getDataForPickingColor(n);
        if (!h) {
          So(`Failed to find id for picking color ${n}`),
            this.pickResult = { pickingReadCacheKey: e };
          return;
        }
        if (h.blocksPicking) {
          this.pickResult = { pickingReadCacheKey: e };
          return;
        }
        let u = (S = (w = this.pickResult.result) == null ? void 0 : w.point) !=
            null
          ? S
          : new ye();
        if (u.set(c, d, p), h.isPoint) {
          let k = h.mesh, _;
          k instanceof Mi
            ? (_ = new Nt(), k.getMatrixAt(h.index, _))
            : _ = h.mesh.dcgModelMatrix, u = new ye(0, 0, 0).applyMatrix4(_);
        }
        let f = h.pickingId.split(":"),
          y = f.length,
          C = f[0],
          E = y > 1 ? parseInt(f[y - 1]) : -1;
        this.pickResult = {
          pickingReadCacheKey: e,
          result: { point: u, id: C, index: E },
        };
      }
      isClickable(e) {
        if (e === void 0) return false;
        let t = this.controller.getItemModel(e);
        return !!bb(t);
      }
      getPickResult() {
        return this.pickResult.result;
      }
      getKeyboardFocus() {
        let e = this.controller.getGrapher2d().poiController
            .keyboardAttentionManager.getKeyboardAttention(),
          t = e == null ? void 0 : e.calcId,
          o = e == null ? void 0 : e.listIndex;
        return { keyboardFocusId: t, keyboardFocusIndex: o };
      }
      pressedActionData() {
        var o, i;
        let e = (o = this.pressedAction) == null ? void 0 : o.id,
          t = (i = this.pressedAction) == null ? void 0 : i.index;
        return { pressedId: e, pressedIndex: t };
      }
      getZoomScrollWheelPickResult() {
        if (this.controller.getGrapher3d().controls.speed3D === 0) {
          return this.getPickResult();
        }
      }
      getMouse() {
        return this.mouse;
      }
      setMouse(e) {
        this.mouse = e;
      }
      getWorldViewCacheKey() {
        let { math: e, clip: t } = this.worldViewCacheKeyInfo, o = "";
        for (let i = 0; i < e.length; i++) {
          this.projectMathCoordinates(e[i], t[i]), o += `:${t[i].x},${t[i].y}`;
        }
        return o;
      }
      baseplaneMultiplier() {
        let e = E9 * (Math.PI / 360),
          t = this.camera instanceof xh ? S9(this.perspective * PO(e)) : e;
        return 2 / (PO(t) * -this.camera.position.x);
      }
      mathCoordinatesToBufferCoordinates(e) {
        let t = new ye(e.x, e.y, e.z).applyMatrix4(this.world.matrixWorld)
            .project(this.camera),
          o = this.canvas,
          i = o.width / 2,
          n = o.height / 2,
          a = Math.round(t.x * i + i),
          s = Math.round(t.y * n + n);
        return { x: a, y: s };
      }
      mathCoordinatesToScreenCoordinates(e, t) {
        let o = new ye(e.x, e.y, e.z).applyMatrix4(this.world.matrixWorld)
            .project(this.camera),
          i = this.canvas,
          n = window.devicePixelRatio,
          a = i.width / n / 2,
          s = i.height / n / 2,
          l = o.x * a + a,
          c = -o.y * s + s;
        return (!t || !t.skipRounding) &&
          (l = Math.round(l), c = Math.round(c)),
          { x: l, y: c };
      }
      _testingGetMeshById(e) {
        let t = this.surfaces[e];
        return t ? t.mesh : void 0;
      }
      remove() {
        this.materialManager.disposeAllMaterials(),
          this.pickingColorManager.disposeColorsNotInScene(new eu()),
          this.domainBox && DO(this.domainBox),
          this.domainAxes &&
          (kO(this.domainAxes), e9(this.axesMaterials)),
          this.renderer.dispose(),
          this.renderer.forceContextLoss();
      }
      addTabTarget(e, t) {
        let o = JP(e.id, t);
        this.renderedTabTargetOrder.indexOf(o) !== -1 ||
          this.renderedTabTargets[o] !== void 0 ||
          (this.renderedTabTargetOrder.push(o),
            this.renderedTabTargets[o] = {
              type: e.type,
              id: e.id,
              listIndex: t,
              description: this.getComputedDescription(e, t),
            });
      }
      getOrderedTabTargets() {
        return this.renderedTabTargetOrder.map((e) => {
          let t = this.renderedTabTargets[e];
          return {
            calcId: t.id,
            listIndex: t.listIndex,
            polygonEdge: void 0,
            description: t.description,
          };
        });
      }
      setPressedAction(e) {
        this.pressedAction = e,
          e !== void 0 && (this.isTrackingPressedAction = true);
        let t = this.controller.getGrapher3d();
        t && (t.controls.state = tu.NONE, t.redrawAllLayers());
      }
      getPressedAction() {
        return this.pressedAction;
      }
      getComputedDescription(e, t) {
        let o = e.formula && e.formula.computed_description &&
          e.formula.computed_description[t];
        return o && o !== "" ? ei(o) : this.getDescription(e);
      }
      getDescription(e) {
        switch (e.formula.expression_type) {
          case "SURFACE":
          case "SURFACE_AMBIGUOUS":
          case "SURFACE_CONSTANT_AMBIGUOUS":
          case "SURFACE_r_\u03B8z":
          case "SURFACE_r_\u03B8z_AMBIGUOUS":
          case "SURFACE_z_r\u03B8":
          case "SURFACE_r_\u03B8\u03C6":
          case "SURFACE_xyz_uv":
          case "IMPLICIT_SURFACE":
          case "IMPLICIT_SURFACE_AMBIGUOUS":
            return this.controller.raw("surface");
          case "CURVE3D_xyz_t":
          case "SLICE":
          case "SLICE_r\u03B8z_at_z":
          case "SLICE_zr\u03B8_at_r":
          case "SLICE_zr\u03B8_at_\u03B8":
          case "SLICE_zr\u03B8_at_xyz":
          case "SLICE_r\u03B8\u03C6_at_\u03B8":
          case "SLICE_r\u03B8\u03C6_at_\u03C6":
          case "SLICE_r\u03B8\u03C6_at_xyz":
          case "SLICE_xyz_uv":
            return this.controller.raw("curve");
          case "SEGMENT3D":
            return this.controller.raw("segment");
          case "VECTOR3D":
            return this.controller.raw("vector");
          case "SPHERE3D":
            return this.controller.raw("sphere");
          case "POINT3D":
          case "POINT3D_LIST":
            return this.controller.raw("point");
          case "TRIANGLE3D":
            return this.controller.raw("triangle");
        }
        return this.controller.raw("3d object");
      }
    };
  function Vle(r) {
    let e = new Vy({
      antialias: true,
      alpha: true,
      preserveDrawingBuffer: true,
      canvas: r,
    });
    return e.setPixelRatio(window.devicePixelRatio || 1), e;
  }
  function VO(r) {
    switch (r) {
      case 106:
        return { x: true, y: true, z: false };
      case 107:
        return { x: false, y: true, z: true };
      case 108:
        return { x: true, y: false, z: true };
      case 110:
        return { x: false, y: false, z: true };
      case 112:
      case 113:
      case 210:
      case 128:
        return { x: true, y: true, z: true };
      default:
        return { x: false, y: false, z: false };
    }
  }
  var _h = { zMinForAnimation: -1 / 0, zMaxForAnimation: 1 / 0 };
  function Z_(r, e, t) {
    let o = new La();
    return o.setIndex(r.length < 65536 ? new fh(t, 1) : new bh(t, 1)),
      o.setAttribute("position", new Bo(r, 3)),
      o.setAttribute("normal", new Bo(e, 3)),
      o;
  }
  var eI = [];
  function J_(r) {
    let e = r < .02 ? 1 : r < .05 ? 2 : r < .2 ? 3 : r < .8 ? 4 : 5;
    if (eI[e] === void 0) {
      let t = L7(e);
      eI[e] = Z_(t.vertices, t.vertices, t.indices);
    }
    return eI[e];
  }
  function Ole(r) {
    return eI.includes(r);
  }
  function Rle(r, e) {
    return e !== void 0 && r.xmin === e.xmin && r.xmax === e.xmax &&
      r.ymin === e.ymin && r.ymax === e.ymax && r.zmin === e.zmin &&
      r.zmax === e.zmax;
  }
  function vm(r, e) {
    return __dcg_shared_module_exports__["Xd"](r)
      ? r
      : __dcg_shared_module_exports__["Kd"](r, e);
  }
  function Fle(r, e) {
    let t = r.faces.length / 3,
      o = r.positions.length / 3,
      { xmin: i, xmax: n, ymin: a, ymax: s, zmin: l, zmax: c } = e,
      d = (u) => (u - i) / (n - i),
      p = (u) => (u - a) / (s - a),
      h = (u) => (u - l) / (c - l);
    if (t === 1) return true;
    if (t === 2 && o === 4) {
      let u = r.positions,
        f = new ye(d(u[0]), p(u[1]), h(u[2])),
        y = new ye(d(u[3]), p(u[4]), h(u[5])),
        C = new ye(d(u[6]), p(u[7]), h(u[8])),
        E = new ye(d(u[9]), p(u[10]), h(u[11])),
        v = new ye().subVectors(y, f),
        w = new ye().subVectors(C, f),
        S = new ye().subVectors(E, f),
        k = v.cross(w);
      return Q_(k.dot(S) / (k.length() * S.length())) < .01;
    }
    return false;
  }
  function MO(r) {
    return r.split(":")[0];
  }
  var Nle = 1e3;
  function Ble() {
    return new hl(1024, 768);
  }
  function P9() {
    return new Br(
      __dcg_shared_module_exports__["xc"].xmin,
      __dcg_shared_module_exports__["xc"].xmax,
      __dcg_shared_module_exports__["xc"].ymin,
      __dcg_shared_module_exports__["xc"].ymax,
      __dcg_shared_module_exports__["xc"].zmin,
      __dcg_shared_module_exports__["xc"].zmax,
    );
  }
  var rI = class extends my {
    constructor(t, o, i, n) {
      super({ elt: t, settings: o, controller: i, evaluator: n });
      this.type = "3d";
      this.screen = Ble();
      this.redrawTickCount = 0;
      let a = P9();
      this.setUserRequestedViewport(a),
        this.viewportController = new __(a, this),
        this.graphSketches = {};
      let s = document.createElement("canvas");
      s.className = "dcg-webgl-canvas",
        this.getDebugPixelRatio() !== 1 &&
        (s.style.imageRendering = "pixelated"),
        this.webglLayer = new u0(s, i),
        this.elt.appendChild(s),
        this.transition = new A_(),
        this.controls = new I_(
          this.webglLayer.spinningWorld,
          this,
          this.canvasLayer.canvasNode,
        ),
        this.controls.setWorldRotation(zd()),
        this.controls.unsnappedRotation.copy(
          this.controls.worldRotation3D,
        ),
        this.addKeydownEventHandler();
    }
    isDefaultDomain() {
      let t = this.viewportController.getViewport(),
        o = this.getDefaultViewport();
      return t.xmin === o.xmin && t.xmax === o.xmax &&
        t.ymin === o.ymin && t.ymax === o.ymax && t.zmin === o.zmin &&
        t.zmax === o.zmax;
    }
    getDebugPixelRatio() {
      var t;
      return (t = this.settings.config.debugPixelRatio) != null ? t : 1;
    }
    startZoom() {
      this.settings.config.disableWorkerOnZoom &&
        this.evaluator.setTicksEnabled(false);
    }
    endZoom() {
      this.settings.config.disableWorkerOnZoom &&
        this.evaluator.setTicksEnabled(true);
    }
    remove() {
      this.controls.dispose(),
        this.elt.remove(),
        this.viewportController.remove(),
        this.webglLayer.remove();
    }
    tick(t) {
      this.redrawTickCount += 1,
        this.controller.getGrapher2d().tick(t),
        M7(this.controls);
      let o = this.webglLayer.getPickResult();
      this.webglLayer.pickAtMouseAndReadResults();
      let i = this.webglLayer.getPickResult();
      __dcg_shared_module_exports__["E"](o, i) ||
      (this.__redrawRequested = true),
        (!this.lastRenderedWorldRotation ||
          !this.lastRenderedWorldRotation.equals(
            this.controls.worldRotation3D,
          )) &&
        (this.__redrawRequested = true,
          this.lastRenderedWorldRotation = this.controls.worldRotation3D
            .clone()),
        this.__redrawRequested && this._redrawAllLayers();
    }
    clear() {
      this.graphSketches = {}, this.controller.getGrapher2d().clear();
    }
    getGraphSketch(t) {
      return this.graphSketches[t];
    }
    addGraphSketch(t) {
      this.graphSketches[t.id] = t;
    }
    removeGraphSketch(t) {
      t in this.graphSketches && delete this.graphSketches[t];
    }
    flatWorldRotation3D() {
      return [...this.controls.worldRotation3D.elements];
    }
    debounceUserRequestedRotationChange() {
      this.__debouncedRotationCommit ||
      (this.__debouncedRotationCommit = __dcg_shared_module_exports__
        ["A"](() => {
          if (this.isDragging) return;
          let t = this.flatWorldRotation3D();
          (this.settings.worldRotation3D.length === 0 &&
                  this.controls.worldRotation3D.equals(zd()) ||
                __dcg_shared_module_exports__["E"](
                  this.settings.worldRotation3D,
                  t,
                )) &&
              this.settings.axis3D === this.controls.axis3D &&
              this.settings.speed3D === this.controls.speed3D ||
            this.controller.dispatch({
              type: "commit-user-requested-rotation",
              worldRotation3D: t,
              axis3D: this.controls.axis3D,
              speed3D: this.controls.speed3D,
            });
        }, Nle)), this.__debouncedRotationCommit();
    }
    getDefaultViewport() {
      return P9();
    }
    _updateScreenSize(t, o) {
      if (t <= 0 || o <= 0) return;
      let i = this.screen;
      i.width === t && i.height === o ||
        (this.screen = new hl(t, o),
          this.viewportController.setScreen(this.screen));
    }
    getProjection() {
      return new Rs(
        this.screen,
        this.viewportController.getViewport(),
        this.settings,
      );
    }
    size() {
      let t = this.canvasLayer.ctx;
      if (!t) return this.controller.getGrapher2d().size();
      let { width: o, height: i } = t.canvas.getBoundingClientRect();
      return o === 0 || i === 0
        ? this.controller.getGrapher2d().size()
        : { width: o, height: i };
    }
    update() {
      let { top: t, left: o, width: i, height: n } =
          this.controller.computeMajorLayout().grapher,
        a = this.baseplaneWidth(),
        s = this.controller.getGrapher2d();
      s.setCanvasSizeFor3D(a, a),
        s.update(),
        this.webglLayer.updateDomainObjects(),
        i > 0 && n > 0
          ? (this._setIsVisible(true),
            this._updateScreenSize(i, n),
            Wn(this.elt, {
              position: "absolute",
              left: o + "px",
              top: t + "px",
              width: i + "px",
              height: n + "px",
            }))
          : this._setIsVisible(false);
    }
    deselectSketch(t) {
      let o = this.getGraphSketch(t);
      o && (o.selected = false, o.showHighlight = false);
    }
    selectSketch(t) {
      let o = this.getGraphSketch(t);
      o && (o.selected = true, o.showHighlight = true);
    }
    setSketchHoistedToTop(t, o) {
      let i = this.getGraphSketch(t);
      i && (i.hoistToTop = o);
    }
    updateSketch(t, o) {
      if (!o.length) {
        this.removeGraphSketch(t);
        return;
      }
      let i = new _D(t, o);
      i.color = o[0].color;
      let n = this.getGraphSketch(t);
      n && i.updateFrom(n);
      let a = this.controller.getPropagatedSelectedIds(),
        s = !!a.selected[t],
        l = !!a.hoistedToTop[t];
      i.selected = s,
        i.showHighlight = s,
        i.hoistToTop = l,
        this.addGraphSketch(i);
    }
    _redrawAllLayers() {
      if (!this.isVisible) return;
      let t = Date.now();
      this.__redrawRequested = false,
        this.canvasLayer.resize(this.screen.width, this.screen.height),
        this.controls.update(),
        this._redrawWebglLayer(),
        this.events.triggerEvent("redraw", Date.now() - t),
        this.canvasLayer.updateAria(this.isVisible, 0);
    }
    _redrawWebglLayer() {
      let t = this.getDebugPixelRatio();
      this.webglLayer.canvas.width = this.canvasLayer.canvasNode.width /
        t,
        this.webglLayer.canvas.height = this.canvasLayer.canvasNode.height / t,
        t !== 1 &&
        (this.webglLayer.canvas.style.transform = `scale(${t})`,
          this.webglLayer.canvas.style.transformOrigin = "0 0"),
        this.webglLayer.redraw(this.graphSketches, this.__drawLayers);
    }
    _parseScreenshotOpts(t) {
      return yV(t, this.settings, this.screen);
    }
    screenshot(t) {
      let o = document.createElement("canvas"),
        i = this._parseScreenshotOpts(t);
      o.width = i.width * i.targetPixelRatio,
        o.height = i.height * i.targetPixelRatio;
      let n = this.screenshotToCanvas(o), a = o.toDataURL("image/png");
      return n && n(), a;
    }
    asyncScreenshot(t, o) {
      t.format === "svg" &&
        __dcg_shared_module_exports__["qe"].warn(
          "Unsupported format 'svg' for 3d screenshot. Assuming 'png' format instead.",
        );
      for (
        let i of ["showLabels", "showMovablePoints", "mathBounds", "mode"]
      ) {
        t.hasOwnProperty(i) &&
          __dcg_shared_module_exports__["qe"].warn(
            `Property ${i} is ignored for 3d screenshot.`,
          );
      }
      o(this.screenshot(t));
    }
    screenshotToCanvas(t) {
      let o = new u0(t, this.controller);
      return o.spinningWorld.setRotationFromMatrix(
        new Nt().setFromMatrix3(this.controls.worldRotation3D),
      ),
        o.redraw(this.graphSketches, this.__drawLayers),
        () => o.remove();
    }
    _afterViewportChange() {
      this.webglLayer !== void 0 && this.webglLayer.updateDomainObjects();
    }
    computeConcreteViewport(t) {
      return t;
    }
    setGrapherState(t, o) {
      t = __dcg_shared_module_exports__["od"](Os, t),
        "complex" in t && !this.controller.canEnableComplexMode() &&
        (t = { ...t, complex: false }),
        (!o || !o.doNotClear) && this.clear();
      for (let i in Os) {
        Os.hasOwnProperty(i) && this.settings.setProperty(i, t[i]);
      }
      if ("viewport" in t) {
        let i = Br.fromObject(t.viewport);
        this.setUserRequestedViewport(i),
          this.viewportController.setViewport(i),
          this.webglLayer !== void 0 &&
          this.webglLayer.updateDomainObjects();
      }
      if (
        "speed3D" in t && (this.controls.speed3D = t.speed3D),
          "worldRotation3D" in t
      ) {
        let i = t.worldRotation3D;
        if (i.length === 9) {
          let n = new Po();
          n.set(i[0], i[3], i[6], i[1], i[4], i[7], i[2], i[5], i[8]),
            this.controls.setWorldRotation(n),
            this.controls.unsnappedRotation.copy(
              this.controls.worldRotation3D,
            ),
            !this.controls.isHorizonLevel() &&
            !this.controller.getGraphSettings().config.beta3d &&
            (this.controls.setWorldRotation(zd()),
              this.controls.unsnappedRotation.copy(
                this.controls.worldRotation3D,
              ),
              this.controls.speed3D = 0);
        } else {this.controls.setWorldRotation(zd()),
            this.controls.unsnappedRotation.copy(
              this.controls.worldRotation3D,
            );}
      }
      "axis3D" in t && (this.controls.axis3D = t.axis3D),
        this.controller.requestRedrawGraph();
    }
    baseplaneWidth() {
      let t = this.controller.computeMajorLayout().grapher,
        { width: o, height: i } = t;
      return o < 360 && (i = 360 * (i / o), o = 360),
        i < 360 && (o = 360 * (o / i), i = 360),
        Math.ceil(Math.min(o, i) * this.webglLayer.baseplaneMultiplier());
    }
    mathCoordinatesToScreenCoordinates(t) {
      return this.webglLayer.mathCoordinatesToScreenCoordinates(t);
    }
    addKeydownEventHandler() {
      ee(this.elt).on("keydown", (t) => {
        if (!this.controller.isGraphPaperFocused()) return;
        let o = t;
        if (o.altKey || o.ctrlKey || o.metaKey) return;
        let i = ke(o);
        if (i === "Tab") {
          let a = o.shiftKey ? "prev" : "next";
          this.handleTabEvent(a, o), this.redrawAllLayers();
          return;
        }
        let n = this.controller.getGrapher2d().poiController
          .keyboardAttentionManager.getKeyboardAttention();
        if (n) {
          if (i === "Enter" || i === "Space") {
            let a = this.controller.getItemModel(n.calcId);
            bb(a) &&
              this.controller.dispatch({
                type: "clickable-item-clicked",
                id: n.calcId,
                listIndex: n.listIndex,
              });
          }
          return;
        }
        i !== "Up" && i !== "Down" && i !== "Left" && i !== "Right" ||
          (o.stopPropagation(),
            o.preventDefault(),
            this.controls.applyTiltFromKeyboard(i, o.shiftKey),
            this.debounceUserRequestedRotationChange());
      }),
        ee(this.elt).on("keyup", () => {
          this.controller.isGraphPaperFocused() && this.controls.keyUp();
        });
    }
    getCanvasNode() {
      return this.webglLayer.canvas;
    }
    getOrderedTabTargets() {
      return this.webglLayer.getOrderedTabTargets();
    }
    handleTabEvent(t, o) {
      let n = this.controller.getGrapher2d().poiController
          .keyboardAttentionManager,
        s = n.getKeyboardAttention() !== void 0;
      if (t === "prev" && !s) {
        n.updateKeyboardAttention(void 0, { describe: false }),
          this.webglLayer.updateDomainObjects();
        return;
      }
      if (
        n.focusNextObjFromKeyboard({
          direction: t,
          allowWrapping: false,
          selectNonClickables: false,
        })
      ) {
        o == null || o.preventDefault(),
          o == null || o.stopPropagation(),
          this.webglLayer.updateDomainObjects();
        return;
      } else {
        n.updateKeyboardAttention(void 0, { describe: false }),
          t === "prev" && s &&
          (this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "graph-paper" },
          }),
            this.speakGrapherFocusAriaLabel(),
            o == null || o.preventDefault(),
            o == null || o.stopPropagation()),
          this.webglLayer.updateDomainObjects();
        return;
      }
    }
    speakGrapherFocusAriaLabel() {
      let o = this.elt.getElementsByClassName("dcg-graph-outer")[0]
        .getAttribute("aria-label");
      o && xe(o);
    }
  };
  mg();
  var Wt = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Ut = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var ze = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var ru = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    tr = class extends ru.Class {
      template() {
        return ru.createElement(
          "div",
          {
            class: () => {
              var e, t, o, i, n;
              return {
                "dcg-keypad-btn-container": true,
                "dcg-disabled": this.isDisabled(),
                [
                  (o = (t = (e = this.props).additionalClass) == null
                      ? void 0
                      : t.call(e)) != null
                    ? o
                    : ""
                ]: !!((n = (i = this.props).additionalClass) != null &&
                  n.call(i)),
              };
            },
            style: () => {
              var e;
              return {
                "flex-grow": (e = this.getColSpan()) == null
                  ? void 0
                  : e.toString(),
              };
            },
          },
          ru.createElement(
            "span",
            {
              role: ru.const("button"),
              class: this.bindFn(this.getClasses),
              "dcg-command": this.props.command,
              "aria-label": this.bindFn(this.getAriaLabel),
              "aria-disabled": this.bindFn(this.isDisabled),
              "aria-controls": this.props.ariaControls
                ? this.props.ariaControls
                : this.const(void 0),
              "aria-expanded": this.props.ariaExpanded
                ? this.bindFn(this.getAriaExpanded)
                : this.const(void 0),
              onTap: () => {
                this.isDisabled() || this.props.onTap();
              },
            },
            ru.createElement("span", {
              class: ru.const("dcg-keypad-btn-content"),
            }, this.props.children),
          ),
        );
      }
      getClasses() {
        let e = {
            "dcg-keypad-btn": true,
            "dcg-keypad-btn-active": this.isActive(),
          },
          t = this.props.style();
        switch (t) {
          case "default":
            e["dcg-btn-light-on-gray"] = true;
            break;
          case "highlight":
            e["dcg-btn-dark-on-gray"] = true;
            break;
          case "popover":
            e["dcg-btn-light-gray"] = true;
            break;
          case "blue":
            e["dcg-btn-short-blue"] = true;
            break;
          case "tall-blue":
            e["dcg-btn-tall-blue"] = true;
            break;
          default:
            return t;
        }
        return e;
      }
      isActive() {
        return this.props.active ? this.props.active() : false;
      }
      getAriaLabel() {
        return this.props.ariaLabel
          ? this.props.ariaLabel()
          : this.props.command();
      }
      getColSpan() {
        if (this.props.colspan) return this.props.colspan();
      }
      isDisabled() {
        return this.props.disabled && this.props.disabled();
      }
      getAriaExpanded() {
        return this.props.ariaExpanded ? this.props.ariaExpanded() : void 0;
      }
    };
  var oI = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var V9 = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    Cm = class extends V9.Class {
      init() {
        this.controller = this.props.controller();
      }
    };
  var Or = class extends Cm {
    template() {
      return oI.createElement("div", {
        class: oI.const("dcg-basic-keypad dcg-do-not-blur"),
      }, this.props.children);
    }
  };
  var re = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { IfElse: F9, If: O9, Switch: Ule } = re.Components;
  function cr(r, e) {
    return r === void 0
      ? re.const(e)
      : typeof r == "function"
      ? r
      : re.const(r);
  }
  function qy(r) {
    return (e, t, o = {}, i) =>
      re.createElement(
        tr,
        {
          command: re.const(r.command || r.typedText || r.keys[0]),
          ariaLabel: () =>
            r.ariaLabelKey ? i(r.ariaLabelKey) : r.typedText || r.keys[0],
          colspan: cr(o.colspan, 1),
          style: () => o.style || "default",
          onTap: () =>
            t({
              type: "keypad/type-text",
              text: r.typedText || r.keys[0],
            }),
        },
        F9(() => r.keys[0] === "{" || r.keys[0] === "[", {
          true: () =>
            re.createElement(
              "span",
              {
                class: re.const("dcg-mq-math-mode"),
                style: re.const("font-size: 120%"),
              },
              re.const(r.keys[0]),
              re.const("\xA0"),
              re.createElement(
                "span",
                { style: re.const("color: #999") },
                re.const(r.keys[1]),
              ),
            ),
          false: () =>
            re.createElement(
              "span",
              { class: re.const("dcg-either-or-btn") },
              re.createElement(nt, {
                config: re.const({}),
                latex: re.const(r.keys[0]),
              }),
              re.createElement(
                "span",
                { style: re.const("color: #999") },
                re.createElement(nt, {
                  config: re.const({}),
                  latex: re.const(r.keys[1]),
                }),
              ),
            ),
        }),
      );
  }
  function Hy(r) {
    return (e, t, o = {}, i) =>
      re.createElement(
        tr,
        {
          command: re.const(r.command || r.typedText || r.keys[1]),
          ariaLabel: () =>
            r.ariaLabelKey ? i(r.ariaLabelKey) : r.typedText || r.keys[0],
          colspan: cr(o.colspan, 1),
          style: cr(o.style, "default"),
          onTap: () =>
            t({
              type: "keypad/type-text",
              text: r.typedText || r.keys[1],
            }),
        },
        F9(() => r.keys[1] === "}" || r.keys[1] === "]", {
          true: () =>
            re.createElement(
              "span",
              {
                class: re.const("dcg-mq-math-mode"),
                style: re.const("font-size: 120%"),
              },
              re.createElement(
                "span",
                { style: re.const("color: #999") },
                re.const(r.keys[0]),
              ),
              re.const("\xA0"),
              re.const(r.keys[1]),
            ),
          false: () =>
            re.createElement(
              "span",
              null,
              re.createElement(
                "span",
                { style: re.const("color: #999") },
                re.createElement(nt, {
                  config: re.const({}),
                  latex: re.const(r.keys[0]),
                }),
              ),
              re.createElement(nt, {
                config: re.const({}),
                latex: re.const(r.keys[1]),
              }),
            ),
        }),
      );
  }
  function zle(r) {
    return (e, t, o = {}, i) =>
      re.createElement(
        tr,
        {
          command: re.const(r.command),
          ariaLabel: () => r.ariaLabelKey ? i(r.ariaLabelKey) : e,
          colspan: cr(o.colspan, 1),
          style: () => o.style || "default",
          onTap: () => {
            t({ type: "keypad/audio-trace", command: r.command });
          },
        },
        re.createElement(O9, {
          predicate: re.const(r.iconClass !== void 0),
        }, () =>
          re.createElement(
            "span",
            {
              class: () => ({
                "dcg-button-icon": true,
                "dcg-icon-only": r.contentKey === void 0,
              }),
            },
            re.createElement("i", {
              class: re.const(r.iconClass),
              "aria-hidden": re.const("true"),
            }),
          )),
        re.createElement(
          O9,
          { predicate: re.const(r.contentKey !== void 0) },
          () => re.createElement("span", null, () => i(r.contentKey) || e),
        ),
      );
  }
  function Me(r) {
    return (e, t, o = {}, i) =>
      re.createElement(
        tr,
        {
          command: re.const(r.command || e),
          ariaLabel: () => r.ariaLabelKey ? i(r.ariaLabelKey) : e,
          colspan: cr(o.colspan, 1),
          style: () => o.style || "default",
          onTap: () => t({ type: "keypad/type-text", text: r.typedText || e }),
        },
        re.createElement(nt, {
          config: re.const({}),
          latex: re.const(r.content || e),
        }),
      );
  }
  function R9(r) {
    return (e, t, o = {}, i) =>
      re.createElement(
        tr,
        {
          command: re.const(r.command || e),
          ariaLabel: () => r.ariaLabelKey ? i(r.ariaLabelKey) : e,
          colspan: cr(o.colspan, 1),
          style: () => o.style || "default",
          onTap: () => t({ type: "keypad/type-text", text: r.typedText || e }),
        },
        re.createElement(
          "span",
          { class: re.const("dcg-mq-math-mode") },
          re.const(r.content || e),
        ),
      );
  }
  function Pe(r) {
    return (e, t, o = {}, i) =>
      re.createElement(
        tr,
        {
          command: re.const(e),
          ariaLabel: () => r.ariaLabelKey ? i(r.ariaLabelKey) : e,
          colspan: cr(o.colspan, 1),
          style: () => o.style || "default",
          onTap: () => t({ type: "keypad/type-text", text: e + "(" }),
        },
        re.createElement(
          Ule,
          { key: () => !!e.match(/^[a-z]{2,}$/) },
          (n) =>
            n
              ? re.createElement(
                "span",
                {
                  class: re.const(
                    "dcg-mq-math-mode dcg-static-mathquill-view",
                  ),
                },
                re.createElement(
                  "span",
                  { class: re.const("dcg-mq-root-block") },
                  re.createElement("span", {
                    class: re.const("dcg-mq-operator-name"),
                  }, () => e),
                ),
              )
              : re.createElement(nt, {
                config: re.const({}),
                latex: re.const(e),
              }),
        ),
      );
  }
  function On(r) {
    return (e, t, o = {}, i) =>
      re.createElement(
        tr,
        {
          command: re.const(r.command),
          ariaLabel: () => r.ariaLabelKey ? i(r.ariaLabelKey) : r.command,
          colspan: cr(o.colspan, 1),
          style: () => o.style || "default",
          onTap: () => {
            t({ type: "keypad/custom-command", command: r.command });
          },
        },
        re.createElement(nt, {
          config: re.const({}),
          latex: re.const(r.content),
        }),
      );
  }
  var qle = {
    "{": R9({
      ariaLabelKey: "shared-calculator-narration-keypad-key-left-bracket",
    }),
    "}": R9({
      ariaLabelKey: "shared-calculator-narration-keypad-key-right-bracket",
    }),
    "(": Me({
      ariaLabelKey: "shared-calculator-narration-keypad-key-left-paren",
    }),
    ")": Me({
      ariaLabelKey: "shared-calculator-narration-keypad-key-right-paren",
    }),
    sqrt: Me({
      content: "\\sqrt{}",
      ariaLabelKey: "shared-calculator-narration-keypad-key-sqrt",
    }),
    "/": Me({
      ariaLabelKey: "shared-calculator-narration-keypad-key-divide",
    }),
    division: Me({
      content: "\xF7",
      typedText: "/",
      command: "/",
      ariaLabelKey: "shared-calculator-narration-keypad-key-divide",
    }),
    obelus: Me({
      content: "\xF7",
      typedText: "\xF7",
      ariaLabelKey: "shared-calculator-narration-keypad-key-divide",
    }),
    "*": Me({
      ariaLabelKey: "shared-calculator-narration-keypad-key-times",
    }),
    multiplication: Me({
      content: "\xD7",
      typedText: "*",
      command: "*",
      ariaLabelKey: "shared-calculator-narration-keypad-key-times",
    }),
    "\xB1": Me({
      ariaLabelKey: "shared-calculator-narration-keypad-plus-minus",
    }),
    "-": Me({
      ariaLabelKey: "shared-calculator-narration-keypad-key-minus",
    }),
    "+": Me({
      ariaLabelKey: "shared-calculator-narration-keypad-key-plus",
    }),
    ".": Me({
      ariaLabelKey: "shared-calculator-narration-keypad-key-decimal",
    }),
    ans: (r, e, t = {}, o) =>
      re.createElement(tr, {
        command: re.const(r),
        ariaLabel: () => o("shared-calculator-narration-keypad-key-ans"),
        colspan: cr(t.colspan, 1),
        style: () => t.style || "default",
        onTap: () => e({ type: "keypad/type-text", text: r }),
      }, re.const("ans")),
    enter: (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () => o("shared-calculator-narration-keypad-key-enter"),
          colspan: cr(t.colspan, 1),
          style: () => t.style || "default",
          onTap: () =>
            e({
              type: "keypad/press-key",
              key: "Enter",
              source: "keypad",
            }),
        },
        re.createElement("i", {
          class: re.const("dcg-icon-arrow-enter"),
          "aria-hidden": re.const("true"),
        }),
      ),
    undo: (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () => o("shared-calculator-narration-keypad-key-enter"),
          colspan: cr(t.colspan, 1),
          disabled: cr(t.disabled, false),
          style: () => t.style || "default",
          onTap: () => e({ type: "undo", source: "button-tap" }),
        },
        re.createElement("i", {
          class: re.const("dcg-icon-undo"),
          "aria-hidden": re.const("true"),
        }),
      ),
    redo: (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () => o("shared-calculator-narration-keypad-key-enter"),
          colspan: cr(t.colspan, 1),
          disabled: cr(t.disabled, false),
          style: () => t.style || "default",
          onTap: () => e({ type: "redo", source: "button-tap" }),
        },
        re.createElement("i", {
          class: re.const("dcg-icon-redo"),
          "aria-hidden": re.const("true"),
        }),
      ),
    shift: (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () => o("shared-calculator-narration-keypad-key-shift"),
          colspan: cr(t.colspan, 1),
          style: () => t.style || "default",
          active: cr(t.active, false),
          onTap: () => e({ type: "keypad/shift" }),
        },
        re.createElement("i", {
          class: re.const("dcg-icon-shift"),
          "aria-hidden": re.const("true"),
        }),
      ),
    left: (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () =>
            o("shared-calculator-narration-keypad-key-left-arrow"),
          colspan: cr(t.colspan, 1),
          style: () => t.style || "default",
          onTap: () =>
            e({
              type: "keypad/press-key",
              key: "Left",
              source: "keypad",
            }),
        },
        re.createElement("i", {
          class: re.const("dcg-icon-arrow-left"),
          "aria-hidden": re.const("true"),
        }),
      ),
    right: (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () =>
            o("shared-calculator-narration-keypad-key-right-arrow"),
          colspan: cr(t.colspan, 1),
          style: () => t.style || "default",
          onTap: () =>
            e({
              type: "keypad/press-key",
              key: "Right",
              source: "keypad",
            }),
        },
        re.createElement("i", {
          class: re.const("dcg-icon-arrow-right"),
          "aria-hidden": re.const("true"),
        }),
      ),
    123: (r, e, t = {}, o) =>
      re.createElement(tr, {
        command: re.const(r),
        ariaLabel: () =>
          o("shared-calculator-narration-keypad-key-toggle-numbers"),
        colspan: cr(t.colspan, 1),
        style: () => t.style || "default",
        onTap: () => e({ type: "keypad/123" }),
      }, re.const("1 2 3")),
    ABC: (r, e, t = {}, o) =>
      re.createElement(tr, {
        command: re.const(r),
        ariaLabel: () =>
          o("shared-calculator-narration-keypad-key-toggle-letters"),
        colspan: cr(t.colspan, 1),
        style: () => t.style || "default",
        onTap: () => e({ type: "keypad/abc" }),
      }, re.const("A B C")),
    Audio: (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () =>
            o("shared-calculator-narration-keypad-key-toggle-audio-trace"),
          colspan: cr(t.colspan, 1),
          style: () => t.style || "default",
          onTap: () => e({ type: "keypad/audio-trace", command: "on" }),
        },
        re.createElement("i", {
          class: re.const("dcg-icon-volume"),
          "aria-hidden": re.const("true"),
        }),
      ),
    backspace: (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () =>
            o("shared-calculator-narration-keypad-key-backspace"),
          colspan: cr(t.colspan, 1),
          style: () => t.style || "default",
          onTap: () =>
            e({
              type: "keypad/press-key",
              key: "Backspace",
              source: "keypad",
            }),
        },
        re.createElement("i", {
          class: re.const("dcg-icon-delete"),
          "aria-hidden": re.const("true"),
        }),
      ),
    pi: Me({
      content: "\\pi",
      ariaLabelKey: "shared-calculator-narration-keypad-key-pi",
    }),
    alpha: Me({
      content: "\\alpha",
      ariaLabelKey: "shared-calculator-narration-keypad-key-alpha",
    }),
    beta: Me({
      content: "\\beta",
      ariaLabelKey: "shared-calculator-narration-keypad-key-beta",
    }),
    theta: Me({
      content: "\\theta",
      ariaLabelKey: "shared-calculator-narration-keypad-key-theta",
    }),
    tau: Me({
      content: "\\tau",
      ariaLabelKey: "shared-calculator-narration-keypad-key-tau",
    }),
    phi: Me({
      content: "\\phi",
      ariaLabelKey: "shared-calculator-narration-keypad-key-phi",
    }),
    rho: Me({
      content: "\\rho",
      ariaLabelKey: "shared-calculator-narration-keypad-key-rho",
    }),
    "a^2": On({
      command: "a^2",
      content: "a^2",
      ariaLabelKey: "shared-calculator-narration-keypad-key-squared",
    }),
    "a^3": On({
      command: "a^3",
      content: "a^3",
      ariaLabelKey: "shared-calculator-narration-keypad-key-cubed",
    }),
    "x^3": On({
      command: "a^3",
      content: "x^3",
      ariaLabelKey: "shared-calculator-narration-keypad-key-cubed",
    }),
    "a^b": Me({
      content: "a^b",
      typedText: "^",
      ariaLabelKey: "shared-calculator-narration-keypad-key-superscript",
    }),
    a_b: Me({
      content: "a_b",
      typedText: "_",
      ariaLabelKey: "shared-calculator-narration-keypad-key-subscript",
    }),
    "a/b": On({
      content: "\\frac{a}{b}",
      command: "a/b",
      ariaLabelKey: "shared-calculator-narration-keypad-key-fraction",
    }),
    "x^2": On({
      command: "a^2",
      content: "x^2",
      ariaLabelKey: "shared-calculator-narration-keypad-key-squared",
    }),
    "x^y": Me({
      content: "x^y",
      typedText: "^",
      ariaLabelKey: "shared-calculator-narration-keypad-key-superscript",
    }),
    "x/y": Me({
      content: "\\frac{x}{y}",
      typedText: "/",
      ariaLabelKey: "shared-calculator-narration-keypad-key-fraction",
    }),
    nthroot: On({
      command: "nthroot",
      content: "\\sqrt[n]{}",
      ariaLabelKey: "shared-calculator-narration-keypad-key-nthroot",
    }),
    ythroot: On({
      command: "nthroot",
      content: "\\sqrt[y]{}",
      ariaLabelKey: "shared-calculator-narration-keypad-key-ythroot",
    }),
    sin: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-sin",
    }),
    cos: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-cos",
    }),
    tan: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-tan",
    }),
    tone: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-tone",
    }),
    sec: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-sec",
    }),
    csc: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-csc",
    }),
    cot: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-cot",
    }),
    sinh: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-sinh",
    }),
    cosh: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-cosh",
    }),
    tanh: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-tanh",
    }),
    sech: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-csch",
    }),
    csch: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-csch",
    }),
    coth: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-coth",
    }),
    arcsin: On({
      command: "arcsin",
      content: "sin^{-1}",
      ariaLabelKey: "shared-calculator-narration-keypad-key-arcsin",
    }),
    arccos: On({
      command: "arccos",
      content: "cos^{-1}",
      ariaLabelKey: "shared-calculator-narration-keypad-key-arccos",
    }),
    arctan: On({
      command: "arctan",
      content: "tan^{-1}",
      ariaLabelKey: "shared-calculator-narration-keypad-key-arctan",
    }),
    arccsc: On({
      command: "arccsc",
      content: "csc^{-1}",
      ariaLabelKey: "shared-calculator-narration-keypad-key-arccsc",
    }),
    arcsec: On({
      command: "arcsec",
      content: "sec^{-1}",
      ariaLabelKey: "shared-calculator-narration-keypad-key-arcsec",
    }),
    arccot: On({
      command: "arccot",
      content: "cot^{-1}",
      ariaLabelKey: "shared-calculator-narration-keypad-key-arccot",
    }),
    "|a|": Me({
      typedText: "|",
      ariaLabelKey: "shared-calculator-narration-keypad-key-abs",
    }),
    "|x|": Me({
      typedText: "|",
      ariaLabelKey: "shared-calculator-narration-keypad-key-abs",
    }),
    ln: Pe({ ariaLabelKey: "shared-calculator-narration-keypad-key-ln" }),
    midpoint: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-midpoint",
    }),
    segment: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-segment",
    }),
    line: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-line",
    }),
    ray: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-ray",
    }),
    parallel: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-parallel",
    }),
    perpendicular: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-perpendicular",
    }),
    circle: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-circle",
    }),
    arc: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-arc",
    }),
    angle: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-angle",
    }),
    directedangle: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-directed-angle",
    }),
    glider: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-glider",
    }),
    coterminal: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-coterminal",
    }),
    supplement: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-supplement",
    }),
    dilate: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-dilate",
    }),
    rotate: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-rotate",
    }),
    translate: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-translate",
    }),
    reflect: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-reflect",
    }),
    vertices: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-vertices",
    }),
    angles: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-angles",
    }),
    directedangles: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-directed-angles",
    }),
    segments: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-segments",
    }),
    radius: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-radius",
    }),
    center: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-center",
    }),
    intersection: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-intersection",
    }),
    area: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-area",
    }),
    perimeter: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-perimeter",
    }),
    log: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-log",
    }),
    quantile: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-quantile",
    }),
    quartile: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-quartile",
    }),
    var: Pe({}),
    varp: Pe({}),
    nCr: Pe({}),
    loga: On({
      command: "loga",
      content: "log_a",
      ariaLabelKey: "shared-calculator-narration-keypad-key-loga",
    }),
    stdev: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-stdev",
    }),
    mad: Pe({}),
    nPr: Pe({}),
    total: Pe({}),
    count: Pe({}),
    length: Pe({}),
    for: Pe({}),
    min: Pe({}),
    max: Pe({}),
    cov: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-cov",
    }),
    covp: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-covp",
    }),
    corr: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-corr",
    }),
    spearman: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-spearman",
    }),
    stats: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-stats",
    }),
    polygon: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-polygon",
    }),
    distance: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-distance",
    }),
    triangle: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-triangle",
    }),
    sphere: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-sphere",
    }),
    vector: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-vector",
    }),
    mean: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-mean",
    }),
    stdevp: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-stdevp",
    }),
    mod: Pe({}),
    "e^x": Me({
      typedText: "e^",
      ariaLabelKey: "shared-calculator-narration-keypad-key-exp",
    }),
    "10^n": Me({
      content: "\\times10^{n}",
      typedText: "*10^",
      ariaLabelKey: "shared-calculator-narration-keypad-key-10-n",
    }),
    "a^{-1}": Me({
      typedText: "^-1",
      ariaLabelKey: "shared-calculator-narration-keypad-key-reciprocal",
    }),
    sum: Me({
      content: "\\sum",
      ariaLabelKey: "shared-calculator-narration-keypad-key-sum",
    }),
    prod: Me({
      content: "\\prod",
      ariaLabelKey: "shared-calculator-narration-keypad-key-product",
    }),
    floor: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-floor",
    }),
    ceil: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-ceil",
    }),
    round: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-round",
    }),
    abs: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-abs",
    }),
    "!": Me({
      ariaLabelKey: "shared-calculator-narration-keypad-key-factorial",
    }),
    "n!": Me({
      typedText: "!",
      ariaLabelKey: "shared-calculator-narration-keypad-key-factorial",
    }),
    median: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-median",
    }),
    lcm: Pe({}),
    gcd: Pe({}),
    gcf: Pe({}),
    ddx: On({ command: "ddx", content: "\\frac{d}{dx}" }),
    integral: On({
      command: "integral",
      content: "\\int",
      ariaLabelKey: "shared-calculator-narration-keypad-key-int",
    }),
    "%": Me({
      content: "\\%",
      ariaLabelKey: "shared-calculator-narration-keypad-key-percent-of",
    }),
    "->": Me({
      content: "\\to",
      ariaLabelKey: "shared-calculator-narration-keypad-key-action-to",
    }),
    with: Me({
      typedText: "with",
      content: "with",
      ariaLabelKey: "shared-calculator-narration-keypad-key-action-with",
    }),
    prime: Me({
      typedText: "'",
      content: "f'",
      ariaLabelKey: "shared-calculator-narration-keypad-key-prime",
    }),
    exp: Pe({}),
    sign: Pe({}),
    normaldist: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-normaldist",
    }),
    poissondist: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-poissondist",
    }),
    binomialdist: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-binomialdist",
    }),
    uniformdist: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-uniformdist",
    }),
    erf: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-erf",
    }),
    histogram: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-histogram",
    }),
    boxplot: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-boxplot",
    }),
    dotplot: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-dotplot",
    }),
    tscore: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-tscore",
    }),
    ittest: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-ittest",
    }),
    ttest: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-ttest",
    }),
    tdist: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-tdist",
    }),
    pdf: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-pdf",
    }),
    cdf: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-pdf",
    }),
    random: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-random",
    }),
    inversecdf: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-inversecdf",
    }),
    hsv: Pe({}),
    rgb: Pe({}),
    sort: Pe({}),
    shuffle: Pe({}),
    unique: Pe({}),
    join: Pe({}),
    "A^-1": On({
      command: "A^-1",
      content: "A^{-1}",
      ariaLabelKey: "matrix-calculator-narration-keypad-key-inverse",
    }),
    "A^T": On({
      command: "A^T",
      content: "A^T",
      ariaLabelKey: "matrix-calculator-narration-keypad-key-transpose",
    }),
    "A^2": On({
      command: "A^2",
      content: "A^2",
      ariaLabelKey: "shared-calculator-narration-keypad-key-squared",
    }),
    "A^n": Me({
      content: "A^n",
      typedText: "^",
      ariaLabelKey: "shared-calculator-narration-keypad-key-exp",
    }),
    det: Pe({
      ariaLabelKey: "matrix-calculator-narration-keypad-key-det",
    }),
    trace: Pe({
      ariaLabelKey: "matrix-calculator-narration-keypad-key-trace",
    }),
    rref: Pe({
      ariaLabelKey: "matrix-calculator-narration-keypad-key-rref",
    }),
    a: Me({}),
    b: Me({}),
    c: Me({}),
    d: Me({}),
    e: Me({}),
    f: Me({}),
    g: Me({}),
    h: Me({}),
    i: Me({}),
    j: Me({}),
    k: Me({}),
    l: Me({}),
    m: Me({}),
    n: Me({}),
    o: Me({}),
    p: Me({}),
    q: Me({}),
    r: Me({}),
    s: Me({}),
    t: Me({}),
    u: Me({}),
    v: Me({}),
    w: Me({}),
    x: Me({}),
    boldX: Me({ content: "x", typedText: "x" }),
    y: Me({}),
    boldY: Me({ content: "y", typedText: "y" }),
    z: Me({}),
    boldZ: Me({ content: "z", typedText: "z" }),
    A: Me({}),
    B: Me({}),
    C: Me({}),
    D: Me({}),
    E: Me({}),
    F: Me({}),
    G: Me({}),
    H: Me({}),
    I: Me({}),
    J: Me({}),
    K: Me({}),
    L: Me({}),
    M: Me({}),
    N: Me({}),
    O: Me({}),
    P: Me({}),
    Q: Me({}),
    R: Me({}),
    S: Me({}),
    T: Me({}),
    U: Me({}),
    V: Me({}),
    W: Me({}),
    X: Me({}),
    Y: Me({}),
    Z: Me({}),
    0: Me({}),
    1: Me({}),
    2: Me({}),
    3: Me({}),
    4: Me({}),
    5: Me({}),
    6: Me({}),
    7: Me({}),
    8: Me({}),
    9: Me({}),
    ",": Me({}),
    "=": Me({}),
    "[": Me({}),
    "]": Me({}),
    "{}_left": qy({ keys: ["{", "}"] }),
    "{}_right": Hy({ keys: ["{", "}"] }),
    "()_left": qy({ keys: ["(", ")"] }),
    "()_right": Hy({ keys: ["(", ")"] }),
    "[]_left": qy({ keys: ["[", "]"] }),
    "[]_right": Hy({ keys: ["[", "]"] }),
    ",'_left": qy({ keys: [",", "\u2032"] }),
    ",'_right": Hy({ keys: [",", "\u2032"], typedText: "'" }),
    '"': Me({}),
    "'": Me({}),
    "~": Me({}),
    ":": Me({}),
    ">": Me({}),
    "<": Me({}),
    ">=": Me({ content: "\\ge" }),
    "<=": Me({ content: "\\le" }),
    "!%_left": qy({ keys: ["!", "{}^{%}"] }),
    "!%_right": Hy({ keys: ["!", "{}^{%}"], typedText: "%" }),
    "~:_left": qy({ keys: ["~", "{}^{:}"] }),
    "~:_right": Hy({ keys: ["~", "{}^{:}"], typedText: ":" }),
    real: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-real",
    }),
    imag: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-imag",
    }),
    conj: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-conj",
    }),
    arg: Pe({
      ariaLabelKey: "shared-calculator-narration-keypad-key-arg",
    }),
    "audio-trace-off": zle({
      contentKey: "graphing-calculator-button-keypad-audio-trace-off",
      command: "off",
    }),
    "hear-graph": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          disabled: cr(t.disabled, false),
          colspan: cr(t.colspan, 1),
          style: cr(t.style, "blue"),
          ariaLabel: re.const(void 0),
          onTap: () => {
            e({ type: "keypad/audio-trace", command: "hear-graph" });
          },
        },
        re.createElement(
          "span",
          { class: re.const("dcg-play-icon-container") },
          re.createElement("i", {
            class: re.const("dcg-icon-play"),
            "aria-hidden": re.const("true"),
          }),
        ),
        re.createElement(
          "span",
          null,
          () => o("graphing-calculator-button-audio-trace-hear-graph"),
        ),
      ),
    "stop-graph": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          disabled: cr(t.disabled, false),
          colspan: cr(t.colspan, 1),
          style: cr(t.style, "blue"),
          onTap: () => {
            e({ type: "keypad/audio-trace", command: "stop-graph" });
          },
        },
        re.createElement(
          "span",
          { class: re.const("dcg-stop-icon-container") },
          re.createElement("span", { class: re.const("dcg-stop-icon") }),
        ),
        re.createElement(
          "span",
          null,
          () => o("graphing-calculator-button-audio-trace-stop-graph"),
        ),
      ),
    "volume-down": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () =>
            o("graphing-calculator-narration-keypad-key-volume-down"),
          disabled: cr(t.disabled, false),
          style: () => t.style || "default",
          onTap: () =>
            e({ type: "keypad/audio-trace", command: "volume-down" }),
        },
        re.createElement(
          "span",
          { class: re.const("dcg-button-icon dcg-icon-only") },
          re.createElement("i", {
            class: re.const("dcg-icon-volume-down"),
            "aria-hidden": re.const("true"),
          }),
        ),
      ),
    "volume-up": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () =>
            o("graphing-calculator-narration-keypad-key-volume-up"),
          disabled: cr(t.disabled, false),
          style: () => t.style || "default",
          onTap: () => e({ type: "keypad/audio-trace", command: "volume-up" }),
        },
        re.createElement(
          "span",
          { class: re.const("dcg-button-icon dcg-icon-only") },
          re.createElement("i", {
            class: re.const("dcg-icon-volume-up"),
            "aria-hidden": re.const("true"),
          }),
        ),
      ),
    "speed-down": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () =>
            o("graphing-calculator-narration-keypad-key-speed-down"),
          disabled: cr(t.disabled, false),
          style: () => t.style || "default",
          onTap: () => e({ type: "keypad/audio-trace", command: "speed-down" }),
        },
        re.createElement(
          "span",
          { class: re.const("dcg-button-icon dcg-icon-only") },
          re.createElement("i", {
            class: re.const("dcg-icon-hide"),
            "aria-hidden": re.const("true"),
          }),
        ),
      ),
    "speed-up": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          command: re.const(r),
          ariaLabel: () =>
            o("graphing-calculator-narration-keypad-key-speed-up"),
          disabled: cr(t.disabled, false),
          style: () => t.style || "default",
          onTap: () => e({ type: "keypad/audio-trace", command: "speed-up" }),
        },
        re.createElement(
          "span",
          { class: re.const("dcg-button-icon dcg-icon-only") },
          re.createElement("i", {
            class: re.const("dcg-icon-show"),
            "aria-hidden": re.const("true"),
          }),
        ),
      ),
    "previous-point": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          ariaLabel: () =>
            o("graphing-calculator-narration-keypad-key-previous-point"),
          command: re.const(r),
          disabled: cr(t.disabled, false),
          colspan: cr(t.colspan, 1),
          style: () => t.style || "default",
          onTap: () =>
            e({ type: "keypad/audio-trace", command: "previous-point" }),
        },
        re.createElement(
          "span",
          { class: re.const("dcg-button-icon dcg-icon-only") },
          re.createElement("i", {
            class: re.const("dcg-icon-thin-arrow-left"),
            "aria-hidden": re.const("true"),
          }),
        ),
      ),
    "next-point": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          ariaLabel: () =>
            o("graphing-calculator-narration-keypad-key-next-point"),
          command: re.const(r),
          disabled: cr(t.disabled, false),
          colspan: cr(t.colspan, 1),
          style: () => t.style || "default",
          onTap: () => e({ type: "keypad/audio-trace", command: "next-point" }),
        },
        re.createElement(
          "span",
          { class: re.const("dcg-button-icon dcg-icon-only") },
          re.createElement("i", {
            class: re.const("dcg-icon-thin-arrow-right"),
            "aria-hidden": re.const("true"),
          }),
        ),
      ),
    "previous-poi": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          ariaLabel: () =>
            o("graphing-calculator-narration-keypad-key-previous-poi"),
          command: re.const(r),
          disabled: cr(t.disabled, false),
          colspan: cr(t.colspan, 1),
          style: () => t.style || "default",
          onTap: () =>
            e({ type: "keypad/audio-trace", command: "previous-poi" }),
        },
        re.createElement(
          "span",
          { class: re.const("dcg-button-icon dcg-icon-only") },
          re.createElement("i", {
            class: re.const("dcg-icon-hide"),
            "aria-hidden": re.const("true"),
          }),
        ),
      ),
    "next-poi": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          ariaLabel: () =>
            o("graphing-calculator-narration-keypad-key-next-poi"),
          command: re.const(r),
          disabled: cr(t.disabled, false),
          colspan: cr(t.colspan, 1),
          style: () => t.style || "default",
          onTap: () => e({ type: "keypad/audio-trace", command: "next-poi" }),
        },
        re.createElement(
          "span",
          { class: re.const("dcg-button-icon dcg-icon-only") },
          re.createElement("i", {
            class: re.const("dcg-icon-show"),
            "aria-hidden": re.const("true"),
          }),
        ),
      ),
    "previous-curve": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          ariaLabel: () =>
            o("graphing-calculator-narration-keypad-key-previous-curve"),
          command: re.const(r),
          disabled: cr(t.disabled, false),
          colspan: cr(t.colspan, 1),
          style: () => t.style || "default",
          onTap: () =>
            e({ type: "keypad/audio-trace", command: "previous-curve" }),
        },
        re.createElement(
          "span",
          { class: re.const("dcg-button-icon dcg-icon-only") },
          re.createElement("i", {
            class: re.const("dcg-icon-caret-up"),
            "aria-hidden": re.const("true"),
          }),
        ),
      ),
    "next-curve": (r, e, t = {}, o) =>
      re.createElement(
        tr,
        {
          ariaLabel: () =>
            o("graphing-calculator-narration-keypad-key-next-curve"),
          command: re.const(r),
          disabled: cr(t.disabled, false),
          style: () => t.style || "default",
          onTap: () => e({ type: "keypad/audio-trace", command: "next-curve" }),
        },
        re.createElement(
          "span",
          { class: re.const("dcg-button-icon dcg-icon-only") },
          re.createElement("i", {
            class: re.const("dcg-icon-caret-down"),
            "aria-hidden": re.const("true"),
          }),
        ),
      ),
  };
  function I(r, e, t = {}) {
    let o = r.dispatch;
    return qle[e](e, o, t, r.s);
  }
  function to(r = 1) {
    return re.createElement("div", { style: re.const(`flex-grow:${r}`) });
  }
  var N9 = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var OO = class OO extends N9.Class {
    init() {
      this.controller = this.props.controller(),
        this.dispatch = this.controller.dispatch,
        this.s = this.controller.s;
    }
  };
  OO.uuid = Dd();
  var ii = OO;
  var { IfElse: Hle } = ze.Components,
    iI = 460,
    nI = class extends ii {
      template() {
        return ze.createElement(
          Or,
          { controller: this.props.controller },
          ze.createElement(
            "div",
            { class: ze.const("dcg-audio-keypad-container") },
            ze.createElement(
              "div",
              {
                class: ze.const(
                  "dcg-audio-keypad-column dcg-playback-column",
                ),
              },
              ze.createElement(
                Le,
                {
                  tooltip: this.bindFn(this.getDisabledTooltipText),
                  gravity: this.const("s"),
                },
                ze.createElement(
                  "div",
                  { class: ze.const("dcg-btn-playback") },
                  Hle(() => this.controller.isAudioTracing(), {
                    true: () =>
                      I(this, "stop-graph", {
                        disabled: this.bindFn(this.isAudioDisabled),
                      }),
                    false: () =>
                      I(this, "hear-graph", {
                        disabled: this.bindFn(this.isAudioDisabled),
                      }),
                  }),
                ),
              ),
              ze.createElement(
                "div",
                { class: ze.const("dcg-key-nav-section-container") },
                ze.createElement(
                  Le,
                  {
                    tooltip: this.bindFn(this.getDisabledTooltipText),
                    gravity: this.const("s"),
                  },
                  ze.createElement(
                    "div",
                    { class: ze.const("dcg-key-nav-section") },
                    I(this, "volume-down", {
                      disabled: this.bindFn(this.isVolumeDownDisabled),
                    }),
                    ze.createElement(
                      "div",
                      {
                        role: ze.const("heading"),
                        "aria-level": ze.const("2"),
                        class: () => ({
                          "dcg-key-nav-section-title-container": true,
                          "dcg-disabled": this.isAudioDisabled(),
                        }),
                      },
                      ze.createElement("span", {
                        class: ze.const("dcg-key-nav-section-title"),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-label-audio-trace-volume",
                        )),
                      ze.createElement("span", {
                        class: ze.const(
                          "dcg-keypad-volume-value dcg-key-nav-section-value",
                        ),
                      }, () => this.getAudioTraceVolume()),
                    ),
                    I(this, "volume-up", {
                      disabled: this.bindFn(this.isVolumeUpDisabled),
                    }),
                  ),
                ),
              ),
              ze.createElement(
                "div",
                { class: ze.const("dcg-key-nav-section-container") },
                ze.createElement(
                  Le,
                  {
                    tooltip: this.bindFn(this.getDisabledTooltipText),
                    gravity: this.const("s"),
                  },
                  ze.createElement(
                    "div",
                    { class: ze.const("dcg-key-nav-section") },
                    I(this, "speed-down", {
                      disabled: this.bindFn(this.isSpeedDownDisabled),
                    }),
                    ze.createElement(
                      "div",
                      {
                        class: () => ({
                          "dcg-key-nav-section-title-container": true,
                          "dcg-disabled": this.isAudioDisabled(),
                        }),
                        role: ze.const("heading"),
                        "aria-level": ze.const("2"),
                      },
                      ze.createElement("span", {
                        class: ze.const("dcg-key-nav-section-title"),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-label-audio-trace-speed",
                        )),
                      ze.createElement("span", {
                        class: ze.const(
                          "dcg-keypad-speed-value dcg-key-nav-section-value",
                        ),
                      }, () => this.getAudioTraceSpeed()),
                    ),
                    I(this, "speed-up", {
                      disabled: this.bindFn(this.isSpeedUpDisabled),
                    }),
                  ),
                ),
              ),
              I(this, "audio-trace-off", { style: "highlight" }),
            ),
            ze.createElement("div", {
              class: ze.const("dcg-audio-keypad-spacer"),
            }),
            ze.createElement(
              "div",
              {
                class: ze.const(
                  "dcg-audio-keypad-column dcg-navigation-column",
                ),
              },
              ze.createElement("span", {
                class: ze.const("dcg-key-section-title dcg-center-col"),
                role: ze.const("heading"),
                "aria-level": ze.const("2"),
              }, () =>
                this.controller.s(
                  "graphing-calculator-heading-audio-trace-navigation",
                )),
              ze.createElement(
                "div",
                { class: ze.const("dcg-key-nav-section dcg-center-col") },
                I(this, "previous-point", {
                  disabled: this.bindFn(this.isPrevPointDisabled),
                }),
                ze.createElement("div", {
                  class: ze.const("dcg-key-nav-section-title-container"),
                  role: ze.const("heading"),
                  "aria-level": ze.const("2"),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-label-audio-trace-point",
                  )),
                I(this, "next-point", {
                  disabled: this.bindFn(this.isNextPointDisabled),
                }),
              ),
              ze.createElement(
                "div",
                { class: ze.const("dcg-key-nav-section") },
                I(this, "previous-poi", {
                  disabled: this.bindFn(this.isPrevPOIDisabled),
                }),
                ze.createElement(
                  "div",
                  {
                    class: ze.const(
                      "dcg-key-nav-section-title-container dcg-poi-section-container",
                    ),
                    role: ze.const("heading"),
                    "aria-level": ze.const("2"),
                  },
                  ze.createElement(
                    Oi,
                    {
                      i18n: this.const(this.controller),
                      key: this.const(
                        "graphing-calculator-heading-keypad-audio-trace-point-of-interest",
                      ),
                    },
                    ze.createElement("span", {
                      class: ze.const("dcg-key-nav-section-value"),
                    }, ze.const("Point")),
                    ze.createElement("span", {
                      class: ze.const("dcg-key-nav-section-title"),
                    }, ze.const("of Interest")),
                  ),
                ),
                I(this, "next-poi", {
                  disabled: this.bindFn(this.isNextPOIDisabled),
                }),
              ),
              ze.createElement(
                "div",
                { class: ze.const("dcg-key-nav-section dcg-center-col") },
                I(this, "previous-curve", {
                  disabled: this.bindFn(this.isPrevCurveDisabled),
                }),
                ze.createElement("div", {
                  class: ze.const("dcg-key-nav-section-title-container"),
                  role: ze.const("heading"),
                  "aria-level": ze.const("2"),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-label-audio-trace-curve",
                  )),
                I(this, "next-curve", {
                  disabled: this.bindFn(this.isNextCurveDisabled),
                }),
              ),
            ),
            ze.createElement("div", {
              class: ze.const("dcg-audio-keypad-spacer"),
            }),
            ze.createElement(
              "div",
              {
                class: ze.const(
                  "dcg-audio-keypad-column dcg-screenreader-options",
                ),
              },
              ze.createElement(
                "span",
                {
                  class: ze.const("dcg-key-section-title"),
                  role: ze.const("heading"),
                  "aria-level": ze.const("2"),
                },
                () =>
                  this.layoutWidth() <= iI
                    ? this.controller.s(
                      "graphing-calculator-heading-audio-trace-describe",
                    )
                    : this.controller.s(
                      "graphing-calculator-heading-audio-trace-screen-reader",
                    ),
                ze.createElement(
                  Le,
                  {
                    tooltip: () =>
                      this.controller.s(
                        "graphing-calculator-label-audio-trace-need-screen-reader",
                      ),
                    gravity: this.const("s"),
                    sticky: this.const(true),
                  },
                  ze.createElement("i", {
                    class: ze.const("dcg-icon-question-sign"),
                    "aria-hidden": ze.const("true"),
                  }),
                ),
              ),
              ze.createElement(
                tr,
                {
                  command: ze.const("describe-point"),
                  colspan: this.const(1),
                  style: this.const("default"),
                  onTap: () => {
                    this.dispatch({
                      type: "keypad/audio-trace",
                      command: "describe-point",
                    });
                  },
                },
                ze.createElement(
                  "span",
                  null,
                  () =>
                    this.layoutWidth() <= iI
                      ? this.controller.s(
                        "graphing-calculator-button-keypad-describe-point-short",
                      )
                      : this.controller.s(
                        "graphing-calculator-button-keypad-describe-point",
                      ),
                ),
              ),
              ze.createElement(
                tr,
                {
                  command: ze.const("describe-curve"),
                  colspan: this.const(1),
                  style: this.const("default"),
                  onTap: () => {
                    this.dispatch({
                      type: "keypad/audio-trace",
                      command: "describe-curve",
                    });
                  },
                },
                ze.createElement(
                  "span",
                  null,
                  () =>
                    this.layoutWidth() <= iI
                      ? this.controller.s(
                        "graphing-calculator-button-keypad-describe-curve-short",
                      )
                      : this.controller.s(
                        "graphing-calculator-button-keypad-describe-curve",
                      ),
                ),
              ),
              ze.createElement(
                tr,
                {
                  command: ze.const("describe-axes"),
                  colspan: this.const(1),
                  style: this.const("default"),
                  onTap: () => {
                    this.dispatch({
                      type: "keypad/audio-trace",
                      command: "describe-axes",
                    });
                  },
                },
                ze.createElement(
                  "span",
                  null,
                  () =>
                    this.layoutWidth() <= iI
                      ? this.controller.s(
                        "graphing-calculator-label-axes",
                      )
                      : this.controller.s(
                        "graphing-calculator-button-keypad-describe-axes",
                      ),
                ),
              ),
            ),
          ),
        );
      }
      layoutWidth() {
        return this.controller.getLayoutMeasurements().width;
      }
      isPrevPointDisabled() {
        let r = this.controller.getAudioGraph();
        return r ? !r.agNavigator.canMoveToPrevPoint() : true;
      }
      isNextPointDisabled() {
        let r = this.controller.getAudioGraph();
        return r ? !r.agNavigator.canMoveToNextPoint() : true;
      }
      isPrevPOIDisabled() {
        let r = this.controller.getAudioGraph();
        return r ? !r.agNavigator.canMoveToPrevPOI() : true;
      }
      isNextPOIDisabled() {
        let r = this.controller.getAudioGraph();
        return r ? !r.agNavigator.canMoveToNextPOI() : true;
      }
      isPrevCurveDisabled() {
        let r = this.controller.getAudioGraph();
        return r ? !r.agNavigator.canMoveToPrevCurve() : true;
      }
      isNextCurveDisabled() {
        let r = this.controller.getAudioGraph();
        return r ? !r.agNavigator.canMoveToNextCurve() : true;
      }
      isAudioDisabled() {
        return !this.controller.getAudio();
      }
      getAudioTraceVolume() {
        let r = this.controller.getAudioGraph();
        return !r || this.isAudioDisabled()
          ? "0%"
          : `${r.getAudioVolume() * 100}%`;
      }
      isVolumeDownDisabled() {
        let r = this.controller.getAudioGraph();
        return !r || this.isAudioDisabled() ? true : r.getAudioVolume() <= 0;
      }
      isVolumeUpDisabled() {
        let r = this.controller.getAudioGraph();
        return !r || this.isAudioDisabled() ? true : r.getAudioVolume() >= 1;
      }
      getAudioTraceSpeed() {
        let r = this.controller.getAudioGraph();
        return !r || this.isAudioDisabled()
          ? "0"
          : Mv[r.getAudioSpeedIndex()].displayedSpeed;
      }
      isSpeedDownDisabled() {
        let r = this.controller.getAudioGraph();
        return !r || this.isAudioDisabled()
          ? true
          : r.getAudioSpeedIndex() <= 0;
      }
      isSpeedUpDisabled() {
        let r = this.controller.getAudioGraph();
        return !r || this.isAudioDisabled()
          ? true
          : r.getAudioSpeedIndex() === Mv.length - 1;
      }
      getDisabledTooltipText() {
        return this.isAudioDisabled()
          ? this.controller.s(
            "graphing-calculator-narration-audio-trace-sound-effects-disabled",
          )
          : "";
      }
    };
  var Ir = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: aI, For: B9 } = Ir.Components,
    sI = class extends ii {
      template() {
        return Ir.createElement(
          "div",
          {
            class: () => ({
              "dcg-functions-popover": true,
              "dcg-popover": true,
              "dcg-top": true,
              "dcg-two-column": this.shouldRenderWithTwoColumns(),
            }),
            id: this.const(`dcg-functions-popover-${ii.uuid}`),
            role: Ir.const("group"),
            "aria-label": () =>
              this.controller.s("graphing-calculator-button-functions"),
          },
          Ir.createElement(
            "div",
            { class: Ir.const("dcg-popover-interior") },
            Ir.createElement(
              "div",
              { class: Ir.const("dcg-interior-buttons") },
              Ir.createElement(
                "div",
                { class: Ir.const("dcg-basic-keypad dcg-do-not-blur") },
                Ir.createElement(B9, {
                  each: this.bindFn(this.getKeypadKeys),
                  key: (r) => r.id,
                }, (r) =>
                  Ir.createElement(
                    "div",
                    { class: Ir.const("dcg-keypad-keys-section") },
                    Ir.createElement(aI, {
                      predicate: () => r.title !== void 0,
                    }, () =>
                      Ir.createElement(
                        "div",
                        {
                          class: Ir.const("dcg-section-heading"),
                          role: Ir.const("heading"),
                          "aria-level": Ir.const("2"),
                        },
                        () => r.title,
                        Ir.createElement(aI, {
                          predicate: () => !!r.beta,
                        }, () =>
                          Ir.createElement(
                            "span",
                            { class: Ir.const("dcg-beta-tag") },
                            () =>
                              this.controller.s(
                                "shared-calculator-narration-keypad-key-beta",
                              ),
                          )),
                        Ir.createElement(aI, {
                          predicate: () => !!r.helpLink,
                        }, () =>
                          Ir.createElement(
                            "a",
                            {
                              href: () => r.helpLink.url,
                              target: Ir.const("_blank"),
                              "aria-label": () => r.helpLink.tooltip,
                            },
                            Ir.createElement("i", {
                              class: Ir.const("dcg-icon-question-sign"),
                              "aria-hidden": Ir.const("true"),
                            }),
                          )),
                      )),
                    Ir.createElement(aI, {
                      predicate: () => r.title === void 0,
                    }, () =>
                      Ir.createElement("div", {
                        class: Ir.const("dcg-popover-section-separator"),
                        role: Ir.const("separator"),
                      })),
                    Ir.createElement(
                      "div",
                      { class: Ir.const("dcg-keypad-keys-buttons") },
                      Ir.createElement(
                        B9,
                        { each: () => r.keys },
                        (e) => this.b(e),
                      ),
                    ),
                  )),
              ),
            ),
          ),
          Ir.createElement("div", { class: Ir.const("dcg-arrow") }),
        );
      }
      shouldRenderWithTwoColumns() {
        let r = this.controller.getGraphSettings().config.projectorMode
          ? 410
          : 375;
        return this.controller.getLayoutMeasurements().width < r;
      }
      getInverseTrigSection() {
        let r = this.controller.areFunctionsRestricted()
          ? ["arcsin", "arccos", "arctan"]
          : ["arcsin", "arccos", "arctan", "arccsc", "arcsec", "arccot"];
        return {
          id: "inversetrig",
          title: this.controller.s(
            "graphing-calculator-heading-inverse-trig",
          ),
          keys: r,
        };
      }
      getGeometryTools() {
        let r = [
          "midpoint",
          "intersection",
          "segment",
          "line",
          "ray",
          "vector",
          "parallel",
          "perpendicular",
          "circle",
          "arc",
          "angle",
          "directedangle",
          "polygon",
          "glider",
        ];
        return {
          id: "geometry-tools",
          title: this.controller.s(
            "graphing-calculator-heading-geometry-tools",
          ),
          keys: r,
        };
      }
      getGeometryTransformations() {
        let r = ["dilate", "rotate", "reflect", "translate"];
        return {
          id: "geometry-transformations",
          title: this.controller.s(
            "graphing-calculator-heading-geometry-transformations",
          ),
          keys: r,
        };
      }
      getGeometryMeasurements() {
        let r = [
          "distance",
          "length",
          "area",
          "perimeter",
          "vertices",
          "angles",
          "directedangles",
          "segments",
          "radius",
          "center",
          "coterminal",
          "supplement",
        ];
        return {
          id: "geometry-measurements",
          title: this.controller.s(
            "graphing-calculator-heading-geometry-measurements",
          ),
          keys: r,
        };
      }
      getCalculatorGeometryMethods() {
        let r = !this.controller.areFunctionsRestricted() ||
            this.controller.areGeometryFunctionsForceEnabled(),
          e = this.controller.isThreeDMode()
            ? ["segment", "triangle", "sphere", "vector"]
            : ["polygon"],
          t = this.controller.isThreeDMode()
            ? ["length", "distance", "midpoint"]
            : ["distance", "midpoint"],
          o = r ? t : [];
        return {
          id: "geometry",
          title: this.controller.s(
            "graphing-calculator-heading-geometry",
          ),
          keys: [...e, ...o],
        };
      }
      getTrigSection() {
        let r = this.controller.areFunctionsRestricted()
          ? ["sin", "cos", "tan"]
          : ["sin", "cos", "tan", "csc", "sec", "cot"];
        return {
          id: "trig",
          title: this.controller.s("graphing-calculator-heading-trig"),
          keys: r,
        };
      }
      getHyperbolicTrigSection() {
        let r = this.controller.areFunctionsRestricted()
          ? ["sinh", "cosh", "tanh"]
          : ["sinh", "cosh", "tanh", "csch", "sech", "coth"];
        return {
          id: "hyperbtrig",
          title: this.controller.s(
            "graphing-calculator-heading-hyperbolic-trig",
          ),
          keys: r,
        };
      }
      getListFunctions() {
        return {
          id: "lists",
          title: this.controller.s("graphing-calculator-heading-lists"),
          keys: ["join", "sort", "shuffle", "unique", "for"],
        };
      }
      getStatTests() {
        return {
          id: "stat-tests",
          title: this.controller.s(
            "graphing-calculator-heading-stat-tests",
          ),
          keys: ["ttest", "tscore", "ittest"],
        };
      }
      getStatsSection() {
        let r = [
          "mean",
          "median",
          "min",
          "max",
          "quartile",
          "quantile",
          "stdev",
          "stdevp",
          "var",
        ];
        return this.controller.areFunctionsRestricted() ||
          (r = r.concat(["mad", "cov", "covp"])),
          r = r.concat(["corr", "spearman", "stats", "count", "total"]),
          {
            id: "stats",
            title: this.controller.s("graphing-calculator-heading-stats"),
            keys: r,
          };
      }
      getMiscSection() {
        return {
          title: this.controller.s(
            "graphing-calculator-button-functions-menu-number-theory",
          ),
          id: "misc",
          keys: [
            "lcm",
            "gcd",
            "mod",
            "ceil",
            "floor",
            "round",
            "sign",
            "nthroot",
            "nPr",
            "nCr",
          ],
        };
      }
      getVisualizationsSection() {
        return {
          title: this.controller.s(
            "graphing-calculator-heading-dist-tab-visualizations",
          ),
          id: "visualizations",
          keys: ["histogram", "dotplot", "boxplot"],
          helpLink: {
            url:
              "https://help.desmos.com/hc/en-us/articles/360022405991-Data-Visualizations",
            tooltip: this.controller.s(
              "graphing-calculator-narration-dist-tab-visualizations",
            ),
          },
        };
      }
      getCalculusSection() {
        return {
          title: this.controller.s(
            "graphing-calculator-heading-calculus",
          ),
          id: "calculus",
          keys: [
            "exp",
            "ln",
            "log",
            "loga",
            "ddx",
            "prime",
            "integral",
            "sum",
            "prod",
          ],
        };
      }
      getDistributionsSection() {
        return {
          title: this.controller.s(
            "graphing-calculator-heading-dist-tab-distributions",
          ),
          id: "distributions",
          keys: [
            "normaldist",
            "tdist",
            "poissondist",
            "binomialdist",
            "uniformdist",
            "pdf",
            "cdf",
            "inversecdf",
            "random",
          ],
          helpLink: {
            url:
              "https://help.desmos.com/hc/en-us/articles/360022401451-Distributions",
            tooltip: this.controller.s(
              "graphing-calculator-narration-dist-tab-distributions",
            ),
          },
        };
      }
      getColorsSection() {
        return {
          title: this.controller.s(
            "graphing-calculator-button-functions-menu-custom-colors",
          ),
          id: "colors",
          keys: ["rgb", "hsv"],
          helpLink: {
            url:
              "https://help.desmos.com/hc/en-us/articles/4406795899533-Custom-Colors",
            tooltip: this.controller.s(
              "graphing-calculator-button-functions-menu-custom-colors",
            ),
          },
        };
      }
      getAdvancedSection() {
        return {
          title: this.controller.s(
            "graphing-calculator-heading-functions-menu-advanced",
          ),
          id: "advanced",
          keys: ["->", "with"],
          helpLink: {
            url:
              "https://help.desmos.com/hc/en-us/sections/4406370087053-Advanced-Features",
            tooltip: this.controller.s(
              "graphing-calculator-heading-functions-menu-advanced",
            ),
          },
        };
      }
      getPolarSection() {
        return {
          title: this.controller.s(
            "graphing-calculator-heading-functions-menu-polar",
          ),
          id: "polar",
          keys: ["rho", "theta", "phi"],
          helpLink: {
            url: "https://help.desmos.com/hc/en-us/articles/15824510769805",
            tooltip: this.controller.s(
              "graphing-calculator-heading-functions-menu-polar",
            ),
          },
        };
      }
      getSoundSection() {
        return {
          title: this.controller.s(
            "graphing-calculator-heading-functions-menu-sound",
          ),
          id: "sound",
          keys: ["tone"],
          helpLink: {
            url:
              "https://help.desmos.com/hc/en-us/articles/21373904717197-Tone",
            tooltip: this.controller.s(
              "graphing-calculator-heading-functions-menu-sound",
            ),
          },
        };
      }
      getComplexSection() {
        return {
          title: this.controller.s(
            "graphing-calculator-heading-functions-menu-complex",
          ),
          id: "complex",
          keys: ["real", "imag", "conj", "arg"],
        };
      }
      getKeypadKeys() {
        let r = [
          this.getTrigSection(),
          this.getInverseTrigSection(),
          this.getStatsSection(),
          this.getListFunctions(),
        ];
        return this.controller.areDistributionsEnabled() &&
          (this.controller.isThreeDMode() ||
            r.push(this.getVisualizationsSection()),
            r.push(this.getDistributionsSection()),
            r.push(this.getStatTests())),
          r.push(this.getCalculusSection()),
          r.push(this.getHyperbolicTrigSection()),
          this.controller.is3dProduct() && r.push(this.getPolarSection()),
          this.controller.isGeometry()
            ? (r.push(this.getGeometryTools()),
              r.push(this.getGeometryMeasurements()),
              r.push(this.getGeometryTransformations()))
            : r.push(this.getCalculatorGeometryMethods()),
          r.push(this.getColorsSection()),
          this.controller.toneAllowed() && r.push(this.getSoundSection()),
          r.push(this.getMiscSection()),
          this.controller.isComplexModeEnabled() &&
          r.push(this.getComplexSection()),
          this.controller.areActionsEnabled() &&
          r.push(this.getAdvancedSection()),
          r;
      }
      b(r) {
        return I(this, r, { style: "popover" });
      }
    };
  var Ih = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Ky = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    $e = class extends Ky.Class {
      template() {
        return Ky.createElement("div", {
          class: Ky.const("dcg-keypad-row"),
        }, this.props.children);
      }
    };
  var lI = class extends ii {
    template() {
      return Ih.createElement(
        Or,
        { controller: this.props.controller },
        Ih.createElement(
          $e,
          null,
          I(this, "a"),
          I(this, "b"),
          I(this, "c"),
          I(this, "d"),
          I(this, "e"),
          I(this, "f"),
          I(this, "g"),
          I(this, "h"),
          I(this, "i"),
          I(this, "j"),
        ),
        Ih.createElement(
          $e,
          null,
          I(this, "k"),
          I(this, "l"),
          I(this, "m"),
          I(this, "n"),
          I(this, "o"),
          I(this, "p"),
          I(this, "q"),
          I(this, "r"),
          I(this, "s"),
          I(this, "t"),
        ),
        Ih.createElement(
          $e,
          null,
          I(this, "shift", { style: "highlight" }),
          I(this, "u"),
          I(this, "v"),
          I(this, "w"),
          I(this, "x"),
          I(this, "y"),
          I(this, "z"),
          I(this, "theta"),
          I(this, "backspace", { colspan: 2, style: "highlight" }),
        ),
        Ih.createElement(
          $e,
          null,
          I(this, "123", { colspan: 2, style: "highlight" }),
          I(this, "a_b"),
          I(this, "!%_left"),
          I(this, "[]_left"),
          I(this, "{}_left"),
          I(
            this,
            this.controller.getGraphSettings().config.customRegressions
              ? "~:_left"
              : ":",
          ),
          Ih.const(" "),
          I(this, ",'_left"),
          I(this, "enter", { colspan: 2, style: "blue" }),
        ),
      );
    }
  };
  var Wy = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var cI = class extends ii {
    template() {
      return Wy.createElement(
        Or,
        { controller: this.props.controller },
        Wy.createElement(
          $e,
          null,
          I(this, "A"),
          I(this, "B"),
          I(this, "C"),
          I(this, "D"),
          I(this, "E"),
          I(this, "F"),
          I(this, "G"),
          I(this, "H"),
          I(this, "I"),
          I(this, "J"),
        ),
        Wy.createElement(
          $e,
          null,
          I(this, "K"),
          I(this, "L"),
          I(this, "M"),
          I(this, "N"),
          I(this, "O"),
          I(this, "P"),
          I(this, "Q"),
          I(this, "R"),
          I(this, "S"),
          I(this, "T"),
        ),
        Wy.createElement(
          $e,
          null,
          I(this, "shift", { style: "highlight" }),
          I(this, "U"),
          I(this, "V"),
          I(this, "W"),
          I(this, "X"),
          I(this, "Y"),
          I(this, "Z"),
          I(this, "tau"),
          I(this, "backspace", { colspan: 2, style: "highlight" }),
        ),
        Wy.createElement(
          $e,
          null,
          I(this, "123", { colspan: 2, style: "highlight" }),
          I(this, "a^b"),
          I(this, "!%_right"),
          I(this, "[]_right"),
          I(this, "{}_right"),
          I(
            this,
            this.controller.getGraphSettings().config.customRegressions
              ? "~:_right"
              : ":",
          ),
          I(this, ",'_right"),
          I(this, "enter", { colspan: 2, style: "blue" }),
        ),
      );
    }
  };
  var ga = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { IfElse: Kle } = ga.Components,
    dI = class extends ii {
      template() {
        return ga.createElement(
          Or,
          { controller: this.props.controller },
          ga.createElement(
            $e,
            null,
            I(this, "boldX"),
            I(this, "boldY"),
            Kle(() => this.props.controller().isComplexModeEnabled(), {
              false: () => I(this, "a^2"),
              true: () => I(this, "i"),
            }),
            I(this, "a^b"),
            to(.5),
            I(this, "7", { style: "highlight" }),
            I(this, "8", { style: "highlight" }),
            I(this, "9", { style: "highlight" }),
            I(this, "division"),
            to(.5),
            ga.createElement(tr, {
              command: this.const("functions"),
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-functions",
                ),
              colspan: this.const(2),
              style: this.const("highlight"),
              active: () => this.controller.isKeypadFunctionsPopoverOpen(),
              onTap: () => this.dispatch({ type: "keypad/functions" }),
              ariaControls: this.const(
                `dcg-functions-popover-${ii.uuid}`,
              ),
              ariaExpanded: () =>
                this.controller.isKeypadFunctionsPopoverOpen(),
            }, this.bindFn(this.getFuncsBtnText)),
          ),
          ga.createElement(
            $e,
            null,
            I(this, "("),
            I(this, ")"),
            I(this, "<"),
            I(this, ">"),
            to(.5),
            I(this, "4", { style: "highlight" }),
            I(this, "5", { style: "highlight" }),
            I(this, "6", { style: "highlight" }),
            I(this, "multiplication"),
            to(.5),
            I(this, "left", { style: "highlight" }),
            I(this, "right", { style: "highlight" }),
          ),
          ga.createElement(
            $e,
            null,
            I(this, "|a|"),
            I(this, ","),
            I(this, "<="),
            I(this, ">="),
            to(.5),
            I(this, "1", { style: "highlight" }),
            I(this, "2", { style: "highlight" }),
            I(this, "3", { style: "highlight" }),
            I(this, "-"),
            to(1),
            I(this, "backspace", { colspan: 1.5, style: "highlight" }),
          ),
          ga.createElement(
            $e,
            null,
            ga.createElement(
              tr,
              {
                command: ga.const("ABC"),
                colspan: this.const(1),
                additionalClass: this.const("dcg-abc-button--one-column"),
                ariaLabel: () =>
                  this.controller.s(
                    "graphing-calculator-narration-toggle-letters",
                  ),
                style: this.const("highlight"),
                onTap: () => {
                  this.dispatch({ type: "keypad/abc" });
                },
              },
              () =>
                this.controller.getLayoutMeasurements().width <= 600
                  ? this.controller.raw("ABC")
                  : this.controller.raw("A B C"),
            ),
            ga.createElement(
              tr,
              {
                command: ga.const("Audio"),
                disabled: () => !this.controller.canAudioTrace(),
                ariaLabel: () =>
                  this.controller.s(
                    "graphing-calculator-narration-toggle-audio-trace",
                  ),
                colspan: this.const(1),
                style: () => "highlight",
                onTap: () =>
                  this.dispatch({
                    type: "keypad/audio-trace",
                    command: "on",
                  }),
              },
              ga.createElement("i", {
                class: ga.const("dcg-icon-volume"),
                "aria-hidden": ga.const("true"),
              }),
            ),
            I(this, "sqrt"),
            I(this, "pi"),
            to(.5),
            I(this, "0", { style: "highlight" }),
            I(this, ".", { style: "highlight" }),
            I(this, "="),
            I(this, "+"),
            to(.5),
            I(this, "enter", { colspan: 2, style: "blue" }),
          ),
        );
      }
      getFuncsBtnText() {
        return this.controller.isNarrow()
          ? this.controller.s("graphing-calculator-button-funcs")
          : this.controller.s("graphing-calculator-button-functions");
      }
    };
  var xl = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: Wle } = xl.Components,
    pI = class extends ii {
      template() {
        return xl.createElement(
          Or,
          { controller: this.props.controller },
          xl.createElement(
            $e,
            null,
            I(this, "boldX"),
            I(this, "boldY"),
            I(this, "boldZ"),
            I(this, "a^b"),
            to(.5),
            I(this, "7", { style: "highlight" }),
            I(this, "8", { style: "highlight" }),
            I(this, "9", { style: "highlight" }),
            I(this, "division"),
            to(.5),
            xl.createElement(tr, {
              command: this.const("functions"),
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-functions",
                ),
              colspan: this.const(2),
              style: this.const("highlight"),
              active: () => this.controller.isKeypadFunctionsPopoverOpen(),
              onTap: () => this.dispatch({ type: "keypad/functions" }),
              ariaControls: this.const(
                `dcg-functions-popover-${ii.uuid}`,
              ),
              ariaExpanded: () =>
                this.controller.isKeypadFunctionsPopoverOpen(),
            }, this.bindFn(this.getFuncsBtnText)),
          ),
          xl.createElement(
            $e,
            null,
            I(this, "("),
            I(this, ")"),
            I(this, "<"),
            I(this, ">"),
            to(.5),
            I(this, "4", { style: "highlight" }),
            I(this, "5", { style: "highlight" }),
            I(this, "6", { style: "highlight" }),
            I(this, "multiplication"),
            to(.5),
            I(this, "left", { style: "highlight" }),
            I(this, "right", { style: "highlight" }),
          ),
          xl.createElement(
            $e,
            null,
            I(this, "|a|"),
            I(this, ","),
            I(this, "<="),
            I(this, ">="),
            to(.5),
            I(this, "1", { style: "highlight" }),
            I(this, "2", { style: "highlight" }),
            I(this, "3", { style: "highlight" }),
            I(this, "-"),
            to(1),
            I(this, "backspace", { colspan: 1.5, style: "highlight" }),
          ),
          xl.createElement(
            $e,
            null,
            xl.createElement(tr, {
              command: xl.const("ABC"),
              colspan: () => this.controller.isComplexModeEnabled() ? 1 : 2,
              additionalClass: () =>
                this.controller.isComplexModeEnabled()
                  ? "dcg-abc-button--one-column"
                  : void 0,
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-narration-toggle-letters",
                ),
              style: this.const("highlight"),
              onTap: () => {
                this.dispatch({ type: "keypad/abc" });
              },
            }, () =>
              this.controller.isComplexModeEnabled() &&
                this.controller.getLayoutMeasurements().width <= 600
                ? this.controller.raw("ABC")
                : this.controller.raw("A B C")),
            xl.createElement(Wle, {
              predicate: () => this.controller.isComplexModeEnabled(),
            }, () => I(this, "i")),
            I(this, "sqrt"),
            I(this, "pi"),
            to(.5),
            I(this, "0", { style: "highlight" }),
            I(this, ".", { style: "highlight" }),
            I(this, "="),
            I(this, "+"),
            to(.5),
            I(this, "enter", { colspan: 2, style: "blue" }),
          ),
        );
      }
      getFuncsBtnText() {
        return this.controller.isNarrow()
          ? this.controller.s("graphing-calculator-button-funcs")
          : this.controller.s("graphing-calculator-button-functions");
      }
    };
  var $y = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var uI = class extends ii {
    template() {
      return $y.createElement(
        Or,
        { controller: this.props.controller },
        $y.createElement(
          $e,
          null,
          I(this, "q"),
          I(this, "w"),
          I(this, "e"),
          I(this, "r"),
          I(this, "t"),
          I(this, "y"),
          I(this, "u"),
          I(this, "i"),
          I(this, "o"),
          I(this, "p"),
        ),
        $y.createElement(
          $e,
          null,
          I(this, "a"),
          I(this, "s"),
          I(this, "d"),
          I(this, "f"),
          I(this, "g"),
          I(this, "h"),
          I(this, "j"),
          I(this, "k"),
          I(this, "l"),
          I(this, "theta"),
        ),
        $y.createElement(
          $e,
          null,
          I(this, "shift", { colspan: 1.364, style: "highlight" }),
          to(.136),
          I(this, "z"),
          I(this, "x"),
          I(this, "c"),
          I(this, "v"),
          I(this, "b"),
          I(this, "n"),
          I(this, "m"),
          to(.136),
          I(this, "backspace", { colspan: 1.364, style: "highlight" }),
        ),
        $y.createElement(
          $e,
          null,
          I(this, "123", { colspan: 1.818, style: "highlight" }),
          to(.182),
          I(this, "a_b"),
          I(this, "!%_left"),
          I(this, "[]_left"),
          I(this, "{}_left"),
          I(
            this,
            this.controller.getGraphSettings().config.customRegressions
              ? "~:_left"
              : ":",
          ),
          I(this, ",'_left"),
          to(.182),
          I(this, "enter", { colspan: 1.818, style: "blue" }),
        ),
      );
    }
  };
  var jy = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var hI = class extends ii {
    template() {
      return jy.createElement(
        Or,
        { controller: this.props.controller },
        jy.createElement(
          $e,
          null,
          I(this, "Q"),
          I(this, "W"),
          I(this, "E"),
          I(this, "R"),
          I(this, "T"),
          I(this, "Y"),
          I(this, "U"),
          I(this, "I"),
          I(this, "O"),
          I(this, "P"),
        ),
        jy.createElement(
          $e,
          null,
          I(this, "A"),
          I(this, "S"),
          I(this, "D"),
          I(this, "F"),
          I(this, "G"),
          I(this, "H"),
          I(this, "J"),
          I(this, "K"),
          I(this, "L"),
          I(this, "tau"),
        ),
        jy.createElement(
          $e,
          null,
          I(this, "shift", {
            colspan: 1.364,
            active: true,
            style: "highlight",
          }),
          to(.136),
          I(this, "Z"),
          I(this, "X"),
          I(this, "C"),
          I(this, "V"),
          I(this, "B"),
          I(this, "N"),
          I(this, "M"),
          to(.136),
          I(this, "backspace", { colspan: 1.364, style: "highlight" }),
        ),
        jy.createElement(
          $e,
          null,
          I(this, "123", { colspan: 1.818, style: "highlight" }),
          to(.182),
          I(this, "a^b"),
          I(this, "!%_right"),
          I(this, "[]_right"),
          I(this, "{}_right"),
          I(
            this,
            this.controller.getGraphSettings().config.customRegressions
              ? "~:_right"
              : ":",
          ),
          I(this, ",'_right"),
          to(.182),
          I(this, "enter", { colspan: 1.818, style: "blue" }),
        ),
      );
    }
  };
  var { SwitchUnion: $le, If: RO } = Ut.Components,
    gI = class extends ii {
      template() {
        return Ut.createElement(
          "div",
          {
            class: Ut.const("dcg-keypad"),
            role: Ut.const("region"),
            "aria-label": () =>
              this.controller.s("shared-calculator-narration-keypad"),
          },
          Ut.createElement(
            "div",
            {
              class: () => ({
                "dcg-keys-container": true,
                "dcg-smaller-functions-text":
                  this.controller.getLayoutMeasurements().width < 650,
                "dcg-small-ABC":
                  this.controller.getLayoutMeasurements().width < 490,
                "dcg-smaller-ABC":
                  this.controller.getLayoutMeasurements().width < 420,
                "dcg-smallest-ABC":
                  this.controller.getLayoutMeasurements().width < 380,
              }),
              style: this.bindFn(this.computeStyles),
              didMount: this.bindFn(this.didMountContainer),
              "aria-hidden": () => !this.controller.isKeypadOpen(),
            },
            Ut.createElement(
              "div",
              { class: Ut.const("dcg-keys-background dcg-do-not-blur") },
              Ut.createElement(
                "div",
                { class: Ut.const("dcg-keys") },
                $le(() => this.controller.getKeypadLayout(), {
                  letters: () =>
                    Ut.createElement(uI, {
                      controller: this.props.controller,
                    }),
                  capitalLetters: () =>
                    Ut.createElement(hI, {
                      controller: this.props.controller,
                    }),
                  mainNumbers: () =>
                    Ut.createElement(dI, {
                      controller: this.props.controller,
                    }),
                  mainNumbers3D: () =>
                    Ut.createElement(pI, {
                      controller: this.props.controller,
                    }),
                  noQwertyLetters: () =>
                    Ut.createElement(lI, {
                      controller: this.props.controller,
                    }),
                  noQwertyCapitalLetters: () =>
                    Ut.createElement(cI, {
                      controller: this.props.controller,
                    }),
                  audio: () =>
                    Ut.createElement(nI, {
                      controller: this.props.controller,
                    }),
                }),
                Ut.createElement(
                  RO,
                  {
                    predicate: () =>
                      this.controller.isKeypadFunctionsPopoverOpen(),
                  },
                  () =>
                    Ut.createElement(sI, {
                      controller: this.props.controller,
                    }),
                ),
              ),
              Ut.createElement(RO, {
                predicate: () => this.controller.isHideKeypadButtonVisible(),
              }, () =>
                Ut.createElement(
                  "div",
                  { class: Ut.const("dcg-minimize-keypad-container") },
                  Ut.createElement(
                    Le,
                    {
                      tooltip: () =>
                        this.controller.s(
                          "graphing-calculator-label-hide-keypad",
                        ),
                      gravity: this.const("n"),
                      offset: this.const({ left: 6 }),
                    },
                    Ut.createElement(
                      "div",
                      {
                        role: Ut.const("button"),
                        "aria-expanded": Ut.const("true"),
                        "aria-controls": this.const(ii.uuid),
                        "aria-label": () =>
                          this.controller.s(
                            "graphing-calculator-label-hide-keypad",
                          ),
                        class: Ut.const("dcg-minimize-keypad"),
                        onTap: () => {
                          this.controller.dispatch({
                            type: "keypad/set-minimized",
                            minimized: true,
                          });
                        },
                      },
                      Ut.createElement("i", {
                        class: Ut.const("dcg-icon-keyboard"),
                        "aria-hidden": Ut.const("true"),
                      }),
                      Ut.createElement("i", {
                        class: Ut.const("dcg-icon-caret-down"),
                        "aria-hidden": Ut.const("true"),
                      }),
                    ),
                  ),
                )),
            ),
          ),
          Ut.createElement(RO, {
            predicate: this.bindFn(this.isShowKeypadButtonVisible),
          }, () =>
            Ut.createElement(
              "div",
              { class: Ut.const("dcg-show-keypad-container") },
              Ut.createElement(
                Le,
                {
                  tooltip: () =>
                    this.controller.s(
                      "graphing-calculator-label-show-keypad",
                    ),
                  gravity: this.const("n"),
                },
                Ut.createElement(
                  "div",
                  {
                    role: Ut.const("button"),
                    "aria-expanded": Ut.const("false"),
                    "aria-controls": this.const(ii.uuid),
                    "aria-label": () =>
                      this.controller.s(
                        "graphing-calculator-label-show-keypad",
                      ),
                    class: Ut.const(
                      "dcg-btn-flat-gray dcg-show-keypad dcg-do-not-blur",
                    ),
                    onTap: () => {
                      this.controller.dispatch({
                        type: "keypad/set-minimized",
                        minimized: false,
                      });
                    },
                  },
                  Ut.createElement("i", {
                    class: Ut.const("dcg-icon-keyboard"),
                    "aria-hidden": Ut.const("true"),
                  }),
                  Ut.createElement("i", {
                    class: Ut.const("dcg-icon-caret-up dcg-do-not-blur"),
                    "aria-hidden": Ut.const("true"),
                  }),
                ),
              ),
            )),
        );
      }
      didMountContainer(r) {
        this.containerElt = r;
      }
      isShowKeypadButtonVisible() {
        return this.controller.getBrailleMode() !== "none"
          ? false
          : !this.controller.isKeypadOpen() &&
            !this.controller.isNarrow() &&
            !this.controller.isInEditListMode() &&
            (this.controller.isListVisible() ||
              this.controller.inAudioTraceMode());
      }
      didMount() {
        this.updatePopoverPosition();
      }
      didUpdate() {
        this.updatePopoverPosition();
      }
      computeStyles() {
        let r = {};
        return this.controller.isNarrow() ||
          (r.transition = "transform .3s, opacity .3s"),
          this.controller.isKeypadOpen() ||
          (r.opacity = "0", r.transform = "translate3d(0, 255px, 0)"),
          r;
      }
      updatePopoverPosition() {
        if (!this.controller.isKeypadFunctionsPopoverOpen()) {
          this.__popoverCache = void 0;
          return;
        }
        let r = this.controller.computeMajorLayout(),
          e = {
            keypadTop: r.keypad.top,
            keypadWidth: r.keypad.width,
            keypadHeight: r.keypad.height,
            showToLeft: r.grapher.height < 525,
          };
        if (__dcg_shared_module_exports__["E"](e, this.__popoverCache)) {
          return;
        }
        this.__popoverCache = e;
        let t = this.containerElt,
          o = t.querySelector("[dcg-command=functions]"),
          i = t.querySelector(".dcg-functions-popover"),
          n = t.querySelector(".dcg-arrow");
        if (e.showToLeft) {
          i.classList.remove("dcg-top"), i.classList.add("dcg-left");
          let s = e.keypadHeight - (Gl(o).top - Gl(t).top) -
            o.offsetHeight / 2 - 2 - 10;
          n.style.left = "auto", n.style.bottom = `${s}px`;
        } else {i.classList.remove("dcg-left"),
            i.classList.add("dcg-top"),
            n.style.left = `${i.offsetWidth - o.offsetWidth / 2}px`,
            n.style.bottom = "auto";}
      }
    };
  qt();
  qt();
  var jle = function () {
    {
      let o = false,
        i = function () {
          n(document), o = true;
        },
        n = function (a) {
          o || ee(a).bind("touchstart", (s) => {
            let l = ee(s.target), c = 0, d = null;
            if (!l[0].closest("[disablescroll]")) {
              for (; c === 0 && l.length && l[0].tagName !== void 0;) {
                let p = getComputedStyle(l[0]).overflow,
                  h = getComputedStyle(l[0]).overflowY;
                if (
                  p !== "hidden" && p !== "visible" && h !== "hidden" &&
                  h !== "hidden"
                ) {
                  let u = l.scrollTop();
                  u !== 0 && (c = 2),
                    l.scrollTop(u + 1),
                    l.scrollTop() !== u && (c = 1 | c, l.scrollTop(u));
                }
                l = ee(l[0].parentElement);
              }
            }
            if (c !== 0) {
              d = [];
              let p = s.originalEvent.touches;
              for (let h = 0; h < p.length; h++) {
                let u = {};
                for (let f in p[h]) {
                  p[h].hasOwnProperty(f) && (u[f] = p[h][f]);
                }
                d.push(u);
              }
            }
            ee(document).on("touchmove.scrollfix", (p) => {
              if (d) {
                let h = d[0],
                  f = p.originalEvent.touches[0].screenY - h.screenY;
                (f > 0 && !(c & 2) || f < 0 && !(c & 1)) && (c = 0),
                  f && (d = null);
              }
              c === 0 && p.preventDefault();
            }),
              ee(document).on("touchend.scrollfix", () => {
                ee(document).off(".scrollfix");
              });
          });
        };
      return { limitScrollOnElement: n, limitScrollOnDocument: i };
    }
  }();
  var { limitScrollOnElement: mI, limitScrollOnDocument: P4e } = jle;
  qt();
  function FO(r) {
    ee(r).on("drag dragend dragenter dragover dragleave drop", (t) => {
      t.preventDefault(), t.stopPropagation();
    });
  }
  var ro = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var ko = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var ec = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var fI = class extends ec.Class {
    template() {
      return ec.createElement(
        "span",
        {
          class: ec.const("dcg-navigate-back"),
          onTap: this.props.onBack,
          "aria-label": this.props.ariaLabel,
          role: ec.const("button"),
          tabIndex: ec.const("0"),
          handleEvent: ec.const("true"),
          manageFocus: this.const(
            rt({
              controller: this.props.controller(),
              location: { type: "geo-header-back-link" },
            }),
          ),
        },
        ec.createElement("i", {
          class: ec.const("dcg-icon-chevron-left"),
          "aria-hidden": ec.const("true"),
        }),
      );
    }
  };
  var { Each: Yle, SwitchUnion: Xle, If: Jle } = ko.Components,
    bI = class extends ko.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return ko.createElement(
          "div",
          {
            role: ko.const("toolbar"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-label-geometry-tools",
              ),
            class: ko.const(
              "dcg-geo-basic-tools dcg-animate-in-after-initial-load dcg-complex-tool-instruction-view",
            ),
          },
          ko.createElement(fI, {
            ariaLabel: () =>
              this.controller.s("account-shell-button-mygraphs-cancel"),
            controller: this.props.controller,
            onBack: this.bindFn(this.onCancel),
          }),
          Yle(() => this.getInputIndexes(), {
            item: (e) =>
              ko.createElement(NO, {
                activeStep: this.bindFn(this.getInputIndex),
                controller: this.props.controller,
                toolSpec: () => this.getToolSpec(),
                stepIdx: () => e,
              }),
          }),
        );
      }
      onCancel() {
        this.controller.dispatch({
          type: "select-geo-tool",
          tool: "selection",
        }),
          this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "geo-basic-tool", tool: "selection" },
          });
      }
      getInputIndex() {
        return this.controller.getGeoModel().getNonObjectsState().ui
          .currentTool.inputIndex;
      }
      getInputIndexes() {
        return this.getToolSpec().inputs.map((e, t) => t);
      }
      getToolSpec() {
        return this.controller.getGeoModel().getCurrentTool().getSpec();
      }
    },
    NO = class extends ko.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Xle(() => this.getInputType(), {
          completed: () => ko.createElement("span", null),
          upcoming: () =>
            ko.createElement("span", {
              class: ko.const("dcg-step-upcoming"),
            }, ko.createElement("span", null)),
          active: () =>
            ko.createElement(
              "span",
              { class: ko.const("dcg-active-step") },
              ko.createElement(
                "span",
                { class: ko.const("dcg-step-active-icon") },
                ko.createElement(
                  "span",
                  null,
                  () => this.props.stepIdx() + 1,
                ),
              ),
              ko.createElement("span", {
                class: ko.const("dcg-active-step-text"),
              }, this.bindFn(this.getActiveString)),
              ko.createElement(
                Jle,
                { predicate: this.bindFn(this.isNumberInputStep) },
                () =>
                  ko.createElement(
                    "span",
                    {
                      class: ko.const("dcg-input-flex-container"),
                      didMount: this.bindFn(this.didMountNumberInput),
                    },
                    ko.createElement(lr, {
                      containerClass: () => ({
                        "dcg-suffix-degree": this.getNumberUnits() === "\xB0",
                        "dcg-suffix-radian": this.getNumberUnits() === "rad",
                      }),
                      readonly: () => false,
                      latex: () => this.getNumberInputLatex(),
                      ariaLabel: this.bindFn(this.getActiveString),
                      isFocused: () => this.isNumberInputFocused(),
                      handleFocusChanged: (e, t) =>
                        this.handleFocusedChanged(e, t),
                      hasError: this.bindFn(
                        this.doesNumberInputHaveError,
                      ),
                      controller: this.props.controller,
                      handlePressedKey: (e, t) => {
                        this.handlePressedKey(e, t);
                      },
                      handleLatexChanged: (e) => {
                        this.handleLatexChanged(e);
                      },
                      handleSelectionChanged: (e) => {
                        this.handleLatexChanged(e.latex, true);
                      },
                      dataLabelAttributeValue: this.const(
                        "transformation-number",
                      ),
                    }),
                    ko.createElement(
                      "span",
                      {
                        class: () => ({
                          "dcg-action-submit": true,
                          "dcg-disabled": this.isSubmitNumberDisabled(),
                          "dcg-btn-purple": true,
                        }),
                        role: ko.const("button"),
                        tabIndex: () => this.isSubmitNumberDisabled() ? -1 : 0,
                        "aria-disabled": this.bindFn(
                          this.isSubmitNumberDisabled,
                        ),
                        onTap: (e) =>
                          this.submitNumberInput({ device: e.device }),
                      },
                      () => this.controller.s("shared-calculator-button-go"),
                    ),
                  ),
              ),
            ),
        });
      }
      getNumberUnits() {
        return this.controller.getActiveTool() === "rotate"
          ? this.controller.getDegreeMode() ? "\xB0" : "rad"
          : "";
      }
      didMountNumberInput() {
        this.controller.dispatch({
          type: "set-focus-location",
          location: { type: "new-transformation-number" },
        });
      }
      isNumberInputFocused() {
        let e = this.controller.getFocusLocation();
        return !!(e && e.type === "new-transformation-number");
      }
      doesNumberInputHaveError() {
        var l;
        if (
          !this.getNumberInputLatex() ||
          this.getNumberInputLatex() ===
            ((l = this.getStep().numberInputInfo) == null
              ? void 0
              : l.defaultLatex)
        ) return false;
        let t = this.props.toolSpec().outputs[0].id,
          { idMap: o } = this.controller.getGeoModel().getNonObjectsState().ui
            .currentTool,
          i = o[t];
        if (!i) return true;
        let n = rb(this.controller.getListModel()).filter((c) => {
            var d;
            if (c.type === "expression") {
              return i === ((d = pi(c)) == null ? void 0 : d.latex);
            }
          }),
          a = n[0];
        if (!a || n.length === 0 || n.length > 1 || a.error) return true;
        let s = a.formula.typed_constant_value;
        if (!s) return true;
        if (
          __dcg_shared_module_exports__["isTypeOrListOfType"](
            s.valueType,
            __dcg_shared_module_exports__["Transformation"],
          )
        ) {
          let c = __dcg_shared_module_exports__["isList"](s.valueType)
            ? s.value
            : [s.value];
          for (let d of c) {
            let [[p, h], [u, f]] = d;
            if (isNaN(p) || isNaN(h) || isNaN(u) || isNaN(f)) return true;
          }
          return false;
        }
        return true;
      }
      handlePressedKey(e, t) {
        let o = Fe.getFocusedMathquill();
        if (e === "Enter") {
          this.submitNumberInput({ device: "keyboard" });
          return;
        }
        o && (o.keystroke(e, t), this.handleLatexChanged(o.latex()));
      }
      getNumberInputLatex() {
        return this.controller.getGeoModel().getCurrentTool()
          .getNumberInputLatex();
      }
      isSubmitNumberDisabled() {
        return !!(this.doesNumberInputHaveError() ||
          !this.getNumberInputLatex());
      }
      submitNumberInput(e) {
        var s, l;
        if (this.isSubmitNumberDisabled()) return;
        let t = this.controller.getGeoModel(),
          o = this.controller.getActiveTool(),
          i = t.getCurrentTool(),
          n = (s = i.getSpec) == null ? void 0 : s.call(i),
          a = i.tryCommitResults();
        a.committed &&
          (this.controller.dispatch({ type: "commit-geo-objects", ...a }),
            (l = this.controller.get2dPOIController()) == null ||
            l.speakGeoReleaseAction(o, n, a.committed),
            e.device === "keyboard" &&
            this.controller.dispatch({
              type: "set-focus-location",
              location: { type: "graph-paper" },
            }));
      }
      handleLatexChanged(e, t) {
        (this.getNumberInputLatex() !== e || t) &&
          (this.controller.getGeoModel().getCurrentTool().onNumberInput(
            e,
          ),
            this.controller.getGeoModel().onPreviewChange());
      }
      handleFocusedChanged(e, t) {
        e && !this.isNumberInputFocused()
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "new-transformation-number" },
          })
          : this.isNumberInputFocused() &&
            this.controller.dispatch({
              type: "blur-focus-location",
              location: { type: "new-transformation-number" },
            });
      }
      getActiveString() {
        let e = this.props.controller(), t = this.getStep().hint;
        return t ? e.s(t) : e.s("shared-calculator-narration-item-unknown");
      }
      isNumberInputStep() {
        return !!this.getStep().numberInputInfo;
      }
      getStep() {
        return this.props.toolSpec().inputs[this.props.stepIdx()];
      }
      getInputType() {
        let e = this.props.activeStep(), t = this.props.stepIdx();
        return t < e ? "completed" : t > e ? "upcoming" : "active";
      }
    };
  var { SwitchUnion: Qle, If: z9 } = ro.Components,
    yI = class extends ro.Class {
      constructor() {
        super(...arguments), this.afterInitialLoad = false;
      }
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return ro.createElement(
          "div",
          {
            class: () => ({
              "dcg-geometry-toolbar-view": true,
              "dcg-after-initial-load": this.afterInitialLoad,
            }),
            style: () => ({
              left: `${this.controller.computeMajorLayout().grapher.left}px`,
            }),
            onTapStart: this.bindFn(this.onTapStart),
          },
          ro.createElement(
            "div",
            { class: ro.const("dcg-header-left dcg-do-blur") },
            ro.createElement(z9, {
              predicate: this.bindFn(this.showHamburger),
            }, () =>
              ro.createElement(
                Le,
                {
                  tooltip: () =>
                    this.controller.s(
                      "graphing-calculator-label-tooltip-open-graph",
                    ),
                  gravity: this.const("s"),
                },
                ro.createElement(
                  "div",
                  {
                    role: ro.const("button"),
                    "aria-label": () =>
                      this.controller.s(
                        "graphing-calculator-label-tooltip-open-graph",
                      ),
                    tabIndex: ro.const("0"),
                    class: ro.const(
                      "dcg-action-opendrawer dcg-icon-btn dcg-in-api-action-opendrawer",
                    ),
                    onTap: () =>
                      this.controller.dispatch({ type: "open-drawer" }),
                  },
                  ro.createElement("i", {
                    class: ro.const("dcg-icon-hamburger"),
                    "aria-hidden": ro.const("true"),
                  }),
                ),
              )),
            ro.createElement(z9, {
              predicate: this.bindFn(this.showOpenExpressionsButton),
            }, () =>
              ro.createElement(
                "div",
                {
                  class: ro.const(
                    "dcg-show-expressions-tab dcg-icon-btn",
                  ),
                  "aria-label": () =>
                    this.controller.s(
                      "graphing-calculator-label-tooltip-show-list",
                    ),
                  role: ro.const("button"),
                  tabIndex: ro.const("0"),
                  onTap: (e) => {
                    this.controller.dispatch({
                      type: "show-expressions-list",
                      focusHideIcon: e.device === "keyboard",
                    });
                  },
                  manageFocus: this.const(
                    rt({
                      controller: this.controller,
                      location: { type: "show-expression-list-btn" },
                    }),
                  ),
                },
                ro.createElement("i", {
                  class: ro.const("dcg-icon-show"),
                  "aria-hidden": ro.const("true"),
                }),
              )),
          ),
          ro.createElement("div", {
            class: ro.const("dcg-flex-spacer dcg-do-blur"),
          }),
          Qle(this.bindFn(this.getViewToShow), {
            tools: () =>
              ro.createElement(QD, { controller: this.props.controller }),
            selectedItems: () =>
              ro.createElement(nk, { controller: this.props.controller }),
            complexToolInstructions: () =>
              ro.createElement(bI, { controller: this.props.controller }),
          }),
          ro.createElement("div", {
            class: ro.const("dcg-flex-spacer dcg-do-blur"),
          }),
        );
      }
      showHamburger() {
        return this.controller.getGraphSettings().config.showHamburger
          ? !this.controller.isListEnabled() ||
            !this.controller.isListVisible() || this.controller.isNarrow()
          : false;
      }
      showOpenExpressionsButton() {
        return this.controller.isListEnabled() &&
          !this.controller.isListVisible() && !this.controller.isNarrow();
      }
      willUpdate() {
        this.afterInitialLoad ||
          this.getViewToShow() === "selectedItems" &&
            (this.afterInitialLoad = true);
      }
      onTapStart(e) {
        e.target.classList.contains("dcg-do-blur") &&
          (this.controller.dispatch({ type: "set-none-selected" }),
            this.controller.dispatch({
              type: "select-geo-tool",
              tool: "selection",
            }));
      }
      getViewToShow() {
        let e = this.controller.getActiveTool();
        return __dcg_shared_module_exports__["Dc"](e)
          ? "complexToolInstructions"
          : this.controller.shouldShowMultiSelectHeader()
          ? "selectedItems"
          : "tools";
      }
    };
  var xo = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var ms = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Yy = class extends ms.Class {
    init() {
      this.controller = this.props.controller();
    }
    template() {
      return ms.createElement(
        "div",
        {
          class: () => ({
            "dcg-btn-flat-gray": this.props.isPillbox(),
            "dcg-btn-flat-gray-group": this.props.isPillbox(),
            "dcg-group-horizontal": this.props.isPillbox(),
          }),
        },
        ms.createElement(
          Le,
          {
            tooltip: () =>
              this.controller.getshowKeyboardShortcutsInTooltips()
                ? this.controller.s(
                  "graphing-calculator-label-undo-with-shortcut-tooltip",
                )
                : this.controller.s(
                  "graphing-calculator-label-undo-tooltip",
                ),
            gravity: this.const("s"),
            disabled: () => !this.controller.canUndo(),
            displayBlock: this.props.isPillbox,
          },
          ms.createElement(
            "button",
            {
              class: () => ({
                "dcg-unstyled-button": true,
                "dcg-action-undo": true,
                "dcg-icon-btn": true,
                "dcg-pillbox-btn-interior": this.props.isPillbox(),
                "dcg-disabled": !this.controller.canUndo(),
              }),
              tabIndex: () => this.controller.canUndo() ? 0 : -1,
              "aria-label": () =>
                this.controller.s("graphing-calculator-narration-undo"),
              onTap: this.bindFn(this.undo),
              "aria-disabled": () => !this.controller.canUndo(),
            },
            ms.createElement("i", {
              class: ms.const("dcg-icon-undo"),
              "aria-hidden": ms.const("true"),
            }),
          ),
        ),
        ms.createElement(
          Le,
          {
            tooltip: () =>
              this.controller.getshowKeyboardShortcutsInTooltips()
                ? this.controller.s(
                  "graphing-calculator-label-redo-with-shortcut-tooltip",
                )
                : this.controller.s(
                  "graphing-calculator-label-redo-tooltip",
                ),
            gravity: this.const("s"),
            disabled: () => !this.controller.canRedo(),
            displayBlock: this.props.isPillbox,
          },
          ms.createElement(
            "button",
            {
              class: () => ({
                "dcg-unstyled-button": true,
                "dcg-action-redo": true,
                "dcg-icon-btn": true,
                "dcg-pillbox-btn-interior": this.props.isPillbox(),
                "dcg-disabled": !this.controller.canRedo(),
              }),
              tabIndex: () => this.controller.canRedo() ? 0 : -1,
              "aria-label": () =>
                this.controller.s("graphing-calculator-narration-redo"),
              onTap: () => this.controller.dispatch({ type: "redo" }),
              "aria-disabled": () => !this.controller.canRedo(),
            },
            ms.createElement("i", {
              class: ms.const("dcg-icon-redo"),
              "aria-hidden": ms.const("true"),
            }),
          ),
        ),
      );
    }
    undo() {
      this.controller.hasVisibleAndUndoableToast()
        ? this.controller.toastUndo()
        : this.controller.dispatch({ type: "undo" });
    }
  };
  var ta = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: Zle } = ta.Components,
    Ah = class extends ta.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return ta.createElement(
          Le,
          {
            tooltip: this.bindFn(this.getTooltip),
            gravity: this.const("w"),
          },
          ta.createElement(
            "div",
            {
              class: () => ({
                "dcg-action-settings": true,
                "dcg-pillbox-btn-interior": true,
                "dcg-icon-btn": true,
                "dcg-btn-flat-gray": this.isPillbox(),
                "dcg-settings-pillbox": this.isPillbox(),
              }),
              role: ta.const("button"),
              tabIndex: ta.const("0"),
              "aria-haspopup": ta.const("true"),
              "aria-expanded": () => this.controller.isGraphSettingsOpen(),
              "aria-label": this.bindFn(this.getTooltip),
              onTap: this.bindFn(this.onTapSettingsButton),
              manageFocus: this.const(
                rt({
                  controller: this.controller,
                  location: { type: "settings", location: "icon" },
                }),
              ),
            },
            ta.createElement("i", {
              class: ta.const("dcg-icon-wrench"),
              "aria-hidden": ta.const("true"),
            }),
            ta.createElement(
              Zle,
              {
                predicate: () => this.controller.getLockViewportUserSetting(),
              },
              () =>
                ta.createElement("i", {
                  class: ta.const("dcg-icon-lock"),
                  "aria-hidden": ta.const("true"),
                }),
            ),
          ),
        );
      }
      getTooltip() {
        return this.controller.isGeometry()
          ? this.controller.s(
            "graphing-calculator-label-tooltip-geometry-settings",
          )
          : this.controller.s(
            "graphing-calculator-label-tooltip-graph-settings",
          );
      }
      isPillbox() {
        return this.props.isPillbox && this.props.isPillbox();
      }
      onTapSettingsButton(e) {
        this.controller.dispatch({
          type: "toggle-graph-settings",
          focusOnOpen: e.device === "keyboard",
        });
      }
    };
  var bo = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    { SwitchUnion: ece } = bo.Components,
    h0 = class extends bo.Class {
      template() {
        return this.controller = this.props.controller(),
          ece(() => this.controller.getBrandingMode(), {
            "static-edit-link": () =>
              bo.createElement(
                "div",
                { class: bo.const("dcg-graphpaper-branding") },
                bo.createElement(
                  "a",
                  {
                    href: () => this.controller.getEditLink(),
                    target: bo.const("_blank"),
                  },
                  bo.createElement("span", {
                    class: bo.const("dcg-powered-by"),
                    "aria-label": () =>
                      this.controller.s(
                        "graphing-calculator-narration-edit-on-desmos",
                      ),
                  }, () =>
                    this.controller.s(
                      "graphing-calculator-link-edit-on-desmos",
                    )),
                  bo.createElement("i", {
                    class: bo.const("dcg-icon-desmos"),
                    "aria-hidden": bo.const("true"),
                  }),
                ),
              ),
            "edit-link": () =>
              bo.createElement(
                "div",
                { class: bo.const("dcg-graphpaper-branding") },
                bo.createElement(
                  "span",
                  {
                    class: bo.const("dcg-edit-branding"),
                    onTap: () =>
                      this.controller.dispatch({ type: "open-on-web" }),
                  },
                  bo.createElement("span", {
                    class: bo.const("dcg-powered-by"),
                    "aria-label": () =>
                      this.controller.s(
                        "graphing-calculator-narration-edit-on-desmos",
                      ),
                  }, () =>
                    this.controller.s(
                      "graphing-calculator-link-edit-on-desmos",
                    )),
                  bo.createElement("i", {
                    class: bo.const("dcg-icon-desmos"),
                    "aria-hidden": bo.const("true"),
                  }),
                ),
              ),
            "powered-by": () =>
              bo.createElement(
                "div",
                {
                  class: bo.const(
                    "dcg-graphpaper-branding dcg-unclickable",
                  ),
                },
                bo.createElement("span", {
                  class: bo.const("dcg-powered-by"),
                  "aria-label": () =>
                    this.controller.s(
                      "graphing-calculator-narration-powered-by-desmos",
                    ),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-label-powered-by",
                  )),
                bo.createElement("i", {
                  class: bo.const("dcg-icon-desmos"),
                  "aria-hidden": bo.const("true"),
                }),
              ),
          });
      }
    };
  var zs = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var g0 = class extends zs.Class {
    init() {
      this.controller = this.props.controller();
    }
    template() {
      return zs.createElement(
        "div",
        { class: zs.const("dcg-reset-container") },
        zs.createElement(
          Le,
          {
            tooltip: () =>
              this.controller.s(
                "graphing-calculator-label-tooltip-reset",
              ),
            gravity: this.props.tooltipGravity,
          },
          zs.createElement(
            "div",
            {
              class: zs.const(
                "dcg-reset-pillbox dcg-action-reset dcg-btn-flat-gray dcg-pillbox-btn-interior",
              ),
              role: zs.const("button"),
              tabIndex: zs.const("0"),
              "aria-label": () =>
                this.controller.s(
                  "graphing-calculator-label-tooltip-reset",
                ),
              onTap: this.bindFn(this.reset),
            },
            zs.createElement("i", {
              class: zs.const("dcg-icon-reset"),
              "aria-hidden": zs.const("true"),
            }),
          ),
        ),
      );
    }
    reset() {
      this.controller.dispatch({ type: "reset-graph" });
    }
  };
  var ra = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var m0 = class extends ra.Class {
    init() {
      this.controller = this.props.controller();
    }
    template() {
      return ra.createElement(
        "div",
        {
          class: () => ({
            "dcg-3d-orientation-pillbox": true,
            "dcg-btn-flat-gray": true,
            "dcg-btn-flat-gray-group": true,
            "dcg-group-horizontal": this.props.layout() === "horizontal",
            "dcg-group-vertical": this.props.layout() === "vertical",
          }),
          role: ra.const("group"),
          "aria-label": () =>
            this.controller.s(
              "graphing-calculator-narration-3d-orientation-options-label",
            ),
        },
        ra.createElement(
          Le,
          {
            disabled: this.bindFn(this.isDefaultOrientation),
            tooltip: this.bindFn(this.getDefaultOrientationLabel),
            gravity: this.bindFn(this.getTooltipGravity),
            displayBlock: this.const(true),
          },
          ra.createElement(
            "div",
            {
              class: () => ({
                "dcg-action-defaultorientation": true,
                "dcg-pillbox-btn-interior": true,
                "dcg-disabled": this.isDefaultOrientation(),
              }),
              role: ra.const("button"),
              "aria-disabled": this.bindFn(this.isDefaultOrientation),
              tabIndex: () => this.isDefaultOrientation() ? -1 : 0,
              "aria-label": this.bindFn(this.getDefaultOrientationLabel),
              onTap: this.bindFn(this.rotateToDefaultOrientation),
            },
            ra.createElement("i", {
              class: ra.const("dcg-icon-3d-cube"),
              "aria-hidden": ra.const("true"),
            }),
          ),
        ),
        ra.createElement(
          Le,
          {
            tooltip: this.bindFn(this.getXYOrientationLabel),
            gravity: this.bindFn(this.getTooltipGravity),
            disabled: this.bindFn(this.isXYPlaneOrientation),
            displayBlock: this.const(true),
          },
          ra.createElement(
            "div",
            {
              class: () => ({
                "dcg-action-xyorientation": true,
                "dcg-pillbox-btn-interior": true,
                "dcg-disabled": this.isXYPlaneOrientation(),
              }),
              role: ra.const("button"),
              "aria-disabled": this.bindFn(this.isXYPlaneOrientation),
              tabIndex: () => this.isXYPlaneOrientation() ? -1 : 0,
              "aria-label": this.bindFn(this.getXYOrientationLabel),
              onTap: this.bindFn(this.rotateToXyOrientation),
            },
            ra.createElement("i", {
              class: ra.const("dcg-icon-xy-plane"),
              "aria-hidden": ra.const("true"),
            }),
          ),
        ),
      );
    }
    getTooltipGravity() {
      return this.props.layout() === "horizontal" ? "s" : "w";
    }
    rotateToDefaultOrientation() {
      this.controller.dispatch({
        type: "zoom",
        direction: "default3dOrientation",
      });
    }
    rotateToXyOrientation() {
      this.controller.dispatch({
        type: "zoom",
        direction: "xy3dOrientation",
      });
    }
    isDefaultOrientation() {
      var t;
      let e = (t = this.controller.getGrapher3d()) == null
        ? void 0
        : t.controls;
      return !!(e != null && e.isDefaultOrientation());
    }
    isXYPlaneOrientation() {
      var t;
      let e = (t = this.controller.getGrapher3d()) == null
        ? void 0
        : t.controls;
      return !!(e != null && e.isXYPlaneOrientation());
    }
    getDefaultOrientationLabel() {
      return this.controller.s(
        "graphing-calculator-label-tooltip-zoom-default-orientation",
      );
    }
    getXYOrientationLabel() {
      return this.controller.s(
        "graphing-calculator-label-tooltip-zoom-xy-orientation",
      );
    }
  };
  var ve = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var tc = function (r, e, t) {
    if (r === void 0 || e === void 0) return false;
    let o,
      i = e.getBoundingClientRect().height,
      n = r.getBoundingClientRect().height,
      a = Gl(r),
      s = Gl(e);
    if (!a || !s) return false;
    let l = e.scrollTop,
      c = a.top + l - s.top,
      d = c - t,
      p = n + c + t - i;
    return d >= p ? o = Math.min(Math.max(l, p), d) : o = .5 * (d + p),
      o !== l ? (e.scrollTop = o, e.scrollTop != l) : false;
  };
  var yo = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Mh = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Sm = class extends Mh.Class {
    template() {
      return Mh.createElement(
        "div",
        {
          class: Mh.const("dcg-checkbox-title dcg-lock-viewport-option"),
        },
        Mh.createElement(mt, {
          ariaLabel: () =>
            this.props.controller().s(
              "graphing-calculator-label-settings-lock-viewport",
            ),
          onChange: () => {
            this.props.controller().dispatch({
              type: "toggle-lock-viewport",
            });
          },
          checked: () => this.props.controller().getLockViewportUserSetting(),
        }, () =>
          this.props.controller().s(
            "graphing-calculator-label-settings-lock-viewport",
          )),
        Mh.createElement(Md, {
          href: this.const(
            "https://help.desmos.com/hc/en-us/articles/4405296853517#h_01FZX4DBWKD83TZVMH615XF3QA",
          ),
          controller: this.props.controller,
        }),
      );
    }
  };
  var { If: xI } = yo.Components,
    wI = class extends yo.Class {
      init() {
        this.controller = this.props.controller(),
          this.isOpen = this.getAxisScale("x") === "logarithmic" ||
            this.getAxisScale("y") === "logarithmic" ||
            this.controller.getLockViewportUserSetting();
      }
      template() {
        return yo.createElement(
          "div",
          { class: yo.const("dcg-advanced-graph-settings-view") },
          yo.createElement(xI, {
            predicate: () => this.shouldShowLogScalesOption(),
          }, () =>
            yo.createElement(
              "div",
              null,
              yo.createElement(
                "div",
                {
                  class: () => ({
                    "dcg-advanced-toggle": true,
                    "dcg-margin-top": true,
                    "dcg-opened": this.isOpen,
                  }),
                  onTap: this.bindFn(this.toggleOpen),
                  tabIndex: yo.const(0),
                  role: yo.const("button"),
                  "aria-pressed": () => this.isOpen,
                },
                yo.createElement(
                  "div",
                  { class: yo.const("dcg-caret-container") },
                  yo.createElement("i", {
                    class: yo.const("dcg-icon-caret-down"),
                    "aria-hidden": yo.const("true"),
                  }),
                ),
                () =>
                  this.controller.s(
                    "graphing-calculator-label-more-viewport-options",
                  ),
              ),
              yo.createElement(xI, {
                predicate: () => this.isOpen,
              }, () =>
                yo.createElement(
                  "div",
                  { class: yo.const("dcg-advanced-contents") },
                  yo.createElement(
                    "div",
                    { class: yo.const("dcg-log-axes-container") },
                    yo.createElement(
                      "div",
                      null,
                      () => this.getAxisScaleLabel("x"),
                    ),
                    yo.createElement(vo, {
                      ariaGroupLabel: () => this.getAxisScaleLabel("x"),
                      theme: this.const("mini"),
                      staticConfig: this.const(
                        this.getStaticConfigForAxis("x"),
                      ),
                    }),
                    yo.createElement(
                      "div",
                      null,
                      () => this.getAxisScaleLabel("y"),
                    ),
                    yo.createElement(vo, {
                      ariaGroupLabel: () => this.getAxisScaleLabel("y"),
                      theme: this.const("mini"),
                      staticConfig: this.const(
                        this.getStaticConfigForAxis("y"),
                      ),
                    }),
                  ),
                  yo.createElement(xI, {
                    predicate: () =>
                      !this.controller.getLockViewportConfigSetting(),
                  }, () => yo.createElement(Sm, { ...this.props })),
                )),
            )),
          yo.createElement(xI, {
            predicate: () =>
              !this.controller.getLockViewportConfigSetting() &&
              !this.shouldShowLogScalesOption(),
          }, () => yo.createElement(Sm, { ...this.props })),
        );
      }
      toggleOpen() {
        this.isOpen = !this.isOpen, this.update();
      }
      getAxisScaleLabel(e) {
        return e === "x"
          ? this.controller.s(
            "graphing-calculator-label-settings-x-axis",
          ) + ":"
          : this.controller.s(
            "graphing-calculator-label-settings-y-axis",
          ) + ":";
      }
      getStaticConfigForAxis(e) {
        return [{
          key: "linear",
          label: () => "Linear",
          selected: () => this.getAxisScale(e) === "linear",
          onSelect: () => this.setAxisScale({ axis: e, scale: "linear" }),
        }, {
          key: "logarithmic",
          label: () => "Logarithmic",
          selected: () => this.getAxisScale(e) === "logarithmic",
          onSelect: () => this.setAxisScale({ axis: e, scale: "logarithmic" }),
        }];
      }
      shouldShowLogScalesOption() {
        return this.controller.getGraphSettings().config.logScales &&
          !this.controller.isThreeDMode();
      }
      getAxisScale(e) {
        return this.controller
          .getGraphSettings()[e === "x" ? "xAxisScale" : "yAxisScale"];
      }
      setAxisScale({ axis: e, scale: t }) {
        return this.controller.dispatch({
          type: "set-graph-settings",
          [e === "x" ? "xAxisScale" : "yAxisScale"]: t,
        });
      }
    };
  var hn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: tce } = hn.Components,
    Gh = class extends hn.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return hn.createElement(
          "div",
          null,
          hn.createElement(
            "div",
            { class: hn.const("dcg-braille-options-buttons") },
            hn.createElement(vo, {
              ariaGroupLabel: () =>
                this.controller.s(
                  "shared-calculator-narration-braille-mode",
                ),
              staticConfig: this.bindFn(this.getBrailleOptions),
            }),
          ),
          hn.createElement(
            "div",
            { class: hn.const("dcg-six-key-checkbox") },
            hn.createElement(mt, {
              onChange: (e) =>
                this.controller.dispatch({
                  type: "set-six-key-input",
                  useSixKeyInput: e,
                }),
              checked: () => this.controller.getSixKeyInput(),
            }, () =>
              this.controller.s(
                "graphing-calculator-label-settings-six-key-braille",
              )),
            hn.createElement(Md, {
              href: this.const(
                "https://www.desmos.com/accessibility#braille",
              ),
              controller: this.props.controller,
            }),
          ),
          hn.createElement(
            tce,
            { predicate: this.props.showBrailleNote },
            () =>
              hn.createElement(
                "div",
                { class: hn.const("dcg-refreshable-braille-note") },
                () =>
                  this.controller.s(
                    "graphing-calculator-text-refreshable-braille-display-note",
                  ) + " ",
                hn.createElement("a", {
                  href: () =>
                    "https://www.desmos.com/braille-examples?" +
                    this.controller.getBrailleMode(),
                  class: hn.const("dcg-blue-link"),
                  target: hn.const("_blank"),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-link-view-braille-examples",
                  )),
              ),
          ),
        );
      }
      getBrailleOptions() {
        return [{
          key: "nemeth",
          label: () =>
            this.controller.s(
              "shared-calculator-button-braille-mode-nemeth",
            ),
          selected: () => this.controller.getBrailleMode() === "nemeth",
          onSelect: () => this.setBrailleMode("nemeth"),
        }, {
          key: "ueb",
          label: () =>
            this.controller.s(
              "shared-calculator-button-braille-mode-ueb",
            ),
          selected: () => this.controller.getBrailleMode() === "ueb",
          onSelect: () => this.setBrailleMode("ueb"),
        }];
      }
      setBrailleMode(e) {
        this.controller.dispatch({ type: "set-braille-mode", mode: e });
      }
    };
  var gn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: q9 } = gn.Components,
    Lh = class extends gn.Class {
      init() {
        this.controller = this.props.controller();
      }
      toggleComplexMode() {
        this.controller.logEvent({
          category: "settings",
          action: this.props.isComplexModeEnabled()
            ? "disable-complex"
            : "enable-complex",
        }), this.props.toggleComplexMode();
      }
      template() {
        return gn.createElement(
          "div",
          {
            class: gn.const(
              "dcg-options-menu-section dcg-complex-container",
            ),
          },
          gn.createElement(
            "div",
            { class: gn.const("dcg-options-menu-section-title") },
            () =>
              this.controller.s(
                "graphing-calculator-label-settings-complex-mode",
              ),
            gn.createElement(go, {
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-label-settings-complex-mode",
                ),
              onChange: this.bindFn(this.toggleComplexMode),
              toggled: this.props.isComplexModeEnabled,
            }),
          ),
          gn.createElement(q9, {
            predicate: this.props.isComplexModeEnabled,
          }, () =>
            gn.createElement(
              "div",
              { class: gn.const("dcg-complex-options-section") },
              gn.createElement(
                "div",
                { class: gn.const("dcg-complex-enabled-note") },
                gn.createElement(es, {
                  content: () =>
                    this.controller.s(
                      "shared-calculator-text-complex-enabled-note",
                      { eq1: "`i^2`", eq2: "`\\sqrt{-4}`" },
                    ),
                  mqConfig: this.const({}),
                }),
                gn.createElement(q9, {
                  predicate: () =>
                    this.props.product() === "graphing" ||
                    this.props.product() === "graphing-3d",
                }, () =>
                  gn.createElement("div", {
                    class: gn.const("dcg-complex-plotting-note"),
                  }, () =>
                    this.controller.s(
                      "graphing-calculator-text-complex-plotting-note",
                    ))),
              ),
            )),
        );
      }
    };
  var Pc = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { IfElse: rce } = Pc.Components,
    rc = class extends Pc.Class {
      init() {
        this.controller = this.props.setup().controller;
      }
      getGravity() {
        return this.props.setup().type === "basic"
          ? "s"
          : this.controller.isNarrow()
          ? "n"
          : "w";
      }
      template() {
        return Pc.createElement(
          "div",
          { class: Pc.const("dcg-options-menu-section dcg-radiangroup") },
          rce(() => this.controller.isComplexModeEnabled(), {
            true: () =>
              Pc.createElement(
                Le,
                {
                  tooltip: () =>
                    this.controller.s(
                      "shared-calculator-text-complex-radian-mode",
                    ),
                  gravity: this.bindFn(this.getGravity),
                  sticky: this.const(true),
                  displayBlock: this.const(true),
                  additionalClass: this.const("dcg-cursor-default"),
                },
                Pc.createElement(vo, {
                  ariaGroupLabel: () =>
                    this.controller.s(
                      "graphing-calculator-narration-settings-angle",
                    ),
                  theme: () =>
                    this.props.setup().type === "basic" ? "mini" : "default",
                  staticConfig: this.bindFn(this.getAngleModeOptions),
                  disabled: () => this.controller.isComplexModeEnabled(),
                }),
              ),
            false: () => this.renderControl(),
          }),
        );
      }
      renderControl() {
        return Pc.createElement(vo, {
          ariaGroupLabel: () =>
            this.controller.s(
              "graphing-calculator-narration-settings-angle",
            ),
          theme: () => this.props.setup().type === "basic" ? "mini" : "default",
          staticConfig: this.bindFn(this.getAngleModeOptions),
          disabled: () => this.controller.isComplexModeEnabled(),
        });
      }
      getAngleModeOptions() {
        let e = this.props.setup();
        return [{
          key: "radians",
          label: () =>
            e.type === "basic"
              ? this.controller.s("basic-calculator-label-controlbar-rad")
              : this.controller.s(
                "graphing-calculator-button-settings-radians",
              ),
          selected: () => !this.getDegreeMode(),
          onSelect: () => this.setDegreeMode(false),
          focusHelperOptions: e.type === "advanced"
            ? {
              controller: e.controller,
              location: { type: "settings", location: "radian-mode" },
            }
            : void 0,
        }, {
          key: "degrees",
          label: () =>
            e.type === "basic"
              ? this.controller.s("basic-calculator-label-controlbar-deg")
              : this.controller.s(
                "graphing-calculator-button-settings-degrees",
              ),
          selected: () => this.getDegreeMode(),
          onSelect: () => this.setDegreeMode(true),
          focusHelperOptions: e.type === "advanced"
            ? {
              controller: e.controller,
              location: { type: "settings", location: "degree-mode" },
            }
            : void 0,
        }];
      }
      getDegreeMode() {
        return this.controller.getDegreeMode();
      }
      setDegreeMode(e) {
        this.controller.dispatch({ type: "update-degree-mode", mode: e });
      }
    };
  var ou = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Xy = class extends ou.Class {
    init() {
      this.controller = this.props.controller();
    }
    template() {
      return ou.createElement(
        "div",
        null,
        ou.createElement(
          "div",
          { class: ou.const("dcg-displaysizegroup") },
          ou.createElement(vo, {
            ariaGroupLabel: () =>
              this.controller.s(
                "shared-calculator-narration-settings-display-size",
              ),
            staticConfig: this.bindFn(this.getProjectorModeOptions),
          }),
        ),
        ou.createElement(mt, {
          onChange: this.bindFn(this.toggleInvertedColors),
          checked: () => this.controller.getInvertedColors(),
          manageFocus: this.const(
            rt({
              controller: this.controller,
              location: {
                type: "settings",
                location: "reverse-contrast",
              },
            }),
          ),
        }, () =>
          this.controller.s(
            "graphing-calculator-label-settings-reverse-contrast",
          )),
      );
    }
    getProjectorModeOptions() {
      return [{
        key: "default",
        label: () => "A",
        ariaLabel: () =>
          this.controller.s(
            "shared-calculator-narration-settings-display-size-default",
          ),
        class: () => "dcg-displaysize-default",
        selected: () => !this.getProjectorMode(),
        onSelect: () => this.onSelectProjectorModeOption(false),
        focusHelperOptions: {
          controller: this.controller,
          location: { type: "settings", location: "default-size" },
        },
      }, {
        key: "large",
        label: () => "A",
        ariaLabel: () =>
          this.controller.s(
            "shared-calculator-narration-settings-display-size-large",
          ),
        class: () => "dcg-displaysize-large",
        selected: () => this.getProjectorMode(),
        onSelect: () => this.onSelectProjectorModeOption(true),
        focusHelperOptions: {
          controller: this.controller,
          location: { type: "settings", location: "large-size" },
        },
      }];
    }
    onSelectProjectorModeOption(e) {
      this.controller.dispatch({ type: "set-projector-mode", value: e });
    }
    getProjectorMode() {
      return !!this.controller.getGraphSettings().config.projectorMode;
    }
    toggleInvertedColors() {
      this.controller.dispatch({
        type: "set-inverted-colors",
        value: !this.controller.getInvertedColors(),
      });
    }
  };
  var { Input: H9, If: wl, IfElse: K9 } = ve.Components,
    Ph = class extends ve.Class {
      template() {
        return ve.createElement(lr, {
          isFocused: () =>
            this.props.parent().getFocusedLimit() === this.props.limit(),
          latex: () => this.props.parent().getLimitLatex(this.props.limit()),
          ariaLabel: this.props.ariaLabel,
          handleLatexChanged: (e) =>
            this.props.parent().setLimitLatex(this.props.limit(), e),
          handleFocusChanged: (e) =>
            this.props.parent().onFocusedChanged(this.props.limit(), e),
          hasError: () =>
            this.props.parent().isLimitInvalid(this.props.limit()),
          dataLabelAttributeValue: this.props.limit,
          controller: this.props.controller,
          readonly: this.const(false),
          containerClass: () => ({
            "dcg-log-scale": this.props.axisScale() === "logarithmic",
          }),
        });
      }
    },
    vI = class extends ve.Class {
      init() {
        this.controller = this.props.controller(), this.uuid = Dd();
      }
      template() {
        return ve.createElement(
          "div",
          { class: ve.const("dcg-settings-view-container") },
          ve.createElement(Ah, {
            ...this.props,
            isPillbox: this.const(true),
          }),
          ve.createElement(wl, {
            predicate: () => this.controller.isGraphSettingsOpen(),
          }, () =>
            ve.createElement(
              "div",
              {
                class: ve.const(
                  "dcg-settings-container dcg-left dcg-popover dcg-constrained-height-popover",
                ),
                style: this.bindFn(this.getContainerStyle),
                didMount: this.bindFn(this.didMountContainer),
                didUnmount: this.bindFn(this.didUnmountContainer),
              },
              ve.createElement(
                "div",
                {
                  class: ve.const("dcg-popover-interior"),
                  role: ve.const("region"),
                  "aria-label": () =>
                    this.controller.s(
                      "graphing-calculator-label-tooltip-graph-settings",
                    ),
                },
                ve.createElement(
                  "div",
                  { class: ve.const("dcg-visual-settings") },
                  ve.createElement(Xy, {
                    controller: this.props.controller,
                  }),
                  ve.createElement(wl, {
                    predicate: () => this.controller.getBrailleControls(),
                  }, () =>
                    ve.createElement(
                      "div",
                      {
                        class: ve.const(
                          "dcg-braille-container dcg-braille-mode",
                        ),
                      },
                      ve.createElement(mt, {
                        onChange: this.bindFn(this.toggleBrailleMode),
                        checked: () =>
                          this.controller.getBrailleMode() !== "none",
                      }, () =>
                        this.controller.s(
                          "shared-calculator-narration-braille-mode",
                        )),
                      ve.createElement(wl, {
                        predicate: () =>
                          this.controller.getBrailleMode() !== "none",
                      }, () =>
                        ve.createElement(
                          "div",
                          {
                            class: ve.const(
                              "dcg-braille-options-container",
                            ),
                          },
                          ve.createElement(Gh, {
                            controller: this.props.controller,
                            showBrailleNote: this.const(true),
                          }),
                        )),
                    )),
                ),
                ve.createElement(
                  "div",
                  {
                    class: ve.const(
                      "dcg-top-section-flex dcg-grid-settings-container",
                    ),
                  },
                  ve.createElement(
                    "div",
                    { class: ve.const("dcg-grid-settings") },
                    ve.createElement(mt, {
                      class: this.const("dcg-settings-grid-toggle"),
                      onChange: this.bindFn(this.toggleGrid),
                      checked: this.bindFn(this.getShowGrid),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-label-settings-grid",
                      )),
                    ve.createElement(wl, {
                      predicate: this.bindFn(this.getShowGrid),
                    }, () =>
                      ve.createElement(
                        "div",
                        {
                          class: ve.const(
                            "dcg-circle-icon-group dcg-grid-group",
                          ),
                        },
                        ve.createElement(
                          "div",
                          {
                            class: () => ({
                              "dcg-circle-icon": true,
                              "dcg-action-cartesian": true,
                              "dcg-selected": !this.getPolarMode(),
                            }),
                            role: ve.const("button"),
                            tabIndex: ve.const("0"),
                            "aria-pressed": () => !this.getPolarMode(),
                            "aria-label": () =>
                              this.controller.s(
                                "graphing-calculator-narration-settings-cartesian-grid",
                              ),
                            onTap: this.bindFn(this.setCartesianMode),
                          },
                          ve.createElement("i", {
                            class: ve.const("dcg-icon-cartesian"),
                          }),
                        ),
                        ve.const("\xA0"),
                        ve.createElement(
                          "div",
                          {
                            class: () => ({
                              "dcg-circle-icon": true,
                              "dcg-action-polar": true,
                              "dcg-selected": this.getPolarMode(),
                            }),
                            role: ve.const("button"),
                            tabIndex: ve.const("0"),
                            "aria-pressed": () => this.getPolarMode(),
                            "aria-label": () =>
                              this.controller.s(
                                "graphing-calculator-narration-settings-polar-grid",
                              ),
                            onTap: this.bindFn(this.setPolarMode),
                          },
                          ve.createElement("i", {
                            class: ve.const("dcg-icon-polar"),
                          }),
                        ),
                      )),
                    ve.createElement(mt, {
                      onChange: this.bindFn(this.toggleArrows),
                      checked: () => this.getAxisArrowMode() !== "NONE",
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-label-settings-arrows",
                      )),
                    ve.createElement(wl, {
                      predicate: () => this.getAxisArrowMode() !== "NONE",
                    }, () =>
                      ve.createElement(
                        "div",
                        {
                          class: ve.const(
                            "dcg-circle-icon-group dcg-arrow-group",
                          ),
                        },
                        ve.createElement(
                          "div",
                          {
                            role: ve.const("button"),
                            tabIndex: ve.const("0"),
                            class: () => ({
                              "dcg-circle-icon": true,
                              "dcg-arrows": true,
                              "dcg-selected":
                                this.getAxisArrowMode() === "BOTH",
                            }),
                            "dcg-arrows": ve.const("BOTH"),
                            "aria-label": () =>
                              this.controller.s(
                                "graphing-calculator-narration-settings-show-both",
                              ),
                            "aria-pressed": () =>
                              this.getAxisArrowMode() === "BOTH",
                            onTap: () => this.setAxisArrowMode("BOTH"),
                          },
                          ve.createElement("i", {
                            class: ve.const("dcg-icon-arrows-two"),
                            "aria-hidden": ve.const("true"),
                          }),
                        ),
                        ve.const("\xA0"),
                        ve.createElement(
                          "div",
                          {
                            role: ve.const("button"),
                            tabIndex: ve.const("0"),
                            class: () => ({
                              "dcg-circle-icon": true,
                              "dcg-arrows": true,
                              "dcg-selected":
                                this.getAxisArrowMode() === "POSITIVE",
                            }),
                            "dcg-arrows": ve.const("POSITIVE"),
                            "aria-label": () =>
                              this.controller.s(
                                "graphing-calculator-narration-settings-show-positive",
                              ),
                            "aria-pressed": () =>
                              this.getAxisArrowMode() === "POSITIVE",
                            onTap: () => this.setAxisArrowMode("POSITIVE"),
                          },
                          ve.createElement("i", {
                            class: ve.const("dcg-icon-arrows-one"),
                            "aria-hidden": ve.const("true"),
                          }),
                        ),
                      )),
                  ),
                  ve.createElement(
                    "div",
                    { class: ve.const("dcg-top-checkboxes-container") },
                    ve.createElement(mt, {
                      onChange: this.bindFn(this.toggleAxisNumbers),
                      checked: this.bindFn(this.getAxisNumbers),
                      small: this.const(true),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-label-settings-axis-numbers",
                      )),
                    ve.createElement(wl, {
                      predicate: () =>
                        this.getShowGrid() && !this.getPolarMode(),
                    }, () =>
                      ve.createElement(mt, {
                        onChange: this.bindFn(this.toggleMinorGridlines),
                        checked: this.bindFn(this.getMinorGridlines),
                        small: this.const(true),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-label-settings-minor-gridlines",
                        ))),
                    ve.createElement(wl, {
                      predicate: () =>
                        this.controller.canUseAdvancedStyling() &&
                        !this.getPolarMode(),
                    }, () =>
                      ve.createElement(mt, {
                        checked: () =>
                          this.controller.getGraphSettings()
                            .restrictGridToFirstQuadrant,
                        onChange: (e) =>
                          this.controller.dispatch({
                            type: "set-graph-settings",
                            restrictGridToFirstQuadrant: e,
                          }),
                        small: this.const(true),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-label-settings-one-quadrant",
                        ))),
                    ve.createElement(wl, {
                      predicate: this.bindFn(this.showZoomSquareButton),
                    }, () =>
                      ve.createElement("div", {
                        role: ve.const("button"),
                        tabIndex: ve.const("0"),
                        class: ve.const(
                          "dcg-action-zoom-square dcg-btn-light-gray",
                        ),
                        onTap: this.bindFn(this.zoomSquare),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-button-settings-zoom-square",
                        ))),
                  ),
                ),
                ve.createElement(
                  "div",
                  { class: ve.const("dcg-axes-settings-container") },
                  ve.createElement(
                    "div",
                    {
                      class: ve.const(
                        "dcg-checkbox-title dcg-x-axis-title",
                      ),
                    },
                    ve.createElement(
                      mt,
                      {
                        onChange: this.bindFn(this.toggleXAxis),
                        checked: this.bindFn(this.getShowXAxis),
                      },
                      ve.createElement("span", {
                        id: this.const(`x-axis-description-${this.uuid}`),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-label-settings-x-axis",
                        )),
                    ),
                    ve.createElement(wl, {
                      predicate: this.bindFn(this.getShowXAxis),
                    }, () =>
                      ve.createElement(
                        "div",
                        { class: ve.const("dcg-axis-label") },
                        ve.createElement("label", {
                          for: this.const(`x-axis-label-${this.uuid}`),
                        }, () =>
                          this.controller.s(
                            "graphing-calculator-button-label",
                          )),
                        ve.createElement(H9, {
                          class: this.const("dcg-x-axis-label"),
                          disabled: () => this.getShowXAxis() ? void 0 : true,
                          onInput: this.bindFn(this.onXAxisLabelInput),
                          value: this.bindFn(this.getXAxisLabel),
                          "aria-describedby": this.const(
                            `x-axis-description-${this.uuid}`,
                          ),
                          id: this.const(`x-axis-label-${this.uuid}`),
                          placeholder: () =>
                            this.controller.s(
                              "graphing-calculator-narration-settings-x-axis-label-placeholder",
                            ),
                        }),
                      )),
                  ),
                  ve.createElement(
                    "div",
                    {
                      class: ve.const(
                        "dcg-editable-mathquill-container dcg-x-axis-options",
                      ),
                    },
                    ve.createElement(Ph, {
                      limit: this.const("xmin"),
                      axisScale: () => this.getAxisScale("x"),
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-settings-x-axis-min",
                        ),
                      needsSystemKeypad: () =>
                        !this.controller.isKeypadEnabled(),
                      parent: this.const(this),
                      controller: this.props.controller,
                    }),
                    ve.createElement(
                      nt,
                      {
                        config: this.const({}),
                        latex: this.const("\\le x\\le"),
                      },
                      ve.createElement("span", {
                        class: ve.const("dcg-interval-interior"),
                      }),
                    ),
                    ve.createElement(Ph, {
                      limit: this.const("xmax"),
                      axisScale: () => this.getAxisScale("x"),
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-settings-x-axis-max",
                        ),
                      needsSystemKeypad: () =>
                        !this.controller.isKeypadEnabled(),
                      parent: this.const(this),
                      controller: this.props.controller,
                    }),
                    ve.createElement(wl, {
                      predicate: () => !this.getPolarMode(),
                    }, () =>
                      K9(() => this.getAxisScale("x") === "linear", {
                        true: () =>
                          ve.createElement(
                            "span",
                            { class: ve.const("dcg-step-container") },
                            ve.createElement("span", {
                              class: ve.const("dcg-step-label"),
                              "aria-hidden": ve.const("true"),
                            }, () =>
                              this.controller.s(
                                "graphing-calculator-label-settings-step",
                              )),
                            ve.createElement(Ph, {
                              limit: this.const("xstep"),
                              axisScale: this.const("linear"),
                              ariaLabel: () =>
                                this.controller.s(
                                  "graphing-calculator-narration-settings-x-axis-step",
                                ),
                              needsSystemKeypad: () =>
                                !this.controller.isKeypadEnabled(),
                              parent: this.const(this),
                              controller: this.props.controller,
                            }),
                          ),
                        false: () =>
                          ve.createElement("span", {
                            style: ve.const("display: none"),
                          }),
                      })),
                  ),
                  ve.createElement(
                    "div",
                    {
                      class: ve.const(
                        "dcg-checkbox-title dcg-y-axis-title",
                      ),
                    },
                    ve.createElement(
                      mt,
                      {
                        onChange: this.bindFn(this.toggleYAxis),
                        checked: this.bindFn(this.getShowYAxis),
                      },
                      ve.createElement("span", {
                        id: this.const(`y-axis-description-${this.uuid}`),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-label-settings-y-axis",
                        )),
                    ),
                    ve.createElement(wl, {
                      predicate: this.bindFn(this.getShowYAxis),
                    }, () =>
                      ve.createElement(
                        "div",
                        { class: ve.const("dcg-axis-label") },
                        ve.createElement("label", {
                          for: this.const(`y-axis-label-${this.uuid}`),
                        }, () =>
                          this.controller.s(
                            "graphing-calculator-button-label",
                          )),
                        ve.createElement(H9, {
                          class: this.const("dcg-y-axis-label"),
                          onInput: this.bindFn(this.onYAxisLabelInput),
                          value: this.bindFn(this.getYAxisLabel),
                          "aria-describedby": this.const(
                            `y-axis-description-${this.uuid}`,
                          ),
                          id: this.const(`y-axis-label-${this.uuid}`),
                          placeholder: () =>
                            this.controller.s(
                              "graphing-calculator-narration-settings-y-axis-label-placeholder",
                            ),
                        }),
                      )),
                  ),
                  ve.createElement(
                    "div",
                    {
                      class: ve.const(
                        "dcg-editable-mathquill-container dcg-y-axis-options",
                      ),
                    },
                    ve.createElement(Ph, {
                      limit: this.const("ymin"),
                      axisScale: () => this.getAxisScale("y"),
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-settings-y-axis-min",
                        ),
                      needsSystemKeypad: () =>
                        !this.controller.isKeypadEnabled(),
                      parent: this.const(this),
                      controller: this.props.controller,
                    }),
                    ve.createElement(
                      nt,
                      {
                        config: this.const({}),
                        latex: this.const("\\le y\\le"),
                      },
                      ve.createElement("span", {
                        class: ve.const("dcg-interval-interior"),
                      }),
                    ),
                    ve.createElement(Ph, {
                      limit: this.const("ymax"),
                      axisScale: () => this.getAxisScale("y"),
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-settings-y-axis-max",
                        ),
                      needsSystemKeypad: () =>
                        !this.controller.isKeypadEnabled(),
                      parent: this.const(this),
                      controller: this.props.controller,
                    }),
                    ve.createElement(wl, {
                      predicate: () => !this.getPolarMode(),
                    }, () =>
                      K9(() => this.getAxisScale("y") === "linear", {
                        true: () =>
                          ve.createElement(
                            "span",
                            { class: ve.const("dcg-step-container") },
                            ve.createElement("span", {
                              class: ve.const("dcg-step-label"),
                              "aria-hidden": ve.const("true"),
                            }, () =>
                              this.controller.s(
                                "graphing-calculator-label-settings-step",
                              )),
                            ve.createElement(Ph, {
                              limit: this.const("ystep"),
                              axisScale: this.const("linear"),
                              ariaLabel: () =>
                                this.controller.s(
                                  "graphing-calculator-narration-settings-y-axis-step",
                                ),
                              needsSystemKeypad: () =>
                                !this.controller.isKeypadEnabled(),
                              parent: this.const(this),
                              controller: this.props.controller,
                            }),
                          ),
                        false: () =>
                          ve.createElement("span", {
                            style: ve.const("display: none"),
                          }),
                      })),
                  ),
                ),
                ve.createElement(wI, {
                  controller: this.props.controller,
                }),
                ve.createElement(wl, {
                  predicate: () => this.controller.canEnableComplexMode(),
                }, () =>
                  ve.createElement(Lh, {
                    ...this.props,
                    isComplexModeEnabled: () =>
                      this.controller.isComplexModeEnabled(),
                    toggleComplexMode: () =>
                      this.controller.dispatch({
                        type: "toggle-complex-mode",
                      }),
                    product: () => this.controller.getProduct(),
                  })),
                ve.createElement(rc, {
                  setup: this.const({
                    controller: this.controller,
                    type: "advanced",
                  }),
                }),
                ve.createElement("div", { class: ve.const("dcg-arrow") }),
              ),
            )),
        );
      }
      toggleBrailleMode() {
        this.controller.dispatch({
          type: "set-braille-mode",
          mode: this.controller.getBrailleMode() === "none" ? "nemeth" : "none",
        });
      }
      didMountContainer(e) {
        this.node = e,
          ee(document.documentElement).on(
            "dcg-tapstart.settings-view wheel.settings-view",
            (t) => {
              this.eventShouldClosePopover(t) &&
                this.controller.dispatch({
                  type: "close-graph-settings",
                  focusIconAfterClose: t.device === "keyboard",
                });
            },
          ),
          ee(document.documentElement).on(
            "keydown.settings-view",
            (t) => {
              let o = ke(t);
              if (
                o === "Esc" &&
                this.controller.dispatch({
                  type: "close-graph-settings",
                  focusIconAfterClose: true,
                }),
                  this.controller.isGraphSettingsOpen() && o === "Tab" &&
                  !t.altKey && !t.metaKey && !t.ctrlKey
              ) {
                let i = this.controller.getFocusLocation();
                if (!i || i.type !== "settings") return;
                let n = !!this.controller.getGraphSettings().config
                    .projectorMode,
                  a = !!this.controller.getGraphSettings().degreeMode;
                t.shiftKey
                  ? t.shiftKey &&
                    (n && i.location === "large-size" ||
                        !n && i.location === "default-size"
                      ? (this.controller.dispatch({
                        type: "set-focus-location",
                        location: { type: "settings", location: "icon" },
                      }),
                        t.preventDefault(),
                        t.stopPropagation())
                      : i.location === "icon" &&
                        (this.controller.dispatch({
                          type: "set-focus-location",
                          location: {
                            type: "settings",
                            location: a ? "degree-mode" : "radian-mode",
                          },
                        }),
                          t.preventDefault(),
                          t.stopPropagation()))
                  : i.location === "icon"
                  ? (this.controller.dispatch({
                    type: "set-focus-location",
                    location: {
                      type: "settings",
                      location: n ? "large-size" : "default-size",
                    },
                  }),
                    t.preventDefault(),
                    t.stopPropagation())
                  : (!a && i.location === "radian-mode" ||
                    a && i.location === "degree-mode") &&
                    (this.controller.dispatch({
                      type: "set-focus-location",
                      location: { type: "settings", location: "icon" },
                    }),
                      t.preventDefault(),
                      t.stopPropagation());
              }
            },
          );
      }
      didUnmountContainer() {
        ee(document.documentElement).off(".settings-view");
      }
      didUpdate() {
        if (!this.controller.isGraphSettingsOpen()) return;
        let e = this.controller.getKeypadHeight();
        e !== this.cachedKeypadHeight && document.activeElement &&
        this.node.contains(document.activeElement) &&
        tc(
          document.activeElement,
          this.node.querySelector(".dcg-popover-interior"),
          50,
        ), this.cachedKeypadHeight = e;
      }
      eventShouldClosePopover(e) {
        let t = e.target,
          o = this.node.contains(t),
          i = !!t.closest(".dcg-action-settings"),
          n = this.isMathquillFocused() && !!t.closest(".dcg-keypad"),
          a = !!t.closest(".dcg-action-undo") ||
            !!t.closest(".dcg-action-redo");
        return !(o || i || n || a);
      }
      isMathquillFocused() {
        return this.getFocusedLimit() !== void 0;
      }
      getLimitLatex(e) {
        return this.controller.getSettingsViewModel().limitLatex[e] || "";
      }
      setLimitLatex(e, t) {
        t !== this.controller.getSettingsViewModel().limitLatex[e] &&
          this.controller.dispatch({
            type: "set-axis-limit-latex",
            limit: e,
            latex: t,
          });
      }
      getFocusedLimit() {
        let e = this.controller.getFocusLocation();
        if (e && e.type === "settings") return e.location;
      }
      getInvalidLimits() {
        let e = !!this.controller.getGraphSettings().degreeMode,
          t = io(this.getLimitLatex("xmin"), e),
          o = io(this.getLimitLatex("xmax"), e),
          i = io(this.getLimitLatex("ymin"), e),
          n = io(this.getLimitLatex("ymax"), e),
          a = this.getLimitLatex("xstep") === ""
            ? 0
            : io(this.getLimitLatex("xstep"), e),
          s = this.getLimitLatex("ystep") === ""
            ? 0
            : io(this.getLimitLatex("ystep"), e),
          l = {},
          c = new Br(t, o, i, n);
        return isFinite(t) && isFinite(o)
          ? (l.xmin = !c.isXValid(
            this.controller.getGraphSettings().xAxisScale,
          ),
            l.xmax = l.xmin)
          : (l.xmin = !isFinite(t), l.xmax = !isFinite(o)),
          isFinite(i) && isFinite(n)
            ? (l.ymin = !c.isYValid(
              this.controller.getGraphSettings().yAxisScale,
            ),
              l.ymax = l.ymin)
            : (l.ymin = !isFinite(i), l.ymax = !isFinite(n)),
          l.xstep = !ay(a),
          l.ystep = !ay(s),
          l;
      }
      isLimitInvalid(e) {
        return this.getInvalidLimits()[e];
      }
      onFocusedChanged(e, t) {
        t
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "settings", location: e },
          })
          : this.controller.dispatch({
            type: "blur-focus-location",
            location: { type: "settings", location: e },
          });
      }
      onXAxisLabelInput(e) {
        this.controller.dispatch({
          type: "set-graph-settings",
          xAxisLabel: e,
        });
      }
      onYAxisLabelInput(e) {
        this.controller.dispatch({
          type: "set-graph-settings",
          yAxisLabel: e,
        });
      }
      getXAxisLabel() {
        return this.controller.getGraphSettings().xAxisLabel;
      }
      getYAxisLabel() {
        return this.controller.getGraphSettings().yAxisLabel;
      }
      getShowXAxis() {
        return !!this.controller.getGraphSettings().showXAxis;
      }
      toggleXAxis() {
        this.controller.dispatch({
          type: "set-graph-settings",
          showXAxis: !this.getShowXAxis(),
        });
      }
      getShowYAxis() {
        return !!this.controller.getGraphSettings().showYAxis;
      }
      toggleYAxis() {
        this.controller.dispatch({
          type: "set-graph-settings",
          showYAxis: !this.getShowYAxis(),
        });
      }
      getAxisNumbers() {
        return !!this.controller.getGraphSettings().xAxisNumbers;
      }
      toggleAxisNumbers() {
        let e = this.getAxisNumbers();
        this.controller.dispatch({
          type: "set-graph-settings",
          xAxisNumbers: !e,
          yAxisNumbers: !e,
          polarNumbers: !e,
        });
      }
      getMinorGridlines() {
        return this.controller.getGraphSettings()
          .xAxisMinorSubdivisions === 0;
      }
      toggleMinorGridlines() {
        let e = this.getMinorGridlines() ? 1 : 0;
        this.controller.dispatch({
          type: "set-graph-settings",
          yAxisMinorSubdivisions: e,
          xAxisMinorSubdivisions: e,
        });
      }
      getPolarMode() {
        return !!this.controller.getGraphSettings().polarMode;
      }
      setPolarMode() {
        this.controller.dispatch({
          type: "set-polar-mode",
          polarMode: true,
        });
      }
      setCartesianMode() {
        this.controller.dispatch({
          type: "set-polar-mode",
          polarMode: false,
        });
      }
      getAxisScale(e) {
        return this.controller
          .getGraphSettings()[e === "x" ? "xAxisScale" : "yAxisScale"];
      }
      getAxisArrowMode() {
        return this.controller.getGraphSettings().xAxisArrowMode;
      }
      setAxisArrowMode(e) {
        this.controller.dispatch({
          type: "set-graph-settings",
          xAxisArrowMode: e,
          yAxisArrowMode: e,
        });
      }
      getShowGrid() {
        return this.controller.getGraphSettings().showGrid;
      }
      toggleGrid() {
        this.controller.dispatch({
          type: "set-graph-settings",
          showGrid: !this.getShowGrid(),
        });
      }
      toggleArrows() {
        let e = this.getAxisArrowMode() === "NONE" ? "BOTH" : "NONE";
        this.controller.dispatch({
          type: "set-graph-settings",
          xAxisArrowMode: e,
          yAxisArrowMode: e,
        });
      }
      showZoomSquareButton() {
        let e = this.controller.getAxisScaleSettings();
        return e.xAxisScale === e.yAxisScale &&
          !this.controller.getGraphSettings().squareAxes;
      }
      getContainerStyle() {
        return this.controller.getKeypadHeight() ? "bottom: 0" : "";
      }
      zoomSquare() {
        this.controller.dispatch({ type: "zoom", direction: "square" });
      }
    };
  var Tr = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var Ra = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: W9 } = Ra.Components,
    Jy = class extends Ra.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Ra.createElement(
          W9,
          { predicate: this.bindFn(this.shouldShowBrailleSection) },
          () =>
            Ra.createElement(
              "div",
              { class: Ra.const("dcg-options-menu-section") },
              Ra.createElement(
                "div",
                { class: Ra.const("dcg-options-menu-section-title") },
                () =>
                  this.controller.s(
                    "shared-calculator-narration-braille-mode",
                  ),
                Ra.createElement(go, {
                  ariaLabel: () =>
                    this.controller.s(
                      "shared-calculator-narration-braille-mode",
                    ),
                  onChange: this.bindFn(this.toggleBrailleMode),
                  toggled: () => this.controller.getBrailleMode() !== "none",
                }),
              ),
              Ra.createElement(
                W9,
                {
                  predicate: () => this.controller.getBrailleMode() !== "none",
                },
                () =>
                  Ra.createElement(
                    "div",
                    { class: Ra.const("dcg-braille-options-container") },
                    Ra.createElement(Gh, {
                      controller: this.props.controller,
                      showBrailleNote: this.const(true),
                    }),
                  ),
              ),
            ),
        );
      }
      shouldShowBrailleSection() {
        return this.controller.getBrailleControls() &&
          this.controller.getGraphSettings().config.expressions;
      }
      toggleBrailleMode() {
        this.controller.dispatch({
          type: "set-braille-mode",
          mode: this.controller.getBrailleMode() === "none" ? "nemeth" : "none",
        });
      }
    };
  var Uo = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: $9 } = Uo.Components,
    BO = 0,
    f0 = tI / 8,
    CI = class extends Uo.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Uo.createElement(
          "div",
          { class: Uo.const("dcg-options-menu-section") },
          Uo.createElement(
            "div",
            {
              class: Uo.const(
                "dcg-options-menu-section-title dcg-local-display-preferences-title",
              ),
            },
            () =>
              this.controller.s(
                "graphing-calculator-label-display-properties",
              ),
            Uo.createElement(Md, {
              href: this.const(
                "https://help.desmos.com/hc/en-us/articles/20301369699981-3D-Graph-Settings#h_01HCFSXHM8S59ETFXB55Y8CZQ5\u2019",
              ),
              controller: this.props.controller,
            }),
          ),
          Uo.createElement(mt, {
            onChange: this.bindFn(this.toggleInvertedColors),
            checked: () => this.controller.getInvertedColors(),
            manageFocus: this.const(
              rt({
                controller: this.controller,
                location: {
                  type: "settings",
                  location: "reverse-contrast",
                },
              }),
            ),
          }, () =>
            this.controller.s(
              "graphing-calculator-label-settings-reverse-contrast",
            )),
          Uo.createElement($9, {
            predicate: () => this.controller.getGraphSettings().config.beta3d,
          }, () =>
            Uo.createElement(mt, {
              onChange: () => {
                this.controller.dispatch({
                  type: "set-graph-settings",
                  showBox3D: !this.controller.getGraphSettings()
                    .showBox3D,
                });
              },
              checked: () => this.controller.getGraphSettings().showBox3D,
            }, () => this.controller.raw("Clip to box"))),
          Uo.createElement($9, {
            predicate: () => !this.controller.getGraphSettings().config.beta3d,
          }, () =>
            Uo.createElement(mt, {
              class: () => "dcg-translucent-surfaces-checkbox",
              onChange: this.bindFn(this.toggleTranslucentSurfaces),
              checked: () => this.controller.getTranslucentSurfaces(),
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-label-settings-translucent-surfaces",
                ),
              manageFocus: this.const(
                rt({
                  controller: this.controller,
                  location: {
                    type: "settings",
                    location: "translucent-surfaces",
                  },
                }),
              ),
            }, () =>
              this.controller.s(
                "graphing-calculator-label-settings-translucent-surfaces",
              ))),
          Uo.createElement(
            "div",
            { class: Uo.const("dcg-perspective-slider") },
            Uo.createElement(
              Le,
              {
                tooltip: () =>
                  this.controller.s(
                    "graphing-calculator-label-settings-3d-perspective-min",
                  ),
              },
              Uo.createElement("i", {
                class: Uo.const("dcg-icon-3d-cube"),
                "aria-hidden": Uo.const("true"),
              }),
            ),
            Uo.createElement(Kg, {
              min: () => BO - 1,
              max: () => f0 - 1,
              step: () => {},
              value: () => this.getPerspectiveValue(),
              ariaLabel: () =>
                this.controller.s(
                  "graphing-calculator-label-settings-3d-perspective-distortion-ratio",
                ),
              ariaPercent: this.const(true),
              onDragUpdate: this.bindFn(this.onDragUpdate),
              onKeyboardUpdate: this.bindFn(this.onKeyboardUpdate),
            }),
            Uo.createElement(
              Le,
              {
                tooltip: () =>
                  this.controller.s(
                    "graphing-calculator-label-settings-3d-perspective-max",
                  ),
              },
              Uo.createElement("i", {
                class: Uo.const("dcg-icon-3d-perspective"),
                "aria-hidden": Uo.const("true"),
              }),
            ),
          ),
        );
      }
      toggleTranslucentSurfaces() {
        this.controller.dispatch({
          type: "set-translucent-surfaces",
          value: !this.controller.getTranslucentSurfaces(),
        });
      }
      toggleInvertedColors() {
        this.controller.dispatch({
          type: "set-inverted-colors",
          value: !this.controller.getInvertedColors(),
        });
      }
      getPerspectiveValue() {
        return this.controller.getPerspectiveDistortion() - 1;
      }
      onKeyboardUpdate(e) {
        let o = this.getPerspectiveValue();
        switch (e) {
          case "up":
            o += .1;
            break;
          case "down":
            o -= .1;
            break;
          case "bigup":
            o += .3;
            break;
          case "bigdown":
            o -= .3;
            break;
          case "min":
            o = BO - 1;
            break;
          case "max":
            o = f0 - 1;
            break;
        }
        o = __dcg_shared_module_exports__["clamp"](o + 1, BO, f0),
          this.controller.dispatch({
            type: "set-perspective-distortion",
            value: o,
          });
      }
      onDragUpdate(e) {
        this.controller.dispatch({
          type: "set-perspective-distortion",
          value: e + 1,
        });
      }
    };
  var et = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: Vh } = et.Components,
    Oh = class extends et.Class {
      template() {
        return et.createElement(lr, {
          isFocused: () =>
            this.props.parent().getFocusedLimit() === this.props.limit(),
          latex: () => this.props.parent().getLimitLatex(this.props.limit()),
          ariaLabel: this.props.ariaLabel,
          handleLatexChanged: (e) =>
            this.props.parent().setLimitLatex(this.props.limit(), e),
          handleFocusChanged: (e) =>
            this.props.parent().onFocusedChanged(this.props.limit(), e),
          hasError: () =>
            this.props.parent().isLimitInvalid(this.props.limit()),
          dataLabelAttributeValue: this.props.limit,
          controller: this.props.controller,
          readonly: this.const(false),
        });
      }
    },
    SI = class extends et.Class {
      init() {
        this.controller = this.props.controller(),
          this.isOpen = this.mustBeOpen();
      }
      willUpdate() {
        this.mustBeOpen() && (this.isOpen = true);
      }
      mustBeOpen() {
        var t;
        let e = (t = this.controller.getGrapher3d()) == null
          ? void 0
          : t.viewportController.getViewport();
        return e
          ? e.xmin !== e.ymin || e.xmin !== e.zmin || e.xmax !== e.ymax ||
            e.xmax !== e.zmax
          : false;
      }
      template() {
        return et.createElement(
          "div",
          {
            class: et.const(
              "dcg-three-d-domain dcg-advanced-graph-settings-view dcg-options-menu-section",
            ),
          },
          et.createElement(
            "div",
            {
              class: et.const(
                "dcg-options-menu-section-title dcg-flex-container",
              ),
            },
            et.createElement(
              "div",
              null,
              () =>
                this.controller.s(
                  "graphing-calculator-label-edit-graph-bounds",
                ),
            ),
            et.createElement(
              "div",
              null,
              et.createElement(Vh, {
                predicate: this.bindFn(this.showRecenterButton),
              }, () =>
                et.createElement("div", {
                  role: et.const("button"),
                  tabIndex: et.const("0"),
                  class: et.const(
                    "dcg-action-zoom-recenter dcg-btn-light-gray",
                  ),
                  onTap: this.bindFn(this.zoomRecenter),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-label-recenter",
                  ))),
            ),
          ),
          et.createElement(
            "div",
            { class: et.const("dcg-three-d-domain-toggle-container") },
            et.createElement(
              "div",
              {
                class: () => ({
                  "dcg-advanced-toggle": true,
                  "dcg-opened": this.isOpen,
                  "dcg-disabled": this.mustBeOpen(),
                }),
                onTap: this.bindFn(this.toggleOpen),
                tabIndex: () => this.mustBeOpen() ? -1 : 0,
                "aria-disabled": () => this.mustBeOpen(),
                role: et.const("button"),
                "aria-expanded": () => this.isOpen,
                "aria-label": () =>
                  this.controller.s(
                    "graphing-calculator-label-edit-graph-bounds",
                  ),
              },
              et.createElement(
                "div",
                { class: et.const("dcg-caret-container") },
                et.createElement("i", {
                  class: et.const("dcg-icon-caret-down"),
                  "aria-hidden": et.const("true"),
                }),
              ),
              et.createElement(
                Vh,
                { predicate: () => this.isOpen },
                () =>
                  et.createElement(
                    "span",
                    { class: et.const("dcg-axis-label") },
                    et.createElement(nt, {
                      config: this.const({}),
                      latex: this.const("x"),
                    }),
                    et.const("-axis:"),
                  ),
              ),
              et.createElement(
                Vh,
                { predicate: () => !this.isOpen },
                () =>
                  et.createElement("span", {
                    class: et.const("dcg-axis-label"),
                  }, () =>
                    this.controller.s(
                      "graphing-calculator-label-settings-all-axes",
                    )),
              ),
            ),
            et.createElement(
              "div",
              {
                class: et.const(
                  "dcg-editable-mathquill-container dcg-x-axis-options",
                ),
              },
              et.createElement(Oh, {
                limit: this.const("xmin"),
                ariaLabel: () =>
                  this.isOpen
                    ? this.controller.s(
                      "graphing-calculator-narration-settings-x-axis-min",
                    )
                    : this.controller.s(
                      "graphing-calculator-narration-settings-all-axes-min",
                    ),
                needsSystemKeypad: () => !this.controller.isKeypadEnabled(),
                parent: this.const(this),
                controller: this.props.controller,
              }),
              et.createElement(
                Vh,
                { predicate: () => this.isOpen },
                () =>
                  et.createElement(
                    nt,
                    {
                      config: this.const({}),
                      latex: this.const("\\le x\\le"),
                    },
                    et.createElement("span", {
                      class: et.const("dcg-interval-interior"),
                    }),
                  ),
              ),
              et.createElement(
                Vh,
                { predicate: () => !this.isOpen },
                () =>
                  et.createElement("span", {
                    class: et.const("dcg-axis-label-to"),
                  }, () => this.controller.s("shared-label-to")),
              ),
              et.createElement(Oh, {
                limit: this.const("xmax"),
                ariaLabel: () =>
                  this.isOpen
                    ? this.controller.s(
                      "graphing-calculator-narration-settings-x-axis-max",
                    )
                    : this.controller.s(
                      "graphing-calculator-narration-settings-all-axes-max",
                    ),
                needsSystemKeypad: () => !this.controller.isKeypadEnabled(),
                parent: this.const(this),
                controller: this.props.controller,
              }),
            ),
          ),
          et.createElement(
            Vh,
            { predicate: () => this.isOpen },
            () =>
              et.createElement(
                "div",
                { class: et.const("dcg-advanced-contents") },
                et.createElement(
                  "div",
                  {
                    class: et.const(
                      "dcg-editable-mathquill-container dcg-y-axis-options",
                    ),
                  },
                  et.createElement(
                    "span",
                    { class: et.const("dcg-axis-label") },
                    et.createElement(nt, {
                      config: this.const({}),
                      latex: this.const("y"),
                    }),
                    et.const("-axis:"),
                  ),
                  et.createElement(Oh, {
                    limit: this.const("ymin"),
                    ariaLabel: () =>
                      this.controller.s(
                        "graphing-calculator-narration-settings-y-axis-min",
                      ),
                    needsSystemKeypad: () => !this.controller.isKeypadEnabled(),
                    parent: this.const(this),
                    controller: this.props.controller,
                  }),
                  et.createElement(
                    nt,
                    {
                      config: this.const({}),
                      latex: this.const("\\le y\\le"),
                    },
                    et.createElement("span", {
                      class: et.const("dcg-interval-interior"),
                    }),
                  ),
                  et.createElement(Oh, {
                    limit: this.const("ymax"),
                    ariaLabel: () =>
                      this.controller.s(
                        "graphing-calculator-narration-settings-y-axis-max",
                      ),
                    needsSystemKeypad: () => !this.controller.isKeypadEnabled(),
                    parent: this.const(this),
                    controller: this.props.controller,
                  }),
                ),
                et.createElement(
                  "div",
                  null,
                  et.createElement(
                    "div",
                    {
                      class: et.const(
                        "dcg-editable-mathquill-container dcg-z-axis-options",
                      ),
                    },
                    et.createElement(
                      "span",
                      { class: et.const("dcg-axis-label") },
                      et.createElement(nt, {
                        config: this.const({}),
                        latex: this.const("z"),
                      }),
                      et.const("-axis:"),
                    ),
                    et.createElement(Oh, {
                      limit: this.const("zmin"),
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-settings-z-axis-min",
                        ),
                      needsSystemKeypad: () =>
                        !this.controller.isKeypadEnabled(),
                      parent: this.const(this),
                      controller: this.props.controller,
                    }),
                    et.createElement(
                      nt,
                      {
                        config: this.const({}),
                        latex: this.const("\\le z\\le"),
                      },
                      et.createElement("span", {
                        class: et.const("dcg-interval-interior"),
                      }),
                    ),
                    et.createElement(Oh, {
                      limit: this.const("zmax"),
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-settings-z-axis-max",
                        ),
                      needsSystemKeypad: () =>
                        !this.controller.isKeypadEnabled(),
                      parent: this.const(this),
                      controller: this.props.controller,
                    }),
                  ),
                ),
                et.createElement(Vh, {
                  predicate: this.bindFn(this.showZoomSquareButton),
                }, () =>
                  et.createElement(
                    "div",
                    null,
                    et.createElement("div", {
                      role: et.const("button"),
                      tabIndex: et.const("0"),
                      class: et.const(
                        "dcg-action-zoom-square-3d dcg-btn-blue",
                      ),
                      onTap: this.bindFn(this.zoomSquare),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-button-settings-zoom-square",
                      )),
                  )),
              ),
          ),
          et.createElement(Vh, {
            predicate: () => !this.controller.getLockViewportConfigSetting(),
          }, () =>
            et.createElement(mt, {
              ariaLabel: () =>
                this.props.controller().s(
                  "graphing-calculator-label-disable-zoom",
                ),
              onChange: () => {
                this.props.controller().dispatch({
                  type: "toggle-lock-viewport",
                });
              },
              checked: () =>
                this.props.controller().getLockViewportUserSetting(),
            }, () =>
              this.props.controller().s(
                "graphing-calculator-label-disable-zoom",
              ))),
        );
      }
      showRecenterButton() {
        var t;
        let e = (t = this.controller.getGrapher3d()) == null
          ? void 0
          : t.webglLayer.domain();
        return !!e && !G7(e, 0);
      }
      zoomRecenter(e) {
        this.controller.dispatch({ type: "zoom", direction: "recenter" }),
          e.device === "keyboard" &&
          this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "settings", location: "xmin" },
          });
      }
      getFocusedLimit() {
        let e = this.controller.getFocusLocation();
        if (e && e.type === "settings") return e.location;
      }
      getLimitLatex(e) {
        return this.controller.getSettingsViewModel().limitLatex[e] || "";
      }
      setLimitLatex(e, t) {
        t !== this.controller.getSettingsViewModel().limitLatex[e] &&
          this.controller.dispatch({
            type: "set-axis-limit-latex",
            limit: e,
            latex: t,
            updateYZAlso: !this.isOpen && (e === "xmin" || e === "xmax"),
          });
      }
      getInvalidLimits() {
        let e = !!this.controller.getGraphSettings().degreeMode,
          t = io(this.getLimitLatex("xmin"), e),
          o = io(this.getLimitLatex("xmax"), e),
          i = io(this.getLimitLatex("ymin"), e),
          n = io(this.getLimitLatex("ymax"), e),
          a = io(this.getLimitLatex("zmin"), e),
          s = io(this.getLimitLatex("zmax"), e),
          l = {},
          c = new Br(t, o, i, n, a, s);
        return isFinite(t) && isFinite(o)
          ? (l.xmin = !c.isXValid(
            this.controller.getGraphSettings().xAxisScale,
          ),
            l.xmax = l.xmin)
          : (l.xmin = !isFinite(t), l.xmax = !isFinite(o)),
          isFinite(i) && isFinite(n)
            ? (l.ymin = !c.isYValid(
              this.controller.getGraphSettings().yAxisScale,
            ),
              l.ymax = l.ymin)
            : (l.ymin = !isFinite(i), l.ymax = !isFinite(n)),
          isFinite(a) && isFinite(s)
            ? (l.zmin = !c.isZValid(), l.zmax = l.zmin)
            : (l.zmin = !isFinite(a), l.zmax = !isFinite(s)),
          l;
      }
      isLimitInvalid(e) {
        return this.getInvalidLimits()[e];
      }
      onFocusedChanged(e, t) {
        t
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "settings", location: e },
          })
          : this.controller.dispatch({
            type: "blur-focus-location",
            location: { type: "settings", location: e },
          });
      }
      toggleOpen() {
        this.mustBeOpen() || (this.isOpen = !this.isOpen, this.update());
      }
      showZoomSquareButton() {
        return !this.controller.getGraphSettings().squareAxes;
      }
      zoomSquare(e) {
        this.controller.dispatch({ type: "zoom", direction: "square" }),
          e.device === "keyboard" &&
          this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "settings", location: "zmax" },
          });
      }
    };
  var { If: UO } = Tr.Components,
    EI = class extends Tr.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Tr.createElement(
          "div",
          {
            class: Tr.const(
              "dcg-settings-view-container dcg-settings-view-3d-container",
            ),
          },
          Tr.createElement(
            "div",
            { class: Tr.const("dcg-3d-settings-flex-container") },
            Tr.createElement(Ah, {
              ...this.props,
              isPillbox: this.const(true),
            }),
          ),
          Tr.createElement(UO, {
            predicate: () => this.controller.isGraphSettingsOpen(),
          }, () =>
            Tr.createElement(
              "div",
              {
                class: Tr.const(
                  "dcg-settings-container dcg-left dcg-popover dcg-constrained-height-popover",
                ),
                style: this.bindFn(this.getContainerStyle),
                didMount: this.bindFn(this.didMountContainer),
                didUnmount: this.bindFn(this.didUnmountContainer),
              },
              Tr.createElement(
                "div",
                {
                  class: Tr.const(
                    "dcg-popover-interior dcg-generic-options-menu",
                  ),
                  role: Tr.const("region"),
                  "aria-label": () =>
                    this.controller.s(
                      "graphing-calculator-label-tooltip-graph-settings",
                    ),
                },
                Tr.createElement(CI, {
                  controller: this.props.controller,
                }),
                Tr.createElement(SI, {
                  controller: this.props.controller,
                }),
                Tr.createElement(
                  "div",
                  { class: Tr.const("dcg-options-menu-section") },
                  Tr.createElement(
                    "div",
                    { class: Tr.const("dcg-options-menu-section-title") },
                    () => this.controller.s("graphing-calculator-label-axes"),
                    Tr.createElement(go, {
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-label-axes",
                        ),
                      onChange: () => {
                        this.controller.dispatch({
                          type: "set-graph-settings",
                          showAxis3D: !this.controller.getGraphSettings()
                            .showAxis3D,
                        });
                      },
                      toggled: () =>
                        !!this.controller.getGraphSettings().showAxis3D,
                    }),
                  ),
                  Tr.createElement(UO, {
                    predicate: () =>
                      this.controller.getGraphSettings().showAxis3D,
                  }, () =>
                    Tr.createElement(
                      "div",
                      { class: Tr.const("dcg-show-axis-labels-section") },
                      Tr.createElement(
                        "div",
                        null,
                        Tr.createElement(
                          mt,
                          {
                            onChange: () => {
                              this.controller.dispatch({
                                type: "set-graph-settings",
                                showPlane3D: !this.controller
                                  .getGraphSettings().showPlane3D,
                              });
                            },
                            checked: () =>
                              !!this.controller.getGraphSettings()
                                .showPlane3D,
                          },
                          () =>
                            this.controller.s(
                              "graphing-calculator-label-settings-domain-plane",
                            ),
                        ),
                      ),
                      Tr.createElement(
                        "div",
                        null,
                        Tr.createElement(
                          mt,
                          {
                            onChange: () => {
                              this.controller.dispatch({
                                type: "set-graph-settings",
                                showNumbers3D: !this.controller
                                  .getGraphSettings().showNumbers3D,
                              });
                            },
                            checked: () =>
                              !!this.controller.getGraphSettings()
                                .showNumbers3D,
                          },
                          () =>
                            this.controller.s(
                              "graphing-calculator-label-settings-numbers-3d",
                            ),
                        ),
                      ),
                      Tr.createElement(
                        "div",
                        null,
                        Tr.createElement(
                          mt,
                          {
                            onChange: () => {
                              this.controller.dispatch({
                                type: "set-graph-settings",
                                showAxisLabels3D: !this.controller
                                  .getGraphSettings().showAxisLabels3D,
                              });
                            },
                            checked: () =>
                              !!this.controller.getGraphSettings()
                                .showAxisLabels3D,
                          },
                          () =>
                            this.controller.s(
                              "graphing-calculator-label-settings-axis-labels-3d",
                            ),
                        ),
                      ),
                    )),
                ),
                Tr.createElement(UO, {
                  predicate: () => this.controller.canEnableComplexMode(),
                }, () =>
                  Tr.createElement(Lh, {
                    ...this.props,
                    isComplexModeEnabled: () =>
                      this.controller.isComplexModeEnabled(),
                    toggleComplexMode: () =>
                      this.controller.dispatch({
                        type: "toggle-complex-mode",
                      }),
                    product: this.const("graphing-3d"),
                  })),
                Tr.createElement(Jy, {
                  controller: this.props.controller,
                }),
                Tr.createElement(rc, {
                  setup: this.const({
                    controller: this.controller,
                    type: "advanced",
                  }),
                }),
                Tr.createElement("div", { class: Tr.const("dcg-arrow") }),
              ),
            )),
        );
      }
      didMountContainer(e) {
        this.node = e,
          ee(document.documentElement).on(
            "dcg-tapstart.settings-view wheel.settings-view",
            (t) => {
              this.eventShouldClosePopover(t) &&
                this.controller.dispatch({
                  type: "close-graph-settings",
                  focusIconAfterClose: t.device === "keyboard",
                });
            },
          ),
          ee(document.documentElement).on(
            "keydown.settings-view",
            (t) => {
              let o = ke(t);
              if (
                o === "Esc" &&
                this.controller.dispatch({
                  type: "close-graph-settings",
                  focusIconAfterClose: true,
                }),
                  this.controller.isGraphSettingsOpen() && o === "Tab" &&
                  !t.altKey && !t.metaKey && !t.ctrlKey
              ) {
                let i = this.controller.getFocusLocation();
                if (!i || i.type !== "settings") return;
                let n = !!this.controller.getGraphSettings().degreeMode;
                t.shiftKey
                  ? t.shiftKey && (i.location === "reverse-contrast"
                    ? (this.controller.dispatch({
                      type: "set-focus-location",
                      location: { type: "settings", location: "icon" },
                    }),
                      t.preventDefault(),
                      t.stopPropagation())
                    : i.location === "icon" &&
                      (this.controller.dispatch({
                        type: "set-focus-location",
                        location: {
                          type: "settings",
                          location: n ? "degree-mode" : "radian-mode",
                        },
                      }),
                        t.preventDefault(),
                        t.stopPropagation()))
                  : i.location === "icon"
                  ? (this.controller.dispatch({
                    type: "set-focus-location",
                    location: {
                      type: "settings",
                      location: "reverse-contrast",
                    },
                  }),
                    t.preventDefault(),
                    t.stopPropagation())
                  : (!n && i.location === "radian-mode" ||
                    n && i.location === "degree-mode") &&
                    (this.controller.dispatch({
                      type: "set-focus-location",
                      location: { type: "settings", location: "icon" },
                    }),
                      t.preventDefault(),
                      t.stopPropagation());
              }
            },
          );
      }
      didUnmountContainer() {
        ee(document.documentElement).off(".settings-view");
      }
      didUpdate() {
        if (!this.controller.isGraphSettingsOpen()) return;
        let e = this.controller.getKeypadHeight();
        e !== this.cachedKeypadHeight && document.activeElement &&
        this.node.contains(document.activeElement) &&
        tc(
          document.activeElement,
          this.node.querySelector(".dcg-popover-interior"),
          50,
        ), this.cachedKeypadHeight = e;
      }
      eventShouldClosePopover(e) {
        let t = e.target,
          o = this.node.contains(t),
          i = !!t.closest(".dcg-action-settings"),
          n = this.isMathquillFocused() && t.closest(".dcg-keypad"),
          a = !!t.closest(".dcg-action-undo") ||
            !!t.closest(".dcg-action-redo");
        return !(o || i || n || a);
      }
      isMathquillFocused() {
        let e = this.controller.getFocusLocation();
        return (e == null ? void 0 : e.type) === "settings";
      }
      getContainerStyle() {
        return this.controller.getKeypadHeight() ? "bottom: 0" : "";
      }
    };
  var Vc = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var TI = class extends Vc.Class {
    init() {
      this.controller = this.props.controller();
    }
    template() {
      return Vc.createElement(
        Le,
        {
          tooltip: this.bindFn(this.getZoomRestoreLabel),
          gravity: this.const("w"),
        },
        Vc.createElement(
          "div",
          {
            class: () => ({
              "dcg-btn-flat-gray": true,
              "dcg-pillbox-btn-interior": true,
              "dcg-action-zoomrestore": true,
            }),
            role: Vc.const("button"),
            tabIndex: Vc.const("0"),
            "aria-label": this.bindFn(this.getZoomRestoreLabel),
            onTap: this.bindFn(this.setDefaultViewport),
            manageFocus: this.const(
              rt({
                controller: this.controller,
                location: { type: "zoom-restore-btn" },
              }),
            ),
          },
          Vc.createElement("i", {
            class: Vc.const("dcg-icon-home"),
            "aria-hidden": Vc.const("true"),
          }),
        ),
      );
    }
    setDefaultViewport() {
      this.controller.dispatch({ type: "zoom", direction: "default" }),
        this.controller.dispatch({
          type: "set-focus-location",
          location: { type: "zoom-in-btn" },
        });
    }
    getZoomRestoreLabel() {
      return this.controller.s(
        "graphing-calculator-label-tooltip-viewport-default",
      );
    }
  };
  var ni = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var DI = class extends ni.Class {
    init() {
      this.controller = this.props.controller();
    }
    template() {
      return ni.createElement(
        "div",
        { class: ni.const("dcg-zoom-container") },
        ni.createElement(
          "div",
          {
            class: ni.const(
              "dcg-zoominout-pillbox dcg-btn-flat-gray dcg-btn-flat-gray-group dcg-group-vertical",
            ),
            role: ni.const("group"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-narration-zoom-options-label",
              ),
          },
          ni.createElement(
            Le,
            {
              tooltip: this.bindFn(this.getZoomInLabel),
              displayBlock: this.const(true),
              gravity: this.const("w"),
            },
            ni.createElement(
              "div",
              {
                class: ni.const(
                  "dcg-action-zoomin dcg-pillbox-btn-interior",
                ),
                role: ni.const("button"),
                tabIndex: ni.const("0"),
                "aria-label": this.bindFn(this.getZoomInLabel),
                onTap: this.bindFn(this.zoomIn),
                manageFocus: this.const(
                  rt({
                    controller: this.controller,
                    location: { type: "zoom-in-btn" },
                  }),
                ),
              },
              ni.createElement("i", {
                class: ni.const("dcg-icon-plus"),
                "aria-hidden": ni.const("true"),
              }),
            ),
          ),
          ni.createElement(
            Le,
            {
              tooltip: this.bindFn(this.getZoomOutLabel),
              displayBlock: this.const(true),
              gravity: this.const("w"),
            },
            ni.createElement(
              "div",
              {
                class: ni.const(
                  "dcg-action-zoomout dcg-pillbox-btn-interior",
                ),
                role: ni.const("button"),
                tabIndex: ni.const("0"),
                "aria-label": this.bindFn(this.getZoomOutLabel),
                onTap: this.bindFn(this.zoomOut),
              },
              ni.createElement("i", {
                class: ni.const("dcg-icon-minus"),
                "aria-hidden": ni.const("true"),
              }),
            ),
          ),
        ),
      );
    }
    zoomIn() {
      this.controller.dispatch({ type: "zoom", direction: "in" });
    }
    zoomOut() {
      this.controller.dispatch({ type: "zoom", direction: "out" });
    }
    getZoomInLabel() {
      return this.controller.s(
        "graphing-calculator-label-tooltip-zoom-in",
      );
    }
    getZoomOutLabel() {
      return this.controller.s(
        "graphing-calculator-label-tooltip-zoom-out",
      );
    }
  };
  var { Each: oce, If: b0 } = xo.Components,
    kI = class extends xo.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return xo.createElement(
          "div",
          null,
          xo.createElement(b0, {
            predicate: this.bindFn(this.shouldShowLeftPillboxes),
          }, () =>
            xo.createElement(
              "div",
              {
                class: () => ({
                  "dcg-left-pillboxes": true,
                  "dcg-geometry-toolbar-present": this.controller
                    .shouldShowGeoToolbar(),
                }),
              },
              xo.createElement(b0, {
                predicate: this.bindFn(this.shouldShowUndoRedo),
              }, () =>
                xo.createElement(Yy, {
                  controller: this.props.controller,
                  isPillbox: this.const(true),
                })),
              xo.createElement(b0, {
                predicate: this.bindFn(this.shouldShowGeoReset),
              }, () =>
                xo.createElement(g0, {
                  controller: this.props.controller,
                  tooltipGravity: this.const("s"),
                })),
            )),
          xo.createElement(
            "div",
            {
              class: () => ({
                "dcg-pillbox-container": true,
                "dcg-geometry-toolbar-present": this.controller
                  .shouldShowGeoToolbar(),
              }),
              role: () => this.controller.isGeoUIActive() ? void 0 : "region",
              "aria-label": () =>
                this.controller.isGeoUIActive() ? void 0 : this.controller.s(
                  "graphing-calculator-narration-graph-settings-controls",
                ),
            },
            xo.createElement(
              "div",
              {
                class: xo.const("dcg-overgraph-pillbox-elements"),
                style: this.bindFn(this.getContainerStyle),
              },
              xo.createElement(b0, {
                predicate: () =>
                  this.shouldShowOrientationPillbox() &&
                  !this.onSmallScreen(),
              }, () =>
                xo.createElement(
                  "div",
                  { class: xo.const("dcg-left-pillbox-elements") },
                  xo.createElement(m0, {
                    controller: this.props.controller,
                    layout: this.const("horizontal"),
                  }),
                )),
              xo.createElement(b0, {
                predicate: () => this.getRightPillboxElements().length > 0,
              }, () =>
                xo.createElement(
                  "div",
                  { class: xo.const("dcg-right-pillbox-elements") },
                  oce(() => this.getRightPillboxElements(), {
                    item: (e) => {
                      switch (e) {
                        case "settings2d":
                          return xo.createElement(vI, {
                            controller: this.props.controller,
                          });
                        case "settings3d":
                          return xo.createElement(EI, {
                            controller: this.props.controller,
                          });
                        case "settings-geo":
                          return xo.createElement(Ah, {
                            ...this.props,
                            isPillbox: this.const(true),
                          });
                        case "reset":
                          return xo.createElement(g0, {
                            controller: this.props.controller,
                            tooltipGravity: this.const("w"),
                          });
                        case "zoom-in-out":
                          return xo.createElement(DI, {
                            controller: this.props.controller,
                          });
                        case "orientation":
                          return xo.createElement(m0, {
                            layout: this.const("vertical"),
                            controller: this.props.controller,
                          });
                        case "zoom-home":
                          return xo.createElement(TI, {
                            controller: this.props.controller,
                          });
                      }
                    },
                  }),
                )),
            ),
          ),
          xo.createElement(h0, {
            controller: () => this.props.controller(),
          }),
        );
      }
      shouldShowLeftPillboxes() {
        return this.shouldShowGeoReset() || this.shouldShowUndoRedo();
      }
      shouldShowGeoReset() {
        return this.controller.isGeometry() &&
          this.shouldShowResetButton() &&
          !this.controller.isListEnabled();
      }
      shouldShowUndoRedo() {
        return this.controller.isGeometry() &&
          !this.controller.isListEnabled() &&
          !(this.controller.getGeoToolbarSuppressedByAuthor() ||
            this.controller.getGraphSettings().config.hideGeoUI);
      }
      getRightPillboxElements() {
        let e = [];
        return this.shouldShowGraphSettings() && e.push("settings2d"),
          this.shouldShow3DGraphSettings() && e.push("settings3d"),
          this.shouldShowGeometrySettings() && e.push("settings-geo"),
          this.shouldShowResetButton() && !this.shouldShowGeoReset() &&
          e.push("reset"),
          this.shouldShowZoomInOutButtons() && e.push("zoom-in-out"),
          this.shouldShowOrientationPillbox() && this.onSmallScreen() &&
          e.push("orientation"),
          this.shouldShowZoomHomeButton() && e.push("zoom-home"),
          e;
      }
      shouldShowOrientationPillbox() {
        return this.controller.is3dProduct() &&
          this.controller.getGraphSettings().config.orientationButtons;
      }
      getContainerStyle() {
        let e = this.controller.isKeypadOpen()
          ? this.controller.getKeypadHeight()
          : 0;
        return this.controller.isGraphSettingsOpen()
          ? `bottom: ${e}px;`
          : "bottom: auto";
      }
      shouldShow3DGraphSettings() {
        return this.controller.getGraphSettings().config.settingsMenu &&
          this.controller.is3dProduct();
      }
      shouldShowGraphSettings() {
        return this.controller.getGraphSettings().config.settingsMenu &&
          !this.controller.isGeometry() && !this.controller.is3dProduct();
      }
      shouldShowGeometrySettings() {
        return this.controller.getGraphSettings().config.settingsMenu
          ? this.controller.isGeometry()
          : false;
      }
      zoomEnabled() {
        return this.controller.getGraphSettings().config.zoomButtons &&
          !this.isViewportLocked();
      }
      onSmallScreen() {
        let e = this.controller.getLayoutMeasurements();
        return e.width < 450 || e.height < 450;
      }
      shouldShowZoomInOutButtons() {
        return Df && this.onSmallScreen() ? false : this.zoomEnabled();
      }
      shouldShowZoomHomeButton() {
        return this.zoomEnabled() &&
          !this.controller.isDefaultViewportRestored();
      }
      isViewportLocked() {
        return this.controller.getGraphSettings().config.lockViewport ||
          this.controller.getGraphSettings().userLockedViewport;
      }
      shouldShowResetButton() {
        return this.controller.getGraphSettings().config
          .showResetButtonOnGraphpaper &&
          this.controller.hasDefaultState();
      }
    };
  var gr = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    { If: y0 } = gr.Components,
    zO = class extends gr.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return gr.createElement(
          "span",
          { class: gr.const("dcg-toast") },
          gr.createElement("i", {
            class: gr.const("dcg-icon-error"),
            "aria-hidden": gr.const("true"),
          }),
          gr.createElement(
            y0,
            { predicate: () => !this.showUndo() },
            () =>
              gr.createElement("i", {
                class: gr.const("dcg-icon-remove"),
                onTap: () => this.controller.dispatch({ type: "toast/close" }),
                role: gr.const("link"),
                tabIndex: gr.const(0),
                "aria-label": gr.const("Dismiss Notice"),
              }),
          ),
          gr.createElement("span", {
            class: gr.const("dcg-msg"),
            "aria-atomic": () => this.shouldLiveUpdateAria(),
            "aria-live": () => this.shouldLiveUpdateAria() ? "assertive" : "",
          }, () => this.controller.toastData.message),
          gr.createElement(
            y0,
            { predicate: this.bindFn(this.showUndo) },
            () =>
              gr.createElement(
                "a",
                {
                  role: gr.const("link"),
                  tabIndex: gr.const(0),
                  class: gr.const("dcg-undo"),
                  onTap: () => this.controller.dispatch({ type: "toast/undo" }),
                },
                () => this.controller.s("shared-calculator-label-toast-undo"),
              ),
          ),
          gr.createElement(y0, {
            predicate: this.bindFn(this.showLearnMore),
          }, () =>
            gr.createElement("a", {
              role: gr.const("link"),
              tabIndex: gr.const(0),
              target: gr.const("_blank"),
              onTap: () =>
                this.controller.dispatch({ type: "toast/learn-more" }),
            }, () =>
              this.controller.s(
                "shared-calculator-label-toast-learn-more",
              ))),
          gr.createElement(y0, {
            predicate: () => !!this.controller.toastData.link,
          }, () =>
            gr.createElement("a", {
              role: gr.const("link"),
              tabIndex: gr.const(0),
              target: gr.const("_blank"),
              href: () => {
                var e;
                return ((e = this.controller.toastData.link) == null
                  ? void 0
                  : e.url) || "";
              },
            }, () => {
              var e;
              return ((e = this.controller.toastData.link) == null
                ? void 0
                : e.text) || "";
            })),
        );
      }
      showUndo() {
        return !!this.controller.toastData.undoCallback;
      }
      showLearnMore() {
        return !!this.controller.toastData.learnMoreCallback;
      }
      shouldUpdate() {
        return !!this.controller.toastData.message;
      }
      shouldLiveUpdateAria() {
        return !this.controller.toastData.noAria;
      }
    },
    _I = class extends gr.Class {
      template() {
        return gr.createElement(
          "div",
          {
            class: () => ({
              "dcg-toast-view": true,
              "dcg-visible": !!this.props.controller().toastData.message,
              "dcg-below-geo-toolbar": this.isGeometryInCalculator(),
            }),
            "toast-style": () => this.props.controller().toastData.toastStyle,
          },
          gr.createElement(y0, {
            predicate: () => !!this.props.controller().toastData.message,
          }, () =>
            gr.createElement(
              "div",
              { class: gr.const("dcg-toast-wrapper") },
              gr.createElement("div", {
                class: gr.const("dcg-toast-cover"),
              }),
              gr.createElement(zO, { ...this.props }),
            )),
        );
      }
      isGeometryInCalculator() {
        var t;
        let e = this.props.controller();
        return (t = e.isGeometry) == null ? void 0 : t.call(e);
      }
    };
  var tt = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  function j9(r) {
    if (window.clipboardData && window.clipboardData.getData) {
      return window.clipboardData.getData("Text");
    }
    if (r && r.clipboardData && r.clipboardData.getData) {
      return r.clipboardData.getData("text/plain");
    }
  }
  Ss();
  function qO(r) {
    let e;
    if (typeof r == "number") e = r + "";
    else if (typeof r == "string") e = r;
    else return false;
    return e.trim().match(/^-?[0-9]*\.?[0-9]*$/);
  }
  var Hd = {
      delimiter: "",
      header: false,
      dynamicTyping: false,
      preview: 0,
      step: void 0,
      encoding: "",
      comments: false,
      complete: void 0,
      error: void 0,
      download: false,
      chunk: void 0,
      keepEmptyRows: false,
    },
    Rn = {};
  Rn.parse = ice;
  Rn.RECORD_SEP = "";
  Rn.UNIT_SEP = "";
  Rn.BYTE_ORDER_MARK = "\uFEFF";
  Rn.BAD_DELIMITERS = [
    "\r",
    `
`,
    '"',
    Rn.BYTE_ORDER_MARK,
  ];
  Rn.LocalChunkSize = 1024 * 1024 * 10;
  Rn.RemoteChunkSize = 1024 * 1024 * 5;
  Rn.DefaultDelimiter = ",";
  Rn.Parser = II;
  Rn.ParserHandle = Y9;
  function ice(r, e) {
    var t = nce(e), o = new Y9(t), i = o.parse(r);
    return i;
  }
  function Y9(r) {
    var e = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i,
      t = this,
      o,
      i,
      n = false,
      a,
      s = [],
      l = { data: [], errors: [], meta: {} };
    r = HO(r),
      this.parse = function (C) {
        if (a = false, !r.delimiter) {
          var E = u(C);
          E.successful
            ? r.delimiter = E.bestDelimiter
            : (a = true, r.delimiter = Rn.DefaultDelimiter),
            l.meta.delimiter = r.delimiter;
        }
        if (Qy(r.step)) {
          var v = r.step;
          r.step = function (w) {
            l = w, d() ? c() : v(c(), t);
          };
        }
        return r.preview && r.header && r.preview++,
          o = C,
          i = new II(r),
          l = i.parse(o),
          c(),
          Qy(r.complete) && !n && r.complete(l),
          n ? { meta: { paused: true } } : l;
      },
      this.pause = function () {
        n = true, i.abort(), o = o.substr(i.getCharIndex());
      },
      this.resume = function () {
        n = false,
          i = new II(r),
          i.parse(o),
          Qy(r.complete) && !n && r.complete(l);
      },
      this.abort = function () {
        i.abort(), Qy(r.complete) && r.complete(l), o = "";
      };
    function c() {
      return l && a &&
        (y(
          "Delimiter",
          "UndetectableDelimiter",
          "Unable to auto-detect delimiting character; defaulted to '" +
            Rn.DefaultDelimiter + "'",
        ),
          a = false),
        d() && p(),
        h();
    }
    function d() {
      return r.header && s.length == 0;
    }
    function p() {
      if (l) {
        for (var C = 0; d() && C < l.data.length; C++) {
          for (var E = 0; E < l.data[C].length; E++) {
            s.push(l.data[C][E]);
          }
        }
        l.data.splice(0, 1);
      }
    }
    function h() {
      if (!l || !r.header && !r.dynamicTyping) return l;
      for (var C = 0; C < l.data.length; C++) {
        for (var E = {}, v = 0; v < l.data[C].length; v++) {
          if (r.dynamicTyping) {
            var w = l.data[C][v];
            w == "true"
              ? l.data[C][v] = true
              : w == "false"
              ? l.data[C][v] = false
              : l.data[C][v] = f(w);
          }
          r.header &&
            (v >= s.length
              ? (E.__parsed_extra || (E.__parsed_extra = []),
                E.__parsed_extra.push(l.data[C][v]))
              : E[s[v]] = l.data[C][v]);
        }
        r.header && (l.data[C] = E,
          v > s.length
            ? y(
              "FieldMismatch",
              "TooManyFields",
              "Too many fields: expected " + s.length +
                " fields but parsed " + v,
              C,
            )
            : v < s.length &&
              y(
                "FieldMismatch",
                "TooFewFields",
                "Too few fields: expected " + s.length +
                  " fields but parsed " + v,
                C,
              ));
      }
      return r.header && l.meta && (l.meta.fields = s), l;
    }
    function u(C) {
      for (
        var E = [",", "	", "|", ";", Rn.RECORD_SEP, Rn.UNIT_SEP],
          v,
          w,
          S,
          k = 0;
        k < E.length;
        k++
      ) {
        var _ = E[k], A = 0, P = 0;
        S = void 0;
        for (
          var O = new II({ delimiter: _, preview: 10 }).parse(C), U = 0;
          U < O.data.length;
          U++
        ) {
          var z = O.data[U].length;
          if (P += z, typeof S == "undefined") {
            S = z;
            continue;
          } else z > 1 && (A += Math.abs(z - S), S = z);
        }
        P /= O.data.length,
          (typeof w == "undefined" || A < w) && P > 1.99 &&
          (w = A, v = _);
      }
      return r.delimiter = v, { successful: !!v, bestDelimiter: v };
    }
    function f(C) {
      var E = e.test(C);
      return E ? parseFloat(C) : C;
    }
    function y(C, E, v, w) {
      l.errors.push({ type: C, code: E, message: v, row: w });
    }
  }
  function II(r) {
    var e = /^\s*$/, t, o, i, n, a, s, l, c, d, p, h, u, f, y, C, E = false;
    r = r || {},
      o = r.delimiter,
      i = r.comments,
      n = r.step,
      s = r.preview,
      (typeof o != "string" || o.length != 1 ||
        Rn.BAD_DELIMITERS.indexOf(o) > -1) && (o = ","),
      i === true ? i = "#" : (typeof i != "string" || i.length != 1 ||
        Rn.BAD_DELIMITERS.indexOf(i) > -1 || i == o) && (i = false),
      this.parse = function (ae) {
        if (typeof ae != "string") throw "Input must be a string";
        return Y(ae), v();
      },
      this.abort = function () {
        E = true;
      },
      this.getCharIndex = function () {
        return c;
      };
    function v() {
      for (; c < t.length && !(E || s > 0 && C >= s);) {
        l == '"' ? k() : d ? _() : A(), w();
      }
      return S();
    }
    function w() {
      c++, l = t[c];
    }
    function S() {
      if (
        E &&
        te(
          "Abort",
          "ParseAbort",
          "Parsing was aborted by the user's step function",
        ),
          d &&
          te("Quotes", "MissingQuotes", "Unescaped or mismatched quotes"),
          L(),
          !Qy(n)
      ) return se();
    }
    function k() {
      F() && !M()
        ? d = !d
        : (U(),
          d && M()
            ? c++
            : te("Quotes", "UnexpectedQuotes", "Unexpected quotes"));
    }
    function _() {
      (R(c) || N(c)) && p++, U();
    }
    function A() {
      l == o ? z() : R(c) ? (x(), w()) : N(c) ? x() : P() ? O() : U();
    }
    function P() {
      if (!i) return false;
      var ae = c == 0 || N(c - 1) || R(c - 2);
      return ae && t[c] === i;
    }
    function O() {
      for (; !R(c) && !N(c) && c < t.length;) w();
    }
    function U() {
      h[f][y] += l;
    }
    function z() {
      h[f].push(""), y = h[f].length - 1;
    }
    function x() {
      L(), p++, C++, h.push([]), f = h.length - 1, z();
    }
    function L() {
      V(), Qy(n) && (h[f] && n(se()), he());
    }
    function V() {
      h[f].length == 1 && e.test(h[f][0]) &&
        (r.keepEmptyRows ? h[f].splice(0, 1) : h.splice(f, 1),
          f = h.length - 1);
    }
    function R(ae) {
      return ae < t.length - 1 && (t[ae] == "\r" && t[ae + 1] == `
` || t[ae] == `
` && t[ae + 1] == "\r");
    }
    function N(ae) {
      return t[ae] == "\r" || t[ae] == `
`;
    }
    function M() {
      return !F() && c < t.length - 1 && t[c + 1] == '"';
    }
    function F() {
      return !d && Z(c - 1) || Z(c + 1);
    }
    function Z(ae) {
      typeof ae != "number" && (ae = c);
      var q = t[ae];
      return ae <= -1 || ae >= t.length || q == o || q == "\r" || q == `
`;
    }
    function te(ae, q, oe) {
      u.push({
        type: ae,
        code: q,
        message: oe,
        line: p,
        row: f,
        index: c,
      });
    }
    function Y(ae) {
      t = ae, d = false, c = 0, C = 0, p = 1, he(), h = [[""]], l = t[c];
    }
    function he() {
      h = [], u = [], f = 0, y = 0;
    }
    function se() {
      return {
        data: h,
        errors: u,
        meta: {
          lines: p,
          delimiter: o,
          aborted: E,
          truncated: s > 0 && c < t.length,
        },
      };
    }
  }
  function nce(r) {
    typeof r != "object" && (r = {});
    var e = HO(r);
    return (typeof e.delimiter != "string" || e.delimiter.length != 1 ||
      Rn.BAD_DELIMITERS.indexOf(e.delimiter) > -1) &&
      (e.delimiter = Hd.delimiter),
      typeof e.header != "boolean" && (e.header = Hd.header),
      typeof e.dynamicTyping != "boolean" &&
      (e.dynamicTyping = Hd.dynamicTyping),
      typeof e.preview != "number" && (e.preview = Hd.preview),
      typeof e.step != "function" && (e.step = Hd.step),
      typeof e.complete != "function" && (e.complete = Hd.complete),
      typeof e.error != "function" && (e.error = Hd.error),
      typeof e.encoding != "string" && (e.encoding = Hd.encoding),
      typeof e.download != "boolean" && (e.download = Hd.download),
      typeof e.keepEmptyRows != "boolean" &&
      (e.keepEmptyRows = Hd.keepEmptyRows),
      e;
  }
  function HO(r) {
    if (typeof r != "object") return r;
    var e = r instanceof Array ? [] : {};
    for (var t in r) e[t] = HO(r[t]);
    return e;
  }
  function Qy(r) {
    return typeof r == "function";
  }
  var { parse: X9 } = Rn;
  function J9(r) {
    let e = r.split(/\r?\n/), t = [], o = false;
    if (!(e.length < 2)) {
      for (let i = 0; i < e.length; i++) {
        let n = e[i];
        if (!n.trim()) continue;
        i > 0 && !qO(n.replace(/,(\d{3})/g, "$1")) && (o = true);
        let a = { content: n };
        t.push(a);
      }
      if (!o) {
        let i = __dcg_shared_module_exports__["m"](t, "content").map(
          (n) => n.replace(/,(\d{3})/g, "$1"),
        );
        return qO(i[0]) || (i = i.slice(1)), [{
          content: "\\left[" + i.join(",") + "\\right]",
          numberList: true,
        }];
      }
      return t;
    }
  }
  function Q9(r) {
    if (/^\s*$/.test(r)) return;
    let e = X9(r, { preview: 1e4 }), t = e.data, o = [];
    if (e.errors.length && !e.data.length) {
      So("PapaParse.parse returned errors.", {
        metaData: { input: r, output: e.errors },
      });
      return;
    }
    if (!e.data.length || e.data.length < 2) return;
    let i = t[0].length;
    for (let n = 0; n < i; n++) o.push([]);
    for (let n = 0; n < e.data.length; n++) {
      if (!(n === 0 && isNaN(parseFloat(t[n][0])))) {
        if (t[n].length < 2) return;
        if (!(!t[n][0] && !t[n][1])) {
          for (let a = 0; a < i; a++) {
            let s = (t[n][a] || "").replace(/,(\d{3})/g, "$1");
            if (s && isNaN(parseFloat(s))) return;
            o[a].push(s);
          }
        }
      }
    }
    if (!(o[0].length < 2)) return o;
  }
  function Z9(r) {
    let e = __dcg_shared_module_exports__["Jc"](dc_migrateToLatest(r));
    return e.graph.product = "geometry-calculator", e;
  }
  function AI(r) {
    return /^\s*(https?:\/\/)?([-a-zA-Z0-9]*\.)?desmos\.com(:[0-9]+)?\/calculator\/./
      .test(r);
  }
  function KO(r) {
    return /^\s*(https?:\/\/)?([-a-zA-Z0-9]*\.)?desmos\.com(:[0-9]+)?\/(geometry|geometry-beta)\/./
      .test(r);
  }
  function WO(r) {
    return /^\s*(https?:\/\/)?([-a-zA-Z0-9]*\.)?desmos\.com(:[0-9]+)?\/3d\/./
      .test(r);
  }
  function $O(r) {
    return /^\s*(https?:\/\/)?([-a-zA-Z0-9]*\.)?desmos\.com(:[0-9]+)?\/geometry-legacy\/./
      .test(r);
  }
  function e$(r) {
    return AI(r)
      ? "graphing"
      : KO(r)
      ? "geometry-calculator"
      : $O(r)
      ? "geometry"
      : WO(r)
      ? "graphing-3d"
      : void 0;
  }
  async function MI(r, e, t) {
    let o = false;
    r.dispatch({
      type: "toast/show",
      toast: {
        message: r.s("graphing-calculator-text-toast-importing-graph"),
        hideAfter: 0,
        toastStyle: "cover",
        onHide: () => {
          o = true;
        },
      },
    });
    let i = () => {
        o ||
          r.dispatch({
            type: "toast/show",
            toast: {
              message: r.s(
                "graphing-calculator-text-toast-error-importing-graph",
              ),
              toastStyle: "error",
              hideAfter: 12e3,
            },
          });
      },
      n = () => {
        r.dispatch({
          type: "toast/show",
          toast: {
            message: r.s(
              "graphing-calculator-text-toast-error-no-folders",
            ),
            toastStyle: "error",
            hideAfter: 12e3,
          },
        });
      },
      a = (l, c) => {
        r.dispatch({
          type: "set-state",
          state: l,
          opts: { forceUnsavedChanges: true },
        }),
          r.dispatch({
            type: "toast/show",
            toast: {
              message: r.s(
                "graphing-calculator-text-toast-imported-graph",
              ),
              undoCallback: () => {
                r.dispatch({
                  type: "set-state",
                  state: c,
                  opts: { forceUnsavedChanges: true },
                });
              },
            },
          });
      },
      s = (l, c, d) => {
        if (o) return;
        let p = r.getSelectedItem();
        if (!p) return;
        let h = p.type === "folder",
          u = p.type !== "folder" && !!p.folderId,
          f = h || u,
          y = {},
          C = r.getState(),
          E = C.expressions.list;
        if (E.length === 1 && !h && !r.isGeometry()) {
          a(l, C);
          return;
        }
        if (r.isGeometry() && d !== "graphing") {
          a(l, C);
          return;
        }
        let v = l.expressions.list;
        d === "graphing" && Array.isArray(v) &&
          (v = v.filter((A) => A.id !== __dcg_shared_module_exports__["xd"]));
        for (let A = 0; A < v.length; A++) {
          let P = r.generateId(), O = v[A];
          if (O.type === "folder") {
            if (f) {
              n();
              return;
            } else {
              y[O.id] = P, O.id = P;
              continue;
            }
          }
          O.folderId
            ? O.folderId = y[O.folderId]
            : h
            ? O.folderId = p.id
            : u && (O.folderId = p.folderId), O.id = P;
        }
        let w = __dcg_shared_module_exports__["Jc"](C), S = 0;
        for (; S < E.length;) {
          if (E[S].id === p.id) {
            h && (E[S].title = c);
            break;
          }
          S += 1;
        }
        let k = h ? S + 1 : S, _ = h ? 0 : 1;
        E.splice(k, _, ...v), a(C, w);
      };
    try {
      let l = await fetch(`${e}?${new URLSearchParams(wT)}`, {
        headers: { Accept: "application/json" },
      });
      if (!l.ok) throw void 0;
      let c = await l.json(), d = c.state, p = e$(e);
      r.isGeometry() &&
      (p === "geometry" ? d = ug_migrateGeoStateToCalcState(d) : p === "graphing" && (d = Z9(d))),
        d = dc_migrateToLatest(d),
        t(d, (h, u) => {
          h || !u || !p ? i() : s(u, c.title || "", p);
        });
    } catch (l) {
      i();
    }
  }
  var Zy = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    x0 = class extends Zy.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Zy.createElement("div", {
          class: Zy.const("dcg-drag-container"),
          style: () => ({ top: this.getTopPx(), left: this.getLeftPx() }),
        }, this.props.children);
      }
      getTopPx() {
        let e = this.controller.getRawDragState();
        if (e) return e.itemTop + "px";
      }
      getLeftPx() {
        let e = this.controller.getRawDragState();
        if (e) return e.itemLeft + "px";
      }
    };
  var iu = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var { If: sce } = iu.Components,
    GI = class extends iu.Class {
      init() {
        this.guid = __dcg_shared_module_exports__["K"](
          "dcg-exp-list-resize",
        );
      }
      template() {
        return iu.createElement(
          sce,
          { predicate: this.bindFn(this.isVisible) },
          () =>
            iu.createElement("div", {
              class: iu.const("dcg-exp-list-resizer"),
              onTapStart: this.bindFn(this.onTapStart),
            }),
        );
      }
      isVisible() {
        return this.props.controller().expressionsAreFullWidth()
          ? false
          : this.props.controller().isListVisible();
      }
      onTapStart(e) {
        this.initialWidth = this.props.controller().getExpListWidth(),
          this.initialLeft = e.changedTouches[0].clientX,
          ee(document).on(`dcg-tapmove.${this.guid}`, (t) => {
            if (
              this.initialLeft === void 0 || this.initialWidth === void 0
            ) return;
            let o = t.changedTouches[0].clientX - this.initialLeft +
              this.initialWidth;
            this.props.controller().dispatch({
              type: "resize-exp-list",
              expListWidth: o,
            });
          }),
          ee(document).on(
            `dcg-tapend.${this.guid}`,
            this.bindFn(this.onTapEnd),
          ),
          ee(document).on(
            `dcg-tapcancel.${this.guid}`,
            this.bindFn(this.onTapEnd),
          );
      }
      onTapEnd() {
        ee(document).off(`.${this.guid}`),
          this.initialLeft = void 0,
          this.initialWidth = void 0;
      }
    };
  var Qi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { For: lce, If: cce } = Qi.Components,
    LI = class extends Qi.Class {
      init() {
        var e;
        this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.guid = (e = this.controller.getOpenItemMenu()) == null
            ? void 0
            : e.guid;
      }
      didMount() {
        Fp(this.guid, this.controller);
      }
      willUnmount() {
        Np(this.guid, this.controller);
      }
      didMountArrow(e) {
        this.arrowElt = e, Vs(this.arrowElt, this.controller);
      }
      didUpdate() {
        Vs(this.arrowElt, this.controller);
      }
      template() {
        let e = this.model;
        return Qi.createElement(
          "div",
          {
            class: () => ({
              "dcg-table-column-menu": true,
              "dcg-options-menu": true,
            }),
            role: Qi.const("region"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-narration-options-menu",
              ),
          },
          Qi.createElement(
            "div",
            null,
            Qi.createElement(lce, {
              each: this.bindFn(this.getSectionsWithColorAfterFirstOpen),
            }, (t) => {
              switch (t) {
                case "points":
                  return Qi.createElement(iy, {
                    model: () => e,
                    controller: this.props.controller,
                    isOpen: () => this.isSectionOpen("points"),
                  });
                case "drag":
                  return Qi.createElement(ty, {
                    model: () => e,
                    controller: this.props.controller,
                    isOpen: () => this.isSectionOpen("drag"),
                  });
                case "lines":
                  return Qi.createElement(oy, {
                    model: () => e,
                    controller: this.props.controller,
                    isOpen: () => this.isSectionOpen("lines"),
                  });
                case "colors":
                  return Qi.createElement(ih, {
                    model: () => e,
                    controller: this.props.controller,
                  });
              }
            }),
          ),
          Qi.createElement(nh, {
            model: () => e,
            controller: () => this.props.controller(),
          }),
          Qi.createElement(cce, {
            predicate: this.bindFn(this.shouldShowRegressionButton),
          }, () =>
            Qi.createElement(
              "div",
              {
                class: Qi.const(
                  "dcg-options-menu-section dcg-options-menu__regression-btn-container",
                ),
              },
              Qi.createElement("button", {
                class: () => ({
                  "dcg-btn-light-gray": true,
                  "dcg-disabled": this.isRegressionButtonDisabled(),
                }),
                onTap: this.bindFn(this.addRegression),
              }, () =>
                this.controller.s(
                  "graphing-calculator-button-add-table-regression",
                )),
            )),
          Qi.createElement("div", {
            class: Qi.const("dcg-triangle"),
            didMount: this.bindFn(this.didMountArrow),
            didUnmount: () => this.arrowElt = void 0,
          }),
        );
      }
      shouldShowRegressionButton() {
        return this.controller.shouldShowRegressionButton(
            this.model.table,
          )
          ? Cp(this.model)
          : false;
      }
      getSectionsWithColorAfterFirstOpen() {
        let e = this.getSections(), t = [], o = false;
        for (let i of e) {
          t.push(i),
            i === "colors" && (o = true),
            !o && this.canColorComeAfterSection(i) &&
            this.isSectionOpen(i) && (t.push("colors"), o = true);
        }
        return t;
      }
      canColorComeAfterSection(e) {
        switch (e) {
          case "colors":
          case "drag":
            return false;
          case "lines":
          case "points":
            return true;
          default:
            return e;
        }
      }
      getSections() {
        return this.model.draggable && !this.controller.isThreeDMode() &&
            !this.controller.shouldIgnoreGraphInteractions(this.model)
          ? ["points", "lines", "drag"]
          : ["points", "lines"];
      }
      isSectionOpen(e) {
        switch (e) {
          case "drag":
            return this.model.dragMode !== "NONE";
          case "lines":
            return !!this.model.lines;
          case "points":
            return !!this.model.points;
          case "colors":
            return true;
        }
      }
      addRegression() {
        this.isRegressionButtonDisabled() ||
          (this.controller.dispatch({ type: "close-item-settings-menu" }),
            this.controller.dispatch({
              type: "create-table-regression",
              tableId: this.model.table.id,
              regressionType: "linear",
              columnIds: {
                y: this.model.id,
                x: this.model.table.columnModels[0].id,
              },
            }));
      }
      isRegressionButtonDisabled() {
        return !Ru(this.model);
      }
    };
  var nu = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var PI = class extends nu.Class {
    init() {
      var e;
      this.controller = this.props.controller(),
        this.model = this.props.model(),
        this.guid = (e = this.controller.getOpenItemMenu()) == null
          ? void 0
          : e.guid;
    }
    didMount() {
      Fp(this.guid, this.controller);
    }
    willUnmount() {
      Np(this.guid, this.controller);
    }
    didMountArrow(e) {
      this.arrowElt = e, Vs(this.arrowElt, this.controller);
    }
    didUpdate() {
      Vs(this.arrowElt, this.controller);
    }
    template() {
      let e = this.model;
      return nu.createElement(
        "div",
        {
          class: () => ({
            "dcg-table-column-menu": true,
            "dcg-options-menu": true,
          }),
          role: nu.const("region"),
          "aria-label": () =>
            this.controller.s(
              "graphing-calculator-narration-options-menu",
            ),
        },
        nu.createElement(ih, {
          model: () => e,
          controller: this.props.controller,
        }),
        nu.createElement("div", {
          class: nu.const("dcg-triangle"),
          didMount: this.bindFn(this.didMountArrow),
          didUnmount: () => this.arrowElt = void 0,
        }),
      );
    }
  };
  var ir = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: w0 } = ir.Components,
    VI = class extends ir.Class {
      constructor() {
        super(...arguments), this.justGlobalReplaced = false;
      }
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return ir.createElement(
          "div",
          {
            class: () => ({
              "dcg-expression-search-bar": true,
              "dcg-expressions-scrolled": this.props.expsScrolled() &&
                !this.controller.getTickerOpen(),
            }),
            role: ir.const("search"),
          },
          ir.createElement(
            "div",
            { class: ir.const("dcg-search-row") },
            ir.createElement(
              "div",
              { class: ir.const("dcg-search-mathquill-container") },
              ir.createElement(Fe, {
                hasError: this.const(false),
                getAriaLabel: () =>
                  this.controller.s(
                    "graphing-calculator-label-search-expressions",
                  ),
                getAriaPostLabel: () =>
                  this.controller.getExpressionSearchStr().length === 0
                    ? this.controller.raw("")
                    : this.shouldShowReplaceError()
                    ? this.controller.s(
                      "graphing-calculator-error-expression-replacement",
                    )
                    : this.shouldShowSearchError()
                    ? this.controller.s(
                      "graphing-calculator-error-expression-search",
                    )
                    : this.controller.s(
                      "shared-calculator-text-search-results",
                      {
                        count: __dcg_shared_module_exports__["ra"](
                          this.controller.getExpressionSearchCount(),
                        ),
                      },
                    ),
                capExpressionSize: this.const(false),
                onUserChangedLatex: this.bindFn(this.onSearchChange),
                latex: () => this.controller.getRawExpressionSearchStr(),
                isFocused: this.bindFn(this.isSearchFocused),
                config: this.bindFn(this.getMQConfig),
                onFocusedChanged: this.bindFn(this.onSearchFocusChanged),
                noFadeout: this.const(true),
                onUserPressedKey: (e, t) => {
                  if (e === "Esc") {
                    t && t.preventDefault(), this.closeSearch();
                  } else if (e === "Enter") {
                    t && t.preventDefault(), this.onEnter();
                  } else if (e === "Down") {
                    let o = Fe.getFocusedMathquill();
                    return !o ||
                        !Fe.applyArrowKeyAndReturnIfWasAtBounds(o, e, t)
                      ? void 0
                      : this.controller.dispatch({
                        type: "on-special-key-pressed",
                        key: e,
                      });
                  } else {
                    let o = Fe.getFocusedMathquill();
                    if (!o) return;
                    o.keystroke(e, t),
                      this.controller.getRawExpressionSearchStr() !==
                        o.latex() &&
                      (this.justGlobalReplaced = false,
                        this.onSearchChange(o.latex()));
                  }
                },
              }),
              ir.createElement("i", {
                class: ir.const("dcg-icon-search"),
                "aria-hidden": ir.const("true"),
              }),
              ir.createElement(w0, {
                predicate: () =>
                  this.controller.getRawExpressionSearchStr().length ===
                    0,
              }, () =>
                ir.createElement("span", {
                  class: ir.const("dcg-search-placeholder"),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-label-search-expressions",
                  ))),
              ir.createElement(w0, {
                predicate: () => this.shouldShowSearchError(),
              }, () =>
                ir.createElement(
                  "span",
                  {
                    class: ir.const("dcg-search-replace-icon-container"),
                  },
                  ir.createElement(Di, {
                    error: () =>
                      this.controller.s(
                        "graphing-calculator-error-expression-search",
                      ),
                    size: this.const("small"),
                  }),
                )),
              ir.createElement(w0, {
                predicate: () =>
                  this.controller.isSearchReplaceValid() &&
                  !this.justGlobalReplaced,
              }, () =>
                ir.createElement(
                  "span",
                  {
                    class: ir.const("dcg-search-replace-icon-container"),
                  },
                  ir.createElement("i", {
                    class: ir.const("dcg-icon-replace"),
                    role: ir.const("button"),
                    tabIndex: ir.const("0"),
                    "aria-label": () =>
                      this.controller.s(
                        "graphing-calculator-button-replace",
                      ),
                    onTap: this.bindFn(this.onGlobalReplace),
                  }),
                )),
              ir.createElement(w0, {
                predicate: () => this.justGlobalReplaced,
              }, () =>
                ir.createElement(
                  "span",
                  {
                    class: ir.const("dcg-search-replace-icon-container"),
                  },
                  ir.createElement("i", {
                    class: ir.const("dcg-icon-check"),
                    "aria-hidden": ir.const("true"),
                  }),
                )),
              ir.createElement(w0, {
                predicate: () => this.shouldShowReplaceError(),
              }, () =>
                ir.createElement(
                  "span",
                  {
                    class: ir.const("dcg-search-replace-icon-container"),
                  },
                  ir.createElement(Di, {
                    error: () =>
                      this.controller.s(
                        "graphing-calculator-error-expression-replacement",
                      ),
                    size: this.const("small"),
                  }),
                )),
            ),
            ir.createElement("i", {
              onTap: () => this.closeSearch(),
              tabIndex: ir.const("0"),
              "aria-label": () =>
                this.controller.s("account-shell-button-cancel"),
              role: ir.const("button"),
              class: ir.const("dcg-icon-remove dcg-do-not-blur"),
            }),
          ),
        );
      }
      onGlobalReplace() {
        this.justGlobalReplaced = true,
          setTimeout(
            this.bindIfMounted(() => {
              this.justGlobalReplaced = false, this.update();
            }),
            1500,
          ),
          this.controller.dispatch({
            type: "rename-identifier-global",
            search: this.controller.getExpressionSearchStr(),
            replace: this.controller.getExpressionReplaceStr(),
          });
      }
      onEnter() {
        this.controller.isSearchReplaceValid()
          ? this.onGlobalReplace()
          : this.controller.dispatch({
            type: "update-expression-search-str",
            str: this.controller.getRawExpressionSearchStr(),
          });
      }
      shouldShowSearchError() {
        return !this.controller
          .getIsExpressionSearchStrValidForReplace() &&
          this.controller.getExpressionReplaceStr().length > 0;
      }
      shouldShowReplaceError() {
        return !this.shouldShowSearchError() &&
          !this.controller.getIsExpressionReplaceStrValidForReplace() &&
          this.controller.getExpressionReplaceStr().length > 0;
      }
      closeSearch() {
        this.controller.dispatch({ type: "close-expression-search" });
      }
      onSearchChange(e) {
        this.controller.dispatch({
          type: "update-expression-search-str",
          str: e,
        });
      }
      onSearchFocusChanged(e) {
        e
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "search-expressions" },
          })
          : this.controller.dispatch({
            type: "blur-focus-location",
            location: { type: "search-expressions" },
          });
      }
      isSearchFocused() {
        let e = this.controller.getFocusLocation();
        return !!e && e.type === "search-expressions";
      }
      onReplaceChange(e) {
        this.controller.dispatch({
          type: "update-expression-replace-str",
          str: e,
        });
      }
      onReplaceFocusChanged(e) {
        e
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "replace-expressions" },
          })
          : this.controller.dispatch({
            type: "blur-focus-location",
            location: { type: "replace-expressions" },
          });
      }
      isReplaceFocused() {
        let e = this.controller.getFocusLocation();
        return !!e && e.type === "replace-expressions";
      }
      getMQConfig() {
        return this.controller.getMathquillConfig({
          additionalOperators: ["label", "rename", "image"],
        });
      }
    };
  var _t = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var ct = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var { If: v0 } = ct.Components,
    C0 = class extends ct.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return ct.createElement(
          "div",
          { class: ct.const("dcg-add-expression-container") },
          ct.createElement(
            Le,
            {
              tooltip: () =>
                this.controller.s(
                  "graphing-calculator-label-add-item-tooltip",
                ),
              gravity: this.const("s"),
            },
            ct.createElement(
              "button",
              {
                class: () => ({
                  "dcg-unstyled-button": true,
                  "dcg-icon-btn": true,
                  "dcg-add-expression-btn": true,
                  "dcg-action-add-expression": true,
                  "dcg-do-blur": true,
                  "dcg-active": this.controller.isAddExpressionOpen(),
                }),
                handleEvent: ct.const("true"),
                "aria-haspopup": ct.const("true"),
                "aria-expanded": () => this.controller.isAddExpressionOpen(),
                "aria-label": () =>
                  this.controller.s(
                    "graphing-calculator-label-add-item-tooltip",
                  ),
                didMount: (e) => {
                  this.toggleButtonNode = e;
                },
                onTap: this.bindFn(this.toggleAddExpression),
                manageFocus: this.const(
                  rt({
                    controller: this.controller,
                    location: { type: "add-item-btn" },
                  }),
                ),
              },
              ct.createElement("i", {
                class: ct.const("dcg-icon-plus"),
                "aria-hidden": ct.const("true"),
              }),
            ),
          ),
          ct.createElement(v0, {
            predicate: () => this.controller.isAddExpressionOpen(),
          }, () =>
            ct.createElement(
              "div",
              {
                class: () => ({
                  "dcg-add-expression-dropdown": true,
                  "dcg-popover": true,
                  "dcg-bottom": !this.controller.isNarrow(),
                  "dcg-right": this.controller.isNarrow(),
                }),
                role: ct.const("region"),
                "aria-label": () =>
                  this.controller.s(
                    "graphing-calculator-narration-add-item-menu",
                  ),
                didMount: this.bindFn(this.didMountPopover),
                didUnmount: this.bindFn(this.didUnmountPopover),
              },
              ct.createElement(
                "div",
                { class: ct.const("dcg-popover-interior") },
                ct.createElement(
                  "div",
                  {
                    class: ct.const(
                      "dcg-new-item dcg-do-not-blur dcg-action-newexpression",
                    ),
                    role: ct.const("button"),
                    tabIndex: ct.const(0),
                    "aria-label": () =>
                      this.controller.s(
                        "graphing-calculator-narration-add-expression",
                      ),
                    onTap: this.bindFn(this.newExpression),
                    handleEvent: ct.const("true"),
                    manageFocus: this.const(
                      rt({
                        controller: this.controller,
                        location: { type: "add-expression-btn" },
                      }),
                    ),
                  },
                  ct.createElement("i", {
                    class: ct.const(
                      "dcg-icon-new-expression dcg-expression-icon",
                    ),
                    "aria-hidden": ct.const("true"),
                  }),
                  () =>
                    this.controller.s(
                      "graphing-calculator-label-expression-lowercase",
                    ),
                ),
                ct.createElement(v0, {
                  predicate: () => this.controller.areNotesEnabled(),
                }, () =>
                  ct.createElement(
                    "div",
                    {
                      class: ct.const(
                        "dcg-new-item dcg-do-not-blur dcg-action-newtext",
                      ),
                      role: ct.const("button"),
                      tabIndex: ct.const(0),
                      "aria-label": () =>
                        this.controller.s(
                          "graphing-calculator-narration-add-note",
                        ),
                      onTap: this.bindFn(this.newText),
                      handleEvent: ct.const("true"),
                      manageFocus: this.const(
                        rt({
                          controller: this.controller,
                          location: { type: "add-note-btn" },
                        }),
                      ),
                    },
                    ct.createElement("i", {
                      class: ct.const(
                        "dcg-icon-new-text dcg-expression-icon",
                      ),
                      "aria-hidden": ct.const("true"),
                    }),
                    () =>
                      this.controller.s(
                        "graphing-calculator-label-note-lowercase",
                      ),
                  )),
                ct.createElement(
                  "div",
                  {
                    class: ct.const(
                      "dcg-new-item dcg-do-not-blur dcg-action-newtable",
                    ),
                    role: ct.const("button"),
                    tabIndex: ct.const(0),
                    "aria-label": () =>
                      this.controller.s(
                        "graphing-calculator-narration-add-table",
                      ),
                    onTap: this.bindFn(this.newTable),
                    handleEvent: ct.const("true"),
                    manageFocus: this.const(
                      rt({
                        controller: this.controller,
                        location: { type: "add-table-btn" },
                      }),
                    ),
                  },
                  ct.createElement("i", {
                    class: ct.const("dcg-icon-table dcg-expression-icon"),
                    "aria-hidden": ct.const("true"),
                  }),
                  () =>
                    this.controller.s(
                      "graphing-calculator-label-table-lowercase",
                    ),
                ),
                ct.createElement(v0, {
                  predicate: () => this.controller.areFoldersEnabled(),
                }, () =>
                  ct.createElement(
                    "div",
                    {
                      class: ct.const(
                        "dcg-new-item dcg-do-not-blur dcg-action-newfolder",
                      ),
                      role: ct.const("button"),
                      tabIndex: ct.const(0),
                      "aria-label": () =>
                        this.controller.s(
                          "graphing-calculator-narration-add-folder",
                        ),
                      onTap: this.bindFn(this.newFolder),
                      handleEvent: ct.const("true"),
                      manageFocus: this.const(
                        rt({
                          controller: this.controller,
                          location: { type: "add-folder-btn" },
                        }),
                      ),
                    },
                    ct.createElement("i", {
                      class: ct.const(
                        "dcg-icon-new-folder dcg-expression-icon",
                      ),
                      "aria-hidden": ct.const("true"),
                    }),
                    () =>
                      this.controller.s(
                        "graphing-calculator-label-folder-lowercase",
                      ),
                  )),
                ct.createElement(v0, {
                  predicate: () => this.controller.areImagesEnabled(),
                }, () =>
                  ct.createElement(
                    Op,
                    {
                      controller: () => this.controller,
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-add-image",
                        ),
                      onFileChange: (e) => this.insertFiles(e),
                      location: this.const({ type: "add-image-btn" }),
                      readonly: this.const(false),
                    },
                    ct.createElement(
                      "div",
                      {
                        class: ct.const(
                          "dcg-new-item dcg-action-newimage",
                        ),
                      },
                      ct.createElement("i", {
                        class: ct.const(
                          "dcg-icon-new-image dcg-expression-icon",
                        ),
                        "aria-hidden": ct.const("true"),
                      }),
                      () =>
                        this.controller.s(
                          "graphing-calculator-label-image-lowercase",
                        ),
                    ),
                  )),
                ct.createElement(v0, {
                  predicate: this.bindFn(this.showAddTicker),
                }, () =>
                  ct.createElement(
                    "div",
                    {
                      class: ct.const(
                        "dcg-new-item dcg-do-not-blur dcg-action-ticker",
                      ),
                      role: ct.const("button"),
                      tabIndex: ct.const(0),
                      "aria-label": () =>
                        this.controller.s(
                          "graphing-calculator-narration-add-ticker",
                        ),
                      onTap: this.bindFn(this.addTicker),
                      handleEvent: ct.const("true"),
                      manageFocus: this.const(
                        rt({
                          controller: this.controller,
                          location: { type: "add-ticker-btn" },
                        }),
                      ),
                    },
                    ct.createElement("i", {
                      class: ct.const(
                        "dcg-icon-metronome dcg-expression-icon",
                      ),
                      "aria-hidden": ct.const("true"),
                    }),
                    () =>
                      this.controller.s(
                        "graphing-calculator-label-ticker-lowercase",
                      ),
                  )),
              ),
              ct.createElement("span", { class: ct.const("dcg-arrow") }),
            )),
        );
      }
      showAddTicker() {
        return this.controller.areActionsEnabled() &&
          !this.controller.getTickerOpen();
      }
      didMountPopover(e) {
        this.popoverNode = e,
          ee(document).on(
            "dcg-tapstart.add-expression-view wheel.add-expression-view",
            (t) => {
              this.eventShouldClosePopover(t) &&
                this.controller.dispatch({
                  type: "close-add-expression",
                  focusIconAfterClose: t.device === "keyboard",
                });
            },
          ),
          ee(document).on("keydown.add-expression-view", (t) => {
            if (
              ke(t) === "Esc" &&
              this.controller.dispatch({
                type: "close-add-expression",
                focusIconAfterClose: true,
              }), ke(t) === "Tab" && !t.altKey && !t.metaKey && !t.ctrlKey
            ) {
              let o = this.controller.getFocusLocation();
              if (!o) return;
              let i;
              this.showAddTicker()
                ? i = { type: "add-ticker-btn" }
                : this.controller.areImagesEnabled()
                ? i = { type: "add-image-btn" }
                : this.controller.areFoldersEnabled()
                ? i = { type: "add-folder-btn" }
                : i = { type: "add-table-btn" },
                !t.shiftKey && o.type === i.type
                  ? (this.controller.dispatch({
                    type: "set-focus-location",
                    location: { type: "add-item-btn" },
                  }),
                    t.preventDefault(),
                    t.stopPropagation())
                  : t.shiftKey && o.type === "add-item-btn" &&
                    (this.controller.dispatch({
                      type: "set-focus-location",
                      location: i,
                    }),
                      t.preventDefault(),
                      t.stopPropagation());
            }
          }),
          tl && mp && ee(e).on("dcg-tapstart", (t) => t.preventDefault()),
          ee(e.querySelector(".dcg-new-item")).on(
            "touchstart",
            (t) => t.preventDefault(),
          );
      }
      didUnmountPopover() {
        ee(document).off(".add-expression-view");
      }
      toggleAddExpression(e) {
        this.controller.dispatch({
          type: "toggle-add-expression",
          focusOnOpen: e.device === "keyboard",
        });
      }
      newExpression() {
        this.controller.dispatch({ type: "new-expression" });
      }
      newText() {
        this.controller.dispatch({ type: "new-text" });
      }
      newFolder() {
        this.controller.dispatch({ type: "new-folder" });
      }
      addTicker() {
        this.controller.dispatch({ type: "open-ticker" });
      }
      newTable() {
        this.controller.dispatch({ type: "new-table" });
      }
      insertFiles(e) {
        this.controller.dispatch({ type: "new-images", files: e });
      }
      eventShouldClosePopover(e) {
        let t = !!this.popoverNode.contains(e.target),
          o = !!this.toggleButtonNode.contains(e.target);
        return !(t || o);
      }
    };
  var Kd = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var OI = class extends Kd.Class {
    init() {
      this.controller = this.props.controller();
    }
    template() {
      return Kd.createElement(
        "button",
        {
          class: () => ({
            "dcg-unstyled-button": true,
            "dcg-constructions-count-link": true,
            "dcg-icon-btn": true,
            "dcg-active": this.controller.getShowConstructionsOpen(),
            "dcg-do-not-blur": true,
          }),
          handleEvent: Kd.const("true"),
          "aria-expanded": () => this.controller.getShowConstructionsOpen(),
          manageFocus: this.const(
            rt({
              controller: this.controller,
              location: { type: "geo-show-constructions-icon" },
            }),
          ),
          onTap: this.bindFn(this.showAllConstructions),
        },
        Kd.createElement("i", {
          class: Kd.const("dcg-icon-geometry"),
          "aria-label": () =>
            this.controller.s(
              "graphing-calculator-narration-geometry-construction-icon-label",
            ),
        }),
        Kd.createElement("span", {
          class: Kd.const("dcg-construction-count"),
        }, () => this.controller.getGeometryTokenCount()),
      );
    }
    showAllConstructions() {
      this.controller.dispatch({
        type: "set-show-constructions-open",
        open: !this.controller.getShowConstructionsOpen(),
        setFocus: false,
      });
    }
  };
  var Wd = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var RI = class extends Wd.Class {
    init() {
      this.controller = this.props.controller();
    }
    toggleMuted() {
      var e;
      (e = this.controller.toneController) != null && e.isGlobalMuted()
        ? this.controller.dispatch({ type: "unmute-global" })
        : this.controller.dispatch({ type: "mute-global" });
    }
    getMutedState() {
      return !this.controller.toneController ||
          this.controller.toneController.isGlobalMuted()
        ? "muted"
        : "playing";
    }
    getAriaLabel() {
      switch (this.getMutedState()) {
        case "playing":
          return this.controller.s(
            "graphing-calculator-narration-mute-all",
          );
        case "muted":
          return this.controller.s(
            "graphing-calculator-narration-unmute-all",
          );
      }
    }
    template() {
      return Wd.createElement(
        Le,
        {
          gravity: this.const("s"),
          tooltip: this.bindFn(this.getAriaLabel),
        },
        Wd.createElement(
          "button",
          {
            class: () => {
              var e;
              return {
                "dcg-global-mute-button": true,
                "dcg-unstyled-button": true,
                "dcg-icon-btn": true,
                "dcg-is-muted": this.getMutedState() === "muted",
                "dcg-has-never-interacted":
                  !((e = this.controller.toneController) != null &&
                    e.getHasEverInteractedWithMute()),
              };
            },
            didMount: (e) =>
              ee(e).on("tipsyshow", () => {
                var t;
                (t = this.controller.toneController) == null ||
                t.registerMuteInteraction(), this.update();
              }),
            onTap: () => this.toggleMuted(),
            manageFocus: this.const(
              rt({
                controller: this.controller,
                location: { type: "global-mute-button" },
              }),
            ),
            "aria-label": this.bindFn(this.getAriaLabel),
          },
          Wd.createElement("span", {
            class: Wd.const("dcg-first-time-animation"),
          }),
          Wd.createElement("i", { class: Wd.const("dcg-icon-volume") }),
        ),
      );
    }
  };
  var { If: $d } = _t.Components,
    S0 = class extends _t.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return _t.createElement(
          "div",
          {
            class: () => ({
              "dcg-expression-top-bar": true,
              "dcg-expressions-scrolled": this.showShadow(),
            }),
            role: _t.const("toolbar"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-narration-expression-bar",
              ),
            didMount: (e) => {
              this.node = e;
            },
            onTapStart: this.bindFn(this.clearSelectionOnMobile),
          },
          _t.createElement($d, {
            predicate: this.bindFn(this.showHamburger),
          }, () =>
            _t.createElement(
              "button",
              {
                class: _t.const(
                  "dcg-unstyled-button dcg-action-opendrawer dcg-tooltip dcg-icon-btn dcg-in-api-action-opendrawer",
                ),
                handleEvent: _t.const("true"),
                tooltip: this.bindFn(this.getHamburgerLabel),
                "aria-label": this.bindFn(this.getHamburgerLabel),
                onTap: () => this.controller.dispatch({ type: "open-drawer" }),
              },
              _t.createElement("i", {
                class: _t.const("dcg-icon-hamburger"),
                "aria-hidden": _t.const("true"),
              }),
            )),
          _t.createElement($d, {
            predicate: () => !this.controller.isInEditListMode(),
          }, () =>
            _t.createElement(C0, {
              controller: () => this.props.controller(),
            })),
          _t.createElement(
            $d,
            {
              predicate: () =>
                this.controller.isGeoUIActive() &&
                !this.controller.isInEditListMode(),
            },
            () => _t.createElement(OI, { controller: this.props.controller }),
          ),
          _t.createElement(
            $d,
            { predicate: this.bindFn(this.showMuteButton) },
            () => _t.createElement(RI, { controller: this.props.controller }),
          ),
          _t.createElement(
            $d,
            { predicate: this.bindFn(this.showRerandomize) },
            () =>
              _t.createElement(
                Le,
                {
                  tooltip: () =>
                    this.controller.s(
                      "graphing-calculator-label-randomize-tooltip",
                    ),
                  gravity: this.const("s"),
                },
                _t.createElement(
                  "button",
                  {
                    class: _t.const("dcg-unstyled-button dcg-icon-btn"),
                    handleEvent: _t.const("true"),
                    "aria-label": () =>
                      this.controller.s(
                        "graphing-calculator-label-randomize-tooltip",
                      ),
                    onTap: () =>
                      this.controller.dispatch({ type: "re-randomize" }),
                  },
                  _t.createElement("i", {
                    class: _t.const("dcg-icon-randomize"),
                    "aria-hidden": _t.const("true"),
                  }),
                ),
              ),
          ),
          _t.createElement(
            $d,
            {
              predicate: () =>
                this.controller.isInEditListMode() &&
                !this.controller.hasDefaultState(),
            },
            () =>
              _t.createElement("button", {
                class: _t.const("dcg-btn-red dcg-action-clearall"),
                onTap: () => this.controller.dispatch({ type: "clear-graph" }),
              }, () =>
                this.controller.s(
                  "graphing-calculator-button-clear-graph",
                )),
          ),
          _t.createElement(
            $d,
            {
              predicate: () =>
                this.controller.isInEditListMode() &&
                this.controller.hasDefaultState(),
            },
            () =>
              _t.createElement("button", {
                class: _t.const("dcg-btn-red dcg-action-reset"),
                onTap: () => this.controller.dispatch({ type: "reset-graph" }),
              }, () =>
                this.controller.s(
                  "graphing-calculator-button-reset-graph",
                )),
          ),
          _t.createElement(
            "div",
            { class: _t.const("dcg-center-buttons") },
            _t.createElement(Yy, {
              ...this.props,
              isPillbox: this.const(false),
            }),
          ),
          _t.createElement(
            $d,
            { predicate: () => !this.controller.isInEditListMode() },
            () =>
              _t.createElement(
                Le,
                {
                  tooltip: () =>
                    this.controller.s(
                      "graphing-calculator-label-edit-list-tooltip",
                    ),
                  gravity: this.const("s"),
                },
                _t.createElement(
                  "button",
                  {
                    class: _t.const(
                      "dcg-unstyled-button dcg-icon-btn dcg-action-toggle-edit",
                    ),
                    handleEvent: _t.const("true"),
                    "aria-label": () =>
                      this.controller.s(
                        "graphing-calculator-narration-edit-expression-list",
                      ),
                    onTap: this.bindFn(this.toggleEditListMode),
                    manageFocus: this.const(
                      rt({
                        controller: this.controller,
                        location: { type: "edit-list-toggle" },
                      }),
                    ),
                  },
                  _t.createElement("i", {
                    class: _t.const("dcg-icon-settings"),
                    "aria-hidden": _t.const("true"),
                  }),
                ),
              ),
          ),
          _t.createElement($d, {
            predicate: () => this.controller.isInEditListMode(),
          }, () =>
            _t.createElement(
              "button",
              {
                class: _t.const(
                  "dcg-btn-blue dcg-action-toggle-edit dcg-do-not-blur",
                ),
                handleEvent: _t.const("true"),
                onTap: this.bindFn(this.toggleEditListMode),
                manageFocus: this.const(
                  rt({
                    controller: this.controller,
                    location: { type: "edit-list-toggle" },
                  }),
                ),
              },
              () => this.controller.s("graphing-calculator-button-done"),
            )),
          _t.createElement(
            $d,
            {
              predicate: () =>
                !this.controller.isInEditListMode() &&
                this.controller.getGraphSettings().config.graphpaper,
            },
            () =>
              _t.createElement(
                Le,
                {
                  tooltip: () =>
                    this.controller.s(
                      "graphing-calculator-label-hide-expression-list-tooltip",
                    ),
                  gravity: this.const("s"),
                },
                _t.const(" "),
                _t.createElement(
                  "button",
                  {
                    class: () => ({
                      "dcg-unstyled-button": true,
                      "dcg-resize-list-btn": true,
                      "dcg-action-hideexpressions": true,
                      "dcg-icon-btn": true,
                      "dcg-rotated": this.controller.isNarrow(),
                    }),
                    "aria-label": () =>
                      this.controller.s(
                        "graphing-calculator-label-hide-expression-list-tooltip",
                      ),
                    onTap: (e) => {
                      this.controller.dispatch({
                        type: "hide-expressions-list",
                        focusShowIcon: e.device === "keyboard",
                      });
                    },
                    manageFocus: this.const(
                      rt({
                        controller: this.controller,
                        location: { type: "hide-expression-list-btn" },
                      }),
                    ),
                  },
                  _t.createElement("i", {
                    class: _t.const("dcg-icon-hide"),
                    "aria-hidden": _t.const("true"),
                  }),
                ),
              ),
          ),
        );
      }
      showShadow() {
        return this.controller.getTickerOpen() ||
            this.controller.getExpressionSearchOpen()
          ? false
          : this.props.expsScrolled();
      }
      showRerandomize() {
        return this.controller.isInEditListMode()
          ? false
          : this.controller.anyItemDependsOnRandomSeed();
      }
      showHamburger() {
        return !this.controller.getGraphSettings().config.showHamburger ||
            this.controller.isInEditListMode()
          ? false
          : !this.controller.isNarrow();
      }
      getHamburgerLabel() {
        return this.controller.getshowKeyboardShortcutsInTooltips()
          ? this.controller.s(
            "graphing-calculator-label-open-graph-with-shortcut-tooltip",
          )
          : this.controller.s(
            "graphing-calculator-label-open-graph-tooltip",
          );
      }
      clearSelectionOnMobile(e) {
        e.wasHandled() ||
          this.controller.dispatch({ type: "set-none-selected" });
      }
      toggleEditListMode(e) {
        this.controller.dispatch({
          type: "set-edit-list-mode",
          isEditListMode: !this.controller.isInEditListMode(),
          focusExpressionList: false,
        }),
          e.device === "keyboard" &&
          this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "edit-list-toggle" },
          });
      }
      showMuteButton() {
        return this.controller.isInEditListMode()
          ? false
          : this.controller.toneItemsExist();
      }
    };
  var mr = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Oc = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var { Textarea: dce } = Oc.Components,
    au = class extends Oc.Class {
      template() {
        return Oc.createElement(
          "div",
          { class: Oc.const("dcg-smart-textarea-container") },
          Oc.createElement("div", {
            class: Oc.const(
              "dcg-displayTextarea dcg-fixed-width-element",
            ),
            didMount: this.bindFn(this.didMountDisplay),
          }),
          Oc.createElement(dce, {
            class: () => ({
              "dcg-do-blur": true,
              "dcg-fixed-width-element": true,
              "dcg-smart-textarea": true,
              "dcg-empty": !this.props.text(),
            }),
            "aria-label": () => {
              var e, t;
              return (t = (e = this.props).ariaLabel) == null
                ? void 0
                : t.call(e);
            },
            placeholder: this.bindFn(this.getPlaceholder),
            readOnly: () => this.props.readonly() ? true : void 0,
            value: this.props.text,
            onInput: this.props.onInput,
            didMount: this.bindFn(this.didMountTextarea),
            onKeyDown: this.bindFn(this.onKeydownEvent),
          }),
        );
      }
      getDisplayTextHTML() {
        let e = this.props.text() || "",
          t = (n, a) =>
            e.slice(n, a).replace(/</g, "&lt;").replace(/>/g, "&gt;"),
          o = 0,
          i = "";
        if (this.props.showLinks()) {
          let n =
              /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gi,
            a = null;
          for (; (a = n.exec(e)) !== null;) {
            let [s] = a;
            i += t(o, a.index),
              i +=
                `<a rel='nofollow ugc' href='${s}' target ='_blank'>${s}</a>`,
              o = n.lastIndex;
          }
        }
        return i += t(o), i;
      }
      willUnmount() {
        this.textareaNode = void 0;
      }
      didMountDisplay(e) {
        this.displayNode = e,
          ee(e).on("touchend", (t) => {
            t.preventDefault();
          }),
          ee(e).on("dcg-tap dcg-tapstart", (t) => {
            t.target.closest("a") && t.handle();
          }),
          this.renderDisplayText();
      }
      didMountTextarea(e) {
        this.textareaNode = e,
          ee(e).on("dcg-tapstart", (t) => {
            t.handle();
          }),
          ee(e).on("focusin focusout", () => this.onFocusEvent()),
          this.updateFocused();
      }
      didUpdate() {
        this.updateFocused(), this.renderDisplayText();
      }
      onFocusEvent() {
        if (!this.textareaNode) return;
        let e = document.activeElement === this.textareaNode;
        this.shouldBeFocused() !== e && this.props.onFocusChange(e);
      }
      renderDisplayText() {
        if (!this.displayNode) return;
        let e = this.getDisplayTextHTML();
        this.lastDisplayTextHTML !== e &&
          (this.lastDisplayTextHTML = e, this.displayNode.innerHTML = e);
      }
      isFocused() {
        return document.activeElement === this.textareaNode;
      }
      shouldBeFocused() {
        return this.props.shouldFocus();
      }
      updateFocused() {
        if (!this.textareaNode) return;
        let e = this.isFocused(), t = this.shouldBeFocused();
        if (e !== t) {
          if (!t) this.textareaNode.blur();
          else {
            if (tl && mp) return;
            this.textareaNode.focus(),
              this.textareaNode.selectionStart =
                this.textareaNode
                  .selectionEnd =
                  this.textareaNode.value.length;
          }
        }
      }
      onKeydownEvent(e) {
        let t = this.textareaNode;
        if (!t) return;
        let o = ke(e),
          i = this.props.readonly(),
          n = this.props.readonlyAction && this.props.readonlyAction();
        if (i && n !== void 0 && n.predicate()) {
          !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey &&
            (o === "Enter" || o === "Space") &&
            (e.preventDefault(), n.action());
          return;
        }
        o === "Enter" && !e.shiftKey
          ? (e.preventDefault(), this.props.onSpecialKey("Enter"))
          : o === "Esc"
          ? Jr()
          : o === "Up"
          ? (i || t.selectionStart === 0 && t.selectionEnd === 0) &&
            !(e.altKey || e.metaKey) &&
            (e.preventDefault(), this.props.onSpecialKey("Up"))
          : o === "Down"
          ? (i ||
            t.selectionStart === t.value.length &&
              t.selectionEnd === t.value.length) &&
            !(e.altKey || e.metaKey) &&
            (e.preventDefault(), this.props.onSpecialKey("Down"))
          : o === "Backspace" && !(i && n !== void 0 && n.predicate())
          ? t.value.length === 0 &&
            (e.preventDefault(), this.props.onSpecialKey("Backspace"))
          : o === "Del" && !(i && n !== void 0 && n.predicate()) &&
            t.value.length === 0 &&
            (e.preventDefault(), this.props.onSpecialKey("Delete")),
          this.props.onKeydown && this.props.onKeydown(e);
      }
      getPlaceholder() {
        var e, t;
        if (!this.props.text()) {
          return (t = (e = this.props).placeholder) == null
            ? void 0
            : t.call(e);
        }
      }
    };
  var { If: pce } = mr.Components,
    E0 = class extends is {
      didMountRoot(e) {
        this.onItemViewMounted(e);
      }
      willUnmount() {
        this.onItemViewUnmounted();
      }
      template() {
        return mr.createElement(
          "div",
          {
            class: () => ({
              "dcg-do-not-blur": true,
              "dcg-expressionitem": true,
              "dcg-readonly": this.controller.isItemReadonly(this.id),
              "dcg-expressionfolder": true,
              "dcg-inFolder": false,
              "dcg-selected": this.renderAsSelected(),
              "dcg-dragging": !!this.controller.isItemBeingDragged(
                this.id,
              ),
              "dcg-collapsed": !!this.model.collapsed,
              "dcg-hidden": !!this.model.hidden,
              "dcg-has-items":
                this.controller.getNumberOfItemsInFolder(this.id) > 0,
              "dcg-secretFolder": this.model.secret &&
                !this.controller.shouldShowAuthorFeatures(),
            }),
            "expr-id": () => this.model.id,
            onTapStart: this.bindFn(this.onMouseSelect),
            onTap: this.bindFn(this.onMouseSelect),
            didMount: this.bindFn(this.didMountRoot),
          },
          mr.createElement(
            "div",
            { class: mr.const("dcg-fade-container") },
            mr.createElement(
              "div",
              { class: mr.const("dcg-main") },
              mr.createElement(
                "div",
                {
                  role: mr.const("button"),
                  tabIndex: mr.const("0"),
                  "aria-pressed": () => this.model.collapsed,
                  "aria-label": () =>
                    this.model.collapsed
                      ? Xr(this.model, "expand")
                      : Xr(this.model, "collapse"),
                  class: mr.const(
                    "dcg-caret-container dcg-action-toggle-folder-collapsed dcg-do-not-blur",
                  ),
                  handleEvent: mr.const("true"),
                  onTap: this.bindFn(this.toggleCollapsed),
                },
                mr.createElement("i", {
                  class: mr.const("dcg-icon-caret-down"),
                  "aria-hidden": mr.const("true"),
                }),
              ),
              mr.createElement(au, {
                shouldFocus: this.bindFn(this.isFocused),
                text: () => this.model.title,
                showLinks: () => this.controller.areLinksEnabled(),
                onInput: this.bindFn(this.onInput),
                onFocusChange: this.bindFn(this.onFocusChange),
                onSpecialKey: this.bindFn(this.onSpecialKey),
                ariaLabel: this.bindFn(this.getAriaLabel),
                readonly: () =>
                  this.controller.isInEditListMode() ||
                  this.controller.isItemReadonly(this.id),
                readonlyAction: this.const({
                  predicate: () => this.controller.isInEditListMode(),
                  action: () => this.exitEditListMode(),
                }),
                placeholder: () =>
                  this.controller.s(
                    "graphing-calculator-text-folder-placeholder",
                  ),
              }),
              mr.createElement(
                mt,
                {
                  checked: () => this.model.secret,
                  class: () => {
                    let e = "dcg-action-toggle-secret-folder dcg-do-not-blur";
                    return this.controller.canUseAdvancedStyling()
                      ? e
                      : e + " dcg-last-folder-checkbox";
                  },
                  style: () => ({
                    display: this.controller.shouldShowAuthorFeatures()
                      ? void 0
                      : "none",
                  }),
                  onChange: this.bindFn(this.toggleSecret),
                },
                mr.createElement("span", {
                  class: mr.const("dcg-checkbox-label"),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-button-hide-folder-from-students-2",
                  )),
              ),
              mr.createElement(pce, {
                predicate: () => this.controller.canUseAdvancedStyling(),
              }, () =>
                mr.createElement(
                  mt,
                  {
                    checked: () => this.model.inFrontOfEverything,
                    class: this.const(
                      "dcg-action-toggle-in-front-of-everything dcg-do-not-blur dcg-last-folder-checkbox",
                    ),
                    onChange: this.bindFn(this.toggleinFrontOfEverything),
                  },
                  mr.createElement("span", {
                    class: mr.const("dcg-checkbox-label"),
                  }, () =>
                    this.controller.s(
                      "graphing-calculator-button-in-front-of-everything",
                    )),
                )),
            ),
            mr.createElement(Wl, {
              controller: this.props.controller,
              model: this.props.model,
            }),
          ),
          mr.createElement(
            "span",
            {
              class: mr.const("dcg-tab dcg-action-drag"),
              handleEvent: mr.const("true"),
              tapboundary: mr.const("true"),
              disablescroll: mr.const("true"),
              onTapStart: this.bindFn(this.onDragPending),
            },
            mr.createElement(
              "span",
              { class: mr.const("dcg-num") },
              () => this.model.displayIndex,
            ),
            mr.createElement(
              "div",
              { class: mr.const("dcg-tab-interior") },
              mr.createElement(
                "span",
                {
                  role: mr.const("button"),
                  tabIndex: mr.const("0"),
                  "aria-pressed": () => !!this.model.hidden,
                  "aria-label": () =>
                    this.model.hidden
                      ? Xr(this.model, "show")
                      : Xr(this.model, "hide"),
                  class: mr.const(
                    "dcg-circular-icon-container dcg-expression-icon-container",
                  ),
                  onTap: this.bindFn(this.toggleHidden),
                },
                mr.createElement($o, {
                  iconType: () => this.model.hidden ? "hidden" : "folder",
                  whiteIcon: () =>
                    this.renderAsSelected() ||
                    this.controller.isItemBeingDragged(this.model.id),
                }),
              ),
            ),
          ),
          mr.createElement(Hl, {
            controller: this.props.controller,
            id: () => this.model.id,
          }),
        );
      }
      renderAsSelected() {
        return this.controller.isItemSelected(this.model.id) ||
          this.model.collapsedChildIsSelected;
      }
      toggleHidden() {
        this.controller.dispatch({
          type: "toggle-item-hidden",
          id: this.id,
        });
      }
      toggleSecret() {
        this.controller.dispatch({
          type: "set-item-secret",
          id: this.id,
          isSecret: !this.model.secret,
        });
      }
      toggleinFrontOfEverything() {
        this.controller.dispatch({
          type: "set-item-in-front-of-everything",
          id: this.id,
          inFrontOfEverything: !this.model.inFrontOfEverything,
        });
      }
      toggleCollapsed() {
        this.controller.dispatch({
          type: "set-folder-collapsed",
          id: this.id,
          isCollapsed: !this.model.collapsed,
        });
      }
      onInput(e) {
        this.controller.dispatch({
          type: "set-folder-title",
          id: this.id,
          title: e,
        });
      }
      onFocusChange(e) {
        e
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "folder", id: this.id },
          })
          : this.controller.dispatch({
            type: "blur-focus-location",
            location: { type: "folder", id: this.id },
          });
      }
      onSpecialKey(e) {
        return this.controller.dispatch({
          type: "on-special-key-pressed",
          key: e,
        });
      }
      isFocused() {
        let e = this.controller.getFocusLocation();
        return !(!e || e.type !== "folder" || e.id !== this.id);
      }
      getAriaLabel() {
        let e = "", t = "";
        switch (
          (this.model.hidden ? 1 : 0) + (this.model.collapsed ? 16 : 0) +
          (this.model.secret ? 256 : 0) + (this.model.readonly ? 4096 : 0)
        ) {
          case 0:
            t = this.controller.s(
              "graphing-calculator-narration-description-folder",
            );
            break;
          case 1:
            t = this.controller.s(
              "graphing-calculator-narration-description-hidden-folder",
            );
            break;
          case 16:
            t = this.controller.s(
              "graphing-calculator-narration-description-collapsed-folder",
            );
            break;
          case 256:
            t = this.controller.s(
              "graphing-calculator-narration-description-secret-folder",
            );
            break;
          case 4096:
            t = this.controller.s(
              "graphing-calculator-narration-description-readonly-folder",
            );
            break;
          case 17:
            t = this.controller.s(
              "graphing-calculator-narration-description-hidden-collapsed-folder",
            );
            break;
          case 257:
            t = this.controller.s(
              "graphing-calculator-narration-description-hidden-secret-folder",
            );
            break;
          case 4097:
            t = this.controller.s(
              "graphing-calculator-narration-description-hidden-readonly-folder",
            );
            break;
          case 272:
            t = this.controller.s(
              "graphing-calculator-narration-description-collapsed-secret-folder",
            );
            break;
          case 4352:
            t = this.controller.s(
              "graphing-calculator-narration-description-secret-readonly-folder",
            );
            break;
          case 4112:
            t = this.controller.s(
              "graphing-calculator-narration-description-collapsed-readonly-folder",
            );
            break;
          case 273:
            t = this.controller.s(
              "graphing-calculator-narration-description-hidden-collapsed-secret-folder",
            );
            break;
          case 4113:
            t = this.controller.s(
              "graphing-calculator-narration-description-hidden-collapsed-readonly-folder",
            );
            break;
          case 4353:
            t = this.controller.s(
              "graphing-calculator-narration-description-hidden-secret-readonly-folder",
            );
            break;
          case 4368:
            t = this.controller.s(
              "graphing-calculator-narration-description-collapsed-secret-readonly-folder",
            );
            break;
          case 4369:
            t = this.controller.s(
              "graphing-calculator-narration-description-hidden-collapsed-secret-readonly-folder",
            );
            break;
        }
        let c = this.controller.getNumberOfItemsInFolder(this.id);
        return c > 0
          ? e = this.controller.s(
            "graphing-calculator-narration-folder-has-items",
            { folder: t, count: c },
          )
          : e = t,
          e;
      }
    };
  var mn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { For: t$, If: uce } = mn.Components,
    FI = class extends mn.Class {
      init() {
        this.controller = this.props.controller(),
          this.currentlyInspectedDepth = 1 / 0,
          this.cachedTokenDepths = { depths: {}, isInvalid: false },
          this.updateCachedTokenDepthInfo();
      }
      willUpdate() {
        this.updateCachedTokenDepthInfo();
      }
      updateCachedTokenDepthInfo() {
        let e = "", t = false, o = this.controller.getFocusLocation();
        if (o && o.type === "expression") {
          let n = this.controller.getFocusedItem();
          (n == null ? void 0 : n.type) === "expression" &&
            (e = n.id,
              t = !!n.error && n.latex !== "" ||
                !!n.formula.variables.length);
        }
        if (
          this.cachedTokenDepths.focusedExpressionBeforeError == e && t
        ) {
          this.cachedTokenDepths.isInvalid = true;
          return;
        }
        this.cachedTokenDepths = {
          depths: this.controller.cachedGeoTokenDepths,
          isInvalid: false,
          focusedExpressionBeforeError: t ? void 0 : e,
        };
      }
      template() {
        return mn.createElement(
          "div",
          {
            class: () => ({
              "dcg-geo-show-constructions-pane": true,
              "dcg-transient-error": this.cachedTokenDepths.isInvalid,
              "dcg-cant-drag-item": !!this.controller.getDraggedItemId() &&
                !this.controller.canDraggedItemBeMovedIntoTokenPane(),
            }),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-narration-geometry-token-navigator-label",
              ),
            role: mn.const("region"),
            didUnmount: () => this.lastFocusedIdentifier = void 0,
            onKeyDown: this.bindFn(this.handleKeydown),
          },
          mn.createElement(uce, {
            predicate: () => this.controller.getGeometryTokenCount() === 0,
          }, () =>
            mn.createElement("div", {
              class: mn.const("dcg-empty-constructions"),
            }, () =>
              this.controller.s(
                "graphing-calculator-text-geometry-no-constructed-objects",
              ))),
          mn.createElement(
            "div",
            { class: mn.const("dcg-displayed-sections-container") },
            mn.createElement(t$, {
              each: this.bindFn(this.getObjectDepths),
            }, (e) =>
              mn.createElement(
                "div",
                {
                  class: () => ({
                    "dcg-displayed-section-level": true,
                    "dcg-selected-level":
                      parseInt(e) === this.getCurrentlyInspectedDepth(),
                    "dcg-below-the-line":
                      parseInt(e) > this.getCurrentlyInspectedDepth(),
                  }),
                },
                mn.createElement(
                  "span",
                  {
                    role: mn.const("listbox"),
                    "aria-label": () =>
                      this.controller.s(
                        "graphing-calculator-narration-geometry-token-navigator-depth",
                        { depth: e },
                      ),
                  },
                  mn.createElement(t$, {
                    each: () => this.getTokensForDepth(e),
                    key: (t, o) => o,
                  }, (t, o) =>
                    mn.createElement(
                      "span",
                      {
                        class: () => ({
                          "dcg-token-being-dragged-container": this
                            .isTokenBeingDragged(e, o),
                        }),
                        onTapStart: (i) => {
                          let n = this.getCalcIdForDepth(e, o),
                            a = this.controller.getItemModel(n);
                          !a || a.type !== "expression" ||
                            this.controller.isItemInGeoFolder(a.id) &&
                              this.props.onDragPending(i, {
                                type: "token",
                                calcId: n,
                                originalIndex: a.index,
                              });
                        },
                      },
                      mn.createElement(Ad, {
                        showParentChildrenHover: this.const(true),
                        controller: this.props.controller,
                        identifier: () => this.getIdentifierForDepth(e, o),
                        insideMQ: this.const(false),
                        insideGroup: this.const(true),
                        focusLocation: () => ({
                          type: "geo-token",
                          identifier: this.getIdentifierForDepth(e, o),
                        }),
                        putInTabOrder: () => {
                          if (this.lastFocusedIdentifier === void 0) {
                            let i = this.getObjectDepths();
                            this.lastFocusedIdentifier = this
                              .getIdentifierForDepth(i[0], 0);
                          }
                          return this.lastFocusedIdentifier ===
                            this.getIdentifierForDepth(e, o);
                        },
                      }),
                    )),
                ),
              )),
          ),
        );
      }
      isTokenBeingDragged(e, t) {
        let o = this.controller.getDraggedItemId();
        if (!o) return false;
        if (this.controller.isItemInGeoFolder(o)) {
          return o == this.getCalcIdForDepth(e, t);
        }
      }
      getCurrentlyInspectedDepth() {
        return Math.min(
          this.currentlyInspectedDepth,
          this.getObjectDepths().length - 1,
        );
      }
      getIdentifierForDepth(e, t) {
        let o = this.getTokensForDepth(e)[t];
        return o ? o.identifier : "";
      }
      getCalcIdForDepth(e, t) {
        let o = this.getTokensForDepth(e)[t];
        return o ? o.calcId : "";
      }
      getTokensForDepth(e) {
        let { depths: t } = this.cachedTokenDepths, o = t[e];
        return o || [];
      }
      getObjectDepths() {
        let e = Object.keys(this.cachedTokenDepths.depths);
        return e.sort((t, o) => {
          let i = parseInt(t), n = parseInt(o);
          return isFinite(i) ? isFinite(n) ? i - n : 1 : -1;
        }),
          e;
      }
      selectItemIfNecessary() {
        if (this.controller.hasAnyItemsSelected()) return;
        let e = this.controller.getFocusLocation();
        if ((e == null ? void 0 : e.type) !== "geo-token") return;
        let { calcId: t } = this.controller.cachedGeoTokenInfo[e.identifier];
        !t || !this.controller.getItemModel(t) ||
          this.controller.dispatch({
            type: "set-selected-id",
            id: t,
            state: "selected",
          });
      }
      handleKeydown(e) {
        let t = this.controller.getFocusLocation(), o = ke(e), i = Ko(e);
        if (
          e.ctrlKey && e.shiftKey && !e.altKey && !e.metaKey && i === "O"
        ) {
          e.preventDefault(),
            e.stopPropagation(),
            this.selectItemIfNecessary(),
            this.controller.dispatch({
              type: "toggle-item-settings-menu",
              menu: {
                type: "multi-select-more",
                guid: rm(),
                focusFirstOption: true,
                previousFocusLocation: t,
              },
            });
          return;
        }
        if (
          e.altKey && !e.ctrlKey && !e.metaKey && e.shiftKey && i === "T"
        ) {
          if (
            e.preventDefault(),
              e.stopPropagation(),
              (t == null ? void 0 : t.type) !== "geo-token"
          ) return;
          let { calcId: h } = this.controller.cachedGeoTokenInfo[t.identifier];
          if (!h) return;
          let u = this.controller.getItemModel(h);
          if (!il(u)) return;
          this.controller.convertToNamedAssignment(u),
            _n(u, ""),
            this.controller.dispatch({ type: "set-none-selected" }),
            this.controller.dispatch({
              type: "set-focus-location",
              location: { type: "expression", id: u.id },
            });
          return;
        }
        if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) return;
        if (o === "Esc") {
          e.preventDefault(),
            e.stopPropagation(),
            this.controller.dispatch({
              type: "set-show-constructions-open",
              open: false,
              setFocus: true,
            });
          return;
        }
        if (o !== "Up" && o !== "Down" && o !== "Left" && o !== "Right") {
          return;
        }
        e.preventDefault(), e.stopPropagation();
        let n = this.getObjectDepths();
        if (n.length === 0) return;
        let a = "";
        if (t && t.type === "geo-token") a = t.identifier;
        else {
          let h = this.getTokensForDepth(n[0])[0];
          if (!h) return;
          a = h.identifier;
        }
        if (a === "") return;
        let s, l = -1, c = [];
        for (s = 0; s < n.length; s++) {
          let h = n[s];
          if (
            c = this.getTokensForDepth(h),
              !!c &&
              (l = __dcg_shared_module_exports__["w"](c, {
                identifier: a,
              }),
                l !== -1)
          ) break;
        }
        if (s === -1 || l === -1) return;
        o === "Up"
          ? s = Math.max(s - 1, 0)
          : o === "Down"
          ? s = Math.min(s + 1, n.length - 1)
          : o === "Left"
          ? l = Math.max(l - 1, 0)
          : o === "Right" && (l = Math.min(l + 1, c.length - 1));
        let d = this.getTokensForDepth(n[s]);
        if (!d) return;
        l = Math.min(l, d.length - 1);
        let p = d[l].identifier;
        this.controller.dispatch({
          type: "set-focus-location",
          location: { type: "geo-token", identifier: p },
        }), this.lastFocusedIdentifier = p;
      }
    };
  var Kt = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { For: hce, If: T0, Textarea: gce } = Kt.Components,
    NI = class extends Kt.Class {
      template() {
        return Kt.createElement(
          "div",
          { class: Kt.const("dcg-image-aria-container") },
          Kt.createElement(gce, {
            placeholder: () =>
              this.props.controller().s(
                "graphing-calculator-text-add-screen-reader-label-placeholder",
              ),
            value: () => this.props.model().description,
            onInput: (e) =>
              this.props.controller().dispatch({
                type: "set-item-description",
                id: this.props.model().id,
                description: e,
              }),
          }),
        );
      }
    },
    BI = class extends Kt.Class {
      init() {
        var e;
        this.controller = this.props.controller(),
          this.model = this.props.model(),
          this.guid = (e = this.controller.getOpenItemMenu()) == null
            ? void 0
            : e.guid;
      }
      didMountArrow(e) {
        this.arrowElt = e, Vs(this.arrowElt, this.controller);
      }
      didMount() {
        Fp(this.guid, this.controller);
      }
      willUnmount() {
        Np(this.guid, this.controller);
      }
      didUpdate() {
        Vs(this.arrowElt, this.controller);
      }
      template() {
        let e = this.model;
        return Kt.createElement(
          "div",
          { class: Kt.const("dcg-image-options-menu dcg-options-menu") },
          Kt.createElement(
            "div",
            {
              class: Kt.const(
                "dcg-opacities-menu dcg-options-menu-section",
              ),
            },
            Kt.createElement("div", {
              role: Kt.const("heading"),
              "aria-level": Kt.const("2"),
              class: Kt.const("dcg-options-menu-section-title"),
            }, () =>
              this.controller.s(
                "graphing-calculator-heading-image-opacity",
              )),
            Kt.createElement(
              "div",
              {
                class: Kt.const("dcg-opacities-menu-flex"),
                role: Kt.const("group"),
                "aria-label": () =>
                  this.controller.s(
                    "graphing-calculator-heading-image-opacity",
                  ),
              },
              Kt.createElement(hce, {
                each: () => this.controller.getImageOpacities(),
              }, (t) =>
                Kt.createElement(
                  "span",
                  {
                    class: Kt.const("dcg-opacity-option"),
                    role: Kt.const("button"),
                    tabIndex: Kt.const(0),
                    "aria-label": () => `opacity: ${t}`,
                    "aria-pressed": () => this.isOpacitySelected(t),
                    handleEvent: Kt.const("true"),
                    onTap: () => this.onSelectOpacity(t),
                  },
                  Kt.createElement($o, {
                    backgroundImage: this.bindFn(this.getBackgroundImage),
                    iconType: () =>
                      this.isOpacitySelected(t) ? "check" : "none",
                    backgroundOpacity: () => parseFloat(t),
                  }),
                )),
            ),
          ),
          Kt.createElement(
            "div",
            {
              class: Kt.const(
                "dcg-styles-div dcg-options-menu-section dcg-section-without-title",
              ),
            },
            Kt.createElement(T0, {
              predicate: () => this.shouldShowBackgroundCheckbox(),
            }, () =>
              Kt.createElement(
                "div",
                {
                  class: Kt.const("dcg-styles-menu"),
                  role: Kt.const("group"),
                  "aria-label": () =>
                    this.controller.s(
                      "graphing-calculator-narration-image-styles",
                    ),
                },
                Kt.createElement(
                  mt,
                  {
                    checked: () => !e.foreground,
                    onChange: this.bindFn(this.onToggleForeground),
                  },
                  () =>
                    this.controller.s(
                      "graphing-calculator-button-place-image-behind-graphs",
                    ),
                ),
              )),
            Kt.createElement(T0, {
              predicate: () => this.shouldShowDraggableCheckbox(),
            }, () =>
              Kt.createElement(
                "div",
                { class: Kt.const("dcg-draggable-checkbox-container") },
                Kt.createElement(
                  mt,
                  {
                    checked: () => fc(e),
                    onChange: this.bindFn(this.onToggleDraggable),
                  },
                  () =>
                    this.controller.s(
                      "graphing-calculator-button-draggable",
                    ),
                ),
              )),
          ),
          Kt.createElement(
            T0,
            { predicate: () => fc(e) },
            () => Kt.createElement(NI, { ...this.props }),
          ),
          Kt.createElement(
            T0,
            { predicate: this.bindFn(this.shouldShowClickable) },
            () =>
              Kt.createElement(Zb, {
                controller: this.props.controller,
                model: () => e,
                isOpen: () => !!e.clickableInfo.enabled,
              }),
          ),
          Kt.createElement(T0, {
            predicate: () => !!e.clickableInfo.enabled && !fc(e),
          }, () => Kt.createElement(NI, { ...this.props })),
          Kt.createElement(nh, {
            model: () => e,
            controller: () => this.props.controller(),
          }),
          Kt.createElement("div", {
            class: Kt.const("dcg-triangle"),
            didMount: this.bindFn(this.didMountArrow),
            didUnmount: () => this.arrowElt = void 0,
          }),
        );
      }
      onToggleDraggable() {
        jf(this.model)
          ? this.controller.dispatch({
            type: "set-image-draggable",
            id: this.model.id,
            draggable: !this.model.draggable,
          })
          : this.makeDraggable();
      }
      onToggleForeground(e) {
        this.controller.dispatch({
          type: "set-image-in-foreground",
          id: this.model.id,
          foreground: !e,
        });
      }
      onSelectOpacity(e) {
        this.controller.dispatch({
          type: "set-image-opacity",
          id: this.model.id,
          opacity: e,
        });
      }
      isOpacitySelected(e) {
        return this.model.opacity === e;
      }
      getBackgroundImage() {
        return this.model.image_url === this.lastURL
          ? this.lastEncodedURL
          : (this.lastURL = this.model.image_url,
            this.lastEncodedURL = 'url("' + dD(this.model.image_url) +
              '")',
            this.lastEncodedURL);
      }
      shouldShowClickable() {
        return this.controller.shouldIgnoreGraphInteractions(this.model)
          ? false
          : this.controller.areActionsEnabled();
      }
      makeDraggable() {
        this.controller.dispatch({
          type: "convert-image-to-draggable",
          id: this.model.id,
        });
      }
      shouldShowDraggableCheckbox() {
        if (
          this.controller.isThreeDMode() ||
          this.controller.shouldIgnoreGraphInteractions(this.model)
        ) return false;
        let e = jf(this.model);
        return e ? xT(e) : r4(this.model);
      }
      shouldShowBackgroundCheckbox() {
        let e = this.controller.getItemModel(this.model.folderId);
        return !(e && e.type === "folder" && e.inFrontOfEverything);
      }
    };
  var Qe = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: D0, SwitchUnion: mce } = Qe.Components,
    Em = class extends Qe.Class {
      init() {
        this.model = this.props.model(),
          this.controller = this.props.controller();
      }
      template() {
        return Qe.createElement(lr, {
          containerClass: () => ({
            "dcg-image-input-mathquill": true,
            "dcg-suffix-degree": this.props.name() === "angle" &&
              this.props.controller().getGraphSettings().degreeMode,
            "dcg-suffix-radian": this.props.name() === "angle" &&
              !this.props.controller().getGraphSettings().degreeMode,
          }),
          fontSize: this.const("large"),
          fullWidth: this.const(true),
          readonly: this.props.readonly,
          latex: () => this.model[this.props.name()],
          isFocused: () => this.props.focusedInput() === this.props.name(),
          ariaLabel: () => this.controller.raw(this.props.name()),
          handleFocusChanged: this.bindFn(this.handleMQFocusedChanged),
          hasError: () => s4(this.model, this.props.name()),
          controller: this.props.controller,
          handlePressedKey: this.bindFn(this.handlePressedKey),
          handleLatexChanged: this.bindFn(this.handleLatexChanged),
          noBorder: () => !this.props.focusedInput(),
        });
      }
      getInputs() {
        return ["center", "width", "angle", "height", "opacity"];
      }
      handlePressedKey(e, t) {
        let o = this.props.name(),
          i = Fe.getFocusedMathquill(),
          n = this.getInputs(),
          a = n.indexOf(o);
        if (!this.controller.isInEditListMode()) {
          if (e === "Enter") {
            return this.controller.dispatch({
              type: "on-special-key-pressed",
              key: "Enter",
            });
          }
          if (e === "Esc") {
            Jr();
            return;
          }
        }
        let s = -1;
        e === "Up" && (s = a === 1 ? 4 : a - 2),
          e === "Down" && (s = a === 4 ? 1 : a + 2),
          e === "Left" && (s = a - 1),
          e === "Right" && (s = a + 1);
        let l = e;
        if (s >= 0 && s < n.length) {
          let c = false;
          if (i) c = Fe.applyArrowKeyAndReturnIfWasAtBounds(i, l, t);
          else if (e === "Up" || e === "Down") c = true;
          else {
            let d = os();
            c = d &&
              (e === "Left" && d.selectionStart === 0 ||
                e === "Right" && d.selectionStart === d.value.length);
          }
          c && (this.focusInput(n[s]), t && t.preventDefault());
          return;
        }
        i && (i.keystroke(e, t), this.handleLatexChanged(i.latex()));
      }
      focusInput(e) {
        this.controller.dispatch({
          type: "set-focus-location",
          location: { type: "image", id: this.model.id, location: e },
        });
      }
      handleLatexChanged(e) {
        let t = this.props.name();
        this.model.draggingOnGraphpaper ||
          Zz(this.model, t) !== e &&
            this.controller.dispatch({
              type: "set-image-mq-attribute",
              id: this.model.id,
              attribute: t,
              latex: e,
            });
      }
      handleMQFocusedChanged(e) {
        let t = this.props.name();
        e
          ? this.props.focusedInput() !== t &&
            this.controller.dispatch({
              type: "set-focus-location",
              location: { type: "image", id: this.model.id, location: t },
            })
          : this.controller.dispatch({
            type: "blur-focus-location",
            location: { type: "image", id: this.model.id, location: t },
          });
      }
    },
    k0 = class extends is {
      didMountRoot(e) {
        this.onItemViewMounted(e);
      }
      willUnmount() {
        this.onItemViewUnmounted();
      }
      template() {
        return Qe.createElement(
          "div",
          {
            class: () => ({
              "dcg-do-not-blur": true,
              "dcg-expressionitem": true,
              "dcg-readonly": this.controller.isItemMarkedReadonly(
                this.id,
              ),
              "dcg-expressionimage": true,
              "dcg-inFolder": !!this.model.folderId,
              "dcg-selected": this.controller.isItemSelected(this.id),
              "dcg-dragging": !!this.controller.isItemBeingDragged(
                this.id,
              ),
              "dcg-input-focused": this.getFocusedInput() &&
                this.getFocusedInput() !== "name",
            }),
            "expr-id": () => this.model.id,
            onTapStart: this.bindFn(this.onMouseSelect),
            onTap: this.bindFn(this.onMouseSelect),
            didMount: this.bindFn(this.didMountRoot),
          },
          Qe.createElement(
            "div",
            { class: Qe.const("dcg-fade-container") },
            Qe.createElement(
              "div",
              { class: Qe.const("dcg-main") },
              mce(() => this.model.loadStatus, {
                failed: () =>
                  Qe.createElement(
                    "div",
                    null,
                    Qe.createElement("div", {
                      class: Qe.const("dcg-image-failed"),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-error-failed-to-load-image",
                      )),
                    Qe.createElement("div", {
                      role: Qe.const("button"),
                      tabIndex: Qe.const(0),
                      class: Qe.const("dcg-retry-loading-image"),
                      onTap: this.bindFn(this.onRetryLoad),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-button-load-image-retry",
                      )),
                  ),
                loading: () =>
                  Qe.createElement(
                    "div",
                    null,
                    Qe.createElement("div", {
                      class: Qe.const("dcg-image-loading"),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-text-loading-image",
                      )),
                    Qe.createElement("div", {
                      role: Qe.const("button"),
                      tabIndex: Qe.const(0),
                      class: Qe.const("dcg-retry-loading-image"),
                      onTap: this.bindFn(this.onRetryLoad),
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-button-load-image-retry",
                      )),
                  ),
                loaded: () =>
                  Qe.createElement(
                    "div",
                    { class: Qe.const("dcg-image-loaded") },
                    Qe.createElement(
                      "div",
                      { class: Qe.const("dcg-image-title-row") },
                      Qe.createElement(au, {
                        shouldFocus: () => this.getFocusedInput() === "name",
                        text: () => this.model.name,
                        ariaLabel: () => Xr(this.model, "edit_title"),
                        placeholder: () =>
                          this.controller.s(
                            "graphing-calculator-text-image-placeholder",
                          ),
                        showLinks: () => this.controller.areLinksEnabled(),
                        onInput: this.bindFn(this.onNameInput),
                        onFocusChange: this.bindFn(
                          this.onNameFocusChange,
                        ),
                        onSpecialKey: this.bindFn(this.onNameSpecialKey),
                        readonly: () =>
                          this.controller.isInEditListMode() ||
                          this.isReadonly(),
                      }),
                      Qe.createElement(D0, {
                        predicate: () => this.controller.areImagesEnabled(),
                      }, () =>
                        Qe.createElement(
                          Op,
                          {
                            controller: () => this.controller,
                            ariaLabel: () =>
                              this.controller.s(
                                "graphing-calculator-button-change-image",
                              ),
                            onFileChange: (e) => this.insertFiles(e),
                            location: this.const({
                              type: "change-image-btn",
                              id: this.id,
                            }),
                            readonly: this.bindFn(this.isReadonly),
                          },
                          Qe.createElement(D0, {
                            predicate: () => !this.isReadonly(),
                          }, () =>
                            Qe.createElement("div", {
                              class: Qe.const("dcg-action-changeimage"),
                            }, () =>
                              this.controller.s(
                                "graphing-calculator-button-change-image",
                              ))),
                        )),
                    ),
                    Qe.createElement(
                      "div",
                      {
                        class: () => ({
                          "dcg-do-blur": true,
                          "dcg-image-input-grid": true,
                        }),
                        handleEvent: Qe.const("true"),
                      },
                      Qe.createElement("div", {
                        class: Qe.const("dcg-image-input-name"),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-label-image-center",
                        )),
                      Qe.createElement(Em, {
                        name: this.const("center"),
                        controller: () => this.controller,
                        model: () => this.model,
                        focusedInput: this.bindFn(this.getFocusedInput),
                        readonly: this.bindFn(this.isReadonly),
                      }),
                      Qe.createElement("div", {
                        class: Qe.const("dcg-image-input-name"),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-label-image-width",
                        )),
                      Qe.createElement(Em, {
                        name: this.const("width"),
                        controller: () => this.controller,
                        model: () => this.model,
                        focusedInput: this.bindFn(this.getFocusedInput),
                        readonly: this.bindFn(this.isReadonly),
                      }),
                      Qe.createElement("div", {
                        class: Qe.const("dcg-image-input-name"),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-label-image-angle",
                        )),
                      Qe.createElement(Em, {
                        name: this.const("angle"),
                        controller: () => this.controller,
                        model: () => this.model,
                        focusedInput: this.bindFn(this.getFocusedInput),
                        readonly: this.bindFn(this.isReadonly),
                      }),
                      Qe.createElement("div", {
                        class: Qe.const("dcg-image-input-name"),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-label-image-height",
                        )),
                      Qe.createElement(Em, {
                        name: this.const("height"),
                        controller: () => this.controller,
                        model: () => this.model,
                        focusedInput: this.bindFn(this.getFocusedInput),
                        readonly: this.bindFn(this.isReadonly),
                      }),
                      Qe.createElement("div", {
                        class: Qe.const("dcg-image-input-name"),
                      }, () =>
                        this.controller.s(
                          "graphing-calculator-label-image-opacity",
                        )),
                      Qe.createElement(Em, {
                        name: this.const("opacity"),
                        controller: () => this.controller,
                        model: () => this.model,
                        focusedInput: this.bindFn(this.getFocusedInput),
                        readonly: this.bindFn(this.isReadonly),
                      }),
                    ),
                  ),
              }),
            ),
            Qe.createElement("span", { class: Qe.const("dcg-fadeout") }),
            Qe.createElement(Wl, {
              controller: this.props.controller,
              model: this.props.model,
            }),
            Qe.createElement(D0, {
              predicate: this.bindFn(this.shouldShowBrailleError),
            }, () =>
              Qe.createElement(
                "div",
                { class: this.getFooterClass() },
                Qe.createElement(
                  "div",
                  {
                    tabIndex: Qe.const(0),
                    class: Qe.const("dcg-expression-braille-error"),
                    "aria-roledescription": Qe.const("error"),
                    "aria-label": () =>
                      this.controller.unpack(this.model.error),
                  },
                  Qe.createElement("i", {
                    class: Qe.const("dcg-icon-error"),
                    "aria-hidden": Qe.const("true"),
                  }),
                  () => this.controller.unpack(this.model.error),
                ),
              )),
            Qe.createElement(D0, {
              predicate: () =>
                TE(this.model).length > 0 &&
                this.controller.areSlidersEnabled(),
            }, () =>
              Qe.createElement(
                "div",
                { class: this.getFooterClass() },
                Qe.createElement(Ec, {
                  model: this.props.model,
                  controller: this.props.controller,
                }),
              )),
            Qe.createElement(D0, {
              predicate: this.bindFn(this.shouldShowActionInfo),
            }, () =>
              Qe.createElement(
                "div",
                { class: this.getFooterClass() },
                Qe.createElement(zg, {
                  model: this.props.model,
                  controller: this.props.controller,
                }),
              )),
          ),
          Qe.createElement(
            "span",
            {
              class: Qe.const(
                "dcg-tab dcg-action-drag dcg-action-icon-touch",
              ),
              handleEvent: Qe.const("true"),
              tapboundary: Qe.const("true"),
              disablescroll: Qe.const("true"),
              onTapStart: this.bindFn(this.onDragPending),
            },
            Qe.createElement(
              "span",
              { class: Qe.const("dcg-num") },
              () => this.model.displayIndex,
            ),
            Qe.createElement(
              "div",
              {
                class: Qe.const("dcg-tab-interior dcg-action-icon-mouse"),
              },
              Qe.createElement($g, {
                model: this.props.model,
                controller: this.props.controller,
              }),
            ),
          ),
          Qe.createElement(Hl, {
            controller: this.props.controller,
            id: () => this.model.id,
          }),
        );
      }
      isReadonly() {
        return this.controller.isItemReadonly(this.id);
      }
      shouldShowActionInfo() {
        return !!(this.model.clickableInfo &&
          this.model.clickableInfo.enabled &&
          this.model.clickableInfo.latex);
      }
      getFooterClass() {
        return this.isFirstRender()
          ? this.const("dcg-expression-bottom dcg-indent-in-folder")
          : this.const(
            "dcg-expression-bottom dcg-fadein-bottom dcg-indent-in-folder",
          );
      }
      onNameInput(e) {
        this.controller.dispatch({
          type: "set-image-name",
          id: this.id,
          name: e,
        });
      }
      onNameFocusChange(e) {
        e
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "image", id: this.id, location: "name" },
          })
          : this.getFocusedInput() === "name" &&
            this.controller.dispatch({
              type: "blur-focus-location",
              location: { type: "image", id: this.id, location: "name" },
            });
      }
      onNameSpecialKey(e) {
        return this.controller.dispatch({
          type: "on-special-key-pressed",
          key: e,
        });
      }
      getFocusedInput() {
        let e = this.controller.getFocusLocation();
        if (e && e.type === "image" && e.id === this.model.id) {
          return e.location;
        }
      }
      onRetryLoad() {
        this.controller.dispatch({
          type: "image-retry-loading",
          id: this.id,
        });
      }
      shouldShowBrailleError() {
        return this.controller.getBrailleMode() !== "none" &&
          !!this.model.error;
      }
      insertFiles(e) {
        this.controller.dispatch({
          type: "change-image",
          files: e,
          id: this.id,
        });
      }
      onMouseSelect(e) {
        e.type === "dcg-tap" && e.device === "mouse" ||
          e.type === "dcg-tapstart" && e.device === "touch" ||
          e.wasHandled() ||
          (e.handle(),
            this.controller.dispatch({
              type: "set-selected-id",
              id: this.id,
              state: "selected",
            }));
      }
    };
  var Fa = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    _0 = class extends Fa.Class {
      template() {
        return this.controller = this.props.controller(),
          Fa.createElement(
            "div",
            {
              class: Fa.const(
                "dcg-expressionitem dcg-new-expression dcg-opened",
              ),
            },
            Fa.createElement(
              "div",
              {
                class: Fa.const(
                  "dcg-new-math-div dcg-do-not-blur dcg-action-newmath",
                ),
                onTap: this.bindFn(this.newMath),
              },
              Fa.createElement("div", {
                class: Fa.const("dcg-new-expression-fade"),
              }),
            ),
            Fa.createElement(
              "span",
              { class: Fa.const("dcg-tab") },
              Fa.createElement("span", {
                class: Fa.const("dcg-num dcg-variable-index"),
              }, this.bindFn(this.getIndex)),
              Fa.createElement("div", {
                class: Fa.const("dcg-tab-interior"),
              }),
            ),
          );
      }
      getIndex() {
        return this.controller.getNextDisplayIndex();
      }
      newMath() {
        this.controller.dispatch({ type: "new-expression-at-end" });
      }
    };
  var Ar = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    I0 = class extends Ar.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Ar.createElement(
          "section",
          { class: Ar.const("dcg-progress-update-legend") },
          Ar.createElement(
            "h2",
            { class: Ar.const("dcg-sr-only") },
            Ar.const("Progress Update Legend"),
          ),
          Ar.createElement("button", {
            onTap: () => this.hideLegend(),
            class: Ar.const("dcg-hide-progress"),
          }, Ar.const("Hide Legend")),
          Ar.createElement(
            "ul",
            { class: Ar.const("dcg-unstyled-list") },
            Ar.createElement(
              "li",
              { class: Ar.const("dcg-legend-section") },
              Ar.createElement("span", {
                class: Ar.const(
                  "dcg-progress-unpublished dcg-progress-swatch",
                ),
                "aria-label": Ar.const("light yellow swatch"),
                role: Ar.const("img"),
              }),
              Ar.createElement("span", null, Ar.const("unpublished")),
            ),
            Ar.createElement(
              "li",
              { class: Ar.const("dcg-legend-section") },
              Ar.createElement("span", {
                class: Ar.const(
                  "dcg-progress-analyzing dcg-progress-swatch",
                ),
                "aria-label": Ar.const("light blue swatch"),
                role: Ar.const("img"),
              }),
              Ar.createElement("span", null, Ar.const("analyzing")),
            ),
            Ar.createElement(
              "li",
              { class: Ar.const("dcg-legend-section") },
              Ar.createElement("span", {
                class: Ar.const(
                  "dcg-progress-graphing dcg-progress-swatch",
                ),
                "aria-label": Ar.const("light red swatch"),
                role: Ar.const("img"),
              }),
              Ar.createElement("span", null, Ar.const("computing plot")),
            ),
          ),
        );
      }
      hideLegend() {
        this.controller.dispatch({ type: "hide-progress-update-legend" });
      }
    };
  var A0 = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var M0 = class extends is {
    didMountRoot(e) {
      this.onItemViewMounted(e);
    }
    willUnmount() {
      this.onItemViewUnmounted();
    }
    template() {
      let e = "";
      return this.model.cachedRenderHeight &&
        (e = "height:" + this.model.cachedRenderHeight + "px"),
        A0.createElement("div", {
          class: A0.const("dcg-do-not-blur dcg-expressionitem dcg-shell"),
          "expr-id": this.const(this.model.id),
          onTap: this.bindFn(this.onMouseSelect),
          style: A0.const(e),
          didMount: this.bindFn(this.didMountRoot),
        });
    }
  };
  var zo = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var fn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var UI = [
      .05,
      .1,
      .15,
      .2,
      .35,
      .5,
      .75,
      1,
      1.5,
      2,
      3.5,
      5,
      7.5,
      10,
      15,
      20,
    ],
    fce = __dcg_shared_module_exports__["o"](UI),
    bce = __dcg_shared_module_exports__["n"](UI),
    G0 = class extends fn.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return fn.createElement(
          "div",
          {
            class: fn.const("dcg-slider-speed-container dcg-do-not-blur"),
            handleEvent: fn.const("true"),
          },
          fn.createElement(
            "span",
            {
              class: () => ({
                "dcg-action-slower": true,
                "dcg-disabled": this.isSlowerDisabled(),
              }),
              onTap: () => this.animateSlower(),
              role: fn.const("button"),
              "aria-label": () => this.getSlowerAriaLabel(),
              tabIndex: () => this.isSlowerDisabled() ? -1 : 0,
              "aria-disabled": () => this.isSlowerDisabled(),
            },
            fn.createElement("i", {
              class: fn.const("dcg-icon-show"),
              "aria-hidden": fn.const("true"),
            }),
          ),
          fn.createElement(
            "span",
            { class: fn.const("dcg-variable-speed") },
            this.bindFn(this.computeSpeed),
            fn.const("x"),
          ),
          fn.createElement(
            "span",
            {
              class: () => ({
                "dcg-action-faster": true,
                "dcg-disabled": this.isFasterDisabled(),
              }),
              onTap: () => this.animateFaster(),
              role: fn.const("button"),
              "aria-label": () => this.getFasterAriaLabel(),
              tabIndex: () => this.isFasterDisabled() ? -1 : 0,
              "aria-disabled": () => this.isFasterDisabled(),
            },
            fn.createElement("i", {
              class: fn.const("dcg-icon-show"),
              "aria-hidden": fn.const("true"),
            }),
          ),
        );
      }
      computeSpeed() {
        let e = __dcg_shared_module_exports__["yd"] /
          this.model.slider.animationPeriod;
        return e = Number(e.toFixed(3)), e;
      }
      isSlowerDisabled() {
        return fce >= this.computeSpeed();
      }
      isFasterDisabled() {
        return bce <= this.computeSpeed();
      }
      animateSlower() {
        let e = this.computeSpeed(),
          t = __dcg_shared_module_exports__["i"](UI, (o) => o < e);
        t.length !== 0 &&
          this.setPeriodFromSpeed(__dcg_shared_module_exports__["n"](t));
      }
      animateFaster() {
        let e = this.computeSpeed(),
          t = __dcg_shared_module_exports__["i"](UI, (o) => o > e);
        t.length !== 0 &&
          this.setPeriodFromSpeed(__dcg_shared_module_exports__["o"](t));
      }
      setPeriodFromSpeed(e) {
        let t = __dcg_shared_module_exports__["yd"] / e;
        this.controller.dispatch({
          type: "set-slider-animationperiod",
          id: this.model.id,
          animationPeriod: t,
        }),
          xe(
            this.controller.s(
              "graphing-calculator-narration-slider-animating-at-speed",
              { speed: e + "" },
            ),
          );
      }
      getSlowerAriaLabel() {
        return this.controller.s(
          "graphing-calculator-narration-slider-animate-slower",
        );
      }
      getFasterAriaLabel() {
        return this.controller.s(
          "graphing-calculator-narration-slider-animate-faster",
        );
      }
    };
  var zI = class extends zo.Class {
    init() {
      var e;
      this.controller = this.props.controller(),
        this.model = this.props.model(),
        this.guid = (e = this.controller.getOpenItemMenu()) == null
          ? void 0
          : e.guid;
    }
    didMount() {
      Fp(this.guid, this.controller);
    }
    willUnmount() {
      Np(this.guid, this.controller);
    }
    didMountArrow(e) {
      this.arrowElt = e, Vs(this.arrowElt, this.controller);
    }
    didUpdate() {
      Vs(this.arrowElt, this.controller);
    }
    template() {
      let e = this.model;
      return zo.createElement(
        "div",
        { class: zo.const("dcg-slider-options-view dcg-options-menu") },
        zo.createElement("div", {
          class: zo.const("dcg-triangle"),
          didMount: this.bindFn(this.didMountArrow),
          didUnmount: () => this.arrowElt = void 0,
        }),
        zo.createElement(
          "div",
          { class: zo.const("dcg-slider-menu") },
          zo.createElement(
            "div",
            {
              role: zo.const("group"),
              "aria-label": () =>
                this.controller.s(
                  "graphing-calculator-heading-slider-animation-mode",
                ),
            },
            zo.createElement("div", {
              role: zo.const("heading"),
              "aria-level": zo.const("2"),
              class: zo.const("dcg-title"),
            }, () =>
              this.controller.s(
                "graphing-calculator-heading-slider-animation-mode",
              )),
            zo.createElement(vo, {
              ariaGroupLabel: () =>
                this.controller.s(
                  "graphing-calculator-heading-slider-animation-mode",
                ),
              staticConfig: this.bindFn(this.getAnimationOptions),
              theme: this.const("mini"),
            }),
          ),
        ),
        zo.createElement(
          "div",
          {
            class: zo.const("dcg-slider-menu dcg-slider-speed-menu"),
            role: zo.const("group"),
            "aria-label": () =>
              this.controller.s(
                "graphing-calculator-heading-slider-speed",
              ),
          },
          zo.createElement("div", {
            role: zo.const("heading"),
            "aria-level": zo.const("2"),
            class: zo.const("dcg-title"),
          }, () =>
            this.controller.s(
              "graphing-calculator-heading-slider-speed",
            )),
          zo.createElement(
            "div",
            { class: zo.const("dcg-slider-speed-container") },
            zo.createElement(G0, {
              model: () => e,
              controller: this.props.controller,
            }),
          ),
        ),
      );
    }
    getAnimationOptions() {
      let e = this.model;
      return [
        "LOOP_FORWARD_REVERSE",
        "LOOP_FORWARD",
        "PLAY_ONCE",
        "PLAY_INDEFINITELY",
      ].map((o) => ({
        key: o,
        icon: () => __dcg_shared_module_exports__["qd"](o),
        tooltip: () => this.getTooltip(o),
        tooltipGravity: this.const("s"),
        selected: () => this.isSelected(o),
        onSelect: () => {
          this.controller.dispatch({
            type: "set-slider-loopmode",
            id: e.id,
            loopMode: o,
          });
        },
      }));
    }
    getTooltip(e) {
      let t = this.controller.s;
      switch (e) {
        case "LOOP_FORWARD_REVERSE":
          return t(
            "graphing-calculator-narration-slider-loop-forwards-and-backwards",
          );
        case "LOOP_FORWARD":
          return t(
            "graphing-calculator-narration-slider-repeat-one-direction",
          );
        case "PLAY_ONCE":
          return t("graphing-calculator-narration-slider-play-once");
        case "PLAY_INDEFINITELY":
          return t(
            "graphing-calculator-narration-slider-play-indefinitely",
          );
      }
    }
    isSelected(e) {
      return this.model.slider.loopMode === e;
    }
  };
  var rr = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  function r$(r) {
    let e = [], t = r.getAllItemModels();
    for (let o of t) {
      let i = r.getItemRootNodeById(o.id);
      i && e.push(i);
    }
    return e;
  }
  function yce(r) {
    let e = r.getAllItemModels();
    for (let t = e.length - 1; t >= 0; t--) {
      let o = e[t];
      if (o.rootViewNode) return o.id;
    }
  }
  function o$(r, e) {
    let t = r$(r), o = 0, i = t.length - 1;
    for (; o <= i;) {
      let n = o + Math.floor((i - o) / 2),
        a = t[n],
        s = a.getBoundingClientRect();
      if (s.top > e) i = n - 1;
      else if (s.bottom < e) o = n + 1;
      else return a;
    }
  }
  function xce(r, e) {
    let t = r$(r), o = 0, i = t.length - 1, n;
    for (; o <= i;) {
      let a = o + Math.floor((i - o) / 2), s = t[a];
      s.getBoundingClientRect().top > e ? (i = a - 1, n = s) : o = a + 1;
    }
    return n;
  }
  function i$(r, e) {
    let t = Tm(r);
    if (!t) return;
    if (e) {
      let i = r.getItemRootNodeById(e);
      if (i) {
        let n = i.getBoundingClientRect();
        if (n.height > 0 && n.top <= t.top && n.bottom >= t.top) return e;
      }
    }
    let o = o$(r, t.top);
    return o ? o.getAttribute("expr-id") : jO(r);
  }
  function n$(r, e) {
    let t = Tm(r);
    if (!t) return;
    let o = yce(r);
    if (!o) return;
    if (e) {
      let n = r.getItemRootNodeById(e);
      if (n) {
        let a = n.getBoundingClientRect();
        if (
          a.height > 0 && a.top <= t.bottom && a.bottom >= t.bottom ||
          e === o && a.bottom <= t.bottom
        ) return e;
      }
    }
    let i = o$(r, t.bottom);
    return i && i.getAttribute("expr-id") || o;
  }
  function jO(r) {
    let e = Tm(r);
    if (!e) return;
    let t = xce(r, e.top - 2);
    if (t) return t.getAttribute("expr-id");
  }
  function L0(r) {
    return r.findEl(".dcg-exppanel");
  }
  function Tm(r) {
    let e = L0(r);
    if (e) return e.getBoundingClientRect();
  }
  function a$(r) {
    let e = r.findEl(".dcg-exppanel-container");
    if (!e) return;
    let t = e.getBoundingClientRect(), o = e.scrollTop;
    return t.top - o;
  }
  function s$(r) {
    let e = r.findEl(".dcg-expressionlist");
    if (!e) return;
    let t = e.getBoundingClientRect();
    return { width: t.width, height: t.height };
  }
  function l$(r) {
    let e = L0(r);
    if (!e) return;
    let t = e.querySelector(".dcg-drag-container > *");
    if (!t) return;
    let o = t.getBoundingClientRect();
    return { width: o.width, height: o.height };
  }
  qt();
  var fs = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: wce } = fs.Components,
    qI = class extends fs.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.props.model();
      }
      template() {
        return fs.createElement(
          wce,
          {
            predicate: () =>
              this.controller.shouldShowRegressionButton(this.model),
          },
          () =>
            fs.createElement(
              "div",
              {
                class: fs.const("dcg-add-regression-view dcg-do-blur"),
                handleEvent: fs.const(true),
              },
              fs.createElement(
                Le,
                {
                  tooltip: this.bindFn(this.getTooltipText),
                  gravity: () => "e",
                },
                fs.createElement("i", {
                  onTap: () => {
                    this.controller.dispatch({
                      type: "create-table-regression",
                      tableId: this.model.id,
                      regressionType: "linear",
                    });
                  },
                  role: fs.const("button"),
                  tabIndex: fs.const("0"),
                  "aria-label": this.bindFn(this.getTooltipText),
                  class: fs.const("dcg-icon-points"),
                  manageFocus: this.const(
                    rt({
                      controller: this.controller,
                      location: {
                        type: "add-table-regression-btn",
                        id: this.model.id,
                      },
                    }),
                  ),
                }),
              ),
            ),
        );
      }
      getTooltipText() {
        return this.controller.s(
          "graphing-calculator-button-add-table-regression",
        );
      }
    };
  var je = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Ni = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var vce =
      'a, input, button:not([disabled]), textarea, select [role="textbox"], [tabIndex="0"], [role="option"], [role="button"], [role="link"], summary',
    ex = class {
      constructor(
        {
          isOpen: e,
          closeMenu: t,
          anchorSelector: o,
          popoverSelector: i,
          itemNavigationKey: n,
        },
      ) {
        this.handleKeydown = (e) => {
          switch (this.itemNavigationKey) {
            case "arrow":
              return this.onKeydownWithArrowTrapping(e);
            case "tab":
              return this.onKeydownWithTabTrapping(e);
          }
        };
        this.handleTap = (e) => {
          let t = document.querySelector(this.popoverSelector);
          if (!t) return;
          let { target: o } = e, i = this.anchorSelector;
          i && o.closest(i) || t.contains(o) ||
            Array.from(
              document.querySelectorAll(
                ".dcg-keypad,.dcg-show-keypad-container",
              ),
            ).some((a) => a.contains(o)) || this.closeMenu();
        };
        this.isOpen = e,
          this.closeMenu = t,
          this.anchorSelector = o,
          this.popoverSelector = i,
          this.itemNavigationKey = n;
      }
      getFocusableItems() {
        let e = document.querySelector(this.popoverSelector);
        return e
          ? Array.from(e.querySelectorAll(vce)).filter((o) =>
            o.getAttribute("tabIndex") !== "-1"
          ).filter((o) => bp(o))
          : [];
      }
      focusAnchor() {
        var e;
        (e = document.querySelector(this.anchorSelector)) == null ||
          e.focus();
      }
      focusItemAtIdx(e) {
        let t = this.getFocusableItems();
        return t.length && t.length > e ? (t[e].focus(), true) : false;
      }
      focusFirstItem() {
        this.focusItemAtIdx(0);
      }
      focusLastItem() {
        this.focusItemAtIdx(this.getFocusableItems().length - 1);
      }
      getFocusedElement() {
        return this.getFocusableItems().find((e) => e.matches(":focus"));
      }
      moveFocusInDirection(e) {
        let t = this.getFocusableItems(),
          o = t.findIndex((a) => a.matches(":focus"));
        if (o === -1) return false;
        let i = o + e;
        if (i == -1 || i == t.length) return true;
        let n = t[i];
        return n ? (n.focus(), true) : false;
      }
      isAnchorFocused() {
        var e;
        return (e = document.querySelector(this.anchorSelector)) == null
          ? void 0
          : e.matches(":focus");
      }
      isFirstItemFocused() {
        var t;
        let e = this.getFocusableItems();
        return e.length > 0 &&
          ((t = e[0]) == null ? void 0 : t.matches(":focus"));
      }
      isLastItemFocused() {
        var t;
        let e = this.getFocusableItems();
        return e.length > 0 &&
          ((t = e[e.length - 1]) == null ? void 0 : t.matches(":focus"));
      }
      onKeydownWithArrowTrapping(e) {
        if (this.isOpen()) {
          switch (ke(e)) {
            case xa:
              this.moveFocusInDirection(-1) && e.preventDefault();
              break;
            case Kn:
              this.moveFocusInDirection(1) && e.preventDefault();
              break;
            case fp:
              e.preventDefault(), this.focusLastItem();
              break;
            case rl:
              e.preventDefault(), this.closeMenu();
              break;
            case kn:
              e.preventDefault(),
                e.stopPropagation(),
                this.closeMenu(),
                this.focusAnchor();
              break;
          }
        }
      }
      onKeydownWithTabTrapping(e) {
        if (!this.isOpen()) return;
        let t = ke(e);
        if (t === kn) {
          e.preventDefault(),
            e.stopPropagation(),
            this.focusAnchor(),
            this.closeMenu();
          return;
        }
        if (t === "Tab" && !e.altKey && !e.ctrlKey && !e.metaKey) {
          if (this.isAnchorFocused()) {
            e.shiftKey ? this.focusLastItem() : this.focusFirstItem(),
              e.preventDefault(),
              e.stopPropagation();
            return;
          }
          if (this.isLastItemFocused() && !e.shiftKey) {
            this.focusAnchor(), e.preventDefault(), e.stopPropagation();
            return;
          }
          if (this.isFirstItemFocused() && e.shiftKey) {
            this.focusAnchor(), e.preventDefault(), e.stopPropagation();
            return;
          }
        }
      }
    };
  var { IfDefined: Cce, If: Sce } = Ni.Components,
    Ece = -7,
    HI = 9,
    XO = class extends Ni.Class {
      didMountPopover(e) {
        var o, i, n, a;
        (i = (o = this.props).didMount) == null || i.call(o, e);
        let t = (a = (n = this.props).focusHelper) == null ? void 0 : a.call(n);
        t &&
          (document.addEventListener("keydown", t.handleKeydown),
            t.focusFirstItem());
      }
      didUnmountPopover() {
        var t, o;
        let e = (o = (t = this.props).focusHelper) == null ? void 0 : o.call(t);
        e && document.removeEventListener("keydown", e.handleKeydown);
      }
      isVisible() {
        return this.props.visible ? this.props.visible() : true;
      }
      getPositionClasses() {
        let e = this.props.position();
        return {
          "dcg-left": e === "left",
          "dcg-right": e === "right",
          "dcg-bottom": e === "bottom-left" || e === "bottom-right",
          "dcg-top": e === "top-left" || e === "top-right",
        };
      }
      template() {
        return Ni.createElement(
          "div",
          {
            class: () => {
              var e, t, o, i, n, a;
              return {
                "dcg-dropdown-popover": true,
                "dcg-dropdown-popover--with-arrow":
                  !((t = (e = this.props).hideArrow) != null &&
                    t.call(e)),
                "dcg-dropdown-popover--constrain-height":
                  (i = (o = this.props).constrainHeight) == null
                    ? void 0
                    : i.call(o),
                ...this.getPositionClasses(),
                [
                  ((a = (n = this.props).className) == null
                    ? void 0
                    : a.call(n)) || ""
                ]: !!this.props.className,
              };
            },
            role: Ni.const("region"),
            style: () => {
              var e, t;
              return {
                display: this.isVisible() ? void 0 : "none",
                ...((t = (e = this.props).style) == null
                  ? void 0
                  : t.call(e)) || {},
              };
            },
            didMount: this.bindFn(this.didMountPopover),
            didUnmount: this.bindFn(this.didUnmountPopover),
          },
          Ni.createElement(
            "div",
            { class: Ni.const("dcg-dropdown-popover__interior") },
            Cce(() => {
              var e, t;
              return (t = (e = this.props).title) == null ? void 0 : t.call(e);
            }, (e) =>
              Ni.createElement("h2", {
                class: Ni.const(
                  "dcg-unstyled-heading dcg-dropdown-popover__title",
                ),
              }, () => e())),
            this.props.children,
          ),
          Ni.createElement(Sce, {
            predicate: () => {
              var e, t;
              return !((t = (e = this.props).hideArrow) != null &&
                t.call(e));
            },
          }, () =>
            Ni.createElement("div", {
              class: Ni.const("dcg-arrow"),
              style: () => {
                var e, t;
                return ((t = (e = this.props).arrowStyle) == null
                  ? void 0
                  : t.call(e)) || {};
              },
            })),
        );
      }
    },
    P0 = class extends Ni.Class {
      constructor() {
        super(...arguments),
          this.showDropdown = false,
          this.guid = this.props.guid(),
          this.dropdownStyle = {},
          this.arrowStyle = void 0,
          this.debouncedPositionDynamically = __dcg_shared_module_exports__
            ["A"](
              this.bindFn(this.positionDynamically),
              200,
            );
      }
      init() {
        var t, o;
        let e = (o = (t = this.props).manageFocus) == null ? void 0 : o.call(t);
        e && (this.focusHelper = new ex({
          anchorSelector: `.dcg-popover-with-anchor__anchor--${this.guid}`,
          popoverSelector: `.dcg-popover-with-anchor__popover--${this.guid}`,
          isOpen: () => this.isDropdownOpen(),
          closeMenu: () => this.setDropdownOpen(false),
          itemNavigationKey: e.itemNavigationKey,
        }));
      }
      isDropdownOpen() {
        return this.props.controlled
          ? this.props.controlled().isOpen
          : this.showDropdown;
      }
      setDropdownOpen(e) {
        var t, o, i;
        (o = (t = this.props).disabled) != null && o.call(t) ||
          (this.props.controlled
            ? this.props.controlled().setDropdownOpen(e)
            : (this.showDropdown = e, this.update()),
            e &&
            (this.resetPosition(),
              this.positionDynamically(),
              (i = this.focusHelper) == null || i.focusFirstItem()));
      }
      didMountWrapper(e) {
        var o, i;
        this.rootNode = e,
          window.addEventListener(
            "resize",
            this.debouncedPositionDynamically,
          );
        let t = (i = (o = this.props).boundingParentElement) == null
          ? void 0
          : i.call(o);
        t &&
        (this.resizeObserver = new ResizeObserver(
          this.debouncedPositionDynamically,
        ),
          this.resizeObserver.observe(t)),
          ee(document.body).on(`dcg-tapstart.${this.guid}`, (n) => {
            if (
              !(n.target === e || ee.contains(e, n.target)) &&
              this.isDropdownOpen()
            ) {
              let a = e.querySelector(
                ".dcg-popover-with-anchor__popover",
              );
              if (ee.contains(a, n.target)) return;
              let s = a.getBoundingClientRect();
              if (
                n.clientX !== void 0 && n.clientY !== void 0 &&
                n.clientX > s.left && n.clientX < s.right &&
                n.clientY > s.top && n.clientY < s.bottom
              ) return;
              this.setDropdownOpen(false);
              return;
            }
          });
      }
      didUnmountWrapper() {
        this.showDropdown = false,
          ee(document.body).off(`.${this.guid}`),
          ee(document).off(`.${this.guid}`),
          window.removeEventListener(
            "resize",
            this.debouncedPositionDynamically,
          ),
          this.resizeObserver && this.resizeObserver.disconnect();
      }
      didMountDropdown(e) {
        var o, i, n;
        this.dropdownNode = e,
          ((o = this.rootNode) == null
            ? void 0
            : o.querySelector(".dcg-arrow")) && (this.arrowStyle = {}),
          this.resetPosition(),
          this.positionDynamically(),
          (n = (i = this.props.dropdownProps()).didMount) == null ||
          n.call(i, e);
      }
      getDropdownOffset() {
        var e, t;
        return ((t = (e = this.props).dropdownOffset) == null
          ? void 0
          : t.call(e)) || Ece;
      }
      resetPosition() {
        var i;
        let e = this.props.dropdownProps().position();
        this.dropdownStyle = {},
          ((i = this.rootNode) == null ? void 0 : i.querySelector(".dcg-arrow"))
            ? this.arrowStyle = {}
            : this.arrowStyle = void 0;
        let o = this.getDropdownOffset();
        switch (e) {
          case "left":
          case "right":
            this.dropdownStyle.top = `${o}px`,
              this.arrowStyle && (this.arrowStyle.top = `${HI}px`);
            break;
          case "top-right":
          case "bottom-right":
            this.dropdownStyle.left = `${o}px`,
              this.arrowStyle && (this.arrowStyle.left = `${HI}px`);
            break;
          case "top-left":
          case "bottom-left":
            this.dropdownStyle.right = `${o}px`,
              this.arrowStyle && (this.arrowStyle.right = `${HI}px`);
            break;
        }
        this.update();
      }
      positionDynamically() {
        var y, C, E, v;
        let e = this.dropdownNode, t = this.rootNode;
        if (!t || !e || !this.isDropdownOpen()) return;
        let o = e.getBoundingClientRect(),
          i =
            (E = (C = (y = this.props).boundingParentElement) == null
                ? void 0
                : C.call(y)) == null
              ? void 0
              : E.getBoundingClientRect(),
          n = i ? i.x + i.width : window.innerWidth,
          a = i ? i.y + i.height : window.innerHeight,
          s = (v = i == null ? void 0 : i.left) != null ? v : 0,
          l = o.bottom > a,
          c = o.right > n,
          d = o.left < s,
          p = this.props.dropdownProps().position(),
          h = t.getBoundingClientRect(),
          u = 15,
          f = HI + this.getDropdownOffset();
        if ((p === "left" || p === "right") && l) {
          let w = a - h.y - u, S = o.height - w;
          this.dropdownStyle.top = `${-1 * S}px`,
            this.arrowStyle && (this.arrowStyle.top = `${S + f}px`);
        } else if ((p === "bottom-right" || p === "top-right") && c) {
          let w = n - h.x - u, S = o.width - w;
          this.dropdownStyle.left = `${-1 * S}px`,
            this.arrowStyle && (this.arrowStyle.left = `${S + f}px`);
        } else if ((p === "bottom-left" || p === "top-left") && d) {
          let w = h.x + h.width - u - s, S = o.width - w;
          this.dropdownStyle.right = `${-1 * S}px`,
            this.arrowStyle && (this.arrowStyle.right = `${S + f}px`);
        }
        this.update();
      }
      getDropdownClassNames() {
        var t, o;
        let e =
          ((o = (t = this.props.dropdownProps()).className) == null
            ? void 0
            : o.call(t)) || "";
        return `dcg-popover-with-anchor__popover dcg-popover-with-anchor__popover--${this.guid} ${e}`;
      }
      template() {
        return Ni.createElement(
          "div",
          {
            class: () => {
              var e, t;
              return {
                "dcg-popover-with-anchor": true,
                [
                  ((t = (e = this.props).containerClassName) == null
                    ? void 0
                    : t.call(e)) || ""
                ]: !!this.props.containerClassName,
              };
            },
            didMount: this.bindFn(this.didMountWrapper),
            didUnmount: this.bindFn(this.didUnmountWrapper),
          },
          Ni.createElement("div", {
            role: Ni.const("link"),
            tabIndex: Ni.const(0),
            "aria-label": () => {
              var e, t;
              return (t = (e = this.props).anchorAriaLabel) == null
                ? void 0
                : t.call(e);
            },
            "aria-expanded": this.bindFn(this.isDropdownOpen),
            "aria-haspopup": Ni.const("true"),
            class: () => ({
              "dcg-popover-with-anchor__anchor": true,
              [`dcg-popover-with-anchor__anchor--${this.guid}`]: true,
              "dcg-popover-with-anchor__open": this.isDropdownOpen(),
            }),
            onTap: () => {
              this.setDropdownOpen(!this.isDropdownOpen());
            },
          }, this.props.anchor()),
          Ni.createElement(XO, {
            ...this.props.dropdownProps(),
            className: this.bindFn(this.getDropdownClassNames),
            visible: this.bindFn(this.isDropdownOpen),
            focusHelper: () => this.focusHelper,
            didMount: (e) => this.didMountDropdown(e),
            arrowStyle: () => this.arrowStyle,
            style: () => this.dropdownStyle,
          }, this.props.children),
        );
      }
    };
  var oa = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var dr = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { For: c$, If: KI, IfDefined: Tce, Switch: Dce } = dr.Components,
    WI = class extends dr.Class {
      template() {
        var e, t;
        return dr.createElement(
          "div",
          {
            role: dr.const("list"),
            class: () => {
              var o, i;
              return {
                "dcg-shared-options-dropdown": true,
                [
                  ((i = (o = this.props).class) == null ? void 0 : i.call(o)) ||
                  ""
                ]: !!this.props.class,
              };
            },
          },
          dr.createElement(c$, {
            each: this.props.options,
            key: (o) =>
              `${o.key ? o.key : o.title()}${o.disabled ? "-disabled" : ""}`,
          }, (o) =>
            dr.createElement(
              "div",
              {
                role: dr.const("listitem"),
                class: dr.const("dropdown-option-container"),
              },
              dr.createElement(Dce, {
                key: () => o,
              }, (i) =>
                "href" in i
                  ? dr.createElement(
                    "a",
                    {
                      "aria-disabled": () => i.disabled,
                      "aria-selected": () => {
                        var n;
                        return (n = i.selected) == null ? void 0 : n.call(i);
                      },
                      id: this.const(i.key),
                      tabIndex: () => this.getTabIndex(i),
                      class: () => {
                        var n;
                        return {
                          [i.class || ""]: !!i.class,
                          "dcg-standard-link-styling": !i.class,
                          "dcg-dropdown-choice": true,
                          "dcg-disabled": i.disabled,
                          "dcg-selected": (n = i.selected) == null
                            ? void 0
                            : n.call(i),
                        };
                      },
                      onTap: () => !i.disabled && this.props.onTap(i),
                      href: () => i.href,
                      target: () => i.target !== void 0 ? i.target : "",
                      rel: () => i.noreferrer ? "noreferrer noopener" : "",
                    },
                    dr.createElement(KI, {
                      predicate: () => i.icon != null,
                    }, () =>
                      dr.createElement(
                        "div",
                        { class: dr.const("dcg-option-icon-container") },
                        dr.createElement("i", {
                          "aria-hidden": dr.const("true"),
                          class: () => `${i.icon} dcg-option-icon`,
                        }),
                      )),
                    dr.createElement(es, {
                      content: i.title,
                      mqConfig: this.const({}),
                    }),
                  )
                  : dr.createElement(
                    "div",
                    {
                      role: dr.const("link"),
                      tabIndex: () => this.getTabIndex(i),
                      "aria-disabled": () => i.disabled,
                      "aria-selected": () => {
                        var n;
                        return (n = i.selected) == null ? void 0 : n.call(i);
                      },
                      id: this.const(i.key),
                      class: () => {
                        var n;
                        return {
                          [i.class || ""]: !!i.class,
                          "dcg-standard-link-styling": !i.class,
                          "dcg-dropdown-choice": true,
                          "dcg-disabled": i.disabled,
                          "dcg-selected": (n = i.selected) == null
                            ? void 0
                            : n.call(i),
                        };
                      },
                      onTap: () => !i.disabled && this.props.onTap(i),
                    },
                    dr.createElement(KI, {
                      predicate: () => i.icon != null,
                    }, () =>
                      dr.createElement(
                        "div",
                        { class: dr.const("dcg-option-icon-container") },
                        dr.createElement("i", {
                          "aria-hidden": dr.const("true"),
                          class: () => `${i.icon} dcg-option-icon`,
                        }),
                      )),
                    dr.createElement(
                      "span",
                      { class: dr.const("option-title") },
                      dr.createElement(es, {
                        content: i.title,
                        mqConfig: this.const({}),
                      }),
                    ),
                    Tce(() => i.subtitle && i.subtitle(), (n) =>
                      dr.createElement("span", {
                        class: dr.const("dcg-option-subtitle"),
                      }, n)),
                  )),
              dr.createElement(
                KI,
                {
                  predicate: () => !!o.explanations,
                },
                () =>
                  dr.createElement(
                    "div",
                    { class: dr.const("dcg-dropdown-explanations") },
                    dr.createElement(c$, {
                      each: () => o.explanations || [],
                      key: (i) => i.flag,
                    }, (i) =>
                      dr.createElement(
                        "div",
                        { class: dr.const("dcg-explanation") },
                        () => i.explanation,
                        dr.const(" "),
                        dr.createElement(KI, {
                          predicate: () => !!i.link,
                        }, () =>
                          dr.createElement("a", {
                            class: dr.const("learn-more"),
                            href: () => i.link !== void 0 ? i.link : "",
                            target: dr.const("_blank"),
                          }, () =>
                            i.linkText ? i.linkText : Ls(
                              "shared-button-learn-more-capitalized",
                            ))),
                      )),
                  ),
              ),
            )),
          (t = (e = this.props).buildFooter) == null ? void 0 : t.call(e),
        );
      }
      getTabIndex(e) {
        var t;
        return e.disabled && !((t = e.selected) != null && t.call(e)) ? -1 : 0;
      }
    };
  var { If: kce, IfElse: _ce } = oa.Components,
    V0 = class extends oa.Class {
      init() {
        var e, t;
        this.i18n = this.props.controller(),
          this.filter = (t = (e = this.props).defaultValue) == null
            ? void 0
            : t.call(e),
          this.shouldShowResults = false,
          this.uuid = Dd(),
          this.focusHelper = new ex({
            anchorSelector:
              `#dcg-select-dropdown-container-${this.props.id()} .dcg-dropdown-input`,
            popoverSelector:
              `#dcg-select-dropdown-container-${this.props.id()} .dcg-select-dropdown-list`,
            isOpen: () => this.isOpen(),
            closeMenu: () => this.setResultsOpen(false),
            itemNavigationKey: "arrow",
          });
      }
      handleKeyDown(e) {
        var t;
        switch (ke(e)) {
          case Kn:
            if (!this.isOpen()) {
              this.setResultsOpen(true), e.preventDefault();
              return;
            }
            break;
          case rl:
            if (this.isOpen()) {
              let o = this.focusHelper.getFocusedElement();
              o &&
                (this.selectOptionById(
                  (t = o.getAttribute("id")) != null ? t : void 0,
                ),
                  e.preventDefault());
              return;
            }
            break;
        }
        this.focusHelper.handleKeydown(e);
      }
      template() {
        return oa.createElement(
          "div",
          {
            class: oa.const("dcg-select-dropdown-container"),
            onKeyDown: this.bindFn(this.handleKeyDown),
            didMount: this.bindFn(this.attachTapListener),
            didUnmount: this.bindFn(this.unmountTapListener),
            id: () => `dcg-select-dropdown-container-${this.props.id()}`,
          },
          oa.createElement(
            "button",
            {
              class: () => ({
                "dcg-dropdown-input": true,
                "dcg-results-hidden": !this.isOpen(),
              }),
              "aria-haspopup": this.const("listbox"),
              "aria-expanded": () => this.isOpen(),
              onTap: this.bindFn(this.toggleResultsOpen),
              didMount: (e) => {
                var t, o;
                (o = (t = this.props).focusOnMount) != null &&
                  o.call(t) && e.focus();
              },
              id: this.props.id,
              manageFocus: () => {
                var e, t;
                return (t = (e = this.props).manageFocus) == null
                  ? void 0
                  : t.call(e);
              },
            },
            oa.createElement(es, {
              content: this.bindFn(this.getFilterString),
              mqConfig: this.const({}),
            }),
            _ce(() => this.isOpen(), {
              true: () =>
                oa.createElement("i", {
                  class: oa.const("dcg-icon-caret-up dcg-open-options"),
                  "aria-label": () =>
                    this.i18n.s("shared-calculator-button-hide-options"),
                }),
              false: () =>
                oa.createElement("i", {
                  class: oa.const("dcg-icon-caret-down dcg-open-options"),
                  "aria-label": () =>
                    this.i18n.s("shared-calculator-button-show-options"),
                }),
            }),
          ),
          oa.createElement(
            kce,
            { predicate: () => this.isOpen() },
            () =>
              oa.createElement(
                "div",
                {
                  class: oa.const(
                    "dcg-options-dropdown__padded-bottom-container",
                  ),
                },
                oa.createElement(WI, {
                  options: () => this.getOptions(),
                  onTap: (e) => this.selectOptionById(e.key),
                  class: this.const("dcg-select-dropdown-list"),
                  buildFooter: this.props.buildFooter,
                }),
              ),
          ),
        );
      }
      getOptions() {
        return this.props.options().map((e) => ({
          key: e.id,
          title: () => e.label,
          selected: () => e.label === this.getFilterString(),
          disabled: e.disabled,
          class: "dcg-select-dropdown-option",
        }));
      }
      isOpen() {
        return !!this.shouldShowResults;
      }
      setResultsOpen(e) {
        var t, o;
        if (
          this.shouldShowResults = e,
            this.update(),
            (o = (t = this.props).onOpenChange) == null || o.call(t, e),
            e
        ) {
          if (this.filter) {
            let i = this.props.options().find((n) => n.id === this.filter);
            this.focusOption(i);
          } else if (this.props.externalControl) {
            let i = this.props.externalControl().getValue(),
              n = this.props.options().find((a) => a.id === i);
            this.focusOption(n);
          } else this.focusHelper.focusFirstItem();
        }
      }
      toggleResultsOpen() {
        this.setResultsOpen(!this.shouldShowResults);
      }
      focusOption(e) {
        if (!e) return;
        let t = document.querySelector(
          `#dcg-select-dropdown-container-${this.props.id()} .dcg-select-dropdown-list #${e.id}`,
        );
        t == null || t.focus();
      }
      onInputChange(e) {
        this.props.externalControl
          ? this.props.externalControl().onValueChange(e)
          : this.filter = e, this.update();
      }
      getFilterString() {
        let t = this.props.options().find((o) =>
          o.id ===
            (this.props.externalControl
              ? this.props.externalControl().getValue()
              : this.filter)
        );
        return (t == null ? void 0 : t.label) || "";
      }
      selectOptionById(e) {
        var i, n;
        let o = this.props.options().find((a) => a.id === e);
        o &&
          (this.onInputChange(o.id),
            this.setResultsOpen(false),
            this.focusHelper.focusAnchor(),
            (n = (i = this.props).onChange) == null || n.call(i, o.id));
      }
      unmountTapListener() {
        ee(document.body).off(
          `dcg-tapstart.dcg-select-dropdown-container-${this.uuid}`,
        );
      }
      attachTapListener() {
        ee(document.body).on(
          `dcg-tapstart.dcg-select-dropdown-container-${this.uuid}`,
          this.bindFn(this.tapListener),
        );
      }
      tapListener(e) {
        e.target.closest(
          `#dcg-select-dropdown-container-${this.props.id()}`,
        ) || this.setResultsOpen(false);
      }
    };
  Ss();
  function d$(r) {
    switch (r) {
      case void 0:
      case "IDLE":
      case "UNPUBLISHED":
      case "RESOLVED":
        return false;
      case "ANALYZING":
      case "GRAPHING":
        return true;
      default:
        throw new Error(`Unexpected progress status: ${r}`);
    }
  }
  var aj = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var O0 = class {
    constructor(e) {
      this.active = false, this.controller = e;
      let t = this.controller.getExppanelElt();
      t && (this.exppanel = t);
    }
    startDragging(e) {
      this.active = true, this.mousePt = e, this.setupEventListeners();
    }
    applyDrag() {
      var w;
      let t = this.controller.getListModel().dragState;
      if (!t) return;
      this.scheduleUpdateScroll();
      let o = this.measureDOM(t);
      if (!o) return;
      let { floatingPreviewRect: i, dragState: n, visibleRects: a } = o,
        s = this.controller.getItemModel(n.firstItemId);
      if (!s) return;
      let l = s.index, c = a[0];
      if (c && c.id !== s.id) {
        let S = this.controller.getItemModel(c.id);
        S && S.index > l && (l = S.index - 1);
      }
      let {
        cachedNamedAssignmentLatex: d,
        cachedTokenAssignmentLatex: p,
      } = n;
      for (let { id: S, rect: k } of a) {
        if (S === s.id) continue;
        let _ = this.controller.getItemModel(S);
        if (!_) return;
        if (_.index < s.index) {
          if (i.top < k.top + k.height / 2) {
            l = _.index;
            break;
          }
        } else {i.bottom > k.top + k.height / 2 &&
            (l = _.index,
              _.type === "folder" && _.collapsed &&
              (l += this.controller.getNumberOfItemsInFolder(_.id)));}
      }
      let h, u;
      l > s.index
        ? (h = l, u = l + 1)
        : l < s.index
        ? (h = l - 1, u = l)
        : (h = l - 1, u = l + 1);
      let f = this.controller.getItemModelByIndex(h),
        y = this.controller.getItemModelByIndex(u),
        C = "",
        E = "";
      f && (f.type === "folder" ? C = f.id : C = f.folderId),
        y && (y.type === "folder" ? E = y.id : E = y.folderId);
      let v = "";
      if (
        C &&
        (E === C
          ? s.type === "folder" ? l = s.index : v = C
          : s.type !== "folder" &&
            this.isPreviewTopContainedInFolder(o, C) && (v = C)),
          s.type === "expression"
      ) {
        if (n.renderType === "token") {
          if (
            t.renderType === "expression" &&
            (d = s.latex, this.controller.convertToTokenAssignment(s, p)),
              n.dragTarget.type === "token"
          ) {
            l = n.dragTarget.originalIndex,
              v = ((w = this.controller.getGeometryFolder()) == null
                ? void 0
                : w.id) || "";
          } else if (n.dragTarget.type === "expression") {
            let S = this.controller.getGeometryFolder();
            if (S) {
              let k = this.controller.getNumberOfItemsInFolder(S.id);
              s.type === "expression" && s.folderId === S.id && (k -= 1),
                l = S.index + k + 1,
                v = S.id;
            }
          }
        } else {n.renderType === "expression" &&
            t.renderType === "token" &&
            (p = s.latex, this.controller.convertToNamedAssignment(s, d));}
      }
      return {
        dragState: {
          ...n,
          cachedNamedAssignmentLatex: d,
          cachedTokenAssignmentLatex: p,
        },
        newIndex: l,
        folderId: v,
      };
    }
    measureDOM(e) {
      var A;
      let t = {
          x: ((A = Tm(this.controller)) == null ? void 0 : A.left) || 0,
          y: a$(this.controller),
        },
        o = s$(this.controller),
        i = l$(this.controller);
      if (t.y === void 0 || !o || !i) return;
      let n = o.height,
        a = i.height,
        s = false,
        l = this.controller.getExppanelElt(),
        c = l == null
          ? void 0
          : l.querySelector(".dcg-template-expressioneach"),
        d = c == null ? void 0 : c.getBoundingClientRect();
      d && d.top <= e.mousePt.y && (s = true);
      let p = false,
        h = l == null
          ? void 0
          : l.querySelector(".dcg-geo-show-constructions-pane"),
        u = h == null ? void 0 : h.getBoundingClientRect();
      u && u.bottom > e.mousePt.y && (p = true);
      let f = false;
      (e.dragTarget.type === "token" && !s ||
        e.dragTarget.type === "expression" && p && !s &&
          this.controller.canDraggedItemBeMovedIntoTokenPane()) &&
        (f = true);
      let y = e.grabOffset;
      f
        ? y = { x: i.width / 2 + 2.5, y: i.height / 2 }
        : e.dragTarget.type === "token" &&
          (y = { x: 0, y: i.height / 2 });
      let C = e.mousePt.y - y.y,
        E = __dcg_shared_module_exports__["clamp"](C - t.y, -a / 2, n - a),
        v = 0;
      f &&
        (v = __dcg_shared_module_exports__["clamp"](
          e.mousePt.x - y.x - t.x,
          0,
          o.width - i.width - 4,
        ),
          E = Math.max(E, 2));
      let w = { left: v, top: C, bottom: C + a, height: a },
        S = this.controller.findFirstVisibleItem(),
        k = this.controller.findLastVisibleItem(),
        _ = [];
      if (S && k) {
        for (let P = S.index; P <= k.index; P++) {
          let O = this.controller.getItemModelByIndex(P);
          if (!O) continue;
          let U = this.controller.getItemRootNodeById(O.id);
          if (U && O.id !== e.firstItemId) {
            let z = U.getBoundingClientRect();
            _.push({ id: O.id, rect: z });
          }
        }
      }
      return {
        dragState: {
          ...e,
          itemTop: E,
          itemLeft: v,
          renderType: f ? "token" : "expression",
        },
        floatingPreviewRect: w,
        visibleRects: _,
      };
    }
    isPreviewTopContainedInFolder(e, t) {
      let { visibleRects: o, floatingPreviewRect: i } = e;
      for (let { id: n, rect: a } of o) {
        if (a.top <= i.top && a.bottom >= i.top) {
          let s = this.controller.getItemModel(n);
          if (!s) return false;
          if (
            s.type === "folder" && s.id === t ||
            s.type !== "folder" && s.folderId === t
          ) return true;
        }
      }
      return false;
    }
    scheduleUpdateScroll() {
      this.updateScrollScheduled ||
        (this.updateScrollScheduled = true,
          requestAnimationFrame(() => {
            this.updateScroll(), this.updateScrollScheduled = false;
          }));
    }
    stop() {
      this.active = false,
        this.tearDownEventListeners(),
        this.controller.dispatch({ type: "stop-dragdrop" });
    }
    setupEventListeners() {
      ee(document).on("dcg-tapmove.dragdrop", (e) => {
        this.mousePt.x = e.changedTouches[0].clientX,
          this.mousePt.y = e.changedTouches[0].clientY,
          this.controller.dispatch({
            type: "update-dragdrop",
            mousePt: this.mousePt,
          });
      }),
        ee(document).on("dcg-tapend.dragdrop", (e) => {
          this.stop(), e.handle("dragdrop");
        });
    }
    tearDownEventListeners() {
      ee(document).off(".dragdrop");
    }
    updateScroll() {
      if (!this.active) return;
      let e = this.exppanel.getBoundingClientRect(), t = 0;
      t = Math.min(t, this.mousePt.y - e.top),
        t = Math.max(t, this.mousePt.y - e.bottom + 30),
        t = t * e.height / 900,
        t && (this.exppanel.scrollTop = this.exppanel.scrollTop + t);
    }
  };
  function p$(r, e, t) {
    let i = .5 / (2 * t * e);
    return ho(r - i, r + i);
  }
  function R0(r, e, t, o, i = 0) {
    let n = __dcg_shared_module_exports__["U"](
      r.x,
      r.y,
      0,
      t[0],
      t[1],
      0,
      o[0],
      o[1],
      0,
    );
    i && (n += i);
    let s = .5 / (__dcg_shared_module_exports__["distance"](t, o) * e);
    return ho(n - s, n + s);
  }
  function Rc(r, e) {
    for (let t of e) {
      t &&
        (t.min !== void 0 && r < t.min
          ? r = t.min
          : t.max !== void 0 && r > t.max && (r = t.max));
    }
    return r;
  }
  function $I(r, e, t, o) {
    if (!t) return 0;
    let i = r.mapx(1) - r.mapx(0);
    switch (t.valueType) {
      case __dcg_shared_module_exports__["Circle"]: {
        let a = e.x - t.value[0][0],
          s = e.y - t.value[0][1],
          l = Math.atan2(s, a) / (2 * Math.PI);
        l < 0 && (l += 1), l = p$(l, i, t.value[1]);
        let c = Rc(0, [o]), d = Rc(1, [o]);
        if (l >= c && l <= d) return l;
        {
          let p = __dcg_shared_module_exports__["circleGlider"](t.value, c),
            h = __dcg_shared_module_exports__["circleGlider"](t.value, d),
            u = __dcg_shared_module_exports__["distance"](p, [e.x, e.y]),
            f = __dcg_shared_module_exports__["distance"](h, [e.x, e.y]);
          return u <= f ? c : d;
        }
      }
      case __dcg_shared_module_exports__["Arc"]: {
        let a = __dcg_shared_module_exports__["getArcDetails"](t.value);
        if (!a) return 0;
        if (a.type === "segment") {
          let s = R0(e, i, a.start, a.end);
          return Rc(s, [{ min: 0, max: 1 }, o]);
        } else if (a.type === "rays") {
          let s = __dcg_shared_module_exports__["distance"](a.start1, [
              e.x,
              e.y,
            ]),
            l = __dcg_shared_module_exports__["distance"](a.start2, [e.x, e.y]),
            c = !o || o.min === void 0 ? -1 / 0 : o.min,
            d = !o || o.max === void 0 ? 1 / 0 : o.max;
          return s < l
            ? c > 0 ? d >= 1 ? 1 : c : Rc(-R0(e, i, a.start1, a.end1), [
              { min: void 0, max: 0 },
              o,
            ])
            : d < 1
            ? c <= 0 ? 0 : d
            : Rc(R0(e, i, a.start2, a.end2, 1), [
              { min: 1, max: void 0 },
              o,
            ]);
        } else if (a.type == "arc") {
          let [s, l] = a.center,
            { radius: c, startAngle: d } = a,
            p = __dcg_shared_module_exports__["arcOmega"](t.value),
            h = e.x - s,
            u = e.y - l,
            f = __dcg_shared_module_exports__["P"](
              Math.atan2(u, h),
              d,
              p,
            );
          if (f >= 0 && f <= 1) f = p$(f, i, c);
          else {
            let E = lk(e, {
                x: s + c * Math.cos(d),
                y: l + c * Math.sin(d),
              }),
              v = lk(e, {
                x: s + c * Math.cos(d + p),
                y: l + c * Math.sin(d + p),
              });
            E <= v ? f = 0 : f = 1;
          }
          let y = Rc(0, [o]), C = Rc(1, [o]);
          if (f >= y && f <= C) return f;
          {
            let E = __dcg_shared_module_exports__["arcGlider"](t.value, y),
              v = __dcg_shared_module_exports__["arcGlider"](t.value, C),
              w = __dcg_shared_module_exports__["distance"](E, [e.x, e.y]),
              S = __dcg_shared_module_exports__["distance"](v, [e.x, e.y]);
            return w <= S ? y : C;
          }
        }
        return Rc(0, [o]);
      }
      case __dcg_shared_module_exports__["Ray"]:
      case __dcg_shared_module_exports__["Segment"]:
      case __dcg_shared_module_exports__["Line"]: {
        let a = R0(e, i, t.value[0], t.value[1]);
        return Rc(a, [{
          min: t.valueType === __dcg_shared_module_exports__["Line"]
            ? void 0
            : 0,
          max: t.valueType !== __dcg_shared_module_exports__["Segment"]
            ? void 0
            : 1,
        }, o]);
      }
      case __dcg_shared_module_exports__["Polygon"]: {
        let a = t.value,
          s = 1 / 0,
          l = Rc(0, [o]),
          c = o && o.min !== void 0 ? o.min : -1 / 0,
          d = o && o.max !== void 0 ? o.max : 1 / 0,
          p = Math.floor(Math.max(c, 0)),
          h = Math.ceil(Math.min(d, a.length));
        for (let u = p; u < h; u++) {
          let f = a[u],
            y = a[(u + 1) % a.length],
            C = Rc(R0(e, i, f, y, u), [{ min: u, max: u + 1 }, o]),
            E = __dcg_shared_module_exports__["polygonGlider"](t.value, C),
            v = __dcg_shared_module_exports__["distance"](E, [e.x, e.y]);
          v < s && (s = v, l = C);
        }
        return l;
      }
      case __dcg_shared_module_exports__["Point"]:
      case __dcg_shared_module_exports__["AngleMarker"]:
      case __dcg_shared_module_exports__["DirectedAngleMarker"]:
      case __dcg_shared_module_exports__["Transformation"]:
      case __dcg_shared_module_exports__["Vector"]:
        return 0;
      default:
        return t;
    }
  }
  function u$(r, e) {
    switch (r.valueType) {
      case __dcg_shared_module_exports__["Circle"]:
        return __dcg_shared_module_exports__["circleGlider"](r.value, e);
      case __dcg_shared_module_exports__["Arc"]:
        return __dcg_shared_module_exports__["arcGlider"](r.value, e);
      case __dcg_shared_module_exports__["Ray"]:
        return __dcg_shared_module_exports__["rayGlider"](r.value, e);
      case __dcg_shared_module_exports__["Segment"]:
        return __dcg_shared_module_exports__["segmentGlider"](r.value, e);
      case __dcg_shared_module_exports__["Line"]:
        return __dcg_shared_module_exports__["lineGlider"](r.value, e);
      case __dcg_shared_module_exports__["Polygon"]:
        return __dcg_shared_module_exports__["polygonGlider"](r.value, e);
      case __dcg_shared_module_exports__["Point"]:
      case __dcg_shared_module_exports__["AngleMarker"]:
      case __dcg_shared_module_exports__["DirectedAngleMarker"]:
      case __dcg_shared_module_exports__["Transformation"]:
      case __dcg_shared_module_exports__["Vector"]:
        return [NaN, NaN];
      default:
        return r;
    }
  }
  function Ice(r, e) {
    if (!e) return false;
    let { left: t, right: o, top: i, bottom: n } = r.pixelCoordinates,
      { x: a, y: s } = e.mathPoint;
    if (e.transform) {
      let l = e.model.formula.typed_constant_value;
      if (
        (l == null ? void 0 : l.valueType) !==
          __dcg_shared_module_exports__["Point"]
      ) {
        throw new Error(
          `Expected movable point to be a Point but found ${
            l ? __dcg_shared_module_exports__["repr"](l.valueType) : void 0
          } instead`,
        );
      }
      a = a != null ? a : l.value[0],
        s = s != null ? s : l.value[1],
        [a, s] = __dcg_shared_module_exports__["transformPoint"](
          e.transform.forward,
          [a, s],
        );
    }
    if (a !== void 0) {
      let l = r.mathToPixels.mapX(a);
      if (l < t - .5 || l > o + .5) return false;
    }
    if (s !== void 0) {
      let l = r.mathToPixels.mapY(s);
      if (l < i - .5 || l > n + .5) return false;
    }
    return true;
  }
  function h$(r, e) {
    if (e.length === 1 && !Ice(r, e[0])) return false;
    let t = false;
    for (let o of e) {
      if (o.newPointLatex) {
        let i = o.model.latex;
        $a(o.model, o.newPointLatex), t = t || i !== o.model.latex;
      }
      for (let i in o.sliderUpdates) {
        let { value: n, model: a } = o.sliderUpdates[i];
        o.commitSliderSoftLimits && yb(a);
        let s = a.latex;
        QE(a, n), t = t || s !== a.latex;
      }
    }
    return t;
  }
  function g$(
    {
      projection: r,
      transform: e,
      controller: t,
      strategy: o,
      mode: i,
      clampToViewport: n,
    },
  ) {
    var S;
    let a = t.getItemModel(o.id);
    if (!a || a.type !== "expression") {
      throw new Error(
        `Programming error: updateSliderNonlinear move strategy should point to an expression item, but found ${
          a == null ? void 0 : a.type
        }`,
      );
    }
    let s = i === "up" || i === "bigup",
      l = ((S = a.slider) == null ? void 0 : S.step) !== "" &&
        (s && !a.slider.hardMax || !s && !a.slider.hardMin);
    o.compiled.fn || __dcg_shared_module_exports__["vc"](o.compiled);
    let c = o.compiled.fn;
    e &&
      (c = (k) =>
        __dcg_shared_module_exports__["transformPoint"](
          e.forward,
          o.compiled.fn(k),
        ));
    let d = (k) => {
        let [_, A] = c(k);
        return { x: _, y: A } = r.mathToPixels.mapPoint({ x: _, y: A }), [_, A];
      },
      p = al(a),
      [h, u] = d(p),
      f = dL(a, i, { ignoreSoftLimits: l }),
      y = f,
      [C, E] = d(y),
      v = __dcg_shared_module_exports__["MathHypot"](C - h, E - u);
    if (v < 1) {
      let k = __dcg_shared_module_exports__["aa"](
        d,
        [h + (C - h) / v, u + (E - u) / v],
        y,
        y > p ? y : o.min,
        y < p ? y : o.max,
        1,
      );
      if (k) {
        let _ = ho(k[0], k[1]);
        (i === "bigup" || i === "bigdown") && (_ = p + (_ - p) * 5);
        let A = Ol(
            a,
            __dcg_shared_module_exports__["$"](_, o.min, o.max),
            { ignoreSoftLimits: l },
          ),
          [P, O] = d(A);
        __dcg_shared_module_exports__["MathHypot"](P - h, O - u) > v && (f = A);
      }
    }
    n && (f = f$(r, al(a), f, c));
    let w = c(f);
    return {
      mathPoint: { x: w[0], y: w[1] },
      sliderUpdates: { [o.id]: { model: a, value: f } },
    };
  }
  function m$(
    {
      controller: r,
      projection: e,
      transform: t,
      strategy: o,
      targetScreenPoint: i,
      clampToViewport: n,
    },
  ) {
    let a = { mathPoint: {}, sliderUpdates: {} },
      s = r.getItemModel(o.id);
    if (!s || s.type !== "expression") {
      throw new Error(
        `Programming error: updateSliderNonlinear move strategy should point to an expression item, but found ${
          s == null ? void 0 : s.type
        }`,
      );
    }
    o.compiled.fn || __dcg_shared_module_exports__["vc"](o.compiled);
    let l = o.compiled.fn;
    t &&
      (l = (w) =>
        __dcg_shared_module_exports__["transformPoint"](
          t.forward,
          o.compiled.fn(w),
        ));
    let c = (w) => {
        let [S, k] = l(w);
        return { x: S, y: k } = e.mathToPixels.mapPoint({ x: S, y: k }), [S, k];
      },
      d = o.initialValue,
      p = o.min,
      h = o.max,
      u = [i.x, i.y],
      f = __dcg_shared_module_exports__["aa"](c, u, d, p, h, 1);
    if (!f) return a;
    let y = ho(f[0], f[1]);
    p !== void 0 && y < p && (y = p), h !== void 0 && y > h && (y = h);
    let C = Ol(s, y, { ignoreSoftLimits: true });
    n && (C = f$(e, al(s), C, l));
    let [E, v] = l(C);
    return a.mathPoint.x = E,
      a.mathPoint.y = v,
      a.sliderUpdates[s.id] = { value: C, model: s },
      a;
  }
  function JO(
    {
      controller: r,
      projection: e,
      transform: t,
      strategy: o,
      targetScreenPoint: i,
    },
  ) {
    let n = e.reverse_map_pt(i);
    if (t) {
      let d = __dcg_shared_module_exports__["transformPoint"](t.inverse, [
        n.x,
        n.y,
      ]);
      n = { x: d[0], y: d[1] };
    }
    let a = o.type === "updateSliderForGlider"
        ? { min: o.min, max: o.max }
        : void 0,
      s = $I(e, n, o.movesOn, a);
    if (!isFinite(s)) return;
    let l = u$(o.movesOn, s),
      c = {
        mathPoint: { x: l[0], y: l[1] },
        newPointLatex: void 0,
        sliderUpdates: {},
      };
    if (o.type === "updateGliderParameter") {
      let d = o.span;
      c.newPointLatex = d.input.slice(0, d.start) +
        __dcg_shared_module_exports__["ce"](s) + d.input.slice(d.end);
    } else if (o.type === "updateSliderForGlider") {
      let d = r.getItemModel(o.id);
      d && d.type === "expression" &&
        (c.sliderUpdates[d.id] = { value: s, model: d });
    }
    return c;
  }
  function f$(r, e, t, o) {
    let i = (d) => {
        let [p, h] = o(d);
        return r.mathToPixels.mapPoint({ x: p, y: h });
      },
      n = ({ x: d, y: p }) => {
        let { left: h, right: u, top: f, bottom: y } = r.pixelCoordinates;
        return d >= h && d <= u && p >= f && p <= y;
      },
      a = e,
      s = i(e),
      l = t,
      c = i(t);
    if (n(c) || !n(s)) return t;
    for (;;) {
      let d = s.x - c.x, p = s.y - c.y;
      if (d * d + p * p < .5) break;
      let h = __dcg_shared_module_exports__["_"](a, l);
      if (h === a || h === l) {
        [a, l] = n(s) ? [a, a] : [l, l];
        break;
      }
      let u = i(h);
      n(u) !== n(s) ? [l, c] = [h, u] : [a, s] = [h, u];
    }
    return ho(a, l);
  }
  function QO(
    {
      controller: r,
      projection: e,
      transform: t,
      formula: o,
      moveStrategy: i,
      dragMode: n,
      targetScreenPoint: a,
      clampToViewport: s,
    },
  ) {
    if (t) {
      let { x: u, y: f } = e.pixelsToMath.mapPoint(a),
        [y, C] = __dcg_shared_module_exports__["transformPoint"](t.inverse, [
          u,
          f,
        ]);
      a = e.mathToPixels.mapPoint({ x: y, y: C });
    }
    let l = e.pixelsToMath.mapRect({
        left: a.x - .5,
        right: a.x + .5,
        top: a.y + .5,
        bottom: a.y - .5,
      }),
      c = [{ min: l.left, max: l.right }, { min: l.top, max: l.bottom }],
      d = { mathPoint: {}, sliderUpdates: {} },
      [p, h] = i;
    if (p.type === "updateCoordinate" || h.type === "updateCoordinate") {
      let u = Ace(o, c, n);
      if (u) {
        let { latex: f, x: y, y: C } = u;
        (y !== void 0 || C !== void 0) &&
          (d.newPointLatex = f,
            d.mathPoint.x = y != null ? y : d.mathPoint.x,
            d.mathPoint.y = C != null ? C : d.mathPoint.y);
      }
    }
    for (let u of [0, 1]) {
      let f = i[u];
      if (F0(u, n) && f.type === "updateSlider") {
        let y = r.getItemModel(f.id);
        if (!y || y.type !== "expression") continue;
        let [C, E] = f.coefficients,
          v = ho(E * c[u].min + C, E * c[u].max + C),
          w = Ol(y, v, { ignoreSoftLimits: true }),
          S = (w - C) / E;
        if (!s || t) {
          d.mathPoint[u === 0 ? "x" : "y"] = S,
            d.sliderUpdates[y.id] = { value: w, model: y };
          continue;
        }
        let [k, _] = u === 0
            ? [e.mathCoordinates.left, e.mathCoordinates.right]
            : [e.mathCoordinates.bottom, e.mathCoordinates.top],
          A = S < k ? k : S > _ ? _ : void 0;
        A !== void 0 && Rl(y) === void 0
          ? (d.mathPoint[u === 0 ? "x" : "y"] = A,
            d.sliderUpdates[y.id] = { value: E * A + C, model: y })
          : (d.mathPoint[u === 0 ? "x" : "y"] = S,
            d.sliderUpdates[y.id] = { value: w, model: y });
      }
    }
    return d;
  }
  function Ace(r, e, t) {
    var h;
    if (!r.move_strategy) {
      throw new Error(
        "Programming error: expected move_strategy to be defined.",
      );
    }
    let o = ho(e[0].min, e[0].max),
      i = ho(e[1].min, e[1].max),
      [n, a] = r.move_strategy;
    if (
      ((h = r.typed_constant_value) == null ? void 0 : h.valueType) ===
        __dcg_shared_module_exports__["Complex"] &&
      n.type === "updateCoordinate" && a.type === "updateCoordinate"
    ) {
      let [u, f] = r.typed_constant_value.value,
        y = F0(0, t),
        C = F0(1, t),
        E = y ? o : u,
        v = C ? i : f,
        w = n.inputSpan;
      return {
        latex: w.input.slice(0, w.start) +
          __dcg_shared_module_exports__["complexNumberLabel"]([E, v], {
            alwaysEmitImaginary: true,
          }) + w.input.slice(w.end),
        x: y ? o : void 0,
        y: C ? i : void 0,
      };
    }
    let s = false, l = false, c, d = "", p = 0;
    if (
      n.type === "updateCoordinate" && F0(0, t) &&
      (c = n.inputSpan.input,
        s = true,
        d += c.slice(p, n.inputSpan.start),
        d += __dcg_shared_module_exports__["ce"](o),
        p = n.inputSpan.end),
        a.type === "updateCoordinate" && F0(1, t) &&
        (c = a.inputSpan.input,
          l = true,
          d += c.slice(p, a.inputSpan.start),
          d += __dcg_shared_module_exports__["ce"](i),
          p = a.inputSpan.end),
        c !== void 0
    ) {
      return d += c.slice(p),
        { latex: d, x: s ? o : void 0, y: l ? i : void 0 };
    }
  }
  function F0(r, e) {
    switch (e) {
      case "X":
        return r === 0;
      case "Y":
        return r === 1;
      case "XY":
        return true;
      default:
        return false;
    }
  }
  function b$(r, e, t) {
    t.forEach((o) => {
      Mce(r, e, o);
    });
  }
  function y$(r, e, t, o, i, n, a) {
    var d;
    let s = false, l = e.length === 1, c = [];
    for (let p = 0; p < e.length; p++) {
      let h = e[p];
      if (h.tableInfo) {
        Lce(r, h, o[p], i), s = true;
        continue;
      }
      let u = r.getItemModel(h.calcId);
      if (u) {
        if (u.type === "image") s = s || Oce(r, u, h, o[p], i);
        else if (u.type === "expression") {
          let f = Rce({
            controller: r,
            movedExpr: u,
            dragMode: (d = Ro(u, { isReverseDrag: h.isReverseDrag })) != null
              ? d
              : "NONE",
            currentScreenPoint: t[p],
            targetScreenPoint: o[p],
            projection: i,
            transform: n && n[p],
            isOnlyPoint: l,
            keyboardDirection: a,
          });
          f && c.push(f);
        }
      }
    }
    return s = s || h$(i, c), s;
  }
  function x$(r, e) {
    e.forEach((t) => {
      Gce(r, t);
    });
  }
  function Mce(r, e, t) {
    if (t.tableInfo) {
      Nr(e, void 0);
      let o = r.getItemModel(t.tableInfo.tableId);
      if (!o || o.type !== "table") return;
      RG(o, true);
    } else {
      let o = r.getItemModel(t.calcId);
      if (
        !o || !(o.type === "expression" || o.type === "image") ||
        !o.formula || !o.formula.move_strategy
      ) return;
      let i = o.formula.move_strategy;
      for (let n = 0; n < i.length; n++) {
        let a = i[n];
        if (
          i[n].type === "updateCoordinate" ||
          i[n].type === "updateGliderParameter"
        ) {
          o.type === "image"
            ? $G(o, true)
            : o.type === "expression" && gL(o, true);
        } else if (
          a.type === "updateSlider" ||
          a.type === "updateSliderNonlinear" ||
          a.type === "updateSliderForGlider"
        ) {
          let s = r.getItemModel(a.id);
          if (!s || s.type !== "expression") continue;
          let l;
          if (
            o.type === "expression"
              ? l = Ro(o, { isReverseDrag: t.isReverseDrag })
              : l = void 0,
              l === "NONE" || n === 0 && l === "Y" || n === 1 && l === "X"
          ) continue;
          Ww(s, true);
        }
      }
    }
  }
  function Gce(r, e) {
    for (let t of r.getAllItemModels()) {
      t.type === "table"
        ? t.draggingOnGraphpaper && RG(t, false)
        : t.type === "expression"
        ? (t.sliderDragging && Ww(t, false),
          t.draggingOnGraphpaper && gL(t, false))
        : t.type === "image" && t.draggingOnGraphpaper && $G(t, false);
    }
  }
  function Lce(r, e, t, o) {
    let i = e.tableInfo.tableId,
      n = e.tableInfo.rowIndex,
      a = e.tableInfo.columnId,
      s = e.tableInfo.dragX,
      l = e.tableInfo.dragY,
      c = r.getItemModel(i);
    if (!c || c.type !== "table") return;
    let d = Eo(c, a);
    if (!d) return;
    let p = o.closestPointOnScreen(t),
      h = o.pixelsToMath.mapRect(w$(p, .5)),
      u = {
        x: __dcg_shared_module_exports__["be"](ho(h.left, h.right)),
        y: __dcg_shared_module_exports__["be"](ho(h.top, h.bottom)),
      };
    if (s && vp(c, { row: n + 1, column: 0 }, u.x), l) {
      let f = d.index;
      vp(c, { row: n + 1, column: f }, u.y);
    }
  }
  function w$(r, e) {
    return {
      left: r.x - e,
      right: r.x + e,
      top: r.y + e,
      bottom: r.y - e,
    };
  }
  function Pce(r, e, t) {
    if (t[0] === 0 && t[1] === 0) {
      return { x: e.x, y: e.y, width: r.width, height: r.height };
    }
    let o = Math.cos(r.radianAngle),
      i = Math.sin(r.radianAngle),
      n = e.x - r.x,
      a = e.y - r.y;
    if (t[0] === 0) {
      return {
        x: r.x,
        y: r.y,
        width: r.width,
        height: 2 * t[1] * (o * a + i * n),
      };
    }
    if (t[1] === 0) {
      return {
        x: r.x,
        y: r.y,
        width: 2 * t[0] * (o * n - i * a),
        height: r.height,
      };
    }
    let s = 2 *
      (r.width * t[0] * (o * n - i * a) +
        r.height * t[1] * (i * n + o * a)) /
      (r.width * r.width + r.height * r.height);
    return { x: r.x, y: r.y, width: s * r.width, height: s * r.height };
  }
  function Vce(r, e, t) {
    let o = [{ x: e.left, y: e.bottom }, { x: e.left, y: e.top }, {
        x: e.right,
        y: e.top,
      }, { x: e.right, y: e.bottom }],
      i = ["x", "y", "width", "height"],
      n = { x: 1 / 0, y: 1 / 0, width: 1 / 0, height: 1 / 0 },
      a = { x: -1 / 0, y: -1 / 0, width: -1 / 0, height: -1 / 0 };
    for (let s of o) {
      let l = Pce(r, s, t);
      for (let c of i) {
        n[c] = Math.min(n[c], l[c]), a[c] = Math.max(a[c], l[c]);
      }
    }
    return { min: n, max: a };
  }
  function N0(r) {
    return r === void 0 ? NaN : r[0];
  }
  function Oce(r, e, t, o, i) {
    var k;
    let n = e.formula;
    if (!n || ((k = n.move_strategy) == null ? void 0 : k.length) !== 4) {
      return false;
    }
    let a = n.dimensions,
      s = {
        x: N0(a.x),
        y: N0(a.y),
        width: N0(a.width),
        height: N0(a.height),
        radianAngle: N0(a.radianAngle),
      },
      l = t.scaleFactor || [0, 0],
      c = l[0] !== 0 && l[1] !== 0,
      d = i.closestPointOnScreen(o),
      p = i.pixelsToMath.mapRect(w$(d, c ? .05 : .5)),
      h = Vce(s, p, l),
      u = i.mathToPixels.mapRect({
        left: s.x - .5 * s.width,
        right: s.x + .5 * s.width,
        top: s.y - .5 * s.height,
        bottom: s.y + .5 * s.height,
      }),
      f = Math.abs(u.right - u.left),
      y = Math.abs(u.bottom - u.top),
      C = i.mathToPixels.mapRect({
        left: h.min.x - .5 * h.min.width,
        right: h.min.x + .5 * h.min.width,
        top: h.min.y - .5 * h.min.height,
        bottom: h.min.y + .5 * h.min.height,
      }),
      E = Math.abs(C.right - C.left),
      v = Math.abs(C.bottom - C.top);
    if (E < f && E < 1 || v < y && v < 1) return false;
    let w = ["width", "height", "x", "y"], S = false;
    for (let _ = 0; _ < w.length; _++) {
      let A = w[_], P = n.move_strategy[_];
      switch (P.type) {
        case "updateCoordinate":
          let O = ho(h.min[A], h.max[A]),
            U = P.inputSpan.input,
            z = __dcg_shared_module_exports__["be"](O);
          switch (A) {
            case "width":
            case "height":
              ks(e, A, z);
              break;
            case "x":
              if (n.move_strategy[3].type === "updateCoordinate") {
                let L = n.move_strategy[3],
                  V = ho(h.min.y, h.max.y),
                  R = __dcg_shared_module_exports__["be"](V),
                  N = U.slice(0, P.inputSpan.start) + z +
                    U.slice(P.inputSpan.end, L.inputSpan.start) + R +
                    U.slice(L.inputSpan.end);
                ks(e, "center", N);
              } else {
                let L = U.slice(0, P.inputSpan.start) + z +
                  U.slice(P.inputSpan.end);
                ks(e, "center", L);
              }
              break;
            case "y":
              if (n.move_strategy[2].type !== "updateCoordinate") {
                let L = U.slice(0, P.inputSpan.start) + z +
                  U.slice(P.inputSpan.end);
                ks(e, "center", L);
              }
              break;
            default:
              return A;
          }
          S = true;
          break;
        case "updateSlider":
          {
            let x = r.getItemModel(P.id);
            if (!x || x.type !== "expression") continue;
            let L = P.coefficients[0],
              V = P.coefficients[1],
              R = V * h.min[A] + L,
              N = V * h.max[A] + L,
              M = ho(R, N),
              F = x.latex;
            QE(x, M), x.latex !== F && (S = true);
          }
          break;
      }
    }
    return S;
  }
  function Rce(
    {
      controller: r,
      movedExpr: e,
      dragMode: t,
      currentScreenPoint: o,
      targetScreenPoint: i,
      projection: n,
      transform: a,
      isOnlyPoint: s,
      keyboardDirection: l,
    },
  ) {
    var f, y;
    let c = e.formula;
    if (!c || ((f = c.move_strategy) == null ? void 0 : f.length) !== 2) {
      return;
    }
    let [d, p] = c.move_strategy;
    if (
      s && d.type === "updateCoordinate" && p.type === "updateCoordinate"
    ) {
      let C = n.reverse_map_pt(i), E = ZO(n, C);
      E && (i = n.map_pt(E));
    }
    let h = s ? n.closestPointOnScreen(i) : i;
    if (!l) {
      let C;
      switch (d.type) {
        case "updateSliderNonlinear":
          C = m$({
            controller: r,
            projection: n,
            transform: a,
            strategy: d,
            targetScreenPoint: h,
            clampToViewport: s,
          });
          break;
        case "updateGliderParameter":
        case "updateSliderForGlider":
          C = JO({
            controller: r,
            projection: n,
            transform: a,
            strategy: d,
            targetScreenPoint: h,
          });
          break;
        default:
          C = QO({
            controller: r,
            projection: n,
            transform: a,
            formula: c,
            moveStrategy: c.move_strategy,
            dragMode: t,
            targetScreenPoint: h,
            clampToViewport: s,
          });
      }
      return C &&
        { ...C, commitSliderSoftLimits: false, transform: a, model: e };
    }
    let u;
    if (d.type === "updateSliderNonlinear") {
      if (!(l != null && l.x)) return;
      u = g$({
        projection: n,
        transform: a,
        controller: r,
        strategy: d,
        mode: l.x,
        clampToViewport: s,
      });
    } else if (
      d.type === "updateGliderParameter" ||
      d.type === "updateSliderForGlider"
    ) {
      u = JO({
        controller: r,
        projection: n,
        transform: a,
        strategy: d,
        targetScreenPoint: h,
      });
    } else {
      let C = l.x ? 0 : 1,
        E = l.x ? h.x - o.x : h.y - o.y,
        v = c.move_strategy[C];
      if (v.type === "updateSlider") {
        let w = r.getItemModel(v.id);
        if ((w == null ? void 0 : w.type) !== "expression") {
          throw new Error(
            `Programming error: updateSlider move strategy should point to an expression item, but found ${
              w == null ? void 0 : w.type
            }`,
          );
        }
        let S = Rl(w);
        if (S) {
          let k = n.mathToPixels.mapPoint({ x: 0, y: 0 }),
            _ = v.coefficients[1],
            A = Math.abs(
              C === 0
                ? n.mathToPixels.mapX(S / _) - k.x
                : n.mathToPixels.mapY(S / _) - k.y,
            ),
            P = Math.ceil(1 / A);
          E = A * P * (E > 0 ? 1 : -1);
          let O = (y = l.x) != null ? y : l.y;
          (O === "bigup" || O === "bigdown") && (E *= 5);
        }
      }
      u = QO({
        controller: r,
        projection: n,
        transform: a,
        formula: c,
        moveStrategy: c.move_strategy,
        dragMode: t,
        targetScreenPoint: {
          x: o.x + (C === 0 ? E : 0),
          y: o.y + (C === 1 ? E : 0),
        },
        clampToViewport: s,
      });
    }
    return u &&
      { ...u, commitSliderSoftLimits: true, transform: a, model: e };
  }
  function ZO(r, e) {
    if (!r.settings.showGrid) return;
    let t = gl(r),
      o = t.minorStepX,
      i = t.minorStepY,
      n = r.map_pt(e),
      a = Math.round(e.x / o) * o,
      s = Math.round(e.y / i) * i,
      l = 5,
      c = { x: a, y: s },
      d = r.map_pt(c);
    if (__dcg_shared_module_exports__["MathHypot"](d.x - n.x, d.y - n.y) <= l) {
      return c;
    }
  }
  function Fce(r, e) {
    if (!(r instanceof e)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var Nce = "ID_",
    U0 = function () {
      function r() {
        Fce(this, r),
          this._callbacks = {},
          this._isDispatching = false,
          this._isHandled = {},
          this._isPending = {},
          this._lastID = 1;
      }
      return r.prototype.register = function (t) {
        var o = Nce + this._lastID++;
        return this._callbacks[o] = t, o;
      },
        r.prototype.unregister = function (t) {
          this._callbacks[t] ||
          B0(
            false,
            "Dispatcher.unregister(...): `%s` does not map to a registered callback.",
            t,
          ), delete this._callbacks[t];
        },
        r.prototype.waitFor = function (t) {
          this._isDispatching ||
            B0(
              false,
              "Dispatcher.waitFor(...): Must be invoked while dispatching.",
            );
          for (var o = 0; o < t.length; o++) {
            var i = t[o];
            if (this._isPending[i]) {
              this._isHandled[i] ||
                B0(
                  false,
                  "Dispatcher.waitFor(...): Circular dependency detected while waiting for `%s`.",
                  i,
                );
              continue;
            }
            this._callbacks[i] ||
            B0(
              false,
              "Dispatcher.waitFor(...): `%s` does not map to a registered callback.",
              i,
            ), this._invokeCallback(i);
          }
        },
        r.prototype.dispatch = function (t) {
          this._isDispatching &&
          B0(
            false,
            "Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.",
          ), this._startDispatching(t);
          try {
            for (var o in this._callbacks) {
              this._isPending[o] || this._invokeCallback(o);
            }
          } finally {
            this._stopDispatching();
          }
        },
        r.prototype.isDispatching = function () {
          return this._isDispatching;
        },
        r.prototype._invokeCallback = function (t) {
          this._isPending[t] = true,
            this._callbacks[t](this._pendingPayload),
            this._isHandled[t] = true;
        },
        r.prototype._startDispatching = function (t) {
          for (var o in this._callbacks) {
            this._isPending[o] = false, this._isHandled[o] = false;
          }
          this._pendingPayload = t, this._isDispatching = true;
        },
        r.prototype._stopDispatching = function () {
          delete this._pendingPayload, this._isDispatching = false;
        },
        r;
    }();
  function B0(r, e, t, o, i, n, a, s) {
    if (e === void 0) {
      throw new Error("invariant requires an error message argument");
    }
    if (!r) {
      var l;
      if (e === void 0) {
        l = new Error(
          "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.",
        );
      } else {
        var c = [t, o, i, n, a, s], d = 0;
        l = new Error(e.replace(/%s/g, function () {
          return c[d++];
        })), l.name = "Invariant Violation";
      }
      throw l.framesToPop = 1, l;
    }
  }
  Ss();
  function Fc(r) {
    return __dcg_shared_module_exports__["D"](r);
  }
  function Nc(r) {
    this.setState(r);
  }
  Nc.prototype.setState = function (r) {
    this.state = r;
  };
  Nc.prototype.getState = function () {
    return this.state;
  };
  Nc.prototype.set = function (r, e) {
    if (arguments.length === 1) {
      this.state = r;
      return;
    } else if (typeof r == "string") {
      this.state = Fc(this.state), this.state[r] = e;
      return;
    }
    let t = r.length - 2, o = r[t + 1], i;
    this.state = i = Fc(this.state);
    for (let n = 0; n <= t; n++) {
      let a = r[n];
      i = i[a] = Fc(i[a]);
    }
    i[o] = e;
  };
  Nc.prototype.deepMutate = function (r, e) {
    if (arguments.length === 1) {
      e = r,
        this.state = __dcg_shared_module_exports__["Jc"](this.state),
        e(this.state);
      return;
    } else if (typeof r == "string") {
      this.state = Fc(this.state),
        this.state[r] = __dcg_shared_module_exports__["Jc"](
          this.state[r],
        ),
        e(this.state[r]);
      return;
    }
    let t = r.length - 2, o = r[t + 1], i = this.state = Fc(this.state);
    for (let n = 0; n <= t; n++) {
      let a = r[n];
      i = i[a] = Fc(i[a]);
    }
    i = i[o] = __dcg_shared_module_exports__["Jc"](i[o]), e(i);
  };
  Nc.prototype.shallowMutate = function (r, e) {
    if (arguments.length === 1) {
      e = r, this.state = Fc(this.state), e(this.state);
      return;
    } else if (typeof r == "string") {
      this.state = Fc(this.state),
        this.state[r] = Fc(this.state[r]),
        e(this.state[r]);
      return;
    }
    let t = r.length - 1, o = this.state = Fc(this.state);
    for (let i = 0; i <= t; i++) {
      let n = r[i];
      o = o[n] = Fc(o[n]);
    }
    e(o);
  };
  Nc.areShallowEqual = function (r, e) {};
  Nc.areDeepEqual = function (r, e) {};
  var v$ = [
    { key: "compass", objects: "Segment + Point" },
    { key: "midpoint", objects: "Segment" },
    { key: "parallel", objects: "Line + Point" },
    { key: "perpendicular", objects: "Line + Point" },
    { key: "image", objects: "2 Points" },
  ];
  function Bce(r, e) {
    var a;
    if (
      e.typedRuntimeValue.valueType ===
        __dcg_shared_module_exports__["Transformation"] ||
      e.typedRuntimeValue.valueType ===
        __dcg_shared_module_exports__["ListOfTransformation"]
    ) return [];
    let t = e.data.call;
    if (!t || !t.parents) return [];
    let o = t.symbol, i = t.parents.map(tx), n;
    switch (o) {
      case "circle": {
        let [s, l] = i,
          c = l &&
            ((a = r[l]) == null ? void 0 : a.typedRuntimeValue.valueType);
        c &&
          __dcg_shared_module_exports__["isTypeOrListOfType"](
            c,
            __dcg_shared_module_exports__["Segment"],
          )
          ? n = [s]
          : n = [s, l];
        break;
      }
      case "apply": {
        n = [i[1]];
        break;
      }
      case "parallel":
      case "perpendicular": {
        n = [i[1]];
        break;
      }
      case "polygon": {
        n = i.every((s) => s !== void 0) ? i : [];
        break;
      }
      default:
        n = i;
    }
    return n.filter(S$);
  }
  var Uce = [[1, 0], [0, 0], false],
    z0 = class z0 {
      constructor(e, t) {
        let o = (e == null ? void 0 : e.list) || [];
        t && (o = o.concat(t)), this.list = o;
        let i = (e == null ? void 0 : e.forward) || Uce;
        t &&
        (i = __dcg_shared_module_exports__["composeTransformation"](
          i,
          t.value,
        )),
          this.forward = i,
          this.inverse = __dcg_shared_module_exports__["invertTransformation"](
            i,
          );
      }
      add(e) {
        return new z0(this, e);
      }
      equals(e) {
        if (this.list.length !== e.list.length) return false;
        for (let t = this.list.length - 1; t >= 0; t--) {
          let o = this.list[t], i = e.list[t];
          if (!__dcg_shared_module_exports__["E"](o, i)) return false;
        }
        return true;
      }
      isCompletelyRigid() {
        return this.list.length === 0;
      }
    };
  z0.COMPLETELY_RIGID = new z0(void 0);
  var jI = z0;
  function zce(r) {
    var o, i;
    let e = {}, t = {};
    for (let n in r) {
      let a = r[n];
      if (!a) continue;
      for (
        let l of ((o = a.data.call) == null ? void 0 : o.parents) || []
      ) {
        let c = tx(l);
        c &&
          (e[c] || (e[c] = []), (i = e[c]) == null || i.push(a.assignment));
      }
      let s = Bce(r, a);
      t[a.assignment] = s;
    }
    return { parentToChildren: e, childToReversibilityParents: t };
  }
  function C$(r) {
    let e = [], t = {};
    function a(s) {
      var l;
      t[s] !== 2 &&
        (t[s] = 1, (l = r[s]) == null || l.forEach(a), t[s] = 2, e.unshift(s));
    }
    for (let s in r) t[s] === void 0 && a(s);
    return e;
  }
  function eR(r, e) {
    var p, h, u, f, y, C, E, v, w, S;
    let t = {}, o = {}, i = {}, n = {}, a = {};
    for (let k of e) a[k] = true, i[k] = jI.COMPLETELY_RIGID;
    let { parentToChildren: s, childToReversibilityParents: l } = zce(r);
    for (let k of C$(l)) {
      let _ = r[k];
      if (!_) continue;
      let A = (p = _.data.call) == null ? void 0 : p.symbol,
        P = (((h = _.data.call) == null ? void 0 : h.parents) || []).map(
          tx,
        ).filter(S$);
      if (i[_.assignment]) {
        if (
          _.typedRuntimeValue.valueType ===
            __dcg_shared_module_exports__["Point"] && !A
        ) t[_.assignment] = i[_.assignment];
        else if (A === "glider" && P.length && !a[P[0]]) {
          o[_.assignment] = i[_.assignment];
        } else {
          let O = i[_.assignment];
          if (A === "apply") {
            let z = (u = r[P[0]]) == null ? void 0 : u.typedRuntimeValue;
            if (
              (z == null ? void 0 : z.valueType) ===
                __dcg_shared_module_exports__["ListOfTransformation"]
            ) return {};
            if (
              (z == null ? void 0 : z.valueType) !==
                __dcg_shared_module_exports__["Transformation"]
            ) continue;
            O = O.add(z);
          }
          let U = (f = l[_.assignment]) != null ? f : [];
          for (let z of U) {
            i[z]
              ? O.equals(i[z]) || (i[z] = jI.COMPLETELY_RIGID, n[z] = true)
              : i[z] = O;
          }
        }
      }
    }
    let c = {};
    for (let k in i) c[k] = true;
    for (let k of C$(s)) {
      if (c[k]) {
        for (let _ of s[k] || []) c[_] = true;
        if (i[k]) {
          let _ = l[k] || [];
          for (let A of _) n[A] && (n[k] = true);
        }
      }
    }
    for (let k in o) {
      let A = (((C = (y = r[k]) == null ? void 0 : y.data.call) == null
        ? void 0
        : C.parents) || []).map(tx)[0];
      A && c[A] && (n[A] = true);
    }
    for (let k in r) {
      if (!c[k]) continue;
      let _ = r[k],
        A = (E = _ == null ? void 0 : _.data.call) == null ? void 0 : E.symbol,
        P = (((v = _ == null ? void 0 : _.data.call) == null
          ? void 0
          : v.parents) || []).map(tx);
      if (A === "apply" && i[k]) {
        let O = P[1], U = P[0];
        if (!O || !U) {
          continue;
        }
        let z = (((S = (w = r[U]) == null ? void 0 : w.data.call) == null
            ? void 0
            : S.parents) || []).map(tx),
          x = z.some((V) =>
            V && c[V]
          );
        if (
          i[k].isCompletelyRigid() &&
            (!(O in i) || i[O].isCompletelyRigid()) || x
        ) {
          n[O] = true;
          for (let V of z) {
            V && (n[V] = true);
          }
        }
      }
    }
    let d = [];
    for (let k in n) a[k] || d.push(k);
    return d.length ? eR(r, e.concat(d)) : { ...t, ...o };
  }
  function tx(r) {
    if (r.type === "arbitrary-expression") return;
    let e = __dcg_shared_module_exports__["Cc"](r);
    return e ? __dcg_shared_module_exports__["identifierToLatex"](e) : void 0;
  }
  function S$(r) {
    return r !== void 0;
  }
  var q0 = class {
    constructor() {
      this._nextId = 0;
      this._defs = {};
    }
    clear() {
      this._nextId = 0, this._defs = {};
    }
    add(e, t) {
      let o;
      t
        ? (o = e.assignment,
          e.listIndex !== void 0 &&
          (o += "\\left[" + e.listIndex + "\\right]"))
        : o = "**geo-internal-id-" + this._nextId++, this._defs[o] = e;
    }
    computeReversibilityLineages(e) {
      var s;
      let t = this.buildAssignmentMap(), o = {};
      for (let l in t) {
        let c = t[l];
        c && (o[c.calcId] = c);
      }
      let i = [];
      for (let l of e) {
        let c = o[l];
        if (!c) return {};
        i.push(c.assignment);
      }
      let n = eR(this.buildAssignmentMap(), i), a = {};
      for (let l in n) {
        let c = (s = t[l]) == null ? void 0 : s.calcId;
        c && (a[c] = n[l]);
      }
      return a;
    }
    buildAssignmentMap() {
      let e = {};
      for (let t in this._defs) {
        let o = this._defs[t];
        o && (e[o.assignment] = o);
      }
      return e;
    }
    getDepthValues() {
      let e = {}, t = {}, o = this.buildAssignmentMap();
      for (let l in o) {
        let c = o[l];
        if (!c) continue;
        let d = __dcg_shared_module_exports__["latexToIdentifier"](
            c.assignment,
          ),
          p = [];
        for (let h of c.data.parentDependencies) {
          p.push(h), t[h] || (t[h] = []), t[h].push(d);
        }
        e[d] = p;
      }
      let i = {},
        n = (l) => {
          if (i[l] !== void 0) return i[l];
          if (i[l] === -1) return i[l] = 0, 0;
          i[l] = -1;
          let c = -1, d = e[l] || [];
          for (let h = 0; h < d.length; h++) {
            let u = n(d[h]);
            u > c && (c = u);
          }
          let p = c + 1;
          return i[l] = p, p;
        };
      for (let l in e) i[l] === void 0 && n(l);
      let a = {}, s = {};
      for (let l in t) {
        let c = i[l], d = 1 / 0;
        t[l].forEach((p) => {
          let h = i[p];
          h > c && (c = h), h < d && (d = h);
        }),
          a[l] = c,
          s[l] = d;
      }
      return {
        createdDepth: i,
        lastReferencedDepth: a,
        firstReferencedDepth: s,
      };
    }
  };
  function Dm(r) {
    return r
      ? !!(qce(r) && r !== "Vector" || r === "Circle" || r === "Arc" ||
        r === "Polygon")
      : false;
  }
  function qce(r) {
    if (!r) return false;
    switch (r) {
      case "Line":
      case "Ray":
      case "Vector":
      case "Segment":
        return true;
    }
    return false;
  }
  function D$(r, e) {
    let t = { i: 0, x: NaN, y: NaN }, o = { i: 1, x: NaN, y: NaN };
    if (!r || !e) return [t, o];
    let i = E$(r.typedRuntimeValue), n = E$(e.typedRuntimeValue);
    if (!i || !n) return [t, o];
    let a = T$(i, n);
    return t.x = a[0], t.y = a[1], a = T$(n, i), o.x = a[0], o.y = a[1], [t, o];
  }
  function E$(r) {
    switch (r.valueType) {
      case __dcg_shared_module_exports__["Segment"]:
      case __dcg_shared_module_exports__["Line"]:
      case __dcg_shared_module_exports__["Ray"]:
        return { type: "straight", def: r.value };
      case __dcg_shared_module_exports__["Vector"]:
        return { type: "straight", def: nm(r.value) };
      case __dcg_shared_module_exports__["Circle"]:
        return { type: "circle", def: r.value };
      case __dcg_shared_module_exports__["Arc"]:
        return { type: "arc", def: r.value };
    }
  }
  function T$(r, e) {
    switch (r.type) {
      case "straight":
        switch (e.type) {
          case "straight":
            return __dcg_shared_module_exports__["lineLineIntersection"](
              r.def,
              e.def,
            );
          case "circle":
            return __dcg_shared_module_exports__["lineCircleIntersection"](
              r.def,
              e.def,
            );
          case "arc":
            return __dcg_shared_module_exports__["lineArcIntersection"](
              r.def,
              e.def,
            );
        }
      case "circle":
        switch (e.type) {
          case "straight":
            return __dcg_shared_module_exports__["circleLineIntersection"](
              r.def,
              e.def,
            );
          case "circle":
            return __dcg_shared_module_exports__["circleCircleIntersection"](
              r.def,
              e.def,
            );
          case "arc":
            return __dcg_shared_module_exports__["circleArcIntersection"](
              r.def,
              e.def,
            );
        }
      case "arc":
        switch (e.type) {
          case "straight":
            return __dcg_shared_module_exports__["arcLineIntersection"](
              r.def,
              e.def,
            );
          case "circle":
            return __dcg_shared_module_exports__["arcCircleIntersection"](
              r.def,
              e.def,
            );
          case "arc":
            return __dcg_shared_module_exports__["arcArcIntersection"](
              r.def,
              e.def,
            );
        }
    }
    return [NaN, NaN];
  }
  var Rh = class extends _c {
    constructor(t) {
      super(t);
      this.model = t;
      this.displayName =
        "graphing-calculator-text-geometry-tool-expression-edit-display-name",
        this.toolType = "custom",
        this.toolName = "expression-edit";
    }
    getHint() {
      let t = this.model.controller.getValidCursorContext();
      if (
        (t == null ? void 0 : t.type) !== "expression-arguments" ||
        !t.functionSymbol
      ) return this.getGenericHint();
      let o = this.model.getTool(t.functionSymbol);
      if (!o) return this.getGenericHint();
      let i = t.argIndex;
      if (
        t.positionWithinArg === "end" && (i += 1),
          o.toolType === "transformation"
      ) {
        if (t.argCount === 0) {
          return Ls(
            "graphing-calculator-text-geometry-tool-expression-edit-starting-transformation-hint",
          );
        }
        i > 0 && (i -= 1);
      }
      return o.getExpressionEditHint(i);
    }
    getGenericHint() {
      let t = this.getAllValidNextInputTypes();
      if (
        t.some((i) =>
          i === __dcg_shared_module_exports__["Any"] ||
          i === __dcg_shared_module_exports__["ListOfAny"]
        )
      ) {
        return Ls(
          "graphing-calculator-text-geometry-tool-expression-edit-generic-hint-any-object",
        );
      }
      let o = t.filter((i) =>
        !(__dcg_shared_module_exports__["isList"](i) &&
          t.find((n) => __dcg_shared_module_exports__["elementType"](i) === n))
      ).map((i) => Fl(__dcg_shared_module_exports__["prettyPrint"](i), Zw()));
      return o.length === 0
        ? Ls(
          "graphing-calculator-text-geometry-tool-expression-edit-generic-hint-0",
        )
        : o.length === 1
        ? Ls(
          "graphing-calculator-text-geometry-tool-expression-edit-generic-hint-1",
          { type: o[0] },
        )
        : o.length === 2
        ? Ls(
          "graphing-calculator-text-geometry-tool-expression-edit-generic-hint-2",
          { type1: o[0], type2: o[1] },
        )
        : Ls(
          "graphing-calculator-text-geometry-tool-expression-edit-generic-hint-many",
          { types: Cd(jL(), o) },
        );
    }
    getExpressionEditHint(t) {
      return this.getHint();
    }
    getSpec() {
      let t = this.model.controller.getSelectedItem(),
        o = tR(this.model.controller.getValidCursorContext());
      return !o || !t || t.type !== "expression"
        ? { inputs: [], outputs: [] }
        : {
          inputs: [{ type: "union", valueTypes: o, id: "1" }],
          outputs: [{
            type: "expression-edit-preview-latex",
            rhsLatex: this.buildPreviewLatex(),
            hidden: false,
            color: t.color,
            id: "2",
            parents: [],
          }],
        };
    }
    onMove(t) {
      super.onMove(t);
      let { idMap: o, inputIndex: i } =
          this.model.getNonObjectsState().ui.currentTool,
        n = this.getSpec().inputs[i];
      return !!(n && o[n.id]);
    }
    buildPreviewLatex() {
      let t = "",
        o = "",
        i = this.model.controller.getValidCursorContext(),
        n = (i == null ? void 0 : i.type) === "permissive"
          ? i.cursorContext
          : i;
      if ((n == null ? void 0 : n.type) === "empty") return "";
      (n == null ? void 0 : n.type) === "expression-arguments" &&
        ((n == null ? void 0 : n.positionWithinArg) === "end"
          ? t = ","
          : (n == null ? void 0 : n.positionWithinArg) === "start" &&
            (o = ","));
      let s = this.model.getNonObjectsState().ui.currentTool.idMap[1];
      if (!s) return "";
      let l = this.model.controller.getSelectedItem();
      if ((l == null ? void 0 : l.type) !== "expression") return "";
      let c = Fe.getFocusedMathquill(),
        d = c == null ? void 0 : c.selection();
      if ((d == null ? void 0 : d.latex) !== l.latex) return "";
      let p = l.latex.slice(0, d.startIndex) + t + s + o +
        l.latex.slice(d.endIndex);
      return pi(l) ? p.slice(l.latex.indexOf("=") + 1) : p;
    }
    canNextInputBePoint() {
      let t = this.model.controller.getValidCursorContext();
      if (
        (t == null ? void 0 : t.type) !== "expression-arguments" ||
        t.expressionType !== "FunctionCall" && t.expressionType !== "List"
      ) return false;
      let o = tR(t);
      if (!o) return false;
      let i = false;
      for (let n of o) {
        if (
          __dcg_shared_module_exports__["isTypeOrListOfType"](
            n,
            __dcg_shared_module_exports__["Any"],
          )
        ) return false;
        __dcg_shared_module_exports__["isTypeOrListOfType"](
          n,
          __dcg_shared_module_exports__["Point"],
        ) && (i = true);
      }
      return i;
    }
    shouldHighlightRelevantObjects() {
      let t = this.model.controller.getValidCursorContext();
      if (
        (t == null ? void 0 : t.type) === "empty" ||
        (t == null ? void 0 : t.type) === "permissive"
      ) return false;
      let o = tR(t);
      return !(!o ||
        o.some((i) =>
          __dcg_shared_module_exports__["isTypeOrListOfType"](
            i,
            __dcg_shared_module_exports__["Any"],
          )
        ) || o.every((i) =>
          __dcg_shared_module_exports__["isTypeOrListOfType"](
            i,
            __dcg_shared_module_exports__["Number"],
          ) ||
          __dcg_shared_module_exports__["isTypeOrListOfType"](
            i,
            __dcg_shared_module_exports__["AngleMarker"],
          ) ||
          __dcg_shared_module_exports__["isTypeOrListOfType"](
            i,
            __dcg_shared_module_exports__["DirectedAngleMarker"],
          )
        ));
    }
  };
  function tR(r) {
    if ((r == null ? void 0 : r.type) === "permissive") {
      return [__dcg_shared_module_exports__["Any"]];
    }
    if ((r == null ? void 0 : r.type) === "empty") {
      return [
        __dcg_shared_module_exports__["AngleMarker"],
        __dcg_shared_module_exports__["DirectedAngleMarker"],
        __dcg_shared_module_exports__["ListOfAngleMarker"],
        __dcg_shared_module_exports__["ListOfDirectedAngleMarker"],
        __dcg_shared_module_exports__["Vector"],
      ];
    }
    if (
      (r == null ? void 0 : r.type) === "expression-arguments" &&
      r.expressionType === "FunctionCall" && r.functionSymbol &&
      !__dcg_shared_module_exports__["qc"][r.functionSymbol]
    ) return;
    let e = (r == null ? void 0 : r.type) === "expression-arguments"
      ? r.allowedTypesForInsertedArg
      : r == null
      ? void 0
      : r.allowedTypes;
    return e == null
      ? void 0
      : e.filter((t) =>
        !__dcg_shared_module_exports__["isTypeOrListOfType"](
          t,
          __dcg_shared_module_exports__["Point3D"],
        )
      );
  }
  var rR = "graphing-calculator-text-geometry-tool-angle-hint-1",
    oR = "graphing-calculator-text-geometry-tool-angle-hint-2",
    iR = "graphing-calculator-text-geometry-tool-angle-hint-3",
    nR = "graphing-calculator-text-geometry-tool-angles-hint-1",
    Hce = {
      name: "angle",
      displayName: "graphing-calculator-text-geometry-tool-angle-display-name",
      toolType: "complex",
      icon: [
        {
          type: "stroked-path",
          path: [40, 30, 30, 70, 70, 70],
          color: "#bbb",
        },
        {
          type: "angle",
          x: 30,
          y: 70,
          radius: 20,
          startAngle: -1.325817,
          deltaAngle: 1.325817,
          isDirected: false,
        },
        { type: "point", x: 30, y: 70 },
        { type: "point", x: 40, y: 30 },
        { type: "point", x: 70, y: 70 },
      ],
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [rR, oR, iR],
        },
        output: [{ type: "angle", parents: [0, 1, 2] }],
      }, {
        input: {
          broadcast: false,
          types: [__dcg_shared_module_exports__["Polygon"]],
          hints: [nR],
        },
        output: ({ inputs: r }) => {
          if (
            r.length !== 1 ||
            r[0].valueType !== __dcg_shared_module_exports__["Polygon"]
          ) {
            throw new Error(
              `Programming error: expected a single polygon input, got ${
                JSON.stringify(r)
              }`,
            );
          }
          return r[0].value.map((t, o) => ({
            type: "polygon-angle",
            angleIndex: o + 1,
            parents: [0],
          }));
        },
      }],
    },
    H0 = class extends Vr {
      constructor(t) {
        super(t, Hce);
        this.model = t;
      }
    };
  var Kce = "graphing-calculator-text-geometry-tool-angle-bisector-hint-angle",
    Wce = {
      name: "anglebisector",
      displayName:
        "graphing-calculator-text-geometry-tool-angle-bisector-display-name",
      toolType: "complex",
      icon: [{
        type: "stroked-path",
        color: "#ccc",
        path: [40, 30, 30, 70, 70, 70],
      }, {
        type: "angle",
        x: 30,
        y: 70,
        radius: 20,
        startAngle: -1.325817,
        deltaAngle: 1.325817,
        isDirected: false,
      }, {
        type: "stroked-path",
        lineWidth: "large",
        path: [31, 69, 70, 38.8],
      }],
      workflows: [{
        input: {
          broadcast: false,
          types: [
            __dcg_shared_module_exports__["Union"].of([
              __dcg_shared_module_exports__["AngleMarker"],
              __dcg_shared_module_exports__["DirectedAngleMarker"],
            ]),
          ],
          hints: [Kce],
        },
        output: [{ type: "anglebisector", parents: [0] }],
      }],
    },
    K0 = class extends Vr {
      constructor(t) {
        super(t, Wce);
        this.model = t;
      }
    };
  var $ce = "graphing-calculator-text-geometry-tool-arc-hint-1",
    jce = "graphing-calculator-text-geometry-tool-arc-hint-2",
    Yce = "graphing-calculator-text-geometry-tool-arc-hint-3",
    km = 50,
    YI = 80,
    XI = 80,
    aR = -3,
    k$ = -2.6,
    sR = -1.7,
    Xce = [{
      type: "arc",
      x: YI,
      y: XI,
      radius: km,
      startAngle: aR,
      endAngle: sR,
    }, {
      type: "point",
      x: YI + km * Math.cos(aR),
      y: XI + km * Math.sin(aR),
    }, {
      type: "point",
      x: YI + km * Math.cos(k$),
      y: XI + km * Math.sin(k$),
    }, {
      type: "point",
      x: YI + km * Math.cos(sR),
      y: XI + km * Math.sin(sR),
    }],
    Jce = {
      name: "arc",
      displayName: "graphing-calculator-text-geometry-tool-arc-display-name",
      toolType: "complex",
      icon: Xce,
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [$ce, jce, Yce],
        },
        output: [{ type: "arc", parents: [0, 1, 2] }],
      }],
    },
    W0 = class extends Vr {
      constructor(t) {
        super(t, Jce);
        this.model = t;
      }
    };
  var Qce = "graphing-calculator-text-geometry-tool-circle-hint-center",
    Zce = "graphing-calculator-text-geometry-tool-circle-hint-radius",
    ede = {
      name: "circle",
      displayName: "graphing-calculator-text-geometry-tool-circle-display-name",
      toolType: "simple",
      icon: [{ type: "circle", x: 50, y: 50, radius: 26 }, {
        type: "point",
        x: 50,
        y: 50,
      }, { type: "point", x: 68, y: 32 }],
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [Qce, Zce],
        },
        output: [{ type: "circle", parents: [0, 1] }],
      }],
    },
    $0 = class extends Vr {
      constructor(t) {
        super(t, ede);
        this.model = t;
      }
    };
  var tde = "graphing-calculator-text-geometry-tool-compass-hint-segment",
    rde = "graphing-calculator-text-geometry-tool-compass-hint-center",
    ode = {
      name: "compass",
      displayName:
        "graphing-calculator-text-geometry-tool-circle-by-length-display-name",
      toolType: "complex",
      icon: [
        {
          type: "ellipse",
          x: 50,
          y: 65,
          rx: 26,
          ry: 11,
          color: __dcg_shared_module_exports__["Rd"].GRAY,
          lineWidth: 2,
        },
        { type: "stroked-path", path: [50, 65, 78, 65] },
        {
          type: "stroked-path",
          path: [50, 65, 62, 36],
          lineWidth: "large",
          color: (r) => __dcg_shared_module_exports__["Kd"](r.circle, .3),
        },
        {
          type: "stroked-path",
          path: [78, 65, 66, 36],
          lineWidth: "large",
          color: (r) => __dcg_shared_module_exports__["Kd"](r.circle, .3),
        },
        {
          type: "circle",
          radius: 6,
          x: 64,
          y: 31,
          lineWidth: 5,
          color: (r) => __dcg_shared_module_exports__["Kd"](r.circle, .3),
        },
        {
          type: "stroked-path",
          path: [64, 24, 64, 18],
          lineWidth: "large",
          color: (r) => __dcg_shared_module_exports__["Kd"](r.circle, .3),
        },
        { type: "point", x: 50, y: 65 },
        { type: "point", x: 78, y: 65 },
      ],
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["Segment"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [tde, rde],
        },
        output: [{ type: "circle", parents: [1, 0] }],
      }],
    },
    j0 = class extends Vr {
      constructor(t) {
        super(t, ode);
        this.model = t;
      }
    };
  var _$ = "graphing-calculator-text-geometry-tool-dilation-hint-center",
    I$ = "graphing-calculator-text-geometry-tool-dilation-hint-scale-factor",
    Y0 = class extends Ic {
      constructor(t) {
        super(t);
        this.model = t;
        this.displayName =
          "graphing-calculator-text-geometry-tool-dilate-display-name",
          this.toolName = "dilation",
          this.toolType = "transformation";
      }
      getExpressionEditHint(t) {
        return t === 0 ? this.s(_$) : this.s(I$);
      }
      getSpecIdToLockIn(t, o) {
        return o === 1 ? "2-number" : super.getSpecIdToLockIn(t, o);
      }
      getSpec() {
        return {
          inputs: [{ type: "point", id: "1", hint: _$ }, {
            type: "union",
            valueTypes: [],
            id: "2",
            hint: I$,
            numberInputInfo: {
              defaultLatex: "2",
              sliderInfo: { value: "2", min: "0", max: "5" },
            },
          }],
          outputs: [{
            id: "3",
            type: "dilate",
            hidden: false,
            name: this.generateDefaultName(),
            parents: [{ type: "reference-input", id: "1" }, {
              type: "reference-input",
              id: "2-number",
            }],
          }],
        };
      }
    };
  var ide = {
      name: "directedangle",
      displayName:
        "graphing-calculator-text-geometry-tool-directedangle-display-name",
      toolType: "complex",
      icon: [
        {
          type: "stroked-path",
          path: [40, 30, 30, 70, 70, 70],
          color: "#bbb",
        },
        {
          type: "angle",
          x: 30,
          y: 70,
          radius: 20,
          isDirected: true,
          startAngle: -1.325817,
          deltaAngle: 1.325817,
        },
        {
          type: "stroked-path",
          path: [35, 50, 41, 50, 37, 55, 35, 50],
          color: "#000",
          lineWidth: "medium",
        },
        { type: "point", x: 30, y: 70 },
        { type: "point", x: 40, y: 30 },
        { type: "point", x: 70, y: 70 },
      ],
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [rR, oR, iR],
        },
        output: [{ type: "directedangle", parents: [0, 1, 2] }],
      }, {
        input: {
          broadcast: false,
          types: [__dcg_shared_module_exports__["Polygon"]],
          hints: [nR],
        },
        output: ({ inputs: r }) => {
          if (
            r.length !== 1 || typeof r[0] != "object" ||
            r[0].valueType !== __dcg_shared_module_exports__["Polygon"]
          ) {
            throw new Error(
              `Programming error: expected a single polygon input, got ${
                JSON.stringify(r)
              }`,
            );
          }
          return r[0].value.map((t, o) => ({
            type: "polygon-directedangle",
            angleIndex: o + 1,
            parents: [0],
          }));
        },
      }],
    },
    X0 = class extends Vr {
      constructor(t) {
        super(t, ide);
        this.model = t;
      }
    };
  var nde = "graphing-calculator-text-geometry-tool-line-hint-start",
    ade = "graphing-calculator-text-geometry-tool-line-hint-end",
    sde = {
      name: "line",
      displayName: "graphing-calculator-text-geometry-tool-line-display-name",
      toolType: "simple",
      icon: [
        {
          type: "stroked-path",
          path: [78, 22, 22, 78],
          lineWidth: "large",
        },
        { type: "point", x: 68, y: 32 },
        { type: "point", x: 32, y: 68 },
      ],
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [nde, ade],
        },
        output: [{ type: "line", parents: [0, 1] }],
      }],
    },
    J0 = class extends Vr {
      constructor(t) {
        super(t, sde);
        this.model = t;
      }
    };
  var A$ = "graphing-calculator-text-geometry-tool-midpoint-hint",
    lde = {
      name: "midpoint",
      displayName:
        "graphing-calculator-text-geometry-tool-midpoint-display-name",
      toolType: "simple",
      icon: [
        { type: "stroked-path", path: [32, 32, 68, 68] },
        { type: "point", x: 50, y: 50, size: "large" },
        { type: "point", x: 32, y: 32, size: "medium" },
        { type: "point", x: 68, y: 68, size: "medium" },
      ],
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [A$],
        },
        output: [{ type: "midpoint", parents: [0, 1] }],
      }, {
        input: {
          broadcast: true,
          types: [__dcg_shared_module_exports__["Segment"]],
          hints: [A$],
        },
        output: [{ type: "midpoint", parents: [0] }],
      }],
    },
    Q0 = class extends Vr {
      constructor(t) {
        super(t, lde);
        this.model = t;
      }
    };
  var cde =
      "graphing-calculator-text-geometry-tool-parallel-hint-straight-line",
    dde = "graphing-calculator-text-geometry-tool-parallel-hint-point",
    pde = {
      name: "parallel",
      displayName:
        "graphing-calculator-text-geometry-tool-parallel-display-name",
      toolType: "complex",
      icon: [{
        type: "stroked-path",
        color: "light",
        path: [25, 50, 75, 30],
        lineWidth: "large",
      }, {
        type: "stroked-path",
        path: [25, 70, 75, 50],
        lineWidth: "large",
      }, { type: "point", x: 50, y: 60, size: "medium" }],
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["straightTypes"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [cde, dde],
        },
        output: [{ type: "parallel", parents: [0, 1] }],
      }],
    },
    Z0 = class extends Vr {
      constructor(t) {
        super(t, pde);
        this.model = t;
      }
    };
  var ude =
      "graphing-calculator-text-geometry-tool-perpendicular-hint-straight-line",
    hde = "graphing-calculator-text-geometry-tool-perpendicular-hint-point",
    gde = {
      name: "perpendicular",
      displayName:
        "graphing-calculator-text-geometry-tool-perpendicular-display-name",
      toolType: "complex",
      icon: [{
        type: "stroked-path",
        color: "light",
        path: [40, 25, 60, 75],
        lineWidth: "large",
      }, {
        type: "stroked-path",
        path: [25, 60, 75, 40],
        lineWidth: "large",
      }, { type: "point", x: 50, y: 50, size: "medium" }],
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["straightTypes"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [ude, hde],
        },
        output: [{ type: "perpendicular", parents: [0, 1] }],
      }],
    },
    e1 = class extends Vr {
      constructor(t) {
        super(t, gde);
        this.model = t;
      }
    };
  var mde = "graphing-calculator-text-geometry-tool-point-hint",
    fde = {
      name: "point",
      displayName: "graphing-calculator-text-geometry-tool-point-display-name",
      toolType: "simple",
      icon: [{ type: "point", x: 50, y: 50, size: "large" }],
      workflows: [{
        input: {
          broadcast: true,
          types: [__dcg_shared_module_exports__["Point"]],
          hints: [mde],
        },
        output: [],
      }],
    },
    t1 = class extends Vr {
      constructor(t) {
        super(t, fde);
        this.model = t;
      }
    };
  var bde = "graphing-calculator-text-geometry-tool-polygon-hint-first-point",
    yde = "graphing-calculator-text-geometry-tool-polygon-hint-next-point",
    xde = "graphing-calculator-text-geometry-tool-polygon-hint-finish-point",
    wde = {
      name: "polygon",
      displayName:
        "graphing-calculator-text-geometry-tool-polygon-display-name",
      toolType: "complex",
      icon: [
        {
          type: "filled-polygon",
          path: [55, 30, 30, 30, 35, 70, 70, 60, 55, 30],
        },
        {
          type: "stroked-path",
          path: [55, 30, 30, 30, 35, 70, 70, 60, 55, 30],
        },
        { type: "point", x: 55, y: 30 },
        { type: "point", x: 30, y: 30 },
        { type: "point", x: 35, y: 70 },
        { type: "point", x: 70, y: 60 },
      ],
      isDegenerateInput: ({ previousInputs: r, proposedInput: e }) =>
        !!(r.length === 1 && __dcg_shared_module_exports__["E"](r[0], e)),
      workflows: [{
        input: {
          broadcast: true,
          types: {
            type: "variadic",
            initial: [
              __dcg_shared_module_exports__["Point"],
              __dcg_shared_module_exports__["Point"],
            ],
            rest: __dcg_shared_module_exports__["Point"],
          },
          hints: (r) => r === 0 ? bde : r < 3 ? yde : xde,
        },
        output: (
          { inputs: r, isCommitting: e },
        ) => ((e ||
          __dcg_shared_module_exports__["E"](
            r[r.length - 1],
            r[r.length - 2],
          )) && (r = r.slice(0, -1)),
          [{ type: "polygon", hidden: false, parents: r.map((t, o) => o) }]),
        canCommit: (r) => {
          if (r.length < 2) return false;
          let e = r[r.length - 1], t = r[r.length - 2], o = r[0];
          return __dcg_shared_module_exports__["E"](e, o) ||
            __dcg_shared_module_exports__["E"](e, t);
        },
      }],
    },
    r1 = class extends Vr {
      constructor(t) {
        super(t, wde);
        this.model = t;
      }
    };
  var vde = "graphing-calculator-text-geometry-tool-ray-hint-start",
    Cde = "graphing-calculator-text-geometry-tool-ray-hint-end",
    Sde = {
      name: "ray",
      displayName: "graphing-calculator-text-geometry-tool-ray-display-name",
      toolType: "simple",
      icon: [
        {
          type: "stroked-path",
          path: [78, 22, 32, 68],
          lineWidth: "large",
        },
        { type: "point", x: 68, y: 32 },
        { type: "point", x: 32, y: 68 },
      ],
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [vde, Cde],
        },
        output: [{ type: "ray", parents: [0, 1] }],
      }],
    },
    o1 = class extends Vr {
      constructor(t) {
        super(t, Sde);
        this.model = t;
      }
    };
  var M$ = "graphing-calculator-text-geometry-tool-reflection-hint-choose-line",
    i1 = class extends Ic {
      constructor(t) {
        super(t);
        this.model = t;
        this.displayName =
          "graphing-calculator-text-geometry-tool-reflect-display-name",
          this.toolName = "reflection",
          this.toolType = "transformation";
      }
      getExpressionEditHint(t) {
        return this.s(M$);
      }
      getSpec() {
        return {
          inputs: [{ type: "straight", id: "1", hint: M$ }],
          outputs: [{
            id: "2",
            type: "reflect",
            hidden: false,
            name: this.generateDefaultName(),
            parents: [{ type: "reference-input", id: "1" }],
          }],
        };
      }
    };
  var Ede = "graphing-calculator-text-geometry-tool-segment-hint-start",
    Tde = "graphing-calculator-text-geometry-tool-segment-hint-end",
    Dde = {
      name: "segment",
      displayName:
        "graphing-calculator-text-geometry-tool-segment-display-name",
      toolType: "simple",
      icon: [
        {
          type: "stroked-path",
          path: [68, 32, 32, 68],
          lineWidth: "large",
        },
        { type: "point", x: 68, y: 32 },
        { type: "point", x: 32, y: 68 },
      ],
      workflows: [{
        input: {
          broadcast: true,
          types: [
            __dcg_shared_module_exports__["Point"],
            __dcg_shared_module_exports__["Point"],
          ],
          hints: [Ede, Tde],
        },
        output: [{ type: "segment", parents: [0, 1] }],
      }],
    },
    n1 = class extends Vr {
      constructor(t) {
        super(t, Dde);
        this.model = t;
      }
    };
  var a1 = class {
    constructor() {
      this.displayName =
        "graphing-calculator-text-geometry-tool-selection-display-name";
      this.toolType = "selection";
      this.icon = [{
        type: "filled-polygon",
        color: "#000",
        path: [
          40,
          30,
          58,
          46,
          51,
          47,
          56,
          60,
          53,
          62,
          47,
          49,
          41,
          54,
          40,
          30,
        ],
      }];
    }
    getNumberInputLatex() {
      return "";
    }
    clearTentativeOutputs() {}
    canNextInputBePoint() {
      return false;
    }
    getAllValidNextInputTypes() {
      return __dcg_shared_module_exports__["allValueTypes"].filter((e) =>
        this.isValidNextInputType(e)
      );
    }
    isValidNextInputType(e) {
      return e !== __dcg_shared_module_exports__["Transformation"];
    }
    getNonPointInputType() {}
    getHint() {
      return "";
    }
    getExpressionEditHint(e) {
      return this.getHint();
    }
    onNumberInput(e) {}
    onMove(e) {
      return true;
    }
    onFocus(e) {}
    tryCommitResults() {
      return { committed: void 0 };
    }
    shouldUseJitEdges() {
      return false;
    }
    shouldHighlightRelevantObjects() {
      return false;
    }
  };
  var lR =
      "graphing-calculator-text-geometry-tool-translation-hint-from-with-vector",
    G$ = "graphing-calculator-text-geometry-tool-translation-hint-to",
    s1 = class extends Ic {
      constructor(t) {
        super(t);
        this.model = t;
        this.displayName =
          "graphing-calculator-text-geometry-tool-translate-display-name",
          this.toolName = "translation",
          this.toolType = "transformation";
      }
      getExpressionEditHint(t) {
        return t === 0 ? this.s(lR) : this.s(G$);
      }
      firstInputIsVector() {
        let { idMap: t } = this.model.getNonObjectsState().ui.currentTool,
          o = t[1],
          i = o && this.model.findDefsForInputId(o)[0];
        return i &&
          i.typedRuntimeValue.valueType ===
            __dcg_shared_module_exports__["Vector"];
      }
      getSpec() {
        return this.firstInputIsVector()
          ? {
            inputs: [{
              type: "union",
              valueTypes: [
                __dcg_shared_module_exports__["Point"],
                __dcg_shared_module_exports__["Vector"],
              ],
              id: "1",
              hint: lR,
            }],
            outputs: [{
              id: "3",
              type: "translate",
              hidden: false,
              name: this.generateDefaultName(),
              parents: [{ type: "reference-input", id: "1" }],
            }],
          }
          : {
            inputs: [{
              type: "union",
              valueTypes: [
                __dcg_shared_module_exports__["Point"],
                __dcg_shared_module_exports__["Vector"],
              ],
              id: "1",
              hint: lR,
            }, { type: "point", id: "2", hint: G$ }],
            outputs: [{
              id: "3",
              type: "translate",
              hidden: false,
              name: this.generateDefaultName(),
              parents: [{ type: "reference-input", id: "1" }, {
                type: "reference-input",
                id: "2",
              }],
            }],
          };
      }
    };
  var kde = {
      selection: a1,
      point: t1,
      line: J0,
      segment: n1,
      ray: o1,
      vector: qv,
      circle: $0,
      arc: W0,
      parallel: Z0,
      perpendicular: e1,
      midpoint: Q0,
      polygon: r1,
      compass: j0,
      angle: H0,
      directedangle: X0,
      reflect: i1,
      translate: s1,
      rotate: im,
      dilate: Y0,
      anglebisector: K0,
      "box-selection": om,
      "expression-edit": Rh,
    },
    cR = kde;
  var _de = true, Ide = false, P$ = "**dcg_geo_tool_output_slider**";
  function Ade() {
    return {
      point: __dcg_shared_module_exports__["Rd"].PURPLE,
      line: __dcg_shared_module_exports__["Rd"].BLUE,
      circle: __dcg_shared_module_exports__["Rd"].GREEN,
      polygon: __dcg_shared_module_exports__["Rd"].BLUE,
      angle: __dcg_shared_module_exports__["Rd"].BLACK,
    };
  }
  function Mde(r, e) {
    let t = [], o = r.parents;
    for (let i = 0; i < o.length; i++) {
      let n = o[i];
      n.type === "hardcoded" ? t[i] = n.id : t[i] = e[n.id];
    }
    return t;
  }
  var l1 = class {
    constructor(e) {
      this.availableInputTypes = new Set();
      this._nextObjectId = 0;
      this.clear(),
        this.controller = e,
        this.s = this.controller.s,
        this._tools = {};
      for (let t in cR) this._tools[t] = new cR[t](this);
    }
    onPreviewChange() {
      var n;
      let e = this.controller.getToolPreviewJSONState(),
        t = this.getUncommittedObjects();
      if (
        this.getCurrentTool() instanceof Rh &&
        !this.controller.getValidCursorContext()
      ) {
        t = { ...t };
        for (let a in e) {
          let s = e[a];
          s.type === "expression-edit-preview-latex" && (t[a] = s);
        }
      }
      let i = this.getNonObjectsState().ui.currentTool.lockedIds;
      for (let a in t) {
        let s = t[a];
        s.type === "polygon-segment" &&
          (!i[a] ||
            Object.keys(t).some((l) => !i[l] && t[l].parents.includes(a))) &&
          (t[a] = { ...s, showAsSepratePreviewObject: true });
      }
      __dcg_shared_module_exports__["E"](e, t)
        ? this.controller.dispatch({ type: "render" })
        : this.controller.dispatch({
          type: "set-tool-preview-state",
          state: t,
        }),
        (n = this.controller.get2dPOIController()) == null ||
        n.updateGeoHoveredObjects();
    }
    peekNextObjectId() {
      return "\\token{" + this._nextObjectId.toString() + "}";
    }
    generateObjectId() {
      let e = this.peekNextObjectId();
      return this._nextObjectId += 1, e;
    }
    updateNextObjectId(e) {
      e > this._nextObjectId && (this._nextObjectId = e);
    }
    clear() {
      let e = {
        objects: {},
        ui: {
          currentTool: {
            name: "selection",
            idMap: {},
            reusableInputIdMap: {},
            lockedIds: {},
            inputIndex: 0,
            outputHistory: {},
            forceSingleUse: false,
          },
          colors: Ade(),
          clickToInsertMode: "valid-type",
        },
        hoveredObjects: [],
        uncommittedIds: {},
        selectedIds: {},
        nextSelectionNumber: 1,
        fadeAnimations: {},
        maxAnimationEndTime: 0,
      };
      this.store ? this.store.set(e) : this.store = new Nc(e);
    }
    onFocus(e) {
      this.clearHoveredObjects(),
        this.getCurrentTool().onFocus(e),
        this.onPreviewChange();
    }
    onMouseAction(e, t) {
      let o = this.getCurrentTool();
      if (o instanceof Rh && !this.controller.getValidCursorContext()) {
        return { committed: void 0, handled: false };
      }
      switch (
        this.updateNextObjectId(
          this.controller.findLastTokenNumber() + 1,
        ),
          this.clearHoveredObjects(),
          e
      ) {
        case "move":
          return { committed: void 0, handled: o.onMove(t) };
        case "release":
          o.onMove(t);
          let i = o.tryCommitResults();
          return i.committed
            ? { ...i, handled: true }
            : { committed: void 0, handled: false };
      }
    }
    generatePureToolOutput(e, t) {
      let o = this.getTool(e);
      if (!(o instanceof Vr)) return;
      let i = t.map((d) => d.typedValue), n = o.getMatchingWorkflow(i);
      if (!n) return;
      let a = pV(n.firstMatch, i, false), s = {}, l = {};
      for (let d = 0; d < t.length; d++) l[d] = t[d].referenceLatex;
      this.updateNextObjectId(this.controller.findLastTokenNumber() + 1),
        this.generateIdsForNewToolOutputs(a);
      let { ui: c } = this.getNonObjectsState();
      for (let d of a) {
        let p = c.currentTool.idMap[d.id];
        s[p] = {
          ...d,
          color: this.defaultColorForObject(c, d),
          id: p,
          parents: d.parents.map((h, u) => {
            var f;
            return (f = l[u]) != null ? f : "";
          }),
        };
      }
      return { canCommit: n.canCommit, outputs: s };
    }
    getNonObjectsState() {
      return { ...this.store.getState(), objects: void 0 };
    }
    getCurrentTool() {
      return this.getTool(this.getToolMode());
    }
    getTool(e) {
      return this._tools[e];
    }
    getClickToInsertMode() {
      return this.store.getState().ui.clickToInsertMode;
    }
    setClickToInsertMode(e) {
      this.store.set(["ui", "clickToInsertMode"], e);
    }
    defaultColorForObject(e, t) {
      switch (t.type) {
        case "point":
        case "point-reference":
        case "midpoint":
        case "glider":
        case "intersection":
        case "vector-endpoint":
          return e.colors.point;
        case "polygon-segment":
          return t.polygonColor || e.colors.line;
        case "line":
        case "segment":
        case "ray":
        case "vector":
        case "vector-copy":
        case "perpendicular":
        case "parallel":
        case "anglebisector":
          return e.colors.line;
        case "circle":
        case "compass":
        case "arc":
          return e.colors.circle;
        case "polygon":
          return e.colors.polygon;
        case "angle":
        case "polygon-angle":
        case "directedangle":
        case "polygon-directedangle":
          return e.colors.angle;
        case "dilate":
        case "reflect":
        case "rotate":
        case "translate":
          return __dcg_shared_module_exports__["Rd"].GRAY;
        case "slider":
          return __dcg_shared_module_exports__["Rd"].BLACK;
        case "expression-edit-preview-latex":
          return t.color || __dcg_shared_module_exports__["Rd"].BLACK;
        default:
          return t;
      }
    }
    _deselectAll() {
      this.store.shallowMutate((e) => {
        e.nextSelectionNumber = 1, e.selectedIds = {};
      });
    }
    _modifySelection(e) {
      let t = this.getNonObjectsState().nextSelectionNumber;
      this.store.shallowMutate("selectedIds", (o) => {
        for (let i in e) e[i] ? o[i] || (o[i] = t, t += 1) : delete o[i];
      }), this.store.set("nextSelectionNumber", t);
    }
    _addObjects(e) {
      this.store.shallowMutate("objects", (t) => {
        for (let o of e) t[o.id] = o;
      });
    }
    _deleteObjects(e) {
      if (!e.length) return;
      let t = {};
      this.store.shallowMutate("objects", (o) => {
        for (let i of e) t[i] = Ide, delete o[i];
      }),
        this._modifySelection(t),
        this.store.shallowMutate("uncommittedIds", (o) => {
          for (let i of e) delete o[i];
        });
    }
    createCustomToolOutput(e) {
      var n;
      this.generateIdsForNewToolOutputs(e.outputs);
      let { idMap: t } = this.getNonObjectsState().ui.currentTool,
        o = [],
        i = this.getNonObjectsState().ui;
      for (let a of e.outputs) {
        let s;
        a.type === "polygon-segment"
          ? s = a.polygonColor
          : s = this.defaultColorForObject(i, a);
        let l = { ...a, id: t[a.id], color: s, parents: Mde(a, t) };
        o.push(l);
      }
      for (let a of e.inputs) {
        if ((n = a.numberInputInfo) != null && n.sliderInfo) {
          let s = a.numberInputInfo.sliderInfo, l = t[`${a.id}-number`];
          if (ya(l)) {
            let c = GN(l);
            if (c && c in __dcg_shared_module_exports__["qc"]) continue;
            this.controller.getItemsByIdentifier(
              __dcg_shared_module_exports__["latexToIdentifier"](l),
            ).length ||
              o.push({
                type: "slider",
                lhsLatex: l,
                rhsLatex: s.value,
                sliderInfo: s,
                id: P$,
                parents: [],
                hidden: false,
                color: "#000",
              });
          }
        }
      }
      this._shouldNewObjectsBeMarkedUncommitted() &&
      this.store.shallowMutate("uncommittedIds", (a) => {
        for (let s of o) a[s.id] = true;
      }), this._addObjects(o);
    }
    _getReusableIdForCurrentInput(e) {
      let t = this.getCurrentTool();
      if (!t.getSpec) return;
      let { inputIndex: o, reusableInputIdMap: i } =
          this.getNonObjectsState().ui.currentTool,
        a = t.getSpec().inputs[o];
      if (!a) return;
      let s = a.id;
      return e !== void 0 && (s += "-" + e), i[s];
    }
    _createInputObject(e, t) {
      let o, i = this._shouldNewObjectsBeMarkedUncommitted();
      i
        ? o = this._getReusableIdForCurrentInput(t) ||
          this.generateObjectId()
        : o = this.generateObjectId(),
        i && this.store.set(["uncommittedIds", o], true);
      let n = this.defaultColorForObject(this.getNonObjectsState().ui, e),
        a = {
          hidden: e.type === "point" && !!e.previewOnly,
          ...e,
          id: o,
          color: n,
        };
      return this._addObjects([a]), o;
    }
    attemptLockToolInputIn(e) {
      let { inputIndex: t, idMap: o } =
          this.getNonObjectsState().ui.currentTool,
        i = this.getCurrentTool();
      if (!(i instanceof _c)) return;
      let n = i.getSpecIdToLockIn(e, t);
      if (!n) return;
      let a = o[n];
      if (!a) {
        this.getCurrentTool().canNextInputBePoint() ||
          this.controller.dispatch({
            type: "select-geo-tool",
            tool: "selection",
          });
        return;
      }
      let s = a && this.store.getState().objects[a];
      if (s && s.type === "point" && s.previewOnly) {
        this.controller.dispatch({
          type: "select-geo-tool",
          tool: "selection",
        });
        return;
      }
      this.store.set(["ui", "currentTool", "inputIndex"], t + 1),
        this.store.set(["ui", "currentTool", "lockedIds", a], true);
      for (let l = 0; l < 2; l++) {
        let c = n + "-" + l, d = o[c];
        d && this.store.set(["ui", "currentTool", "lockedIds", d], true);
      }
      i.didLockInput(e), this.updateFadeAnimations();
    }
    generateIdsForNewToolOutputs(e) {
      let { idMap: t } = this.getNonObjectsState().ui.currentTool,
        o = false,
        i = {};
      for (let n of e) {
        t[n.id] || (o = true, i[n.id] = this.generateObjectId());
      }
      o && this.store.set(["ui", "currentTool", "idMap"], { ...t, ...i });
    }
    tentativelyMatchToolInput(e, t) {
      let { currentTool: o } = this.getNonObjectsState().ui,
        i = o.inputIndex,
        n = e.inputs[i];
      if (!n) return;
      let a = n.id;
      this.store.set(["ui", "currentTool", "idMap", a], t);
    }
    storeNumberInputLatex(e, t) {
      let { currentTool: o } = this.getNonObjectsState().ui,
        i = o.inputIndex,
        n = e.inputs[i];
      if (!(n != null && n.numberInputInfo)) return;
      let a = n.id;
      this.store.set(["ui", "currentTool", "idMap", `${a}-number`], t);
    }
    createToolInputDependency(e, t, o) {
      let i = this._createInputObject(e, o),
        { currentTool: n } = this.getNonObjectsState().ui,
        a = n.inputIndex,
        s = t.inputs[a];
      if (!s) {
        throw So("geo tool could not find input in spec", {
          metaData: {
            fnArgs: { objectDef: e, toolSpec: t, depIndex: o },
            localVars: {
              newObjectId: i,
              currentTool: n,
              inputIndex: a,
              input: s,
            },
            toolState: this.store.getState(),
          },
        }),
          new Error(
            "programming error: could not find input " + a + " in spec",
          );
      }
      let l = s.id;
      return this.store.set(
        ["ui", "currentTool", "idMap", l + "-" + o],
        i,
      ),
        i;
    }
    isObjectALockedToolInput(e) {
      return !!this.getNonObjectsState().ui.currentTool.lockedIds[e];
    }
    isDegenerateInput(e) {
      let t = this.getCurrentTool();
      return t instanceof _c ? t.isDegenerateInput(e) : false;
    }
    getEnabledAdditionalTools() {
      return v$.filter((e) => true);
    }
    getAdditionalTools() {
      return this.getEnabledAdditionalTools();
    }
    isAnyAdditionalToolEnabled() {
      return this.getAdditionalTools().length > 0;
    }
    setObjectSelected(e) {
      let t = {};
      t[e] = _de, this._modifySelection(t);
    }
    setObjectsSelected(e) {
      __dcg_shared_module_exports__["g"](e, (t) => {
        this.setObjectSelected(t);
      });
    }
    deleteSelectedObjects() {
      let e = this.getSelectedObjectIdsUnsorted();
      this._deleteObjects(e);
    }
    isObjectUncommitted(e) {
      return !!this.getNonObjectsState().uncommittedIds[e];
    }
    getUncommittedObjectIds() {
      return Object.keys(this.getNonObjectsState().uncommittedIds);
    }
    getUncommittedObjects() {
      let e = {},
        t = this.store.getState().objects,
        o = this.getUncommittedObjectIds();
      for (let i of o) e[i] = t[i];
      return e;
    }
    isValidNextInputType(e) {
      let t = this.getCurrentTool(), o = t.getNonPointInputType();
      return e && __dcg_shared_module_exports__["isList"](e) &&
        (e = __dcg_shared_module_exports__["elementType"](e)),
        !!(o && e && WD(e, o) ||
          t.canNextInputBePoint() && e && WD(e, "point"));
    }
    recordCommittedOutput(e) {
      this.store.shallowMutate(
        ["ui", "currentTool", "outputHistory"],
        (t) => {
          t[e] = true;
        },
      );
    }
    updateFadeAnimations() {
      let e = this.controller.getAllItemModels(),
        t = Date.now(),
        o = -1 / 0;
      this.store.shallowMutate(["fadeAnimations"], (i) => {
        var s, l;
        if (this.getCurrentTool().shouldHighlightRelevantObjects()) {
          for (let c of e) {
            if (c.type !== "expression" || !c.latex) {
              continue;
            }
            let d = c.id,
              p = (s = c.formula) == null ? void 0 : s.geometry,
              h,
              u = p == null ? void 0 : p.valueType;
            p != null && p.unconstructable ||
              this.controller.shouldIgnoreGraphInteractions(c)
              ? h = "fade-out"
              : this.isValidNextInputType(
                      __dcg_shared_module_exports__["Point"],
                    ) &&
                    (Dm(KD(u)) ||
                      __dcg_shared_module_exports__["isList"](u) &&
                        Dm(
                          KD(__dcg_shared_module_exports__["elementType"](u)),
                        )) ||
                  u &&
                    __dcg_shared_module_exports__["isTypeOrListOfType"](
                      u,
                      __dcg_shared_module_exports__["Polygon"],
                    ) &&
                    this.isValidNextInputType(
                      __dcg_shared_module_exports__["Segment"],
                    ) ||
                  this.isValidNextInputType(u) ||
                  this.store.getState().ui.currentTool.outputHistory[d]
              ? h = "fade-in"
              : h = "fade-out";
            let f = this.store.getState().fadeAnimations[d];
            if (f && f.type !== h) {
              let y = __dcg_shared_module_exports__["clamp"](
                  t - f.start,
                  0,
                  150,
                ),
                C = t + y - 150;
              i[d] = { type: h, start: C }, o = Math.max(o, C);
            } else if (h === "fade-out") {
              let y = (l = f == null ? void 0 : f.start) != null ? l : t;
              i[d] = { type: "fade-out", start: y }, o = Math.max(o, y);
            }
          }
        } else {
          for (let c in i) i[c] = { type: "fade-in", start: t - 150 };
          o = t - 150;
        }
      }), isFinite(o) && this.store.set("maxAnimationEndTime", o + 150);
    }
    getToolFadeOpacity(e) {
      let t = this.controller.getItemModel(e);
      if ((t == null ? void 0 : t.type) !== "expression") return 1;
      let o = this.store.getState().fadeAnimations[t.id];
      if (!o) return 1;
      let i = Date.now(),
        n = __dcg_shared_module_exports__["clamp"](
          (i - o.start) / 150,
          0,
          1,
        ),
        a = o.type === "fade-in" ? .2 : 1,
        s = o.type === "fade-in" ? 1 : .2;
      return a * (1 - n) + s * n;
    }
    updateAvailableInputTypes() {
      let e = this.controller.getAllItemModels();
      this.availableInputTypes = Pde(e);
    }
    isToolActuallyUsable(e) {
      let t = this.controller.getGeoModel().getTool(e);
      if (t instanceof Vr) {
        let o = t.getWorkflows();
        for (let i of this.availableInputTypes) {
          if (o.some((n) => n.signature.matches([i]))) return true;
        }
        return false;
      }
      return true;
    }
    isFading() {
      return Date.now() <= this.store.getState().maxAnimationEndTime;
    }
    isObjectSelected(e) {
      return !!this.getNonObjectsState().selectedIds[e];
    }
    getSelectedObjectIdsUnsorted() {
      return Object.keys(this.getNonObjectsState().selectedIds);
    }
    getSelectedObjectIdsSorted() {
      let e = this.getNonObjectsState().selectedIds,
        t = this.getSelectedObjectIdsUnsorted();
      return __dcg_shared_module_exports__["q"](t, (i) => e[i]);
    }
    deselectAllObjects() {
      this._deselectAll();
    }
    getToolMode() {
      return this.getNonObjectsState().ui.currentTool.name;
    }
    setToolMode(e) {
      let t = this.getToolMode(),
        o = this.getNonObjectsState().ui.currentTool;
      this.store.set(["ui", "currentTool"], {
        name: e,
        idMap: {},
        reusableInputIdMap: {},
        lockedIds: {},
        inputIndex: 0,
        outputHistory: e !== t ? {} : o.outputHistory,
        forceSingleUse: e !== t ? false : o.forceSingleUse,
      }),
        this.updateFadeAnimations(),
        e !== t && this.controller.isGraphPaperFocused() &&
        (e !== "expression-edit" &&
          yt(this.getCurrentToolDisplayName() + "."),
          this.speakCurrentGeoToolHint());
    }
    resetToolMode() {
      this.setToolMode(this.getToolMode());
    }
    markCurrentToolSingleUse() {
      this.store.set(["ui", "currentTool", "forceSingleUse"], true);
    }
    areAnyObjectsHovered() {
      return !!this.getNonObjectsState().hoveredObjects.length;
    }
    setObjectHovered(e) {
      this.store.deepMutate((t) => {
        t.hoveredObjects.push(e);
      });
    }
    objectIsInstanceOf(e, t) {
      let o = e == null ? void 0 : e.typedRuntimeValue.valueType;
      if (o) return WD(o, t);
    }
    getSelectionBox() {
      return this.getTool("selection").getSelectionBox();
    }
    commitObjects() {
      this.store.set("uncommittedIds", {}), this.store.set("objects", {});
    }
    applyTransformation(e) {}
    getProjection() {
      return this.controller.get2dProjection();
    }
    _getPixelsAwayFromDef(e, t, o) {
      let i = o.typedRuntimeValue;
      switch (i.valueType) {
        case __dcg_shared_module_exports__["Point"]: {
          let a = t.mapx(i.value[0]), s = t.mapy(i.value[1]);
          return __dcg_shared_module_exports__["MathHypot"](e.x - a, e.y - s) -
            6;
        }
        case __dcg_shared_module_exports__["Line"]:
        case __dcg_shared_module_exports__["Segment"]:
        case __dcg_shared_module_exports__["Ray"]:
        case __dcg_shared_module_exports__["Vector"]: {
          let n, a, s, l;
          if (i.valueType === __dcg_shared_module_exports__["Vector"]) {
            let [[h, u], [f, y]] = nm(i.value);
            n = t.mapx(h), s = t.mapy(u), a = t.mapx(f), l = t.mapy(y);
          } else {n = t.mapx(i.value[0][0]),
              s = t.mapy(i.value[0][1]),
              a = t.mapx(i.value[1][0]),
              l = t.mapy(i.value[1][1]);}
          let c = i.valueType === __dcg_shared_module_exports__["Line"],
            d = i.valueType === __dcg_shared_module_exports__["Line"] ||
              i.valueType === __dcg_shared_module_exports__["Ray"],
            p = __dcg_shared_module_exports__["W"](
              e.x,
              e.y,
              n,
              s,
              a,
              l,
              c,
              d,
            );
          return p
            ? __dcg_shared_module_exports__["MathHypot"](p[0] - e.x, p[1] - e.y)
            : 1 / 0;
        }
        case __dcg_shared_module_exports__["Circle"]: {
          let n = i.value[0][0],
            a = i.value[0][1],
            s = i.value[1],
            l = 0,
            c = Math.PI * 2,
            d = t.reverse_mapx(e.x),
            p = t.reverse_mapy(e.y),
            h = __dcg_shared_module_exports__["X"](d, p, n, a, s, l, c);
          return h
            ? t.screen.width / (t.viewport.xmax - t.viewport.xmin) *
              __dcg_shared_module_exports__["MathHypot"](h[0] - d, h[1] - p)
            : 1 / 0;
        }
        case __dcg_shared_module_exports__["Arc"]: {
          let n = __dcg_shared_module_exports__["getArcDetails"](i.value);
          if (!n) return 1 / 0;
          let a = (s, l, c, d) => {
            let p = t.mapx(s[0]),
              h = t.mapy(s[1]),
              u = t.mapx(l[0]),
              f = t.mapy(l[1]),
              y = __dcg_shared_module_exports__["W"](
                e.x,
                e.y,
                p,
                h,
                u,
                f,
                c,
                d,
              );
            return y
              ? __dcg_shared_module_exports__["MathHypot"](
                y[0] - e.x,
                y[1] - e.y,
              )
              : 1 / 0;
          };
          if (n.type === "arc") {
            let s = t.reverse_mapx(e.x),
              l = t.reverse_mapy(e.y),
              c = __dcg_shared_module_exports__["X"](
                s,
                l,
                n.center[0],
                n.center[1],
                n.radius,
                n.startAngle,
                n.endAngle,
              );
            return c
              ? t.screen.width / (t.viewport.xmax - t.viewport.xmin) *
                __dcg_shared_module_exports__["MathHypot"](c[0] - s, c[1] - l)
              : 1 / 0;
          } else {return n.type === "segment"
              ? a(n.start, n.end, false, false)
              : Math.min(
                a(n.start1, n.end1, false, true),
                a(n.start2, n.end2, false, true),
              );}
        }
        case __dcg_shared_module_exports__["Polygon"]: {
          let n = [];
          return i.value.forEach((a) => {
            n.push(t.mapx(a[0]), t.mapy(a[1]));
          }),
            __dcg_shared_module_exports__["ba"](n, [e.x, e.y]) ? 0 : 1 / 0;
        }
        case __dcg_shared_module_exports__["AngleMarker"]:
        case __dcg_shared_module_exports__["DirectedAngleMarker"]: {
          let n = t.screen.width / (t.viewport.xmax - t.viewport.xmin),
            a = t.screen.height / (t.viewport.ymax - t.viewport.ymin),
            [[s, l], c, d] = i.value,
            p = Zu(d, t),
            h = p / n,
            u = t.reverse_mapx(e.x),
            f = t.reverse_mapy(e.y),
            y = 1 / 0,
            C = f - l,
            E = u - s,
            v = Math.atan2(C, E);
          if (__dcg_shared_module_exports__["Q"](v, c, d)) {
            __dcg_shared_module_exports__["MathHypot"](C * a, E * n) <= p + 7 &&
              (y = 0);
          } else {
            let w = __dcg_shared_module_exports__["V"](
                u,
                f,
                s + h * Math.cos(c),
                l + h * Math.sin(c),
                s,
                l,
              ),
              S = __dcg_shared_module_exports__["V"](
                u,
                f,
                s + h * Math.cos(c + d),
                l + h * Math.sin(c + d),
                s,
                l,
              ),
              k = __dcg_shared_module_exports__["MathHypot"](
                n * (w[0] - u),
                a * (w[1] - f),
              ),
              _ = __dcg_shared_module_exports__["MathHypot"](
                n * (S[0] - u),
                a * (S[1] - f),
              );
            y = Math.min(k, _);
          }
          return y;
        }
        case __dcg_shared_module_exports__["Transformation"]:
          return 1 / 0;
        default:
          return 1 / 0;
      }
    }
    getAllChoosableDefsUnordered(e, t) {
      var h;
      if (!this.controller.isGeometry()) return [];
      let o = [],
        i = e.mode === "tab",
        n = e.mode === "mouse",
        a = i && this.controller.getActiveTool() === "box-selection",
        s = false,
        l = false;
      (h = t.isValidNextInputType) != null &&
      h.call(t, __dcg_shared_module_exports__["Point"]) && (s = true),
        t.shouldUseJitEdges() &&
        (t.isValidNextInputType(__dcg_shared_module_exports__["Segment"]) ||
          t.isValidNextInputType(__dcg_shared_module_exports__["Line"]) ||
          t.isValidNextInputType(__dcg_shared_module_exports__["Ray"])) &&
        (l = true);
      let c = n && s;
      c && (l = true);
      let { lockedIds: d, reusableInputIdMap: p } =
        this.store.getState().ui.currentTool;
      return Qg({ controller: this.controller }, (u, f) => {
        var C, E;
        if (!u.isGraphableAndInteractive) return;
        let y = u.assignment;
        for (let v in p) if (p[v] === y && !d[y]) return;
        if (
          !u.hidden && !u.data.unconstructable &&
          !(this.getToolMode() === "expression-edit" &&
            ((C = u.data) != null && C.depends_on_selected)) &&
          !(a && this.controller.isClickableId(u.calcId)) &&
          !(i &&
            this.isDegenerateInput(u == null ? void 0 : u.assignment)) &&
          !(i && f)
        ) {
          if (
            u.typedRuntimeValue.valueType ===
              __dcg_shared_module_exports__["Polygon"]
          ) {
            if (u.typedRuntimeValue.value.length) {
              if (l) {
                let v = u;
                if (
                  v.typedRuntimeValue.valueType ===
                    __dcg_shared_module_exports__["Polygon"]
                ) {
                  let w = v.typedRuntimeValue.value;
                  for (let S = 0; S < w.length; S++) {
                    let k = w[S],
                      _ = w[(S + 1) % w.length],
                      A = v.referenceLatex +
                        ".\\operatorname{segments}\\left[" + (S + 1) +
                        "\\right]",
                      P = {
                        calcId: v.calcId,
                        listIndex: v.listIndex,
                        hidden: v.hidden,
                        isGraphableAndInteractive: false,
                        assignment: A,
                        referenceLatex: A,
                        data: v.data,
                        typedRuntimeValue: {
                          valueType: __dcg_shared_module_exports__["Segment"],
                          value: [k, _],
                        },
                        polygonEdgeInfo: { edgeNumber: S, polygonDef: v },
                      };
                    o.push(P);
                  }
                }
              }
            } else return;
          }
          if (
            c &&
            !__dcg_shared_module_exports__["isTypeOrListOfType"](
              u.typedRuntimeValue.valueType,
              __dcg_shared_module_exports__["Polygon"],
            )
          ) {
            o.push(u);
            return;
          }
          if (
            (E = t.isValidNextInputType) != null &&
            E.call(t, u.typedRuntimeValue.valueType)
          ) {
            o.push(u);
            return;
          }
        }
      }),
        o;
    }
    _getObjectsUnderMouse(e, t, o) {
      let i = this.getAllChoosableDefsUnordered({ mode: "mouse" }, o),
        n = this.getProjection(),
        a = [];
      i.forEach((c) => {
        let d = this._getPixelsAwayFromDef(e, n, c),
          p = c.polygonEdgeInfo ? -1 : 0;
        if (d <= t) {
          let h = { def: c, layerNumber: p, pixelsAway: d };
          a.push(h);
        }
      });
      let s = this.controller.get2dSketchOrder(), l = {};
      for (let c = 0; c < s.length; c++) l[s[c]] = c;
      return a.sort((c, d) => {
        let p = d.layerNumber - c.layerNumber;
        if (p !== 0) return p;
        let h = c.pixelsAway - d.pixelsAway;
        if (h !== 0) return h;
        let u = l[c.def.calcId];
        return l[d.def.calcId] - u;
      }),
        a;
    }
    convertCanvasPixelsToPoint(e) {
      return this.getProjection().reverse_map_pt(e);
    }
    convertPointToCanvasPixels(e) {
      return this.getProjection().map_pt(e);
    }
    deleteObjectsAndRememberReusableId(e) {
      for (let t in e) this._deleteObjects([e[t]]);
      this._deleteObjects([P$]),
        this.store.shallowMutate(
          ["ui", "currentTool"],
          (t) => t.reusableInputIdMap = e,
        );
    }
    getObjectDefUnderMouse(e, t, o) {
      let i = this.convertPointToCanvasPixels(e),
        n = this._getObjectsUnderMouse(i, t, o);
      return n.length > 0 ? n[0].def : void 0;
    }
    getOrCreatePointNearMouse(e, t) {
      let o = this.convertPointToCanvasPixels(e),
        i = this._getObjectsUnderMouse(o, t, this.getCurrentTool()),
        n = [];
      for (let h of i) {
        let u = h.def, f = c6(u);
        f === "Point"
          ? n.push({ def: u, type: f })
          : (Dm(f) || f === "Vector") && n.push({ def: u, type: f });
      }
      let { def: a, type: s } = n[0] || {},
        { def: l, type: c } = n[1] || {},
        d = this.controller.isGeoToolEnabled("point");
      if (s === "Point") return { type: "def", def: a };
      if (Dm(s) && Dm(c)) {
        let h = D$(a, l).map((u) => ({
          x: u.x,
          y: u.y,
          i: u.i,
          pixelsFromPoint: V$(
            this.getProjection(),
            dh(u.x - e.x, u.y - e.y),
          ),
        }));
        if (
          h.sort((u, f) => u.pixelsFromPoint - f.pixelsFromPoint),
            h = h.filter((u) => u.pixelsFromPoint < 5),
            h[0]
        ) {
          let u = h[0].i === 0 ? [a, l] : [l, a],
            f = this.findIncidentPointDef(a, l);
          if (f != null && f.hidden) {
            let y = false, C;
            if (
              cV(f.typedRuntimeValue, (E, v) => {
                let [w, S] = E.value,
                  k = this.getProjection().mathToPixels.mapPoint({
                    x: w,
                    y: S,
                  });
                dh(k.x - o.x, k.y - o.y) < t && (y = true, C = v);
              }), y
            ) {
              return C !== void 0 && (f = dV(f, C)), {
                type: "spec",
                spec: {
                  type: "point-reference",
                  targetSpec: { type: "intersection", parentDefs: u },
                  parentDefs: [f],
                },
              };
            }
          }
          return {
            type: "spec",
            spec: { type: "intersection", parentDefs: u },
          };
        } else if (d) return O$(this.getProjection(), e, a);
      } else {
        if (d && Dm(s)) return O$(this.getProjection(), e, a);
        if (s === "Vector") {
          let u = nm(a.typedRuntimeValue.value).map((f, y) => ({
            index: y,
            point: { x: f[0], y: f[1] },
            pixelsFromPoint: V$(
              this.getProjection(),
              dh(f[0] - e.x, f[1] - e.y),
            ),
          })).sort((f, y) => f.pixelsFromPoint - y.pixelsFromPoint)
            .filter((f) => f.pixelsFromPoint < 5);
          if (u.length > 0) return Lde(a, u[0].index === 1 ? 1 : 0);
        }
      }
      let p = Gde(this.getProjection(), e);
      return {
        type: "spec",
        spec: {
          type: "point",
          x: p.x,
          y: p.y,
          parentDefs: [],
          previewOnly: !d,
        },
      };
    }
    findIncidentPointDef(e, t) {
      let o = e.typedRuntimeValue.valueType,
        i = t.typedRuntimeValue.valueType,
        n = {};
      Qg({ controller: this.controller, expandLists: false }, (l) => {
        if (
          l.data.identifier &&
          __dcg_shared_module_exports__["isTypeOrListOfType"](
            l.typedRuntimeValue.valueType,
            __dcg_shared_module_exports__["Point"],
          )
        ) {
          let c = l.data.identifier;
          n[c] = l;
        }
      });
      let a = __dcg_shared_module_exports__["Ec"](
          {
            getGeometryTree: (l) => l.data.call,
            isPointOrListOfPoints: (l) =>
              __dcg_shared_module_exports__["isTypeOrListOfType"](
                l.typedRuntimeValue.valueType,
                __dcg_shared_module_exports__["Point"],
              ),
            lookup: (l) => n[l],
            resolvesTo: (l, c) => l === c.data.identifier,
          },
          e,
          o,
          t,
          i,
        ),
        s = a && __dcg_shared_module_exports__["Cc"](a);
      if (s) {
        let l = n[s], c = a && __dcg_shared_module_exports__["Bc"](a);
        return c === void 0 ? l : dV(l, c);
      }
    }
    _shouldNewObjectsBeMarkedUncommitted() {
      return this.getToolMode() !== "selection";
    }
    clearHoveredObjects() {
      this.store.set("hoveredObjects", []);
    }
    getHoveredItems() {
      return this.store.getState().hoveredObjects;
    }
    cancelToolplay() {
      this._deleteObjects(this.getUncommittedObjectIds()),
        this.clearHoveredObjects(),
        this.resetToolMode();
    }
    isToolplayActive() {
      return this.getNonObjectsState().ui.currentTool.inputIndex > 0;
    }
    getComputedBoard() {
      let e = new q0();
      return Qg({ controller: this.controller }, (t, o) => {
        e.add(t, o);
      }),
        e;
    }
    findDefsForInputId(e) {
      let t = [];
      return Qg({ controller: this.controller }, (o) => {
        (o.assignment === e || o.referenceLatex === e) && t.push(o);
      }),
        t;
    }
    isCreatingNewTransform() {
      return this.getCurrentTool().toolType === "transformation";
    }
    getCurrentToolDisplayName() {
      return this.controller.s(this.getCurrentTool().displayName);
    }
    isCurrentToolComplex() {
      return this.getCurrentTool().toolType === "complex";
    }
    isCurrentToolSingleUse() {
      return this.getCurrentTool().toolType === "transformation" ||
        this.getNonObjectsState().ui.currentTool.forceSingleUse;
    }
    getIconInstructionsForTool(e) {
      let t = this.getTool(e);
      return t ? t.icon : [];
    }
    getDisplayNameForTool(e) {
      let t = this.getTool(e);
      return t ? this.controller.s(t.displayName) : "";
    }
    speakCurrentGeoToolHint() {
      xe(this.getCurrentTool().getHint());
    }
  };
  function Gde(r, e) {
    let t = ZO(r, e);
    t && (e = t);
    let o = .5 / R$(r);
    return { x: ho(e.x - o, e.x + o), y: ho(e.y - o, e.y + o) };
  }
  function R$(r) {
    return r.mapx(1) - r.mapx(0);
  }
  function V$(r, e) {
    return R$(r) * e - 6;
  }
  function O$(r, e, t) {
    return {
      type: "spec",
      spec: {
        type: "glider",
        t: $I(r, e, t.typedRuntimeValue),
        parentDefs: [t],
      },
    };
  }
  function Lde(r, e) {
    return {
      type: "spec",
      spec: {
        type: "vector-endpoint",
        location: e ? "end" : "start",
        parentDefs: [r],
      },
    };
  }
  function Pde(r) {
    let e = new Set();
    e.add(__dcg_shared_module_exports__["Point"]);
    for (let t of r) {
      if (
        t.type !== "expression" || !t.formula.typed_constant_value ||
        t.hidden
      ) continue;
      let o = t.formula.typed_constant_value.valueType,
        i = __dcg_shared_module_exports__["isList"](o)
          ? __dcg_shared_module_exports__["elementType"](o)
          : o;
      __dcg_shared_module_exports__["isGeometryType"](i) && e.add(i),
        i === __dcg_shared_module_exports__["Polygon"] &&
        e.add(__dcg_shared_module_exports__["Segment"]);
    }
    return e;
  }
  function bi(r, e, t) {
    let o = Vde(r, e, t);
    qr(r, o);
  }
  function qr(r, e) {
    if (
      r.focusLocation = e,
        !e ||
        (e.type === "ticker" &&
          (r.getListModel().ticker.playing = false,
            Nr(r.getListModel(), void 0)),
          e.type === "settings" || e.type === "generic-menu" ||
          e.type === "editable-label" || e.type === "add-item-btn" ||
          e.type === "add-expression-btn" || e.type === "add-note-btn" ||
          e.type === "add-table-btn" || e.type === "add-folder-btn" ||
          e.type === "add-ticker-btn" || e.type === "add-image-btn" ||
          e.type === "edit-list-toggle" ||
          e.type === "hide-expression-list-btn" ||
          e.type === "show-expression-list-btn" ||
          e.type === "zoom-in-btn" || e.type === "zoom-restore-btn" ||
          e.type === "search-expressions" ||
          e.type === "replace-expressions" || e.type === "ticker" ||
          e.type === "geo-token" ||
          e.type === "geo-show-constructions-icon" ||
          e.type === "geo-basic-tool" ||
          e.type === "geo-basic-tool-menu-item" ||
          e.type === "geo-construct-menu-existing-transformations" ||
          e.type === "multi-select-more-icon" ||
          e.type === "multi-select-construct-icon" ||
          e.type === "multi-select-style-icon" ||
          e.type === "multi-select-label-icon" ||
          e.type === "geo-header-back-link" ||
          e.type === "multi-select-show-hide-icon" ||
          e.type === "new-transformation-number" ||
          e.type === "label-points-icon" || e.type === "graph-paper" ||
          e.type === "quest" || e.type === "global-mute-button" ||
          e.type === "color-picker-option" ||
          e.type === "multi-select-label-menu-label-input")
    ) return;
    let t = r.getItemModel(e.id);
    if (e.type === "expression-menu") {
      Nr(r.getListModel(), void 0);
      return;
    } else Nr(r.getListModel(), t);
    t && t.type === "expression" && As(t, false);
  }
  function Vde(r, e, t) {
    let o = r.getItemModel(e);
    if (!o) return;
    let i = r.isInEditListMode() || r.isItemReadonly(o.id);
    switch (o.type) {
      case "expression":
        return { type: i ? "readonly-expression" : o.type, id: e };
      case "folder":
      case "text":
        return { type: o.type, id: e };
      case "table": {
        let a = { row: 1, column: 0 }, s = false;
        return t &&
          (t.location === "cell"
            ? a = { row: t.row, column: t.column }
            : t === "end"
            ? a = { row: Pl(o), column: 0 }
            : t === "start"
            ? a = { row: 0, column: 0 }
            : t === "container" && (s = true)),
          s
            ? { type: "table-container", id: e }
            : { type: o.type, id: e, location: a };
      }
      case "image":
        return { type: o.type, id: e, location: "name" };
      default:
        return o;
    }
  }
  function F$(r) {
    let e = r.getSelectedItem();
    if (e && e.type === "expression" && !e.readonly) {
      bi(r, e.id);
      return;
    }
    if (e && e.type === "table" && r.focusLocation && !e.readonly) return;
    let t = r.getFirstFullyVisibleItem(), o = r.getListModel();
    for (; t && (t.type !== "expression" || t.readonly);) {
      t = Tw(o, t.index);
    }
    if (t) {
      bi(r, t.id);
      return;
    }
    let i = r.createItemModel({
      type: "expression",
      id: r.generateId(),
      color: r.getNextColor(),
    });
    ol(r.getListModel(), i), bi(r, i.id);
  }
  function N$(r) {
    let e = r.focusLocation;
    if (
      e &&
      !(e.type === "settings" || e.type === "generic-menu" ||
        e.type === "editable-label" || e.type === "add-item-btn" ||
        e.type === "add-expression-btn" || e.type === "add-note-btn" ||
        e.type === "add-table-btn" || e.type === "add-ticker-btn" ||
        e.type === "add-folder-btn" || e.type === "add-image-btn" ||
        e.type === "edit-list-toggle" ||
        e.type === "hide-expression-list-btn" ||
        e.type === "show-expression-list-btn" ||
        e.type === "zoom-in-btn" || e.type === "zoom-restore-btn" ||
        e.type === "search-expressions" ||
        e.type === "replace-expressions" || e.type === "ticker" ||
        e.type === "geo-token" ||
        e.type === "geo-show-constructions-icon" ||
        e.type === "geo-basic-tool" ||
        e.type === "geo-basic-tool-menu-item" ||
        e.type === "geo-construct-menu-existing-transformations" ||
        e.type === "multi-select-more-icon" ||
        e.type === "multi-select-construct-icon" ||
        e.type === "multi-select-style-icon" ||
        e.type === "multi-select-label-icon" ||
        e.type === "geo-header-back-link" ||
        e.type === "multi-select-show-hide-icon" ||
        e.type === "new-transformation-number" ||
        e.type === "label-points-icon" || e.type === "graph-paper" ||
        e.type === "quest" || e.type === "global-mute-button" ||
        e.type === "color-picker-option" ||
        e.type === "multi-select-label-menu-label-input")
    ) return r.getItemModel(e.id);
  }
  function ox(r, e, t) {
    qr(r, { type: "table", id: e, location: t });
  }
  function U$(r, e, t) {
    let o = r.getItemModel(e);
    if (!o || o.type !== "table") return;
    let i = o,
      n = wa(i),
      a = n ? n.row : -1,
      s = n ? n.column : -1,
      l = i.columnModels,
      c = Pl(i),
      d = l.length,
      p = (y, C) => {
        y === -1
          ? JI(r)
          : y > c
          ? QI(r)
          : (C === -1 ? (C = d - 1, y--) : C === d && (y++, C = 0),
            ox(r, e, { row: y, column: C }));
      },
      h = (y) => {
        c > 2 && oz(i, a - 1), ox(r, e, { row: y, column: s });
      },
      u = (y) => {
        s === 0 || d <= 2 || (mw(i, s), ox(r, e, { row: a, column: y }));
      },
      f = !!Uf(i.columnModels[0]);
    switch (t) {
      case "Left":
        p(a, s - 1);
        break;
      case "Right":
        p(a, s + 1);
        break;
      case "Up":
        p(a - 1, s);
        break;
      case "Down":
        p(a + 1, s);
        break;
      case "PageUp":
        return JI(r);
      case "PageDown":
        return QI(r);
      case "Enter":
        if (a >= c) return uR(r);
        if (s > 0 || f) return p(a + 1, s);
        if (a === c - 1) {
          let y = iz(i, a);
          OG(i, a);
          for (let C = 0; C < y.length; C++) {
            vp(i, { row: a + 1, column: C }, y[C]);
          }
          ox(r, e, { row: a + 1, column: s });
          return;
        }
        OG(i, a), ox(r, e, { row: a + 1, column: s });
        break;
      case "Backspace":
        a === 0
          ? s === 0
            ? dR(r)
            : s === d - 1 || s === 1 && d === 3
            ? p(0, s - 1)
            : u(s - 1)
          : s !== 0
          ? p(a, s - 1)
          : a === c || f
          ? p(a - 1, s)
          : h(a - 1);
        break;
      case "Delete":
        a === 0 ? s === 0 ? pR(r) : s < d - 1 && u(s) : a >= c || f || h(a);
        break;
    }
  }
  function JI(r) {
    if (r.inAudioTraceMode()) return;
    let e = r.getFocusLocation(), t = r.getListModel();
    if (
      (e == null ? void 0 : e.type) === "ticker" &&
      r.getExpressionSearchOpen()
    ) return qr(r, { type: "search-expressions" });
    let o = r.getSelectedItem();
    if (!o) return;
    if (NE(t)) {
      if (o = r.getSelectedItem(), !o) return;
      bi(
        r,
        o.id,
        r.isInEditListMode() && o.type === "table" ? "container" : "end",
      );
    } else {r.getTickerVisible()
        ? qr(r, { type: "ticker", location: "handler" })
        : r.getExpressionSearchOpen() &&
          qr(r, { type: "search-expressions" });}
  }
  function QI(r) {
    if (r.inAudioTraceMode()) return;
    let e = r.getFocusLocation(), t = r.getListModel();
    if (
      (e == null ? void 0 : e.type) === "search-expressions" &&
      r.getTickerVisible()
    ) return qr(r, { type: "ticker", location: "handler" });
    if (
      (e == null ? void 0 : e.type) === "ticker" ||
      (e == null ? void 0 : e.type) === "search-expressions"
    ) {
      let i = eb(t);
      if (i) {
        return bi(
          r,
          i.id,
          r.isInEditListMode() && i.type === "table" ? "container" : "start",
        );
      }
    }
    if (!BE(t) && !r.isInEditListMode()) {
      let i = r.createItemModel({
        type: "expression",
        id: r.generateId(),
        color: r.getNextColor(),
      });
      ol(t, i), Nr(t, i);
    }
    let o = r.getSelectedItem();
    if (o) {
      return bi(
        r,
        o.id,
        r.isInEditListMode() && o.type === "table" ? "container" : "start",
      );
    }
  }
  function dR(r) {
    if (r.isInEditListMode()) return;
    let e = r.getSelectedItem();
    if (!e || r.getItemCount() === 1 && e.type === "expression") return;
    let t = e.type === "text", o = Ca(e);
    if (o) {
      let i = r.getNumberOfItemsInFolder(o.id);
      if (e.index === o.index + i) {
        _n(e, "");
        return;
      }
    }
    if (hR(r, { moveSelection: true }), t && tl && mp) {
      Nr(r.getListModel(), void 0);
      return;
    }
    e = r.getSelectedItem(), e && bi(r, e.id, "end");
  }
  function pR(r) {
    if (r.isInEditListMode()) return;
    let e = r.getSelectedItem();
    e &&
      (r.getItemCount() === 1 && e.type === "expression" ||
        (gR(r, { moveSelection: true }),
          e = r.getSelectedItem(),
          e && bi(r, e.id, "start")));
  }
  function uR(r) {
    if (r.isInEditListMode()) return;
    let e = r.getSelectedItem();
    if (!e) return;
    if (e.type === "text" && tl && mp) {
      Jr(), Nr(r.getListModel(), void 0);
      return;
    }
    if (e.type === "expression" && Ep(e).length > 0) {
      return r.createSlidersForItem(e.id, Ep(e).concat(""));
    }
    let t = Iw(e);
    if (t.length > 0 && t.length <= zw && r.areSlidersEnabled()) {
      return r.createSlidersForItem(e.id, Iw(e).concat(""));
    }
    let o = r.createItemModel({
        type: "expression",
        id: r.generateId(),
        color: r.getNextColor(),
      }),
      i = e.index + 1;
    e.type === "folder" && e.collapsed &&
    (i += r.getNumberOfItemsInFolder(e.id)),
      _s(r.getListModel(), o, i),
      Nr(r.getListModel(), o),
      e.type === "folder" && !e.collapsed
        ? _n(o, e.id)
        : e.type !== "folder" && e.folderId && _n(o, e.folderId),
      e = r.getSelectedItem(),
      e && bi(r, e.id);
  }
  function hR(r, { moveSelection: e }) {
    let t = r.getSelectedItem(), o = r.getListModel();
    if (!t || r.isItemReadonly(t.id)) return;
    let i = Ew(o, t.index);
    if (r._removeExpressionSynchronously(t), e) {
      if (!i) {
        let n = eb(o);
        n && (i = n);
      }
      Nr(o, i);
    } else Nr(o, void 0);
  }
  function gR(r, { moveSelection: e }) {
    let t = r.getSelectedItem(), o = r.getListModel();
    if (!t || r.isItemReadonly(t.id)) return;
    let i = Tw(o, t.index);
    if (r._removeExpressionSynchronously(t), e) {
      if (!i) {
        let n = PE(o);
        n && (i = n);
      }
      Nr(o, i);
    } else Nr(o, void 0);
  }
  qt();
  var Rde = {
    loga: (r, e) => {
      Fe.canAcceptText(
        r,
        e.capExpressionSize,
        "\\log_{}\\left(\\right)",
      ) &&
        (r.write("\\log_{}"),
          r.typedText("("),
          r.keystroke("Left"),
          r.keystroke("Down"));
    },
    nthroot: (r, e) => {
      Fe.canAcceptText(r, e.capExpressionSize, "\\sqrt[]{}") &&
        (r.write("\\sqrt[]{}"), r.keystroke("Left"), r.keystroke("Left"));
    },
    ddx: (r, e) => {
      Fe.canAcceptText(r, e.capExpressionSize, "\\frac{d}{dx}") &&
        r.write("\\frac{d}{dx}");
    },
    arcsin: (r, e) => {
      Fe.canAcceptText(
        r,
        e.capExpressionSize,
        "\\sin^{-1}\\left(\\right)",
      ) && (r.write("sin^{-1}"), r.typedText("("));
    },
    arccos: (r, e) => {
      Fe.canAcceptText(
        r,
        e.capExpressionSize,
        "\\cos^{-1}\\left(\\right)",
      ) && (r.write("cos^{-1}"), r.typedText("("));
    },
    arctan: (r, e) => {
      Fe.canAcceptText(
        r,
        e.capExpressionSize,
        "\\tan^{-1}\\left(\\right)",
      ) && (r.write("tan^{-1}"), r.typedText("("));
    },
    arcsec: (r, e) => {
      Fe.canAcceptText(
        r,
        e.capExpressionSize,
        "\\sec^{-1}\\left(\\right)",
      ) && (r.write("sec^{-1}"), r.typedText("("));
    },
    arccsc: (r, e) => {
      Fe.canAcceptText(
        r,
        e.capExpressionSize,
        "\\csc^{-1}\\left(\\right)",
      ) && (r.write("csc^{-1}"), r.typedText("("));
    },
    arccot: (r, e) => {
      Fe.canAcceptText(
        r,
        e.capExpressionSize,
        "\\cot^{-1}\\left(\\right)",
      ) && (r.write("cot^{-1}"), r.typedText("("));
    },
    "A^T": (r, e) => {
      Fe.canAcceptText(r, e.capExpressionSize, "^{T}") &&
        (r.typedText("^T"), r.keystroke("Right"));
    },
    "A^-1": (r, e) => {
      Fe.canAcceptText(r, e.capExpressionSize, "^{-1}") &&
        (r.typedText("^-1"), r.keystroke("Right"));
    },
    "A^2": (r, e) => {
      Fe.canAcceptText(r, e.capExpressionSize, "^{2}") &&
        (r.typedText("^2"), r.keystroke("Right"));
    },
    "a^2": (r, e) => {
      Fe.canAcceptText(r, e.capExpressionSize, "^{2}") &&
        (r.typedText("^2"), r.keystroke("Right"));
    },
    "a^3": (r, e) => {
      Fe.canAcceptText(r, e.capExpressionSize, "^{3}") &&
        (r.typedText("^3"), r.keystroke("Right"));
    },
    "a/b": (r, e) => {
      Fe.canAcceptText(r, e.capExpressionSize, "\\frac{}{}") &&
        (r.write("\\frac{}{}"), r.keystroke("Left"));
    },
    integral: (r, e) => {
      Fe.canAcceptText(r, e.capExpressionSize, "\\int_{}^{}") &&
        r.cmd("integral");
    },
  };
  function ZI(r, e, t) {
    Rde[e](r, t);
  }
  var mR = (r) => ({
      value: r.degreeMode ? "30" : "0.5",
      min: "0",
      max: r.degreeMode ? "360" : "2\\pi",
    }),
    q$ = { min: "0", max: "5", value: "1" },
    ix = (r) => ({ min: "0", max: "1", value: `${r}` }),
    Fde = {
      latex: void 0,
      polarDomainMin: void 0,
      polarDomainMax: void 0,
      parametricDomainMin: void 0,
      parametricDomainMax: void 0,
      parametricDomain3DuMin: void 0,
      parametricDomain3DuMax: void 0,
      parametricDomain3DvMin: void 0,
      parametricDomain3DvMax: void 0,
      parametricDomain3DrMin: void 0,
      parametricDomain3DrMax: void 0,
      parametricDomain3DphiMin: void 0,
      parametricDomain3DphiMax: void 0,
      clickableInfoLatex: void 0,
      colorLatex: void 0,
      tableColumnColorLatex: void 0,
      cdfMin: () => ({ value: "0", min: "-10", max: "10" }),
      cdfMax: () => ({ value: "0", min: "-10", max: "10" }),
      pointSize: () => ({ value: 8 + "", min: "0", max: "20" }),
      movablePointSize: () => ({ value: 8 + "", min: "0", max: "20" }),
      tableColumnPointSize: () => ({
        value: 8 + "",
        min: "0",
        max: "20",
      }),
      labelAngle: mR,
      labelSize: () => ({ value: "1", min: "0", max: "5" }),
      lineWidth: () => ({ value: 2.5 + "", min: "0", max: "10" }),
      resolution: () => ({
        value: "50",
        min: "2",
        max: "100",
        step: "1",
      }),
      tableColumnLineWidth: () => ({
        value: 2.5 + "",
        min: "0",
        max: "10",
      }),
      fillOpacity: () => ({ value: .4 + "", min: "0", max: "1" }),
      surfaceOpacity: () => ({ value: "0.9", min: "0", max: "1" }),
      lineOpacity: () => ({ value: 1 + "", min: "0", max: "1" }),
      tableColumnLineOpacity: () => ix(1),
      pointOpacity: () => ix(1),
      tableColumnPointOpacity: () => ix(1),
      sliderMin: void 0,
      sliderMax: void 0,
      sliderStep: void 0,
      residualVariable: void 0,
      tableHeader: void 0,
      tableCellValue: void 0,
      imageOpacity: () => ({ value: "1", min: "0", max: "1" }),
      imageCenter: void 0,
      imageHeight: () => ({ value: "10", min: "-10", max: "10" }),
      imageWidth: () => ({ value: "10", min: "-10", max: "10" }),
      imageAngle: mR,
      tickerMinStep: () => ({ value: "0", min: "0" }),
      tickerHandler: void 0,
    },
    H$ = {
      tone: {
        paramBounds: (r) =>
          r === 0 ? { value: "440", min: "110", max: "880" } : ix(.5),
      },
      glider: {
        paramBounds: (r) => {
          if (r !== 0) return ix(.5);
        },
      },
      dilate: {
        paramBounds: (r) => {
          if (!(r < 2)) return { value: "2", min: "0", max: "5" };
        },
      },
      rotate: {
        paramBounds: (r, e) => {
          if (!(r < 2)) return mR(e);
        },
      },
      circle: {
        paramBounds: (r) => {
          if (r === 1) return q$;
        },
      },
      normaldist: {
        paramBounds: (r) => {
          if (r === 0) return { min: "-5", max: "5", value: "0" };
          if (r === 1) return q$;
        },
      },
      rgb: {
        paramBounds: (r) => ({
          value: "0",
          min: "0",
          max: "255",
          step: "1",
        }),
      },
      hsv: {
        paramBounds: (r) =>
          r === 0 ? { value: "0", min: "0", max: "360", step: "1" } : ix(.5),
      },
    };
  function K$(r, e, t) {
    let o = r.map((n) => ({
        location: n.location,
        parsed: __dcg_shared_module_exports__["Wc"](n.latex),
      })
      ),
      i = {};
    for (let n of e) {
      for (let a of o) {
        let s = Nde(n, a, t);
        s && s.length && (i[n] = s[0]);
      }
    }
    return i;
  }
  function Nde(r, { parsed: e, location: t }, o) {
    let i = __dcg_shared_module_exports__["latexToIdentifier"](r);
    if (e.type === "Identifier" && e._symbol === i) {
      let a = Fde[t];
      return a ? [a(o)] : void 0;
    }
    e.type === "Assignment" && (e = e._expression);
    let n = [];
    switch (e.type) {
      case "FunctionCall": {
        let a = e._symbol;
        if (H$.hasOwnProperty(a)) {
          let s = H$[a];
          e.args.forEach((l, c) => {
            if (l.type === "Identifier" && l._symbol === i) {
              let d = s.paramBounds(c, o);
              d && n.push(d);
            }
          });
        }
        break;
      }
      default:
        return;
    }
    return n;
  }
  var su = class r {
    constructor(e = 100) {
      this.clear(), this._sizeLimit = e;
    }
    clone() {
      let e = new r(this._sizeLimit);
      return e._stack = this._stack.slice(),
        e._stackPointer = this._stackPointer,
        e;
    }
    clear() {
      this._stack = [], this._stackPointer = -1;
    }
    getState() {
      return this._stack[this._stackPointer];
    }
    serializeForBugsnag() {
      function e(t) {
        try {
          return JSON.stringify(t, null, 2);
        } catch (o) {
          return "[[could not jsonify]]";
        }
      }
      return {
        currentState: e(this._stack[this._stackPointer]),
        undoState: e(this._stack[this._stackPointer - 1]),
        redoState: e(this._stack[this._stackPointer + 1]),
      };
    }
    addState(e) {
      this.canRedo() && this._stack.splice(this._stackPointer + 1),
        this._stack.push(e),
        this._stack.length > this._sizeLimit && this._stack.shift(),
        this._stackPointer = this._stack.length - 1;
    }
    replaceState(e) {
      this.canRedo() && this._stack.splice(this._stackPointer + 1),
        this.replaceInteriorState(e);
    }
    replaceInteriorState(e) {
      this._stack.length === 0
        ? (this._stack.push(e), this._stackPointer = 0)
        : this._stack[this._stackPointer] = e;
    }
    canUndo() {
      return this._stackPointer > 0;
    }
    canRedo() {
      return this._stackPointer < this._stack.length - 1;
    }
    undo() {
      this.canUndo() && (this._stackPointer -= 1);
    }
    redo() {
      this.canRedo() && (this._stackPointer += 1);
    }
  };
  function Ude(r) {
    switch (r) {
      case "histogram":
      case "dotplot":
        return 12;
      case "boxplot":
        return 40;
    }
    return 1 / 0;
  }
  function zde(r) {
    return r === "boxplot" || r === "dotplot" || r == "histogram";
  }
  function qde(r) {
    return r === "boxplot" ? 3 : .5;
  }
  function Hde(r, e) {
    if (r.type === "dotplot" || r.type === "histogram") {
      let i = Math.max(1, r.xmax - r.xmin) * 80 /
          (r.binWidth ? r.binWidth : 1),
        n = .5 * (e.screen.width - i) / i;
      return Math.max(.2, n);
    }
    return .5;
  }
  function Kde(r, e, t) {
    r = __dcg_shared_module_exports__["Jc"](r);
    let o = 1.2;
    return e && r.xmax < 0 && r.xmin < 0 &&
      r.xmax / (r.xmin - r.xmax) < o && (r.xmax = 0),
      e && r.xmax > 0 && r.xmin > 0 && r.xmin / (r.xmax - r.xmin) < o &&
      (r.xmin = 0),
      t && r.ymax < 0 && r.ymin < 0 && r.ymax / (r.ymin - r.ymax) < o &&
      (r.ymax = 0),
      t && r.ymax > 0 && r.ymin > 0 && r.ymin / (r.ymax - r.ymin) < o &&
      (r.ymin = 0),
      r;
  }
  function Wde(r, e, t, o) {
    let i = r.type, n = Hde(r, e), a = qde(i), s, l, c, d;
    if (
      r.xmin === r.xmax &&
      (t ? (r.xmin -= .5, r.xmax += .5) : (r.xmin *= .5, r.xmax /= .5)),
        r.ymin === r.ymax &&
        (o ? (r.ymin -= .5, r.ymax += .5) : (r.ymin *= .5, r.ymax /= .5)),
        t
    ) {
      let p = (r.xmax - r.xmin) * n;
      s = r.xmin - p, l = r.xmax + p;
    } else {
      let p = (r.xmax / r.xmin) ** n;
      s = r.xmin / p, l = r.xmax * p;
    }
    if (o) {
      let p = (r.ymax - r.ymin) * a;
      c = r.ymin - p, d = r.ymax + p;
    } else {
      let p = (r.ymax / r.ymin) ** a;
      c = r.ymin / p, d = r.ymax * p;
    }
    if (zde(i)) {
      let p = e.screen.height / e.screen.width, h = (l - s) * p;
      if (h > r.ymax - r.ymin && h < Ude(i) * (r.ymax - r.ymin)) {
        let u = .5 * (r.ymax + r.ymin);
        d = u + .5 * h, c = u - .5 * h;
      }
    }
    return { xmin: s, xmax: l, ymin: c, ymax: d };
  }
  function eA(r, e) {
    let t = c1(r, e);
    if (!t) return false;
    let { xAxisScale: o, yAxisScale: i } = e.settings;
    if (!Br.fromObject(t).isValid({ xAxisScale: o, yAxisScale: i })) {
      return false;
    }
    let a = e.mapx(t.xmin),
      s = e.mapx(t.xmax),
      l = e.mapy(t.ymin),
      c = e.mapy(t.ymax),
      d = 10;
    return !(Math.abs(a) <= d && Math.abs(c) <= d &&
      Math.abs(s - e.screen.width) <= d &&
      Math.abs(l - e.screen.height) <= d);
  }
  function c1(r, e) {
    let t = 1 / 0,
      o = -1 / 0,
      i = 1 / 0,
      n = -1 / 0,
      a = 0,
      s = r.length,
      l = e.settings.xAxisScale === "linear",
      c = e.settings.yAxisScale === "linear";
    for (let d = 0; d < s; d++) {
      let p = Kde(r[d], l, c);
      if (!isFinite(p.xmax - p.xmin) || !isFinite(p.ymax - p.ymin)) {
        a += 1;
        continue;
      }
      if (
        !l && !(p.xmax > 0 && p.xmin > 0) ||
        !c && !(p.ymax > 0 && p.ymin > 0)
      ) {
        a += 1;
        continue;
      }
      let h = Wde(p, e, l, c);
      h.xmin < t && (t = h.xmin),
        h.xmax > o && (o = h.xmax),
        h.ymin < i && (i = h.ymin),
        h.ymax > n && (n = h.ymax);
    }
    if (a !== s) return { xmin: t, xmax: o, ymin: i, ymax: n };
  }
  function $de(r) {
    var o, i;
    let e = r && r.id, t = [];
    if (r && r.type === "table") {
      r.columnModels.forEach((a) => {
        t.push(a.id);
      }), (o = r.regression) != null && o.id && t.push(r.regression.id);
      let n = wa(r);
      if (!n) {
        let a = r.controller.getFocusLocation();
        if ((a == null ? void 0 : a.type) === "table-icon") {
          let s = r.columnModels.findIndex((l) => l.id === a.columnId);
          s >= 0 && (n = { row: 0, column: s });
        }
      }
      if (n) {
        let a = r.columnModels[n.column];
        e = a ? a.id : void 0;
      } else e = (i = r.regression) == null ? void 0 : i.id;
      return { selected: e ? [e] : [], hoistedToTop: t };
    }
    return e
      ? { selected: [e], hoistedToTop: [e] }
      : { selected: [], hoistedToTop: [] };
  }
  function W$(r, e, t) {
    let o = {}, i = {}, n = r.getAllSelectedItems();
    for (let a of n) {
      let s = $de(a);
      for (let l of s.selected) {
        o[l] = true, t.selected[l] || e.selectSketch(l);
      }
      for (let l of s.hoistedToTop) {
        i[l] = true, t.hoistedToTop[l] || e.setSketchHoistedToTop(l, true);
      }
    }
    for (let a in t.selected) o[a] || e.deselectSketch(a);
    for (let a in t.hoistedToTop) i[a] || e.setSketchHoistedToTop(a, false);
    return { selected: o, hoistedToTop: i };
  }
  function jde(r) {
    for (let e in r) return false;
    return true;
  }
  function Yde(r) {
    var o;
    if (r.type !== "expression") return;
    let e = r.formula.assignment;
    return e ||
      ((o = r.formula.geometry) == null ? void 0 : o.identifier);
  }
  function Xde(r) {
    var t, o, i;
    let e = { lookupIdentifier: {}, lookupCalcId: {} };
    for (let n of r) {
      let a = {
        calcId: n.id,
        identifier: Yde(n),
        referencesTheseIdentifiers: {},
        referencedByTheseCalcIds: {},
      };
      e.lookupCalcId[a.calcId] = a,
        a.identifier && (e.lookupIdentifier[a.identifier] = a);
    }
    for (let n of r) {
      let a = e.lookupCalcId[n.id];
      if (a) {
        if (n.type === "expression") {
          n.folderId === __dcg_shared_module_exports__["xd"] &&
            (a.isGarbageCollectable = !n.readonly,
              (((o = (t = n.formula.geometry) == null ? void 0 : t.call) == null
                    ? void 0
                    : o.symbol) === "segments" || mc(n)) &&
              (a.deleteIfNotReferenced = true));
          for (
            let s of ((i = n.formula.geometry) == null
              ? void 0
              : i.parentDependencies) || []
          ) {
            $$(e, a, s);
          }
        }
        Jf(n, (s) => {
          let l = s.match(/(\\token{[0-9]+})/g);
          if (l) {
            for (let c of l) {
              let d = __dcg_shared_module_exports__["latexToIdentifier"](c);
              d !== a.identifier && $$(e, a, d);
            }
          }
        });
      }
    }
    return e;
  }
  function $$(r, e, t) {
    e.referencesTheseIdentifiers[t] = true;
    let o = r.lookupIdentifier[t];
    o && (o.referencedByTheseCalcIds[e.calcId] = true);
  }
  function Jde(r, e, t) {
    var a;
    let o = [];
    for (let s of e) {
      let l = r.lookupCalcId[s];
      if (!l) continue;
      o.push(l);
      let c = l.referencesTheseIdentifiers;
      for (let d in c) {
        let p = r.lookupIdentifier[d];
        p && delete p.referencedByTheseCalcIds[l.calcId];
      }
    }
    let i = {};
    for (let s in t) {
      for (let l of t[s]) {
        let c = r.lookupIdentifier[l];
        c && delete c.referencedByTheseCalcIds[s], i[l] = true;
      }
    }
    let n = {};
    for (let s of o) {
      let l = s.referencesTheseIdentifiers;
      for (let d in l) i[d] = true;
      let c = s.identifier;
      if (c) {
        let d = (a = r.lookupIdentifier[c]) == null
          ? void 0
          : a.referencedByTheseCalcIds;
        if (d) {
          for (let p in d) {
            let h = r.lookupCalcId[p];
            h && h.isGarbageCollectable && (n[p] = true);
          }
        }
      }
    }
    for (let s in i) {
      let l = r.lookupIdentifier[s];
      if (l && l.deleteIfNotReferenced) {
        let c = l.referencedByTheseCalcIds;
        l.calcId && l.isGarbageCollectable && jde(c) &&
          (n[l.calcId] = true);
      }
    }
    for (let s of o) {
      delete r.lookupCalcId[s.calcId],
        s.identifier && delete r.lookupIdentifier[s.identifier];
    }
    return Object.keys(n);
  }
  function j$(r, e, t) {
    var c;
    let o = r.getAllItemModels(),
      i = e.map((d) => d.id),
      n = Xde(o.concat(e)),
      a = {},
      s = {};
    for (let d in t) {
      let { nextLatex: p } = t[d], h = r.getItemModel(d);
      if ((h == null ? void 0 : h.type) !== "expression") continue;
      let u = {};
      for (
        let y of ((c = h.formula.geometry) == null
          ? void 0
          : c.parentDependencies) || []
      ) {
        u[y] = true;
      }
      for (let y in u) {
        Il(p, __dcg_shared_module_exports__["identifierToLatex"](y)) &&
          delete u[y];
      }
      let f = Object.keys(u);
      f.length && (s[d] = f);
    }
    let l = Object.keys(s).length > 0;
    for (; i.length || l;) {
      l = false, i = Jde(n, i, s);
      for (let d of i) a[d] = true;
    }
    return Object.keys(a);
  }
  var Y$ = Symbol("privateHistoryProperty"),
    tA = class {
      constructor(e, t) {
        this.currentState = e;
        this.__historyThatShouldNotBeSerialized = Symbol(
          "__historyThatShouldNotBeSerialized",
        );
        Object.defineProperty(this, Y$, {
          value: t.clone(),
          enumerable: false,
          configurable: false,
          writable: false,
        });
      }
      toJSON() {
        throw new Error(
          "Operation unsupported: history should not be serialized.",
        );
      }
    };
  function X$(r) {
    let e = r;
    return { currentState: e.currentState, history: e[Y$] };
  }
  var J$ = {
    version: _l,
    randomSeed: "",
    graph: {
      product: "graphing-3d",
      threeDMode: true,
      viewport: { ...__dcg_shared_module_exports__["xc"] },
    },
    expressions: { list: [{ id: "1", type: "expression" }] },
  };
  function Q$(r) {
    switch (r) {
      case "letters":
        return "capitalLetters";
      case "noQwertyLetters":
        return "noQwertyCapitalLetters";
      case "noQwertyCapitalLetters":
        return "noQwertyLetters";
      default:
        return "letters";
    }
  }
  function Z$(r) {
    switch (r) {
      case "mainNumbers":
        return "mainNumbers3D";
      default:
        return r;
    }
  }
  function fR(r) {
    return {
      keypadMinimized: !Q5,
      keypadLayout: "mainNumbers",
      keypadFunctionsOpen: false,
      graphSettingsOpen: false,
      addExpressionOpen: false,
      expressionsVisible: !!r.expressions,
      inEditListMode: false,
      isFileDraggedOver: false,
      expressionsHiddenTime: void 0,
    };
  }
  var Yo = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    rA = class extends Yo.Class {
      template() {
        return Yo.createElement(
          "form",
          {
            name: Yo.const("open_graph_on_web"),
            target: Yo.const("_blank"),
            method: Yo.const("POST"),
            action: () => this.props.saveURL(),
            style: () => ({ display: "none" }),
          },
          Yo.createElement("input", {
            type: Yo.const("text"),
            name: Yo.const("is_open_on_web"),
            value: Yo.const("true"),
          }),
          Yo.createElement("input", {
            type: Yo.const("text"),
            name: Yo.const("my_graphs"),
            value: Yo.const("false"),
          }),
          Yo.createElement("input", {
            type: Yo.const("text"),
            name: Yo.const("is_update"),
            value: Yo.const("false"),
          }),
          Yo.createElement("input", {
            type: Yo.const("text"),
            name: Yo.const("calc_state"),
            value: () => this.props.stateData(),
          }),
          Yo.createElement("input", {
            type: Yo.const("text"),
            name: Yo.const("thumb_data"),
            value: () => this.props.thumbData(),
          }),
        );
      }
    };
  var tj = {
    xmin: "",
    xmax: "",
    xstep: "",
    ymin: "",
    ymax: "",
    ystep: "",
    zmin: "",
    zmax: "",
  };
  function rj(r) {
    return r in tj;
  }
  function Qde(r) {
    let e = r.split("\xD7");
    return (e.length > 1 && e[0] === "1" ? e.slice(1) : e).join("\\cdot");
  }
  function _m(r, e) {
    let t = __dcg_shared_module_exports__["value"](r, e), o = "";
    if (t.mantissa) o = Qde(t.mantissa) + "^{" + t.superscript + "}";
    else {
      let i = t.string.split("/");
      i.length === 2
        ? i[0][0] === "-"
          ? o = "-\\frac{" + i[0].slice(1) + "}{" + i[1] + "}"
          : o = "\\frac{" + i[0] + "}{" + i[1] + "}"
        : o = t.string;
    }
    return o = o.replace(//, "\\pi"), o;
  }
  function Zde(r, e) {
    let t = e.xAxisScale === "linear" ? r.xmax - r.xmin : void 0,
      o = e.yAxisScale === "linear" ? r.ymax - r.ymin : void 0,
      i = {
        xmin: _m(r.xmin, t),
        xmax: _m(r.xmax, t),
        ymin: _m(r.ymin, o),
        ymax: _m(r.ymax, o),
      };
    return r.zmin !== void 0 && r.zmax !== void 0 &&
      (i.zmin = _m(r.zmin, r.zmax - r.zmin),
        i.zmax = _m(r.zmax, r.zmax - r.zmin)),
      i;
  }
  function ej(r, e) {
    return r === 0 ? "" : _m(r, e);
  }
  function oj(r, e) {
    return {
      ...Zde(r, e.scales),
      xstep: ej(e.steps.xAxisStep, r.xmax - r.xmin),
      ystep: ej(e.steps.yAxisStep, r.ymax - r.ymin),
    };
  }
  function bR() {
    return { limitLatex: { ...tj } };
  }
  function ij(r) {
    var e;
    switch (r.type) {
      case "tick":
      case "tick-ticker":
      case "evaluator-progress-update":
        return false;
      case "on-evaluator-changes":
        return !!((e = r.eventUpdates) != null && e.userAction);
      default:
        return true;
    }
  }
  var Im = class {
    constructor(e) {
      this.__nextItemId = 0;
      this.__pendingImageUploads = {};
      this.__lastSelectedIdsForPropagation = {
        selected: {},
        hoistedToTop: {},
      };
      this.nextSubscription = 0;
      this.subscriptions = {};
      this._queuedCallbacks = [];
      this._hasUnsavedChanges = false;
      this.shouldScrollSelectedItemIntoViewAfterDispatch = false;
      this.lastParsableObjects = {};
      this.isExpressionSearchStrValidForReplace = false;
      this.isExpressionReplaceStrValidForReplace = false;
      this.expressionSearchCount = 0;
      this.expressionSearchOpen = false;
      this.geoUIActive = false;
      this.showConstructionsOpen = false;
      this.activeTool = "selection";
      this.geometryGettingStartedMessageState = "pick-a-tool";
      this.activeTokens = { selected: void 0, hovered: void 0 };
      this.apiMethodCallStackInfo = {
        apiMethodCallDepth: 0,
        withHistoryReplacementDepth: 0,
      };
      this.canShowKeyboardShortcuts = false;
      this.progressUpdateLegendHidden = false;
      this.shellViews = {};
      this.toastData = {};
      this.s = Ip(() => this.graphSettings.config.language);
      this.raw = (e, t) => Gs(e, t);
      this.hasTranslation = (e) => {
        let t = this.graphSettings.config.language;
        return WL(e, t);
      };
      this.unpack = (e) => {
        let t = this.graphSettings.config.language;
        return Fl(e, t);
      };
      this.dispatch = (e) => {
        if (
          e.type === "blur-focus-location" &&
          this.dispatcher.isDispatching()
        ) {
          this.runAfterDispatch(() => {
            this.dispatch(e);
          });
          return;
        }
        if (
          e.type === "set-focus-location" &&
          this.dispatcher.isDispatching()
        ) {
          this.runAfterDispatch(() => {
            this.dispatch(e);
          });
          return;
        }
        if (e.type === "tick" && this.dispatcher.isDispatching()) {
          this.runAfterDispatch(() => {
            this.dispatch(e);
          });
          return;
        }
        e.type === "tick" ||
        Wx("dispatch::" + this.bugsnagContext, { type: e.type }),
          this.dispatcher.isDispatching() &&
          Wx("dispatch-in-dispatch::" + this.bugsnagContext, {
            type: e.type,
          }),
          this.dispatcher.dispatch(e),
          this.onEventsEmitted &&
          this.onEventsEmitted(this.enqueuedEvents),
          this.logEventsFromDispatch(e);
        let t;
        for (; t = this._queuedCallbacks.shift();) t();
      };
      this._requiresTickNextFrame = false;
      this.cachedGeoTokenDepths = {};
      this.cachedGeoTokenInfo = {};
      this.toolPreviewJSONState = {};
      this.updateViews = () => {
        for (let e in this.subscriptions) this.subscriptions[e]();
      };
      this.bugsnagContext = "";
      this.inPrintMode = false;
      this.lastInfiniteScrollFirstDOM = void 0;
      this.lastInfiniteScrollLastDOM = void 0;
      this.hasDispatchSinceLastInfiniteScrollUpdate = false;
      this.stateStack = new su();
      this.isCurrentlyDoingSetState = false;
      this.isCurrentlyDoingRestoreState = false;
      this.expressionActionsToRestartIfSlow = new Array();
      this.getQuestIsActive = () => false;
      this.logEvent = (e) => {};
      this.logEventsFromDispatch = (e) => {};
      var t, o;
      this.graphSettings = e,
        (o = (t = this.graphSettings).setController) == null ||
        o.call(t, this),
        this.listModel = M4(this),
        this.layoutModel = fR(this.graphSettings.config),
        this.layoutMeasurements = { width: 0, height: 0 },
        this.settingsViewModel = bR(),
        this.geometryToolbarModel = $z(),
        this.imageRetryState = { lastAttemptTime: 0, attempts: 0 },
        this.makeGeoAPI(),
        this.setupDispatcher(),
        this.toneAllowed() && (this.toneController = new Nw(this)),
        this.graphSettings.config.observe(
          "tone",
          () => this._updateToneAvailability(),
        ),
        this.graphSettings.config.observe(
          "audio",
          () => this._updateToneAvailability(),
        );
    }
    setShellView(e, t) {
      if (this.shellViews[e]) {
        throw new Error(`Shell view is already set: '${e}'.`);
      }
      this.shellViews[e] = t;
    }
    getShellView(e) {
      var t;
      return (t = this.shellViews) == null ? void 0 : t[e];
    }
    hasUnsavedChanges() {
      return this._hasUnsavedChanges;
    }
    getExpressionSearchOpen() {
      return this.expressionSearchOpen;
    }
    getShowConstructionsOpen() {
      return this.showConstructionsOpen;
    }
    getGeoToolbarSuppressedByAuthor() {
      return this.geometryToolbarModel.toolbar === "none" &&
        !this.shouldShowAuthorFeatures();
    }
    shouldShowGeoToolbar() {
      return this.isGeoUIActive() &&
        !this.getGeoToolbarSuppressedByAuthor();
    }
    isGeoUIActive() {
      return this.geoUIActive;
    }
    isGeoToolActive() {
      return this.activeTool !== "selection" &&
        this.activeTool !== "box-selection";
    }
    getActiveTool() {
      return this.activeTool;
    }
    canExpandListForItem(e) {
      let t = this.getItemModel(e);
      return t
        ? !this.isGeometry() ||
          this.activeTool !== "selection" &&
            this.activeTool !== "box-selection" ||
          this.isClickableId(e) || "label" in t && t.label !== ""
        : false;
    }
    getGeoModel() {
      return this.geoModel;
    }
    getGeoToolbarGroupKeys() {
      return vw(
        this.geometryToolbarModel,
        this.shouldShowAuthorFeatures(),
      ).groups;
    }
    getGeoToolbarItemsForGroup(e) {
      let { items: t } = vw(
        this.geometryToolbarModel,
        this.shouldShowAuthorFeatures(),
      );
      return t[e];
    }
    getAllAvailableGeoTools() {
      let e = vw(
          this.geometryToolbarModel,
          this.shouldShowAuthorFeatures(),
        ),
        t = [];
      for (let o of e.groups) {
        let i = e.items[o];
        i && (i.dropdown ? t.push(...i.dropdown) : t.push(i.current));
      }
      return t;
    }
    getAllVisibleGeoToolbarItems() {
      let e = this.getGeoToolbarGroupKeys(), t = [];
      for (let o of e) {
        let i = this.getGeoToolbarItemsForGroup(o);
        i && t.push(i);
      }
      return t;
    }
    getTickerOpen() {
      return this.areActionsEnabled() ? this.listModel.ticker.open : false;
    }
    getTickerVisible() {
      return this.getTickerOpen() && !this.getTicker().filteredBySearch;
    }
    getTickerPlaying() {
      return this.areActionsEnabled() ? this.listModel.ticker.playing : false;
    }
    hasVisibleToast() {
      return !__dcg_shared_module_exports__["F"](this.toastData);
    }
    hasVisibleAndUndoableToast() {
      return typeof this.toastData.undoCallback == "function";
    }
    toastUndo() {
      typeof this.toastData.undoCallback == "function" &&
        (this.toastData.undoCallback(), this.dispatch({ type: "toast/close" }));
    }
    runAfterDispatch(e) {
      this.dispatcher.isDispatching() ? this._queuedCallbacks.push(e) : e();
    }
    enqueueEvent(e, t) {
      var n;
      let o = this.apiMethodCallStackInfo.apiMethodCallDepth > 0,
        i = t && !o && ij(t) ||
          !!((n = this.enqueuedEvents[e]) != null && n.isUserInitiated) ||
          e === "userMovedPoint";
      this.enqueuedEvents[e] = { isUserInitiated: i };
    }
    getLanguage() {
      return this.graphSettings.config.language;
    }
    pushWithHistoryReplacement() {
      this.apiMethodCallStackInfo.withHistoryReplacementDepth++;
    }
    popWithHistoryReplacement() {
      if (
        this.apiMethodCallStackInfo.withHistoryReplacementDepth--,
          this.apiMethodCallStackInfo.withHistoryReplacementDepth < 0
      ) {
        throw new Error(
          "Programming Error: withHistoryReplacementDepth < 0",
        );
      }
    }
    pushAPIMethodCall() {
      this.apiMethodCallStackInfo.apiMethodCallDepth++;
    }
    popAPIMethodCall() {
      this.apiMethodCallStackInfo.apiMethodCallDepth--;
    }
    getGrapherDimensions() {
      let e = this.getGrapher();
      if (!e) return { width: 0, height: 0 };
      let { width: t, height: o } = e.getProjection().screen;
      return { width: t, height: o };
    }
    setRandomSeed(e) {
      this.graphSettings.setProperty("randomSeed", e);
    }
    getRandomSeed() {
      return this.graphSettings.randomSeed;
    }
    setIncludeFunctionParametersInRandomSeed(e) {
      this.graphSettings.setProperty(
        "includeFunctionParametersInRandomSeed",
        e,
      );
    }
    getIncludeFunctionParametersInRandomSeed() {
      return this.graphSettings.includeFunctionParametersInRandomSeed;
    }
    shouldDispatchTickNextFrame() {
      return !!this._requiresTickNextFrame;
    }
    markTickRequiredNextFrame() {
      this._requiresTickNextFrame = true;
    }
    handleTick(e) {
      let t = this.handlePossiblySlowEvaluator();
      this.areActionsEnabled() &&
        k4(this.listModel.ticker, {
          currentFrameTime: e,
          previousFrameTime: this.lastFrameTime,
        })
        ? this.dispatch({ type: "tick-ticker", time: e })
        : this.shouldDispatchTickNextFrame()
        ? this.dispatch({ type: "tick", time: e })
        : t && this.dispatch({ type: "render" }),
        this.getGeoModel().isFading() && this.requestRedrawGraph(),
        this.lastFrameTime = e;
    }
    setupDispatcher() {
      this.dispatcher = new U0(),
        this.dispatcher.register((e) => {
          var l;
          let t = this.getFirstSelectedItem(),
            o = this.getFocusLocation();
          this.shouldScrollSelectedItemIntoViewAfterDispatch = false;
          let i;
          this.enqueuedEvents = {
            change: void 0,
            graphReset: void 0,
            clearUnsavedChanges: void 0,
            openDrawer: void 0,
            showHotkeysModal: void 0,
            userMovedPoint: void 0,
            userClickedObject: void 0,
            userEditedLabel: void 0,
          },
            e.type === "tick" && (this._requiresTickNextFrame = false),
            this.isCurrentlyDoingSetState = false,
            this.isCurrentlyDoingRestoreState = false,
            this.handleDispatchedAction(e),
            this.constrainMultiSelect(),
            this.updateTheComputedWorld();
          let n = this.getImageToRetry();
          (this.getPlayingSliders().length > 0 ||
            this.isDragDropActive() || n) &&
          this.markTickRequiredNextFrame(),
            n && this.retryLoadingFailedImage(n),
            this.updateGeometryGettingStartedMessageState(),
            e.type !== "undo" && e.type !== "redo" &&
            e.type !== "restore-history" && !this.isDragDropActive() &&
            this.commitUndoRedoSynchronously(e),
            this.requestParseForAllItems(),
            this.isCurrentlyDoingSetState = false,
            this.isCurrentlyDoingRestoreState = false,
            this.enqueuedEvents.change &&
            ((l = this.getGrapher2d()) == null || l.markLabelsDirty()),
            this.enqueuedEvents.clearUnsavedChanges
              ? this._hasUnsavedChanges = false
              : this.enqueuedEvents.change &&
                (this._hasUnsavedChanges = true);
          let a = this.getFirstSelectedItem();
          a
            ? (!t || t.guid !== a.guid) &&
              (this.shouldScrollSelectedItemIntoViewAfterDispatch = true)
            : this.shouldScrollSelectedItemIntoViewAfterDispatch = false;
          let s = this.getFocusLocation();
          s && !__dcg_shared_module_exports__["E"](s, o) &&
          this.getFocusedItem() == a &&
          (this.shouldScrollSelectedItemIntoViewAfterDispatch = true),
            o && t && t.type === "table" && o.type === "table" &&
            (!s || s.type !== "table" || o.id !== s.id) && t.isExpanded &&
            (Nf(t, false), s || (i = t)),
            s && a && a.type === "table" && WU(a),
            (e.type === "adjust-slider-by-dragging-thumb" ||
              e.type === "adjust-slider-by-keyboard") &&
            (i = this.getItemModel(e.id)),
            this.updateRenderShellsBeforePaint(),
            this.updateViews(),
            i
              ? this.scrollItemIntoView(i)
              : this.shouldScrollSelectedItemIntoViewAfterDispatch &&
                this.scrollSelectedItemIntoView(),
            this.updateDragDrop(),
            this.updateRenderShellsAfterDispatch();
        });
    }
    updateGeometryGettingStartedMessageState() {
      if (!this.isGeometry()) return;
      let e = this.geometryGettingStartedMessageState,
        t = this.getActiveTool(),
        o = t === "selection" || t === "box-selection" ||
          t === "expression-edit";
      if (e === "hidden") return;
      if (
        this.isGraphSettingsOpen() || this.getGraphSettings().showGrid ||
        this.getGraphSettings().showYAxis
      ) {
        this.geometryGettingStartedMessageState = "hidden";
        return;
      }
      let i = this.getItemModelByIndex(1);
      if (
        this.getItemCount() > 2 || !i || i.type !== "expression" ||
        i.latex !== "" ||
        this.geoModel.getNonObjectsState().ui.currentTool.inputIndex > 0
      ) {
        this.geometryGettingStartedMessageState = "hidden";
        return;
      }
      o || (this.geometryGettingStartedMessageState = "construct");
    }
    getGeometryGettingStartedMessageState() {
      return this.geometryGettingStartedMessageState;
    }
    handleDispatchedAction(e) {
      var t, o, i, n, a, s, l, c, d, p, h, u, f, y, C, E, v, w, S, k;
      switch (e.type) {
        case "render":
          break;
        case "undo":
          this.isGeoToolActive() && this.cancelGeoToolplay(), this.undo();
          break;
        case "redo":
          this.isGeoToolActive() && this.cancelGeoToolplay(), this.redo();
          break;
        case "clear-undoredo-history":
          this.clearUndoRedoHistory();
          break;
        case "on-special-key-pressed":
          e.key === "Enter"
            ? uR(this)
            : e.key === "Up" || e.key === "PageUp"
            ? JI(this)
            : e.key === "Down" || e.key === "PageDown"
            ? QI(this)
            : e.key === "Backspace"
            ? dR(this)
            : e.key === "Delete" && pR(this);
          break;
        case "select-previous-expression":
          NE(this.listModel);
          break;
        case "select-next-expression":
          BE(this.listModel);
          break;
        case "toggle-label-for-all-selected-points":
          this.toggleLabelForAllSelectedObjects();
          break;
        case "set-label-state-for-selected-points": {
          let x = [];
          for (let L of this.getAllSelectedItems()) {
            L.type === "expression" && mc(L) && x.push(L);
          }
          this.setLabelStateForObjects(x, e.state);
          break;
        }
        case "move-selected-item-to-expression-list":
          {
            let x = this.getSelectedItem();
            if (!x || x.type === "folder" || this.isItemReadonly(x.id)) {
              return;
            }
            if (x.type === "expression") {
              let R = oT(x);
              R &&
                fd(
                  this.listModel,
                  R,
                  this.getAutonameLatexForExpression(
                    x,
                    this.findLastSubscriptForLetters(),
                  ),
                );
            }
            Ag(this.listModel, x.id),
              "folderId" in x &&
              x.folderId === __dcg_shared_module_exports__["xd"] &&
              (x.folderId = "");
            let L = this.getItemCount() - 1, V = kg(this.listModel, L);
            if (V && V.type === "expression" && V.latex === "") {
              this._toplevelReplaceItemAt(L, x, false);
              return;
            }
            ol(this.listModel, x);
          }
          break;
        case "update-all-selected-items":
          {
            let x = e.update;
            if (e.update.prop === "folderId") {
              let L;
              if (e.update.createFolder) {
                L = this.generateId();
                let Y = this.createItemModel({
                    type: "folder",
                    id: L,
                    title: e.update.value,
                  }),
                  he = this.getItemCount() - 1,
                  se = kg(this.listModel, he);
                se && se.type === "expression" && se.latex === ""
                  ? this._toplevelReplaceItemAt(
                    this.getItemCount() - 1,
                    Y,
                    false,
                  )
                  : ol(this.listModel, Y);
              } else L = e.update.value;
              let V = this.getItemModel(L);
              if (!V || V.type !== "folder") return;
              let R = {}, N = {};
              this.getAllSelectedItems().forEach((Y) => {
                var he;
                if (
                  !(Y.type === "folder" || Y.folderId === L) &&
                  !this.isItemReadonly(Y.id) &&
                  (R[Y.id] = Y, Y.type === "expression")
                ) {
                  let se = (he = Y.formula.geometry) == null ? void 0 : he.call;
                  if (se && se.symbol === "apply") {
                    let ae = se.parents[0],
                      q = ae.type !== "arbitrary-expression"
                        ? __dcg_shared_module_exports__["Cc"](ae)
                        : void 0;
                    q && (N[q] = true);
                  }
                }
              });
              for (let Y in N) {
                let he = Nu(this.listModel, Y);
                he.length === 1 && he[0].folderId !== L &&
                  (R[he[0].id] = he[0]);
              }
              let M = {}, F = [];
              for (let Y in R) {
                let he = R[Y];
                F.push(he);
              }
              F.forEach((Y) => {
                if (Y.type === "expression") {
                  let he = oT(Y);
                  he && (M[Y.id] = he);
                }
              }), F.sort((Y, he) => Y.index - he.index);
              let Z = this.findLastSubscriptForLetters();
              F.forEach((Y) => {
                if (Y.type === "expression") {
                  let he = M[Y.id];
                  if (he) {
                    let se = this.getAutonameLatexForExpression(Y, Z);
                    fd(this.listModel, he, se);
                  }
                }
              }),
                F.forEach((Y) => {
                  Ag(this.listModel, Y.id);
                });
              let te = V.index + this.getNumberOfItemsInFolder(L) + 1;
              F.forEach((Y) => {
                _s(this.listModel, Y, te), te += 1;
              }),
                F.forEach((Y) => {
                  _n(Y, L);
                });
            } else if (x.prop === "visible") {
              this.getAllSelectedItems().forEach((L) => {
                this.isItemReadonly(L.id) ||
                  (this._setItemHidden(L.id, !x.value),
                    x.value === false && L.type === "expression" &&
                    Ku(L, false));
              });
            } else if (e.update.prop === "color") {
              let L = e.update.value;
              this.getAllSelectedItems().forEach((V) => {
                V.type === "expression" && iT(V, L);
              });
            } else if (e.update.prop === "colorLatex") {
              let L = e.update.value;
              this.getAllSelectedItems().forEach((V) => {
                V.type === "expression" && Rw(V, L);
              });
            } else if (e.update.prop === "showLabel") {
              let L = e.update.value;
              this.getAllSelectedItems().forEach((V) => {
                V.type === "expression" && Ku(V, L);
              });
            } else if (e.update.prop === "label") {
              let L = e.update.value;
              this.getAllSelectedItems().forEach((V) => {
                V.type === "expression" && yd(V, L);
              });
            } else if (e.update.prop === "dragMode") {
              let L = e.update.value;
              this.getAllSelectedItems().forEach((V) => {
                V.type === "expression" && Mg(V, L);
              });
            } else if (e.update.prop === "lineWidth") {
              let L = e.update.value;
              this.getAllSelectedItems().forEach((V) => {
                V.type === "expression" && db(V, L);
              });
            } else if (e.update.prop === "lineOpacity") {
              let L = e.update.value;
              this.getAllSelectedItems().forEach((V) => {
                V.type === "expression" && cb(V, L);
              });
            } else if (e.update.prop === "lineStyle") {
              let L = e.update.value;
              this.getAllSelectedItems().forEach((V) => {
                V.type === "expression" && nT(V, L);
              });
            } else if (e.update.prop === "strictIntersection") {
              let L = e.update.value;
              this.getAllSelectedItems().forEach((V) => {
                V.type === "expression" && eH(V, L);
              });
            } else if (e.update.prop === "disableGraphInteractions") {
              let L = e.update.value;
              this.getAllSelectedItems().forEach((V) => {
                V.type === "expression"
                  ? RL(V, L)
                  : V.type === "image" && YG(V, L);
              });
            }
          }
          break;
        case "delete-all-selected-items": {
          let { deletedItems: x, readonlyItemsNotDeleted: L } = this
            .removeListOfItems(this.getSelectedExpressionIds());
          this.garbageCollectGeo(x, {}),
            this.ensureAtLeastOneVisibleItem(),
            x.length > 0 &&
            yt(
              this.s("graphing-calculator-narration-items-deleted", {
                count: __dcg_shared_module_exports__["ra"](x.length),
              }),
            ),
            L > 0 &&
            yt(
              this.s(
                "graphing-calculator-narration-locked-items-not-deleted",
                { count: __dcg_shared_module_exports__["ra"](L) },
              ),
            ),
            xe();
          break;
        }
        case "upward-delete-selected-expression":
          hR(this, { moveSelection: false });
          break;
        case "downward-delete-selected-expression":
          gR(this, { moveSelection: false });
          break;
        case "table-show-more-rows":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "table") return;
            let L = Eg(x);
            if (!L) return;
            Nr(this.listModel, x),
              Nf(x, true),
              qr(this, {
                type: "table",
                id: x.id,
                location: { row: L.min, column: 0 },
              });
          }
          break;
        case "navigate-table-by-key":
          U$(this, e.id, e.key);
          break;
        case "delete-item-and-animate-out":
          this._deleteItemAndAnimateOut(e.id, e.setFocusAfterDelete);
          break;
        case "finish-deleting-item-after-animation":
          this._finishDeletingItemAfterAnimation(
            e.id,
            e.setFocusAfterDelete,
          );
          break;
        case "expression-zoom-fit":
          this._expressionZoomFit(e.id, {
            focusAfterTap: e.focusAfterTap,
            synchronous: false,
            justResiduals: false,
          });
          break;
        case "expression-zoom-fit-residuals":
          this._expressionZoomFit(e.id, {
            focusAfterTap: e.focusAfterTap,
            synchronous: false,
            justResiduals: true,
          });
          break;
        case "set-expression-properties-from-api":
          this._setExpressionPropertiesFromAPI(e.id, e.properties);
          break;
        case "add-item-to-end-from-api":
          this._addItemToEndFromAPI(this.createItemModel(e.state));
          break;
        case "duplicate-expression":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type === "folder") return;
            this.copyExpressionToIndex(x, x.index + 1);
          }
          break;
        case "duplicate-folder":
          {
            let { id: x } = e, L = this.getItemModel(x);
            if (!L || L.type !== "folder") return;
            let V = this.createItemModel({
                ...xE(L, { stripDefaults: false }),
                id: this.generateId(),
              }),
              R = this.getNumberOfItemsInFolder(x),
              N = R + 1;
            this._toplevelInsertItemAt(L.index + N, V, false, void 0);
            let M = L.index + 1, F = M + R;
            for (let Z = M; Z <= F; Z++) {
              let te = kg(this.listModel, Z);
              if (!te || te.type === "folder") return;
              this.copyExpressionToIndex(te, Z + N, V.id);
            }
          }
          break;
        case "insert-item-at-index":
          {
            let x = this.createItemModel(e.state);
            this._toplevelInsertItemAt(e.index, x, e.focus, e.folderId);
          }
          break;
        case "new-expression-at-end":
          {
            this.setGeoTool("selection");
            let x = this.createItemModel({
              type: "expression",
              id: this.generateId(),
              color: this.getNextColor(),
            });
            this.setEditListMode(false), ol(this.listModel, x), bi(this, x.id);
          }
          break;
        case "new-expression":
          {
            let x = this.createItemModel({
              type: "expression",
              id: this.generateId(),
              color: this.getNextColor(),
            });
            this.setEditListMode(false),
              this._toplevelNewItemAtSelection(x, { shouldFocus: true }),
              this._closeAddExpression();
          }
          break;
        case "new-text":
          {
            let x = this.createItemModel({
              id: this.generateId(),
              type: "text",
            });
            this._toplevelNewItemAtSelection(x, { shouldFocus: true }),
              this._closeAddExpression();
          }
          break;
        case "new-folder":
          {
            let x = this.createItemModel({
              type: "folder",
              id: this.generateId(),
            });
            this._toplevelNewItemAtSelection(x, { shouldFocus: true }),
              this._closeAddExpression();
          }
          break;
        case "new-images":
          this._uploadImagesAndWaitForThemToLoad({ files: e.files }),
            this._closeAddExpression();
          break;
        case "change-image":
          this._uploadImagesAndWaitForThemToLoad({
            files: e.files,
            id: e.id,
          });
          break;
        case "new-table":
          {
            let x = this._createTableItem();
            this._toplevelNewItemAtSelection(x, { shouldFocus: true }),
              this._closeAddExpression();
          }
          break;
        case "paste-table":
          this._pasteTable(e.data);
          break;
        case "convert-or-create-table":
          this._convertOrCreateTable(e.index);
          break;
        case "insert-several-expressions":
          this.shouldScrollSelectedItemIntoViewAfterDispatch = true,
            this._insertSeveralExpressions(e.expressions);
          break;
        case "append-number-list":
          this._appendNumberList(e.latex);
          break;
        case "remove-item-by-id":
          Ag(this.listModel, e.id);
          break;
        case "replace-item-at-index":
          {
            let x = this.createItemModel(e.state);
            this._toplevelReplaceItemAt(e.index, x, e.focus);
          }
          break;
        case "create-sliders-for-item":
          this.createSlidersForItem(e.id, e.variables);
          break;
        case "create-sliders-for-ticker":
          this.createSlidersForTicker(e.variables);
          break;
        case "convert-image-to-draggable":
          this.convertImageToDraggable(e.id);
          break;
        case "start-dragdrop":
          {
            let x = this.getItemModel(e.dragTarget.calcId);
            if (!x) return;
            let L = { x: 0, y: 0 }, V = this.getItemRootNodeById(x.id);
            if (V) {
              let M = V.getBoundingClientRect();
              L.y = e.grabPt.y - M.top, L.x = e.grabPt.x - M.left;
            }
            this.isItemSelected(x.id)
              ? Nr(this.listModel, x)
              : Nr(this.listModel, void 0), this.setGeoTool("selection");
            let R = false, N = 1;
            x.type === "folder" &&
            (N += this.getNumberOfItemsInFolder(x.id),
              x.collapsed || (R = true, Kf(x, true))),
              _w(this.listModel, {
                firstItemId: x.id,
                numberOfItems: N,
                expandFolder: R,
                grabOffset: L,
                mousePt: e.mousePt,
                dragTarget: e.dragTarget,
                renderType: e.dragTarget.type,
                itemTop: 0,
                itemLeft: 0,
              }),
              this.dragdrop_expressions.startDragging(e.mousePt);
          }
          break;
        case "update-dragdrop":
          {
            let x = this.listModel.dragState;
            if (!x) return;
            _w(this.listModel, { ...x, mousePt: e.mousePt });
          }
          break;
        case "stop-dragdrop":
          {
            let x = this.listModel.dragState;
            if (!x) return;
            let L = this.getItemModel(x.firstItemId);
            if (!L) return;
            L.type === "folder" && x.expandFolder && Kf(L, false),
              _w(this.listModel, void 0),
              this.ensureAtLeastOneVisibleItem();
          }
          break;
        case "set-selected-id":
          {
            let x = this.getItemModel(e.id);
            x
              ? e.state === "selected"
                ? Nr(this.listModel, x)
                : (e.state, dq(this.listModel, x))
              : Nr(this.listModel, void 0);
          }
          break;
        case "set-all-selected-ids":
          rL(this.listModel, e.ids);
          break;
        case "toggle-selected-with-multi-select":
          tL(this.listModel, e.id, e.state);
          break;
        case "set-selected-index":
          {
            let x = this.getItemModelByIndex(e.index);
            Nr(this.listModel, x);
          }
          break;
        case "set-none-selected":
          Nr(this.listModel, void 0);
          break;
        case "commit-tentative-selection": {
          pq(this.listModel);
          break;
        }
        case "clear-tentative-selection": {
          uq(this.listModel);
          break;
        }
        case "set-focus-location":
          {
            let x = e.location ? e.location.type : "";
            if (
              x === "expression" && this.setGeoTool("selection"),
                x === "table" &&
                (this.layoutModel = {
                  ...this.layoutModel,
                  inEditListMode: false,
                }),
                x === "graph-paper"
            ) {
              this.setGraphPaperFocus({ isFocused: true });
              break;
            }
            qr(this, e.location);
          }
          break;
        case "focus-first-expression": {
          this.focusFirstExpression();
          break;
        }
        case "move-focus-to-item":
          bi(this, e.id, e.where);
          break;
        case "blur-focus-location":
          this.isFocusLocationFocused(e.location) && qr(this, void 0),
            ((t = e.location) == null ? void 0 : t.type) ===
              "graph-paper" && this.setGraphPaperFocus({ isFocused: false });
          break;
        case "set-folder-collapsed":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "folder") return;
            Kf(x, e.isCollapsed);
          }
          break;
        case "set-all-folders-collapsed":
          xq(this.listModel, e.isCollapsed);
          break;
        case "set-item-secret":
          {
            let x = this.getItemModel(e.id);
            if (!x) return;
            fE(x, e.isSecret);
          }
          break;
        case "set-item-in-front-of-everything":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "folder") return;
            Rz(x, e.inFrontOfEverything);
          }
          break;
        case "set-item-readonly":
          {
            let { id: x, readonly: L } = e, V = this.getItemModel(x);
            if (!V) return;
            if (yw(V, L), V.type === "folder") {
              for (let R of O4(this.listModel, x)) {
                yw(R, L);
              }
            }
          }
          break;
        case "set-item-disable-graph-interactions": {
          let { id: x, disableGraphInteractions: L } = e,
            V = this.getItemModel(x);
          if (!V) return;
          switch (V.type) {
            case "expression":
              RL(V, L);
              break;
            case "image":
              YG(V, L);
              break;
          }
          break;
        }
        case "set-tablecolumn-disable-graph-interactions": {
          let { tableId: x, columnId: L, disableGraphInteractions: V } = e,
            R = this.getItemModel(x);
          if (!R || R.type !== "table") return;
          let N = Eo(R, L);
          if (!N) return;
          Tz(N, V);
          break;
        }
        case "set-tablecolumn-color":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            mz(x, e.columnId, e.color);
          }
          break;
        case "set-tableregression-color":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            fz(x, e.color);
          }
          break;
        case "set-tablecolumn-colorlatex":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            lE(x, e.columnId, e.colorLatex);
          }
          break;
        case "set-show-cdf":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            fH(x, e.showCDF);
          }
          break;
        case "set-cdf-min":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            WE(x, e.latex);
          }
          break;
        case "set-cdf-max":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            $E(x, e.latex);
          }
          break;
        case "toggle-item-hidden":
          this._toggleItemHidden(e.id);
          break;
        case "toggle-tablecolumn-hidden":
          this._toggleTableColumnHidden(e.tableId, e.columnId);
          break;
        case "toggle-item-settings-menu":
          this.isItemSettingsMenuOpen(e.menu.guid)
            ? this.closeItemSettingsMenu()
            : (this.listModel.openItemMenu = e.menu,
              e.menu.focusFirstOption &&
              (e.menu.type === "geo-tool-dropdown"
                ? qr(this, {
                  type: "geo-basic-tool-menu-item",
                  tool: e.menu.tools[0],
                })
                : e.menu.type === "multi-select-more" ||
                    e.menu.type === "multi-select-construct" ||
                    e.menu.type === "multi-select-style" ||
                    e.menu.type === "multi-select-label"
                ? qr(this, { type: "generic-menu", where: "start" })
                : qr(this, {
                  type: "expression-menu",
                  id: e.menu.model.id,
                  location: "start",
                })));
          break;
        case "close-item-settings-menu":
          this.closeItemSettingsMenu();
          break;
        case "toggle-fraction-evaluation":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            let L = Hu(x);
            $q(x, !L);
          }
          break;
        case "set-item-label":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            yd(x, e.label), this.enqueueEvent("userEditedLabel", e);
          }
          break;
        case "set-item-showlabel":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Ku(x, e.showLabel),
              !e.showLabel && !zu(x) && ($w(x, false), aT(x, "NONE"));
          }
          break;
        case "set-item-color":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            iT(x, e.color);
          }
          break;
        case "set-item-description":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression" && x.type !== "image") {
              return;
            }
            x.type === "expression"
              ? jq(x, e.description)
              : x.type === "image" && e4(x, e.description);
          }
          break;
        case "set-item-fill":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            xL(x, e.fill), this._setItemHidden(x.id, wb(x));
          }
          break;
        case "set-image-opacity":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "image") return;
            o4(x, e.opacity), this._setItemHidden(x.id, false);
          }
          break;
        case "set-image-in-foreground":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "image") return;
            WG(x, e.foreground);
          }
          break;
        case "image-upload-error":
          this.__pendingImageUploads[e.token] &&
            (delete this.__pendingImageUploads[e.token],
              this._showToast({
                message: this.s(
                  "graphing-calculator-text-toast-image-upload-failed",
                ),
              }));
          break;
        case "image-upload-success":
          {
            if (this.__pendingImageUploads[e.token]) {
              if (delete this.__pendingImageUploads[e.token], e.id) {
                let x = this.getItemModel(e.id);
                x && x.type === "image" && i4(x, e.url);
              } else {
                let x = this.createItemModel({
                  type: "image",
                  id: this.generateId(),
                  width: e.width,
                  height: e.height,
                  image_url: e.url,
                  name: e.name,
                });
                this._toplevelNewItemAtSelection(x, { shouldFocus: false });
              }
            }
            this.isUploadingImages() || (this.toastData = {});
          }
          break;
        case "image-load-success":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "image") return;
            kE(x, "loaded"),
              this.imageRetryState = { lastAttemptTime: 0, attempts: 0 };
          }
          break;
        case "image-load-error":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "image") return;
            kE(x, "failed");
          }
          break;
        case "image-retry-loading":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "image") return;
            jG(x);
          }
          break;
        case "set-item-dragmode":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Mg(x, e.dragMode);
          }
          break;
        case "set-tablecolumn-dragmode":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            gz(x, e.columnId, e.dragMode),
              e.dragMode !== "NONE" &&
              this._setTableColumnHidden(e.tableId, e.columnId, false);
          }
          break;
        case "set-tablecolumn-points":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            NG(x, e.columnId, e.bool),
              this._setTableColumnHidden(
                e.tableId,
                e.columnId,
                cE(x, e.columnId),
              );
          }
          break;
        case "set-tablecolumn-lines":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            pz(x, e.columnId, e.bool),
              this._setTableColumnHidden(
                e.tableId,
                e.columnId,
                cE(x, e.columnId),
              );
          }
          break;
        case "set-tablecolumn-linestyle":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            uz(x, e.columnId, e.lineStyle),
              this._setTableColumnHidden(e.tableId, e.columnId, false);
          }
          break;
        case "set-tablecolumn-linewidth":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            iE(x, e.columnId, e.lineWidth),
              this._setTableColumnHidden(e.tableId, e.columnId, false);
          }
          break;
        case "set-tablecolumn-lineopacity":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            nE(x, e.columnId, e.lineOpacity),
              this._setTableColumnHidden(e.tableId, e.columnId, false);
          }
          break;
        case "set-tablecolumn-pointsize":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            aE(x, e.columnId, e.pointSize),
              this._setTableColumnHidden(e.tableId, e.columnId, false);
          }
          break;
        case "set-tablecolumn-pointopacity":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            sE(x, e.columnId, e.pointOpacity),
              this._setTableColumnHidden(e.tableId, e.columnId, false);
          }
          break;
        case "set-tablecolumn-pointstyle":
          {
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            dz(x, e.columnId, e.pointStyle),
              this._setTableColumnHidden(e.tableId, e.columnId, false);
          }
          break;
        case "set-item-points":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            wL(x, e.points),
              this._setItemHidden(e.id, wb(x)),
              !e.points && x.dragMode !== "NONE" && Mg(x, "NONE");
          }
          break;
        case "set-item-pointstyle":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            vL(x, e.pointStyle), this._setItemHidden(e.id, false);
          }
          break;
        case "set-item-lines":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            CL(x, e.lines), this._setItemHidden(e.id, wb(x));
          }
          break;
        case "set-item-extend-to-3D":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Xq(x, e.extendTo3D), this._setItemHidden(e.id, false);
            let L = (o = this.grapher3d) == null ? void 0 : o.transition;
            L && e.extendTo3D &&
              (L.objectIdExtendingTo3D &&
                ((i = this.grapher3d) == null ||
                  i.webglLayer.setZboundsOnSurfaces(
                    L.objectIdExtendingTo3D,
                    -1 / 0,
                    1 / 0,
                  )),
                L.objectIdExtendingTo3D = x.id,
                L.startTime = -1,
                L.duration = 150);
          }
          break;
        case "set-item-linestyle":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            nT(x, e.lineStyle), this._setItemHidden(e.id, false);
          }
          break;
        case "set-item-arrow-mode": {
          let x = this.getItemModel(e.id);
          if (!x || x.type !== "expression") return;
          Jq(x, e.value), this._setItemHidden(e.id, false);
          break;
        }
        case "set-item-label-dropdown-open":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Yq(x, e.open);
          }
          break;
        case "set-item-fillopacity":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Lw(x, e.fillOpacity), this._setItemHidden(e.id, false);
          }
          break;
        case "set-item-surfaceopacity":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Pw(x, e.surfaceOpacity), this._setItemHidden(e.id, false);
          }
          break;
        case "set-item-lineopacity":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            cb(x, e.lineOpacity), this._setItemHidden(e.id, false);
          }
          break;
        case "set-item-pointopacity":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Vw(x, e.pointOpacity),
              x.showLabel || this._setItemHidden(e.id, false);
          }
          break;
        case "set-item-pointsize":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Ow(x, e.pointSize), this._setItemHidden(e.id, false);
          }
          break;
        case "set-item-linewidth":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            db(x, e.lineWidth), this._setItemHidden(e.id, false);
          }
          break;
        case "set-item-resolution":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            HE(x, e.resolution), this._setItemHidden(e.id, false);
          }
          break;
        case "set-item-colorlatex":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Rw(x, e.colorLatex);
          }
          break;
        case "set-item-labelSize":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Fw(x, e.labelSize);
          }
          break;
        case "set-item-labelangle":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            KE(x, e.labelAngle);
          }
          break;
        case "set-item-label-orientation":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            SL(x, e.labelOrientation);
          }
          break;
        case "set-suppress-text-outline":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Qq(x, e.suppressTextOutline);
          }
          break;
        case "set-item-interactive-label":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            $w(x, e.interactiveLabel), e.interactiveLabel && aT(x, "NONE");
          }
          break;
        case "set-item-editable-label-mode":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            x.editableLabelMode !== "NONE" &&
            e.editableLabelMode !== "NONE" &&
            x.editableLabelMode !== e.editableLabelMode && yd(x, ""),
              aT(x, e.editableLabelMode),
              e.editableLabelMode !== "NONE" && $w(x, false);
          }
          break;
        case "plot-residuals":
          {
            let x = this.getItemModel(e.id);
            if (!x) return;
            let L;
            if (
              x.type === "expression"
                ? L = x.formula.regression
                : x.type === "table" && ((a = (n = x.formula) == null
                        ? void 0
                        : n.table_regression) == null
                      ? void 0
                      : a.status) === "success" &&
                  (L = x.formula.table_regression.result), !L
            ) return;
            let V = L.residualSuggestionId;
            if (!V) return;
            let R = this.getItemModel(V);
            if (!R) return;
            oE(R, {
              latex: L.residualVariable,
              columnIndex: R.columnModels.length - 1,
            }),
              qr(this, {
                type: "regression-output",
                id: e.id,
                parameter: "residual-zoom",
              });
          }
          break;
        case "toggle-logmode":
          {
            let x = this.getItemModel(e.id);
            if (!x) return;
            let L;
            x.type === "expression"
              ? (L = x.isLogModeRegression, yL(x, !L))
              : x.type === "table" && x.regression &&
                (L = x.regression.isLogMode, bz(x, !L)),
              L !== void 0 &&
              this.logEvent({
                category: "regressions",
                action: L ? "disable-log-mode" : "enable-log-mode",
              });
          }
          break;
        case "set-item-latex":
          {
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            let L = e.latex, V = x.latex;
            if (
              this.garbageCollectGeo([], {
                [x.id]: { prevLatex: V, nextLatex: L },
              }), (L === '"' || L === "note") && this.areNotesEnabled()
            ) {
              let R = this.createItemModel({
                id: this.generateId(),
                type: "text",
              });
              this._toplevelReplaceItemAt(x.index, R, true);
            } else if (L === "") CH(x);
            else if (L === "ticker" && this.canAddTicker()) {
              this.listModel.ticker.open = true,
                this.focusLocation = {
                  type: "ticker",
                  location: "handler",
                },
                this._removeExpressionSynchronously(x);
            } else if (L === "folder" && this.areFoldersEnabled()) {
              let R = this.createItemModel({
                id: this.generateId(),
                type: "folder",
              });
              Ca(x)
                ? (this._toplevelNewItemAtSelection(R, {
                  shouldFocus: true,
                }),
                  $a(x, ""))
                : this._toplevelReplaceItemAt(x.index, R, true);
            } else if (L === "table") {
              let R = this._createTableItem();
              this._toplevelReplaceItemAt(x.index, R, true);
            } else {!this.isGeometry() &&
                  (L === "betchacant" || L === "pride" ||
                    L === "teapot" && this.is3dProduct())
                ? this.runAfterDispatch(() => {
                  this.triggerEasterEgg && this.triggerEasterEgg(L);
                })
                : ($a(x, L),
                  e.source === "user-edit" &&
                  this.trackActionForPotentialEvaluatorRestart(
                    "edit",
                    e.id,
                  ));}
          }
          break;
        case "set-visualization-prop":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Lq(x, e.prop, e.value);
          }
          break;
        case "set-clickableinfo-prop":
          {
            let x = this.getItemModel(e.id);
            if (!x) return;
            x.type === "expression"
              ? Pq(x, e.prop, e.value)
              : x.type === "image" && _E(x, e.prop, e.value);
          }
          break;
        case "set-clickableinfo-rule-latex":
          {
            let x = this.getItemModel(e.id);
            if (!x) return;
            x.type === "expression"
              ? UE(x, e.latex)
              : x.type === "image" && p4(x, e.latex);
          }
          break;
        case "set-folder-title":
          {
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "folder") return;
            Pz(x, e.title);
          }
          break;
        case "set-image-mq-attribute":
          {
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "image") return;
            ks(x, e.attribute, e.latex);
          }
          break;
        case "set-image-name":
          {
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "image") return;
            t4(x, e.name);
          }
          break;
        case "set-image-draggable":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "image") return;
            let L = jf(x);
            if (!L) return;
            KG(x, e.draggable),
              e.draggable &&
              (Ro(L) === "NONE" || L.dragMode === "AUTO") && Mg(L, "XY");
          }
          break;
        case "update-degree-mode": {
          if (this.isComplexModeEnabled()) return;
          this.graphSettings.setProperty("degreeMode", e.mode);
          break;
        }
        case "set-graph-settings":
          {
            for (let x in e) {
              x !== "type" &&
                (x === "xAxisScale"
                  ? this.switchAxisScale("xAxisScale", e.xAxisScale)
                  : x === "yAxisScale"
                  ? this.switchAxisScale("yAxisScale", e.yAxisScale)
                  : this.graphSettings.setProperty(x, e[x]));
            }
            this.grapher3d && this.isThreeDMode() &&
              (this.grapher2d.redrawAllLayersSynchronously(),
                "backgroundColor3d" in e &&
                this.grapher3d.webglLayer.setBackgroundColor(
                  e.backgroundColor3d,
                ),
                this.apply3dProps(e));
          }
          break;
        case "set-polar-mode":
          if (
            this.graphSettings.setProperty("polarMode", e.polarMode),
              e.polarMode
          ) {
            let x = this.graphSettings.xAxisScale === "logarithmic" ||
                this.graphSettings.yAxisScale === "logarithmic",
              L = this.getGrapher2d();
            x && L &&
              (this.graphSettings.setProperty("xAxisScale", "linear"),
                this.graphSettings.setProperty("yAxisScale", "linear"),
                L.viewportController.setViewport(L.getDefaultViewport()),
                L.getProjection().updateScalePairs());
          }
          break;
        case "set-domain-minlatex":
          {
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Ka(x, e.latex, e.variable);
          }
          break;
        case "set-domain-maxlatex":
          {
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Wa(x, e.latex, e.variable);
          }
          break;
        case "set-note-text":
          {
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "text") return;
            XG(x, e.text);
          }
          break;
        case "set-edit-list-mode":
          {
            let x = Ig(this.listModel);
            if (
              this.setEditListMode(e.isEditListMode), e.focusExpressionList
            ) {
              if (x === void 0 && (x = this.getItemModelByIndex(0)), !x) {
                return;
              }
              bi(
                this,
                x.id,
                x.type === "table" && e.isEditListMode ? "container" : "start",
              );
            } else Nr(this.listModel, void 0), qr(this, void 0);
          }
          break;
        case "set-ghost-mode":
          this.getGraphSettings().config.setProperty(
            "ghostMode",
            e.value,
          );
          break;
        case "set-projector-mode":
          this.getGraphSettings().config.setProperty(
            "projectorMode",
            e.value,
          ),
            this.isThreeDMode() &&
            this.grapher2d.redrawAllLayersSynchronously();
          break;
        case "set-inverted-colors":
          this.getGraphSettings().config.setProperty(
            "invertedColors",
            e.value,
          );
          break;
        case "set-tablecell-latex":
          {
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
            let x = this.getItemModel(e.tableId);
            if (!x || x.type !== "table") return;
            vp(x, e.cell, e.latex);
          }
          break;
        case "set-state":
          this.externalSetState(e.state, e.opts);
          break;
        case "set-blank":
          this.externalSetState(
            this.getBlankState({ degreeMode: e.degreeMode }),
            e.opts,
          );
          break;
        case "restore-history":
          {
            let { currentState: x, history: L } = X$(e.history);
            this.setState(x), this.stateStack = L.clone();
          }
          break;
        case "clear-unsaved-changes":
          this.enqueueEvent("clearUnsavedChanges", e);
          break;
        case "reset-graph":
          {
            let x = this.getState();
            this.externalSetState(this.graphSettings.defaultState, {
              allowUndo: true,
            }),
              this.setGeoTool("selection"),
              this.graphSettings.config.expressions
                ? this.focusFirstExpression()
                : this.setGraphPaperFocus({ isFocused: true }),
              this._showToast({
                message: this.s(
                  "graphing-calculator-text-toast-graph-reset",
                ),
                undoCallback: () =>
                  this.dispatch({
                    type: "set-state",
                    state: x,
                    opts: { allowUndo: true },
                  }),
              }),
              this.enqueueEvent("graphReset", e);
          }
          break;
        case "clear-graph":
          {
            if (this.triggerClearGraph) {
              this.runAfterDispatch(() => this.triggerClearGraph());
              return;
            }
            let x = this.getState();
            this.externalSetState(this.getBlankState(), {
              allowUndo: true,
            });
            let L = this.getItemModelByIndex(0);
            L && bi(this, L.id, "end"),
              this._showToast({
                message: this.s(
                  "graphing-calculator-text-toast-graph-cleared",
                ),
                undoCallback: () =>
                  this.dispatch({
                    type: "set-state",
                    state: x,
                    opts: { allowUndo: true },
                  }),
              }),
              this.enqueueEvent("graphReset", e);
          }
          break;
        case "hide-progress-update-legend":
          this.progressUpdateLegendHidden = true;
          break;
        case "evaluator-progress-update":
          this.handleEvaluatorProgressUpdates();
          break;
        case "on-evaluator-changes":
          {
            if (
              this.onEvaluatorChangesSpy &&
              this.onEvaluatorChangesSpy(
                e.changes,
                e.timingData,
                e.graphData,
                e.eventUpdates,
              ),
                this.clearSlowEvaluatorTracking(),
                this.evaluator.cancelRestartWorker(),
                lq(this.listModel, e.changes, e.dependencyOrder),
                (s = this.toneController) == null || s.recomputeAudio(),
                e.type === "on-evaluator-changes" &&
                !this.getIncludeFunctionParametersInRandomSeed() &&
                !gq(this.listModel) && this.stateStack.getState() &&
                this.setIncludeFunctionParametersInRandomSeed(true),
                !e.graphData
            ) break;
            for (let x in e.graphData.addedGraphs) {
              let L = e.graphData.addedGraphs[x];
              if (__dcg_shared_module_exports__["tc"](L)) {
                let V = L.filter((N) =>
                    !__dcg_shared_module_exports__["L"](N.graphMode)
                  ),
                  R = L.filter((N) =>
                    __dcg_shared_module_exports__["L"](N.graphMode)
                  );
                (l = this.grapher2d) == null || l.updateSketch(x, V),
                  (c = this.grapher3d) == null || c.updateSketch(x, R),
                  sq(this.listModel, x, L);
              }
            }
            for (let x in e.graphData.removedGraphs) {
              (d = this.grapher2d) == null || d.removeGraphSketch(x),
                (p = this.grapher3d) == null || p.removeGraphSketch(x);
            }
            if (this.isThreeDMode()) {
              (h = this.grapher2d) == null ||
                h.redrawAllLayersSynchronously();
            } else {
              for (let x in e.graphData.intersections) {
                let L = e.graphData.intersections[x];
                __dcg_shared_module_exports__["tc"](L) &&
                  ((u = this.grapher2d) == null ||
                    u.updateIntersections(x, L));
              }
              (f = this.get2dPOIController()) == null ||
              f.handleTraceUpdate(),
                (y = this.getAudioGraph()) == null ||
                y.handleEvaluatorChange(e.graphData);
            }
            if (e.eventUpdates) {
              let x = false;
              for (let L in e.eventUpdates.updates) {
                if (this.doesIdentifierBlockActionUpdate(L)) {
                  x = true;
                  break;
                }
              }
              if (!x) {
                for (let L in e.eventUpdates.updates) {
                  this.updateLatexForIdentifier(
                    L,
                    e.eventUpdates.updates[L],
                  );
                }
                e.eventUpdates.objectClicked &&
                this.enqueueEvent("userClickedObject", e),
                  this.onActionUpdatesAppliedSpy &&
                  this.onActionUpdatesAppliedSpy(e.eventUpdates);
              }
            }
          }
          break;
        case "add-helper-expression":
          Y4(this.listModel, e.state);
          break;
        case "tick":
          this._tickSliders(e.time);
          break;
        case "tick-ticker":
          this.tickTicker(e.time);
          break;
        case "adjust-slider-by-keyboard":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Dq(x, e.adjustment);
          }
          break;
        case "adjust-slider-by-dragging-thumb":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            kq(x, e.target);
          }
          break;
        case "set-slider-minlatex":
          {
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            sb(x, e.latex);
          }
          break;
        case "set-slider-maxlatex":
          {
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            lb(x, e.latex);
          }
          break;
        case "set-slider-steplatex":
          {
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Gw(x, e.latex);
          }
          break;
        case "set-slider-dragging":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Ww(x, e.dragging);
          }
          break;
        case "play-slider-from-min":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            let L = nl(x);
            if (isNaN(L)) return;
            let V = qu(x.latex, L);
            As(x, false), $a(x, V), As(x, true);
          }
          break;
        case "set-slider-isplaying":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            As(x, e.isPlaying);
          }
          break;
        case "set-slider-loopmode":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Kq(x, e.loopMode);
          }
          break;
        case "set-slider-animationperiod":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "expression") return;
            Wq(x, e.animationPeriod);
          }
          break;
        case "show-expressions-list":
          this._showExpressions(e.focusHideIcon);
          break;
        case "hide-expressions-list":
          this._hideExpressions(e.focusShowIcon);
          break;
        case "open-drawer":
          this.enqueueEvent("openDrawer", e);
          break;
        case "re-randomize":
          this.setRandomSeed(rd());
          break;
        case "resize-exp-list":
          this._setExpListWidth(e.expListWidth);
          break;
        case "toast/show":
          this._showToast(e.toast);
          break;
        case "toast/close":
          this.closeToast();
          break;
        case "toast/undo":
          let _ = this.toastData.undoCallback;
          _ && this.runAfterDispatch(_), this.toastData = {};
          break;
        case "toast/learn-more":
          let A = this.toastData.learnMoreCallback;
          A && this.runAfterDispatch(A), this.toastData = {};
          break;
        case "start-moving-points":
          b$(this, this.listModel, e.points);
          break;
        case "stop-moving-points":
          x$(this, e.points);
          break;
        case "on-move-points":
          y$(
            this,
            e.points,
            e.previousScreenPts,
            e.screenPts,
            e.projection,
            e.transform,
            e.keyboardDirection,
          ) && this.enqueueEvent("userMovedPoint", e);
          break;
        case "commit-user-requested-viewport":
          this._commitUserRequestedViewport(e.viewport);
          break;
        case "commit-user-requested-rotation":
          this.graphSettings.setProperty(
            "worldRotation3D",
            e.worldRotation3D,
          ),
            this.graphSettings.setProperty("axis3D", e.axis3D),
            this.graphSettings.setProperty("speed3D", e.speed3D);
          break;
        case "toggle-lock-viewport":
          this.graphSettings.setProperty(
            "userLockedViewport",
            !this.graphSettings.userLockedViewport,
          );
          break;
        case "toggle-complex-mode": {
          let x = this.getState({ avoidBackMigration: true });
          x.graph.complex = !x.graph.complex,
            x.graph.degreeMode = false,
            this.setState(x, { allowUndo: true });
          break;
        }
        case "set-axis-limit-latex":
          this._setAxisLimitLatex(e.limit, e.latex),
            e.updateYZAlso &&
            (this._setAxisLimitLatex(
              e.limit === "xmin" ? "ymin" : "ymax",
              e.latex,
            ),
              this._setAxisLimitLatex(
                e.limit === "xmin" ? "zmin" : "zmax",
                e.latex,
              )),
            this.lastDirectlyEditedViewport = (C = this.getGrapher()) == null
              ? void 0
              : C.getCurrentViewport();
          break;
        case "toggle-graph-settings":
          this.layoutModel = {
            ...this.layoutModel,
            graphSettingsOpen: !this.layoutModel.graphSettingsOpen,
          },
            Nr(this.listModel, void 0),
            e.focusOnOpen &&
            (this.layoutModel.graphSettingsOpen
              ? this.is3dProduct()
                ? qr(this, {
                  type: "settings",
                  location: "reverse-contrast",
                })
                : this.getGraphSettings().config.projectorMode
                ? qr(this, { type: "settings", location: "large-size" })
                : qr(this, { type: "settings", location: "default-size" })
              : qr(this, { type: "settings", location: "icon" }));
          break;
        case "close-graph-settings":
          this.layoutModel = {
            ...this.layoutModel,
            graphSettingsOpen: false,
          },
            e.focusIconAfterClose &&
            qr(this, { type: "settings", location: "icon" });
          break;
        case "toggle-add-expression":
          this.layoutModel = {
            ...this.layoutModel,
            addExpressionOpen: !this.layoutModel.addExpressionOpen,
          },
            e.focusOnOpen && this.layoutModel.addExpressionOpen &&
            qr(this, { type: "add-expression-btn" });
          break;
        case "close-add-expression":
          this._closeAddExpression(),
            e.focusIconAfterClose && qr(this, { type: "add-item-btn" });
          break;
        case "ui/container-resized":
          this.layoutMeasurements = {
            width: e.size.width,
            height: e.size.height,
          }, this.shouldScrollSelectedItemIntoViewAfterDispatch = true;
          break;
        case "enter-printmode":
          this.inPrintMode = true;
          break;
        case "exit-printmode":
          this.inPrintMode = false;
          break;
        case "expression-size-exceeded":
          this._showToast({
            message: this.s(
              "graphing-calculator-text-toast-expression-size-limit",
            ),
          });
          break;
        case "keypad/set-layout":
          this.layoutModel = {
            ...this.layoutModel,
            keypadLayout: e.layout,
            keypadFunctionsOpen: false,
          };
          break;
        case "keypad/set-minimized":
          this.layoutModel = {
            ...this.layoutModel,
            keypadMinimized: e.minimized,
            keypadLayout: "mainNumbers",
          },
            this.shouldScrollSelectedItemIntoViewAfterDispatch = true,
            this.needsFakeKeypad() || F$(this),
            xe(
              e.minimized
                ? this.s("graphing-calculator-narration-keypad-hidden")
                : this.s("graphing-calculator-narration-keypad-visible"),
            );
          break;
        case "keypad/type-text":
          this.layoutModel = {
            ...this.layoutModel,
            keypadFunctionsOpen: false,
          },
            this.runAfterDispatch(() => {
              let x = Fe.getFocusedMathquill();
              x &&
                Fe.canAcceptText(
                  x,
                  this.getCapExpressionSize(),
                  e.text,
                ) &&
                (x.typedText(e.text), Fe.simulateUserChangedLatex(x));
            });
          break;
        case "keypad/press-key":
          this.layoutModel = {
            ...this.layoutModel,
            keypadFunctionsOpen: false,
          },
            this.runAfterDispatch(() => {
              let x = Fe.getFocusedMathquill();
              x && Fe.simulateKeypressFromKeypad(x, e.key);
            });
          break;
        case "keypad/audio-trace":
          this.handleAudioTraceCommand(e.command);
          break;
        case "set-audio-trace-speed":
          this.setAudioTraceSpeed(e.speed);
          break;
        case "keypad/custom-command":
          this.layoutModel = {
            ...this.layoutModel,
            keypadFunctionsOpen: false,
          },
            this.runAfterDispatch(() => {
              let x = Fe.getFocusedMathquill();
              x &&
                (ZI(x, e.command, {
                  capExpressionSize: this.getCapExpressionSize(),
                }),
                  Fe.simulateUserChangedLatex(x));
            });
          break;
        case "keypad/shift":
          this.layoutModel = {
            ...this.layoutModel,
            keypadLayout: Q$(this.getKeypadLayout()),
            keypadFunctionsOpen: false,
          };
          break;
        case "keypad/123":
          this.layoutModel = {
            ...this.layoutModel,
            keypadLayout: "mainNumbers",
            keypadFunctionsOpen: false,
          };
          break;
        case "keypad/abc":
          this.isQwertyKeyboardEnabled()
            ? this.layoutModel = {
              ...this.layoutModel,
              keypadLayout: "letters",
              keypadFunctionsOpen: false,
            }
            : this.layoutModel = {
              ...this.layoutModel,
              keypadLayout: "noQwertyLetters",
              keypadFunctionsOpen: false,
            };
          break;
        case "keypad/audio":
          this.layoutModel = {
            ...this.layoutModel,
            keypadMinimized: false,
            keypadLayout: "audio",
            keypadFunctionsOpen: false,
          };
          break;
        case "keypad/functions":
          this.layoutModel = {
            ...this.layoutModel,
            keypadFunctionsOpen: !this.isKeypadFunctionsPopoverOpen(),
          };
          break;
        case "grapher/drag-start":
          break;
        case "grapher/drag-move":
          break;
        case "grapher/drag-end":
          break;
        case "open-on-web":
          this._openOnWeb();
          break;
        case "file-is-dragged-over":
          this.listModel.openItemMenu = void 0,
            this.layoutModel = {
              ...this.layoutModel,
              isFileDraggedOver: true,
            };
          break;
        case "file-is-not-dragged-over":
          this.layoutModel = {
            ...this.layoutModel,
            isFileDraggedOver: false,
          };
          break;
        case "zoom":
          (E = this.getGrapher()) == null ||
            E.viewportController.zoom(e.direction);
          break;
        case "set-hovered-image":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "image") return;
            _E(x, "hoveredImage", e.url);
          }
          break;
        case "set-depressed-image":
          {
            let x = this.getItemModel(e.id);
            if (!x || x.type !== "image") return;
            _E(x, "depressedImage", e.url);
          }
          break;
        case "clickable-item-clicked":
          this.handleClickableItemClicked(e.id, e.listIndex);
          break;
        case "action-single-step":
          {
            let x = this.getItemModel(e.id);
            if (
              !x || x.type !== "expression" || !x.formula.action_value
            ) return;
            this.evaluator.addActionStepEvent(x.id);
          }
          break;
        case "update-expression-search-str":
          this.updateExpressionSearchStr(e.str);
          break;
        case "update-expression-replace-str":
          this.updateExpressionReplaceStr(e.str);
          break;
        case "rename-identifier-global":
          fd(this.listModel, e.search, e.replace);
          break;
        case "rename-identifier-in-item":
          let P = this.getItemModel(e.id);
          P && P.type === "folder"
            ? fd(this.listModel, e.search, e.replace, {
              limitToFolder: e.id,
            })
            : fd(this.listModel, e.search, e.replace, {
              limitToItem: e.id,
            });
          break;
        case "update-ticker-handlerlatex":
          this.updateTickerHandlerLatex(e.latex);
          break;
        case "update-ticker-minsteplatex":
          this.updateTickerMinStepLatex(e.latex);
          break;
        case "set-braille-mode":
          this.setBrailleMode(e.mode);
          break;
        case "set-six-key-input":
          this.setSixKeyInput(e.useSixKeyInput);
          break;
        case "set-show-constructions-open":
          if (this.showConstructionsOpen = e.open, e.setFocus) {
            if (!e.open) {
              qr(this, { type: "geo-show-constructions-icon" });
            } else {for (let x in this.cachedGeoTokenInfo) {
                let { calcId: L } = this.cachedGeoTokenInfo[x];
                if (this.getItemModel(L)) {
                  qr(this, { type: "geo-token", identifier: x });
                  break;
                }
              }}
          }
          break;
        case "select-geo-tool":
          this.listModel.openItemMenu = void 0,
            this.setGeoTool(e.tool),
            e.forceSingleUse && this.geoModel.markCurrentToolSingleUse(),
            __dcg_shared_module_exports__["Dc"](e.tool) ||
            e.tool === "selection" || Nr(this.listModel, void 0),
            e.focusGraphPaper &&
            this.setGraphPaperFocus({ isFocused: true }),
            this.closeToast();
          break;
        case "cancel-geo-toolplay":
          this.cancelGeoToolplay(),
            this.geoModel.getNonObjectsState().ui.currentTool
              .forceSingleUse && this.setGeoTool("selection");
          break;
        case "update-click-to-insert-mode":
          this.getGeoModel().setClickToInsertMode(e.clickToInsertMode);
          break;
        case "commit-geo-objects":
          {
            let x = [],
              L = [],
              V = this.findLastSubscriptForLetters(),
              R = {},
              N = (se) => {
                let ae = R[se];
                if (ae) return ae.assignmentLatex;
                let q = this.getItemModel(se);
                if (!q || q.type !== "expression") return se;
                let oe = this._autoNameExpression(q, V);
                return ae = R[se] = { model: q, assignmentLatex: oe },
                  ae.assignmentLatex;
              },
              M = [],
              F = lV(e.committed, {
                isBeingCommitted: true,
                getVariableNameForId: N,
              });
            for (let se in e.committed) {
              let ae = e.committed[se];
              __dcg_shared_module_exports__["Dc"](ae.type) && M.push(se);
              let q = F[se];
              (q == null ? void 0 : q.type) === "assignment" &&
                (q.sliderInfo
                  ? L.push({
                    latex: q.latex,
                    color: q.color,
                    sliderInfo: q.sliderInfo,
                  })
                  : x.push({ ...q, tokenId: se }));
            }
            let Z = this.listModel.__toolPreviewIdToModel;
            if (x.length) {
              let se = this.getGeometryFolder(),
                ae = se
                  ? se.index + this.getNumberOfItemsInFolder(se.id) + 1
                  : 0;
              x.forEach((q) => {
                var K;
                let oe;
                for (let fe in Z) {
                  let me = Z[fe];
                  if (
                    ((K = pi(me)) == null ? void 0 : K.latex) ===
                      q.tokenId
                  ) {
                    oe = me;
                    break;
                  }
                }
                oe
                  ? (oe.latex = q.latex,
                    oe.color = q.color,
                    oe.showLabel = !!q.showLabel,
                    oe.showAngleLabel = q.showAngleLabel !== false,
                    se && (oe.folderId = se.id))
                  : oe = this.createItemModel({
                    id: this.generateId(),
                    type: "expression",
                    showLabel: q.showLabel,
                    showAngleLabel: q.showAngleLabel,
                    latex: q.latex,
                    folderId: se && se.id,
                    color: q.color,
                  }),
                  se
                    ? (_s(this.listModel, oe, ae), ae += 1)
                    : ol(this.listModel, oe),
                  this.getGeoModel().recordCommittedOutput(oe.id);
              });
            }
            L.forEach((se) => {
              let ae;
              for (let q in Z) {
                let oe = Z[q];
                if (oe.latex === se.latex) {
                  ae = oe;
                  break;
                }
              }
              ae
                ? (ae.latex = se.latex,
                  ae.color = se.color,
                  sb(ae, se.sliderInfo.min),
                  lb(ae, se.sliderInfo.max))
                : ae = this.createItemModel({
                  id: this.generateId(),
                  type: "expression",
                  latex: se.latex,
                  color: se.color,
                  slider: {
                    hardMin: true,
                    hardMax: true,
                    min: se.sliderInfo.min,
                    max: se.sliderInfo.max,
                  },
                }),
                _s(this.listModel, ae, 0),
                this.getGeoModel().recordCommittedOutput(ae.id);
            }),
              M.length === 1 &&
              this.transformAllSelectedItemsByAssignmentLatex(M[0]),
              (this.geoModel.isCurrentToolSingleUse() ||
                e.clearToolAndSelection) && this.setGeoTool("selection"),
              e.clearToolAndSelection && Nr(this.listModel, void 0);
            let te = e.toolIdToLatex[1],
              Y = F[te],
              he = (Y == null ? void 0 : Y.type) === "inline" ? Y.rhs : te;
            if (this.geoModel.getToolMode() === "expression-edit" && he) {
              let se = sV(he, N);
              this.writeIdentifierIntoCurrentMathquill(se);
            }
            this.isGeometry() &&
              this.getGeoModel().updateFadeAnimations();
          }
          break;
        case "rename-identifier":
          {
            let x = e.from,
              L = e.to,
              V = __dcg_shared_module_exports__["latexToIdentifier"](x),
              R = this.getGeometryFolder();
            R && this.getItemsByIdentifier(V).forEach((N) => {
              e.geoFolder && N.folderId !== R.id
                ? (_n(N, R.id), Uu(this.listModel, N.index, R.index + 1, 1))
                : !e.geoFolder && N.folderId === R.id &&
                  (Uu(
                    this.listModel,
                    N.index,
                    R.index + this.getNumberOfItemsInFolder(R.id),
                    1,
                  ),
                    _n(N, ""));
            }), fd(this.listModel, x, L);
          }
          break;
        case "set-active-token":
          this.activeTokens[e.style] = e.identifier;
          break;
        case "unset-active-token":
          this.activeTokens[e.style] === e.identifier &&
            (this.activeTokens[e.style] = void 0);
          break;
        case "select-expression-that-defines-token":
          {
            let x = this.getExpressionIdForIdentifier(e.identifier);
            if (
              !x ||
              (this.setGeoTool("selection"),
                this.isItemNotSelectableBecauseItsSecret(x))
            ) return;
            e.multiSelectMode || e.toggle
              ? tL(this.listModel, x, "selected")
              : this.tryInsertTokenIntoMathquill(x, void 0) ||
                Nr(this.listModel, this.getItemModel(x));
          }
          break;
        case "close-expression-search":
          this.closeExpressionsSearch();
          break;
        case "open-expression-search":
          this.expressionSearchOpen = true,
            this.focusLocation = { type: "search-expressions" };
          let O = e.latex;
          e.rename && !ya(O) && (O = "");
          let U = e.rename
            ? O
              ? `\\operatorname{rename}\\ ${O}\\to`
              : "\\operatorname{rename}\\ "
            : O;
          this.updateExpressionSearchStr(U);
          break;
        case "open-ticker":
          this.listModel.ticker.open = true,
            this.focusLocation = { type: "ticker", location: "handler" },
            this._closeAddExpression();
          break;
        case "close-ticker":
          this.listModel.ticker.open = false,
            this.listModel.ticker.playing = false,
            this.listModel.ticker.minStepLatex = "",
            this.listModel.ticker.handlerLatex = "";
          break;
        case "toggle-ticker":
          this.listModel.ticker.playing = !this.listModel.ticker.playing,
            this.listModel.ticker.lastTickTime = void 0,
            this.pauseAllSliders();
          break;
        case "set-tool-preview-state":
          this.setToolPreviewState(e.state);
          break;
        case "apply-transformation-to-selected":
          this.transformAllSelectedItemsByAssignmentLatex(
            e.assignmentLatex,
          ), this.closeItemSettingsMenu();
          break;
        case "set-geometry-toolbar": {
          jz(this.geometryToolbarModel, e.toolbar);
          break;
        }
        case "set-geometry-custom-toolbar-setting": {
          vE(this.geometryToolbarModel, e.tool, e.value);
          break;
        }
        case "set-author-mode": {
          this.setAuthorMode(e.enabled);
          break;
        }
        case "set-translucent-surfaces": {
          this.getGraphSettings().config.setProperty(
            "translucentSurfaces",
            e.value,
          );
          break;
        }
        case "set-perspective-distortion": {
          this.getGraphSettings().config.setProperty(
            "perspectiveDistortion",
            e.value,
          ), (v = this.grapher3d) == null || v.redrawAllLayers();
          break;
        }
        case "mute-global":
        case "unmute-global": {
          e.type === "unmute-global" && this.runAfterDispatch(() => {
            var x;
            (x = this.getAudioGraph()) == null || x.exitAudioTrace();
          }),
            (w = this.toneController) == null || w.handleAction(e),
            this.getGraphSettings().config.setProperty(
              "muted",
              e.type === "mute-global",
            );
          break;
        }
        case "mark-too-complex-for-gl": {
          for (let x of e.errors) {
            let L = this.getItemModel(x);
            L && L.type === "expression" && (L.expressionTooComplex = true);
          }
          for (let x of e.fixed) {
            let L = this.getItemModel(x);
            L && L.type === "expression" && (L.expressionTooComplex = false);
          }
          break;
        }
        case "update-legacy-random-seed-behavior": {
          this.setIncludeFunctionParametersInRandomSeed(true),
            this.setState(this.getState(), { allowUndo: true });
          break;
        }
        case "add-poi-expression": {
          let x = this.getNextColor();
          x === zf && (x = this.getNextColor());
          let L = this.createItemModel({
            type: "expression",
            id: this.generateId(),
            latex: e.latex,
            color: x,
          });
          this.setEditListMode(false), ol(this.listModel, L), bi(this, L.id);
          break;
        }
        case "create-table-regression": {
          let x = this.getItemModel(e.tableId);
          if (
            (x == null ? void 0 : x.type) === "table" &&
            this.areTableRegressionsEnabled()
          ) {
            let L = e.columnIds;
            if (!L) {
              let V = x.columnModels.slice(1).filter((R) => Cp(R) && Ru(R));
              if (V.length === 0) break;
              L = { x: x.columnModels[0].id, y: V[0].id };
            }
            bw(x, {
              type: e.regressionType,
              columnIds: L,
              id: this.generateId(),
              color: this.getNextColor(),
              lineStyle: "SOLID",
              hidden: false,
              isLogMode: this.areLogModeRegressionsDefault() ||
                this.areLogModeRegressionsForced(),
              residualVariable: void 0,
            }),
              qr(this, {
                type: "table-regression-type-dropdown",
                id: e.tableId,
              });
          }
          break;
        }
        case "remove-table-regression": {
          let x = this.getItemModel(e.tableId);
          if ((x == null ? void 0 : x.type) === "table") {
            if (
              ((k = (S = x.formula) == null ? void 0 : S.table_regression) ==
                  null
                ? void 0
                : k.status) === "success"
            ) {
              let V = x.formula.table_regression.result.residualVariable;
              if (V) {
                let R = x.columnModels.findIndex((N) => N.latex === V);
                R >= 0 && mw(x, R);
              }
            }
            bw(x, void 0),
              qr(this, {
                type: "add-table-regression-btn",
                id: e.tableId,
              });
          }
          break;
        }
        case "update-table-regression": {
          let x = this.getItemModel(e.tableId);
          if ((x == null ? void 0 : x.type) === "table" && x.regression) {
            let L = { ...x.regression, ...e.update };
            bw(x, L);
          }
          break;
        }
        case "export-table-regression": {
          this.exportTableRegression(e.mode, e.tableId);
          break;
        }
        default:
          return e;
      }
    }
    areTableRegressionsEnabled() {
      return this.getGraphSettings().config.tableRegressions;
    }
    switchAxisScale(e, t) {
      var i;
      if (!t || t === this.graphSettings[e]) return;
      this.graphSettings.setProperty("polarMode", false);
      let o;
      this.getAllItemModels().forEach((n) => {
        if (this.isExpressionZoomFit(n)) {
          if (!this.getBoundingBoxesForZoomFit(n)) return;
          o = n.id;
        }
      }),
        this.graphSettings.setProperty(e, t),
        (i = this.getGrapher2d()) == null ||
        i.getProjection().updateScalePairs(),
        !(o &&
          this._expressionZoomFit(o, {
            focusAfterTap: false,
            synchronous: true,
            justResiduals: false,
          })) && this.enforceAxisLimitsForScale(e);
    }
    enforceAxisLimitsForScale(e) {
      let t = this.getGrapher2d();
      if (!t) return;
      let o = t.getDefaultViewport();
      if (!o) return;
      e === "xAxisScale"
        ? (this._setAxisLimitLatex(
          "xmin",
          __dcg_shared_module_exports__["truncatedLatexLabel"](o.xmin),
        ),
          this._setAxisLimitLatex(
            "xmax",
            __dcg_shared_module_exports__["truncatedLatexLabel"](o.xmax),
          ))
        : (this._setAxisLimitLatex(
          "ymin",
          __dcg_shared_module_exports__["truncatedLatexLabel"](o.ymin),
        ),
          this._setAxisLimitLatex(
            "ymax",
            __dcg_shared_module_exports__["truncatedLatexLabel"](o.ymax),
          )),
        this.graphSettings.xAxisScale === this.graphSettings.yAxisScale &&
        (this.graphSettings.setProperty(
          "lastChangedAxis",
          e === "xAxisScale" ? "y" : "x",
        ),
          t.viewportController.zoomSquareImmediately(),
          this.markSquareAxesAfterUserEditedViewport());
      let i = t.viewportController.getViewport(),
        n = t.getProjection(),
        { xmin: a, xmax: s, ymin: l, ymax: c } = i,
        d = this.getGraphSettings().config.logScales;
      if (e === "xAxisScale" && d) {
        let p = n.mapx(a),
          h = n.mapx(s),
          u = ho(n.reverse_mapx(p - .25), n.reverse_mapx(p + .25)),
          f = ho(n.reverse_mapx(h - .25), n.reverse_mapx(h + .25));
        this._setAxisLimitLatex(
          "xmin",
          __dcg_shared_module_exports__["truncatedLatexLabel"](u),
        ),
          this._setAxisLimitLatex(
            "xmax",
            __dcg_shared_module_exports__["truncatedLatexLabel"](f),
          );
      }
      if (e === "yAxisScale" && d) {
        let p = n.mapy(l),
          h = n.mapy(c),
          u = ho(n.reverse_mapy(p - .25), n.reverse_mapy(p + .25)),
          f = ho(n.reverse_mapy(h - .25), n.reverse_mapy(h + .25));
        this._setAxisLimitLatex(
          "ymin",
          __dcg_shared_module_exports__["truncatedLatexLabel"](u),
        ),
          this._setAxisLimitLatex(
            "ymax",
            __dcg_shared_module_exports__["truncatedLatexLabel"](f),
          );
      }
      this.lastDirectlyEditedViewport = t.getCurrentViewport();
    }
    _convertOrCreateTable(e) {
      let t = this.getItemModelByIndex(e), o = Sg(t), i = ZS(t);
      if ((t == null ? void 0 : t.type) !== "expression") return;
      let n = this.isInEditListMode(), a;
      switch (o) {
        case "point-list":
          a = DU(t);
          break;
        case "point-list-reference":
          a = kU(t);
          break;
        case "anonymous-function":
          a = _U(t);
          break;
        case "function-reference":
          a = MU(t);
          break;
        case "recursive-function":
          a = AU(t);
          break;
      }
      if (n && this.setEditListMode(false), !o || !a) {
        this._showToast({
          message: this.s(
            "graphing-calculator-text-table-creation-error",
          ),
        }),
          So("Convert to table bug", {
            metaData: { latex: t.latex, type: o },
          });
        return;
      }
      let s = {
          id: this.generateId(),
          type: "table",
          readonly: t.readonly,
          columns: [{
            ...dg,
            id: this.generateId(),
            latex: a.headers[0],
            values: a.values[0],
          }, {
            ...dg,
            id: this.generateId(),
            latex: a.headers[1],
            values: a.values[1],
            color: t.color,
            lines: !i && !!t.lines,
          }],
        },
        l = this.createItemModel(s);
      if (i) {
        let d = t.index + 1;
        if (o === "recursive-function") {
          let p = t.formula.function_definition;
          for (; this.isBaseCaseItem(d, p);) d++;
        }
        this._toplevelInsertItemAt(d, l, true, t.folderId);
      } else this._toplevelReplaceItemAt(t.index, l, true);
      let c = () => {
        this.dispatch({ type: "undo" }),
          n &&
          this.dispatch({
            type: "set-edit-list-mode",
            isEditListMode: true,
            focusExpressionList: false,
          });
      };
      this._showToast({
        message: this.s("graphing-calculator-text-table-created"),
        undoCallback: c,
      }), this.logEvent({ category: "convert-to-table", action: o });
    }
    isBaseCaseItem(e, t) {
      var i;
      let o = this.getItemModelByIndex(e);
      return !o || o.type !== "expression" || !t
        ? false
        : ((i = o.formula.recursion_base_case) == null ? void 0 : i.symbol) ===
          t;
    }
    hasTableHeaderWithIdentifier(e) {
      return !!e && U4(this.listModel, e);
    }
    updateGraphSettingsViewportLimitsLatex(e) {
      this._setAxisLimitLatex("xmin", e.xmin + ""),
        this._setAxisLimitLatex("xmax", e.xmax + ""),
        this._setAxisLimitLatex("ymin", e.ymin + ""),
        this._setAxisLimitLatex("ymax", e.ymax + ""),
        this._setAxisLimitLatex("zmin", e.zmin + ""),
        this._setAxisLimitLatex("zmax", e.zmax + "");
    }
    transformAllSelectedItemsByAssignmentLatex(e) {
      var c, d;
      let t = FE(this.listModel),
        o = this.findLastTokenNumber() + 1,
        i = this.findLastSubscriptForLetters(),
        n = this.getGeometryFolder(),
        a = n ? n.index + this.getNumberOfItemsInFolder(n.id) + 1 : 0,
        s = {};
      for (let p of t) {
        if (p.type !== "expression" || !p.formula.geometry) continue;
        let u = (c = p.formula.typed_constant_value) == null
          ? void 0
          : c.valueType;
        if (
          !u ||
          __dcg_shared_module_exports__["isTypeOrListOfType"](
            u,
            __dcg_shared_module_exports__["Transformation"],
          )
        ) continue;
        let f = (d = pi(p)) == null ? void 0 : d.latex;
        f || (f = this._autoNameExpression(p, i));
        let y = `\\token{${o}}`;
        o += 1;
        let C = `${y}=${e}\\left(${f}\\right)`,
          E = this.createItemModel({
            id: this.generateId(),
            type: "expression",
            showLabel: p.showLabel && !p.label,
            showAngleLabel: p.showAngleLabel && !p.label,
            latex: C,
            folderId: n && n.id,
            color: p.color,
          });
        s[E.id] = true,
          n ? (_s(this.listModel, E, a), a += 1) : ol(this.listModel, E);
      }
      let l = Object.keys(s);
      if (l.length && rL(this.listModel, s), l.length === 1) {
        let p = l[0];
        this.runAfterDispatch(() => {
          this.getItemModel(p) &&
            this.get2dPOIController().keyboardAttentionManager
              .updateKeyboardAttention({
                calcId: p,
                listIndex: void 0,
                polygonEdge: void 0,
              }, { describe: false });
        });
      }
    }
    convertToTokenAssignment(e, t = "") {
      var n;
      let o = (n = pi(e)) == null ? void 0 : n.latex,
        i = t
          ? Nx(t) || ""
          : "\\token{" + (this.findLastTokenNumber() + 1) + "}";
      o ? fd(this.listModel, o, i) : $a(e, i + "=" + e.latex);
    }
    convertToNamedAssignment(e, t = "") {
      let o = oT(e);
      if (!o) return;
      let i = t ? Nx(t) : this.getAutonameLatexForExpression(e);
      i ? fd(this.listModel, o, i) : $a(e, t);
    }
    getAutonameLatexForExpression(e, t) {
      if (
        t || (t = this.findLastSubscriptForLetters()),
          fL(e) === "point" && e.label && ya(e.label) &&
          this.countGlobalIdentifierOccurences(e.label) === 0
      ) return e.label;
      let o = Uq(e), i = (t[o] || 0) + 1;
      return t[o] = i, o + "_{" + i + "}";
    }
    _autoNameExpression(e, t) {
      let o = this.getAutonameLatexForExpression(e, t);
      return $a(e, o + "=" + e.latex), o;
    }
    isGeoToolVisible(
      e,
      { ignoreAuthorMode: t } = { ignoreAuthorMode: false },
    ) {
      return !t && this.shouldShowAuthorFeatures()
        ? true
        : Tg(this.geometryToolbarModel, e);
    }
    isGeoToolEnabled(
      e,
      { ignoreAuthorMode: t } = { ignoreAuthorMode: false },
    ) {
      return !t && this.shouldShowAuthorFeatures()
        ? true
        : $f(this.geometryToolbarModel, e);
    }
    setGeoTool(e) {
      if (
        !this.geoUIActive || this.activeTool === e ||
        !this.isGeoToolEnabled(e)
      ) return;
      Yz(this.geometryToolbarModel, e, this.shouldShowAuthorFeatures()),
        this.activeTool = e,
        this.getGeoModel().setToolMode(e),
        this.cancelGeoToolplay();
    }
    cancelGeoToolplay() {
      var t;
      let e = this.getGeoModel();
      e.cancelToolplay(),
        e.deselectAllObjects(),
        this.setToolPreviewState({}),
        (t = this.get2dPOIController()) == null || t.cancelGeoToolplay();
    }
    setToolPreviewState(e) {
      var i;
      this.toolPreviewJSONState = e;
      let t = this.listModel.__toolPreviewIdToModel;
      this.listModel.__toolPreviewIdToModel = {};
      let o = lV(e, { isBeingCommitted: false });
      for (let n in e) {
        let a = e[n], s = o[n];
        if (!s || s.type !== "assignment") continue;
        let l;
        for (let c in t) {
          let d = t[a.type === "expression-edit-preview-latex" ? Zf : c];
          if (((i = pi(d)) == null ? void 0 : i.latex) === n) {
            l = d;
            break;
          }
        }
        if (l) {
          l.latex = s.latex,
            l.color = s.color,
            l.showAngleLabel = !!s.showAngleLabel,
            l.hidden = a.hidden;
        } else {
          let c = a.type === "expression-edit-preview-latex"
              ? this.getSelectedItem()
              : void 0,
            d = (c == null ? void 0 : c.type) === "expression"
              ? Mw(c, { stripDefaults: true })
              : void 0;
          l = zE({
            ...d,
            id: a.type === "expression-edit-preview-latex"
              ? Zf
              : this.generateId(),
            type: "expression",
            color: s.color,
            latex: s.latex,
            showAngleLabel: !!s.showAngleLabel,
            hidden: a.hidden,
          }, this);
        }
        this.listModel.__toolPreviewIdToModel[l.id] = l;
      }
    }
    isGeoItem(e) {
      let t = this.getItemModel(e);
      return t && t.type === "expression" && t.formula &&
        t.formula.geometry && !t.formula.error;
    }
    getSelectedGeoExpression() {
      let e = this.getSelectedItem();
      if (e && this.isGeoItem(e.id) && e.type === "expression") return e;
    }
    getGeometryFolder() {
      let e = this.getItemModel(__dcg_shared_module_exports__["xd"]);
      return e && e.type === "folder" ? e : void 0;
    }
    isItemInGeoFolder(e) {
      let t = this.getItemModel(e);
      return !t || t.type === "folder"
        ? false
        : t.folderId === __dcg_shared_module_exports__["xd"];
    }
    isGeoFolder(e) {
      return e.id === __dcg_shared_module_exports__["xd"];
    }
    isItemNotSelectableBecauseItsSecret(e) {
      return !(this.shouldShowAuthorFeatures() ||
        this.isItemInGeoFolder(e) || !this.isItemSecret(e));
    }
    pauseAllSliders() {
      this.getPlayingSliders().forEach((e) => {
        As(e, false);
      });
    }
    countGlobalIdentifierOccurences(e) {
      return Cw(this.listModel, e);
    }
    handleClickableItemClicked(e, t) {
      let o = this.getItemModel(e);
      nb(o) && this.evaluator.addClickEvent(o.id, t);
    }
    canAddTicker() {
      return !this.getTickerOpen();
    }
    doesIdentifierBlockActionUpdate(e) {
      let t = this.getFocusLocation(), o = Nu(this.listModel, e);
      for (let i of o) {
        if (
          (t == null ? void 0 : t.type) === "expression" &&
            t.id === i.id || Hq(i)
        ) return true;
      }
      return false;
    }
    getItemsByIdentifier(e) {
      return Nu(this.listModel, e);
    }
    isAtLeastOnePointSelected() {
      let e = this.getAllSelectedItems();
      for (let t = 0; t < e.length; t++) {
        let o = e[t];
        if (o.type === "expression" && mc(o)) return true;
      }
      return false;
    }
    toggleLabelForAllSelectedObjects() {
      let e = [], t = [];
      this.getAllSelectedItems().forEach((o) => {
        o.type === "expression" && mc(o) &&
          (o.showLabel ? t.push(o) : e.push(o));
      }),
        e.length
          ? this.setLabelStateForObjects(e, "measurement")
          : t.length && this.setLabelStateForObjects(t, "none");
    }
    setLabelStateForObjects(e, t) {
      let o = /^([A-Z])([0-9]*)$/;
      if (t === "auto") {
        let i = 0;
        this.getAllItemModels().forEach((n) => {
          if (n.type !== "expression" || !n.showLabel || !n.label) return;
          let a = n.label.match(o);
          if (!a) return;
          let s = a[1].charCodeAt(0) - 65;
          a[2] && (s += parseInt(a[2]) * 26), s >= i && (i = s + 1);
        }),
          e.forEach((n) => {
            if (!n.label) {
              let a = i;
              i++;
              let s = String.fromCharCode(a % 26 + 65),
                l = Math.floor(a / 26),
                c = l > 0 ? l + "" : "";
              yd(n, s + c);
            }
            Ku(n, true);
          });
      } else if (t === "measurement") {
        for (let i of e) yd(i, ""), Ku(i, true);
      } else if (t === "none") {
        for (let i of e) o.test(i.label) && yd(i, ""), Ku(i, false);
      }
    }
    updateLatexForIdentifier(e, t) {
      let o = Nu(this.listModel, e);
      if (o.length === 1) {
        let i = o[0];
        i.slider.isPlaying ? (As(i, false), $a(i, t), As(i, true)) : $a(i, t);
      }
    }
    updateExpressionSearchStr(e) {
      this.rawExpressionSearchStr = e;
      let t = "\\operatorname{rename}";
      if (e.indexOf(t) === 0) {
        let i = e.slice(t.length).replace(/\\ /g, "").split(
          /\\to(?![a-zA-Z])/,
        );
        i.length === 2
          ? (this.expressionSearchStr = i[0],
            this.isExpressionSearchStrValidForReplace = ya(
              this.expressionSearchStr,
            ),
            this.updateExpressionReplaceStr(i[1]))
          : (this.expressionSearchStr = i[0],
            this.isExpressionSearchStrValidForReplace = false,
            this.updateExpressionReplaceStr(""));
        let n = z4(this.listModel, this.getExpressionSearchStr());
        this.expressionSearchCount = this.expressionSearchOpen ? n : 0;
      } else {this.expressionSearchStr =
          e.length > 1 && "rename".indexOf(e) === 0
            ? ""
            : e,
          this.isExpressionSearchStrValidForReplace = false,
          this.updateExpressionReplaceStr(""),
          this.filterItemsBySearch();}
    }
    closeExpressionsSearch() {
      var o;
      if (
        this.expressionSearchOpen = false,
          this.updateExpressionSearchStr(""),
          ((o = this.getFocusLocation()) == null ? void 0 : o.type) ===
            "ticker"
      ) return;
      let e = this.getFirstSelectedItem(),
        t = this.getItemModelByIndex(0);
      !e && t && bi(this, t.id, "end"),
        e && this.getSelectedItem() && !this.getFocusedItem() &&
        bi(this, e.id, "end"),
        (e || t) &&
        (this.shouldScrollSelectedItemIntoViewAfterDispatch = true);
    }
    filterItemsBySearch() {
      if (!this.getExpressionReplaceStr()) {
        let e = q4(this.listModel, this.getExpressionSearchStr());
        this.expressionSearchCount = this.expressionSearchOpen ? e : 0;
      }
    }
    updateExpressionReplaceStr(e) {
      this.expressionReplaceStr = e,
        this.isExpressionReplaceStrValidForReplace = ya(e);
    }
    getIsExpressionSearchStrValidForReplace() {
      return this.isExpressionSearchStrValidForReplace;
    }
    getIsExpressionReplaceStrValidForReplace() {
      return this.isExpressionReplaceStrValidForReplace;
    }
    isSearchReplaceValid() {
      return this.getIsExpressionSearchStrValidForReplace() &&
        this.getIsExpressionReplaceStrValidForReplace();
    }
    shouldShowReplaceIcon() {
      return this.isSearchReplaceValid();
    }
    updateTickerHandlerLatex(e) {
      this.listModel.ticker.handlerLatex = e;
    }
    updateTickerMinStepLatex(e) {
      this.listModel.ticker.minStepLatex = e;
    }
    getRawExpressionSearchStr() {
      return this.rawExpressionSearchStr || "";
    }
    getExpressionSearchStr() {
      return this.expressionSearchStr || "";
    }
    getExpressionReplaceStr() {
      return this.expressionReplaceStr || "";
    }
    getExpressionSearchCount() {
      return this.expressionSearchCount || 0;
    }
    getTicker() {
      return this.listModel.ticker;
    }
    getTickerHandlerLatex() {
      return this.listModel.ticker.handlerLatex || "";
    }
    getTickerMinStepLatex() {
      return this.listModel.ticker.minStepLatex || "";
    }
    getTickerAvgDelta() {
      return this.listModel.ticker.avgDelta;
    }
    getBrailleMode() {
      return this.graphSettings.config.brailleMode;
    }
    setBrailleMode(e) {
      this.graphSettings.config.setProperty("brailleMode", e);
    }
    getSixKeyInput() {
      return this.graphSettings.config.sixKeyInput;
    }
    setSixKeyInput(e) {
      this.graphSettings.config.setProperty("sixKeyInput", e);
    }
    getBrailleControls() {
      return this.graphSettings.config.brailleControls;
    }
    setBrailleControls(e) {
      this.graphSettings.config.setProperty("brailleControls", e);
    }
    getAudio() {
      return this.graphSettings.config.audio;
    }
    setAudio(e) {
      this.graphSettings.config.setProperty("audio", e);
    }
    setEditListMode(e) {
      this.layoutModel = { ...this.layoutModel, inEditListMode: e };
    }
    generateTableXSubscript() {
      return OE(this.listModel);
    }
    findLastTokenNumber() {
      return H4(this.listModel);
    }
    findLastSubscriptForLetters() {
      return K4(this.listModel);
    }
    _createTableItem() {
      let e = this.generateTableXSubscript(), t = FG(e, [[], []], this);
      return this.createItemModel(t);
    }
    _populateSettingsViewLimitLatex() {
      let e = this.getGrapher();
      if (!e) return;
      let t = e.getCurrentViewport();
      this.isGraphSettingsOpen() &&
          __dcg_shared_module_exports__["E"](
            t,
            this.lastDirectlyEditedViewport,
          ) ||
        (this.settingsViewModel = {
          ...this.settingsViewModel,
          limitLatex: oj(t, {
            steps: this.getAxisStepSettings(),
            scales: this.getAxisScaleSettings(),
          }),
        });
    }
    getAxisStepSettings() {
      return {
        xAxisStep: this.graphSettings.xAxisStep,
        yAxisStep: this.graphSettings.yAxisStep,
      };
    }
    getAxisScaleSettings() {
      return {
        xAxisScale: this.graphSettings.xAxisScale,
        yAxisScale: this.graphSettings.yAxisScale,
      };
    }
    getDefaultAxisScaleSettings() {
      var t, o;
      let { defaultState: e } = this.graphSettings;
      return {
        xAxisScale:
          ((t = e == null ? void 0 : e.graph) == null
            ? void 0
            : t.xAxisScale) || "linear",
        yAxisScale:
          ((o = e == null ? void 0 : e.graph) == null
            ? void 0
            : o.yAxisScale) || "linear",
      };
    }
    getSettingsViewModel() {
      return this.settingsViewModel;
    }
    getListModel() {
      return this.listModel;
    }
    getGeometryToolbarModel() {
      return this.geometryToolbarModel;
    }
    hasBackgroundColor() {
      return this.getBackgroundColor() !== "#ffffff";
    }
    getBackgroundColor() {
      return this.getGraphSettings().getConfiguredBackgroundColor();
    }
    hasTextColor() {
      return this.getTextColor() !== "#000000";
    }
    getTextColor() {
      return this.getGraphSettings().getConfiguredTextColor();
    }
    getPillboxBackgroundColor() {
      return __dcg_shared_module_exports__["Kd"](
        this.getBackgroundColor(),
        -.07,
      );
    }
    subscribeToChanges(e) {
      let t = this.nextSubscription;
      return this.nextSubscription += 1, this.subscriptions[t] = e, () => {
        delete this.subscriptions[t];
      };
    }
    updateTheComputedWorld() {
      var d, p, h, u, f, y, C, E, v;
      _g(this.listModel);
      let t = this.getSelectedItem() && this.activeTool === "expression-edit" &&
          this.listModel.__toolPreviewIdToModel[Zf] &&
          ((d = this.getGrapher()) != null && d.graphSketches[Zf])
        ? "preview"
        : "actual";
      W4(this.listModel, t),
        (p = this.grapher2d) == null ||
        p.setTabOrder(this.listModel.tabOrder),
        (h = this.grapher3d) == null ||
        h.setTabOrder(this.listModel.tabOrder),
        (u = this.grapher2d) == null ||
        u.setDrawLayers(this.listModel.drawLayers),
        (f = this.grapher3d) == null ||
        f.setDrawLayers(this.listModel.drawLayers);
      let o = {},
        i = (w) => {
          var k;
          let S = (k = pi(w)) == null ? void 0 : k.identifier;
          S && (S[0] === "$" || w.formula.geometry) && S &&
            (o[S]
              ? o[S].multiple = true
              : o[S] = { model: w, multiple: false });
        };
      for (let w of this.getAllToolPreviewItems()) bL(w), i(w);
      for (let w of this.getAllItemModels()) {
        switch (w.type) {
          case "expression":
            bL(w), i(w);
            break;
          case "image":
            n4(w);
            break;
          case "table":
            tz(w);
            break;
          case "folder":
            Gz(w);
            break;
          case "text":
            f4(w);
            break;
          default:
            return w;
        }
      }
      this.geoUIActive = this.isGeometry() &&
        !this.getGraphSettings().config.hideGeoUI, this.cachedGeoTokenInfo = {};
      for (let w in o) {
        let { multiple: S, model: k } = o[w],
          _ = "blue",
          A = "unknown",
          P = "unknown",
          O = false,
          U = false,
          z = false,
          x = Hi(k);
        !S && k
          ? (_ = Fu(k),
            O = Bq(k),
            P = qq(k),
            A = fL(k),
            k.error && (U = true, _ = "#"))
          : (A = "error", U = true),
          A && k ? this.isItemSelected(k.id) && (z = true) : U = true;
        let L = (k == null ? void 0 : k.label) || "";
        this.cachedGeoTokenInfo[w] = {
          groupType: A,
          iconType: P,
          isList: O,
          hasError: U,
          color: _,
          isSelected: z,
          isHidden: x,
          label: L,
          calcId: k && k.id || "",
        };
      }
      this.cachedGeoTokenDepths = {};
      let { createdDepth: n, firstReferencedDepth: a } = this.geoModel
        .getComputedBoard().getDepthValues();
      for (let w in this.cachedGeoTokenInfo) {
        let { calcId: S } = this.cachedGeoTokenInfo[w],
          k = this.getItemModel(S);
        if (!k) continue;
        let _ = w;
        if (
          !(w in n) && k.type === "expression" &&
          (S === this.getDraggedItemId() || k === this.getFocusedItem())
        ) {
          let L = k.formula.assignment;
          L && L in n && (_ = L);
        }
        let A = n[_] || 0, P = a[_];
        P = isFinite(P) ? P : 0;
        let O = Math.max(A, P - 1) + "", U = this.cachedGeoTokenDepths[O];
        U || (U = [], this.cachedGeoTokenDepths[O] = U);
        let z = this.cachedGeoTokenInfo[w];
        !this.isItemInGeoFolder(k.id) && (k.readonly || Ds(k)) ||
          U.push({
            color: z.color,
            groupType: z.groupType,
            identifier: w,
            calcId: S,
          });
      }
      D4(this.listModel.ticker);
      let s = this.getFocusLocation();
      if (
        s && s.type === "expression" && s.isFakeGraphFocus &&
        (this.getValidCursorContext() ||
          qr(this, { ...s, isFakeGraphFocus: void 0 })),
          this.isCurrentFocusLocationValid() || qr(this, void 0),
          this.listModel.openItemMenu
      ) {
        let w = this.getOpenMenuIcon();
        document.body && w && document.body.contains(w) ||
          (this.listModel.openItemMenu = void 0);
      }
      let l = this.getSelectedItem();
      l && !this.getItemModel(l.id) && Nr(this.listModel, void 0),
        this._populateSettingsViewLimitLatex(),
        this.propagateSelection(),
        this.propagateActiveTokens(),
        this.isKeypadOpen() ||
        (this.layoutModel = {
          ...this.layoutModel,
          keypadFunctionsOpen: false,
        }),
        yq(this.listModel),
        this.isGeometry() && l && l.type === "expression"
          ? this.getValidCursorContext()
            ? (this.setGeoTool("expression-edit"),
              this.geoModel.updateFadeAnimations())
            : this.geoModel.getToolMode() === "expression-edit" &&
              this.setGeoTool("selection")
          : this.geoModel.getToolMode() === "expression-edit" &&
            this.setGeoTool("selection"),
        this.isGeometry() &&
        this.getGeoModel().updateAvailableInputTypes();
      let c = this.getValidCursorContext();
      this.isGeometry() &&
      this.getGeoModel().getToolMode() === "expression-edit" &&
      !__dcg_shared_module_exports__["E"](c, this.lastCursorContext) &&
      this.runAfterDispatch(() => {
        var w;
        (w = this.get2dPOIController()) == null || w.replayGeoTapMove();
      }),
        this.lastCursorContext = c,
        (C = (y = this.grapher2d) == null ? void 0 : y.poiController) !=
          null &&
        C.keyboardAttentionManager.getKeyboardAttention() &&
        !this.isGraphPaperFocused() &&
        ((v = (E = this.grapher2d) == null ? void 0 : E.poiController) ==
            null ||
          v.keyboardAttentionManager.setKeyboardAttention(void 0)),
        this.isGeometry() &&
        (qz(this.geometryToolbarModel),
          this.isGeoToolEnabled(this.getActiveTool()) ||
          this.setGeoTool("selection")),
        this.runAfterDispatch(() => {
          var w, S;
          this.isThreeDMode() ||
            ((w = this.grapher2d) == null ||
              w.audioGraph.checkIfSelectedItemChanged(l ? l.id : void 0),
              this.focusLocation &&
              this.focusLocation.type !== "graph-paper" &&
              ((S = this.grapher2d) == null ||
                S.audioGraph.exitAudioTrace()));
        });
    }
    getOpenMenuIconSelector() {
      let e = this.getOpenItemMenu();
      return e ? `[dcg-open-menu-guid="${e.guid}"]` : void 0;
    }
    getOpenMenuIcon() {
      let e = this.getOpenMenuIconSelector();
      return e ? this.findEl(e) : void 0;
    }
    propagateSelection() {
      let e = this.getGrapher();
      e
        ? this.__lastSelectedIdsForPropagation = W$(
          this,
          e,
          this.__lastSelectedIdsForPropagation,
        )
        : this.__lastSelectedIdsForPropagation = {
          selected: {},
          hoistedToTop: {},
        };
    }
    propagateActiveTokens() {
      var e, t;
      this.isThreeDMode() ||
        ((e = this.grapher2d) == null ||
          e.setActiveToken(
            this.getExpressionIdForIdentifier(this.activeTokens.selected),
            "selected",
          ),
          (t = this.grapher2d) == null ||
          t.setActiveToken(
            this.getExpressionIdForIdentifier(this.activeTokens.hovered),
            "hovered",
          ));
    }
    getHoveredOrFocusedTokenIdentifier() {
      if (this.activeTokens.hovered) return this.activeTokens.hovered;
      let e = this.getFocusLocation();
      if (e && e.type === "geo-token") return e.identifier;
    }
    doesLatexContainToken(e) {
      return zq(e);
    }
    getToolPreviewJSONState() {
      return this.toolPreviewJSONState;
    }
    removeListOfItems(e) {
      let t = {}, o = [], i = new Set();
      return e.forEach((n) => {
        if (this.isItemReadonly(n)) i.add(n);
        else {
          let a = Ag(this.listModel, n);
          for (let s of a) t[s.id] || (t[s.id] = true, o.push(s));
        }
      }),
        { deletedItems: o, readonlyItemsNotDeleted: i.size };
    }
    garbageCollectGeo(e, t) {
      if (!this.isGeometry()) return;
      let o = j$(this, e, t);
      o.length && this.removeListOfItems(o);
    }
    ensureAtLeastOneVisibleItem() {
      if (Z4(this.listModel)) {
        let e = this.createItemModel({
          type: "expression",
          id: this.generateId(),
          color: this.getNextColor(),
        });
        ol(this.listModel, e);
      }
    }
    getExpressionIdForIdentifier(e) {
      if (!e) return;
      let t = this.getItemsByIdentifier(e);
      if (t.length === 1) return t[0].id;
    }
    getValidCursorContext() {
      var n;
      let e = this.getSelectedItem();
      if (!e || e.type !== "expression") return;
      let t = e.formula.cursor_context,
        o = (n = Fe.getFocusedMathquill()) == null ? void 0 : n.selection(),
        i = (e == null ? void 0 : e.type) === "expression" &&
          e.latex === (t == null ? void 0 : t.selection.input) &&
          (o == null ? void 0 : o.startIndex) ===
            (t == null ? void 0 : t.selection.start) &&
          (o == null ? void 0 : o.endIndex) ===
            (t == null ? void 0 : t.selection.end) &&
          (o == null ? void 0 : o.latex) ===
            (t == null ? void 0 : t.selection.input);
      if (this.getGeoModel().getClickToInsertMode() === "permissive") {
        return {
          type: "permissive",
          allowedTypes: [__dcg_shared_module_exports__["Any"]],
          cursorContext: i ? t : void 0,
        };
      }
      if (i) {
        if ((t == null ? void 0 : t.type) === "expression-arguments") {
          let { argIndex: a, positionWithinArg: s } = t;
          if (
            !(a === t.argCount - 1 && s === "end" ||
              t.positionWithinArg === "start-to-end" &&
                (o == null ? void 0 : o.startIndex) !== void 0 &&
                (o == null ? void 0 : o.startIndex) ===
                  (o == null ? void 0 : o.endIndex))
          ) return;
        }
        return t;
      }
    }
    tryInsertTokenIntoMathquill(e, t) {
      if (!this.isGeometry() || !e) return false;
      let o = this.getItemModel(e);
      if (!o || o.type !== "expression") return false;
      let i = o.formula.typed_constant_value;
      t === 0 &&
        (!i || !__dcg_shared_module_exports__["isList"](i.valueType)) &&
        (t = void 0);
      let n, a, s = Ya(o);
      if (
        s
          ? a = __dcg_shared_module_exports__["identifierToLatex"](s)
          : o.formula.geometry &&
            (a = this.getAutonameLatexForExpression(o), n = a), !a
      ) return false;
      t !== void 0 && (a += "\\left[" + (t + 1) + "\\right]");
      let l = this.getFocusLocation();
      return !l ||
          !this.seemsLikeInsertingTokenWillImproveThings(
            i == null ? void 0 : i.valueType,
          )
        ? false
        : l.type === "expression"
        ? (n &&
          (Ro(o) === "NONE" && o.dragMode === "AUTO" && Mg(o, "NONE"),
            $a(o, n + "=" + o.latex)),
          this.writeIdentifierIntoCurrentMathquill(a),
          true)
        : false;
    }
    seemsLikeInsertingTokenWillImproveThings(e) {
      let t = this.getValidCursorContext();
      if (t) {
        if (!e) return false;
        let o = __dcg_shared_module_exports__["isList"](e)
          ? __dcg_shared_module_exports__["elementType"](e)
          : e;
        return t.type === "empty" &&
            __dcg_shared_module_exports__["isGeometryType"](o)
          ? false
          : (t.type === "expression-arguments"
            ? t.allowedTypesForInsertedArg
            : t.allowedTypes).some((n) =>
              __dcg_shared_module_exports__["isSubTypeOrCoercible"](o, n)
            );
      }
      return false;
    }
    writeIdentifierIntoCurrentMathquill(e) {
      this.runAfterDispatch(() => {
        let t = Fe.getFocusedMathquill();
        if (!t) return;
        let o = this.getValidCursorContext(),
          i = (o == null ? void 0 : o.type) === "permissive"
            ? o.cursorContext
            : o,
          n = "",
          a = "";
        (i == null ? void 0 : i.type) === "expression-arguments" &&
          ((i == null ? void 0 : i.positionWithinArg) === "end"
            ? n = ","
            : (i == null ? void 0 : i.positionWithinArg) === "start" &&
              (a = ","));
        let s = `${n}${e}${a}`, l = false;
        if (
          (i == null ? void 0 : i.type) === "expression-arguments" &&
          i.polygonVertices
        ) {
          let { argIndex: c, polygonVertices: d, positionWithinArg: p } = i;
          (e === d.firstLatex || e === d.lastLatex) &&
            (p === "end" || p === "start-to-end") &&
            c === i.argCount - 1 && (s = "", l = true);
        } else {(i == null ? void 0 : i.type) ===
              "expression-arguments" && (l = i.isLastValidArg);}
        Fe.canAcceptText(t, this.getCapExpressionSize(), s) &&
          (t.write(s),
            Fe.simulateUserChangedLatex(t),
            l && t.keystroke("Right"));
      });
    }
    getSelectedExpressionIds() {
      return tq(this.listModel);
    }
    hasTentativeSelection() {
      return cq(this.listModel);
    }
    getPropagatedSelectedIds() {
      return this.__lastSelectedIdsForPropagation;
    }
    areParsableObjectsEqual(e, t) {
      return e === t ? true : __dcg_shared_module_exports__["E"]({
        ...e,
        regressionParameters: void 0,
      }, { ...t, regressionParameters: void 0 });
    }
    requestParseForAllItems() {
      var i, n, a;
      (this.isCurrentlyDoingSetState ||
        this.isCurrentlyDoingRestoreState) &&
        (this.lastParsableObjects = {},
          this.evaluator.clearStatementsAndStartCompleteState(),
          this.isCurrentlyDoingRestoreState &&
          this.evaluator.markUndoRedoState());
      let e = {}, t = this.lastParsableObjects;
      for (let s of this.getAllItemModels()) {
        switch (s.type) {
          case "expression":
          case "image":
          case "table":
            e[s.guid] = s.cachedParsableState;
            break;
          case "folder":
          case "text":
            break;
          default:
            return s;
        }
      }
      for (let s of N4(this.listModel)) e[s.guid] = s.cachedParsableState;
      for (let s of rb(this.listModel)) {
        let l = this.getSelectedItem(), c = this.activeTool === "polygon";
        if (
          this.activeTool === "expression-edit" &&
          (l == null ? void 0 : l.type) === "expression" &&
          ((n = (i = l.formula.geometry) == null ? void 0 : i.call) ==
                null
              ? void 0
              : n.symbol) === "polygon" &&
          ((a = l.formula.cursor_context) == null ? void 0 : a.type) ===
            "expression-arguments"
        ) {
          let { positionWithinArg: d, argIndex: p } = l.formula.cursor_context;
          c = (d === "end" || d === "start-to-end") &&
            p === l.formula.geometry.call.parents.length - 1;
        }
        e[s.guid] = {
          ...s.cachedParsableState,
          shouldOmitLastPolygonSegment: c,
        };
      }
      let o = this.getFocusedItem();
      if ((o == null ? void 0 : o.type) === "expression") {
        let s = Fe.getFocusedMathquill(),
          l = s == null ? void 0 : s.selection();
        (l == null ? void 0 : l.latex) === o.latex &&
          this.shouldEvaluateSelection() &&
          (e[o.guid] = {
            ...o.cachedParsableState,
            latexSelection: { start: l.startIndex, end: l.endIndex },
          });
      }
      if (this.is3dProduct() && this.getTranslucentSurfaces()) {
        for (let s in e) {
          let l = e[s];
          l.type === "statement" &&
            (e[s] = {
              ...l,
              surfaceOpacity: this.getGraphSettings().config.translucentOpacity,
            });
        }
      }
      this.listModel.ticker.cachedParsableState &&
        (e[this.listModel.ticker.guid] =
          this.listModel.ticker.cachedParsableState);
      for (let s of Hz(this.geometryToolbarModel)) e[s.id] = s;
      for (let s in t) {
        let l = t[s], c = e[s];
        if (
          l.type === "image" &&
          (!c || c.type !== l.type || c.guid !== l.guid) &&
          this.grapher2d && this.grapher2d.removeGraphImage(l.id),
            !c &&
            (this.evaluator.removeStatement(l.id), l.type === "table")
        ) {
          for (let d of l.columns) this.evaluator.removeStatement(d.id);
        }
      }
      for (let s in e) {
        let l = e[s], c = t[s];
        if (
          l.type === "image" &&
          (!c || l.type !== c.type || l.guid !== c.guid) && this.grapher2d
        ) {
          let d = this.getItemModel(l.id);
          d && d.type === "image" && this.grapher2d.addGraphImage(d);
        }
        this.areParsableObjectsEqual(l, c) ||
          (this.grapher2d && l.type === "statement" && l.latex === "" &&
            this.grapher2d.removeGraphSketch(l.id),
            this.evaluator.addStatement(l));
      }
      this.lastParsableObjects = e;
    }
    getViewState() {
      let e = this.getGrapher();
      if (e) {
        let t = e.getProjection();
        return {
          viewport: t.viewport.toObject(),
          screen: t.screen,
          xAxisScale: t.settings.xAxisScale,
          yAxisScale: t.settings.yAxisScale,
          degreeMode: t.settings.degreeMode,
          complex: t.settings.complex,
        };
      } else return;
    }
    getTokenRenderInfoByIdentifier(e) {
      let t = this.cachedGeoTokenInfo[e];
      return t ||
        (t = {
          iconType: "unknown",
          isList: false,
          hasError: true,
          isSelected: false,
          groupType: "unknown",
          color: "",
          isHidden: false,
          label: "",
          calcId: "",
        }),
        t;
    }
    setEvaluator(e) {
      this.evaluator = e,
        e.clearSlowEvaluatorTracking = this.clearSlowEvaluatorTracking
          .bind(this);
    }
    getEvaluator() {
      return this.evaluator;
    }
    setGrapher2d(e) {
      this.grapher2d = e;
    }
    setGrapher3d(e) {
      this.grapher3d = e,
        this.grapher2d.poiController.add3DTouchEventHandlers(e);
    }
    getGrapher() {
      return this.isThreeDMode() ? this.grapher3d : this.grapher2d;
    }
    getGrapher2d() {
      return this.grapher2d;
    }
    getGrapher3d() {
      return this.grapher3d;
    }
    get2dPOIController() {
      var e;
      return (e = this.grapher2d) == null ? void 0 : e.poiController;
    }
    isDefaultViewportRestored() {
      var e;
      return !!((e = this.getGrapher()) != null &&
        e.viewportController.isDefaultViewportRestored());
    }
    requestRedrawGraph() {
      var e, t;
      (e = this.grapher2d) == null || e.redrawAllLayers(),
        this.isThreeDMode() &&
        ((t = this.grapher3d) == null || t.redrawAllLayers());
    }
    get2dProjection() {
      var e;
      return (e = this.grapher2d) == null ? void 0 : e.getProjection();
    }
    get2dSketchOrder() {
      return this.grapher2d ? [...this.grapher2d.generateMergeDrawOrder()] : [];
    }
    getBoundingBoxesForZoomFit(e) {
      if (
        !(!this.grapher2d && !this.grapher3d) &&
        this.isZoomFitEnabled() &&
        !(e.type !== "expression" && e.type !== "table") &&
        !(e.type === "expression" &&
          (e.error || !e.shouldGraph || !e.formula.is_graphable))
      ) return e.boundingBoxes;
    }
    getBoundingBoxForResidualsZoomFit(e) {
      var t, o;
      if (
        !(!this.grapher2d && !this.grapher3d) &&
        this.isZoomFitEnabled() &&
        !(e.type !== "expression" && e.type !== "table") &&
        !(e.type === "expression" && (e.error || !e.formula.is_graphable))
      ) {
        if (
          e.type === "table" &&
          ((o = (t = e.formula) == null ? void 0 : t.table_regression) ==
                null
              ? void 0
              : o.status) === "success" &&
          e.boundingBoxes
        ) {
          let i = e.formula.table_regression.result.residualVariable;
          for (let n of e.boundingBoxes) {
            if (
              n.symbol &&
              __dcg_shared_module_exports__["identifierToLatex"](n.symbol) === i
            ) return [n];
          }
        }
        if (e.type === "expression" && e.formula.regression) {
          let i = e.formula.regression.residualVariable;
          for (let n of this.getAllItemModels()) {
            if (n.type === "table" && n.boundingBoxes) {
              for (let a of n.boundingBoxes) {
                if (
                  a.symbol &&
                  __dcg_shared_module_exports__["identifierToLatex"](
                      a.symbol,
                    ) === i
                ) {
                  return [a];
                }
              }
            }
          }
        }
      }
    }
    isExpressionZoomFit(e) {
      if (this.isThreeDMode()) return false;
      let t = this.getBoundingBoxesForZoomFit(e),
        o = this.get2dProjection();
      return !o || !t ? false : !eA(t, o) && !!c1(t, o);
    }
    viewportIsLocked() {
      return this.getLockViewportConfigSetting() ||
        this.getLockViewportUserSetting();
    }
    showExpressionZoomFitButton(e) {
      if (
        this.viewportIsLocked() || this.isGeometry() || this.is3dProduct()
      ) return false;
      let t = this.getBoundingBoxesForZoomFit(e),
        o = this.get2dProjection();
      return !!(o && t && eA(t, o));
    }
    showResidualsZoomFitButton(e) {
      if (
        this.viewportIsLocked() || this.isGeometry() || this.is3dProduct()
      ) return false;
      let t = this.getBoundingBoxForResidualsZoomFit(e),
        o = this.get2dProjection();
      return !!(o && t && eA(t, o));
    }
    setBugsnagContext(e) {
      this.bugsnagContext = e;
    }
    getItemRootNodeById(e) {
      let t = this.getItemModel(e);
      return t == null ? void 0 : t.rootViewNode;
    }
    getItemNodeById(e) {
      return this.getItemRootNodeById(e);
    }
    generateId() {
      let e = this.__nextItemId;
      return this.__nextItemId += 1, e + "";
    }
    getNextColor() {
      return L4(this.listModel);
    }
    getNextDisplayIndex() {
      return this.listModel.nextDisplayIndex;
    }
    _clearPendingImageUploads() {
      this.__pendingImageUploads = {};
    }
    isUploadingImages() {
      return Object.keys(this.__pendingImageUploads).length > 0;
    }
    getExpressionAnalysis() {
      return this.listModel.expressionAnalysis;
    }
    getHelperExpressions() {
      return j4(this.listModel).map((e) => e.proxy);
    }
    createItemModel(e) {
      return Qf(this.listModel, e);
    }
    getItemModel(e, t) {
      return bd(this.listModel, e, t);
    }
    getHiddenGeoItemCount() {
      return Q4(this.listModel);
    }
    getColorById(e) {
      let t = this.getItemModel(e);
      return !t || t.type !== "expression" ? "" : cL(t);
    }
    getAllColorAssignments() {
      let e = [];
      for (let t of this.getAllItemModels()) {
        if (t.type !== "expression") continue;
        let o = Ya(t);
        if (!o) continue;
        let i = this.getEvaluationValueForItem(t.id);
        (typeof i == "string" ||
          Array.isArray(i) && typeof i[0] == "string") &&
          e.push({
            id: t.id,
            assignmentLatex: __dcg_shared_module_exports__["identifierToLatex"](
              o,
            ),
          });
      }
      return e;
    }
    getAllColorFunctionAssignments() {
      let e = [];
      if (!this.isBeta3DMode()) return e;
      for (let t of this.getAllItemModels()) {
        if (t.type !== "expression") continue;
        let o = Ya(t), i = mL(t);
        !o || !i ||
          e.push({
            id: "shader",
            assignmentLatex: "shader:" +
              __dcg_shared_module_exports__["identifierToLatex"](o),
          });
      }
      return e;
    }
    getShader(e) {
      for (let t of this.getAllItemModels()) {
        if (t.type !== "expression") continue;
        let o = Ya(t);
        if (o && __dcg_shared_module_exports__["identifierToLatex"](o) === e) {
          let i = mL(t);
          if (i) return i;
        }
      }
      return { source: "", shaderFunctions: {}, shaderUniforms: [] };
    }
    getItemModelByIndex(e) {
      return kg(this.listModel, e);
    }
    getItemCount() {
      return kw(this.listModel);
    }
    getItemEditableLabelMode(e) {
      let t = this.getItemModel(e);
      if (!(!t || t.type !== "expression")) return Zq(t);
    }
    isItemSecret(e) {
      let t = this.getItemModel(e);
      return t ? Xf(t) : false;
    }
    isItemMarkedReadonly(e) {
      let t = this.getItemModel(e);
      return t
        ? !this.isListEnabled() && !this.isItemInGeoFolder(e) ? true : R4(t)
        : false;
    }
    isItemReadonly(e) {
      return this.isItemMarkedReadonly(e) &&
        !this.shouldShowAuthorFeatures();
    }
    isItemSelected(e) {
      let t = this.getItemModel(e);
      return !!t && Sa(t);
    }
    getItemSelectedState(e) {
      return bq(this.listModel, e);
    }
    isItemGraphing(e) {
      return this.getEvaluatorStateForItem(e) === "GRAPHING";
    }
    getEvaluatorStateForItem(e) {
      return this.evaluator.evaluationProgressById.get(e);
    }
    hasAnyItemsSelected() {
      return this.getAllSelectedItems().length > 0;
    }
    hasMultipleItemsSelected() {
      return this.getAllSelectedItems().length > 1;
    }
    isItemSelectable(e) {
      let t = this.getItemModel(e);
      return t ? tb(t) : false;
    }
    anyItemDependsOnRandomSeed() {
      return hq(this.listModel);
    }
    areActionsEnabled() {
      return this.graphSettings.config.actions === "auto"
        ? mq(this.listModel)
        : !!this.graphSettings.config.actions;
    }
    getAllItemModels() {
      return VE(this.listModel);
    }
    getAllToolPreviewItems() {
      return rb(this.listModel);
    }
    isToolPreviewItem(e) {
      return $4(this.listModel, e);
    }
    getAllModelsWithSliders() {
      return eq(this.listModel);
    }
    getGraphSettings() {
      return this.graphSettings;
    }
    getAudioGraph() {
      var e;
      if (!this.isThreeDMode()) {
        return (e = this.grapher2d) == null ? void 0 : e.audioGraph;
      }
    }
    inAudioTraceMode() {
      let e = this.getAudioGraph();
      return !!(e && e.audioTraceActive);
    }
    canAudioTrace() {
      let e = this.getAudioGraph();
      return e ? e.canAudioTraceCurrentExp() : false;
    }
    isAudioTracing() {
      let e = this.getAudioGraph();
      return e ? e.isAudioTracing() : false;
    }
    expressionsAreFullWidth() {
      return this.isNarrow() ||
        this.graphSettings.config.graphpaper === false;
    }
    getExpListWidthString() {
      return this.expressionsAreFullWidth()
        ? "100%"
        : this.rootElt
        ? this._getExpListWidth() + "px"
        : "0";
    }
    getExpListWidth() {
      return this.rootElt ? this._getExpListWidth() : 0;
    }
    findFirstVisibleItem() {
      let e = i$(this, this._previousFirstVisibleId);
      if (this._previousFirstVisibleId = e, e) {
        return this.getItemModel(e);
      }
    }
    findLastVisibleItem() {
      let e = n$(this, this._previousLastVisibleId);
      if (this._previousLastVisibleId = e, e) return this.getItemModel(e);
    }
    updateRenderShellsAfterDispatch() {
      if (!this.rootElt || !this.isListVisible()) return;
      let e = this.findFirstVisibleItem(),
        t = this.findLastVisibleItem(),
        o = e && this.getItemRootNodeById(e.id),
        i = t && this.getItemRootNodeById(t.id);
      if (
        o === this.lastInfiniteScrollFirstDOM &&
        i === this.lastInfiniteScrollLastDOM &&
        !this.hasDispatchSinceLastInfiniteScrollUpdate
      ) return;
      this.lastInfiniteScrollFirstDOM = o,
        this.lastInfiniteScrollLastDOM = i,
        this.hasDispatchSinceLastInfiniteScrollUpdate = false;
      let n = false,
        a = e ? e.index : 1 / 0,
        s = t ? t.index : 1 / 0,
        l = this.listModel.dragState &&
          this.listModel.dragState.firstItemId,
        c,
        d = this.getOpenItemMenu();
      d && d.type !== "multi-select-more" &&
        d.type !== "multi-select-construct" &&
        d.type !== "multi-select-style" &&
        d.type !== "multi-select-label" &&
        d.type !== "geo-tool-dropdown" && (c = d.model.id);
      for (let p of this.getAllItemModels()) {
        let h = (p.index < a || p.index > s || p.isHiddenFromUI) &&
          !(p.type === "expression" && p.sliderDragging);
        if (
          l == p.id && (h = false),
            c === p.id && (h = false),
            p.renderShell !== h && (p.renderShell = h, n = true, h)
        ) {
          let u = this.getItemRootNodeById(p.id);
          if (u) {
            let f = u.getBoundingClientRect().height;
            f > 0 && (p.cachedRenderHeight = f);
          }
        }
      }
      n && this.markTickRequiredNextFrame();
    }
    updateRenderShellsBeforePaint() {
      if (
        this.hasDispatchSinceLastInfiniteScrollUpdate = true, this.inPrintMode
      ) {
        for (let t of this.getAllItemModels()) t.renderShell = false;
        return;
      }
      for (let t of this.getAllItemModels()) {
        t.isHiddenFromUI && (t.renderShell = true),
          t.type === "expression" && t.sliderDragging &&
          (t.renderShell = false);
      }
      let e = this.getSelectedItem();
      e && !this.isGeoItem(e.id) && (e.renderShell = false);
    }
    updateDragDrop() {
      let e = this.listModel.dragState;
      if (!e) return;
      let t = this.getItemModel(e.firstItemId);
      if (!t) return;
      let o = this.dragdrop_expressions.applyDrag();
      o &&
        (_w(this.listModel, o.dragState),
          _n(t, o.folderId),
          t.index !== o.newIndex &&
          Uu(this.listModel, t.index, o.newIndex, e.numberOfItems));
    }
    _tickSliders(e) {
      this.getPlayingSliders().forEach((t) => {
        _q(t, e);
      });
    }
    tickTicker(e) {
      let t = this.listModel.ticker.lastTickTime === void 0;
      this.evaluator.addClockTickEvent(this.listModel.ticker.id, t),
        _4(this.listModel.ticker, e);
    }
    stopAllSliders() {
      for (let e of this.getAllItemModels()) {
        e.type === "expression" && e.slider.isPlaying && As(e, false);
      }
    }
    getPlayingSliders() {
      let e = this.getAllItemModels(), t = [];
      for (let o of e) {
        o.type === "expression" && o.sliderExists && o.slider.isPlaying &&
          t.push(o);
      }
      return t;
    }
    areAnyImagesLoading() {
      return G4(this.listModel);
    }
    _commitUserRequestedViewport(e) {
      var t;
      (t = this.getGrapher()) == null || t.setUserRequestedViewport(e);
    }
    _setAxisLimitLatex(e, t) {
      this.settingsViewModel = {
        ...this.settingsViewModel,
        limitLatex: { ...this.settingsViewModel.limitLatex, [e]: t },
      };
      let i = t === "" && (e === "xstep" || e === "ystep")
          ? 0
          : io(t, this.graphSettings.degreeMode),
        n = this.getGrapher();
      switch (e) {
        case "xstep":
          {
            if (!ay(i)) return;
            this.graphSettings.setProperty("xAxisStep", i);
          }
          break;
        case "ystep":
          {
            if (!ay(i)) return;
            this.graphSettings.setProperty("yAxisStep", i);
          }
          break;
        case "xmin":
        case "xmax":
        case "ymin":
        case "ymax":
        case "zmin":
        case "zmax":
          {
            if (!n) return;
            let a = n.viewportController.getViewport(), s = "xmin";
            e === "xmin" && (s = "xmax"),
              e === "ymax" && (s = "ymin"),
              e === "ymin" && (s = "ymax"),
              e === "zmax" && (s = "zmin"),
              e === "zmin" && (s = "zmax");
            let l = io(
                this.settingsViewModel.limitLatex[s] || "",
                this.graphSettings.degreeMode,
              ),
              c = Br.fromObject({ ...a.toObject(), [e]: i, [s]: l });
            if (!c.isValid(this.getAxisScaleSettings())) return;
            n.viewportController.setViewport(c);
            let p;
            switch (e) {
              case "xmin":
              case "xmax":
                p = "x";
                break;
              case "ymin":
              case "ymax":
                p = "y";
                break;
              case "zmin":
              case "zmax":
                p = "z";
                break;
              default:
                let h = e;
                throw new Error(`Invalid limit: ${h}`);
            }
            this.graphSettings.setProperty("lastChangedAxis", p),
              this.markSquareAxesAfterUserEditedViewport();
          }
          break;
      }
      if (n) {
        let a = n.viewportController.getViewport().toObject();
        this._commitUserRequestedViewport(a);
      }
    }
    unmarkLastChangedAxis() {
      this.graphSettings.setProperty("lastChangedAxis", void 0);
    }
    markSquareAxesAfterUserEditedViewport() {
      let e = this.getGrapher();
      if (!e) return;
      let t = e.viewportController.getViewport(),
        o = this.isThreeDMode() ? t.isSquare3D() : t.isSquare(
          e.getProjection().screen,
          this.getAxisScaleSettings(),
        );
      this.graphSettings.setProperty("squareAxes", o);
    }
    getLockViewportConfigSetting() {
      return this.graphSettings.config.lockViewport;
    }
    getLockViewportUserSetting() {
      return this.graphSettings.userLockedViewport;
    }
    canUserAddExpressions() {
      return !!this.graphSettings.config.expressions;
    }
    areNotesEnabled() {
      return !!this.graphSettings.config.notes;
    }
    areSlidersEnabled() {
      return !!this.graphSettings.config.sliders;
    }
    areLinksEnabled() {
      return !!this.graphSettings.config.links;
    }
    areImagesEnabled() {
      let e = window.FileReader,
        t = tl && yg && yg[0] === 8 && yg[1] === 0 && yg[2] === 0;
      return !!(this.graphSettings.config.images && e && !t &&
        !this.is3dProduct());
    }
    areFoldersEnabled() {
      return !!this.graphSettings.config.folders;
    }
    isDecimalToFractionEnabled() {
      return !!this.graphSettings.config.decimalToFraction;
    }
    isTraceEnabled() {
      return !!this.graphSettings.config.trace;
    }
    areFunctionsRestricted() {
      return !!this.graphSettings.config.restrictedFunctions;
    }
    areGeometryFunctionsForceEnabled() {
      return !!this.graphSettings.config.forceEnableGeometryFunctions;
    }
    isQwertyKeyboardEnabled() {
      return !!this.graphSettings.config.qwertyKeyboard;
    }
    isZoomFitEnabled() {
      return !!this.graphSettings.config.zoomFit;
    }
    canEditOnWeb() {
      return !!this.graphSettings.config.editOnWeb;
    }
    hasTransparentBackground() {
      return !!this.graphSettings.config.transparentBackground;
    }
    shouldAudioTraceReverseExpressions() {
      return !!this.graphSettings.config.audioTraceReverseExpressions;
    }
    hasDefaultState() {
      return !!this.graphSettings.defaultState;
    }
    getDefaultViewport() {
      var t;
      let e = this.graphSettings.defaultState;
      return e && e.graph
        ? e.graph.viewport
        : (t = this.getGrapher()) == null
        ? void 0
        : t.getDefaultViewport();
    }
    getColors() {
      return this.isThreeDMode()
        ? __dcg_shared_module_exports__["Sd"]
        : this.graphSettings.config.colors;
    }
    getImageOpacities() {
      return ["0.2", "0.4", "0.6", "0.8", "1"];
    }
    getUIDragModes() {
      return ["X", "Y", "XY"];
    }
    getNumberOfItemsInFolder(e) {
      return P4(this.listModel, e);
    }
    getEnabledDragModesForItem(e) {
      let t = this.getItemModel(e);
      if (!t || t.type !== "expression") return [];
      let o = t.formula, i = [];
      if (!o.move_strategy) return i;
      let n = o.move_strategy[0].type !== "none",
        a = o.move_strategy[1].type !== "none",
        s = n && a;
      return n && i.push("X"), a && i.push("Y"), s && i.push("XY"), i;
    }
    shouldShowEvaluationForItem(e) {
      let t = this.getItemModel(e);
      return !t || t.type !== "expression" ? false : lL(t);
    }
    shouldShowCDFEvaluationForItem(e) {
      let t = this.getItemModel(e);
      return !t || t.type !== "expression" ? false : JE(t);
    }
    getEvaluationValueForItem(e) {
      let t = this.getItemModel(e);
      return t ? t.type !== "expression" ? NaN : cL(t) : NaN;
    }
    getEvaluationValueTypeForItem(e) {
      var o;
      let t = this.getItemModel(e);
      if (t && t.type === "expression") {
        return (o = t.formula.typed_constant_value) == null
          ? void 0
          : o.valueType;
      }
    }
    canDisplayEvaluationForItemAsFraction(e) {
      if (!this.isDecimalToFractionEnabled()) return false;
      let t = this.getItemModel(e);
      if (!t || t.type !== "expression" || qw(t)) return false;
      let o = this.getEvaluationValueForItem(e);
      return typeof o != "number"
        ? false
        : __dcg_shared_module_exports__["canDisplayAsFraction"](o);
    }
    shouldEvaluationForItemDisplayAsFraction(e) {
      if (!this.isDecimalToFractionEnabled()) return false;
      let t = this.getItemModel(e);
      return !t || t.type !== "expression" ? false : Hu(t);
    }
    getEvaluationLabelOptionsForItem(e) {
      return {
        ...__dcg_shared_module_exports__["DEFAULT_EVALUATION_LABEL_OPTIONS"],
        displayAsFraction: this.shouldEvaluationForItemDisplayAsFraction(
          e,
        ),
      };
    }
    isInEditListMode() {
      return this.layoutModel.inEditListMode;
    }
    authorFeaturesAvailable() {
      return !!this.graphSettings.config.authorFeatures;
    }
    shouldShowAuthorFeatures() {
      return this.authorFeaturesAvailable() &&
        !!this.graphSettings.config.authorMode;
    }
    shouldIgnoreGraphInteractions(e) {
      return this.shouldShowAuthorFeatures() ? false : Ds(e);
    }
    toolWillBeHiddenOrDisabled(e) {
      return this.shouldShowAuthorFeatures() &&
        (!this.isGeoToolVisible(e, { ignoreAuthorMode: true }) ||
          !this.isGeoToolEnabled(e, { ignoreAuthorMode: true }));
    }
    setAuthorMode(e) {
      this.graphSettings.config.setProperty("authorMode", e);
    }
    getInvertedColors() {
      return !!this.graphSettings.config.invertedColors;
    }
    invertSwatches() {
      return this.isThreeDMode() && this.getInvertedColors();
    }
    canUseAdvancedStyling() {
      return this.graphSettings.config.advancedStyling;
    }
    getDegreeMode() {
      return this.graphSettings.degreeMode;
    }
    isThreeDMode() {
      return this.graphSettings.threeDMode;
    }
    showPlane3D() {
      let { threeDMode: e, showAxis3D: t, showPlane3D: o } = this.graphSettings;
      return e && t && o;
    }
    showNumbers3D() {
      let { threeDMode: e, showAxis3D: t, showNumbers3D: o } =
        this.graphSettings;
      return e && t && o;
    }
    getTranslucentSurfaces() {
      return !!this.graphSettings.config.translucentSurfaces;
    }
    getPerspectiveDistortion() {
      let e = this.graphSettings.config.perspectiveDistortion;
      return isNaN(e)
        ? 1
        : e < 1e-4
        ? 0
        : __dcg_shared_module_exports__["clamp"](e, 0, f0);
    }
    isBeta3DMode() {
      return this.isThreeDMode() && this.getGraphSettings().config.beta3d;
    }
    areLogModeRegressionsForced() {
      return this.graphSettings.config.forceLogModeRegressions;
    }
    areLogModeRegressionsDefault() {
      return this.graphSettings.config.defaultLogModeRegressions;
    }
    setAllRegressionsToLogMode() {
      for (let e of this.getAllItemModels()) {
        e.type === "expression" && e.formula && e.formula.is_regression &&
          yL(e, true);
      }
    }
    isGraphSettingsOpen() {
      return this.layoutModel.graphSettingsOpen;
    }
    isAddExpressionOpen() {
      return this.layoutModel.addExpressionOpen;
    }
    shouldRenderList() {
      if (this.layoutModel.expressionsVisible) return true;
      let e = this.layoutModel.expressionsHiddenTime;
      return e === void 0 ? false : Date.now() - e <= 500;
    }
    isListVisible() {
      return this.layoutModel.expressionsVisible;
    }
    isGrapherEnabled() {
      return this.graphSettings.config.graphpaper !== false;
    }
    isListEnabled() {
      return this.graphSettings.config.expressions !== false;
    }
    areDistributionsEnabled() {
      return this.graphSettings.config.distributions === true;
    }
    isExpressionListFocused() {
      let e = this.getFocusLocation();
      if (!e) return false;
      switch (e.type) {
        case "settings":
        case "generic-menu":
        case "expression-menu":
        case "editable-label":
        case "geo-token":
        case "multi-select-more-icon":
        case "multi-select-construct-icon":
        case "multi-select-label-icon":
        case "multi-select-style-icon":
        case "geo-header-back-link":
        case "multi-select-show-hide-icon":
        case "new-transformation-number":
        case "label-points-icon":
        case "geo-show-constructions-icon":
        case "geo-basic-tool":
        case "geo-basic-tool-menu-item":
        case "geo-construct-menu-existing-transformations":
        case "regression-output":
        case "stats-output":
        case "graph-paper":
        case "zoom-in-btn":
        case "zoom-restore-btn":
        case "quest":
        case "global-mute-button":
        case "color-picker-option":
        case "multi-select-label-menu-label-input":
          return false;
        case "distribution-param":
        case "cdf-limit":
        case "slider-limit":
        case "domain-limit":
        case "expression":
        case "visualization-prop":
        case "search-expressions":
        case "replace-expressions":
        case "ticker":
        case "table":
        case "image":
        case "readonly-expression":
        case "add-table-regression-btn":
        case "table-regression-delete-btn":
        case "table-regression-type-dropdown":
        case "table-container":
        case "text":
        case "folder":
        case "add-item-btn":
        case "add-expression-btn":
        case "add-note-btn":
        case "add-table-btn":
        case "add-folder-btn":
        case "add-ticker-btn":
        case "add-image-btn":
        case "change-image-btn":
        case "edit-list-toggle":
        case "expression-icon":
        case "expression-evaluation":
        case "image-icon":
        case "slider-icon":
        case "slider-animation-properties-icon":
        case "slider-thumb":
        case "table-icon":
        case "table-regression-icon":
        case "action-icon":
        case "hide-expression-list-btn":
        case "show-expression-list-btn":
        case "top-level-icon":
          return true;
        default:
          return e;
      }
    }
    needsFakeKeypad() {
      if (this.inAudioTraceMode() && this.isKeypadEnabled()) return true;
      let e = this.getFocusLocation();
      if (!e || this.getBrailleMode() !== "none" && os()) return false;
      switch (e.type) {
        case "settings":
          return rj(e.location);
        case "new-transformation-number":
        case "distribution-param":
        case "cdf-limit":
        case "slider-limit":
        case "domain-limit":
        case "expression":
        case "visualization-prop":
        case "search-expressions":
        case "replace-expressions":
        case "ticker":
          return true;
        case "expression-menu":
          return e.location === "opacity" || e.location === "linewidth" ||
            e.location === "lineopacity" ||
            e.location === "pointopacity" || e.location === "pointsize" ||
            e.location === "labelsize" || e.location === "labelangle" ||
            e.location === "updaterule";
        case "table": {
          if (this.isInEditListMode()) return false;
          let o = e.location;
          if (o.row === 0) return true;
          let i = this.getItemModel(e.id);
          if (!i || i.type !== "table") return false;
          let n = i.columnModels[o.column];
          return n ? !Uf(n) : false;
        }
        case "image":
          return e.location !== "name";
        case "readonly-expression":
        case "add-table-regression-btn":
        case "table-regression-delete-btn":
        case "table-regression-type-dropdown":
        case "regression-output":
        case "stats-output":
        case "graph-paper":
        case "table-container":
        case "text":
        case "folder":
        case "add-item-btn":
        case "add-expression-btn":
        case "add-note-btn":
        case "add-table-btn":
        case "add-folder-btn":
        case "add-ticker-btn":
        case "add-image-btn":
        case "change-image-btn":
        case "edit-list-toggle":
        case "hide-expression-list-btn":
        case "show-expression-list-btn":
        case "geo-token":
        case "multi-select-more-icon":
        case "multi-select-construct-icon":
        case "multi-select-label-icon":
        case "multi-select-style-icon":
        case "geo-header-back-link":
        case "multi-select-show-hide-icon":
        case "label-points-icon":
        case "geo-show-constructions-icon":
        case "geo-basic-tool":
        case "geo-basic-tool-menu-item":
        case "geo-construct-menu-existing-transformations":
        case "generic-menu":
        case "zoom-in-btn":
        case "zoom-restore-btn":
        case "quest":
        case "global-mute-button":
        case "color-picker-option":
        case "multi-select-label-menu-label-input":
          return false;
        case "expression-icon":
        case "expression-evaluation":
        case "image-icon":
        case "slider-icon":
        case "action-icon":
        case "slider-animation-properties-icon":
        case "slider-thumb":
        case "table-icon":
        case "table-regression-icon":
        case "top-level-icon":
          return false;
        case "editable-label":
          return this.getItemEditableLabelMode(e.id) === "MATH";
        default:
          return e;
      }
    }
    isIdentifierRenameValid(e) {
      return ya(e) ? !B4(this.listModel, e) : false;
    }
    getBrandingMode() {
      return this.getEditLink()
        ? "static-edit-link"
        : this.getGraphSettings().config.editOnWeb
        ? "edit-link"
        : "powered-by";
    }
    getEditLink() {
      return window.iframeEmbedBrandingLink;
    }
    _expressionZoomFit(e, t) {
      let o = this.getItemModel(e);
      if (
        this.isThreeDMode() || !this.grapher2d ||
        !this.isZoomFitEnabled() || !o ||
        o.type !== "expression" && o.type !== "table" ||
        (!o.boundingBoxes || !o.boundingBoxes.length) && !t.justResiduals
      ) return false;
      let i = this.grapher2d.viewportController;
      if (!("zoomCustom" in i)) return false;
      let n = o.boundingBoxes;
      if (t.justResiduals) {
        let s = this.getBoundingBoxForResidualsZoomFit(o);
        s !== void 0 && (n = s);
      }
      if (n === void 0) return false;
      let a = c1(n, i.getProjection());
      return a
        ? (t.synchronous ? i.setViewport(Br.fromObject(a)) : i.zoomCustom(a),
          t.focusAfterTap && qr(this, { type: "zoom-restore-btn" }),
          true)
        : false;
    }
    _deleteItemAndAnimateOut(e, t) {
      let i = this.getItemNodeById(e);
      i &&
        (Wn(i, {
          transition: .2 + "s",
          opacity: "0",
          transform: "scale(.1, .1)",
        }),
          setTimeout(() => {
            this.dispatch({
              type: "finish-deleting-item-after-animation",
              id: e,
              setFocusAfterDelete: t,
            });
          }, 1e3 * .2));
    }
    _finishDeletingItemAfterAnimation(e, t) {
      let o = this.getItemModel(e);
      if (!o) return;
      let i = this.getItemNodeById(e),
        n = i && document.activeElement &&
          i.contains(document.activeElement),
        a = Ew(this.listModel, o.index);
      if (this._removeExpressionSynchronously(o), !(!t || !n)) {
        if (!a) {
          let s = eb(this.listModel);
          s && (a = s);
        }
        a && bi(this, a.id, "end");
      }
    }
    _removeExpressionSynchronously(e) {
      var o;
      if (e.type === "expression") {
        let i = (o = e.formula.regression) == null
          ? void 0
          : o.residualVariable;
        if (i) {
          for (let n of this.getAllItemModels()) {
            if (n.type === "table") {
              let a = n.columnModels.findIndex((s) => s.latex === i);
              if (a >= 0) {
                mw(n, a);
                break;
              }
            }
          }
        }
      }
      let t = ib(this.listModel, e.index);
      this.trackActionForPotentialEvaluatorRestart("remove", e.id),
        t.forEach((i) =>
          this.trackActionForPotentialEvaluatorRestart("remove", i.id)
        ),
        this.garbageCollectGeo(t, {}),
        this.ensureAtLeastOneVisibleItem();
    }
    setRootElt(e) {
      this.rootElt = e, this.dragdrop_expressions = new O0(this);
    }
    getRootElt() {
      return this.rootElt;
    }
    _hideExpressions(e) {
      this.graphSettings.config.expressions &&
        (Nr(this.listModel, void 0),
          this.layoutModel = {
            ...this.layoutModel,
            expressionsVisible: false,
            expressionsHiddenTime: Date.now(),
          },
          e ? qr(this, { type: "show-expression-list-btn" }) : Jr());
    }
    _showExpressions(e) {
      this.graphSettings.config.expressions &&
        (this.layoutModel = {
          ...this.layoutModel,
          expressionsVisible: true,
        },
          e ? qr(this, { type: "hide-expression-list-btn" }) : Jr());
    }
    _showToast(e) {
      this.toastData = e, clearTimeout(this._hideToastTimeout);
      let t = typeof e.hideAfter == "number" ? e.hideAfter : 6e3;
      t > 0 && (this._hideToastTimeout = setTimeout(() => {
        this.dispatch({
          type: "toast/close",
          onHide: this.toastData.onHide,
        });
      }, t));
    }
    _setExpressionPropertiesFromAPI(e, t) {
      let o = this.getItemModel(e);
      if (o) {
        if (o.type === "table" && t.columns) {
          t = __dcg_shared_module_exports__["Jc"](t);
          let i = cz(o, t), n = Qf(this.listModel, i);
          this._toplevelReplaceItemAt(o.index, n, false);
        } else if (o.type === "text") {
          let i = this.getItemModel(e);
          if (!i) return;
          for (let n in t) {
            if (t.hasOwnProperty(n)) {
              switch (n) {
                case "text":
                  XG(i, t.text);
                  break;
                case "secret":
                  fE(i, t.secret);
                  break;
                case "readonly":
                  yw(i, t.readonly);
                  break;
              }
            }
          }
        } else {
          let i = this.getItemModel(e);
          if (!i) return;
          for (let n in t) {
            if (t.hasOwnProperty(n)) {
              switch (n) {
                case "slider":
                  {
                    if (i.type !== "expression") continue;
                    let a = t[n];
                    a.hasOwnProperty("min") && sb(i, a.min),
                      a.hasOwnProperty("max") && lb(i, a.max),
                      a.hasOwnProperty("step") && Gw(i, a.step),
                      a.hasOwnProperty("isPlaying") && As(i, a.isPlaying);
                  }
                  break;
                case "polarDomain":
                  {
                    if (i.type !== "expression") continue;
                    Ka(
                      i,
                      __dcg_shared_module_exports__["be"](
                        t.polarDomain.min,
                      ),
                      "theta",
                    ),
                      Wa(
                        i,
                        __dcg_shared_module_exports__["be"](
                          t.polarDomain.max,
                        ),
                        "theta",
                      );
                  }
                  break;
                case "parametricDomain":
                  {
                    if (i.type !== "expression") continue;
                    Ka(
                      i,
                      __dcg_shared_module_exports__["be"](
                        t.parametricDomain.min,
                      ),
                      "t",
                    ),
                      Wa(
                        i,
                        __dcg_shared_module_exports__["be"](
                          t.parametricDomain.max,
                        ),
                        "t",
                      );
                  }
                  break;
                case "parametricDomain3Du":
                  {
                    if (i.type !== "expression") continue;
                    Ka(
                      i,
                      __dcg_shared_module_exports__["be"](
                        t.parametricDomain3Du.min,
                      ),
                      "u",
                    ),
                      Wa(
                        i,
                        __dcg_shared_module_exports__["be"](
                          t.parametricDomain3Du.max,
                        ),
                        "u",
                      );
                  }
                  break;
                case "parametricDomain3Dv":
                  {
                    if (i.type !== "expression") continue;
                    Ka(
                      i,
                      __dcg_shared_module_exports__["be"](
                        t.parametricDomain3Dv.min,
                      ),
                      "v",
                    ),
                      Wa(
                        i,
                        __dcg_shared_module_exports__["be"](
                          t.parametricDomain3Dv.max,
                        ),
                        "v",
                      );
                  }
                  break;
                case "parametricDomain3Dr":
                  {
                    if (i.type !== "expression") continue;
                    Ka(
                      i,
                      __dcg_shared_module_exports__["be"](
                        t.parametricDomain3Dr.min,
                      ),
                      "r",
                    ),
                      Wa(
                        i,
                        __dcg_shared_module_exports__["be"](
                          t.parametricDomain3Dr.max,
                        ),
                        "r",
                      );
                  }
                  break;
                case "parametricDomain3Dphi":
                  {
                    if (i.type !== "expression") continue;
                    Ka(
                      i,
                      __dcg_shared_module_exports__["be"](
                        t.parametricDomain3Dphi.min,
                      ),
                      "phi",
                    ),
                      Wa(
                        i,
                        __dcg_shared_module_exports__["be"](
                          t.parametricDomain3Dphi.max,
                        ),
                        "phi",
                      );
                  }
                  break;
                case "hidden":
                  this._setItemHidden(e, t.hidden);
                  break;
                case "secret":
                  fE(i, t.secret);
                  break;
                case "readonly":
                  yw(i, t.readonly);
                  break;
                case "color":
                  {
                    if (i.type !== "expression") continue;
                    iT(i, t.color);
                  }
                  break;
                case "dragMode":
                  {
                    if (i.type !== "expression") continue;
                    Mg(i, t.dragMode);
                  }
                  break;
                case "label":
                  {
                    if (i.type !== "expression") continue;
                    yd(i, t.label);
                  }
                  break;
                case "showLabel":
                  {
                    if (i.type !== "expression") continue;
                    Ku(i, t.showLabel);
                  }
                  break;
                case "labelSize":
                  {
                    if (i.type !== "expression") continue;
                    Fw(i, t.labelSize);
                  }
                  break;
                case "labelOrientation":
                  {
                    if (i.type !== "expression") continue;
                    SL(i, t.labelOrientation);
                  }
                  break;
                case "latex":
                  if (i.type !== "expression") continue;
                  $a(i, t.latex);
                  break;
                case "points":
                  if (i.type !== "expression") continue;
                  wL(i, !!t.points);
                  break;
                case "lines":
                  if (i.type !== "expression") continue;
                  CL(i, !!t.lines);
                  break;
                case "pointStyle":
                  if (i.type !== "expression") continue;
                  vL(i, t.pointStyle);
                  break;
                case "pointSize":
                case "movablePointSize":
                  if (i.type !== "expression") continue;
                  Ow(i, t.pointSize);
                  break;
                case "pointOpacity":
                  if (i.type !== "expression") continue;
                  Vw(i, t.pointOpacity);
                  break;
                case "lineStyle":
                  if (i.type !== "expression") continue;
                  nT(i, t.lineStyle);
                  break;
                case "lineWidth":
                  if (i.type !== "expression") continue;
                  db(i, t.lineWidth);
                  break;
                case "lineOpacity":
                  if (i.type !== "expression") continue;
                  cb(i, t.lineOpacity);
                  break;
                case "fill":
                  if (i.type !== "expression") continue;
                  xL(i, t.fill);
                  break;
                case "fillOpacity":
                  if (i.type !== "expression") continue;
                  Lw(i, t.fillOpacity);
                  break;
                case "surfaceOpacity":
                  if (i.type !== "expression") continue;
                  Pw(i, t.surfaceOpacity);
                  break;
                case "id":
                case "type":
                case "domain":
                  break;
                default:
                  throw new Error("trying to call setProperty for: " + n);
              }
            }
          }
        }
      }
    }
    _isParentFolderHidden(e) {
      let t = this.getItemModel(e);
      if (!t) return false;
      let o = Ca(t);
      return o ? o.hidden : false;
    }
    _toggleItemHidden(e) {
      var t;
      if (this._isParentFolderHidden(e)) this._setItemHidden(e, false);
      else {
        let o = this.getItemModel(e);
        if (!o) return;
        switch (o.type) {
          case "expression":
            this._setItemHidden(e, !Hi(o));
            break;
          case "image":
          case "folder":
            this._setItemHidden(e, !o.hidden);
            break;
          case "table":
          case "text":
            break;
          default:
            return o;
        }
        Is(o) &&
          (Hi(o) ||
            this.logEvent({
              category: "tone",
              action: Hi(o) ? "mute-local" : "unmute-local",
            }),
            (t = this.toneController) == null || t.recomputeAudio());
      }
    }
    _toggleTableColumnHidden(e, t) {
      if (this._isParentFolderHidden(e)) {
        this._setTableColumnHidden(e, t, false);
      } else {
        let o = this.getItemModel(e);
        if (!o || o.type !== "table") return;
        let i = Eo(o, t);
        if (!i) return;
        this._setTableColumnHidden(e, t, !i.hidden);
      }
    }
    _setTableColumnHidden(e, t, o) {
      let i = this.getItemModel(e);
      if (!i || i.type !== "table") return;
      let n = cE(i, t);
      !o && this._isParentFolderHidden(e) &&
      this._setItemHidden(i.folderId, false),
        yz(i, t, o),
        !o && n && NG(i, t, true);
    }
    _setItemHidden(e, t) {
      let o = this.getItemModel(e);
      if (!o) return;
      !t && o.type !== "folder" && this._isParentFolderHidden(o.id) &&
        this._setItemHidden(o.folderId, false);
      let i;
      switch (o.type) {
        case "expression": {
          i = Hi(o), rH(o, t);
          break;
        }
        case "folder":
          i = Oz(o), Vz(o, t);
          break;
        case "image":
          Qz(o, t);
          break;
        case "table":
        case "text":
          break;
        default:
          return o;
      }
      i !== void 0 && t && !i &&
        (o.type === "expression"
          ? this.trackActionForPotentialEvaluatorRestart("hide", o.id)
          : o.type === "folder" &&
            this.getAllItemModels().filter((n) =>
              n.type === "expression" && n.folderId === o.id
            ).forEach((n) =>
              this.trackActionForPotentialEvaluatorRestart("hide", n.id)
            ));
    }
    _addItemToEndFromAPI(e) {
      let t = PE(this.listModel);
      !e.secret && t && t.type === "expression" && t.latex === "" &&
      ib(this.listModel, t.index), ol(this.listModel, e);
    }
    copyExpressionToIndex(e, t, o) {
      let i = { stripDefaults: false }, n;
      switch (e.type) {
        case "expression":
          n = Mw(e, i);
          break;
        case "table":
          n = Bf(e, i);
          let s = {};
          n.columns && n.columns.forEach((l) => {
            let c = this.generateId();
            s[l.id] = c, l.id = c;
          }),
            n.regression &&
            (n.regression = {
              ...n.regression,
              id: this.generateId(),
              columnIds: {
                x: s[n.regression.columnIds.x],
                y: s[n.regression.columnIds.y],
              },
            });
          break;
        case "image":
          n = DE(e, i);
          break;
        case "text":
          n = AE(e, i);
          break;
        default:
          return;
      }
      let a = this.createItemModel({ ...n, id: this.generateId() });
      this._toplevelInsertItemAt(t, a, false, o || e.folderId);
    }
    _toplevelInsertItemAt(e, t, o, i) {
      let n = t;
      _s(this.listModel, n, e), i && _n(n, i), o && bi(this, n.id);
    }
    _toplevelNewItemAtSelection(e, t) {
      this.setGeoTool("selection");
      let o = this.getSelectedItem();
      if (o) {
        let s = o.type === "expression" && !o.latex;
        if (s && !o.folderId && (e.type !== "expression" || e.latex)) {
          return this._toplevelReplaceItemAt(o.index, e, t.shouldFocus);
        }
        if (
          s && o.folderId && e.type !== "expression" &&
          e.type !== "folder"
        ) return this._toplevelReplaceItemAt(o.index, e, t.shouldFocus);
        if (o.type !== "folder" && !o.folderId) {
          return this._toplevelInsertItemAt(
            o.index + 1,
            e,
            t.shouldFocus,
            void 0,
          );
        }
        if (o.type !== "folder" && o.folderId && e.type !== "folder") {
          return this._toplevelInsertItemAt(
            o.index + 1,
            e,
            t.shouldFocus,
            o.folderId,
          );
        }
        if (o.type === "folder" && !o.collapsed && e.type !== "folder") {
          return this._toplevelInsertItemAt(
            o.index + 1,
            e,
            t.shouldFocus,
            o.id,
          );
        }
      }
      let i = this.getFirstFullyVisibleItem();
      for (
        i && i.type === "folder" &&
        (i = this.getItemModelByIndex(i.index + 1));
        i && i.type !== "folder" && i.folderId;
      ) i = this.getItemModelByIndex(i.index + 1);
      let n = i ? i.index : this.getItemCount();
      return this._toplevelInsertItemAt(n, e, t.shouldFocus, void 0);
    }
    getFirstFullyVisibleItem() {
      let e = jO(this);
      if (e) return bd(this.listModel, e);
    }
    findEl(e) {
      if (this.rootElt) return this.rootElt.querySelector(e) || void 0;
    }
    getExppanelElt() {
      return L0(this);
    }
    scrollItemIntoView(e) {
      if (!this.rootElt || !this.isListVisible()) return;
      let t = this.getItemNodeById(e.id), o = L0(this);
      if (!(!t || !o)) {
        if (e.type === "table") {
          let i = t.querySelector(".dcg-select-dropdown-list");
          if (i) {
            tc(i, o, 60);
            return;
          }
          let n = t.querySelector(".dcg-row .dcg-selected");
          if (n) {
            tc(n, o, 60);
            return;
          }
        }
        tc(t, o, 90);
      }
    }
    scrollSelectedItemIntoView() {
      let e = this.getFirstSelectedItem();
      if (e) {
        if (e && e.type !== "folder" && e.folderId) {
          let t = this.getItemModel(e.folderId);
          t && t.type === "folder" && t.collapsedChildIsSelected &&
            (e = t);
        }
        this.scrollItemIntoView(e);
      }
    }
    _pasteTable(e) {
      let t = this.getGrapher();
      if (!t) return;
      let o = OE(this.listModel),
        i = FG(o, e, this),
        n = this.createItemModel(i);
      this._toplevelNewItemAtSelection(n, { shouldFocus: true }),
        this._closeAddExpression();
      let a = t.getProjection(),
        s = a.viewport,
        l = __dcg_shared_module_exports__["h"](
          e[0],
          (p) => parseFloat(p),
        ),
        c = __dcg_shared_module_exports__["h"](
          e[1],
          (p) => parseFloat(p),
        );
      if (this.is3dProduct()) return;
      let d = {
        xmin: __dcg_shared_module_exports__["o"](l),
        xmax: __dcg_shared_module_exports__["n"](l),
        ymin: __dcg_shared_module_exports__["o"](c),
        ymax: __dcg_shared_module_exports__["n"](c),
        type: "table",
      };
      if (
        isFinite(d.xmin) && isFinite(d.xmax) && isFinite(d.ymin) &&
        isFinite(d.ymax) &&
        (d.xmax > s.xmax || d.xmin < s.xmin || d.ymax > s.ymax ||
          d.ymin < s.ymin)
      ) {
        let p = c1([d], a);
        if (p && !this.viewportIsLocked()) {
          let h = new Br(p.xmin, p.xmax, p.ymin, p.ymax);
          t.viewportController.setViewport(h),
            this._showToast({
              message: this.s(
                "graphing-calculator-text-toast-zoom-to-fit",
              ),
              undoCallback: () => {
                this.dispatch({ type: "undo" });
              },
            }),
            this.markSquareAxesAfterUserEditedViewport();
        }
      }
    }
    _insertSeveralExpressions(e) {
      for (let t = 0; t < e.length; t++) {
        let o = this.createItemModel(e[t]);
        this._toplevelNewItemAtSelection(o, { shouldFocus: true });
      }
    }
    _appendNumberList(e) {
      let t = this.getSelectedItem();
      if (t && t.type === "expression") {
        let o = t.latex,
          i = this.createItemModel({
            type: "expression",
            id: this.generateId(),
            latex: o + e,
          });
        return this._toplevelReplaceItemAt(t.index, i, true);
      }
    }
    _openOnWeb() {
      this.runAfterDispatch(() => {
        let e = this.getGrapher();
        if (!e) return;
        let t = JSON.stringify(this.getState()),
          o = e.screenshot({ width: 100, height: 100 }),
          a = (this.getGraphSettings().config.crossOriginSaveTest
            ? "/"
            : "https://www.desmos.com/") +
            "api/v1/calculator/cross_origin_save",
          s = document.createElement("div");
        aj.mountToNode(rA, s, {
          stateData: () =>
            t,
          thumbData: () => o,
          saveURL: () => a,
        }), this.rootElt.append(s);
        let l = s.querySelector("form[name=open_graph_on_web]");
        ee(l).trigger("submit"), s.remove();
      });
    }
    notifyBugsnagAboutMissingSelectedItem(e, t) {
      let o = Ig(this.listModel), i = "";
      try {
        o
          ? i = JSON.stringify(o.cachedUndoRedoFullState, null, 2)
          : i = "undefined";
      } catch (s) {
        i = "[[could not stringify]]";
      }
      let n = "";
      try {
        if (!o) n = "undefined";
        else {
          let s = {
            id: o.id,
            index: o.index,
            displayIndex: o.index,
            secretIndex: o.secretIndex,
            guid: o.guid,
            renderShell: o.renderShell,
            isHiddenFromUI: o.isHiddenFromUI,
            hasDCGView: !!o.rootViewNode,
            cachedRenderHeight: o.cachedRenderHeight,
          };
          n = JSON.stringify(s, null, 2);
        }
      } catch (s) {
        n = "[[could not stringify]]";
      }
      let a = "";
      try {
        a = JSON.stringify(eL(this.listModel), null, 2);
      } catch (s) {
        a = "[[could not stringify]]";
      }
      So("ReplaceItemAtError: no item at index", {
        metaData: {
          index: e,
          shouldFocus: t,
          selectedModelJSON: n,
          selectedItemJSON: i,
          listStateJSON: a,
        },
      });
    }
    _toplevelReplaceItemAt(e, t, o) {
      let i = t, n = this.getItemModelByIndex(e);
      n || this.notifyBugsnagAboutMissingSelectedItem(e, o);
      let a = n.type !== "folder" && n.folderId;
      ib(this.listModel, e),
        _s(this.listModel, i, e),
        a && _n(i, a),
        o && bi(this, i.id);
    }
    convertImageToDraggable(e) {
      let t = this.getItemModel(e);
      if (!t || t.type !== "image") return;
      let o = t.folderId,
        i = t.index + 1,
        n = t.center,
        a = OE(this.listModel),
        s = __dcg_shared_module_exports__["identifierToLatex"]("C_" + a),
        l = this.createItemModel({
          id: this.generateId(),
          type: "expression",
          latex: s + "=" + n,
          dragMode: "XY",
          hidden: true,
        });
      _s(this.listModel, l, i),
        o && _n(l, o),
        ks(t, "center", s),
        KG(t, true),
        WG(t, true);
    }
    createSlidersForItem(e, t) {
      let o = this.getItemModel(e);
      if (!o) return;
      let i = o.type !== "folder" && o.folderId;
      return this.createSliders({
        model: o,
        folderId: i,
        index: o.index + 1,
      }, t);
    }
    createSlidersForTicker(e) {
      return this.createSliders({
        model: this.listModel.ticker,
        folderId: false,
        index: 0,
        doNotChangeFocus: true,
      }, e);
    }
    createSliders(
      { model: e, folderId: t, index: o, doNotChangeFocus: i },
      n,
    ) {
      let a = [];
      e.type === "ticker"
        ? ME(e, (p, h) => {
          a.push({ latex: p, location: h });
        })
        : Jf(e, (p, h) => {
          a.push({ latex: p, location: h.location });
        });
      let s = K$(a, n, { degreeMode: this.graphSettings.degreeMode }),
        l = e.formula ? e.formula.action_value : void 0,
        c = n.map((p) => {
          let h = s[p], u = "1";
          h && h.value !== void 0 && (u = h.value);
          let f, y = __dcg_shared_module_exports__["latexToIdentifier"](p);
          p === ""
            ? f = ""
            : l && l.hasOwnProperty(y)
            ? f = l[y]
            : f = p + "=" + u;
          let C = {
            type: "expression",
            id: this.generateId(),
            latex: f,
            color: this.getNextColor(),
            hidden: !!f,
          };
          return h &&
            (h.min !== void 0 &&
              (C.slider || (C.slider = {}),
                C.slider.hardMin = true,
                C.slider.min = h.min),
              h.max !== void 0 &&
              (C.slider || (C.slider = {}),
                C.slider.hardMax = true,
                C.slider.max = h.max),
              h.step !== void 0 &&
              (C.slider || (C.slider = {}), C.slider.step = h.step)),
            C;
        });
      for (let p = c.length - 1; p >= 0; p--) {
        let h = this.createItemModel(c[p]);
        _s(this.listModel, h, o), t && _n(h, t);
      }
      if (i) return;
      let d = c[c.length - 1];
      d.latex === "" ? bi(this, d.id) : qr(this, void 0);
    }
    _uploadImagesAndWaitForThemToLoad(e) {
      let { files: t, id: o } = e;
      if (!t || t.length === 0) {
        this._showToast({
          message: this.s(
            "graphing-calculator-text-toast-no-file-selected",
          ),
        });
        return;
      }
      if (o && t.length > 1) {
        this._showToast({
          message: this.s(
            "graphing-calculator-text-toast-choose-one-file",
          ),
        });
        return;
      }
      let i = d4({ controller: this, files: t, id: o }), n = i.errors[0];
      n && this._showToast({ message: n });
      for (let a of i.tokens) this.__pendingImageUploads[a] = true;
      this.isUploadingImages() &&
        this._showToast({
          message: this.s(
            "graphing-calculator-text-toast-uploading-images",
          ),
          onHide: () => {
            this._clearPendingImageUploads();
          },
        });
    }
    getImageToRetry() {
      let e;
      for (let t of this.getAllItemModels()) {
        t.type === "image" && t.loadStatus === "failed" &&
          (!e || e.failures > t.failures) && (e = t);
      }
      return e;
    }
    retryLoadingFailedImage(e) {
      let t = Date.now(),
        o = t - this.imageRetryState.lastAttemptTime,
        i = 1e3 * Math.pow(2, this.imageRetryState.attempts);
      this.imageRetryState.attempts > 0 && o < i ||
        (jG(e),
          this.imageRetryState = {
            lastAttemptTime: t,
            attempts: this.imageRetryState.attempts + 1,
          });
    }
    getSelectedItem() {
      return Ig(this.listModel);
    }
    getFirstSelectedItem() {
      let e = this.getAllSelectedItems(), t = e[0];
      if (t) {
        for (let o = 1; o < e.length; o++) {
          let i = e[o];
          i.index < t.index && (t = i);
        }
        return t;
      }
    }
    getAllSelectedItems() {
      return FE(this.listModel);
    }
    getOpenItemMenu() {
      return this.listModel.openItemMenu;
    }
    isItemSettingsMenuOpen(e) {
      let t = this.listModel.openItemMenu;
      return t ? t.guid === e : false;
    }
    closeItemSettingsMenu() {
      let e = this.getOpenItemMenu();
      e !== void 0 &&
        (e.focusFirstOption &&
          (e.previousFocusLocation !== void 0
            ? qr(this, e.previousFocusLocation)
            : this.focusOpenMenuIcon()),
          this.listModel.openItemMenu = void 0);
    }
    focusOpenMenuIcon() {
      let e = this.getOpenItemMenu();
      e &&
        (e.type === "slider"
          ? this.dispatch({
            type: "set-focus-location",
            location: {
              type: "slider-animation-properties-icon",
              id: e.model.id,
            },
          })
          : e.type === "image"
          ? this.dispatch({
            type: "set-focus-location",
            location: { type: "image-icon", id: e.model.id },
          })
          : e.type === "table-column"
          ? this.dispatch({
            type: "set-focus-location",
            location: {
              type: "table-icon",
              id: e.model.table.id,
              columnId: e.model.id,
            },
          })
          : e.type === "table-regression"
          ? this.dispatch({
            type: "set-focus-location",
            location: { type: "table-regression-icon", id: e.model.id },
          })
          : e.type === "geo-tool-dropdown"
          ? this.dispatch({
            type: "set-focus-location",
            location: { type: "geo-basic-tool", tool: e.tools[0] },
          })
          : e.type === "multi-select-more"
          ? this.dispatch({
            type: "set-focus-location",
            location: { type: "multi-select-more-icon" },
          })
          : e.type === "multi-select-construct"
          ? this.dispatch({
            type: "set-focus-location",
            location: { type: "multi-select-construct-icon" },
          })
          : e.type === "multi-select-style"
          ? this.dispatch({
            type: "set-focus-location",
            location: { type: "multi-select-style-icon" },
          })
          : e.type === "multi-select-label"
          ? this.dispatch({
            type: "set-focus-location",
            location: { type: "multi-select-label-icon" },
          })
          : this.dispatch({
            type: "set-focus-location",
            location: { type: "expression-icon", id: e.model.id },
          }));
    }
    getFocusedItem() {
      return N$(this);
    }
    getFocusLocation() {
      return this.focusLocation;
    }
    isFocusLocationFocused(e) {
      let t = this.focusLocation, o = e;
      return !t || !o ? false : __dcg_shared_module_exports__["E"](t, o);
    }
    isCurrentFocusLocationValid() {
      var i;
      let e = this.focusLocation;
      if (!e) return true;
      if (e.type === "settings") {
        return e.location === "icon" || this.isGraphSettingsOpen();
      }
      if (
        e.type === "add-item-btn" || e.type === "edit-list-toggle" ||
        e.type === "hide-expression-list-btn" ||
        e.type === "show-expression-list-btn"
      ) return this.isListEnabled();
      if (e.type === "add-expression-btn" || e.type === "add-table-btn") {
        return this.layoutModel.addExpressionOpen;
      }
      if (e.type === "add-note-btn") {
        return this.layoutModel.addExpressionOpen &&
          this.areNotesEnabled();
      }
      if (e.type === "add-folder-btn") {
        return this.layoutModel.addExpressionOpen &&
          this.areFoldersEnabled();
      }
      if (e.type === "add-ticker-btn") {
        return this.layoutModel.addExpressionOpen &&
          this.areActionsEnabled();
      }
      if (e.type === "add-image-btn") {
        return this.layoutModel.addExpressionOpen &&
          this.areImagesEnabled();
      }
      if (e.type === "zoom-in-btn" || e.type === "zoom-restore-btn") {
        return true;
      }
      if (
        e.type === "search-expressions" ||
        e.type === "replace-expressions"
      ) return this.expressionSearchOpen;
      if (e.type === "ticker") return this.listModel.ticker.open;
      if (e.type === "generic-menu") return !!this.getOpenItemMenu();
      if (e.type === "graph-paper") {
        let n = this.getGrapher();
        return !!(n && n.getIsVisible() && n.settings.config.graphpaper);
      }
      if (
        e.type === "geo-show-constructions-icon" ||
        e.type === "geo-token" || e.type === "multi-select-more-icon" ||
        e.type === "multi-select-construct-icon" ||
        e.type === "multi-select-style-icon" ||
        e.type === "multi-select-label-icon" ||
        e.type === "label-points-icon"
      ) return this.isGeoUIActive();
      if (e.type === "new-transformation-number") {
        let n = this.getGeoModel(),
          a = n.getCurrentTool(),
          s = n.getNonObjectsState().ui.currentTool.inputIndex,
          l = a.getSpec && a.getSpec();
        return !!l && !!l.inputs[s] && !!l.inputs[s].numberInputInfo;
      }
      if (
        e.type === "geo-header-back-link" ||
        e.type === "multi-select-show-hide-icon"
      ) return this.isGeoUIActive() && this.hasAnyItemsSelected();
      if (e.type === "geo-basic-tool") {
        return this.isGeoUIActive() && e.tool !== "expression-edit";
      }
      if (e.type === "regression-output") {
        return !!this.getItemModel(e.id) && e.parameter !== "";
      }
      if (e.type === "stats-output") {
        let n = this.getItemModel(e.id);
        return !!(n && n.type === "expression" && uT(n) &&
          e.parameter !== "");
      }
      if (e.type === "quest") return this.getQuestIsActive();
      let t = this.getOpenItemMenu();
      if (e.type === "geo-basic-tool-menu-item") {
        return this.isGeoUIActive() && e.tool !== "" && t !== void 0 &&
          (t.type === "geo-tool-dropdown" ||
            t.type === "multi-select-construct");
      }
      if (e.type === "geo-construct-menu-existing-transformations") {
        return this.isGeoUIActive() &&
          (t == null ? void 0 : t.type) === "multi-select-construct";
      }
      if (e.type === "multi-select-label-menu-label-input") {
        return this.isGeoUIActive() && this.hasAnyItemsSelected() &&
          (t == null ? void 0 : t.type) === "multi-select-label";
      }
      if (e.type === "global-mute-button") {
        return !!((i = this.toneController) != null &&
          i.someExpressionsShouldPlayTones());
      }
      if (e.type === "color-picker-option") return true;
      let o;
      if (
        t && t.type === "table-column"
          ? o = t.model.table
          : o = this.getItemModel(e.id), !o
      ) return false;
      if (e.type === "change-image-btn") {
        return this.listModel && o.type === "image" &&
          this.areImagesEnabled();
      }
      if (e.type === "expression-menu") {
        let n = this.getOpenItemMenu();
        if (
          !n ||
          (n.type === "expression" || n.type === "image" ||
              n.type === "table-column") && n.model.id !== e.id
        ) return false;
        if (
          e.location === "start" || e.location === "end" ||
          e.location === "updaterule" || e.location === "anywhere" ||
          o.type === "table"
        ) return true;
        if (o.type !== "expression") return false;
        let { points: a, lines: s, fill: l } = o;
        wd(o) && (l = true);
        let c = __dcg_shared_module_exports__["Zc"](
          o.formula.expression_type,
          { points: a, lines: s, fill: l },
          (d) => {
            So("getReconciledExpressionProps [Chrome Switch Bug]", {
              metaData: {
                method: "isCurrentFocusLocationValid",
                type: d,
              },
            });
          },
        );
        return !(!c.fill && !c.points && !c.lines && !o.showLabel);
      }
      if (e.type === "add-table-regression-btn") {
        return this.areTableRegressionsEnabled() && o.type === "table" &&
          !o.regression;
      }
      if (
        e.type === "table-regression-delete-btn" ||
        e.type === "table-regression-type-dropdown"
      ) {
        return this.areTableRegressionsEnabled() && o.type === "table" &&
          !!o.regression;
      }
      if (!this.isItemSelected(e.id) && e.type !== "editable-label") {
        return false;
      }
      switch (e.type) {
        case "domain-limit":
          return !(o.type !== "expression" || !Wu(o) && !Dp(o));
        case "expression-icon":
        case "top-level-icon":
          return true;
        case "expression-evaluation":
          return this.shouldShowEvaluationForItem(o.id) ||
            this.shouldShowCDFEvaluationForItem(o.id);
        case "image-icon":
          return o.type === "image" && o.loadStatus !== "loading" &&
            o.loadStatus !== "failed" && !o.error;
        case "action-icon":
          return !(o.type !== "expression" || !vb(o));
        case "slider-icon":
        case "slider-animation-properties-icon":
        case "slider-thumb":
        case "slider-limit":
          return !(o.type !== "expression" || !nH(o));
        case "table-icon":
          return o.type === "table" &&
            this.getGraphSettings().config.graphpaper;
        case "table-regression-icon":
          return this.areTableRegressionsEnabled() &&
            o.type === "table" && !!o.regression;
        case "visualization-prop":
          return !(o.type !== "expression" || !pT(o));
        case "distribution-param":
          if (o.type !== "expression") return false;
          let n = sl(o);
          return n ? e.location in n.values : false;
        case "cdf-limit":
          return o.type !== "expression" ? false : vd(o);
        case "image":
          return o.type === "image";
        case "folder":
          return o.type === "folder";
        case "text":
          return o.type === "text";
        case "expression":
          return !(o.type !== "expression" || this.isInEditListMode() ||
            e.isFakeGraphFocus && !this.getValidCursorContext());
        case "readonly-expression":
          return this.isItemReadonly(o.id) ||
            o.type === "expression" && this.isInEditListMode();
        case "table":
          return o.type !== "table" ? false : Cz(o, e.location);
        case "table-container":
          return o.type === "table" && this.isInEditListMode();
        case "editable-label":
          return o.type !== "expression" ? false : xb(o);
        default:
          return e;
      }
    }
    shouldAllowMovingPointsWithKeyboard() {
      let e = this.getActiveTool();
      return e === "selection" || e === "box-selection";
    }
    isDragDropActive() {
      return !!this.listModel.dragState;
    }
    isItemBeingDragged(e) {
      let t = this.listModel.dragState;
      return !(!t || t.firstItemId !== e);
    }
    shouldRenderDraggedItemAsToken() {
      let e = this.listModel.dragState;
      return e ? e.renderType === "token" : false;
    }
    canDraggedItemBeMovedIntoTokenPane() {
      var i, n, a;
      let e = this.getDraggedItemId();
      if (!e) return false;
      let t = this.getItemModel(e);
      if (
        !t || t.type !== "expression" || this.isItemMarkedReadonly(t.id)
      ) return false;
      let o = (i = t.formula.geometry) == null ? void 0 : i.valueType;
      return o === void 0 ||
          (n = t.formula.geometry) != null && n.unconstructable ||
          t.formula.recursion_base_case ||
          t.formula.function_definition &&
            !__dcg_shared_module_exports__["isTypeOrListOfType"](
              o,
              __dcg_shared_module_exports__["Transformation"],
            )
        ? false
        : !!((a = t.formula.geometry) != null && a.parentDependencies);
    }
    getDraggedItemId() {
      let e = this.listModel.dragState;
      return e && e.firstItemId;
    }
    getDraggedIdentifier() {
      var o;
      let e = this.getRawDragState();
      if (!e) return;
      let t = this.getItemModel(e.dragTarget.calcId);
      if (!(!t || t.type !== "expression")) {
        return (o = pi(t)) == null ? void 0 : o.identifier;
      }
    }
    getRawDragState() {
      return this.listModel.dragState;
    }
    initStateStack() {
      this.stateStack = new su(),
        this.stateStack.addState({
          diffState: this.getUndoRedoDiffState(),
          fullState: this.getUndoRedoFullState(),
        });
    }
    getUndoRedoDiffState() {
      var e;
      return {
        randomSeed: this.getRandomSeed(),
        includeFunctionParametersInRandomSeed: this
          .getIncludeFunctionParametersInRandomSeed(),
        layoutModel: this.layoutModel,
        settingsViewModel: this.settingsViewModel,
        graph: (e = this.getGrapher()) == null
          ? void 0
          : e.getUndoRedoDiffState(),
        expressions: rq(this.listModel),
        geometryToolbar: zG(this.geometryToolbarModel),
        wasCompleteSetState: this.isCurrentlyDoingSetState,
      };
    }
    getUndoRedoFullState() {
      var e;
      return {
        randomSeed: this.getRandomSeed(),
        includeFunctionParametersInRandomSeed: this
          .getIncludeFunctionParametersInRandomSeed(),
        layoutModel: this.layoutModel,
        settingsViewModel: this.settingsViewModel,
        graph: (e = this.getGrapher()) == null
          ? void 0
          : e.getUndoRedoFullState(),
        expressions: eL(this.listModel),
        geometryToolbar: zG(this.geometryToolbarModel),
        wasCompleteSetState: this.isCurrentlyDoingSetState,
      };
    }
    getState(e) {
      var a, s;
      let t = { stripDefaults: true };
      e && e.hasOwnProperty("stripDefaults") &&
        (t.stripDefaults = !!e.stripDefaults);
      let o =
          (s = (a = this.getGrapher()) == null ? void 0 : a.getState(t)) != null
            ? s
            : {
              ...this.getBlankState().graph,
              degreeMode: this.graphSettings.degreeMode,
            },
        i = {
          version: _l,
          randomSeed: this.getRandomSeed(),
          graph: o,
          expressions: oq(this.listModel, t),
        },
        n = this.getIncludeFunctionParametersInRandomSeed();
      if (
        (!n || !t.stripDefaults) &&
        (i.includeFunctionParametersInRandomSeed = n), this.isGeometry()
      ) {
        let l = zz(this.geometryToolbarModel, t);
        l && (i.geometryToolbar = l);
      }
      return e && e.avoidBackMigration
        ? __dcg_shared_module_exports__["Jc"](i)
        : VN(__dcg_shared_module_exports__["Jc"](i));
    }
    getHistory() {
      return new tA(this.getState(), this.stateStack);
    }
    getProduct() {
      return this.graphSettings.config.product;
    }
    isGeometry() {
      return this.getProduct() === "geometry-calculator";
    }
    is3dProduct() {
      return this.getProduct() === "graphing-3d";
    }
    isMultiSelectEnabled() {
      return this.isGeometry();
    }
    shouldEvaluateSelection() {
      return this.isGeometry();
    }
    canLoadPastedLink(e) {
      return this.graphSettings.config.pasteGraphLink
        ? this.isGeometry()
          ? AI(e) || KO(e) || $O(e)
          : this.is3dProduct()
          ? WO(e)
          : AI(e)
        : false;
    }
    getBlankState(e) {
      if (this.isGeometry()) return nf;
      if (this.is3dProduct()) return J$;
      let t;
      (e == null ? void 0 : e.degreeMode) !== void 0
        ? t = e.degreeMode
        : t = this.graphSettings.config.clearIntoDegreeMode;
      let o = { ...Bx.graph };
      return t && (o.degreeMode = true), { ...Bx, graph: o };
    }
    externalSetState(e, t) {
      var s;
      this._clearPendingImageUploads(),
        this.rootElt && document.activeElement &&
        this.rootElt.contains(document.activeElement) &&
        ee(document.activeElement).trigger("blur"),
        t || (t = {}),
        e || (e = this.getBlankState()),
        typeof e == "string" && (e = JSON.parse(e));
      let o = dc_migrateToLatest(e);
      !this.canEnableComplexMode() &&
        ((s = o == null ? void 0 : o.graph) != null && s.complex) &&
        (o.graph.complex = false, o.graph.degreeMode = e.graph.degreeMode);
      let i = this.graphSettings.config.product, n;
      if (
        !o.graph || o.graph.product === void 0
          ? n = "graphing"
          : n = o.graph.product, n !== i
      ) {
        throw new Error(
          `Data Error: state appears to have been saved in the '${n}' product and cannot be opened in the '${i}' product.`,
        );
      }
      i === "geometry-calculator" && (this.showConstructionsOpen = false),
        Z5 && i === "graphing-3d" && o.graph.speed3D &&
        delete o.graph.speed3D;
      let a = this.layoutModel;
      this.setState(o, t),
        J4(this.listModel),
        RE(this.listModel),
        this.layoutModel = {
          ...fR(this.graphSettings.config),
          keypadMinimized: a.keypadMinimized,
          keypadLayout: a.keypadLayout,
          keypadFunctionsOpen: a.keypadFunctionsOpen,
          expressionsVisible: !!this.graphSettings.config.expressions &&
            (this.isListVisible() || !!t.forceExpressionsOpen),
        },
        this.settingsViewModel = bR(),
        qr(this, void 0),
        t.forceUnsavedChanges
          ? this.enqueueEvent("change")
          : this.enqueueEvent("clearUnsavedChanges");
    }
    setState(e, t) {
      var o;
      if (
        this.isCurrentlyDoingSetState = true, "graph" in e && e.graph !== void 0
      ) {
        if (
          "threeDMode" in e.graph && e.graph.threeDMode && this.grapher3d
        ) {
          if (
            "showBox3D" in e.graph &&
            this.grapher3d.webglLayer.showBox(e.graph.showBox3D),
              "showAxis3D" in e.graph &&
              this.grapher3d.webglLayer.showAxes(!!e.graph.showAxis3D),
              "showAxisLabels3D" in e.graph &&
              this.grapher3d.webglLayer.updateAxes(),
              "showPlane3D" in e.graph || "showAxis3D" in e.graph
          ) {
            let a = ("showPlane3D" in e.graph
              ? !!e.graph.showPlane3D
              : this.graphSettings.showPlane3D) &&
              ("showAxis3D" in e.graph
                ? !!e.graph.showAxis3D
                : this.graphSettings.showAxis3D);
            this.grapher3d.webglLayer.showPlane(a);
          }
          let n = this.grapher3d.baseplaneWidth();
          this.grapher2d.setCanvasSizeFor3D(n, n),
            this.grapher3d.webglLayer.setBackgroundColor(
              e.graph.backgroundColor3d,
            );
        }
        let i = this.getGrapher();
        i
          ? i.setGrapherState(e.graph)
          : am.copyGraphProperties(e.graph, this.graphSettings),
          "threeDMode" in e.graph && e.graph.threeDMode &&
          this.grapher3d &&
          this.grapher3d.controls.copyWorldRotationToWorld();
      }
      if ("expressions" in e) {
        Nr(this.listModel, void 0);
        let i = iq(e.expressions);
        i >= this.__nextItemId && (this.__nextItemId = i + 1),
          nq(this.listModel, e.expressions, t || {});
      }
      if (
        e.layoutModel && (this.layoutModel = e.layoutModel),
          e.settingsViewModel &&
          (this.settingsViewModel = e.settingsViewModel),
          (!t || !t.allowUndo) && this.clearUndoRedoHistory(),
          this.setRandomSeed(e.randomSeed || rd()),
          this.setIncludeFunctionParametersInRandomSeed(
            (o = e.includeFunctionParametersInRandomSeed) != null
              ? o
              : Os.includeFunctionParametersInRandomSeed,
          ),
          "geometryToolbar" in e
      ) {
        let i = e.geometryToolbar;
        this.geometryToolbarModel = wE(i);
      }
    }
    updateToState(e) {
      if (
        this.isCurrentlyDoingRestoreState = true,
          "graph" in e &&
          (e.graph.threeDMode
            ? this.grapher3d && this.grapher3d.setGrapherState(e.graph)
            : this.grapher2d &&
              this.grapher2d.setGrapherState(e.graph, {
                doNotClear: true,
              })),
          "expressions" in e && aq(this.listModel, e.expressions),
          e.layoutModel && (this.layoutModel = e.layoutModel),
          e.settingsViewModel &&
          (this.settingsViewModel = e.settingsViewModel),
          "geometryToolbar" in e
      ) {
        let t = e.geometryToolbar;
        this.geometryToolbarModel = wE(t);
      }
    }
    commitUndoRedoSynchronously(e) {
      let t = this.stateStack.getState(),
        o = t && t.diffState,
        i = this.getUndoRedoDiffState();
      if (tpe(o, i)) return;
      let n = this.apiMethodCallStackInfo.withHistoryReplacementDepth > 0,
        a = { diffState: i, fullState: this.getUndoRedoFullState() };
      if (!n && ij(e)) {
        this.stateStack.addState(a), this.enqueueEvent("change", e);
      } else {
        let s = t && t.fullState.wasCompleteSetState ||
            a.fullState.wasCompleteSetState,
          l = {
            diffState: { ...a.diffState, wasCompleteSetState: s },
            fullState: { ...a.fullState, wasCompleteSetState: s },
          };
        this.stateStack.replaceInteriorState(l);
      }
    }
    undo() {
      if (!this.canUndo()) return;
      this.closeToast(), this.stateStack.undo();
      let e = this.stateStack.getState().fullState;
      e.wasCompleteSetState
        ? this.setState(e, { allowUndo: true })
        : this.updateToState(e), this.enqueueEvent("change", { type: "undo" });
    }
    redo() {
      if (!this.canRedo()) return;
      this.stateStack.redo();
      let e = this.stateStack.getState().fullState;
      e.wasCompleteSetState
        ? this.setState(e, { allowUndo: true })
        : this.updateToState(e), this.enqueueEvent("change", { type: "undo" });
    }
    clearUndoRedoHistory() {
      this.stateStack.clear();
    }
    canUndo() {
      return this.stateStack.canUndo();
    }
    canRedo() {
      return this.stateStack.canRedo();
    }
    closeToast() {
      let e = this.toastData.onHide;
      e && this.runAfterDispatch(e), this.toastData = {};
    }
    _closeAddExpression() {
      this.layoutModel = { ...this.layoutModel, addExpressionOpen: false };
    }
    doesDOMHaveSize() {
      return this.layoutMeasurements.width > 0 &&
        this.layoutMeasurements.height > 0;
    }
    _getExpListWidth() {
      let e;
      if (this.userSpecifiedExpListWidth !== void 0) {
        let o = this.isGeometry() ? 320 : 200;
        e = Math.max(
          320,
          Math.min(
            this.layoutMeasurements.width - o,
            this.userSpecifiedExpListWidth,
          ),
        );
      } else {
        if (e = this.layoutMeasurements.width, !e) return 356;
        let o = .2 * e + 160;
        e = Math.min(500, Math.max(280, o));
      }
      let t = this.layoutMeasurements.width - this.getGrapherHeight();
      return Math.abs(t - e) <= 10 ? t : e;
    }
    _setExpListWidth(e) {
      this.userSpecifiedExpListWidth !== e &&
        (this.userSpecifiedExpListWidth = e);
    }
    getKeypadHeight() {
      return this.computeMajorLayout().keypad.height;
    }
    isKeypadEnabled() {
      return !!this.graphSettings.config.keypad;
    }
    isKeypadOpen() {
      if (!this.isKeypadEnabled()) return false;
      let e = this.layoutModel.keypadMinimized && !this.isNarrow();
      return this.needsFakeKeypad() && !e;
    }
    isHideKeypadButtonVisible() {
      return this.getBrailleMode() === "none" && this.isKeypadOpen() &&
        (!this.isNarrow() || this.inAudioTraceMode());
    }
    isKeypadFunctionsPopoverOpen() {
      return !!this.layoutModel.keypadFunctionsOpen;
    }
    getKeypadLayout() {
      let e = this.layoutModel.keypadLayout;
      return this.isThreeDMode() ? Z$(e) : e;
    }
    isLetterKeypadOpen() {
      let e = this.getKeypadLayout();
      return this.isKeypadOpen() &&
        (e === "letters" || e === "noQwertyLetters" ||
          e === "capitalLetters" || e === "noQwertyCapitalLetters");
    }
    isFileDraggedOver() {
      return this.layoutModel.isFileDraggedOver;
    }
    getGeoToolbarHeight() {
      return this.shouldShowGeoToolbar() ? 48 : 0;
    }
    isNarrowGeometryHeader() {
      return this.computeMajorLayout().grapher.width < 450;
    }
    shouldShowMultiSelectHeader() {
      return this.getSelectedGeoExpression() ||
        this.hasMultipleItemsSelected();
    }
    getGrapherHeight() {
      return this.layoutMeasurements.height - this.getGeoToolbarHeight();
    }
    computeMajorLayout() {
      let e = this.layoutMeasurements.width,
        t = this.layoutMeasurements.height,
        o = this.isNarrow(),
        i = this.isListVisible(),
        n = this.isKeypadOpen(),
        a = !this.isGrapherEnabled(),
        s = !this.isListEnabled(),
        l = !!this.getGraphSettings().config.projectorMode,
        c = { left: 0, top: 0, width: 0, height: 0 },
        d = { left: 0, top: 0, width: 0, height: 0, paddingTop: 0 },
        p = {
          left: 0,
          top: t,
          width: e,
          height: l ? o ? 185 : 193 : 169,
        };
      s
        ? (d.width = e, d.height = t)
        : a
        ? (c.width = e, c.height = t)
        : i
        ? o
          ? (c.width = e,
            c.height = Math.round(.58 * t),
            c.top = t - c.height,
            d.width = e,
            d.height = t - c.height)
          : (c.width = this.getExpListWidth(),
            c.height = t,
            d.left = c.width,
            d.width = e - d.left,
            d.height = t)
        : i || (o
          ? (c.width = e,
            c.height = Math.round(.58 * t),
            c.top = t,
            d.width = e,
            d.height = t)
          : (c.width = this.getExpListWidth(),
            c.height = t,
            c.left = -c.width,
            d.width = e,
            d.height = t)),
        n && (p.top -= p.height, s || (c.height -= p.height));
      let h = this.getGeoToolbarHeight();
      return h && (d.top += h, d.height -= h),
        { list: c, grapher: d, keypad: p };
    }
    isNarrow() {
      return this.isGeometry()
        ? this.layoutMeasurements.width < 600
        : this.layoutMeasurements.width < 450;
    }
    getLayoutMeasurements() {
      return this.layoutMeasurements;
    }
    getCapExpressionSize() {
      return !!this.getGraphSettings().config.capExpressionSize;
    }
    handleAudioTraceCommand(e) {
      let t = this.getAudioGraph();
      if (t === void 0) return;
      let o = t.agNavigator;
      switch (e) {
        case "on":
          this.runAfterDispatch(() => {
            t.enterAudioTrace({ fromKeypad: true });
          });
          break;
        case "off":
          this.runAfterDispatch(() => {
            t.exitAudioTrace();
          });
          break;
        case "hear-graph":
          t.hearGraph();
          break;
        case "stop-graph":
          t.stopGraph();
          break;
        case "volume-down":
          t.adjustVolume("down");
          break;
        case "volume-up":
          t.adjustVolume("up");
          break;
        case "speed-down":
          t.speedDown();
          break;
        case "speed-up":
          t.speedUp();
          break;
        case "previous-point":
          this.runAfterDispatch(() => {
            t.reportAndMoveToPrevPoint();
          });
          break;
        case "next-point":
          this.runAfterDispatch(() => {
            t.reportAndMoveToNextPoint();
          });
          break;
        case "previous-poi":
          this.runAfterDispatch(() => {
            t.reportAndMoveToPrevPOI();
          });
          break;
        case "next-poi":
          this.runAfterDispatch(() => {
            t.reportAndMoveToNextPOI();
          });
          break;
        case "previous-curve":
          this.runAfterDispatch(() => {
            o.prevCurve();
          });
          break;
        case "next-curve":
          this.runAfterDispatch(() => {
            o.nextCurve();
          });
          break;
        case "describe-point":
          t.describePoint();
          break;
        case "describe-curve":
          t.describeCurve();
          break;
        case "describe-axes":
          t.describeAxes();
          break;
        case "keyboard-shortcuts":
          this.enqueueEvent("showHotkeysModal", {
            type: "keypad/audio-trace",
            command: e,
          });
          break;
        default:
          return e;
      }
    }
    setAudioTraceSpeed(e) {
      let t = this.getAudioGraph();
      t && t.adjustPlaybackSpeed(e);
    }
    setGraphPaperFocus(e) {
      var t;
      qr(this, e.isFocused ? { type: "graph-paper" } : void 0),
        (t = this.get2dPOIController()) == null ||
        t.keyboardAttentionManager.setKeyboardAttention(void 0),
        this.requestRedrawGraph(),
        e.isFocused && this.isGeoToolActive() &&
        this.runAfterDispatch(() => {
          var o;
          (o = this.get2dPOIController()) == null ||
            o.keyboardAttentionManager.handleGrapherGainedFocus();
        });
    }
    isGraphPaperFocused() {
      let e = this.getFocusLocation();
      return e
        ? !!(e.type === "graph-paper" ||
          e.type === "expression" && e.isFakeGraphFocus)
        : false;
    }
    isVirtualMouseAllowed() {
      return !(!this.isGeometry() || !this.isGraphPaperFocused() ||
        !this.geoModel.getCurrentTool().canNextInputBePoint());
    }
    isClickableId(e) {
      return nb(this.getItemModel(e));
    }
    setCanShowKeyboardShortcuts(e) {
      this.canShowKeyboardShortcuts = e;
    }
    getCanShowKeyboardShortcuts() {
      return this.canShowKeyboardShortcuts;
    }
    apply3dProps(e) {
      if (!this.isThreeDMode() || !this.grapher3d) return;
      let t = this.grapher3d.webglLayer;
      for (let o in e) {
        switch (o) {
          case "showPlane3D":
            t.showPlane(this.showPlane3D());
            break;
          case "showBox3D":
            t.showBox(!!e[o]);
            break;
          case "showAxis3D":
            t.showAxes(!!e[o]), t.showPlane(this.showPlane3D());
            break;
          case "showAxisLabels3D":
            t.updateAxes();
            break;
          default:
            break;
        }
      }
    }
    getGeometryTokenCount() {
      if (!this.cachedGeoTokenDepths) return 0;
      let e = 0;
      return __dcg_shared_module_exports__["h"](
        __dcg_shared_module_exports__["C"](this.cachedGeoTokenDepths),
        (t) => e += t ? t.length : 0,
      ),
        e;
    }
    getAllGeometryConstructionIds() {
      return V4(this.listModel, __dcg_shared_module_exports__["xd"]);
    }
    makeGeoAPI() {
      this.geoModel = new l1(this);
    }
    getGeoTokenInfoFromIdentifier(e) {
      if (e) return this.cachedGeoTokenInfo[e];
    }
    getGhostMode() {
      return this.getGraphSettings().config.getProperty("ghostMode");
    }
    getshowKeyboardShortcutsInTooltips() {
      return !!this.getGraphSettings().config
        .showKeyboardShortcutsInTooltips;
    }
    isDispatching() {
      return this.dispatcher.isDispatching();
    }
    getSuggestedIdentifierRenameInfo(e) {
      return this.listModel.renamePrompt.suggestionForId(e);
    }
    getMathquillConfig(e) {
      let t = e.additionalOperators || [];
      return this.toneAllowed() && t.push("tone"), {
        ...Vf({
          additionalOperators: t,
          includeGeometryFunctions: this.isGeometry(),
          include3DFunctions: this.is3dProduct(),
        }),
        autoCommands: Pu({
          additionalCommands: this.isGeometry() ? [] : ["int"],
          disallowAns: this.isGeometry(),
        }),
      };
    }
    constrainMultiSelect() {
      if (this.isMultiSelectEnabled()) return;
      let e = FE(this.listModel);
      e.length > 1 && Nr(this.listModel, e[0]);
    }
    focusFirstExpression() {
      if (!this.getGraphSettings().config.expressions) return;
      let e = eb(this.listModel);
      e && bi(this, e.id, "end");
    }
    _updateToneAvailability() {
      let e = this.toneAllowed();
      e && !this.toneController
        ? this.toneController = new Nw(this)
        : !e && this.toneController && (this.toneController = void 0);
    }
    toneItemsExist() {
      return this.toneEnabled()
        ? this.getAllItemModels().some((e) => Is(e))
        : false;
    }
    toneAllowed() {
      return !!(this.graphSettings.config.audio &&
        this.graphSettings.config.tone);
    }
    toneEnabled() {
      return !!this.toneController;
    }
    isAdaptivePeelingSettled() {
      let e = this.adaptiveDepthPeelingInfo;
      return (e == null ? void 0 : e.status) === 2 ||
        (e == null ? void 0 : e.status) === 1 &&
          (e == null ? void 0 : e.peelLayers) >= zy;
    }
    setAdaptiveDepthPeelingInfo(e) {
      let t = this.adaptiveDepthPeelingInfo;
      this.adaptiveDepthPeelingInfo = e,
        this.isAdaptivePeelingSettled() || this.requestRedrawGraph(),
        (t == null ? void 0 : t.peelLayers) !== e.peelLayers &&
        this.dispatch({ type: "render" });
    }
    getAdaptiveDepthPeelingInfo() {
      return this.adaptiveDepthPeelingInfo;
    }
    handleEvaluatorProgressUpdates() {
      this.checkSlowAnalysis = true, this.requestedEvaluatorRestart = false;
    }
    clearSlowEvaluatorTracking() {
      this.expressionActionsToRestartIfSlow = [],
        this.checkSlowAnalysis = false,
        this.requestedEvaluatorRestart = false;
    }
    handlePossiblySlowEvaluator() {
      if (!this.isEvaluatorSlow()) return false;
      let e = false;
      return this.expressionActionsToRestartIfSlow.some((
          { action: t, id: o },
        ) => this.shouldRestartForAction(t, o)
        )
        ? (this.requestEvaluatorRestart(), e = true)
        : this.checkSlowAnalysis && (e = true, this.checkSlowAnalysis = false),
        e;
    }
    shouldRestartForAction(e, t) {
      switch (e) {
        case "edit":
        case "remove":
          return this.isActivelyComputing(t);
        case "hide":
          return this.getEvaluatorStateForItem(t) === "GRAPHING";
        default:
          return e;
      }
    }
    isEvaluatorSlow() {
      return !this.requestedEvaluatorRestart &&
        this.evaluator.isCurrentlySlow();
    }
    requestEvaluatorRestart() {
      this.evaluator.requestRestartWorker(),
        this.clearSlowEvaluatorTracking(),
        this.requestedEvaluatorRestart = true;
    }
    shouldShowProgressUpdateLegend() {
      return this.getGraphSettings().config.debugProgressUpdates &&
        !this.progressUpdateLegendHidden;
    }
    isItemSlowInEvaluator(e) {
      return this.isActivelyComputing(e) && this.isEvaluatorSlow();
    }
    isActivelyComputing(e) {
      return d$(this.getEvaluatorStateForItem(e));
    }
    trackActionForPotentialEvaluatorRestart(e, t) {
      this.expressionActionsToRestartIfSlow.push({ action: e, id: t });
    }
    shouldShowProgressUpdateColors() {
      return this.shouldShowProgressUpdateLegend();
    }
    shouldShowProgressUpdateIcons() {
      return this.getGraphSettings().config.debugProgressUpdates;
    }
    isComplexModeEnabled() {
      return this.canEnableComplexMode() && this.graphSettings.complex;
    }
    canEnableComplexMode() {
      return this.graphSettings.config.allowComplex;
    }
    shouldShowSliderPrompt(e) {
      let t = Ep(e);
      return t.length > 0 && t.length <= 4
        ? true
        : this.areSlidersEnabled()
        ? ab(e).length > 0
        : false;
    }
    shouldShowRegressionButton(e) {
      return this.is3dProduct() || !this.areTableRegressionsEnabled() ||
          e.type !== "table" || e.regression || e.columnModels.length < 2
        ? false
        : Cp(e.columnModels[0]) && Ru(e.columnModels[0]) &&
          e.columnModels.slice(1).some((t) => Cp(t) && Ru(t));
    }
    renameTableColumnsForGlobalExport(e, t) {
      let o = this.getExportedVariables();
      for (let i of t) {
        let n = Eo(e, i);
        if (!n) continue;
        let a = n.latex;
        if (!ya(a)) continue;
        let s = __dcg_shared_module_exports__["latexToIdentifier"](a);
        if (o.isMultiplyDefined(s, { includeRegressionExports: true })) {
          let l = s.split("_")[0],
            c = o.getLastSubscriptForName(l, {
              includeRegressionExports: true,
            }),
            d = `${l}_{${c + 1}}`;
          fd(this.listModel, a, d, { limitToItem: e.id }),
            o.optimisticallyRegisterColumnName(
              __dcg_shared_module_exports__["latexToIdentifier"](d),
            );
        }
      }
    }
    exportTableRegression(e, t) {
      var l, c;
      let o = this.getItemModel(t);
      if ((o == null ? void 0 : o.type) !== "table") return;
      let i = o.regression;
      if (!i) return;
      let n = "";
      if (e === "regression") {
        this.renameTableColumnsForGlobalExport(o, [
          i.columnIds.x,
          i.columnIds.y,
        ]);
        let d = kz(o);
        if (!d) return;
        n = __dcg_shared_module_exports__["me"](i.type, {
          operator: "~",
          variables: d,
        });
        let p = __dcg_shared_module_exports__["oe"](n),
          h = oL(this.listModel),
          u;
        p.some((f) => h.isDefined(f, { includeRegressionExports: false })) &&
        (u = 1 +
          Math.max(
            ...p.map((f) =>
              h.getLastSubscriptForName(f, {
                includeRegressionExports: false,
              })
            ),
          )),
          n = n.replace(
            __dcg_shared_module_exports__["ne"],
            (f, y) => u !== void 0 ? `${y}_{${u}}` : y,
          );
      } else {
        let d = ((c = (l = o.formula) == null ? void 0 : l.table_regression) ==
              null
            ? void 0
            : c.status) === "success"
          ? o.formula.table_regression.result
          : void 0;
        if (!d) return;
        n = __dcg_shared_module_exports__["me"](i.type, {
          operator: "=",
          variables: ["x", "y"],
          parameterValues: yR(d),
        });
      }
      let a = this.createItemModel({
          type: "expression",
          id: this.generateId(),
          latex: Fe.normalizeLatex(n, this.getMathquillConfig({})),
          color: this.getNextColor(),
          hidden: false,
        }),
        s = 1 + o.index;
      _s(this.listModel, a, s), this.setEditListMode(false), bi(this, a.id);
    }
    getExportedVariables() {
      return oL(this.listModel);
    }
  };
  function yR(r) {
    let e = {};
    for (let [t, o] of Object.entries(r.parameters)) {
      let i = bP(o), n = Math.max(i, r.displayPrecision);
      e[t] = parseFloat(o.toPrecision(n));
    }
    return e;
  }
  function nj(r) {
    return r &&
      {
        ...r,
        wasCompleteSetState: void 0,
        layoutModel: void 0,
        settingsViewModel: void 0,
      };
  }
  function tpe(r, e) {
    return __dcg_shared_module_exports__["E"](nj(r), nj(e));
  }
  var { SwitchUnion: rpe, If: oA, IfDefined: xR, IfElse: ope } = je.Components,
    iA = class extends je.Class {
      init() {
        this.model = this.props.table(),
          this.controller = this.props.controller(),
          this.dropdownOpen = false;
      }
      customRegressionsEnabled() {
        return this.controller.getGraphSettings().config
          .customRegressions;
      }
      template() {
        return xR(
          () => this.getRegression(),
          (e) =>
            je.createElement(
              "div",
              {
                class: () => ({
                  "dcg-table-regression": true,
                  "dcg-do-not-blur": true,
                }),
                handleEvent: je.const("true"),
                onKeyDown: this.bindFn(this.handleKeyDown),
              },
              je.createElement(
                "div",
                {
                  class: () => ({
                    "dcg-dropdown-row": true,
                    "dcg-dropdown-row__has-column-picker": this
                      .shouldShowColumnDropdown(),
                  }),
                },
                je.createElement(
                  "div",
                  { class: je.const("dcg-dropdown-row__plot-and-model") },
                  je.createElement(
                    "div",
                    { class: je.const("dcg-icon-container") },
                    rpe("status", () => e().evaluated)({
                      error: (t) =>
                        je.createElement(Di, {
                          instant: this.const(true),
                          error: () => this.controller.unpack(t().error),
                        }),
                      success: () =>
                        je.createElement(
                          "div",
                          {
                            class: je.const(
                              "dcg-circular-icon-container",
                            ),
                            role: je.const("button"),
                            tabIndex: je.const("0"),
                            "dcg-open-menu-guid": () => this.getGuid(),
                            "aria-label": this.bindFn(
                              this.getIconAriaLabel,
                            ),
                            onTap: (t) => {
                              if (!t.wasLongheld()) {
                                if (
                                  t.shiftKey || this.optionsOpen() ||
                                  this.controller.isInEditListMode()
                                ) return this.toggleOptions();
                                this.setHidden(!e().spec.hidden);
                              }
                            },
                            onLongHold: (t) => {
                              t.handle("dcg-longhold"),
                                t.handle("dcg-tap"),
                                this.toggleOptions();
                            },
                            manageFocus: this.const(
                              rt({
                                controller: this.controller,
                                location: {
                                  type: "table-regression-icon",
                                  id: this.model.id,
                                },
                              }),
                            ),
                          },
                          je.createElement($o, {
                            iconType: () =>
                              e().spec.hidden ? "hidden" : "graph-default",
                            backgroundColor: () => {
                              var t;
                              return {
                                type: "single-color",
                                value: (t = e().spec.color) != null ? t : "",
                              };
                            },
                            whiteIcon: this.const(false),
                            foregroundColor: this.const(""),
                            iconModifier: this.const("none"),
                            backgroundOpacity: this.const(1),
                          }),
                        ),
                    }),
                  ),
                  je.createElement(V0, {
                    id: () => `regression-model-${this.model.id}`,
                    controller: () => this.controller,
                    options: () => this.getModelOptions(),
                    onOpenChange: this.bindFn(this.onDropdownOpenChange),
                    externalControl: this.const({
                      getValue: () => this.getRegressionType(),
                      onValueChange: (t) => {
                        this.controller.dispatch({
                          type: "update-table-regression",
                          tableId: this.model.id,
                          update: { type: t },
                        });
                      },
                    }),
                    manageFocus: this.const(
                      rt({
                        controller: this.controller,
                        location: {
                          type: "table-regression-type-dropdown",
                          id: this.model.id,
                        },
                      }),
                    ),
                    buildFooter: () =>
                      this.customRegressionsEnabled()
                        ? je.createElement(
                          "div",
                          {
                            class: je.const(
                              "dcg-table-regression-view__custom-model-notice",
                            ),
                          },
                          je.createElement(
                            Oi,
                            {
                              i18n: this.const(this.controller),
                              key: this.const(
                                "graphing-calculator-text-make-custom-regression",
                              ),
                            },
                            je.const(
                              "Make a custom regression model in a new line using",
                            ),
                            je.const(" "),
                            je.createElement("span", {
                              class: je.const("dcg-tilde"),
                            }, je.const("~")),
                            je.const("."),
                            je.const(" "),
                            je.createElement("a", {
                              class: je.const("dcg-blue-link"),
                              href: je.const(
                                "https://help.desmos.com/hc/en-us/articles/4406972958733-Regressions",
                              ),
                              target: je.const("_blank"),
                            }, je.const("Learn how")),
                            je.const("."),
                          ),
                        )
                        : [],
                  }),
                ),
                je.createElement(
                  "div",
                  { class: je.const("dcg-dropdown-row__breakable") },
                  je.createElement(oA, {
                    predicate: () => this.shouldShowColumnDropdown(),
                  }, () =>
                    je.createElement("div", {
                      class: je.const(
                        "dcg-table-regression__dropdown-separator",
                      ),
                    }, () => this.controller.s("shared-calculator-label-for"))),
                  je.createElement(oA, {
                    predicate: () => this.shouldShowColumnDropdown(),
                  }, () =>
                    je.createElement(
                      "div",
                      {
                        class: je.const(
                          "dcg-dropdown-row__column-selector",
                        ),
                      },
                      je.createElement(V0, {
                        id: () => `regression-data-${this.model.id}`,
                        controller: () => this.controller,
                        options: () => this.getColumnOptions(),
                        onOpenChange: this.bindFn(
                          this.onDropdownOpenChange,
                        ),
                        externalControl: this.const({
                          getValue: () => `id-${e().spec.columnIds.y}`,
                          onValueChange: (t) => {
                            this.controller.dispatch({
                              type: "update-table-regression",
                              tableId: this.model.id,
                              update: {
                                columnIds: {
                                  x: e().spec.columnIds.x,
                                  y: t.substring(3),
                                },
                              },
                            });
                          },
                        }),
                      }),
                    )),
                  ope(this.bindFn(this.customRegressionsEnabled), {
                    true: () =>
                      je.createElement(
                        P0,
                        {
                          anchor: () =>
                            je.createElement(Le, {
                              tooltip: () =>
                                this.controller.s(
                                  "graphing-calculator-text-view-regression-options",
                                ),
                            }, je.createElement(by, null)),
                          anchorAriaLabel: () =>
                            this.controller.s(
                              "graphing-calculator-text-view-regression-options",
                            ),
                          controlled: () => ({
                            isOpen: this.dropdownOpen,
                            setDropdownOpen: this.bindFn(
                              this.setDropdownOpen,
                            ),
                          }),
                          guid: () => `view-source-regression-${this.model.id}`,
                          dropdownProps: this.const({
                            position: this.const("bottom-left"),
                          }),
                          dropdownOffset: () => -15,
                          manageFocus: this.const({
                            itemNavigationKey: "tab",
                          }),
                        },
                        je.createElement(
                          "div",
                          { class: je.const("dcg-generic-options-menu") },
                          je.createElement(
                            "div",
                            {
                              class: je.const("dcg-options-menu-section"),
                            },
                            je.createElement("div", {
                              class: je.const(
                                "dcg-expression-footer-title",
                              ),
                            }, () =>
                              this.controller.s(
                                "graphing-calculator-heading-table-regression-model-structure",
                              )),
                            je.createElement(
                              "div",
                              { class: je.const("dcg-regression-model") },
                              je.createElement(pl, {
                                controller: this.props.controller,
                                latex: this.bindFn(
                                  this.buildLatexForRegressionModel,
                                ),
                                ariaLabel: () =>
                                  this.controller.s(
                                    "graphing-calculator-heading-table-regression-model-structure",
                                  ),
                                focusLocation: this.const({
                                  type: "regression-output",
                                  id: this.model.id,
                                  parameter: "model",
                                }),
                                tabbable: this.const(false),
                              }),
                            ),
                            xR(() => this.getExportErrorReason(), (t) =>
                              je.createElement(
                                "div",
                                {
                                  class: je.const(
                                    "dcg-regression-popover__unexportable-warning dcg-text-selectable",
                                  ),
                                },
                                je.createElement(es, {
                                  content: () => this.controller.unpack(t()),
                                  mqConfig: () =>
                                    this.controller.getMathquillConfig(
                                      {},
                                    ),
                                }),
                              )),
                          ),
                          je.createElement(
                            "div",
                            {
                              class: je.const("dcg-options-menu-section"),
                            },
                            je.createElement(oA, {
                              predicate: () =>
                                !this.getExportErrorReason(),
                            }, () =>
                              je.createElement(
                                "button",
                                {
                                  class: je.const(
                                    "dcg-btn-light-gray dcg-regression-popover__export-to-list",
                                  ),
                                  onTap: () =>
                                    this.copyToExpressionList(
                                      "regression",
                                    ),
                                },
                                () =>
                                  this.controller.s(
                                    "graphing-calculator-button-copy-table-regression-model-to-expression-list",
                                  ),
                              )),
                            je.createElement(
                              "button",
                              {
                                class: je.const(
                                  "dcg-btn-red dcg-regression-popover__delete",
                                ),
                                onTap: () => {
                                  this.setDropdownOpen(false),
                                    this.controller.dispatch({
                                      type: "remove-table-regression",
                                      tableId: this.model.id,
                                    });
                                },
                                manageFocus: this.const(
                                  rt({
                                    controller: this.controller,
                                    location: {
                                      type: "table-regression-delete-btn",
                                      id: this.model.id,
                                    },
                                  }),
                                ),
                              },
                              () =>
                                this.controller.s(
                                  "graphing-calculator-button-delete-table-regression",
                                ),
                            ),
                          ),
                        ),
                      ),
                    false: () =>
                      je.createElement("i", {
                        class: je.const("dcg-icon-remove"),
                        role: je.const("button"),
                        tabIndex: je.const("0"),
                        "aria-label": () =>
                          this.controller.s(
                            "graphing-calculator-button-delete-table-regression",
                          ),
                        onTap: () =>
                          this.controller.dispatch({
                            type: "remove-table-regression",
                            tableId: this.model.id,
                          }),
                        manageFocus: this.const(
                          rt({
                            controller: this.controller,
                            location: {
                              type: "table-regression-delete-btn",
                              id: this.model.id,
                            },
                          }),
                        ),
                      }),
                  }),
                ),
              ),
              je.createElement(oA, {
                predicate: () => e().evaluated.status === "success",
              }, () =>
                je.createElement(
                  "div",
                  null,
                  je.createElement(
                    "div",
                    {
                      class: je.const(
                        "dcg-expression-footer-title dcg-expression-footer-title__equation",
                      ),
                    },
                    () =>
                      this.controller.s(
                        "graphing-calculator-heading-regression-equation",
                      ),
                    je.createElement(
                      Le,
                      {
                        tooltip: () =>
                          this.controller.s(
                            "graphing-calculator-text-export-snapshot",
                          ),
                      },
                      je.createElement(
                        "button",
                        {
                          class: je.const(
                            "dcg-unstyled-button dcg-copy-regression-button",
                          ),
                          onTap: () => this.copyToExpressionList("equation"),
                          "aria-label": () =>
                            this.controller.s(
                              "graphing-calculator-text-export-snapshot",
                            ),
                        },
                        je.createElement("i", {
                          class: je.const("dcg-icon-insert"),
                          "aria-hidden": je.const("true"),
                        }),
                      ),
                    ),
                  ),
                  je.createElement(
                    "div",
                    {
                      class: je.const(
                        "dcg-regression-equation dcg-do-not-blur",
                      ),
                      onTap: this.bindFn(this.ensureTableSelected),
                      didMount: this.bindFn(
                        this.didMountRegressionEquation,
                      ),
                      didUnmount: this.bindFn(
                        this.didUnmountRegressionEquation,
                      ),
                    },
                    je.createElement(pl, {
                      controller: this.props.controller,
                      latex: this.bindFn(
                        this.buildLatexForRegressionEquation,
                      ),
                      ariaLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-table-regression-equation",
                        ),
                      focusLocation: this.const({
                        type: "regression-output",
                        id: this.model.id,
                        parameter: "equation",
                      }),
                      tabbable: this.const(true),
                    }),
                  ),
                  xR(() => this.getRegressionDetails(), (t) =>
                    je.createElement(Xb, {
                      controller: () =>
                        this.controller,
                      model: () => this.model,
                      hideParameters: this.const(true),
                      regression: t,
                      suppressRMSE: this.const(true),
                      suppressLogModeCheckbox: () =>
                        !__dcg_shared_module_exports__["le"](
                          this.getRegressionType(),
                        ),
                      showRValue: () =>
                        this.getRegressionType() === "linear"
                          ? "always"
                          : "never",
                    })),
                )),
            ),
        );
      }
      getExportErrorReason() {
        let e = this.getRegression();
        if (e) {
          if (e.evaluated.status === "error") return e.evaluated.error;
          if (e.evaluated.export_info.status === "unexportable") {
            return e.evaluated.export_info.reason;
          }
        }
      }
      buildLatexForRegressionEquation() {
        let e = this.getRegression();
        return !e || e.evaluated.status !== "success"
          ? ""
          : __dcg_shared_module_exports__["me"](e.spec.type, {
            operator: "=",
            variables: ["x", "y"],
            parameterValues: yR(e.evaluated.result),
          });
      }
      buildLatexForRegressionModel() {
        let e = this.getRegression();
        return !e || e.evaluated.status !== "success"
          ? ""
          : __dcg_shared_module_exports__["me"](e.spec.type, {
            operator: "~",
            variables: ["x", "y"],
            parameterValues: "canonical",
          });
      }
      didMountRegressionEquation(e) {
        this.regEqNode = e;
      }
      didUnmountRegressionEquation() {
        this.cachedRegEqLatex = "", this.regEqNode = void 0;
      }
      addLineBreaks() {
        if (!this.regEqNode) return;
        let e = this.buildLatexForRegressionEquation();
        e !== this.cachedRegEqLatex &&
          (this.cachedRegEqLatex = e,
            this.regEqNode.querySelectorAll(".dcg-mq-binary-operator")
              .forEach((t) => {
                var o, i;
                t.textContent !== "+" && t.textContent !== "\u2212" ||
                  (i = (o = t.parentNode) == null ? void 0 : o.classList) !=
                        null &&
                    i.contains("dcg-mq-root-block") &&
                    t.classList.add("dcg-break-before");
              }));
      }
      didUpdate() {
        this.addLineBreaks();
      }
      onDropdownOpenChange(e) {
        e && this.controller.scrollItemIntoView(this.model);
      }
      getRegressionType() {
        var e, t;
        return (t = (e = this.getRegression()) == null
            ? void 0
            : e.spec.type) != null
          ? t
          : "linear";
      }
      ensureTableSelected() {
        let e = this.model.id;
        this.controller.isItemSelected(e) ||
          this.controller.dispatch({
            type: "set-selected-id",
            id: e,
            state: "selected",
          });
      }
      getRegressionDetails() {
        var e, t;
        if (
          ((t = (e = this.model.formula) == null
              ? void 0
              : e.table_regression) == null
            ? void 0
            : t.status) === "success"
        ) return this.model.formula.table_regression.result;
      }
      hasAnyNonPositiveXValues() {
        let e = this.model.regression;
        if (!e) return false;
        let t = Eo(this.model, e.columnIds.x);
        return __dcg_shared_module_exports__["k"](
          (t == null ? void 0 : t.computedValues) || [],
          (o) => parseFloat(o) <= 0,
        );
      }
      getRegression() {
        var o;
        if (!this.controller.areTableRegressionsEnabled()) return;
        let e = this.model.regression,
          t = (o = this.model.formula) == null ? void 0 : o.table_regression;
        if (e) {
          let i = Eo(this.model, e.columnIds.x),
            n = Eo(this.model, e.columnIds.y);
          !i || !n || i.hasNanOrErrorValue || n.hasNanOrErrorValue
            ? t = {
              status: "error",
              error: __dcg_shared_module_exports__["Jb"]().getError(),
            }
            : e.type === "logarithmic" &&
              this.hasAnyNonPositiveXValues() &&
              (t = {
                status: "error",
                error: __dcg_shared_module_exports__["Kb"]().getError(),
              });
        }
        return e && t ? { spec: e, evaluated: t } : void 0;
      }
      shouldShowColumnDropdown() {
        return this.getColumnOptions().length > 1;
      }
      getColumnOptions() {
        let e = new Set(), t = this.model.regression;
        return t && (e.add(t.columnIds.x), e.add(t.columnIds.y)),
          this.model.columnModels.slice(1).filter((o) => e.has(o.id) || Cp(o))
            .map((o) => ({
              label: "`" + o.latex + "`",
              id: "id-" + o.id,
              disabled: !Ru(o) || !Cp(o),
            }));
      }
      setDropdownOpen(e) {
        this.dropdownOpen = e,
          e &&
          this.controller.logEvent({
            category: "regressions",
            action: "view-regression-options",
            name: this.getRegressionType(),
          }),
          this.update();
      }
      getModelOptions() {
        return [{
          id: "linear",
          label: this.controller.s(
            "graphing-calculator-label-table-regression-type-linear",
          ),
        }, {
          id: "quadratic",
          label: this.controller.s(
            "graphing-calculator-label-table-regression-type-quadratic",
          ),
        }, {
          id: "cubic",
          label: this.controller.s(
            "graphing-calculator-label-table-regression-type-cubic",
          ),
        }, {
          id: "quartic",
          label: this.controller.s(
            "graphing-calculator-label-table-regression-type-quartic",
          ),
        }, {
          id: "exponential",
          label: this.controller.s(
            "graphing-calculator-label-table-regression-type-exponential",
          ),
        }, {
          id: "logarithmic",
          label: this.controller.s(
            "graphing-calculator-label-table-regression-type-logarithmic",
          ),
        }, {
          id: "power",
          label: this.controller.s(
            "graphing-calculator-label-table-regression-type-power",
          ),
        }, {
          id: "logistic",
          label: this.controller.s(
            "graphing-calculator-label-table-regression-type-logistic",
          ),
        }, {
          id: "sinusoidal",
          label: this.controller.s(
            "graphing-calculator-label-table-regression-type-sinusoidal",
          ),
        }];
      }
      copyToExpressionList(e) {
        this.setDropdownOpen(false),
          this.controller.dispatch({
            type: "export-table-regression",
            tableId: this.model.id,
            mode: e,
            regressionType: this.getRegressionType(),
          });
      }
      getGuid() {
        return `table-regression-${this.model.guid}`;
      }
      toggleOptions() {
        this.controller.dispatch({
          type: "toggle-item-settings-menu",
          menu: {
            type: "table-regression",
            model: this.model,
            guid: this.getGuid(),
            focusFirstOption: true,
          },
        });
      }
      setHidden(e) {
        this.controller.dispatch({
          type: "update-table-regression",
          tableId: this.model.id,
          update: { hidden: e },
        });
      }
      optionsOpen() {
        return this.controller.isItemSettingsMenuOpen(this.getGuid());
      }
      getIconAriaLabel() {
        var e;
        return this.optionsOpen()
          ? this.controller.s(
            "graphing-calculator-narration-hide-options",
          )
          : (e = this.model.regression) != null && e.hidden
          ? this.controller.s(
            "graphing-calculator-narration-show-table-regression",
          )
          : this.controller.s(
            "graphing-calculator-narration-hide-table-regression",
          );
      }
      handleKeyDown(e) {
        let t = Ko(e);
        if (
          !e.altKey && e.ctrlKey && !e.metaKey && e.shiftKey && t === "O"
        ) {
          if (
            e.preventDefault(),
              e.stopPropagation(),
              this.controller.getOpenItemMenu() !== void 0
          ) return;
          this.controller.dispatch({
            type: "toggle-item-settings-menu",
            menu: {
              type: "table-regression",
              model: this.model,
              guid: this.getGuid(),
              focusFirstOption: true,
            },
          });
        }
      }
    };
  var bn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var { If: ipe, Switch: npe } = bn.Components,
    d1 = class extends bn.Class {
      init() {
        this.column = this.props.column(),
          this.controller = this.props.controller(),
          this.table = this.column.table;
      }
      template() {
        return bn.createElement(
          "td",
          {
            class: () => ({
              "dcg-cell": true,
              "dcg-do-not-blur": true,
              "dcg-empty": this.isEmpty(),
              "dcg-non-editable": !!this.isDisabled(),
              "dcg-computed-cell": this.isComputed(),
              "dcg-error": !!this.hasError(),
              "dcg-selected": this.shouldFocus() &&
                !this.controller.isItemReadonly(this.table.id),
            }),
            onTapStart: this.bindFn(this.focusThisCell),
          },
          bn.createElement("div", {
            class: bn.const("dcg-inner-border"),
          }),
          bn.createElement(
            "div",
            null,
            bn.createElement(ipe, {
              predicate: this.bindFn(this.hasError),
            }, () =>
              bn.createElement(
                "span",
                { class: bn.const("dcg-table-icon-error-container") },
                bn.createElement(Di, {
                  error: this.bindFn(this.getErrorMessage),
                  size: this.const("small"),
                }),
              )),
            bn.createElement(
              npe,
              { key: this.bindFn(this.getType) },
              (e) => {
                switch (e) {
                  case "editable":
                    return bn.createElement(
                      Mo,
                      {
                        latex: () => this.getValue(),
                        operatorNames: () =>
                          this.getMQConfig().autoOperatorNames,
                        brailleShouldFocus: this.bindFn(
                          this.shouldFocusEditableCell,
                        ),
                        ariaLabel: () => this.getAriaLabel("braille"),
                        onBrailleInput: (t) => this.handleLatexChanged(t),
                        onBrailleFocusedChanged: this.bindFn(
                          this.handleFocusedChanged,
                        ),
                        onBrailleKeydown: this.bindFn(
                          this.handleKeydownOnBrailleInput,
                        ),
                        selectOnFocus: this.const(true),
                        ...ui(this.props.controller()),
                      },
                      bn.createElement(Fe, {
                        latex: () => this.getValue(),
                        isFocused: () =>
                          this.shouldFocusEditableCell() &&
                          !this.isBraille(),
                        capExpressionSize: () =>
                          this.controller.getCapExpressionSize(),
                        tokenController: this.props.controller,
                        noFadeout: this.const(true),
                        config: this.bindFn(this.getMQConfig),
                        getAriaLabel: () => this.getAriaLabel("speech"),
                        getAriaPostLabel: this.bindFn(
                          this.getErrorMessage,
                        ),
                        hasError: this.const(false),
                        onUserPressedKey: (t, o) => this.handlePressedKey(t, o),
                        onUserChangedLatex: (t) => this.handleLatexChanged(t),
                        onExpressionSizeExceeded: () =>
                          this.controller.dispatch({
                            type: "expression-size-exceeded",
                          }),
                        onFocusedChanged: this.bindFn(
                          this.handleFocusedChanged,
                        ),
                        selectOnFocus: this.const(true),
                        needsSystemKeypad: () =>
                          !this.controller.isKeypadEnabled(),
                      }),
                    );
                  case "tabbable":
                  case "untabbable":
                    return bn.createElement(pl, {
                      controller: () => this.controller,
                      latex: this.bindFn(this.getValue),
                      ariaLabel: () => this.getAriaLabel("speech"),
                      brailleAriaLabel: () => this.getAriaLabel("braille"),
                      onKeypress: (
                        t,
                      ) => (this.handleKeydownOnReadonlyCell(t), true),
                      tabbable: () => e === "tabbable",
                      focusLocation: this.const({
                        type: "table",
                        id: this.table.id,
                        location: this.lookupCellPosition(),
                      }),
                    });
                }
              },
            ),
          ),
          bn.createElement("div", { class: bn.const("dcg-empty-line") }),
        );
      }
      getType() {
        return this.controller.isInEditListMode() ||
            this.column ===
              this.table.columnModels[this.table.columnModels.length - 1]
          ? "untabbable"
          : this.isColumnEditable()
          ? "editable"
          : "tabbable";
      }
      isBraille() {
        return this.controller.getBrailleMode() !== "none";
      }
      isDisabled() {
        return Uf(this.column);
      }
      isComputed() {
        return Ez(this.column);
      }
      focusThisCell(e) {
        e.wasHandled() || this.controller.isItemReadonly(this.table.id) ||
          (e.handle(),
            !this.shouldFocus() &&
            this.controller.dispatch({
              type: "set-focus-location",
              location: {
                type: "table",
                id: this.table.id,
                location: this.lookupCellPosition(),
              },
            }));
      }
      handlePressedKey(e, t) {
        let o = Fe.getFocusedMathquill();
        if (o) {
          let i = Fe.handleKeystrokeAndDecideIfSpecialEvent(o, e, t);
          e === kn && (Jr(), t == null || t.preventDefault()),
            i
              ? (this.controller.dispatch({
                type: "navigate-table-by-key",
                id: this.table.id,
                key: e,
              }),
                t == null || t.preventDefault())
              : this.handleLatexChanged(o.latex());
        }
      }
      handleKeydownOnBrailleInput(e) {
        let t = ke(e);
        if (!t) return;
        t === kn && Jr();
        let o = t === "Enter" || t === "Up" || t === "Down",
          i = os(),
          n = i && t === "Left" && i.selectionStart === 0 ||
            t === "Right" && i.selectionStart === i.value.length;
        (o || n ||
          (t === "Del" || t === "Backspace") &&
            this.getValue().length === 0) &&
          (this.controller.dispatch({
            type: "navigate-table-by-key",
            id: this.table.id,
            key: t === "Del" ? "Delete" : t,
          }),
            e.preventDefault());
      }
      handleKeydownOnReadonlyCell(e) {
        let t = ke(e);
        switch (t) {
          case "Up":
          case "Down":
          case "Left":
          case "Right":
          case "Backspace":
          case "Del":
          case "Enter":
            return this.controller.dispatch({
              type: "navigate-table-by-key",
              id: this.table.id,
              key: t,
            }),
              true;
          case "Esc":
            return Jr(), true;
        }
        return false;
      }
      handleLatexChanged(e) {
        this.getValue() !== e &&
          this.controller.dispatch({
            type: "set-tablecell-latex",
            tableId: this.table.id,
            cell: this.lookupCellPosition(),
            latex: e,
          });
      }
      shouldFocus() {
        return __dcg_shared_module_exports__["E"](
          this.lookupCellPosition(),
          wa(this.table),
        );
      }
      shouldFocusReadonlyCell() {
        return !this.controller.isInEditListMode() &&
          (this.controller.isItemReadonly(this.table.id) ||
            !!this.isDisabled()) &&
          this.shouldFocus();
      }
      shouldFocusEditableCell() {
        return !this.isDisabled() && this.shouldFocus();
      }
      isNodeWithinTableCell(e) {
        if (!e || !e.closest(".dcg-cell")) return false;
        let t = this.controller.getItemRootNodeById(this.table.id);
        return t ? ee.contains(t, e) : false;
      }
      handleFocusedChanged(e, t) {
        e
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: {
              type: "table",
              id: this.table.id,
              location: this.lookupCellPosition(),
            },
          })
          : this.isNodeWithinTableCell(t.relatedTarget) ||
            this.controller.dispatch({
              type: "blur-focus-location",
              location: {
                type: "table",
                id: this.table.id,
                location: this.lookupCellPosition(),
              },
            });
      }
      lookupCellPosition() {
        return { row: this.props.rowIdx(), column: this.column.index };
      }
      getPackedError() {
        return this.column.packedErrors[this.props.rowIdx() - 1];
      }
      hasError() {
        return !!this.getPackedError();
      }
      getErrorMessage() {
        let e = this.getPackedError();
        return e ? this.controller.unpack(e) : "";
      }
      getValue() {
        let e = this.props.rowIdx() - 1, t = this.column.index;
        return dE(this.table, e, t);
      }
      isEmpty() {
        let e = os();
        return this.getValue() === "" && Wb(e);
      }
      getAriaLabel(e) {
        if (e === "speech" && this.isComputed()) {
          return this.controller.s(
            "graphing-calculator-narration-computed-cell-role-description",
          );
        }
        if (e === "braille") {
          let t = this.lookupCellPosition(), o = t.row, i = t.column + 1;
          return this.controller.raw("r__row__c__column__", {
            row: o.toString(),
            column: i.toString(),
          });
        }
        return " ";
      }
      isColumnEditable() {
        return !this.isDisabled() &&
          !this.controller.isItemReadonly(this.table.id) &&
          !this.controller.isInEditListMode();
      }
      getMQConfig() {
        return this.controller.getMathquillConfig({});
      }
    };
  var so = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var yn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { SwitchUnion: ape, If: spe } = yn.Components,
    p1 = class extends yn.Class {
      init() {
        this.model = this.props.model(),
          this.controller = this.props.controller();
      }
      template() {
        return yn.createElement(
          "div",
          { class: yn.const("dcg-table-icon-container") },
          ape(this.bindFn(this.typeOfIcon), {
            error: () =>
              yn.createElement(Di, {
                error: () => this.controller.unpack(this.model.error),
              }),
            none: () => yn.createElement("span", null),
            icon: () =>
              yn.createElement(
                "div",
                {
                  "aria-hidden": () => !this.shouldIconBeFocused(),
                  class: yn.const("dcg-circular-icon-container"),
                  role: yn.const("button"),
                  tabIndex: yn.const("0"),
                  "aria-label": this.bindFn(this.getIconAriaLabel),
                  handleEvent: yn.const("true"),
                  "dcg-open-menu-guid": () => this.getMenuGUID(),
                  onTap: (e) => {
                    if (!e.wasHandled("dragdrop") && !e.wasLongheld()) {
                      if (this.myOptionsOpen()) {
                        return this.toggleOptions();
                      }
                      if (
                        this.controller.isInEditListMode() || e.shiftKey
                      ) return this.toggleOptions();
                      this.toggleGraphShown();
                    }
                  },
                  onLongHold: (e) => {
                    e.handle("dcg-longhold"),
                      e.handle("dcg-tap"),
                      this.toggleOptions();
                  },
                  manageFocus: this.const(
                    rt({
                      controller: this.controller,
                      location: {
                        type: "table-icon",
                        id: this.model.table.id,
                        columnId: this.model.id,
                      },
                    }),
                  ),
                },
                yn.createElement($o, {
                  iconType: this.bindFn(this.getIcon),
                  backgroundColor: this.bindFn(this.getModelColor),
                }),
                yn.createElement(spe, {
                  predicate: () => this.model.disableGraphInteractions,
                }, () =>
                  yn.createElement("i", {
                    class: yn.const(
                      "dcg-graph-interaction-disabled dcg-icon-lock",
                    ),
                    "aria-hidden": yn.const("true"),
                  })),
              ),
          }),
        );
      }
      getModelColor() {
        return xw(this.model);
      }
      getMenuGUID() {
        return this.model.guid;
      }
      myOptionsOpen() {
        return this.controller.isItemSettingsMenuOpen(this.getMenuGUID());
      }
      toggleOptions() {
        this.controller.dispatch({
          type: "toggle-item-settings-menu",
          menu: {
            type: "table-column",
            model: this.model,
            guid: this.getMenuGUID(),
            focusFirstOption: false,
          },
        });
      }
      toggleGraphShown() {
        this.controller.dispatch({
          type: "toggle-tablecolumn-hidden",
          tableId: this.model.table.id,
          columnId: this.model.id,
        });
      }
      hasError() {
        return !!this.model.error;
      }
      getIcon() {
        return this.model.shouldGraph
          ? this.controller.isInEditListMode()
            ? "none"
            : this.model.points && this.model.lines
            ? "table-points-and-lines"
            : this.model.points && !this.model.lines
            ? "table-points"
            : !this.model.points && this.model.lines
            ? "table-lines"
            : "none"
          : "hidden";
      }
      typeOfIcon() {
        return this.model.latex === "" ||
            !this.controller.getGraphSettings().config.graphpaper
          ? "none"
          : this.model.error
          ? "error"
          : this.model.suppressIcon || this.model.index === 0
          ? "none"
          : "icon";
      }
      getIconAriaLabel() {
        return this.myOptionsOpen()
          ? this.controller.s(
            "graphing-calculator-narration-hide-options",
          )
          : this.controller.isInEditListMode()
          ? this.controller.s(
            "graphing-calculator-narration-show-options",
          )
          : this.model.shouldGraph
          ? this.controller.s(
            "graphing-calculator-narration-hide-table-column",
          )
          : this.controller.s(
            "graphing-calculator-narration-show-table-column",
          );
      }
      shouldIconBeFocused() {
        let e = this.controller.getFocusLocation();
        return __dcg_shared_module_exports__["E"](e, {
          type: "table-icon",
          id: this.model.table.id,
          columnId: this.model.id,
        });
      }
    };
  var { If: u1 } = so.Components,
    h1 = class extends so.Class {
      init() {
        this.model = this.props.model(),
          this.controller = this.props.controller(),
          this.table = this.model.table;
      }
      isRightSide() {
        return this.lookupCellPosition().column >=
          this.table.columnModels.length - 1;
      }
      template() {
        return so.createElement(
          "th",
          {
            class: () => ({
              "dcg-cell": true,
              "dcg-table-header": true,
              "dcg-do-not-blur": true,
              "dcg-left": this.model.index === 0,
              "dcg-right": this.isRightSide(),
              "dcg-selected": this.shouldFocus() && !this.table.readonly,
              "dcg-error": !!this.model.error && !!this.model.latex,
              "dcg-leave-space-for-icon": this.leaveSpaceForIcon(),
              "dcg-leave-space-for-drag-icon": this.hasDragIcon(),
              "dcg-could-have-icon": !this.controller.is3dProduct() &&
                !this.isRightSide() && this.model.index > 0,
            }),
            index: () => this.model.index,
            onTapStart: this.bindFn(this.focusThisCell),
          },
          so.createElement("div", {
            class: so.const("dcg-inner-border"),
          }),
          so.createElement(u1, {
            predicate: () =>
              !this.isRightSide() &&
              (!this.controller.is3dProduct() || !!this.model.error),
          }, () =>
            so.createElement(p1, {
              model: this.props.model,
              controller: this.props.controller,
            })),
          so.createElement(
            "div",
            null,
            so.createElement(u1, {
              predicate: () =>
                !this.controller.isInEditListMode() &&
                !this.controller.isItemReadonly(this.table.id),
            }, () =>
              so.createElement(
                Mo,
                {
                  latex: () => this.model.latex || "",
                  operatorNames: () => this.getMQConfig().autoOperatorNames,
                  brailleShouldFocus: this.bindFn(this.shouldFocus),
                  ariaLabel: () => this.getAriaLabel("braille"),
                  onBrailleInput: (e) => this.handleLatexChanged(e),
                  onBrailleFocusedChanged: this.bindFn(
                    this.handleMQFocusedChanged,
                  ),
                  selectOnFocus: this.const(true),
                  onBrailleKeydown: this.bindFn(
                    this.handleKeydownOnBrailleInput,
                  ),
                  ...ui(this.props.controller()),
                },
                so.createElement(Fe, {
                  latex: () => this.model.latex || "",
                  isFocused: () =>
                    this.shouldFocus() &&
                    this.controller.getBrailleMode() === "none",
                  capExpressionSize: () =>
                    this.controller.getCapExpressionSize(),
                  tokenController: this.props.controller,
                  noFadeout: this.const(true),
                  config: this.bindFn(this.getMQConfig),
                  getAriaLabel: () => this.getAriaLabel("speech"),
                  getAriaPostLabel: this.bindFn(this.getAriaPostLabel),
                  hasError: this.const(false),
                  onUserPressedKey: (e, t) => this.handlePressedKey(e, t),
                  onUserChangedLatex: (e) => this.handleLatexChanged(e),
                  onExpressionSizeExceeded: () =>
                    this.controller.dispatch({
                      type: "expression-size-exceeded",
                    }),
                  onFocusedChanged: this.bindFn(
                    this.handleMQFocusedChanged,
                  ),
                  selectOnFocus: this.const(true),
                  needsSystemKeypad: () => !this.controller.isKeypadEnabled(),
                }),
              )),
            so.createElement(u1, {
              predicate: () =>
                this.controller.isInEditListMode() ||
                this.controller.isItemReadonly(this.table.id),
            }, () =>
              so.createElement(
                Mo,
                {
                  latex: () => this.model.latex || "",
                  operatorNames: () => this.getMQConfig().autoOperatorNames,
                  ariaLabel: () => this.getAriaLabel("braille"),
                  onBrailleInput: (e) => this.handleLatexChanged(e),
                  tabIndex: this.const(-1),
                  isStatic: this.const(true),
                  brailleShouldFocus: this.bindFn(
                    this.shouldFocusReadonlyCell,
                  ),
                  onBrailleFocusedChanged: this.bindFn(
                    this.handleMQFocusedChanged,
                  ),
                  ...ui(this.props.controller()),
                },
                so.createElement(
                  nt,
                  {
                    latex: () => this.model.latex || "",
                    config: this.bindFn(this.getMQConfig),
                    tokenController: this.props.controller,
                    getAriaLabel: () => this.getAriaLabel("speech"),
                  },
                  so.createElement("span", {
                    class: so.const(
                      "dcg-math-field dcg-cell-math-content",
                    ),
                    role: so.const("textbox"),
                    "aria-readonly": so.const("true"),
                    tabIndex: () => this.controller.isInEditListMode() ? -1 : 0,
                    onKeyDown: this.bindFn(
                      this.handleKeydownOnReadonlyCell,
                    ),
                    manageFocus: this.const({
                      shouldBeFocused: () =>
                        this.shouldFocusReadonlyCell() &&
                        this.controller.getBrailleMode() === "none",
                      onFocusedChanged: this.bindFn(
                        this.handleFocusedChanged,
                      ),
                    }),
                  }),
                ),
              )),
            so.createElement(u1, {
              predicate: this.bindFn(this.hasDragIcon),
            }, () =>
              so.createElement(
                "span",
                {
                  class: so.const("dcg-drag-icon"),
                  "dcg-drag-mode": () => this.model.dragMode,
                  style: () => ({ color: this.model.color }),
                },
                so.createElement("i", {
                  class: () => ({
                    "dcg-icon-move": this.model.dragMode === "XY",
                    "dcg-icon-move-horizontal": this.model.dragMode === "X",
                    "dcg-icon-move-vertical": this.model.dragMode === "Y",
                  }),
                  "aria-hidden": so.const("true"),
                }),
              )),
          ),
          so.createElement("div", { class: so.const("dcg-empty-line") }),
          so.createElement(
            u1,
            { predicate: () => this.isRightSide() },
            () =>
              so.createElement("span", {
                class: so.const("dcg-fade-right"),
              }),
          ),
        );
      }
      hasDragIcon() {
        return this.model.dragMode !== "NONE" && !this.model.error;
      }
      leaveSpaceForIcon() {
        if (
          this.model.error || this.controller.is3dProduct() ||
          this.model.suppressIcon
        ) return false;
        let { column: e } = this.lookupCellPosition(), t = gw(this.table);
        return e > 0 && e < t - 1;
      }
      focusThisCell(e) {
        e.wasHandled() ||
          (e.handle(),
            !this.controller.isItemReadonly(this.table.id) &&
            (this.shouldFocus() ||
              this.controller.dispatch({
                type: "set-focus-location",
                location: {
                  type: "table",
                  id: this.table.id,
                  location: this.lookupCellPosition(),
                },
              })));
      }
      handleFocusedChanged(e, t) {
        e
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: {
              type: "table",
              id: this.table.id,
              location: this.lookupCellPosition(),
            },
          })
          : this.isNodeWithinTableCell(t.relatedTarget) ||
            this.controller.dispatch({
              type: "blur-focus-location",
              location: {
                type: "table",
                id: this.table.id,
                location: this.lookupCellPosition(),
              },
            });
      }
      lookupCellPosition() {
        return { row: 0, column: this.model.index };
      }
      getAriaLabel(e) {
        let t = this.lookupCellPosition();
        return e === "speech"
          ? " "
          : this.controller.raw("h__column__", { column: t.column + 1 });
      }
      getAriaPostLabel() {
        let e = "", t = this.model;
        return t.shouldGraph && (t.points || t.lines) && !Sz(t) &&
          (e = this.controller.s(
            "graphing-calculator-narration-expression-evaluation-has-graph",
          ),
            Zo
              ? e += " " +
                this.controller.s(
                  "graphing-calculator-narration-expression-audio-trace-mac",
                )
              : e += " " +
                this.controller.s(
                  "graphing-calculator-narration-expression-audio-trace-windows",
                )),
          e;
      }
      handlePressedKey(e, t) {
        let o = Fe.getFocusedMathquill();
        o &&
          (Fe.handleKeystrokeAndDecideIfSpecialEvent(o, e, t)
            ? this.controller.dispatch({
              type: "navigate-table-by-key",
              id: this.table.id,
              key: e,
            })
            : this.handleLatexChanged(o.latex()));
      }
      handleKeydownOnBrailleInput(e) {
        let t = ke(e);
        if (!t) return;
        let o = t === "Enter" || t === "Up" || t === "Down",
          i = os(),
          n = i && t === "Left" && i.selectionStart === 0 ||
            t === "Right" && i.selectionStart === i.value.length,
          a = this.model.latex.length === 0 && Wb(i);
        (o || n || (t === "Del" || t === "Backspace") && a) &&
          (this.controller.dispatch({
            type: "navigate-table-by-key",
            id: this.table.id,
            key: t === "Del" ? "Delete" : t,
          }),
            e.preventDefault());
      }
      handleKeydownOnReadonlyCell(e) {
        let t = ke(e);
        t !== "Tab" &&
          (t === "Esc" && Jr(),
            t &&
            this.controller.dispatch({
              type: "navigate-table-by-key",
              id: this.table.id,
              key: t,
            }),
            e.preventDefault());
      }
      handleLatexChanged(e) {
        this.model.latex !== e &&
          this.controller.dispatch({
            type: "set-tablecell-latex",
            tableId: this.table.id,
            cell: this.lookupCellPosition(),
            latex: e,
          });
      }
      shouldFocus() {
        return !this.controller.isInEditListMode() &&
          __dcg_shared_module_exports__["E"](
            this.lookupCellPosition(),
            wa(this.table),
          );
      }
      shouldFocusReadonlyCell() {
        return __dcg_shared_module_exports__["E"](
          this.lookupCellPosition(),
          wa(this.table),
        );
      }
      isNodeWithinTableCell(e) {
        if (!e || !e.closest(".dcg-cell")) return false;
        let t = this.controller.getItemRootNodeById(this.table.id);
        return t ? ee.contains(t, e) : false;
      }
      handleMQFocusedChanged(e, t) {
        e
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: {
              type: "table",
              id: this.table.id,
              location: this.lookupCellPosition(),
            },
          })
          : this.isNodeWithinTableCell(t.relatedTarget) ||
            this.controller.dispatch({
              type: "blur-focus-location",
              location: {
                type: "table",
                id: this.table.id,
                location: this.lookupCellPosition(),
              },
            });
      }
      getMQConfig() {
        return this.controller.getMathquillConfig({});
      }
    };
  var { For: wR } = rr.Components,
    g1 = class extends is {
      didMountRoot(e) {
        this.onItemViewMounted(e), this.didMountContainer(e);
      }
      willUnmount() {
        this.onItemViewUnmounted();
      }
      template() {
        return rr.createElement(
          "div",
          {
            class: () => ({
              "dcg-expressionitem": true,
              "dcg-expressiontable": true,
              "dcg-readonly": this.controller.isItemReadonly(this.id),
              "dcg-inFolder": !!this.model.folderId,
              "dcg-selected": !!this.controller.isItemSelected(this.id),
              "dcg-dragging": !!this.controller.isItemBeingDragged(
                this.id,
              ),
              "dcg-faded-h": this.shouldFadeLastColumn(),
              "dcg-faded-v": this.shouldFadeLastRow(),
            }),
            "expr-id": () => this.model.id,
            didMount: this.bindFn(this.didMountRoot),
            onKeyDown: this.bindFn(this.onKeydown),
          },
          rr.createElement(
            "div",
            {
              class: rr.const(
                "dcg-fade-container dcg-disable-horizontal-scroll-to-cursor",
              ),
            },
            rr.createElement(
              "div",
              { class: rr.const("dcg-main") },
              rr.createElement(
                "div",
                {
                  class: rr.const("dcg-table-container"),
                  tabIndex: () => this.controller.isInEditListMode() ? 0 : -1,
                  "aria-label": () =>
                    this.controller.getBrailleMode() === "none"
                      ? this.controller.s(
                        "graphing-calculator-narration-expression-index-table",
                        { index: this.model.displayIndex },
                      )
                      : this.controller.s(
                        "graphing-calculator-narration-expression-index-table",
                        { index: this.model.displayIndex },
                      ),
                  didMount: this.bindFn(this.didMountContainer),
                  manageFocus: this.const({
                    shouldBeFocused: this.shouldBeFocused.bind(this),
                    onFocusedChanged: this.onFocusedChanged.bind(this),
                  }),
                },
                rr.createElement(
                  "div",
                  {
                    class: rr.const("dcg-table-sliding-container"),
                    style: () => ({
                      transform: `translateX(${this.computeScrolledX()}px)`,
                    }),
                  },
                  rr.createElement(
                    "table",
                    { class: rr.const("dcg-tabledata") },
                    rr.createElement(wR, {
                      each: () => this.getVisibleRows(),
                      key: (e) => this.getRowGUID(e),
                    }, (e) =>
                      e.type === "show-more"
                        ? rr.createElement(
                          "tr",
                          { class: rr.const("dcg-show-more-row") },
                          rr.createElement(
                            "td",
                            { colSpan: this.bindFn(this.getColSpan) },
                            this.bindFn(this.missingRowMessage),
                            rr.createElement("button", {
                              class: rr.const(
                                "dcg-show-more dcg-blue-link dcg-unstyled-button",
                              ),
                              onTap: () =>
                                this.controller.dispatch({
                                  type: "table-show-more-rows",
                                  id: this.id,
                                }),
                            }, () =>
                              this.controller.s(
                                "graphing-calculator-button-show-all-table-rows",
                              )),
                          ),
                        )
                        : e.type === "spacer-row"
                        ? rr.createElement(
                          "tr",
                          { class: rr.const("dcg-blank-row") },
                          rr.createElement("td", {
                            colSpan: this.bindFn(this.getColSpan),
                            style: () => ({
                              height: (e.endIdx - e.startIdx + 1) *
                                  this.getRowHeight() + "px",
                            }),
                          }),
                        )
                        : e.type === "header"
                        ? rr.createElement(
                          "tr",
                          {
                            "aria-rowindex": rr.const("0"),
                            class: () => ({
                              "dcg-row": !!e,
                              "dcg-braille-row":
                                this.controller.getBrailleMode() !==
                                  "none",
                            }),
                          },
                          rr.createElement(
                            wR,
                            {
                              each: () => this.model.columnModels,
                              key: (t) => t.guid,
                            },
                            (t) =>
                              rr.createElement(h1, {
                                controller: this.props.controller,
                                model: this.const(t),
                              }),
                          ),
                        )
                        : rr.createElement(
                          "tr",
                          {
                            "aria-rowindex": () => e.index,
                            class: () => ({
                              "dcg-row": !!e,
                              "dcg-braille-row":
                                this.controller.getBrailleMode() !==
                                  "none",
                            }),
                          },
                          rr.createElement(wR, {
                            each: () => this.model.columnModels,
                            key: (t) => t.guid,
                          }, (t) =>
                            rr.createElement(d1, {
                              controller: this.props.controller,
                              column: this.const(t),
                              rowIdx: () => e.index,
                            })),
                        )),
                  ),
                ),
              ),
              rr.createElement(iA, {
                controller: this.props.controller,
                table: this.props.model,
              }),
            ),
            rr.createElement(Wl, {
              controller: this.props.controller,
              model: this.props.model,
            }),
          ),
          rr.createElement(
            "span",
            {
              class: rr.const("dcg-tab dcg-action-drag"),
              handleEvent: rr.const("true"),
              tapboundary: rr.const("true"),
              disablescroll: rr.const("true"),
              onTapStart: this.bindFn(this.onDragPending),
            },
            rr.createElement(
              "span",
              { class: rr.const("dcg-num") },
              () => this.model.displayIndex,
            ),
            rr.createElement("div", {
              class: rr.const("dcg-tab-interior"),
            }),
            rr.createElement(qI, {
              model: this.props.model,
              controller: this.props.controller,
            }),
            rr.createElement(Qb, {
              model: this.props.model,
              controller: this.props.controller,
            }),
          ),
          rr.createElement(Hl, {
            controller: this.props.controller,
            id: () => this.model.id,
          }),
        );
      }
      getRowGUID(e) {
        switch (e.type) {
          case "header":
            return "header";
          case "show-more":
            return "show-more";
          case "spacer-row":
            return `spacer-${e.startIdx}-${e.endIdx}`;
          case "standard-row":
            return `row-${e.index}`;
        }
      }
      getColSpan() {
        return this.model.columnModels.length - 1;
      }
      getRowHeight() {
        return this.controller.getGraphSettings().config.projectorMode
          ? 38
          : 33;
      }
      getVisibleRows() {
        var h, u, f;
        let e = [{ type: "header" }], t = Pl(this.model) + 1;
        if (t <= 25) {
          for (let y = 1; y < t; y++) {
            e.push({ type: "standard-row", index: y });
          }
          return e;
        }
        let o = Eg(this.model);
        if (o !== void 0) {
          for (let y = 1; y < o.min; y++) {
            e.push({ type: "standard-row", index: y });
          }
          e.push({ type: "show-more" });
          for (let y = o.max; y < t; y++) {
            e.push({ type: "standard-row", index: y });
          }
          return e;
        }
        let i = Tm(this.controller),
          n = i ? i.height : 0,
          a = ee(this.node).offset(),
          s = (a ? a.top : 0) - (i ? i.top : 0),
          l =
            (f = (u = (h = this.node) == null
                  ? void 0
                  : h.querySelector(".dcg-row")) == null
                ? void 0
                : u.getBoundingClientRect().height) != null
              ? f
              : 0,
          c = this.getRowHeight();
        if (n / c > t) {
          for (let y = 1; y < t; y++) {
            e.push({ type: "standard-row", index: y });
          }
          return e;
        }
        let d = (-s - l) / c, p = (n - s) / c;
        for (let y = 1; y < t; y++) {
          let C = wa(this.model);
          if (y === t - 2 || C && C.row === y) {
            e.push({ type: "standard-row", index: y });
          } else if (y > p || y < d) {
            let E = e[e.length - 1];
            E && E.type === "spacer-row"
              ? E.endIdx = y
              : e.push({ type: "spacer-row", startIdx: y, endIdx: y });
          } else e.push({ type: "standard-row", index: y });
        }
        return e;
      }
      missingRowMessage() {
        let e = Eg(this.model);
        return e === void 0 ? "" : this.controller.s(
          "graphing-calculator-text-table-more-rows",
          { rowCount: e.max - e.min },
        );
      }
      didMountContainer(e) {
        this.node = e, ee(e).on("scroll", () => e.scrollLeft = 0);
      }
      getSelectedCell() {
        return wa(this.model);
      }
      computeScrolledX() {
        if (!this.getSelectedCell() || !this.node) return 0;
        let e = this.node.children[0],
          t = this.node.querySelector(".dcg-selected");
        if (e === null || t === null) return 0;
        let o = this.node.getBoundingClientRect(),
          i = t.getBoundingClientRect(),
          n = i.left - e.getBoundingClientRect().left,
          a = o.width - n - i.width - 80,
          s = Math.min(0, o.width - e.scrollWidth - 30);
        return a = Math.max(a, s), Math.min(0, a);
      }
      shouldFadeLastRow() {
        return Dz(this.model) && !this.isBottomFocused();
      }
      shouldFadeLastColumn() {
        return !this.isRightFocused();
      }
      isBottomFocused() {
        let e = this.getSelectedCell();
        return !!e && e.row === Pl(this.model);
      }
      isRightFocused() {
        let e = this.getSelectedCell();
        return !!e && e.column === this.model.columnModels.length - 1;
      }
      isReadonly() {
        return this.controller.isItemReadonly(this.id);
      }
      isFocused() {
        return !!this.getSelectedCell();
      }
      onKeydown(e) {
        this.controller.isInEditListMode() ||
          e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey &&
            (ke(e) === "Up"
              ? (e.preventDefault(),
                e.stopPropagation(),
                this.moveToFirstCellInColumn())
              : ke(e) === "Down"
              ? (e.preventDefault(),
                e.stopPropagation(),
                this.moveToLastCellInColumn())
              : ke(e) === "Left"
              ? (e.preventDefault(),
                e.stopPropagation(),
                this.moveToFirstCellInRow())
              : ke(e) === "Right"
              ? (e.preventDefault(),
                e.stopPropagation(),
                this.moveToLastCellInRow())
              : Ko(e) === "H" &&
                (e.preventDefault(),
                  e.stopPropagation(),
                  this.speakColumnHeader()));
      }
      moveToFirstCellInColumn() {
        let e = this.getSelectedCell();
        e &&
          this.controller.dispatch({
            type: "set-focus-location",
            location: {
              type: "table",
              id: this.id,
              location: { row: 0, column: e.column },
            },
          });
      }
      moveToLastCellInColumn() {
        let e = this.getSelectedCell();
        e &&
          this.controller.dispatch({
            type: "set-focus-location",
            location: {
              type: "table",
              id: this.id,
              location: { row: Pl(this.model), column: e.column },
            },
          });
      }
      moveToFirstCellInRow() {
        let e = this.getSelectedCell();
        e &&
          this.controller.dispatch({
            type: "set-focus-location",
            location: {
              type: "table",
              id: this.id,
              location: { row: e.row, column: 0 },
            },
          });
      }
      moveToLastCellInRow() {
        let e = this.getSelectedCell();
        e &&
          this.controller.dispatch({
            type: "set-focus-location",
            location: {
              type: "table",
              id: this.id,
              location: { row: e.row, column: Pl(this.model) - 1 },
            },
          });
      }
      speakColumnHeader() {
        let e = this.controller.s(
            "graphing-calculator-narration-table-no-column-header",
          ),
          t = this.getSelectedCell();
        if (t) {
          let o = this.model.columnModels[t.column].latex;
          o &&
            (e = gc.StaticMath(document.createElement("span")).latex(o)
              .mathspeak());
        }
        xe(e);
      }
      focusHelperOptions() {
        return {
          controller: this.controller,
          location: { type: "table-container", id: this.model.id },
        };
      }
      shouldBeFocused() {
        return Bg(this.focusHelperOptions());
      }
      onFocusedChanged(e) {
        if (this.controller.isInEditListMode()) {
          return aP(this.focusHelperOptions(), e);
        }
      }
    };
  var Bi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var m1 = class extends is {
    didMountRoot(e) {
      this.onItemViewMounted(e);
    }
    willUnmount() {
      this.onItemViewUnmounted();
    }
    template() {
      return Bi.createElement(
        "div",
        {
          class: () => ({
            "dcg-do-not-blur": true,
            "dcg-expressionitem": true,
            "dcg-readonly": this.controller.isItemReadonly(this.id),
            "dcg-expressiontext": true,
            "dcg-inFolder": !!this.model.folderId,
            "dcg-selected": !!this.controller.isItemSelected(this.id),
            "dcg-dragging": !!this.controller.isItemBeingDragged(this.id),
          }),
          "expr-id": () => this.model.id,
          onTapStart: this.bindFn(this.onMouseSelect),
          onTap: this.bindFn(this.onMouseSelect),
          didMount: this.bindFn(this.didMountRoot),
        },
        Bi.createElement(
          "div",
          { class: Bi.const("dcg-fade-container") },
          Bi.createElement(
            "div",
            { class: Bi.const("dcg-main") },
            Bi.createElement(au, {
              shouldFocus: this.bindFn(this.isFocused),
              text: () => this.model.text,
              showLinks: () => this.controller.areLinksEnabled(),
              onInput: this.bindFn(this.onInput),
              onFocusChange: this.bindFn(this.onFocusChange),
              onSpecialKey: this.bindFn(this.onSpecialKey),
              readonly: () =>
                this.controller.isInEditListMode() ||
                this.controller.isItemReadonly(this.id),
              readonlyAction: this.const({
                predicate: () => this.controller.isInEditListMode(),
                action: () => this.exitEditListMode(),
              }),
              ariaLabel: () => Xr(this.model, "edit_title"),
              placeholder: () =>
                this.controller.s(
                  "graphing-calculator-text-note-placeholder",
                ),
            }),
          ),
          Bi.createElement(Wl, {
            controller: this.props.controller,
            model: this.props.model,
          }),
        ),
        Bi.createElement(
          "span",
          {
            class: Bi.const("dcg-tab dcg-action-drag"),
            handleEvent: Bi.const("true"),
            tapboundary: Bi.const("true"),
            disablescroll: Bi.const("true"),
            onTapStart: this.bindFn(this.onDragPending),
          },
          Bi.createElement(
            "span",
            { class: Bi.const("dcg-num") },
            () => this.model.displayIndex,
          ),
          Bi.createElement("div", {
            class: Bi.const("dcg-tab-interior"),
          }),
          Bi.createElement("i", {
            class: Bi.const("dcg-icon-text"),
            "aria-hidden": Bi.const("true"),
          }),
        ),
        Bi.createElement(Hl, {
          controller: this.props.controller,
          id: () => this.model.id,
        }),
      );
    }
    onInput(e) {
      this.controller.dispatch({
        type: "set-note-text",
        id: this.id,
        text: e,
      });
    }
    onFocusChange(e) {
      e
        ? this.controller.dispatch({
          type: "set-focus-location",
          location: { type: "text", id: this.id },
        })
        : this.controller.dispatch({
          type: "blur-focus-location",
          location: { type: "text", id: this.id },
        });
    }
    onSpecialKey(e) {
      return this.controller.dispatch({
        type: "on-special-key-pressed",
        key: e,
      });
    }
    isFocused() {
      let e = this.controller.getFocusLocation();
      return !(!e || e.type !== "text" || e.id !== this.id);
    }
  };
  var Xt = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: sj, IfDefined: lpe } = Xt.Components,
    nA = class extends Xt.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Xt.createElement(
          "div",
          {
            class: () => ({
              "dcg-ticker": true,
              "dcg-expressions-scrolled": this.props.expsScrolled(),
            }),
          },
          Xt.createElement(
            "div",
            { class: Xt.const("dcg-ticker-settings-container") },
            Xt.createElement(
              "div",
              { class: Xt.const("dcg-ticker-settings-internal") },
              Xt.createElement(
                "div",
                {
                  class: Xt.const(
                    "dcg-editable-mathquill-container dcg-action-definition",
                  ),
                },
                Xt.createElement("span", {
                  class: Xt.const("dcg-ticker-label"),
                }, () => this.controller.raw("Run")),
                Xt.createElement(
                  Mo,
                  {
                    latex: () => this.getHandlerLatex(),
                    operatorNames: () => this.getMQConfig().autoOperatorNames,
                    ariaLabel: () =>
                      this.controller.s(
                        "graphing-calculator-narration-tick-action",
                      ),
                    brailleShouldFocus: () =>
                      this.getFocusedInput() === "handler",
                    onBrailleInput: (e) =>
                      this.dispatchHandlerLatexIfChanged(e),
                    onBrailleFocusedChanged: (e) =>
                      this.handleFocusedChanged("handler", e),
                    onBrailleKeydown: (e) =>
                      this.handlePressedKey("handler", e.key, e),
                    ...ui(this.controller),
                  },
                  Xt.createElement(Fe, {
                    hasError: () => !!this.getHandlerErrorString(),
                    getAriaPostLabel: () => {
                      let e = this.getHandlerErrorString();
                      return e ? this.controller.unpack(e) : "";
                    },
                    tokenController: this.props.controller,
                    capExpressionSize: this.const(false),
                    onUserChangedLatex: (e) =>
                      this.dispatchHandlerLatexIfChanged(e),
                    latex: () => this.getHandlerLatex(),
                    getAriaLabel: () =>
                      this.controller.s(
                        "graphing-calculator-narration-tick-action",
                      ),
                    isFocused: () => this.getFocusedInput() === "handler",
                    config: () => this.getMQConfig(),
                    onFocusedChanged: (e) =>
                      this.handleFocusedChanged("handler", e),
                    selectOnFocus: this.const(true),
                    noFadeout: this.const(true),
                    onUserPressedKey: (e, t) => {
                      this.handlePressedKey("handler", e, t);
                    },
                  }),
                ),
                lpe(
                  () => this.getHandlerErrorString(),
                  (e) =>
                    Xt.createElement(
                      "span",
                      {
                        class: Xt.const(
                          "dcg-clickable-info-error-container",
                        ),
                      },
                      Xt.createElement(Di, {
                        error: () => this.controller.unpack(e()),
                        size: this.const("small"),
                      }),
                    ),
                ),
              ),
              Xt.createElement(
                "div",
                {
                  class: Xt.const(
                    "dcg-editable-mathquill-container dcg-action-frequency",
                  ),
                },
                Xt.createElement("span", {
                  class: Xt.const("dcg-ticker-label"),
                }, () => this.controller.raw("every")),
                Xt.createElement(
                  Mo,
                  {
                    latex: () => this.getMinStepLatex(),
                    operatorNames: () => this.getMQConfig().autoOperatorNames,
                    ariaLabel: () =>
                      this.controller.s(
                        "graphing-calculator-label-ticker-min-step",
                      ),
                    brailleShouldFocus: () =>
                      this.getFocusedInput() === "minstep",
                    onBrailleInput: (e) =>
                      this.dispatchMinStepLatexIfChanged(e),
                    onBrailleFocusedChanged: (e) =>
                      this.handleFocusedChanged("minstep", e),
                    onBrailleKeydown: (e) =>
                      this.handlePressedKey("minstep", e.key, e),
                    ...ui(this.controller),
                  },
                  Xt.createElement(Fe, {
                    hasError: () => !!this.getMinStepErrorString(),
                    getAriaPostLabel: () => {
                      let e = this.getMinStepErrorString();
                      return e ? this.controller.unpack(e) : "";
                    },
                    capExpressionSize: this.const(false),
                    onUserChangedLatex: (e) =>
                      this.dispatchMinStepLatexIfChanged(e),
                    latex: () => this.getMinStepLatex(),
                    getAriaLabel: () =>
                      this.controller.s(
                        "graphing-calculator-label-ticker-min-step",
                      ),
                    isFocused: () => this.getFocusedInput() === "minstep",
                    config: this.bindFn(this.getMQConfig),
                    onFocusedChanged: (e) =>
                      this.handleFocusedChanged("minstep", e),
                    tokenController: this.props.controller,
                    selectOnFocus: this.const(true),
                    placeholder: this.const("0"),
                    noFadeout: this.const(true),
                    onUserPressedKey: (e, t) => {
                      this.handlePressedKey("minstep", e, t);
                    },
                  }),
                ),
                () => this.controller.raw("ms"),
                Xt.createElement(
                  Le,
                  {
                    tooltip: () =>
                      this.controller.s(
                        "graphing-calculator-label-ticker-help-tooltip",
                      ),
                    gravity: this.const("s"),
                  },
                  Xt.createElement(
                    "a",
                    {
                      "aria-label": () =>
                        this.controller.s(
                          "graphing-calculator-label-ticker-help-tooltip",
                        ),
                      class: Xt.const("dcg-ticker-toggle-help"),
                      target: Xt.const("_blank"),
                      href: Xt.const(
                        "https://help.desmos.com/hc/en-us/articles/4407725009165#h_01FB2RZQRYM62C3EB94H2TRRAX",
                      ),
                    },
                    Xt.createElement("i", {
                      class: Xt.const("dcg-icon-question-sign"),
                      "aria-hidden": Xt.const("true"),
                    }),
                  ),
                ),
              ),
              Xt.createElement(sj, {
                predicate: this.bindFn(this.shouldShowSliderPrompt),
              }, () =>
                Xt.createElement(Ec, {
                  model: () => this.props.controller().getTicker(),
                  controller: this.props.controller,
                })),
            ),
            Xt.createElement(
              "div",
              {
                class: () => ({
                  "dcg-circular-icon-container": true,
                  "dcg-disabled": this.iconDisabled(),
                }),
                "aria-label": this.bindFn(this.getIconAriaLabel),
                role: Xt.const("button"),
                tabIndex: () => this.iconDisabled() ? -1 : 0,
                "aria-disabled": this.bindFn(this.iconDisabled),
                "aria-pressed": () =>
                  this.controller.getTickerPlaying() &&
                  !this.iconDisabled(),
                onTap: this.bindFn(this.toggleTicker),
                onTapStart: () => {
                  Jr();
                },
              },
              Xt.createElement($o, { iconType: this.const("metronome") }),
              Xt.createElement("div", {
                class: () => ({
                  "dcg-metronome-bar": true,
                  "dcg-metronome-playing": this.controller.getTickerPlaying() &&
                    !this.iconDisabled(),
                }),
              }),
              Xt.createElement(sj, {
                predicate: () => !this.iconDisabled(),
              }, () =>
                Xt.createElement(
                  "div",
                  { class: Xt.const("dcg-mini-play-pause") },
                  Xt.createElement($o, {
                    iconType: this.bindFn(this.getPlayIcon),
                  }),
                )),
            ),
          ),
          Xt.createElement("i", {
            onTap: this.bindFn(this.closeTicker),
            tabIndex: () => this.controller.isInEditListMode() ? 0 : -1,
            "aria-label": () =>
              this.controller.s("graphing-calculator-label-ticker-close"),
            role: Xt.const("link"),
            class: Xt.const("dcg-icon-remove dcg-do-not-blur"),
          }),
        );
      }
      iconDisabled() {
        return !!(this.getMinStepErrorString() ||
          this.getHandlerErrorString() || !this.isHandlerMaybeValid());
      }
      isHandlerMaybeValid() {
        var t;
        return ((t = this.controller.getTicker().formula) == null
          ? void 0
          : t.handler.status) === "maybe-valid";
      }
      closeTicker() {
        this.controller.dispatch({ type: "close-ticker" });
      }
      toggleTicker() {
        this.iconDisabled() ||
          this.controller.dispatch({ type: "toggle-ticker" });
      }
      getPlayIcon() {
        return this.controller.getTickerPlaying() ? "pause" : "play";
      }
      getIconAriaLabel() {
        return this.controller.getTickerPlaying()
          ? this.controller.s("graphing-calculator-label-ticker-pause")
          : this.controller.s("graphing-calculator-label-ticker-play");
      }
      getFocusedInput() {
        let e = this.controller.getFocusLocation();
        if (!(!e || e.type !== "ticker")) return e.location;
      }
      handlePressedKey(e, t, o) {
        let i = Fe.getFocusedMathquill();
        if (i) {
          if (t === "PageUp" || t === "PageDown") {
            return o == null || o.preventDefault(),
              o == null || o.stopPropagation(),
              this.controller.dispatch({
                type: "on-special-key-pressed",
                key: t,
              });
          }
          if (
            t === "Enter" && this.shouldShowSliderPrompt() &&
            this.controller.dispatch({
              type: "create-sliders-for-ticker",
              variables: Sw(this.props.controller().getTicker()),
            }),
              t === "Esc" && this.controller.getExpressionSearchOpen() &&
              this.controller.dispatch({
                type: "close-expression-search",
              }),
              t === "Right" && e === "handler" ||
              t === "Left" && e === "minstep" || t === "Down" ||
              t === "Up"
          ) {
            if (!Fe.applyArrowKeyAndReturnIfWasAtBounds(i, t, o)) return;
            if (t === "Down" || t === "Up") {
              return this.controller.dispatch({
                type: "on-special-key-pressed",
                key: t,
              });
            }
            if (t === "Right") {
              this.handleFocusedChanged("minstep", true);
              return;
            } else if (t === "Left") {
              this.handleFocusedChanged("handler", true);
              return;
            }
          }
          i.keystroke(t, o),
            e === "handler"
              ? this.dispatchHandlerLatexIfChanged(i.latex())
              : e === "minstep" &&
                this.dispatchMinStepLatexIfChanged(i.latex());
        }
      }
      handleFocusedChanged(e, t) {
        t
          ? this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "ticker", location: e },
          })
          : this.controller.dispatch({
            type: "blur-focus-location",
            location: { type: "ticker", location: e },
          });
      }
      dispatchHandlerLatexIfChanged(e) {
        this.getHandlerLatex() !== e &&
          this.controller.dispatch({
            type: "update-ticker-handlerlatex",
            latex: e,
          });
      }
      dispatchMinStepLatexIfChanged(e) {
        this.getMinStepLatex() !== e &&
          this.controller.dispatch({
            type: "update-ticker-minsteplatex",
            latex: e,
          });
      }
      getHandlerLatex() {
        return this.controller.getTickerHandlerLatex();
      }
      getMinStepLatex() {
        return this.controller.getTickerMinStepLatex();
      }
      getMQConfig() {
        return this.controller.getMathquillConfig({
          additionalOperators: ["dt"],
        });
      }
      getHandlerErrorString() {
        return this.getHandlerLatex()
          ? I4(this.controller.getTicker())
          : void 0;
      }
      getMinStepErrorString() {
        return A4(this.controller.getTicker());
      }
      shouldShowSliderPrompt() {
        return this.controller.areSlidersEnabled()
          ? Sw(this.controller.getTicker()).length > 0
          : false;
      }
    };
  var {
      If: qs,
      IfDefined: nx,
      For: cpe,
      Switch: lj,
      SwitchUnion: dpe,
      IfElse: ppe,
    } = tt.Components,
    f1 = class extends tt.Class {
      constructor() {
        super(...arguments),
          this.guid = __dcg_shared_module_exports__["K"]("listView");
      }
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return tt.createElement(
          "div",
          { didMount: this.bindFn(this.didMountContainer) },
          tt.createElement(
            "div",
            {
              class: tt.const("dcg-exppanel-outer"),
              onDrop: this.bindFn(this.onDrop),
              style: () => this.computeExppanelOuterStyle(),
            },
            tt.createElement(qs, {
              predicate: () => this.controller.isFileDraggedOver(),
            }, () =>
              tt.createElement(
                "div",
                { class: tt.const("dcg-drop-image") },
                tt.createElement("span", null, () =>
                  this.controller.s(
                    "graphing-calculator-label-drop-image-here",
                  )),
              )),
            tt.createElement(
              "div",
              {
                class: () => {
                  var e;
                  return {
                    "dcg-exppanel-container": true,
                    "dcg-add-shadow": this.controller.shouldRenderList(),
                    "dcg-global-mute-on":
                      !!((e = this.controller.toneController) != null &&
                        e.isGlobalMuted()),
                  };
                },
                style: () => ({
                  transform: this.controller.isListVisible()
                    ? void 0
                    : this.controller.isNarrow()
                    ? "translate(0, 100%)"
                    : "translate(-100%, 0)",
                }),
              },
              tt.createElement(qs, {
                predicate: () => this.controller.shouldRenderList(),
              }, () =>
                tt.createElement(S0, {
                  controller: this.props.controller,
                  expsScrolled: () =>
                    !!this.exppanel && this.exppanel.scrollTop > 0,
                })),
              tt.createElement(qs, {
                predicate: () => this.controller.getExpressionSearchOpen(),
              }, () =>
                tt.createElement(VI, {
                  controller: this.props.controller,
                  expsScrolled: () =>
                    !!this.exppanel && this.exppanel.scrollTop > 0,
                })),
              tt.createElement(
                qs,
                { predicate: () => this.controller.getTickerVisible() },
                () =>
                  tt.createElement(nA, {
                    controller: this.props.controller,
                    expsScrolled: () =>
                      !!this.exppanel && this.exppanel.scrollTop > 0,
                  }),
              ),
              tt.createElement(qs, {
                predicate: () => this.controller.shouldRenderList(),
              }, () =>
                tt.createElement(
                  "div",
                  {
                    class: () => ({
                      "dcg-exppanel": true,
                      "dcg-disable-horizontal-scroll-to-cursor": true,
                      "dcg-isDragging": this.controller
                        .isDragDropActive(),
                      "dcg-has-background-color": this.controller
                        .hasBackgroundColor(),
                      "dcg-edit-list-mode": this.controller
                        .isInEditListMode(),
                    }),
                    onPaste: this.bindFn(this.onPaste),
                    onTapStart: this.bindFn(this.onExppanelTapstart),
                    didMount: this.bindFn(this.didMountExppanel),
                  },
                  tt.createElement(
                    "div",
                    {
                      class: tt.const("dcg-expressionlist"),
                      role: tt.const("region"),
                      "aria-label": () =>
                        this.controller.s(
                          "shared-calculator-narration-expression-list",
                        ),
                    },
                    tt.createElement(qs, {
                      predicate: () =>
                        this.controller.getShowConstructionsOpen(),
                    }, () =>
                      tt.createElement(FI, {
                        controller: this.props.controller,
                        onDragPending: (e, t) => this.onDragPending(e, t),
                      })),
                    tt.createElement(
                      "span",
                      { class: tt.const("dcg-template-expressioneach") },
                      tt.createElement(qs, {
                        predicate: () =>
                          this.controller
                            .shouldShowProgressUpdateLegend(),
                      }, () =>
                        tt.createElement(I0, {
                          controller: () => this.props.controller(),
                        })),
                      tt.createElement(cpe, {
                        each: () => this.controller.getAllItemModels(),
                        key: (e) => e.guid,
                      }, (e) =>
                        dpe(() => Az(e), {
                          shell: () => this.makeShellViewForModel(e),
                          render: () => this.makeViewForModel(e),
                          none: () => {},
                        })),
                    ),
                    tt.createElement(_0, {
                      controller: () => this.props.controller(),
                    }),
                    tt.createElement(lj, {
                      key: () => this.controller.getDraggedItemId(),
                    }, (e) => {
                      if (e) {
                        let t = this.controller.getItemModel(e);
                        return tt.createElement(x0, {
                          controller: this.props.controller,
                        }, this.makeDragCopyViewForModel(t));
                      } else return;
                    }),
                    tt.createElement("span", {
                      style: tt.const("flex:1"),
                    }),
                    nx(
                      () => this.controller.getShellView("notice"),
                      (e) =>
                        tt.createElement(qs, {
                          predicate: () => !this.controller.isKeypadOpen(),
                        }, () => {
                          let t = e();
                          return tt.createElement(t, null);
                        }),
                    ),
                    tt.createElement(qs, {
                      predicate: () => !this.controller.isKeypadOpen(),
                    }, () =>
                      tt.createElement(
                        "div",
                        { class: tt.const("dcg-expressions-branding") },
                        ppe(() => this.controller.canEditOnWeb(), {
                          true: () =>
                            tt.createElement(
                              "span",
                              {
                                role: tt.const("link"),
                                tabIndex: tt.const(0),
                                class: tt.const("dcg-edit-branding"),
                                onTap: () =>
                                  this.controller.dispatch({
                                    type: "open-on-web",
                                  }),
                              },
                              tt.createElement("div", {
                                class: tt.const("dcg-powered-by"),
                                "aria-label": () =>
                                  this.controller.s(
                                    "graphing-calculator-narration-edit-graph-on-desmos",
                                  ),
                              }, () =>
                                this.controller.s(
                                  "graphing-calculator-button-edit-graph-on-desmos-logo",
                                )),
                              tt.createElement("i", {
                                class: tt.const("dcg-icon-desmos"),
                                "aria-hidden": tt.const("true"),
                              }),
                            ),
                          false: () =>
                            tt.createElement(
                              "div",
                              null,
                              tt.createElement("div", {
                                class: tt.const("dcg-powered-by"),
                                "aria-label": () =>
                                  this.controller.s(
                                    "graphing-calculator-narration-powered-by-desmos",
                                  ),
                              }, () =>
                                this.controller.s(
                                  "graphing-calculator-label-powered-by",
                                )),
                              tt.createElement("i", {
                                class: tt.const("dcg-icon-desmos"),
                                "aria-hidden": tt.const("true"),
                              }),
                            ),
                        }),
                      )),
                  ),
                )),
            ),
            tt.createElement(GI, { controller: this.props.controller }),
          ),
          tt.createElement(qs, {
            predicate: () => this.isOptionsViewOpen("expression"),
          }, () =>
            tt.createElement(
              ps,
              {
                menuType: this.const("expression"),
                menuButtonFocusLocation: () => {
                  let e = this.getActiveExpressionModelForOptionsView();
                  return e ? { type: "expression-icon", id: e.id } : void 0;
                },
                ...this.getSharedDropdownWrapperProps(),
              },
              nx(
                this.bindFn(this.getActiveExpressionModelForOptionsView),
                (e) =>
                  tt.createElement(ny, {
                    controller: this.props.controller,
                    model: e,
                  }),
              ),
            )),
          tt.createElement(qs, {
            predicate: () => this.isOptionsViewOpen("image"),
          }, () =>
            tt.createElement(
              ps,
              {
                menuType: this.const("image"),
                menuButtonFocusLocation: () => {
                  let e = this.getActiveImageModelForOptionsView();
                  return e ? { type: "image-icon", id: e.id } : void 0;
                },
                ...this.getSharedDropdownWrapperProps(),
              },
              nx(
                this.bindFn(this.getActiveImageModelForOptionsView),
                (e) =>
                  tt.createElement(BI, {
                    controller: this.props.controller,
                    model: e,
                  }),
              ),
            )),
          tt.createElement(qs, {
            predicate: () => this.isOptionsViewOpen("slider"),
          }, () =>
            tt.createElement(
              ps,
              {
                menuType: this.const("slider"),
                menuButtonFocusLocation: () => {
                  let e = this.getActiveSliderModelForOptionsView();
                  return e ? { type: "slider-icon", id: e.id } : void 0;
                },
                ...this.getSharedDropdownWrapperProps(),
              },
              nx(
                this.bindFn(this.getActiveSliderModelForOptionsView),
                (e) =>
                  tt.createElement(zI, {
                    controller: this.props.controller,
                    model: e,
                  }),
              ),
            )),
          tt.createElement(qs, {
            predicate: () => this.isOptionsViewOpen("table-column"),
          }, () =>
            tt.createElement(
              ps,
              {
                menuType: this.const("table-column"),
                menuButtonFocusLocation: () => {
                  let e = this.getActiveColumnModelForOptionsView();
                  return e
                    ? {
                      type: "table-icon",
                      id: e.table.id,
                      columnId: e.id,
                    }
                    : void 0;
                },
                ...this.getSharedDropdownWrapperProps(),
              },
              nx(
                this.bindFn(this.getActiveColumnModelForOptionsView),
                (e) =>
                  tt.createElement(LI, {
                    controller: this.props.controller,
                    model: e,
                  }),
              ),
            )),
          tt.createElement(qs, {
            predicate: () => this.isOptionsViewOpen("table-regression"),
          }, () =>
            tt.createElement(
              ps,
              {
                menuType: this.const("table-regression"),
                menuButtonFocusLocation: () => {
                  let e = this.getActiveTableModelForOptionsView();
                  return e
                    ? { type: "table-regression-icon", id: e.id }
                    : void 0;
                },
                ...this.getSharedDropdownWrapperProps(),
              },
              nx(
                this.bindFn(this.getActiveTableModelForOptionsView),
                (e) =>
                  tt.createElement(PI, {
                    controller: this.props.controller,
                    model: e,
                  }),
              ),
            )),
        );
      }
      getSharedDropdownWrapperProps() {
        return {
          rootElSelector: this.const(".dcg-container"),
          openAriaAlert: this.const(
            this.controller.s(
              "graphing-calculator-narration-options-menu-open",
            ),
          ),
          closeAriaAlert: this.const(
            this.controller.s(
              "graphing-calculator-narration-options-menu-closed",
            ),
          ),
          focusOnOpen: this.bindFn(this.optionsViewFocusLocation),
          shouldHandleTabAndEscape: this.const(true),
          controller: this.props.controller,
        };
      }
      optionsViewFocusLocation() {
        let e = this.controller.getOpenItemMenu();
        if (!e || !("model" in e)) return "none";
        let { model: t } = e;
        if (!t) return "none";
        let o = this.controller.getFocusLocation();
        if (!o || o.type !== "expression-menu" || o.id !== t.id) {
          return "none";
        }
        switch (o.location) {
          case "start":
            return "first";
          case "end":
            return "last";
          default:
            return "none";
        }
      }
      getActiveSliderModelForOptionsView() {
        let e = this.controller.getOpenItemMenu();
        return e && e.type === "slider" && "model" in e ? e.model : void 0;
      }
      getActiveImageModelForOptionsView() {
        let e = this.controller.getOpenItemMenu();
        return e && e.type === "image" && "model" in e ? e.model : void 0;
      }
      getActiveExpressionModelForOptionsView() {
        let e = this.controller.getOpenItemMenu();
        return e && e.type === "expression" && "model" in e ? e.model : void 0;
      }
      getActiveColumnModelForOptionsView() {
        let e = this.controller.getOpenItemMenu();
        return e && e.type === "table-column" && "model" in e
          ? e.model
          : void 0;
      }
      getActiveTableModelForOptionsView() {
        let e = this.controller.getOpenItemMenu();
        return e && e.type === "table-regression" && "model" in e
          ? e.model
          : void 0;
      }
      isOptionsViewOpen(e) {
        let t = this.controller.getOpenItemMenu();
        return !!t && t.type === e;
      }
      makeShellViewForModel(e) {
        return tt.createElement(M0, {
          controller: this.props.controller,
          model: () => e,
          onDragPending: () => {},
          isDragCopy: () => false,
        });
      }
      computeExppanelOuterStyle() {
        this.getListBottomAndUpdateLastExpressionPadding();
        let { list: e } = this.controller.computeMajorLayout(),
          t = 0,
          o = e.top;
        return e.top > 0 && !this.controller.isListVisible() &&
          (o -= e.height),
          {
            position: "absolute",
            left: t + "px",
            top: o + "px",
            width: e.width + "px",
            height: e.height + "px",
          };
      }
      makeDragCopyViewForModel(e) {
        return this.makeViewForModel(e, true);
      }
      makeViewForModel(e, t = false) {
        let o;
        if (e.type === "table") {
          o = tt.createElement(g1, {
            controller: this.props.controller,
            model: () => e,
            onDragPending: (i) =>
              this.onDragPending(i, { type: "expression", calcId: e.id }),
            isDragCopy: () => t,
          });
        } else if (e.type === "folder") {
          o = tt.createElement(E0, {
            controller: this.props.controller,
            model: () => e,
            onDragPending: (i) =>
              this.onDragPending(i, { type: "expression", calcId: e.id }),
            isDragCopy: () => t,
          });
        } else if (e.type === "text") {
          o = tt.createElement(m1, {
            controller: this.props.controller,
            model: () => e,
            onDragPending: (i) =>
              this.onDragPending(i, { type: "expression", calcId: e.id }),
            isDragCopy: () => t,
          });
        } else if (e.type === "image") {
          o = tt.createElement(k0, {
            controller: this.props.controller,
            model: () => e,
            onDragPending: (i) =>
              this.onDragPending(i, { type: "expression", calcId: e.id }),
            isDragCopy: () => t,
          });
        } else if (e.type === "expression") {
          o = tt.createElement(lj, {
            key: () => t && this.controller.shouldRenderDraggedItemAsToken(),
          }, (i) =>
            i
              ? tt.createElement(Ad, {
                showParentChildrenHover: this.const(false),
                controller: this.props.controller,
                identifier: () => this.controller.getDraggedIdentifier(),
                insideMQ: this.const(false),
                insideGroup: this.const(false),
                putInTabOrder: () => false,
              })
              : tt.createElement(Wg, {
                controller: this.props.controller,
                model: () => e,
                onDragPending: (n) =>
                  this.onDragPending(n, {
                    type: "expression",
                    calcId: e.id,
                  }),
                isDragCopy: () => t,
              }));
        } else return;
        return o;
      }
      didUnmount() {
        ee(document.documentElement).off("." + this.guid);
      }
      didMountContainer(e) {
        this.node = e,
          ee(document.documentElement).on(
            "keydown." + this.guid,
            this.bindFn(this.handleKeyDown),
          );
      }
      didMountExppanel(e) {
        this.exppanel = e,
          e.onscroll = () => this.controller.markTickRequiredNextFrame();
      }
      getListBottomAndUpdateLastExpressionPadding() {
        let e = this.controller.getKeypadHeight(),
          t = this.__listBottom || 0;
        return this.__listBottom = e,
          e === 0 && t !== 0 && DG() &&
          this.padLastExpressionUntilTapEnd(t),
          e;
      }
      padLastExpression(e) {
        let t = this.node.querySelector(
          ".dcg-expressionitem.dcg-new-expression",
        );
        t.style.marginBottom = e + "px";
      }
      unpadLastExpression() {
        let e = this.node.querySelector(
          ".dcg-expressionitem.dcg-new-expression",
        );
        e.style.marginBottom = "0";
      }
      padLastExpressionUntilTapEnd(e) {
        this.padLastExpression(e),
          ee(document).on("dcg-tap.animating-bottom", () => {
            this.unpadLastExpression(),
              ee(document).off("dcg-tap.animating-bottom");
          });
      }
      handleKeyDown(e) {
        var a;
        if (this.controller.inAudioTraceMode()) return;
        let t = ke(e), o = Ko(e), i = this.controller.getSelectedItem();
        if (!i) {
          (t === "Backspace" || t === "Del") &&
            !this.controller.needsFakeKeypad() &&
            this.controller.hasMultipleItemsSelected() &&
            this.controller.dispatch({
              type: "delete-all-selected-items",
            });
          return;
        }
        if (
          e.altKey && !e.ctrlKey && !e.metaKey && e.shiftKey &&
          o === "T" && i
        ) {
          if (!this.controller.isGeometry() || !il(i)) return;
          e.preventDefault(),
            e.stopPropagation(),
            this.controller.convertToTokenAssignment(i);
          let s = this.controller.getGeometryFolder();
          if (s) {
            let c = s.index +
              this.controller.getNumberOfItemsInFolder(s.id);
            _n(i, s.id),
              i.index !== c &&
              Uu(this.controller.getListModel(), i.index, c, 1);
          }
          this.controller.ensureAtLeastOneVisibleItem();
          let l = (a = pi(i)) == null ? void 0 : a.identifier;
          l && this.controller.getShowConstructionsOpen() &&
            this.controller.dispatch({
              type: "set-focus-location",
              location: { type: "geo-token", identifier: l },
            });
          return;
        }
        let n = this.controller.getFocusLocation();
        if (
          e.ctrlKey && e.shiftKey && !e.metaKey && !e.altKey &&
          n !== void 0
        ) {
          if (o === "O") {
            if (
              e.preventDefault(),
                e.stopPropagation(),
                this.controller.getOpenItemMenu() !== void 0
            ) return;
            let s;
            if (i.type === "expression") {
              !i.sliderExists && !vb(i)
                ? (s = {
                  type: "expression",
                  model: i,
                  guid: i.guid,
                  focusFirstOption: true,
                  previousFocusLocation: n,
                },
                  this.controller.dispatch({
                    type: "set-focus-location",
                    location: { type: "expression-icon", id: i.id },
                  }))
                : i.sliderExists &&
                  (s = {
                    type: "slider",
                    model: i,
                    guid: "slider-" + i.guid,
                    focusFirstOption: true,
                    previousFocusLocation: n,
                  },
                    this.controller.dispatch({
                      type: "set-focus-location",
                      location: {
                        type: "slider-animation-properties-icon",
                        id: i.id,
                      },
                    }));
            } else if (i.type === "image") {
              s = {
                type: "image",
                model: i,
                guid: i.guid,
                focusFirstOption: true,
                previousFocusLocation: n,
              },
                this.controller.dispatch({
                  type: "set-focus-location",
                  location: { type: "image-icon", id: i.id },
                });
            } else if (
              i.type === "table" &&
              (n.type === "table" || n.type === "table-icon")
            ) {
              let l;
              if (n.type === "table") {
                let c = n.location;
                if (!c) return;
                l = i.columnModels[c.column];
              } else l = Eo(i, n.columnId);
              if (
                !l || l.latex === "" ||
                !this.controller.getGraphSettings().config.graphpaper ||
                l.error || l.index === 0
              ) return;
              s = {
                type: "table-column",
                model: l,
                guid: l.guid,
                focusFirstOption: true,
                previousFocusLocation: n,
              },
                this.controller.dispatch({
                  type: "set-focus-location",
                  location: {
                    type: "table-icon",
                    id: i.id,
                    columnId: l.id,
                  },
                });
            }
            if (!s) return;
            this.controller.dispatch({
              type: "toggle-item-settings-menu",
              menu: s,
            });
            return;
          } else if (o === "D") {
            if (
              this.controller.isItemReadonly(i.id) &&
              !this.controller.isInEditListMode()
            ) return;
            e.preventDefault(),
              e.stopPropagation(),
              this.controller.dispatch({
                type: "delete-item-and-animate-out",
                id: i.id,
                setFocusAfterDelete: true,
              });
            return;
          }
        }
        if (
          this.controller.isInEditListMode() && !e.altKey && !e.ctrlKey &&
          !e.metaKey
        ) {
          if (t === "Tab" && n !== void 0) {
            let s = this.controller.getItemModelByIndex(0);
            if (!s) return;
            let l = (n.type === "readonly-expression" &&
                  s.type === "expression" ||
                n.type === "table-container" && s.type === "table" ||
                n.type === s.type) && n.id === s.id,
              c = { type: "edit-list-toggle" },
              d = this.controller.isFocusLocationFocused(c);
            e.shiftKey && l
              ? (e.preventDefault(),
                e.stopPropagation(),
                this.controller.dispatch({
                  type: "set-focus-location",
                  location: c,
                }))
              : !e.shiftKey && d &&
                (e.preventDefault(),
                  e.stopPropagation(),
                  this.controller.dispatch({
                    type: "move-focus-to-item",
                    id: s.id,
                    where: s.type === "table" ? "container" : void 0,
                  }));
          } else {(t === "Up" || t === "Down" || t === "PageUp" ||
              t === "PageDown") &&
              this.controller.dispatch({
                type: "on-special-key-pressed",
                key: t === "Up" || t === "PageUp" ? "PageUp" : "PageDown",
              });}
          return;
        }
        if (
          t === "Esc" && this.controller.getExpressionSearchOpen() &&
          this.controller.dispatch({ type: "close-expression-search" }),
            !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey &&
            (t === "PageUp" || t === "PageDown")
        ) {
          this.controller.dispatch({
            type: "on-special-key-pressed",
            key: t,
          }), e.preventDefault();
          return;
        }
        if (
          !(document.activeElement &&
            ee.contains(document.body, document.activeElement)) &&
          !this.exppanel.contains(e.target) &&
          ee.contains(document.documentElement, e.target)
        ) {
          switch (t) {
            case "Up":
              e.preventDefault(),
                this.controller.dispatch({
                  type: "select-previous-expression",
                });
              break;
            case "Down":
              e.preventDefault(),
                this.controller.dispatch({
                  type: "select-next-expression",
                });
              break;
            case "Esc":
              e.preventDefault(),
                this.controller.dispatch({ type: "set-none-selected" });
              break;
            case "Right":
              e.preventDefault(),
                i &&
                (i.type === "expression" && i.sliderExists
                  ? (this.controller.dispatch({
                    type: "adjust-slider-by-keyboard",
                    id: i.id,
                    adjustment: "up",
                  }),
                    this.controller.dispatch({
                      type: "set-focus-location",
                      location: { type: "slider-thumb", id: i.id },
                    }))
                  : this.controller.dispatch({
                    type: "move-focus-to-item",
                    id: i.id,
                    where: "start",
                  }));
              break;
            case "Tab":
              e.preventDefault(),
                i &&
                this.controller.dispatch({
                  type: "move-focus-to-item",
                  id: i.id,
                  where: "start",
                });
              break;
            case "Left":
              e.preventDefault(),
                i &&
                (i.type === "expression" && i.sliderExists
                  ? (this.controller.dispatch({
                    type: "adjust-slider-by-keyboard",
                    id: i.id,
                    adjustment: "down",
                  }),
                    this.controller.dispatch({
                      type: "set-focus-location",
                      location: { type: "slider-thumb", id: i.id },
                    }))
                  : this.controller.dispatch({
                    type: "move-focus-to-item",
                    id: i.id,
                    where: "end",
                  }));
              break;
            case "Backspace":
              e.preventDefault(),
                i && !this.controller.isItemReadonly(i.id) &&
                this.controller.dispatch({
                  type: "upward-delete-selected-expression",
                });
              break;
            case "Del":
              e.preventDefault(),
                i && !this.controller.isItemReadonly(i.id) &&
                this.controller.dispatch({
                  type: "downward-delete-selected-expression",
                });
              break;
            case "Enter":
              e.wasHandled("create-expression-with-keyboard") ||
                (e.preventDefault(),
                  e.handle("create-expression-with-keyboard"),
                  i &&
                  this.controller.dispatch({
                    type: "on-special-key-pressed",
                    key: "Enter",
                  }));
              break;
            default:
              if (
                e.metaKey || e.ctrlKey || t === "Shift" || t === "Space"
              ) return;
              i &&
                (i.type === "table" ||
                  this.controller.dispatch({
                    type: "move-focus-to-item",
                    id: i.id,
                    where: "end",
                  }));
          }
        }
      }
      onDragPending(e, t) {
        e.preventDefault(), Jr();
        let o = { x: e.touches[0].clientX, y: e.touches[0].clientY },
          i = { x: o.x, y: o.y },
          n = setTimeout(() => {
            ee(document).off(".dragpending"), this.onDragStart(e, t, o, i);
          }, 500);
        ee(document).on("dcg-tapmove.dragpending", (a) => {
          i = { x: a.touches[0].clientX, y: a.touches[0].clientY },
            (Math.abs(i.y - o.y) > 3 || Math.abs(i.x - o.x) > 3) &&
            (clearTimeout(n),
              ee(document).off(".dragpending"),
              this.onDragStart(e, t, o, i));
        }),
          ee(document).on("dcg-tapend.dragpending", () => {
            clearTimeout(n), ee(document).off(".dragpending");
          });
      }
      onDragStart(e, t, o, i) {
        e.touches.length === 1 &&
          (e.wasHandled("dcg-longhold") ||
            this.controller.dispatch({
              type: "start-dragdrop",
              dragTarget: t,
              grabPt: o,
              mousePt: i,
            }));
      }
      onExppanelTapstart(e) {
        e.device !== "mouse" &&
          (e.target.closest(".dcg-expressionitem") || Jr());
      }
      onPaste(e) {
        let t = this.controller.getGraphSettings().config, o = j9(e);
        if (!o) return;
        let i = this.controller.getSelectedItem();
        if (
          this.controller.canLoadPastedLink(o) && i &&
          i.type === "folder" && i.title === ""
        ) {
          e.stopPropagation(),
            e.preventDefault(),
            MI(this.controller, o, (a, s) => s(null, a));
          return;
        }
        if (i && (i.type === "text" || i.type === "folder")) return;
        if (this.controller.canLoadPastedLink(o)) {
          e.stopPropagation(), e.preventDefault();
          let a = t.pasteGraphLinkCallback
            ? t.pasteGraphLinkCallback
            : (s, l) => l(null, s);
          MI(this.controller, o, a);
          return;
        }
        if (t.pasteTableData) {
          let a = Q9(o);
          if (a !== void 0) {
            return e.stopPropagation(),
              e.preventDefault(),
              this.controller.dispatch({ type: "paste-table", data: a });
          }
        }
        let n = J9(o);
        if (n !== void 0) {
          e.stopPropagation(), e.preventDefault();
          let a = [];
          n.length === 1 && n[0].numberList
            ? this.controller.dispatch({
              type: "append-number-list",
              latex: n[0].content,
            })
            : (n.forEach((s) => {
              a.push({
                type: "expression",
                id: this.controller.generateId(),
                latex: s.content,
              });
            }),
              this.controller.dispatch({
                type: "insert-several-expressions",
                expressions: a,
              }));
          return;
        }
      }
      onDrop(e) {
        if (!this.controller.areImagesEnabled()) return;
        let t = e.dataTransfer && e.dataTransfer.files;
        t && t.length &&
          this.controller.dispatch({ type: "new-images", files: t });
      }
    };
  var oc = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: upe } = oc.Components,
    hpe = 3e3,
    aA = class extends oc.Class {
      willUpdate() {
        let e = this.props.controller(),
          t = e.getAdaptiveDepthPeelingInfo();
        (t == null ? void 0 : t.status) === 1 && t.peelLayers === zy &&
          (this.visible = true,
            clearTimeout(this.timeout),
            this.timeout = setTimeout(() => {
              this.visible = false, e.dispatch({ type: "render" });
            }, hpe));
      }
      template() {
        return oc.createElement(
          upe,
          { predicate: () => this.visible },
          () =>
            oc.createElement(
              "div",
              {
                class: oc.const("dcg-adaptive-peeling-warning"),
                style: () => ({
                  left:
                    `${this.props.controller().computeMajorLayout().grapher.left}px`,
                }),
              },
              oc.createElement("span", {
                class: oc.const("dcg-warning-content"),
                tabIndex: oc.const("0"),
              }, () =>
                this.props.controller().s(
                  "graphing-calculator-label-adaptive-peel-warning",
                )),
            ),
        );
      }
    };
  var Dr = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  qt();
  var vR = class {
      constructor() {
        this.handlers = [],
          ee(document).on(
            "keydown.delegator",
            (e) => this.handleEvent(e),
          );
      }
      push(e) {
        let t = __dcg_shared_module_exports__["K"]("delegator_");
        return this.handlers.push({ token: t, handler: e }),
          () =>
            this.handlers = __dcg_shared_module_exports__["i"](
              this.handlers,
              (o) => o.token != t,
            );
      }
      handleEvent(e) {
        if (!e.isDefaultPrevented() && this.handlers.length) {
          let t = false, o = () => t = true;
          for (let { handler: i } of this.handlers.slice().reverse()) {
            if (i(e, o), t) return;
          }
        }
      }
    },
    sA = new vR();
  var Ui = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var fr = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var br = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: CR } = br.Components,
    lA = class extends br.Class {
      constructor() {
        super(...arguments),
          this.i18n = this.props.i18n(),
          this.isMounted = false,
          this.isTitleStuck = false;
      }
      template() {
        return br.createElement(
          "div",
          {
            class: () => ({
              "dcg-shared-modal-container": true,
              [this.props.class ? this.props.class() : ""]: !!this.props
                .class,
            }),
            didMount: this.bindFn(this.didMountRoot),
          },
          br.createElement(
            "div",
            {
              class: () => ({
                "dcg-shared-modal-cover": true,
                "dcg-shared-has-close-button": this.showX(),
                "dcg-shared-modal-fullscreen":
                  this.props.size() === "fullscreen",
                "dcg-shared-modal-wide": this.props.size() === "wide",
                "dcg-shared-modal-medium": this.props.size() === "medium",
                "dcg-shared-modal-narrow": this.props.size() === "narrow",
                "dcg-shared-modal-tiny": this.props.size() === "tiny",
              }),
            },
            br.createElement("div", {
              class: br.const("dcg-shared-modal-background"),
              onTap: this.props.onClose,
            }),
            br.createElement(
              "div",
              {
                class: br.const("dcg-shared-modal-transition-container"),
              },
              br.createElement(
                "div",
                {
                  class: br.const("dcg-shared-modal"),
                  role: br.const("dialog"),
                  "aria-modal": br.const("true"),
                  "aria-label": () => {
                    let e = "";
                    return this.props.ariaLabel
                      ? e = this.props.ariaLabel()
                      : this.props.title && (e = this.props.title()),
                      e;
                  },
                },
                br.createElement(
                  CR,
                  { predicate: () => this.showX() },
                  () =>
                    br.createElement(
                      "div",
                      {
                        class: br.const(
                          "dcg-shared-close-cross-container",
                        ),
                      },
                      br.createElement(
                        Le,
                        {
                          tooltip: () =>
                            this.i18n.s("shared-button-close-dialog"),
                        },
                        br.createElement(
                          "div",
                          {
                            role: br.const("button"),
                            tabIndex: br.const("0"),
                            "aria-label": () =>
                              this.i18n.s("shared-button-close-dialog"),
                            class: br.const("dcg-shared-close-cross"),
                            onTap: this.props.onClose,
                          },
                          br.createElement("i", {
                            class: br.const("dcg-icon-remove"),
                            "aria-hidden": br.const("true"),
                          }),
                        ),
                      ),
                    ),
                ),
                br.createElement(
                  "div",
                  {
                    class: br.const("dcg-shared-modal-contents-wrapper"),
                  },
                  br.createElement(CR, {
                    predicate: () => !!this.props.title && !!this.props.title(),
                  }, () =>
                    br.createElement(
                      "h1",
                      {
                        class: () => {
                          var e, t;
                          return {
                            "dcg-shared-modal-title": true,
                            "dcg-shared-left-align-title": this
                              .leftAlignTitle(),
                            "dcg-shared-modal-title--sticky":
                              !!((t = (e = this.props).withStickyTitle) !=
                                  null && t.call(e)),
                            "dcg-shared-modal-title--stuck": this.isTitleStuck,
                          };
                        },
                      },
                      br.createElement(CR, {
                        predicate: () => {
                          var e, t;
                          return !!((t = (e = this.props).withBackButton) !=
                              null && t.call(e));
                        },
                      }, () =>
                        br.createElement(
                          "button",
                          {
                            class: br.const("dcg-shared-back-button"),
                            "aria-label": () =>
                              this.i18n.s("shared-button-back"),
                            tabIndex: br.const(0),
                            onTap: this.props.onBack,
                          },
                          br.createElement("i", {
                            class: br.const(
                              "dcg-icon-chevron-left dcg-shared-back-button__icon",
                            ),
                            "aria-hidden": br.const("true"),
                          }),
                        )),
                      () => this.props.title(),
                    )),
                  br.createElement("div", {
                    class: br.const(
                      "dcg-shared-modal-scrollable-content",
                    ),
                  }, this.props.children),
                ),
              ),
            ),
          ),
        );
      }
      showX() {
        var e, t;
        return !!((t = (e = this.props).showX) != null && t.call(e));
      }
      leftAlignTitle() {
        return !!this.props.leftAlignTitle && this.props.leftAlignTitle();
      }
      didMountRoot(e) {
        var h, u, f, y;
        if (this.isMounted) return;
        this.isMounted = true;
        let t = e.querySelector(".dcg-shared-modal-contents-wrapper"),
          o = e.querySelector(".dcg-shared-modal-title");
        if (
          (u = (h = this.props).withStickyTitle) != null && u.call(h) &&
          t && o
        ) {
          let C = () => {
            this.intersectionObserver &&
              this.intersectionObserver.disconnect();
            let E = getComputedStyle(t).getPropertyValue(
              "--dcg-modal-padding",
            ).trim();
            this.intersectionObserver = new IntersectionObserver(
              ([v]) => {
                this.isTitleStuck = v.intersectionRatio < 1, this.update();
              },
              {
                root: t,
                rootMargin: NS || E === "" ? void 0 : `-${E} 0px 0px 0px`,
                threshold: [1],
              },
            ), this.intersectionObserver.observe(o);
          };
          C(),
            this.resizeObserver = new ResizeObserver(C),
            this.resizeObserver.observe(t);
        }
        let i = () => {
            var C;
            (C = e.querySelector(".dcg-shared-close-cross")) == null ||
              C.focus();
          },
          n = () => e.querySelector(".dcg-shared-modal-scrollable-content"),
          a = () => {
            let C = n();
            C &&
              (C.tabIndex = C.tabIndex >= 0 ? C.tabIndex : 0, C.focus());
          },
          s = n(),
          l = (y = (f = this.props).setFocus) == null ? void 0 : y.call(f),
          c = l === "close" && this.showX(),
          d = l === "content" || l === "close" && !this.showX() && s;
        c && i(), d && a();
        let p = x8(e);
        this.unsub = sA.push((C, E) => {
          var w, S, k, _;
          ke(C) == kn && (this.onClose(), E());
          let v = C.altKey || C.shiftKey || C.metaKey || C.ctrlKey;
          ke(C) === ld && !v &&
          ((S = (w = this.props).onArrowKey) == null ||
            S.call(w, "Left")),
            ke(C) === cd && !v &&
            ((_ = (k = this.props).onArrowKey) == null ||
              _.call(k, "Right")),
            p(C);
        });
      }
      onClose() {
        this.props.onClose && this.props.onClose();
      }
      didUnmount() {
        var e, t;
        this.isMounted &&
          (this.isMounted = false,
            (e = this.intersectionObserver) == null || e.disconnect(),
            (t = this.resizeObserver) == null || t.disconnect(),
            this.unsub());
      }
    };
  var { If: cA, Each: cj } = fr.Components,
    dA = class extends fr.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return fr.createElement(
          cA,
          { predicate: this.props.visible },
          () =>
            fr.createElement(
              lA,
              {
                size: this.const("medium"),
                onClose: this.props.onClose,
                i18n: this.const(this.controller),
                class: this.const("dcg-custom-toolbar-settings-modal"),
              },
              fr.createElement(
                "div",
                {
                  class: fr.const("dcg-btn-blue dcg-done-btn"),
                  "aria-role": fr.const("button"),
                  tabIndex: fr.const(0),
                  didMount: (e) => e.focus(),
                  onTap: this.props.onClose,
                },
                () => this.controller.s("graphing-calculator-button-done"),
              ),
              fr.createElement(
                "h1",
                { class: fr.const("dcg-shared-left-align-title") },
                () =>
                  this.controller.s(
                    "shared-calculator-text-customize-toolbar",
                  ),
              ),
              cj(this.bindFn(this.getToolGroups), {
                key: (e) => e.group,
                item: (e) =>
                  fr.createElement(
                    "div",
                    null,
                    fr.createElement(
                      "div",
                      {
                        class: fr.const(
                          "dcg-configuration-heading-row dcg-configuration-grid-row",
                        ),
                      },
                      fr.createElement(
                        "div",
                        { class: fr.const("dcg-first-column") },
                        () => e.group,
                        fr.const(" Tools"),
                      ),
                      fr.createElement("div", {
                        class: fr.const("dcg-second-column"),
                      }, fr.const("Disabled when:")),
                    ),
                    cj(() => e.dropdown || [e.current], {
                      item: (t) =>
                        fr.createElement(
                          "div",
                          {
                            class: fr.const("dcg-configuration-grid-row"),
                            "dcg-geo-tool": this.const(t),
                          },
                          fr.createElement(
                            "div",
                            { class: fr.const("dcg-first-column") },
                            fr.createElement(mt, {
                              disabled: () => !this.isToolCustomizable(t),
                              checked: () => this.getToolInfo(t).visible,
                              onChange: (o) => {
                                this.controller.dispatch({
                                  type: "set-geometry-custom-toolbar-setting",
                                  tool: t,
                                  value: {
                                    ...this.getToolInfo(t),
                                    visible: o,
                                  },
                                });
                              },
                            }, () => t),
                          ),
                          fr.createElement(
                            "div",
                            {
                              class: () => ({
                                "dcg-disabled": !this.getToolInfo(t).visible ||
                                  !this.isToolCustomizable(t),
                                "dcg-mathquill-condition-container": true,
                                "dcg-second-column": true,
                              }),
                            },
                            fr.createElement(cA, {
                              predicate: () =>
                                !!this.getToolLatexError(t) &&
                                this.getToolInfo(t).visible,
                            }, () =>
                              fr.createElement(
                                "div",
                                {
                                  class: fr.const(
                                    "dcg-latex-error-container",
                                  ),
                                },
                                fr.createElement(Di, {
                                  error: () => this.getToolLatexError(t) || "",
                                }),
                              )),
                            fr.createElement(cA, {
                              predicate: () =>
                                this.isToolCustomizable(t) &&
                                this.getToolInfo(t).visible,
                            }, () =>
                              fr.createElement(
                                Mo,
                                {
                                  latex: () => this.getToolLatex(t),
                                  operatorNames: this.bindFn(
                                    this.autoOperatorNames,
                                  ),
                                  ariaLabel: () => this.getToolAria(t),
                                  brailleShouldFocus: () =>
                                    this.focusedLatexTool === t,
                                  onBrailleInput: (o) => {
                                    this.controller.dispatch({
                                      type:
                                        "set-geometry-custom-toolbar-setting",
                                      tool: t,
                                      value: {
                                        ...this.getToolInfo(t),
                                        disabledLatex: o,
                                      },
                                    });
                                  },
                                  onBrailleFocusedChanged: (o) => {
                                    this.focusedLatexTool === t && !o
                                      ? this.focusedLatexTool = void 0
                                      : o && (this.focusedLatexTool = t);
                                  },
                                  onBrailleKeydown: () => {},
                                  ...ui(this.controller),
                                },
                                fr.createElement(Fe, {
                                  latex: () => this.getToolLatex(t),
                                  getAriaLabel: () => this.getToolAria(t),
                                  noFadeout: this.const(true),
                                  getAriaPostLabel: () =>
                                    this.getToolLatexError(t) || "",
                                  isFocused: () => this.focusedLatexTool === t,
                                  tokenController: this.props.controller,
                                  capExpressionSize: () =>
                                    this.controller
                                      .getCapExpressionSize(),
                                  config: () =>
                                    this.controller.getMathquillConfig(
                                      {},
                                    ),
                                  hasError: () => !!this.getToolLatexError(t),
                                  onUserChangedLatex: (o) => {
                                    this.controller.dispatch({
                                      type:
                                        "set-geometry-custom-toolbar-setting",
                                      tool: t,
                                      value: {
                                        ...this.getToolInfo(t),
                                        disabledLatex: o,
                                      },
                                    });
                                  },
                                  onExpressionSizeExceeded: () =>
                                    this.controller.dispatch({
                                      type: "expression-size-exceeded",
                                    }),
                                  onFocusedChanged: (o) => {
                                    this.focusedLatexTool === t && !o
                                      ? this.focusedLatexTool = void 0
                                      : o && (this.focusedLatexTool = t);
                                  },
                                  onSelectionChanged: () => {
                                    this.controller.runAfterDispatch(
                                      () => {
                                        this.controller.dispatch({
                                          type: "render",
                                        });
                                      },
                                    );
                                  },
                                  needsSystemKeypad: () =>
                                    !this.controller.isKeypadEnabled(),
                                }),
                              )),
                            fr.createElement(cA, {
                              predicate: () => !this.getToolInfo(t).visible,
                            }, () =>
                              fr.createElement(
                                "div",
                                {
                                  class: fr.const(
                                    "dcg-disabled-condition-wrapper",
                                  ),
                                },
                                fr.createElement(
                                  Mo,
                                  {
                                    latex: () => this.getToolLatex(t),
                                    operatorNames: this.bindFn(
                                      this.autoOperatorNames,
                                    ),
                                    ariaLabel: () => this.getToolAria(t),
                                    isStatic: this.const(true),
                                    brailleShouldFocus: this.const(false),
                                    onBrailleFocusedChanged: () => {},
                                    ...ui(this.controller),
                                  },
                                  fr.createElement(nt, {
                                    latex: () => this.getToolLatex(t),
                                    config: () =>
                                      this.controller.getMathquillConfig(
                                        {},
                                      ),
                                    getAriaLabel: () => this.getToolAria(t),
                                  }),
                                ),
                              )),
                          ),
                        ),
                    }),
                  ),
              }),
            ),
        );
      }
      getToolAria(e) {
        return this.controller.s(
          "shared-calculator-narration-disable-tool",
          { tool: e },
        );
      }
      autoOperatorNames() {
        return this.props.controller().getMathquillConfig({})
          .autoOperatorNames;
      }
      getToolLatex(e) {
        return this.getToolInfo(e).disabledLatex || "";
      }
      isToolCustomizable(e) {
        return e !== "selection" && e !== "box-selection";
      }
      getToolGroups() {
        let e = {
          group: "transformation",
          current: "translate",
          dropdown: fy,
        };
        return [...qG(), e];
      }
      getToolLatexError(e) {
        let t = this.controller.getGeometryToolbarModel(), o = Kz(t, e);
        if (o) return this.controller.unpack(o);
      }
      getToolInfo(e) {
        let t = this.controller.getGeometryToolbarModel();
        return { tool: e, ...t.toolbarState[e] };
      }
    };
  var { If: dj } = Ui.Components,
    pA = class extends Ui.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Ui.createElement(
          dj,
          { predicate: () => this.shouldShowAuthorFeaturesSection() },
          () =>
            Ui.createElement(
              "div",
              {
                class: Ui.const(
                  "dcg-options-menu-section dcg-author-mode-section",
                ),
              },
              Ui.createElement(
                "div",
                { class: Ui.const("dcg-options-menu-section-title") },
                () =>
                  this.controller.s(
                    "shared-calculator-narration-author-mode",
                  ),
                Ui.createElement(go, {
                  ariaLabel: () =>
                    this.controller.s(
                      "shared-calculator-narration-author-mode",
                    ),
                  toggled: this.bindFn(this.isAuthorMode),
                  onChange: () => {
                    this.controller.dispatch({
                      type: "set-author-mode",
                      enabled: !this.isAuthorMode(),
                    });
                  },
                }),
              ),
              Ui.createElement(dj, {
                predicate: () => this.isAuthorMode(),
              }, () =>
                Ui.createElement(
                  "div",
                  { class: Ui.const("dcg-author-features-container") },
                  Ui.createElement(
                    "div",
                    { class: Ui.const("dcg-toolbar-customization") },
                    Ui.createElement(
                      "span",
                      null,
                      Ui.const("Geometry Tools:"),
                    ),
                    Ui.createElement(vo, {
                      theme: this.const("mini"),
                      ariaGroupLabel: () =>
                        this.controller.s(
                          "graphing-calculator-narration-configure-toolbar",
                        ),
                      staticConfig: this.bindFn(
                        this.getConfigurationOptions,
                      ),
                    }),
                  ),
                  Ui.createElement(mt, {
                    checked: () =>
                      this.controller.getGraphSettings().hideCustomColors,
                    onChange: (e) =>
                      this.controller.dispatch({
                        type: "set-graph-settings",
                        hideCustomColors: e,
                      }),
                  }, () =>
                    this.controller.s(
                      "shared-calculator-label-hide-custom-colors",
                    )),
                  Ui.createElement(dA, {
                    controller: this.props.controller,
                    onClose: () => {
                      this.customGeometryToolsSettingsModal = false,
                        this.controller.dispatch({ type: "render" });
                    },
                    visible: () => this.customGeometryToolsSettingsModal,
                  }),
                )),
            ),
        );
      }
      getToolbar() {
        return this.controller.getGeometryToolbarModel().toolbar;
      }
      setToolbar(e) {
        e === "custom" && (this.customGeometryToolsSettingsModal = true),
          this.controller.dispatch({
            type: "set-geometry-toolbar",
            toolbar: e,
          });
      }
      getConfigurationOptions() {
        return [{
          key: "all",
          label: () => this.controller.raw("All"),
          selected: () => this.getToolbar() === "all",
          onSelect: () => this.setToolbar("all"),
        }, {
          key: "none",
          label: () => this.controller.raw("None"),
          selected: () => this.getToolbar() === "none",
          onSelect: () => this.setToolbar("none"),
        }, {
          key: "custom",
          label: () => this.controller.raw("Custom"),
          selected: () => this.getToolbar() === "custom",
          onSelect: () => this.setToolbar("custom"),
        }];
      }
      shouldShowAuthorFeaturesSection() {
        return this.controller.authorFeaturesAvailable();
      }
      isAuthorMode() {
        return this.controller.shouldShowAuthorFeatures();
      }
    };
  var { If: uA } = Dr.Components,
    b1 = class extends Dr.Class {
      init() {
        this.controller = this.props.controller();
      }
      template() {
        return Dr.createElement(
          "div",
          {
            class: () => ({
              "dcg-geometry-settings-container": true,
              "dcg-popover": true,
              "dcg-left": true,
              "dcg-constrained-height-popover": true,
              "dcg-generic-options-menu": true,
              "dcg-no-geometry-header": !this.controller
                .shouldShowGeoToolbar(),
            }),
            style: this.bindFn(this.getContainerStyle),
            didMount: this.bindFn(this.didMountContainer),
            didUnmount: this.bindFn(this.didUnmountContainer),
          },
          Dr.createElement(
            "div",
            {
              class: Dr.const("dcg-popover-interior"),
              role: Dr.const("region"),
              "aria-label": () =>
                this.controller.s(
                  "graphing-calculator-label-tooltip-geometry-settings",
                ),
            },
            Dr.createElement(
              "div",
              { class: Dr.const("dcg-options-menu-section") },
              Dr.createElement(Xy, { controller: this.props.controller }),
              Dr.createElement(uA, {
                predicate: () =>
                  !this.controller.getLockViewportConfigSetting(),
              }, () =>
                Dr.createElement(Sm, {
                  controller: this.props.controller,
                })),
              Dr.createElement(uA, {
                predicate: () => this.controller.getHiddenGeoItemCount() > 0,
              }, () =>
                Dr.createElement(mt, {
                  onChange: this.bindFn(this.toggleGhostMode),
                  checked: () => this.controller.getGhostMode(),
                  manageFocus: this.const(
                    rt({
                      controller: this.controller,
                      location: {
                        type: "settings",
                        location: "hidden-objects",
                      },
                    }),
                  ),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-label-settings-hidden-objects",
                    { count: this.controller.getHiddenGeoItemCount() },
                  ))),
            ),
            Dr.createElement(
              "div",
              { class: Dr.const("dcg-options-menu-section") },
              Dr.createElement(
                "div",
                { class: Dr.const("dcg-options-menu-section-title") },
                () =>
                  this.controller.s(
                    "graphing-calculator-label-settings-grid",
                  ),
                Dr.createElement(go, {
                  ariaLabel: () =>
                    this.controller.s(
                      "graphing-calculator-label-settings-grid",
                    ),
                  toggled: this.bindFn(this.getShowGrid),
                  onChange: this.bindFn(this.toggleGrid),
                }),
              ),
              Dr.createElement(uA, {
                predicate: this.bindFn(this.getShowGrid),
              }, () =>
                Dr.createElement(mt, {
                  onChange: this.bindFn(this.toggleMinorGridlines),
                  checked: this.bindFn(this.getMinorGridlines),
                }, () =>
                  this.controller.s(
                    "graphing-calculator-label-settings-minor-gridlines",
                  ))),
            ),
            Dr.createElement(
              "div",
              { class: Dr.const("dcg-options-menu-section") },
              Dr.createElement(
                "div",
                { class: Dr.const("dcg-options-menu-section-title") },
                () => this.controller.s("graphing-calculator-label-axes"),
                Dr.createElement(go, {
                  ariaLabel: () =>
                    this.controller.s("graphing-calculator-label-axes"),
                  toggled: this.bindFn(this.getShowAxes),
                  onChange: this.bindFn(this.toggleAxes),
                }),
              ),
              Dr.createElement(uA, {
                predicate: this.bindFn(this.getShowAxes),
              }, () =>
                Dr.createElement(
                  "div",
                  null,
                  Dr.createElement(mt, {
                    onChange: this.bindFn(this.toggleAxisNumbers),
                    checked: this.bindFn(this.getAxisNumbers),
                  }, () =>
                    this.controller.s(
                      "graphing-calculator-label-settings-axis-numbers",
                    )),
                  Dr.createElement(
                    "div",
                    null,
                    Dr.createElement(mt, {
                      onChange: this.bindFn(this.toggleArrows),
                      checked: () => this.getAxisArrowMode() !== "NONE",
                    }, () =>
                      this.controller.s(
                        "graphing-calculator-label-settings-arrows",
                      )),
                  ),
                )),
            ),
            Dr.createElement(Jy, { controller: this.props.controller }),
            Dr.createElement(pA, { controller: this.props.controller }),
            Dr.createElement(rc, {
              setup: this.const({
                controller: this.controller,
                type: "advanced",
              }),
            }),
            Dr.createElement("div", { class: Dr.const("dcg-arrow") }),
          ),
        );
      }
      toggleGhostMode() {
        this.controller.dispatch({
          type: "set-ghost-mode",
          value: !this.controller.getGhostMode(),
        });
      }
      didMountContainer(e) {
        this.node = e,
          ee(document.documentElement).on(
            "dcg-tapstart.geometry-settings-view wheel.geometry-settings-view",
            (t) => {
              this.eventShouldClosePopover(t) &&
                this.controller.dispatch({
                  type: "close-graph-settings",
                  focusIconAfterClose: t.device === "keyboard",
                });
            },
          ),
          this.unsub = sA.push((t) => {
            let o = ke(t);
            if (
              o === "Esc" &&
              this.controller.dispatch({
                type: "close-graph-settings",
                focusIconAfterClose: true,
              }),
                this.controller.isGraphSettingsOpen() && o === "Tab" &&
                !t.altKey && !t.metaKey && !t.ctrlKey
            ) {
              let i = this.controller.getFocusLocation();
              if (!i || i.type !== "settings") return;
              t.shiftKey
                ? t.shiftKey &&
                  (i.location === "default-size"
                    ? (this.controller.dispatch({
                      type: "set-focus-location",
                      location: { type: "settings", location: "icon" },
                    }),
                      t.preventDefault(),
                      t.stopPropagation())
                    : i.location === "icon" &&
                      (this.controller.dispatch({
                        type: "set-focus-location",
                        location: {
                          type: "settings",
                          location: "degree-mode",
                        },
                      }),
                        t.preventDefault(),
                        t.stopPropagation()))
                : i.location === "icon"
                ? (this.controller.dispatch({
                  type: "set-focus-location",
                  location: {
                    type: "settings",
                    location: "default-size",
                  },
                }),
                  t.preventDefault(),
                  t.stopPropagation())
                : i.location === "degree-mode" &&
                  (this.controller.dispatch({
                    type: "set-focus-location",
                    location: { type: "settings", location: "icon" },
                  }),
                    t.preventDefault(),
                    t.stopPropagation());
            }
          });
      }
      didUnmountContainer() {
        ee(document.documentElement).off(".geometry-settings-view"),
          this.unsub();
      }
      didUpdate() {
        if (!this.controller.isGraphSettingsOpen()) return;
        let e = this.controller.getKeypadHeight();
        e !== this.cachedKeypadHeight && document.activeElement &&
        this.node.contains(document.activeElement) &&
        tc(
          document.activeElement,
          this.node.querySelector(".dcg-popover-interior"),
          50,
        ), this.cachedKeypadHeight = e;
      }
      eventShouldClosePopover(e) {
        let t = e.target,
          o = this.node.contains(t),
          i = !!t.closest(".dcg-action-settings"),
          n = this.isMathquillFocused() && !!t.closest(".dcg-keypad"),
          a = !!t.closest(".dcg-action-undo") ||
            !!t.closest(".dcg-action-redo");
        return !(o || i || n || a);
      }
      isMathquillFocused() {
        return this.getFocusedLimit() !== void 0;
      }
      getFocusedLimit() {
        let e = this.controller.getFocusLocation();
        if (e && e.type === "settings") return e.location;
      }
      getShowXAxis() {
        return !!this.controller.getGraphSettings().showXAxis;
      }
      toggleAxes() {
        this.controller.dispatch({
          type: "set-graph-settings",
          showXAxis: !this.getShowXAxis(),
          showYAxis: !this.getShowXAxis(),
        });
      }
      getShowAxes() {
        return !!this.controller.getGraphSettings().showXAxis;
      }
      getAxisNumbers() {
        return !!this.controller.getGraphSettings().xAxisNumbers;
      }
      toggleAxisNumbers() {
        let e = this.getAxisNumbers();
        this.controller.dispatch({
          type: "set-graph-settings",
          xAxisNumbers: !e,
          yAxisNumbers: !e,
          polarNumbers: !e,
        });
      }
      getMinorGridlines() {
        return this.controller.getGraphSettings()
          .xAxisMinorSubdivisions === 0;
      }
      toggleMinorGridlines() {
        let e = this.getMinorGridlines() ? 1 : 0;
        this.controller.dispatch({
          type: "set-graph-settings",
          yAxisMinorSubdivisions: e,
          xAxisMinorSubdivisions: e,
        });
      }
      getAxisArrowMode() {
        return this.controller.getGraphSettings().xAxisArrowMode;
      }
      getShowGrid() {
        return this.controller.getGraphSettings().showGrid;
      }
      toggleGrid() {
        this.controller.dispatch({
          type: "set-graph-settings",
          showGrid: !this.getShowGrid(),
        });
      }
      toggleArrows() {
        let e = this.getAxisArrowMode() === "NONE" ? "BOTH" : "NONE";
        this.controller.dispatch({
          type: "set-graph-settings",
          xAxisArrowMode: e,
          yAxisArrowMode: e,
        });
      }
      getContainerStyle() {
        return this.controller.getKeypadHeight() ? "bottom: 0" : "";
      }
    };
  var jd = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    { Switch: gpe } = jd.Components,
    mA = class extends jd.Class {
      constructor() {
        super(...arguments), this.frames = 0, this.prevTime = 0;
      }
      init() {
        var t;
        this.current = 0,
          this.panels = {},
          this.panels.fps = new x1({
            name: "fps",
            yMax: 120,
            fg: "#0ff",
            bg: "#002",
          }),
          this.panels.evaluator = new x1({
            name: "eval",
            yMax: 250,
            fg: "#f80",
            bg: "#210",
          }),
          this.panels.mem = new x1({
            name: "MB",
            yMax: this.getMemory().jsHeapSizeLimit / 2 ** 20,
            fg: "#f08",
            bg: "#201",
          }),
          this.list = Object.keys(this.panels),
          this.props.controller().onEvaluatorChangesSpy = (o, i) => {
            var n;
            this.props.controller().isThreeDMode() || this.frame(),
              this.panels.evaluator.update(
                (n = i.timeInWorker) != null ? n : NaN,
              );
          };
        let e = (t = this.props.controller().getGrapher3d()) == null
          ? void 0
          : t.webglLayer;
        e && (e.debugOnlyMeasureGPUTiming = true,
          e.onRenderSpy = () => {
            this.frame();
          });
      }
      willUnmount() {
        this.props.controller().onEvaluatorChangesSpy = void 0;
      }
      template() {
        return jd.createElement(
          "div",
          {
            class: jd.const("dcg-performance-meter"),
            onTap: () => {
              this.current = (this.current + 1) % this.list.length,
                this.update();
            },
          },
          jd.createElement(
            gpe,
            { key: () => this.list[this.current] },
            (e) =>
              jd.createElement("div", {
                didMount: (t) => {
                  t.appendChild(this.panels[e].dom);
                },
              }),
          ),
        );
      }
      frame() {
        this.frames++;
        let e = (performance || Date).now();
        return e >= this.prevTime + 1e3 &&
          (this.panels.fps.update(
            this.frames * 1e3 / (e - this.prevTime),
          ),
            this.prevTime = e,
            this.frames = 0,
            this.panels.mem.update(
              this.getMemory().usedJSHeapSize / 2 ** 20,
            )),
          e;
      }
      getMemory() {
        if (self.performance && "memory" in self.performance) {
          let e = self.performance.memory;
          return {
            usedJSHeapSize: e.usedJSHeapSize,
            totalJSHeapSize: e.totalJSHeapSize,
            jsHeapSizeLimit: e.jsHeapSizeLimit,
          };
        } else {return {
            usedJSHeapSize: NaN,
            totalJSHeapSize: NaN,
            jsHeapSizeLimit: NaN,
          };}
      }
    },
    Hs = Math.round(window.devicePixelRatio || 1),
    SR = 80 * Hs,
    pj = 48 * Hs,
    uj = 3 * Hs,
    hj = 2 * Hs,
    hA = 3 * Hs,
    y1 = 15 * Hs,
    ER = 74 * Hs,
    gA = 30 * Hs,
    x1 = class {
      constructor(e) {
        this.values = [],
          this.minValue = 1 / 0,
          this.maxValue = 0,
          this.dom = document.createElement("canvas"),
          this.name = e.name,
          this.yMax = e.yMax,
          this.fg = e.fg,
          this.bg = e.bg,
          this.dom.width = SR,
          this.dom.height = pj,
          this.dom.style.cssText = "width:80px;height:48px";
        let t = this.dom.getContext("2d");
        if (!t) throw new Error("Could not get context");
        this.context = t,
          t.font = "bold " + 9 * Hs + "px Helvetica,Arial,sans-serif",
          t.textBaseline = "top",
          t.fillStyle = this.bg,
          t.fillRect(0, 0, SR, pj),
          t.fillStyle = this.fg,
          t.fillText(this.name, uj, hj),
          t.fillRect(hA, y1, ER, gA),
          t.fillStyle = this.bg,
          t.globalAlpha = .9,
          t.fillRect(hA, y1, ER, gA);
      }
      update(e) {
        this.values.push(e),
          this.values.length > ER / Hs && this.values.shift(),
          this.minValue = Math.min(this.minValue, e),
          this.maxValue = Math.max(this.maxValue, e),
          this.draw();
      }
      draw() {
        this.context.fillStyle = this.bg,
          this.context.globalAlpha = 1,
          this.context.fillRect(0, 0, SR, y1),
          this.context.fillStyle = this.fg,
          this.context.fillText(
            Math.round(this.values[this.values.length - 1]) + " " +
              this.name + " (" + Math.round(this.minValue) + "-" +
              Math.round(this.maxValue) + ")",
            uj,
            hj,
          ),
          this.context.fillStyle = this.fg,
          this.context.fillRect(hA + Hs, y1, this.values.length * Hs, gA),
          this.context.fillStyle = this.bg,
          this.context.globalAlpha = .9;
        for (let e = 0; e < this.values.length; e++) {
          let t = this.values[e];
          this.context.fillRect(
            hA + (e + 1) * Hs,
            y1,
            Hs,
            Math.round((1 - t / this.yMax) * gA),
          );
        }
      }
    };
  var { If: Fh } = Wt.Components,
    w1 = class extends Wt.Class {
      init() {
        this.controller = this.props.controller();
      }
      settings() {
        return this.controller.getGraphSettings();
      }
      template() {
        return Wt.createElement(
          "div",
          {
            class: this.const(cf),
            style: Wt.const(
              "width: 100%; height: 100%; position: relative;",
            ),
          },
          Wt.createElement(
            "div",
            {
              class: () => ({
                "dcg-container": true,
                "dcg-fullscreen": !this.controller.isListVisible(),
                "dcg-narrow": this.controller.isNarrow(),
                "dcg-projector-mode": this.settings().config.projectorMode,
                "dcg-inverted-colors": !!this.settings().config
                  .invertedColors,
                "dcg-inverted-swatches": this.controller.invertSwatches(),
                "dcg-EDIT-LIST-MODE": this.controller.isInEditListMode(),
                "dcg-no-graphpaper": !this.settings().config.graphpaper,
                "dcg-no-branding": !this.settings().config.branding,
                "dcg-no-expression-topbar": !this.settings().config
                  .expressionsTopbar,
                "dcg-default-border": !!this.settings().config.border,
                "dcg-no-hyperlinks": !this.settings().config.links,
                "dcg-has-background-color": this.controller
                  .hasBackgroundColor(),
                "dcg-is-interactive": this.settings().config.expressions ||
                  !(this.settings().config.lockViewport ||
                    this.settings().userLockedViewport),
              }),
              style: () => ({
                "font-size": this.settings().config.fontSize + "px",
                background: this.controller.hasTransparentBackground()
                  ? "none"
                  : void 0,
                "--dcg-custom-background-color":
                  this.controller.hasBackgroundColor()
                    ? this.controller.getBackgroundColor()
                    : void 0,
                "--dcg-custom-background-color-shaded":
                  this.controller.hasBackgroundColor()
                    ? this.controller.getPillboxBackgroundColor()
                    : void 0,
                "--dcg-custom-text-color": this.controller.hasTextColor()
                  ? this.controller.getTextColor()
                  : void 0,
              }),
              role: Wt.const("application"),
              "aria-label": () =>
                this.controller.isGeometry()
                  ? this.controller.s(
                    "graphing-calculator-narration-main-desmos-geometry",
                  )
                  : this.controller.s(
                    "graphing-calculator-narration-main-desmos-graphing-calculator",
                  ),
              "x-ms-format-detection": Wt.const("none"),
              didMount: this.bindFn(this.didMountRoot),
            },
            Wt.createElement(
              Fh,
              {
                predicate: () =>
                  this.controller.getGraphSettings().config.expressions,
              },
              () =>
                Wt.createElement(f1, {
                  controller: this.props.controller,
                }),
            ),
            Wt.createElement(Fh, {
              predicate: () =>
                this.controller.isListEnabled() &&
                !this.controller.isListVisible() &&
                (!this.controller.isGeometry() ||
                  this.controller.isNarrow()),
            }, () =>
              Wt.createElement(
                "div",
                {
                  class: () => ({
                    "dcg-overgraph-icon-container": true,
                    "dcg-bottom-right": this.controller.isNarrow(),
                  }),
                },
                Wt.createElement(
                  Le,
                  {
                    tooltip: () =>
                      this.controller.s(
                        "graphing-calculator-label-tooltip-show-list",
                      ),
                    gravity: () => this.controller.isNarrow() ? "n" : "s",
                  },
                  Wt.createElement(
                    "div",
                    {
                      class: () => ({
                        "dcg-show-expressions-tab": true,
                        "dcg-overgraph-icon": true,
                        "dcg-rotated": this.controller.isNarrow(),
                      }),
                      "aria-label": () =>
                        this.controller.s(
                          "graphing-calculator-label-tooltip-show-list",
                        ),
                      role: Wt.const("button"),
                      tabIndex: Wt.const("0"),
                      onTap: (e) => {
                        this.controller.dispatch({
                          type: "show-expressions-list",
                          focusHideIcon: e.device === "keyboard",
                        });
                      },
                      manageFocus: this.const(
                        rt({
                          controller: this.controller,
                          location: { type: "show-expression-list-btn" },
                        }),
                      ),
                    },
                    Wt.createElement("i", {
                      class: Wt.const("dcg-icon-show"),
                      "aria-hidden": Wt.const("true"),
                    }),
                  ),
                ),
              )),
            Wt.createElement(Fh, {
              predicate: this.bindFn(this.showHamburger),
            }, () =>
              Wt.createElement(
                "div",
                { class: Wt.const("dcg-overgraph-icon-container") },
                Wt.createElement(
                  Le,
                  {
                    tooltip: () =>
                      this.controller.s(
                        "graphing-calculator-label-tooltip-open-graph",
                      ),
                    gravity: this.const("s"),
                  },
                  Wt.createElement(
                    "div",
                    {
                      role: Wt.const("button"),
                      "aria-label": () =>
                        this.controller.s(
                          "graphing-calculator-label-tooltip-open-graph",
                        ),
                      class: Wt.const(
                        "dcg-action-opendrawer dcg-in-api-action-opendrawer dcg-overgraph-icon",
                      ),
                      onTap: () =>
                        this.controller.dispatch({ type: "open-drawer" }),
                    },
                    Wt.createElement("i", {
                      class: Wt.const("dcg-icon-hamburger"),
                      "aria-hidden": Wt.const("true"),
                    }),
                  ),
                ),
              )),
            Wt.createElement(kI, { controller: this.props.controller }),
            Wt.createElement(aA, { controller: this.props.controller }),
            Wt.createElement(
              Fh,
              {
                predicate: () =>
                  this.controller.isGeoUIActive() &&
                  this.controller.getGraphSettings().config
                    .settingsMenu &&
                  this.controller.isGraphSettingsOpen(),
              },
              () =>
                Wt.createElement(b1, {
                  controller: this.props.controller,
                }),
            ),
            Wt.createElement(
              Fh,
              { predicate: () => this.controller.shouldShowGeoToolbar() },
              () =>
                Wt.createElement(yI, {
                  controller: this.props.controller,
                }),
            ),
            Wt.createElement(_I, { controller: this.props.controller }),
            Wt.createElement("div", {
              class: Wt.const("dcg-grapher dcg-grapher-2d"),
              style: () => ({
                visibility: this.controller.isThreeDMode()
                  ? "hidden"
                  : "visible",
                "pointer-events": this.controller.isThreeDMode()
                  ? "none"
                  : "auto",
              }),
            }),
            Wt.createElement(Fh, {
              predicate: () => this.controller.is3dProduct(),
            }, () =>
              Wt.createElement("div", {
                class: Wt.const("dcg-grapher dcg-grapher-3d"),
                style: () => ({
                  visibility: this.controller.isThreeDMode()
                    ? "visible"
                    : "hidden",
                  "pointer-events": this.controller.isThreeDMode()
                    ? "auto"
                    : "none",
                }),
              })),
            Wt.createElement(
              Fh,
              {
                predicate: () =>
                  this.settings().config.showPerformanceMeter &&
                  !!this.props.controller().getGrapher(),
              },
              () =>
                Wt.createElement(mA, {
                  controller: this.props.controller,
                }),
            ),
            Wt.createElement(
              Fh,
              {
                predicate: () =>
                  this.controller.getGraphSettings().config.keypad,
              },
              () =>
                Wt.createElement(gI, {
                  controller: this.props.controller,
                }),
            ),
          ),
        );
      }
      showHamburger() {
        return !this.controller.getGraphSettings().config.showHamburger ||
            this.controller.isGeometry()
          ? false
          : this.controller.isNarrow();
      }
      didMountRoot(e) {
        nw(e),
          this.controller.getGraphSettings().config.disableScrollFix ||
          mI(e),
          this.setupFileDragDrop(e);
      }
      setupFileDragDrop(e) {
        FO(e);
        let t = new Set(), o = this;
        function i() {
          t = new Set(),
            ee(e).off(".filedraggedover"),
            o.controller.dispatch({ type: "file-is-not-dragged-over" });
        }
        ee(e).on("dragenter", (n) => {
          this.controller.areImagesEnabled() &&
            (n.target.closest(".dcg-notice") ||
              (t.size === 0 &&
                ee(e).on("dcg-tapstart.filedraggedover", i),
                t = t.add(n.target),
                this.controller.dispatch({
                  type: "file-is-dragged-over",
                })));
        }).on("dragleave", (n) => {
          t.delete(n.target), t.size === 0 && i();
        }).on("drop", i);
      }
    };
  qt();
  function gj(r) {
    let e = {}, t = new __dcg_shared_module_exports__["re"](o);
    function o(i, n) {
      r({ type: i, payload: n });
    }
    return e.postMessage = function (i) {
      setTimeout(() => {
        t.processChangeSet(i);
      }, 0);
    },
      e;
  }
  var mj = $5("workerThrottle"), TR = 0;
  function fj(r) {
    return mj
      ? function (e) {
        var o, i;
        let t = ((i = (o = e.data) == null ? void 0 : o.originalMessage) == null
            ? void 0
            : i.type) === "evaluatorProgressUpdate"
          ? 0
          : mj;
        TR = Math.max(Date.now(), TR) + t, setTimeout(r, TR - Date.now(), e);
      }
      : r;
  }
  var ax = class {
    constructor(e = 1 / 0) {
      this.workers = [], this.maxWorkers = e;
    }
    allowedToSpawnWorker() {
      return !!__dcg_worker_source_exports__["createWorker"] &&
        this.workers.length < this.maxWorkers;
    }
    killWorker(e) {
      __dcg_shared_module_exports__["x"](this.workers, e) !== -1 &&
        (e.terminate(),
          this.workers = __dcg_shared_module_exports__["u"](
            this.workers,
            e,
          ),
          __dcg_shared_module_exports__["p"](
            __dcg_shared_module_exports__["C"](e.__connections),
          ).forEach((o) => {
            o && o.onWorkerKilled && o.onWorkerKilled();
          }));
    }
    spawnWorker() {
      if (!__dcg_worker_source_exports__["createWorker"]) return null;
      try {
        let e = __dcg_worker_source_exports__["createWorker"]();
        return e.__connections = {},
          e.__isFake = false,
          e.onerror = function (t) {
            __dcg_shared_module_exports__["qe"].log(t);
          },
          e.addEventListener(
            "message",
            fj((t) => {
              let o = t.data;
              if (!(o && o.log) && o && o.connectionId) {
                let i = e.__connections[o.connectionId];
                i && i.onResponse(o.originalMessage);
              }
            }),
          ),
          this.workers.push(e),
          e;
      } catch (e) {
        return null;
      }
    }
    spawnFakeWorker() {
      let e = gj(fj((t) => {
        let o = __dcg_shared_module_exports__["C"](e.__connections)[0];
        o && o.onResponse(t);
      }));
      return e.__isFake = true, e.__connections = {}, e;
    }
    findLeastUsedWorker() {
      let e = function (o) {
        return __dcg_shared_module_exports__["s"](o.__connections);
      };
      return __dcg_shared_module_exports__["q"](this.workers, e)[0];
    }
    allocateWorker() {
      let e = null;
      return this.allowedToSpawnWorker() && (e = this.spawnWorker()),
        e || (e = this.findLeastUsedWorker()),
        e || (e = this.spawnFakeWorker()),
        e;
    }
  };
  var bA = class {
    constructor(e) {
      this.workerPool = e,
        this.guid = __dcg_shared_module_exports__["K"](
          "worker-pool-connection",
        ),
        this.worker = e.allocateWorker(),
        this.worker.__connections[this.guid] = this;
    }
    destroy() {
      this.sendMessage({ type: "destroy" }),
        delete this.worker.__connections[this.guid];
    }
    killWorker() {
      this.worker.__isFake || this.workerPool.killWorker(this.worker);
    }
    onWorkerKilled() {}
    onResponse(e) {}
    sendMessage(e) {
      this.worker.__isFake
        ? this.worker.postMessage(e)
        : this.worker.postMessage({
          connectionId: this.guid,
          originalMessage: e,
        });
    }
  };
  var yA = class {
    constructor(e) {
      this.onChangeSetChanged = e;
      this.changeSet = null;
      this.cumulativeChangeSet = {};
      this.changed = false;
    }
    hasPendingChanges() {
      return !!this.changeSet;
    }
    pendingChangesAreCompleteState() {
      return !!this.changeSet && this.changeSet.isCompleteState;
    }
    pendingChangesSyncId() {
      var e;
      return (e = this.changeSet) == null ? void 0 : e.syncId;
    }
    popChangeSet() {
      let e = this.changeSet;
      return this.changeSet = null, this.changed = false, e;
    }
    applyToChangeSets(e) {
      this.changed = true,
        this.changeSet || (this.changeSet = {}),
        this.cumulativeChangeSet || (this.cumulativeChangeSet = {}),
        e(this.changeSet),
        e(this.cumulativeChangeSet),
        this.onChangeSetChanged();
    }
    _clearStatementsAndStartCompleteState() {
      this.applyToChangeSets((e) => {
        e.isCompleteState = true, delete e.statements;
      });
    }
    markDroppedJob() {
      this.changeSet = __dcg_shared_module_exports__["Jc"](
        this.cumulativeChangeSet,
      ), this.changed = true;
    }
    markWorkerKilledWhileIdle() {
      this.changeSet = __dcg_shared_module_exports__["Jc"](
        this.cumulativeChangeSet,
      ), this.changed = false;
    }
    markSyncId(e) {
      this.applyToChangeSets((t) => {
        t.syncId = e;
      });
    }
    markUndoRedoState() {
      this.applyToChangeSets((e) => {
        e.isUndoRedoState = true;
      });
    }
    addStatement(e) {
      this.applyToChangeSets((t) => {
        t.statements || (t.statements = {}),
          t.statements[e.id] = __dcg_shared_module_exports__["Jc"](e);
      });
    }
    removeStatement(e) {
      this.applyToChangeSets((t) => {
        t.statements || (t.statements = {}),
          t.removes || (t.removes = {}),
          delete t.statements[e],
          t.removes[e] = true;
      });
    }
    addActionStepEvent(e) {
      this.applyToChangeSets((t) => {
        t.events || (t.events = []),
          t.events.push({ type: "step", expressionId: e });
      });
    }
    addClockTickEvent(e, t) {
      this.applyToChangeSets((o) => {
        o.events || (o.events = []),
          o.events.push({ type: "clock-tick", id: e, isFirstTick: t });
      });
    }
    addClickEvent(e, t) {
      this.applyToChangeSets((o) => {
        o.events || (o.events = []),
          t === void 0 && (t = 0),
          o.events.push({ type: "click", expressionId: e, indexVar: t });
      });
    }
    _applyIfChanged(e, t) {
      let o = this.cumulativeChangeSet && this.cumulativeChangeSet[t],
        i = e[t];
      __dcg_shared_module_exports__["E"](o, i) ||
        this.applyToChangeSets((n) => {
          n[t] = i;
        });
    }
  };
  var mpe = 4e3,
    fpe = 250,
    bpe = 500,
    Nh = class extends yA {
      constructor(t) {
        super(() => this.processChangeSet());
        this.droppedMessage = false;
        this.__hasBufferedProgressUpdates = false;
        this.evaluationProgressById = new Map();
        this.lastProgressUpdateTime = -1;
        this.requestedIntentionalRestart = false;
        this.debouncedRestart = __dcg_shared_module_exports__["A"](() => {
          this.requestedIntentionalRestart = true, this.restartWorker();
        }, fpe);
        this.__ticksEnabled = true;
        this.listeners = {
          evaluatorProgressUpdate(t) {
            this.lastProgressUpdateTime = Date.now(),
              t.ids.forEach((o) =>
                this.evaluationProgressById.set(o, t.update)
              ),
              this.__hasBufferedProgressUpdates = true;
          },
          processChangeSet(t) {
            this.clearProgressUpdates();
            let o = {}, i = {};
            for (let l in t.graphChanges) {
              let c = t.graphChanges[l];
              c === void 0
                ? i[l] = true
                : (__dcg_shared_module_exports__["uc"](c), o[l] = c);
            }
            let n = {};
            for (let l in t.intersectionChanges) {
              i[l] || (n[l] = t.intersectionChanges[l]);
            }
            let a = this.hasPendingChanges();
            this.onEvaluatorResults({
              evaluationStates: t.statusChanges,
              graphData: {
                addedGraphs: o,
                removedGraphs: i,
                intersections: n,
              },
              renderSlowly: !!t.isCompleteState,
              timingData: t.timingData,
              eventUpdates: t.eventUpdates,
              dependencyOrder: t.dependencyOrder,
            });
            let s = t.syncId;
            for (
              ;
              this.syncRequests.length && s !== void 0 &&
              this.syncRequests[0].id <= s;
            ) this.syncRequests.shift().callback();
            this.markJobFinished(), a && this._processChangeSet();
          },
        };
        this.syncId = 1,
          this.syncRequests = [],
          this.workerPool = t != null ? t : new ax(),
          this.createWorkerPoolConnection();
      }
      privateGetWorkerPool() {
        return this.workerPool;
      }
      privateGetWorkerPoolConnection() {
        return this.workerPoolConnection;
      }
      createWorkerPoolConnection() {
        this.workerPoolConnection &&
        (this.workerPoolConnection.onResponse = function () {},
          this.workerPoolConnection.onWorkerKilled = function () {}),
          this.workerPoolConnection = new bA(this.workerPool),
          this.markJobFinished(),
          this.workerPoolConnection.onResponse = (t) => {
            this.shouldIgnoreWorkerMessage(t)
              ? t.type === "processChangeSet" &&
                (this.markJobFinished(), this._processChangeSet())
              : this.listeners[t.type].call(this, t.payload);
          },
          this.workerPoolConnection.onWorkerKilled = () => {
            this.cancelRestartWorker();
            let t = this.hasJobInWorker();
            this.createWorkerPoolConnection(),
              t
                ? (this.markDroppedJob(),
                  this.droppedMessage = !this.requestedIntentionalRestart)
                : this.markWorkerKilledWhileIdle(),
              this.clearProgressUpdates(),
              this.processChangeSet(),
              this.requestedIntentionalRestart = false;
          };
      }
      destroy() {
        this.workerPoolConnection &&
          (this.workerPoolConnection.onResponse = function () {},
            this.workerPoolConnection.onWorkerKilled = function () {},
            this.workerPoolConnection.destroy());
      }
      restartWorker() {
        this.workerPoolConnection.killWorker();
      }
      requestRestartWorker() {
        this.debouncedRestart();
      }
      cancelRestartWorker() {
        this.debouncedRestart.cancel();
      }
      shouldIgnoreWorkerMessage(t) {
        return this.__suspendUntilSyncId
          ? !t || !t.payload
            ? true
            : !(t.payload.syncId >= this.__suspendUntilSyncId)
          : false;
      }
      suspend() {
        this.clearProgressUpdates(),
          this.pendingChangesSyncId() === void 0 &&
          (this.syncId++, this.markSyncId(this.syncId)),
          this.__suspendUntilSyncId = this.pendingChangesSyncId();
      }
      markJobFinished() {
        this.droppedMessage = false,
          this.__jobStartTime = -1,
          this.__suspendUntilSyncId = void 0;
      }
      startJobTimer() {
        this.__jobStartTime = Date.now();
      }
      hasJobInWorker() {
        return this.__jobStartTime !== -1;
      }
      getJobElapsedTime() {
        return this.hasJobInWorker() ? Date.now() - this.__jobStartTime : NaN;
      }
      setTicksEnabled(t) {
        this.__ticksEnabled = t;
      }
      tick() {
        var t;
        this.__ticksEnabled &&
          (this.__hasBufferedProgressUpdates &&
            ((t = this.onEvaluatorProgressUpdate) == null ||
              t.call(this)),
            this.__hasBufferedProgressUpdates = false,
            this._processChangeSet());
      }
      processChangeSet() {
        this.__processChangeSetRequested = true;
      }
      _processChangeSet() {
        var o;
        if (
          this._syncEvaluatorConfig(), !this.__processChangeSetRequested
        ) return;
        let t = this.getJobElapsedTime() >= mpe;
        if (this.droppedMessage && t) {
          this.restartWorker();
          return;
        }
        this.changed && this.hasPendingChanges() &&
          (this.pendingChangesSyncId() === void 0 &&
            (this.syncId++, this.markSyncId(this.syncId)),
            this.hasJobInWorker()
              ? this.pendingChangesAreCompleteState() && t &&
                this.restartWorker()
              : (this.startJobTimer(),
                this.workerPoolConnection.sendMessage(
                  this.popChangeSet(),
                ),
                this.__processChangeSetRequested = false,
                (o = this.clearSlowEvaluatorTracking) == null ||
                o.call(this)));
      }
      notifyWhenSynced(t) {
        if (
          this._syncEvaluatorConfig(),
            !this.hasJobInWorker() && !this.hasPendingChanges()
        ) {
          setTimeout(t, 0);
          return;
        }
        this.syncId++,
          this.syncRequests.push({ id: this.syncId, callback: t }),
          this.markSyncId(this.syncId);
      }
      clearStatementsAndStartCompleteState() {
        this.hasJobInWorker() && this.suspend(),
          this._clearStatementsAndStartCompleteState();
      }
      _syncEvaluatorConfig() {
        if (!this.readEvaluatorConfig) return;
        let t = this.readEvaluatorConfig();
        for (let o in t) this._applyIfChanged(t, o);
      }
      clearProgressUpdates() {
        this.evaluationProgressById = new Map(),
          this.__hasBufferedProgressUpdates = false;
      }
      isCurrentlySlow() {
        return this.lastProgressUpdateTime > -1 &&
          Date.now() - this.lastProgressUpdateTime >= bpe;
      }
    };
  qt();
  var v1 = class {
    constructor(e) {
      this.previousPaneFocusLocations = { main: void 0, quest: void 0 };
      this.controller = e;
    }
    markKeyDownAsHandled(e) {
      e.stopPropagation(), e.preventDefault();
    }
    handleKeydown(e) {
      var o, i, n, a, s;
      let t = Ko(e);
      if (Zx(e)) {
        this.markKeyDownAsHandled(e),
          this.controller.hasVisibleAndUndoableToast()
            ? this.controller.toastUndo()
            : this.controller.dispatch({ type: "undo" });
      } else if (ew(e)) {
        this.markKeyDownAsHandled(e),
          this.controller.dispatch({ type: "redo" });
      } else if (
        e.altKey && !e.ctrlKey && !e.metaKey && e.shiftKey && t === "Z"
      ) {
        let l = this.controller.getSelectedItem();
        l && l.id &&
          (this.markKeyDownAsHandled(e),
            this.controller.dispatch({
              type: "expression-zoom-fit",
              id: l.id,
              focusAfterTap: false,
            }));
      } else if (
        e.altKey !== Zo && e.metaKey === Zo && !e.ctrlKey && e.shiftKey &&
        t === "A" && this.controller.isDecimalToFractionEnabled()
      ) {
        let l = this.controller.getSelectedItem();
        l && l.type === "expression" &&
          (this.markKeyDownAsHandled(e),
            this.controller.dispatch({
              type: "toggle-fraction-evaluation",
              id: l.id,
            }),
            this.controller.runAfterDispatch(() => {
              Hu(l)
                ? xe(
                  this.controller.s(
                    "shared-calculator-narration-show-as-fraction",
                  ),
                )
                : xe(
                  this.controller.s(
                    "shared-calculator-narration-show-as-decimal",
                  ),
                );
            }));
      } else if (
        !e.altKey && e.ctrlKey !== Zo && e.metaKey === Zo && t === "F"
      ) {
        if (this.controller.isExpressionListFocused()) {
          let l = Fe.getFocusedMathquill(), c = "";
          try {
            c = l.__controller.cursor.selection.join("latex") || "";
          } catch (d) {}
          this.controller.dispatch({
            type: "open-expression-search",
            rename: !!e.shiftKey,
            latex: c,
          }), this.markKeyDownAsHandled(e);
        }
      } else if (
        (e.altKey || e.metaKey) && !e.ctrlKey && !e.shiftKey &&
        t === void 0
      ) {
        if (ke(e) === xa) {
          let l = this.controller.getSelectedItem();
          l && l.type === "folder" &&
            (this.markKeyDownAsHandled(e),
              this.controller.dispatch({
                type: "set-folder-collapsed",
                id: l.id,
                isCollapsed: true,
              }),
              xe(
                this.controller.s(
                  "graphing-calculator-narration-folder-collapsed",
                ),
              ));
        } else if (ke(e) === Kn) {
          let l = this.controller.getSelectedItem();
          l && l.type === "folder" &&
            (this.markKeyDownAsHandled(e),
              this.controller.dispatch({
                type: "set-folder-collapsed",
                id: l.id,
                isCollapsed: false,
              }),
              xe(
                this.controller.s(
                  "graphing-calculator-narration-folder-expanded",
                ),
              ));
        }
      } else if (
        e.shiftKey && (e.altKey || e.metaKey) && !e.ctrlKey
      ) {
        if (ke(e) === xa) {
          this.markKeyDownAsHandled(e),
            this.controller.dispatch({
              type: "set-all-folders-collapsed",
              isCollapsed: true,
            }),
            xe(
              this.controller.s(
                "graphing-calculator-narration-all-folders-collapsed",
              ),
            );
        } else if (ke(e) === Kn) {
          this.markKeyDownAsHandled(e),
            this.controller.dispatch({
              type: "set-all-folders-collapsed",
              isCollapsed: false,
            }),
            xe(
              this.controller.s(
                "graphing-calculator-narration-all-folders-expanded",
              ),
            );
        } else if (t === "H") {
          let l = this.controller.getSelectedItem();
          l && "hidden" in l &&
            (this.markKeyDownAsHandled(e),
              this.controller.dispatch({
                type: "toggle-item-hidden",
                id: l.id,
              }),
              this.controller.runAfterDispatch(() => {
                l.hidden
                  ? xe(
                    this.controller.s(
                      "graphing-calculator-narration-item-hidden",
                    ),
                  )
                  : xe(
                    this.controller.s(
                      "graphing-calculator-narration-item-visible",
                    ),
                  );
              }));
        } else if (t === "O") {
          if (!this.controller.authorFeaturesAvailable()) return;
          this.controller.dispatch({
            type: "set-author-mode",
            enabled: !this.controller.shouldShowAuthorFeatures(),
          }),
            xe(
              this.controller.shouldShowAuthorFeatures()
                ? this.controller.s(
                  "shared-calculator-narration-author-mode-on",
                )
                : this.controller.s(
                  "shared-calculator-narration-author-mode-off",
                ),
            ),
            this.markKeyDownAsHandled(e);
        } else if (t === "E") {
          if (!this.controller.isListEnabled()) return;
          this.controller.isListVisible()
            ? (this.controller.dispatch({
              type: "hide-expressions-list",
              focusShowIcon: false,
            }),
              xe(
                this.controller.s(
                  "graphing-calculator-narration-hide-expression-list",
                ),
              ))
            : (this.controller.dispatch({
              type: "show-expressions-list",
              focusHideIcon: false,
            }),
              this.focusExpressionList()), this.markKeyDownAsHandled(e);
        }
      } else if (
        e.ctrlKey && (e.altKey || e.metaKey) && !e.shiftKey
      ) {
        if (t === "E") {
          if (!this.controller.isListEnabled()) return;
          this.markKeyDownAsHandled(e), this.focusExpressionList();
        } else if (t === "X") {
          if (!this.controller.isListEnabled()) return;
          this.markKeyDownAsHandled(e),
            this.controller.canUserAddExpressions()
              ? (xe(
                this.controller.s(
                  "graphing-calculator-narration-add-expression",
                ),
              ),
                this.controller.dispatch({ type: "new-expression" }))
              : xe(
                this.controller.s(
                  "graphing-calculator-narration-unable-to-add-expression",
                ),
              );
        } else if (t === "O") {
          if (!this.controller.isListEnabled()) return;
          this.markKeyDownAsHandled(e),
            this.controller.canUserAddExpressions() &&
              this.controller.areNotesEnabled()
              ? (xe(
                this.controller.s(
                  "graphing-calculator-narration-add-note",
                ),
              ),
                this.controller.dispatch({ type: "new-text" }))
              : xe(
                this.controller.s(
                  "graphing-calculator-narration-unable-to-add-note",
                ),
              );
        } else if (
          t === "F" && this.controller.canUserAddExpressions() &&
          this.controller.areFoldersEnabled()
        ) {
          this.markKeyDownAsHandled(e),
            xe(
              this.controller.s(
                "graphing-calculator-narration-add-folder",
              ),
            ),
            this.controller.dispatch({ type: "new-folder" });
        } else if (
          t === "I" && this.controller.canUserAddExpressions() &&
          this.controller.areImagesEnabled()
        ) {
          this.markKeyDownAsHandled(e),
            this.controller.dispatch({
              type: "toggle-add-expression",
              focusOnOpen: false,
            }),
            this.controller.runAfterDispatch(() => {
              let l = this.controller.findEl(
                ".dcg-add-expression-container input[type=file]",
              );
              l &&
                (ee(l).trigger("click"),
                  xe(
                    this.controller.s(
                      "graphing-calculator-narration-add-image",
                    ),
                  ));
            });
        } else if (t === "T") {
          this.markKeyDownAsHandled(e),
            this.controller.canUserAddExpressions()
              ? (xe(
                this.controller.s(
                  "graphing-calculator-narration-add-table",
                ),
              ),
                this.controller.dispatch({ type: "new-table" }))
              : xe(
                this.controller.s(
                  "graphing-calculator-narration-unable-to-add-table",
                ),
              );
        } else if (t === "R") {
          let l = this.controller.getSelectedItem();
          if (!this.controller.isListEnabled()) return;
          this.markKeyDownAsHandled(e),
            this.controller.canUserAddExpressions() && l &&
              this.controller.shouldShowRegressionButton(l)
              ? (xe(
                this.controller.s(
                  "graphing-calculator-button-add-table-regression",
                ),
              ),
                this.controller.dispatch({
                  type: "create-table-regression",
                  tableId: l.id,
                  regressionType: "linear",
                }))
              : xe(
                this.controller.s(
                  "graphing-calculator-narration-unable-to-add-table-regression",
                ),
              );
        } else if (t === "M" && this.controller.isGeoUIActive()) {
          if (
            this.markKeyDownAsHandled(e),
              this.controller.getGeoToolbarGroupKeys().length > 0
          ) {
            let l = this.controller.getActiveTool();
            if (this.controller.shouldShowMultiSelectHeader()) {
              let c = this.controller.getAllSelectedItems().filter((d) =>
                !this.controller.isItemReadonly(d.id)
              ).length > 0;
              this.controller.dispatch({
                type: "set-focus-location",
                location: {
                  type: c
                    ? "multi-select-show-hide-icon"
                    : "multi-select-style-icon",
                },
              });
            } else {l === "expression-edit" && (l = "selection"),
                this.controller.dispatch({
                  type: "set-focus-location",
                  location: { type: "geo-basic-tool", tool: l },
                });}
          } else {xe(
              this.controller.s(
                "graphing-calculator-narration-no-geometry-tools-available",
              ),
            );}
        } else if (t === "C" && this.controller.isGeoUIActive()) {
          this.markKeyDownAsHandled(e),
            this.controller.getGeometryTokenCount() > 0
              ? this.controller.dispatch({
                type: "set-show-constructions-open",
                open: true,
                setFocus: true,
              })
              : xe(this.controller.raw("Object navigator has no items."));
        } else if (t === "G") {
          this.markKeyDownAsHandled(e),
            this.controller.dispatch({
              type: "toggle-graph-settings",
              focusOnOpen: true,
            });
        } else if (t === "P") {
          if (
            this.markKeyDownAsHandled(e), this.controller.isGeometry()
          ) {
            let l = this.controller.getFocusLocation(),
              c = this.controller.getValidCursorContext();
            if (l && l.type === "expression" && c && c.type !== "empty") {
              this.controller.dispatch({
                type: "set-focus-location",
                location: {
                  type: "expression",
                  id: l.id,
                  isFakeGraphFocus: true,
                },
              }),
                (i = (o = this.controller.getGrapher2d()) == null
                    ? void 0
                    : o.poiController) == null ||
                i.keyboardAttentionManager.handleGrapherGainedFocus();
              return;
            }
          }
          this.controller.dispatch({
            type: "set-focus-location",
            location: { type: "graph-paper" },
          });
        } else if (t === "Z") {
          let l = this.controller.getSelectedItem();
          l && l.id &&
            this.controller.dispatch({
              type: "expression-zoom-fit",
              id: l.id,
              focusAfterTap: false,
            });
        } else if (t === "D" && this.controller.canUserAddExpressions()) {
          this.markKeyDownAsHandled(e);
          let l = !this.controller.isInEditListMode();
          this.controller.dispatch({
            type: "set-edit-list-mode",
            isEditListMode: l,
            focusExpressionList: true,
          });
        }
      } else if (gG(e) && this.controller.getQuestIsActive()) {
        ((n = this.controller.focusLocation) == null ? void 0 : n.type) ===
            "quest"
          ? (this.previousPaneFocusLocations.quest =
            this.controller.focusLocation,
            this.previousPaneFocusLocations.main
              ? this.controller.dispatch({
                type: "set-focus-location",
                location: this.previousPaneFocusLocations.main,
              })
              : this.focusExpressionList())
          : (this.previousPaneFocusLocations.main =
            this.controller.focusLocation,
            this.controller.dispatch({
              type: "set-focus-location",
              location: (a = this.previousPaneFocusLocations.quest) != null
                ? a
                : { type: "quest", location: "quest-pane" },
            })), this.markKeyDownAsHandled(e);
        return;
      } else if (
        !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey
      ) {
        if (ke(e) === _u) {
          (!document.activeElement || !wp(document.activeElement)) &&
            e.preventDefault();
        } else if (
          ke(e) === kn && !this.controller.getOpenItemMenu() &&
          !this.controller.isGraphSettingsOpen()
        ) {
          if (this.controller.isGeoUIActive()) {
            let l = false, c = this.controller.getGeoModel();
            if (
              this.controller.hasAnyItemsSelected() &&
              (this.controller.dispatch({ type: "set-none-selected" }),
                l = true),
                c.isToolplayActive() &&
                (this.controller.dispatch({
                  type: "cancel-geo-toolplay",
                }),
                  xe(
                    this.controller.s(
                      "graphing-calculator-narration-geometry-tool-cancelled",
                    ),
                  ),
                  l = true),
                this.controller.isGraphPaperFocused() &&
                (this.controller.dispatch({
                  type: "set-focus-location",
                  location: {
                    type: "geo-basic-tool",
                    tool: this.controller.getActiveTool(),
                  },
                }),
                  l = true),
                this.controller.getActiveTool() !== "selection" && !l
            ) {
              this.controller.dispatch({
                type: "select-geo-tool",
                tool: "selection",
              });
              let d = this.controller.getFocusLocation();
              d && d.type === "geo-basic-tool" &&
              this.controller.dispatch({
                type: "set-focus-location",
                location: {
                  type: "geo-basic-tool",
                  tool: this.controller.getActiveTool(),
                },
              }), l = true;
            }
            if (l) {
              this.markKeyDownAsHandled(e);
              return;
            }
          }
          this.controller.isInEditListMode() &&
            !this.controller.findEl(".dcg-options-menu") &&
            (this.markKeyDownAsHandled(e),
              this.controller.dispatch({
                type: "set-edit-list-mode",
                isEditListMode: false,
                focusExpressionList: true,
              }));
        }
      } else if (
        !e.metaKey && !e.shiftKey && e.ctrlKey === Zo && e.altKey === !Zo
      ) {
        if (t === "N") {
          if (!this.controller.getBrailleControls()) return;
          this.markKeyDownAsHandled(e),
            this.controller.dispatch({
              type: "set-braille-mode",
              mode: "nemeth",
            }),
            xe(
              this.controller.s(
                "shared-calculator-narration-hotkey-braille-mode-nemeth",
              ),
            );
        } else if (t === "U") {
          if (!this.controller.getBrailleControls()) return;
          this.markKeyDownAsHandled(e),
            this.controller.dispatch({
              type: "set-braille-mode",
              mode: "ueb",
            }),
            xe(
              this.controller.s(
                "shared-calculator-narration-hotkey-braille-mode-ueb",
              ),
            );
        } else if (t === "Q" || t === "X") {
          if (!this.controller.getBrailleControls()) return;
          this.markKeyDownAsHandled(e),
            this.controller.dispatch({
              type: "set-braille-mode",
              mode: "none",
            }),
            xe(
              this.controller.s(
                "shared-calculator-narration-hotkey-braille-mode-off",
              ),
            );
        } else if (t === "6") {
          if (!this.controller.getBrailleControls()) return;
          this.markKeyDownAsHandled(e);
          let l = !this.controller.getSixKeyInput();
          this.controller.dispatch({
            type: "set-six-key-input",
            useSixKeyInput: l,
          }),
            xe(
              l
                ? this.controller.s(
                  "shared-calculator-narration-six-key-mode-on",
                )
                : this.controller.s(
                  "shared-calculator-narration-six-key-mode-off",
                ),
            );
        } else if (t === "D") {
          if (this.controller.isComplexModeEnabled()) {
            xe(
              this.controller.s(
                "shared-calculator-text-complex-radian-mode",
              ),
            );
            return;
          }
          this.markKeyDownAsHandled(e),
            this.controller.dispatch({
              type: "set-graph-settings",
              degreeMode: !this.controller.getGraphSettings().degreeMode,
            }),
            xe(
              this.controller.getGraphSettings().degreeMode
                ? this.controller.s(
                  "graphing-calculator-button-settings-degrees",
                )
                : this.controller.s(
                  "graphing-calculator-button-settings-radians",
                ),
            );
        } else if (t === "K") {
          if (
            !this.controller.isKeypadEnabled() ||
            this.controller.inAudioTraceMode()
          ) return;
          this.markKeyDownAsHandled(e),
            this.controller.dispatch({
              type: "keypad/set-minimized",
              minimized: this.controller.isHideKeypadButtonVisible(),
            });
        } else {t === "M" &&
            ((s = this.controller.toneController) == null ||
              s.handleMuteKeyShortcut(),
              this.markKeyDownAsHandled(e));}
        if (t === "+" || t === "=") {
          this.zoom("in"), this.markKeyDownAsHandled(e);
          return;
        } else if (t === "-") {
          this.zoom("out"), this.markKeyDownAsHandled(e);
          return;
        } else if (t === "0" && !e.shiftKey) {
          this.setDefaultViewport(), this.markKeyDownAsHandled(e);
          return;
        }
      }
    }
    focusExpressionList() {
      let e = this.controller.getSelectedItem();
      e
        ? this.controller.dispatch({
          type: "move-focus-to-item",
          id: e.id,
        })
        : this.controller.dispatch({ type: "focus-first-expression" });
    }
    zoom(e) {
      var t;
      (t = this.controller.getGrapher()) == null ||
        t.viewportController.zoom(e);
    }
    setDefaultViewport() {
      var e;
      (e = this.controller.getGrapher()) == null ||
        e.viewportController.setDefaultViewport();
    }
  };
  function bj(r) {
    let { left: e, right: t, bottom: o, top: i } = r;
    return {
      left: e,
      right: t,
      bottom: o,
      top: i,
      xmin: e,
      xmax: t,
      ymin: o,
      ymax: i,
      width: Math.abs(t - e),
      height: Math.abs(i - o),
    };
  }
  var ype = 0,
    C1 = class {
      constructor(e, t, o, i) {
        e || (e = document.createElement("div"));
        let n = document.createElement("div");
        n.className = "dcg-dom-change-wrapper",
          n.style.width = "100%",
          n.style.height = "100%",
          e.appendChild(n),
          this.__id = ype++;
        let a = new Bp();
        this.graphSettings = a;
        for (let u in o) a.config.setProperty(u, o[u]);
        let s = new Im(a);
        this.controller = s,
          i && s.dispatch({ type: "ui/container-resized", size: i }),
          this.rootElt = n,
          this.view = sx.mountToNode(w1, this.rootElt, {
            controller: sx.const(s),
          });
        let l = new Nh(t);
        this.controller.setEvaluator(l),
          this.controller.setRootElt(this.rootElt);
        let c = this.controller.findEl(".dcg-grapher-2d"),
          d = new am(c, a, this.controller, l);
        if (
          this.controller.setGrapher2d(d), this.controller.is3dProduct()
        ) {
          let u = this.controller.findEl(".dcg-grapher-3d"),
            f = new rI(u, a, this.controller, l);
          this.controller.setGrapher3d(f), this.grapher = f;
        } else this.grapher = d;
        this.controller.initStateStack(),
          l.readEvaluatorConfig = () => ({
            product: a.config.product,
            beta3d: a.config.beta3d,
            evaluationMode: s.isGeometry()
              ? "geometry"
              : this.controller.isThreeDMode()
              ? "graphing_3d"
              : "graphing",
            globalRandomSeed: a.randomSeed,
            includeFunctionParametersInRandomSeed:
              a.includeFunctionParametersInRandomSeed,
            degreeMode: a.degreeMode,
            viewState: s.getViewState(),
            selectedIds: s.getPropagatedSelectedIds().selected,
            restrictedFunctions: a.config.restrictedFunctions,
            forceEnableGeometryFunctions: a.config.forceEnableGeometryFunctions,
            distributions: a.config.distributions,
            pointsOfInterest: a.config.pointsOfInterest,
            plotSingleVariableImplicitEquations:
              a.config.plotSingleVariableImplicitEquations,
            plotImplicits: a.config.plotImplicits,
            plotInequalities: a.config.plotInequalities,
            sliders: a.config.sliders,
            actions: !!a.config.actions,
            substitutions: a.config.substitutions,
            intervalComprehensions: a.config.intervalComprehensions,
            recursion: a.config.recursion,
            recursionDepthLimit: a.config.recursionDepthLimit,
            dimensions: s.getGrapherDimensions(),
            logInternalErrors: a.config.logInternalErrors,
            complex: a.complex,
            customRegressions: a.config.customRegressions,
          }),
          l.onEvaluatorProgressUpdate = () => {
            this.controller.dispatch({
              type: "evaluator-progress-update",
            });
          },
          l.onEvaluatorResults = (u) => {
            this.controller.dispatch({
              type: "on-evaluator-changes",
              changes: u.evaluationStates,
              timingData: u.timingData,
              graphData: u.graphData,
              eventUpdates: u.eventUpdates,
              dependencyOrder: u.dependencyOrder,
            }), this.controller.requestRedrawGraph();
          },
          this.unsubFunc = this.controller.subscribeToChanges(() => {
            this.controller.doesDOMHaveSize() &&
              (this.view.update(),
                this.grapher = this.controller.isThreeDMode()
                  ? this.controller.getGrapher3d() ||
                    this.controller.getGrapher2d()
                  : this.controller.getGrapher2d(),
                this.grapher.update());
            let u = false;
            h() && (u = true),
              u && this.controller.doesDOMHaveSize() &&
              (this.view.update(), this.grapher.update());
          });
        let p = new cs({
          pixelCoordinates: {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0,
          },
          mathCoordinates: bj({ top: 0, bottom: 0, left: 0, right: 0 }),
        });
        this.graphpaperBounds = p;
        let h = () => {
          let u = false,
            f = s.computeMajorLayout(),
            y = {
              left: f.grapher.left,
              right: f.grapher.left + f.grapher.width,
              width: f.grapher.width,
              top: f.grapher.top,
              bottom: f.grapher.top + f.grapher.height,
              height: f.grapher.height,
            },
            C = this.grapher.getCurrentViewport(),
            E = {
              ...bj({
                left: C.xmin,
                right: C.xmax,
                bottom: C.ymin,
                top: C.ymax,
              }),
              zmin: C.zmin,
              zmax: C.zmax,
            };
          return __dcg_shared_module_exports__["E"](
            E,
            p.mathCoordinates,
          ) || (p.setProperty("mathCoordinates", E), u = true),
            y.height > 0 && y.width > 0 &&
            !__dcg_shared_module_exports__["E"](y, p.pixelCoordinates) &&
            (p.setProperty("pixelCoordinates", y), u = true),
            u;
        };
        ee(this.rootElt).on("keydown.calculator-" + this.__id, (u) => {
          this.grapher instanceof am &&
          this.grapher.audioGraph.handleKeydown(u),
            this.instanceHotkeys.handleKeydown(u);
        }),
          ee(document.documentElement).on(
            "dcg-tapstart.calculator-" + this.__id,
            (u) => {
              var w;
              let f = u.target,
                y = !!this.rootElt.contains(f),
                C = u.wasHandled("create-expression-with-keyboard"),
                E = !!f.classList.contains("dcg-shell");
              !y && !E && !C && s.dispatch({ type: "set-none-selected" });
              let v = (w = this.controller.getGrapher2d()) == null
                ? void 0
                : w.traceLayer;
              if (
                !u.wasHandled("do-not-clear-poi-labels") && v &&
                (v.clearOpenedPOI(), this.controller.requestRedrawGraph()),
                  s.isInEditListMode()
              ) {
                let S = !f.closest(".dcg-exppanel") &&
                  !f.closest(".dcg-options-menu") &&
                  !f.closest(".dcg-expression-top-bar") &&
                  !f.closest(".dcg-keypad");
                (!y || S) &&
                  s.dispatch({
                    type: "set-edit-list-mode",
                    isEditListMode: false,
                    focusExpressionList: false,
                  });
              }
            },
          ),
          this.evaluator = l,
          this.controller.dispatch({
            type: "set-blank",
            degreeMode: !!o.degreeMode,
          }),
          a.config.expressionsCollapsed &&
          this.setOptions({ expressionsCollapsed: true }),
          a.config.capExpressionSize &&
          this.setOptions({ capExpressionSize: true }),
          a.config.hasOwnProperty("pointsOfInterest") &&
          this.setOptions({
            pointsOfInterest: a.config.pointsOfInterest,
          }),
          a.config.hasOwnProperty("backgroundColor") &&
          this.setOptions({ backgroundColor: a.config.backgroundColor }),
          a.config.hasOwnProperty("textColor") &&
          this.setOptions({ textColor: a.config.textColor }),
          a.config.observe("language", () => {
            let u = this.controller.getState();
            this.controller.dispatch({ type: "set-state", state: u });
          }),
          a.config.observe("forceLogModeRegressions", () => {
            a.config.forceLogModeRegressions &&
              this.controller.setAllRegressionsToLogMode();
          }),
          this.instanceHotkeys = new v1(s);
      }
      setOption(e, t) {
        this.controller.getGraphSettings().config.setProperty(e, t);
      }
      setOptions(e) {
        let t,
          o = this.controller.getGraphSettings().config,
          i = { ...e };
        e.hasOwnProperty("backgroundColor") &&
        (__dcg_shared_module_exports__["Jd"](e.backgroundColor) ||
          (__dcg_shared_module_exports__["qe"].warn(
            "Invalid backgroundColor. Background color must be a 3- or 6-character hex color (e.g. #cde or #ffaaaa)",
          ),
            delete i.backgroundColor)),
          e.hasOwnProperty("textColor") &&
          (__dcg_shared_module_exports__["Jd"](e.textColor) ||
            (__dcg_shared_module_exports__["qe"].warn(
              "Invalid textColor. Text color must be a 3- or 6-character hex color (e.g. #000 or #001111)",
            ),
              delete i.textColor)),
          e.hasOwnProperty("menus") &&
          (__dcg_shared_module_exports__["qe"].warn(
            "Deprecated option: menus. Setting settingsMenu and expressionsTopbar instead.",
          ),
            e.hasOwnProperty("settingsMenu") ||
            (i.settingsMenu = !!e.menus),
            e.hasOwnProperty("expressionsTopbar") ||
            (i.expressionsTopbar = !!e.menus),
            delete i.menus),
          e.hasOwnProperty("solutions") &&
          (__dcg_shared_module_exports__["qe"].warn(
            "Deprecated option: solutions. Setting pointsOfInterest instead.",
          ),
            e.hasOwnProperty("pointsOfInterest") ||
            (i.pointsOfInterest = !!e.solutions),
            delete i.solutions),
          e.hasOwnProperty("administerSecretFolders") &&
          (__dcg_shared_module_exports__["qe"].warn(
            "Deprecated option: administerSecretFolders. Setting authorFeatures instead.",
          ),
            e.hasOwnProperty("authorFeatures") ||
            (i.authorFeatures = !!e.administerSecretFolders),
            delete i.administerSecretFolders),
          e.hasOwnProperty("singleVariableSolutions") &&
          (__dcg_shared_module_exports__["qe"].warn(
            "Deprecated option: singleVariableSolutions has been removed.",
          ),
            delete i.singleVariableSolutions),
          e.graphpaper === false &&
          (e.expressionsCollapsed &&
            (i.expressionsCollapsed = false,
              __dcg_shared_module_exports__["qe"].warn(
                "Cannot set graphpaper: false with expressionsCollapsed: true. Proceeding with expressionsCollapsed: false.",
              )),
            o.expressionsCollapsed &&
            (i.expressionsCollapsed = false,
              __dcg_shared_module_exports__["qe"].warn(
                "Disabling the graphpaper with the expressions list collapsed is not supported.Setting expressionsCollapsed: false.",
              )),
            e.zoomButtons &&
            (i.zoomButtons = false,
              __dcg_shared_module_exports__["qe"].warn(
                "Cannot set graphpaper: false with zoomButtons: true. Proceeding with zoomButtons: false.",
              )),
            e.showResetButtonOnGraphpaper &&
            (i.showResetButtonOnGraphpaper = false,
              __dcg_shared_module_exports__["qe"].warn(
                "Cannot set graphpaper: false with showResetButtonOnGraphpaper: true. Proceeding with showResetButtonOnGraphpaper: false.",
              )),
            o.zoomButtons &&
            (i.zoomButtons = false,
              __dcg_shared_module_exports__["qe"].warn(
                "Disabling the graphpaper with the zoomButtons visible is not supported. Setting zoomButtons: false.",
              )),
            o.showResetButtonOnGraphpaper &&
            (i.showResetButtonOnGraphpaper = false,
              __dcg_shared_module_exports__["qe"].warn(
                "Disabling the graphpaper with the reset button visible is not supported. Setting showResetButtonOnGraphpaper: false.",
              ))),
          o.graphpaper === false &&
          (e.expressionsCollapsed || e.zoomButtons ||
            e.showResetButtonOnGraphpaper) &&
          (i.graphpaper = true,
            __dcg_shared_module_exports__["qe"].warn(
              "Must have visible graphpaper to proceed. Setting graphpaper: true.",
            )),
          e.lockViewport && e.zoomButtons &&
          (i.zoomButtons = false,
            __dcg_shared_module_exports__["qe"].warn(
              "Cannot set zoomButtons: true and lockViewport: true. Proceeding with zoomButtons: false.",
            )),
          o.lockViewport && e.zoomButtons &&
          (i.lockViewport = false,
            __dcg_shared_module_exports__["qe"].warn(
              "Cannot set zoomButtons: true while the viewport is locked. Setting lockViewport: false.",
            )),
          o.zoomButtons && e.lockViewport &&
          (i.zoomButtons = false,
            __dcg_shared_module_exports__["qe"].warn(
              "Cannot lock the viewport without hiding the zoom buttons. Setting zoomButtons: false.",
            ));
        function n(d) {
          let { notes: p, folders: h, images: u } = d;
          return p === false || h === false || u === false;
        }
        let a = n(e),
          s = n({ ...o, ...e }),
          l = o.pasteGraphLink,
          c = e.pasteGraphLink;
        a
          ? (c || l) &&
            (i.pasteGraphLink = false,
              __dcg_shared_module_exports__["qe"].warn(
                "Cannot disable creating note, folder, or image expressions without disabling graph link pasting. Setting pasteGraphLink: false.",
              ))
          : c && s &&
            (i.notes = true,
              i.folders = true,
              i.images = true,
              __dcg_shared_module_exports__["qe"].warn(
                "Cannot enable graph link pasting while the creation of notes, folders, or images is disable. Setting notes: true, folders: true, images: true.",
              )),
          e.language && (i.language = Ld(e.language)),
          this.controller.isGeometry() &&
          (e.logScales &&
            (__dcg_shared_module_exports__["qe"].warn(
              "Cannot set logScales: true in the geometry calculator",
            ),
              delete i.logScales),
            e.allowComplex &&
            (__dcg_shared_module_exports__["qe"].warn(
              "Cannot set allowComplex: true in the geometry calculator",
            ),
              delete i.allowComplex));
        for (t in i) {
          if (i.hasOwnProperty(t)) {
            switch (t) {
              case "expressionsCollapsed":
                this.setOption(
                  "expressionsCollapsed",
                  !!i.expressionsCollapsed,
                ),
                  i.expressionsCollapsed
                    ? this.controller.dispatch({
                      type: "hide-expressions-list",
                      focusShowIcon: false,
                    })
                    : this.controller.dispatch({
                      type: "show-expressions-list",
                      focusHideIcon: false,
                    });
                break;
              case "qwertyKeyboard":
                this.setOption("qwertyKeyboard", !!i.qwertyKeyboard),
                  this.controller.isLetterKeypadOpen() &&
                  this.controller.dispatch({ type: "keypad/abc" });
                break;
              case "degreeMode":
                this.setOption("degreeMode", !!i.degreeMode),
                  this.controller.dispatch({
                    type: "set-graph-settings",
                    degreeMode: !!i.degreeMode,
                  });
                break;
              case "actions": {
                let p = i[t];
                if (
                  p === void 0 ||
                  p === this.controller.getGraphSettings().config.actions
                ) break;
                this.setOption(t, p),
                  this.setState(this.getState(), { allowUndo: true });
                break;
              }
              case "substitutions": {
                let p = i[t];
                if (
                  p === void 0 ||
                  p ===
                    this.controller.getGraphSettings().config
                      .substitutions
                ) break;
                this.setOption(t, p),
                  this.setState(this.getState(), { allowUndo: true });
                break;
              }
              case "intervalComprehensions": {
                let p = i[t];
                if (
                  p === void 0 ||
                  p ===
                    this.controller.getGraphSettings().config
                      .intervalComprehensions
                ) break;
                this.setOption(t, p),
                  this.setState(this.getState(), { allowUndo: true });
                break;
              }
              case "recursion": {
                let p = i[t];
                if (
                  p === void 0 ||
                  p ===
                    this.controller.getGraphSettings().config.recursion
                ) break;
                this.setOption(t, p),
                  this.setState(this.getState(), { allowUndo: true });
                break;
              }
              case "product":
              case "beta3d": {
                __dcg_shared_module_exports__["qe"].warn(
                  `Cannot update '${t}' setting.`,
                );
                break;
              }
              case "logScales": {
                let p = i[t];
                p !== void 0 &&
                  (p === false &&
                    this.controller.dispatch({
                      type: "set-graph-settings",
                      xAxisScale: "linear",
                      yAxisScale: "linear",
                    }),
                    this.setOption(t, p));
                break;
              }
              case "graphDescription": {
                let p = i[t];
                typeof p == "string" || typeof p == "undefined"
                  ? this.setOption(t, p)
                  : __dcg_shared_module_exports__["qe"].warn(
                    "Invalid graphDescription. graphDescription must be of type string or undefined.",
                  );
                break;
              }
              case "muted": {
                let p = i[t];
                if (
                  p === void 0 ||
                  p === this.controller.getGraphSettings().config.muted
                ) break;
                p
                  ? this.controller.dispatch({ type: "mute-global" })
                  : this.controller.dispatch({ type: "unmute-global" });
                break;
              }
              case "adaptivePeeling":
              case "advancedStyling":
              case "allowComplex":
              case "audio":
              case "audioTraceSimult":
              case "audioTraceReverseExpressions":
              case "authorFeatures":
              case "authorMode":
              case "autosize":
              case "backgroundColor":
              case "border":
              case "brailleControls":
              case "brailleMode":
              case "branding":
              case "cacheRenderedSvgs":
              case "capExpressionSize":
              case "clearIntoDegreeMode":
              case "colors":
              case "crossOriginSaveTest":
              case "customRegressions":
              case "decimalToFraction":
              case "debug3dRender":
              case "debugPeelLayers":
              case "debugPixelRatio":
              case "disableLighting":
              case "disableWorkerOnZoom":
              case "defaultLogModeRegressions":
              case "disableMouseInteractions":
              case "disableScrollFix":
              case "distributions":
              case "editOnWeb":
              case "enableTabindex":
              case "expressions":
              case "expressionsTopbar":
              case "folders":
              case "fontSize":
              case "forceEnableGeometryFunctions":
              case "forceLogModeRegressions":
              case "functionDefinition":
              case "ghostMode":
              case "graphpaper":
              case "hideGeoUI":
              case "imageUploadCallback":
              case "images":
              case "invertedColors":
              case "keypad":
              case "language":
              case "links":
              case "lockViewport":
              case "nativeOnscreenKeypad":
              case "notes":
              case "onlyTraceSelected":
              case "orientationButtons":
              case "pasteGraphLink":
              case "pasteGraphLinkCallback":
              case "pasteTableData":
              case "pauseWhenOffscreen":
              case "peelFloatTexture":
              case "peelUpsample":
              case "debugScale":
              case "perspectiveDistortion":
              case "plaidMode":
              case "plotImplicits":
              case "plotInequalities":
              case "plotSingleVariableImplicitEquations":
              case "pointsOfInterest":
              case "projectorMode":
              case "restrictedFunctions":
              case "settingsMenu":
              case "showHamburger":
              case "showKeyboardShortcutsInTooltips":
              case "showPerformanceMeter":
              case "showResetButtonOnGraphpaper":
              case "sixKeyInput":
              case "sliders":
              case "tableRegressions":
              case "textColor":
              case "tone":
              case "trace":
              case "translucentSurfaces":
              case "transparentBackground":
              case "translucentOpacity":
              case "wireframe":
              case "zoomButtons":
              case "recursionDepthLimit":
              case "debugProgressUpdates":
              case "logInternalErrors":
              case "reflectionArc":
              case "zoomFit": {
                let p = i[t];
                p !== void 0 && this.setOption(t, p);
                break;
              }
              default:
                return t;
            }
          }
        }
      }
      setViewport(e) {
        let t = new Br(e.xmin, e.xmax, e.ymin, e.ymax, e.zmin, e.zmax);
        this.grapher.viewportController.setViewport(t),
          this.controller.dispatch({
            type: "commit-user-requested-viewport",
            viewport: t,
          });
      }
      resize(e) {
        e &&
          this.controller.dispatch({
            type: "ui/container-resized",
            size: e,
          });
      }
      destroy() {
        var t;
        ee(document.documentElement).off(".calculator-" + this.__id),
          ee(this.rootElt).off(".calculator-" + this.__id),
          this.unsubFunc(),
          this.graphSettings.unobserveAll(),
          this.controller &&
          ((t = this.controller.toneController) == null || t.unload()),
          this.evaluator && this.evaluator.destroy(),
          this.grapher && this.grapher.remove(),
          sx.unmountFromNode(this.rootElt),
          this.rootElt.remove();
      }
      tick(e, t) {
        t ||
        (this.controller.handleTick(e),
          this.controller.updateRenderShellsAfterDispatch()),
          this.evaluator.tick(),
          this.grapher && this.grapher.tick(e);
      }
      getState(e) {
        return this.controller.getState(e);
      }
      setBlank(e) {
        this.controller.dispatch({ type: "set-blank", opts: e || {} });
      }
      setState(e, t) {
        this.controller.dispatch({
          type: "set-state",
          state: e,
          opts: t || {},
        });
      }
    };
  function xpe(r) {
    function e(t) {
      requestAnimationFrame(e), r(t);
    }
    requestAnimationFrame(e);
  }
  function wpe(r) {
    function e() {
      setTimeout(e, lx), r(Date.now());
    }
    setTimeout(e, lx);
  }
  var yj = Du("timeoutLoop"), lx = 0;
  typeof yj == "string" &&
    (lx = parseFloat(yj), isNaN(lx) && (lx = 1e3 / 60));
  var xj = lx > 0 ? wpe : xpe;
  var kR = new Kl();
  xj((r) => {
    kR.triggerEvent("tick", r);
  });
  var DR = 0;
  function Am(r) {
    return DR += 1,
      kR.observeEvent("tick." + DR, (e, t) => {
        r(t);
      }),
      DR;
  }
  function Mm(r) {
    kR.unobserveEvent("tick." + r);
  }
  var wj = Du("nworkers"), vj = 4;
  wj && (vj = parseInt(wj, 10));
  var cx = new ax(vj);
  function Cj(r, e) {
    let t = {}, o = {};
    for (let i in r) {
      FP(i) ? t[i] = r[i] : kK(i) ? o[i] = r[i] : e ||
        __dcg_shared_module_exports__["qe"].warn(
          "Unrecognized setting: " + i + ". Ignoring.",
        );
    }
    return { configOptions: t, settingsOptions: o };
  }
  function Sj(r, e) {
    let t = {};
    return e.hasOwnProperty("x") && (t.x = r.mapX(e.x)),
      e.hasOwnProperty("y") && (t.y = r.mapY(e.y)),
      t;
  }
  var Tj = [], IR = false, Ej = new Map();
  function vpe(r) {
    let e = Ej.get(r);
    return e || (e = new r(), Ej.set(r, e)), e;
  }
  function Dj(r) {
    if (!r || IR) return;
    let e;
    for (; (e = Tj.shift()) && e.api._destroyed;);
    if (!e) return;
    let t = e;
    IR = true;
    let { options: o, mathBounds: i, state: n, callback: a, api: s } = t,
      l = vpe(r),
      c = s._calc.controller.getGraphSettings().config,
      d = {};
    Object.keys(c).forEach((y) => {
      FP(y) && y !== "product" && y !== "beta3d" &&
        y !== "projectorMode" && (d[y] = c[y]);
    }),
      l.updateSettings(d),
      l.setState(n),
      l.setMathBounds(i);
    let p = l._calc.evaluator,
      h = () => {
        l._calc.grapher.asyncScreenshot(o, (y) => {
          IR = false, Dj(r), a(y);
        });
      },
      u = t.api._calc.controller,
      f = Am(() => {
        u.areAnyImagesLoading() || (Mm(f), p.notifyWhenSynced(h));
      });
  }
  var lu = class extends cs {
    constructor(t, o, i) {
      super();
      this._eventBus = new Kl();
      this._destroyed = false;
      this.isOffscreen = false;
      let n = Cj(o || {}, true),
        a = DD(n.configOptions),
        s = n.settingsOptions;
      this._calc = new C1(t, cx, a),
        this.controller = this._calc.controller,
        this.controller.onEventsEmitted = (l) => {
          let c = this.controller.getSelectedItem();
          this.setProperty("isAnyExpressionSelected", !!c),
            this.setProperty("selectedExpressionId", c ? c.id : void 0),
            this.setProperty(
              "expressionAnalysis",
              this.controller.getExpressionAnalysis(),
            );
          let d = Fe.getFocusedMathquill();
          this.setProperty("focusedMathQuill", d ? new TD(d) : void 0);
          for (let p in l) {
            if (!l.hasOwnProperty(p)) continue;
            let h = l[p];
            h && this._eventBus.triggerEvent(p, h);
          }
        },
        this._calc.graphpaperBounds.observeAndSync(
          "mathCoordinates",
          this._syncGraphpaperBounds.bind(this),
        ),
        this._calc.graphpaperBounds.observeAndSync(
          "pixelCoordinates",
          this._syncGraphpaperBounds.bind(this),
        ),
        this.colors = this.controller.getColors(),
        this._initGraphSettings(),
        this.updateSettings(s),
        this._sharedClockBusToken = Am((l) =>
          this.withControllerInAPIMode(() => {
            let c = this._calc.grapher.settings.config.pauseWhenOffscreen &&
              this.isOffscreen;
            this._calc.tick(l, c);
          })
        ),
        this.domChangeDetector = new Yg(
          t,
          (l) =>
            this.withControllerInAPIMode(() => {
              switch (this.isOffscreen = l.isOffscreen, l.type) {
                case "offscreen-noop":
                  break;
                case "added":
                  this._calc.resize(l.size);
                  break;
                case "removed":
                  break;
                case "resized":
                  this._calc.resize(l.size);
                  break;
              }
            }),
        ),
        a.autosize
          ? this.domChangeDetector.startWatching()
          : this.domChangeDetector.checkForChanges(),
        typeof i == "function" && i(this);
    }
    destroy() {
      this.controller.onEventsEmitted = function () {},
        this._calc.destroy(),
        Mm(this._sharedClockBusToken),
        this.domChangeDetector.destroy();
      function t(n) {
        __dcg_shared_module_exports__["qe"].warn(
          "You've destroyed this API instance. You can no longer call ." +
            n + "()",
        );
      }
      let o = {}, i = this;
      for (; i;) {
        Object.getOwnPropertyNames(i).forEach((a) => o[a] = true),
          i = Object.getPrototypeOf(i);
      }
      for (let n in o) {
        typeof this[n] == "function"
          ? this[n] = t.bind(this, n)
          : this.hasOwnProperty(n) && delete this[n];
      }
      this.destroy = function () {}, this._destroyed = true;
    }
    withHistoryReplacement(t) {
      try {
        this.controller.pushWithHistoryReplacement(), t();
      } finally {
        this.controller.popWithHistoryReplacement();
      }
    }
    withControllerInAPIMode(t) {
      try {
        return this.controller.pushAPIMethodCall(), t();
      } finally {
        this.controller.popAPIMethodCall();
      }
    }
    _syncGraphpaperBounds() {
      return this.withControllerInAPIMode(() => {
        this.controller.runAfterDispatch(() => {
          this.setProperty("graphpaperBounds", {
            mathCoordinates: this._calc.graphpaperBounds.mathCoordinates,
            pixelCoordinates: this._calc.graphpaperBounds.pixelCoordinates,
          });
        });
      });
    }
    observeEvent(t, o) {
      return this._eventBus.observeEvent(t, o);
    }
    unobserveEvent(t) {
      this._eventBus.unobserveEvent(t);
    }
    _initGraphSettings() {
      return this.withControllerInAPIMode(() => {
        let t = new cs();
        this.settings = this.graphSettings = t,
          DK.forEach((o) => {
            this._calc.grapher.settings.observeAndSync(o, () => {
              this.controller.runAfterDispatch(() => {
                t.setProperty(o, this._calc.grapher.settings[o]);
              });
            });
          }),
          IK.forEach((o) => {
            this._calc.grapher.settings.config.observeAndSync(o, () => {
              this.controller.runAfterDispatch(() => {
                t.setProperty(o, this._calc.grapher.settings.config[o]);
              });
            });
          });
      });
    }
    updateSettings(t) {
      return this.withControllerInAPIMode(() => {
        let o = Cj(t, false), i = o.configOptions, n = o.settingsOptions;
        __dcg_shared_module_exports__["F"](i) || this._calc.setOptions(i),
          __dcg_shared_module_exports__["F"](n) ||
          this.controller.dispatch({
            type: "set-graph-settings",
            ...this.controller.getGraphSettings().validateSettings(n),
          }),
          this.notifyControllerOfAPICall();
      });
    }
    setGraphSettings(t) {
      return this.withControllerInAPIMode(() => {
        __dcg_shared_module_exports__["qe"].warn(
          "As of API v0.8 the 'setGraphSettings' method is deprecated and has been renamed 'updateSettings.'",
        ),
          this.updateSettings(t),
          this.setGraphSettings = this.updateSettings,
          this.notifyControllerOfAPICall();
      });
    }
    setDefaultState(t) {
      return this.withControllerInAPIMode(() => {
        this._calc.grapher.settings.setProperty("defaultState", t),
          this.notifyControllerOfAPICall();
      });
    }
    mathToPixels(t) {
      return this.withControllerInAPIMode(() => {
        let o = __dcg_shared_module_exports__["jd"].fromRects(
          this.graphpaperBounds.mathCoordinates,
          this.graphpaperBounds.pixelCoordinates,
          {
            xAxisScale: this._calc.grapher.settings.xAxisScale,
            yAxisScale: this._calc.grapher.settings.yAxisScale,
          },
        );
        return Sj(o, t);
      });
    }
    pixelsToMath(t) {
      return this.withControllerInAPIMode(() => {
        let o = __dcg_shared_module_exports__["jd"].fromRects(
          this.graphpaperBounds.mathCoordinates,
          this.graphpaperBounds.pixelCoordinates,
          {
            xAxisScale: this._calc.grapher.settings.xAxisScale,
            yAxisScale: this._calc.grapher.settings.yAxisScale,
          },
        ).inverse();
        return Sj(o, t);
      });
    }
    notifyControllerOfAPICall() {
      return this.withControllerInAPIMode(() => {
        this.controller.dispatch({ type: "render" });
      });
    }
    setExpression(t) {
      return this.withControllerInAPIMode(() => {
        let i = this.controller.getItemModel(t.id),
          n = i && i.type,
          a = uD(t, n, this.controller);
        if (a) {
          if (n) {
            this.controller.dispatch({
              type: "set-expression-properties-from-api",
              id: a.id,
              properties: a,
            });
          } else {
            if (a.type === "image") return;
            this.controller.dispatch({
              type: "add-item-to-end-from-api",
              state: a,
            });
          }
        }
      });
    }
    setExpressions(t) {
      return this.withControllerInAPIMode(() => {
        t.forEach(this.setExpression.bind(this));
      });
    }
    removeExpression(t) {
      return this.withControllerInAPIMode(() => {
        let o = t.id.toString();
        this.controller.dispatch({ type: "remove-item-by-id", id: o });
      });
    }
    removeExpressions(t) {
      return this.withControllerInAPIMode(() => {
        t.forEach(this.removeExpression.bind(this));
      });
    }
    removeSelected() {
      return this.withControllerInAPIMode(() => {
        let t = this.controller.getSelectedItem();
        if (!t) return;
        let { id: o } = t;
        return this.controller.dispatch({
          type: "remove-item-by-id",
          id: o,
        }),
          o;
      });
    }
    setMathBounds(t) {
      return this.withControllerInAPIMode(() => {
        var h, u, f, y;
        let o = t,
          i = (h = o.xmin) != null ? h : o.left,
          n = (u = o.xmax) != null ? u : o.right,
          a = (f = o.ymin) != null ? f : o.bottom,
          s = (y = o.ymax) != null ? y : o.top,
          { zmin: l, zmax: c } = o,
          d,
          p;
        l === void 0 && c === void 0
          ? (d = true, p = false)
          : l === void 0 || c === void 0
          ? (d = false, p = true)
          : (d = l < c, p = true),
          i < n && a < s && d
            ? (this._calc.setViewport({
              xmin: i,
              xmax: n,
              ymin: a,
              ymax: s,
              zmin: l,
              zmax: c,
            }),
              this._calc.controller.unmarkLastChangedAxis(),
              this._calc.controller
                .markSquareAxesAfterUserEditedViewport())
            : __dcg_shared_module_exports__["qe"].warn(
              "Invalid bounds argument. " + p
                ? "Expected a bounds object with bounds.xmin < bounds.xmax, bounds.ymin < bounds.ymax, and bounds.zmin < bounds.zmax. "
                : "Expected a bounds object with bounds.xmin < bounds.xmax, and bounds.ymin < bounds.ymax. Got " +
                  JSON.stringify(t),
            ),
          this.notifyControllerOfAPICall();
      });
    }
    setViewport(t) {
      let [o, i, n, a] = t;
      return this.withControllerInAPIMode(() => {
        t.length == 4 && t[1] > t[0] && t[3] > t[2]
          ? (this._calc.setViewport({
            xmin: o,
            xmax: i,
            ymin: n,
            ymax: a,
          }),
            this._calc.controller.markSquareAxesAfterUserEditedViewport())
          : __dcg_shared_module_exports__["qe"].warn(
            "Invalid viewport.  Expected [xmin, xmax, ymin, ymax].  Got " +
              t,
          ), this.notifyControllerOfAPICall();
      });
    }
    resize() {
      return this.withControllerInAPIMode(() => {
        this.domChangeDetector.checkForChanges();
      });
    }
    getState(t) {
      return this.withControllerInAPIMode(() => this.controller.getState(t));
    }
    getExpressions() {
      return this.withControllerInAPIMode(() =>
        this.getState({ stripDefaults: false }).expressions.list.map(pD)
      );
    }
    setBlank(t) {
      return this.withControllerInAPIMode(() => {
        this.controller.dispatch({ type: "set-blank", opts: t || {} });
      });
    }
    setState(t, o) {
      return this.withControllerInAPIMode(() => {
        this.controller.dispatch({
          type: "set-state",
          state: t,
          opts: o || {},
        });
      });
    }
    undo() {
      return this.withControllerInAPIMode(() => {
        this.controller.dispatch({ type: "undo" });
      });
    }
    redo() {
      return this.withControllerInAPIMode(() => {
        this.controller.dispatch({ type: "redo" });
      });
    }
    clearHistory() {
      return this.withControllerInAPIMode(() => {
        this.controller.dispatch({ type: "clear-undoredo-history" });
      });
    }
    getHistory() {
      return this.withControllerInAPIMode(() => this.controller.getHistory());
    }
    restoreHistory(t) {
      return this.withControllerInAPIMode(() => {
        this.controller.dispatch({ type: "restore-history", history: t });
      });
    }
    newRandomSeed() {
      return this.withControllerInAPIMode(() => {
        this.updateSettings({ randomSeed: rd() });
      });
    }
    screenshot(t) {
      return this.withControllerInAPIMode(
        () => (t || (t = {}),
          t = this._validateBrailleScreenshotOptions(t),
          this._calc.grapher.screenshot(t)),
      );
    }
    _getMathAspectRatio() {
      return this.withControllerInAPIMode(() => {
        let t = this.graphpaperBounds.mathCoordinates,
          o = this._calc.grapher.getProjection().pixelCoordinates,
          i = o.right - o.left,
          n = o.bottom - o.top,
          a = t.width / i,
          s = t.height / n;
        return a / s;
      });
    }
    isProjectionUniform() {
      return this.withControllerInAPIMode(() =>
        !!this._calc.grapher.getProjection().settings.squareAxes
      );
    }
    _validateBrailleScreenshotOptions(t) {
      return this.withControllerInAPIMode(() => {
        t = __dcg_shared_module_exports__["Jc"](t);
        let o = t.braille;
        if (o) {
          let i = o.embosserModel;
          if (!i) {
            return __dcg_shared_module_exports__["qe"].warn(
              "Screenshot braille options requires an embosser model to be specified. ",
            ),
              __dcg_shared_module_exports__["qe"].warn(
                "Continuing with non-braille screenshot.",
              ),
              delete t.braille,
              t;
          }
          if (
            i === "etc" && (o.embosserModel = "etc11"),
              i === "vpmax" && (o.embosserModel = "vpmax11"),
              o.embosserModel !== "etc8" && o.embosserModel !== "etc11" &&
              o.embosserModel !== "vpmax8" &&
              o.embosserModel !== "vpmax11"
          ) {
            return __dcg_shared_module_exports__["qe"].warn(
              'Unknown screenshot braille embosser model. Valid models are "etc" and "vpmax".',
            ),
              __dcg_shared_module_exports__["qe"].warn(
                "Continuing with non-braille screenshot.",
              ),
              delete t.braille,
              t;
          }
          o.brailleMode !== "nemeth" && o.brailleMode !== "ueb" &&
          (__dcg_shared_module_exports__["qe"].warn(
            "Screenshot options braille.brailleMode must be nemeth or ueb. Proceeding with nemeth.",
          ),
            o.brailleMode = "nemeth"),
            t.width &&
            (__dcg_shared_module_exports__["qe"].warn(
              "Screenshot width option is ignored when exporting Braille.",
            ),
              delete t.width),
            t.height &&
            (__dcg_shared_module_exports__["qe"].warn(
              "Screenshot height option is ignored when exporting Braille.",
            ),
              delete t.height),
            t.targetPixelRatio &&
            (__dcg_shared_module_exports__["qe"].warn(
              "Screenshot targetPixelRatio option is ignored when exporting Braille.",
            ),
              delete t.targetPixelRatio),
            t.preserveAxisNumbers &&
            (__dcg_shared_module_exports__["qe"].warn(
              "Screenshot preserveAxisNumbers option is ignored when exporting Braille.",
            ),
              delete t.preserveAxisNumbers);
        }
        return t;
      });
    }
    _validateAsyncScreenshotOpts(t) {
      return this.withControllerInAPIMode(() => {
        t = __dcg_shared_module_exports__["Jc"](t);
        let o = t.mode ||
            (this.controller.getGraphSettings().squareAxes
              ? "preserveX"
              : "stretch"),
          i = t.width || t.height ||
            this.graphpaperBounds.pixelCoordinates.width,
          n = t.height || t.width ||
            this.graphpaperBounds.pixelCoordinates.height,
          a = t.targetPixelRatio || 1;
        a < 1 && (a = 1);
        let s = t.preserveAxisNumbers;
        t.hasOwnProperty("format") ||
          (t.svg ? (t.format = "svg", delete t.svg) : t.format = "png");
        let l = t.mathBounds || {},
          c = this._getMathAspectRatio(),
          d = this.graphpaperBounds.pixelCoordinates.width /
            this.graphpaperBounds.pixelCoordinates.height,
          p = _K({
            mode: o,
            width: i,
            height: n,
            currentBounds: this.graphpaperBounds.mathCoordinates,
            graphpaperAspectRatio: d,
            mathAspectRatio: c,
            mathBounds: l,
          });
        return {
          opts: {
            ...t,
            width: i,
            height: n,
            targetPixelRatio: a,
            preserveAxisNumbers: s,
          },
          mathBounds: p,
        };
      });
    }
    asyncScreenshot(...t) {
      var n;
      if (!t.length) {
        __dcg_shared_module_exports__["qe"].warn(
          "asyncScreenshot expects a callback",
        );
        return;
      }
      let o, i;
      if (t.length === 1) {
        if (typeof t[0] != "function") {
          __dcg_shared_module_exports__["qe"].warn(
            "asyncScreenshot expects a callback",
          );
          return;
        } else i = t[0], o = {};
      } else i = t[1], o = (n = t[0]) != null ? n : {};
      return this.withControllerInAPIMode(() => {
        o = this._validateBrailleScreenshotOptions(o);
        let { opts: a, mathBounds: s } = this
          ._validateAsyncScreenshotOpts(o);
        Tj.push({
          api: this,
          options: a,
          mathBounds: s,
          state: this.getState(),
          callback: i,
        }), Dj(this.constructor);
      });
    }
    setOptions(t) {
      return this.withControllerInAPIMode(() => {
        let o = this._calc.setOptions(t);
        return this.notifyControllerOfAPICall(), o;
      });
    }
    focusFirstExpression() {
      return this.withControllerInAPIMode(() => {
        this.controller.dispatch({ type: "focus-first-expression" });
      });
    }
    openKeypad() {
      return this.withControllerInAPIMode(() => {
        this.controller.dispatch({
          type: "keypad/set-minimized",
          minimized: false,
        });
      });
    }
    HelperExpression(t) {
      return this.withControllerInAPIMode(() => {
        let o = (t == null ? void 0 : t.latex) || "",
          i = new cs({ latex: o });
        return this.controller.dispatch({
          type: "add-helper-expression",
          state: {
            type: "helper-expression",
            id: this.controller.generateId(),
            latex: o,
            proxy: i,
          },
        }),
          i;
      });
    }
    getHelperExpressions() {
      return this.withControllerInAPIMode(() =>
        this.controller.getHelperExpressions()
      );
    }
  };
  var dx = class extends lu {
    constructor(t, o, i) {
      super(t, { ...o, product: "graphing-3d" }, i);
      this.mathToPixels = void 0;
      this.pixelsToMath = void 0;
    }
    asyncScreenshot() {
      throw new Error(
        "asyncScreenshot() is currently unimplemented in 3D. Use screenshot() instead.",
      );
    }
  };
  mg();
  Ss();
  var S1 = class {
    constructor(
      {
        evaluationMode: e,
        additionalFunctions: t,
        disableParentheses: o,
        functionDefinition: i,
        replaceRoundWithReciprocal: n,
        workerPool: a,
      },
    ) {
      this._evaluations = {};
      this._nextObjectId = 0;
      this.store = new Nc({
        expressions: {
          1: {
            id: "1",
            latex: "",
            braille: "",
            type: "latex",
            displayAsFraction: false,
          },
        },
        order: ["1"],
        settings: { degreeMode: false, complex: false },
        ui: { focus: void 0 },
      });
      this.evaluationMode = e,
        this.additionalFunctions = t,
        this.disableParentheses = o,
        this.functionDefinition = i,
        this.replaceRoundWithReciprocal = n,
        this.workerPool = a,
        this._setupEvaluator(),
        this.clear(),
        this._sharedClockBusToken = Am(() => {
          this._evaluator.tick();
        });
    }
    isSingleExpression() {
      return this.evaluationMode === "singleExpressionScientific" ||
        this.evaluationMode === "singleExpressionFourFunction";
    }
    destroy() {
      Mm(this._sharedClockBusToken);
    }
    generateObjectId() {
      return (this._nextObjectId++).toString();
    }
    updateNextObjectId() {
      let e = this.store.getState().order;
      this._nextObjectId = 0;
      let t = /^[0-9]+$/;
      for (let o of e) {
        if (t.test(o)) {
          let i = parseInt(o, 10);
          i >= this._nextObjectId && (this._nextObjectId = i + 1);
        }
      }
    }
    clearShouldDebounceUndoRedo() {
      this._shouldDebounceUndoRedo = false;
    }
    markShouldDebounceUndoRedo() {
      this._shouldDebounceUndoRedo = true;
    }
    getShouldDebounceUndoRedo() {
      return this._shouldDebounceUndoRedo;
    }
    clearCachedBrailleValues() {
      for (let e of this.getExpressionOrder()) {
        this.store.set(["expressions", e, "braille"], "");
      }
    }
    getState() {
      return this.store.getState();
    }
    getPersistedState() {
      let { expressions: e, order: t, settings: o } = this.getState();
      return {
        expressions: {
          list: t.map((i) => {
            let n = e[i];
            return {
              id: n.id,
              latex: n.latex,
              displayAsFraction: n.displayAsFraction,
            };
          }),
        },
        settings: o,
      };
    }
    setState(e) {
      this.store.set(e), this._updateIndexes(), this.updateNextObjectId();
    }
    setStateFromAPI(e) {
      let t = [], o = {}, { settings: i } = e;
      i.complex && i.degreeMode && (i = { ...i, degreeMode: false }),
        e.expressions.list.forEach(
          ({ id: n, latex: a, displayAsFraction: s }) => {
            t.push(n),
              o[n] = {
                id: n,
                latex: a,
                displayAsFraction: s,
                braille: "",
                type: "latex",
              };
          },
        ),
        this.setState({
          expressions: o,
          order: t,
          settings: i,
          ui: { focus: void 0 },
        });
    }
    canClear() {
      if (this.getNumberOfExpressions() > 1) return true;
      let e = this.getExpressionOrder()[0];
      return this.getExpressionLatex(e) !== "";
    }
    clear() {
      this.setState({
        expressions: {
          1: {
            id: "1",
            type: "latex",
            latex: "",
            braille: "",
            displayAsFraction: false,
          },
        },
        ui: { focus: void 0 },
        order: ["1"],
        settings: this.getState().settings,
      });
    }
    getExpressionOrder() {
      return this.store.getState().order;
    }
    getNumberOfExpressions() {
      return this.getExpressionOrder().length;
    }
    getExpressionById(e) {
      return this.getState().expressions[e];
    }
    getExpressionIndex(e) {
      return this._indexes[e];
    }
    _getExpressionByIndex(e) {
      let t = this.getExpressionOrder()[e];
      return this.getExpressionById(t);
    }
    _updateIndexes() {
      this._indexes = {};
      let e = 0;
      for (let t of this.getExpressionOrder()) {
        this._indexes[t] = e, e += 1;
      }
      this._evaluate();
    }
    _usesAnsById(e) {
      return this.getExpressionById(e).latex.indexOf(
        "\\operatorname{ans}",
      ) !== -1;
    }
    _getPreviousExpById(e) {
      let t = this.getExpressionIndex(e);
      return this._getExpressionByIndex(t - 1);
    }
    createBlankAfterId(e) {
      if (this.isSingleExpression() || !this.getExpressionById(e).latex) {
        return;
      }
      let t = this.getExpressionIndex(e), o = this.generateObjectId();
      this.store.shallowMutate("order", (i) => {
        i.splice(t + 1, 0, o);
      }),
        this.store.shallowMutate("expressions", (i) => {
          i[o] = {
            id: o,
            latex: "",
            braille: "",
            type: "latex",
            displayAsFraction: false,
          };
        }),
        this._updateIndexes(),
        this.setFocusedById(o, true);
    }
    conditionallyCopyPrevious(e) {
      let t = this._getPreviousExpById(e), o = this.getExpressionById(e);
      t != null && o.latex === "" && this._usesAnsById(t.id) &&
        this.setLatexById(e, t.latex);
    }
    backspaceAtFrontOfId(e) {
      if (
        this.getExpressionById(e).latex !== "" ||
        this.getNumberOfExpressions() === 1
      ) return;
      let o = this.getExpressionIndex(e);
      this.store.shallowMutate("order", (i) => {
        i.splice(o, 1);
      }),
        this.store.shallowMutate("expressions", (i) => {
          delete i[e];
        }),
        this._updateIndexes(),
        this._setFocusedByIndex(Math.max(o - 1, 0), true);
    }
    setLatexById(e, t) {
      this.store.set(["expressions", e, "latex"], t),
        this.store.set(["expressions", e, "braille"], ""),
        t === "" && this.setFractionEvaluation(e, false),
        this._evaluate();
    }
    setLatexAndBrailleById(e, t, o) {
      this.store.set(["expressions", e, "latex"], t),
        this.store.set(["expressions", e, "braille"], o),
        t === "" && this.setFractionEvaluation(e, false),
        this._evaluate();
    }
    setFractionEvaluation(e, t) {
      this.store.set(["expressions", e, "displayAsFraction"], t);
    }
    setLatexOfFocusedExpression(e) {
      let t = this.getFocusedExpressionId();
      t && this.setLatexById(t, e);
    }
    isExpressionFocused(e) {
      return this.getFocusedExpressionId() === e;
    }
    getExpressionLatex(e) {
      return this.getExpressionById(e).latex;
    }
    getExpressionError(e) {
      var t;
      return (t = this._evaluations[e]) == null ? void 0 : t.error;
    }
    getExpressionValue(e) {
      var t, o;
      return (o = (t = this._evaluations[e]) == null
          ? void 0
          : t.typedConstantValue) == null
        ? void 0
        : o.value;
    }
    getExpressionTypedConstantValue(e) {
      var t;
      return (t = this._evaluations[e]) == null ? void 0 : t.typedConstantValue;
    }
    getExpressionAns(e) {
      var o, i;
      let t = (o = this._evaluations[e]) == null ? void 0 : o.ansId;
      return t !== void 0
        ? (i = this._evaluations[t]) == null ? void 0 : i.typedConstantValue
        : t;
    }
    getExpressionAnsId(e) {
      var t;
      return (t = this._evaluations[e]) == null ? void 0 : t.ansId;
    }
    shouldShowEvaluationForExpression(e) {
      let t = this._evaluations[e];
      return t ? t.showEvaluation : false;
    }
    isRationalizableConstant(e) {
      let t = this._evaluations[e];
      return t ? t.isRationalizableConstant : false;
    }
    canDisplayEvaluationAsFraction(e) {
      let t = this.getExpressionValue(e);
      return !t || typeof t != "number"
        ? false
        : __dcg_shared_module_exports__["canDisplayAsFraction"](t);
    }
    isEvaluationList(e) {
      var t;
      return __dcg_shared_module_exports__["isList"](
        (t = this.getExpressionTypedConstantValue(e)) == null
          ? void 0
          : t.valueType,
      );
    }
    _setFocusedByIndex(e, t) {
      let o = this._getExpressionByIndex(e),
        i = this.store.getState().ui.focus,
        n = t ? { type: "latex-expression", id: o.id } : void 0;
      if (!__dcg_shared_module_exports__["E"](i, n)) {
        if (i) {
          let a = i.id;
          this.store.deepMutate("expressions", (s) => {
            let l = s[a];
            l && (l.braille = "");
          });
        }
        !t && this.getFocusedExpressionId() !== o.id ||
          this.store.shallowMutate("ui", (a) => {
            a.focus = n;
          });
      }
    }
    setFocusedById(e, t) {
      let o = this.getExpressionIndex(e);
      this._setFocusedByIndex(o, t);
    }
    focusPrevById(e) {
      let t = this.getExpressionIndex(e) - 1;
      t >= 0 && this._setFocusedByIndex(t, true);
    }
    focusNextById(e) {
      let t = this.getExpressionIndex(e) + 1;
      t < this.getNumberOfExpressions()
        ? this._setFocusedByIndex(t, true)
        : this.createAtEnd();
    }
    getFocusedExpression() {
      let e = this.getFocusedExpressionId();
      if (e) return this.getExpressionById(e);
    }
    getFocusedExpressionId() {
      let e = this.getState().ui.focus;
      return e && e.id;
    }
    clearFocusedExpression() {
      let e = this.getFocusedExpression();
      e && this.setLatexById(e.id, "");
    }
    shouldShowClear() {
      if (this.getNumberOfExpressions() === 1) return false;
      let e = this.getFocusedExpression();
      return !!e && !!e.latex;
    }
    getLastExpression() {
      return this._getExpressionByIndex(
        this.getNumberOfExpressions() - 1,
      );
    }
    isLastExpressionEmpty() {
      return !!this.getLastExpression().latex;
    }
    createAtEnd() {
      this.createBlankAfterId(this.getLastExpression().id);
    }
    focusLastExpression() {
      this._setFocusedByIndex(this.getNumberOfExpressions() - 1, true);
    }
    focusFirstExpression() {
      this._setFocusedByIndex(0, true);
    }
    getDegreeMode() {
      return this.getState().settings.degreeMode;
    }
    setDegreeMode(e) {
      this.getComplexMode() ||
        (this.store.set(["settings", "degreeMode"], e), this._evaluate());
    }
    getComplexMode() {
      return !!this.getState().settings.complex;
    }
    setComplexMode(e) {
      this.store.set(["settings", "complex"], e),
        e && this.store.set(["settings", "degreeMode"], false),
        this._evaluate();
    }
    _cleanupLatex(e) {
      return e = __dcg_shared_module_exports__["trimLatex"](e),
        e.substr(e.length - 1) === "=" && (e = e.substr(0, e.length - 1)),
        e;
    }
    _evaluate() {
      this._evaluator.clearStatementsAndStartCompleteState(),
        this.getExpressionOrder().forEach((e) =>
          this._evaluator.addStatement({
            id: e,
            index: this.getExpressionIndex(e),
            latex: this._cleanupLatex(this.getExpressionLatex(e)),
            shouldGraph: false,
            type: "statement",
          })
        );
    }
    getAdditionalFunctions() {
      return this.getComplexMode()
        ? [
          ...this.additionalFunctions,
          ...__dcg_shared_module_exports__["Hb"],
        ]
        : this.additionalFunctions;
    }
    _setupEvaluator() {
      this._evaluator = new Nh(this.workerPool),
        this._evaluator.readEvaluatorConfig = () => ({
          degreeMode: this.getDegreeMode(),
          evaluationMode: this.evaluationMode,
          additionalFunctions: this.getAdditionalFunctions(),
          disableParentheses: this.disableParentheses,
          functionDefinition: this.functionDefinition,
          replaceRoundWithReciprocal: this.replaceRoundWithReciprocal,
          complex: this.getComplexMode(),
          actions: false,
        }),
        this._evaluator.onEvaluatorResults = (e) => {
          var i;
          let t = e.evaluationStates;
          this._evaluations = {};
          for (let n in t) {
            let a = t[n];
            if (!this.getExpressionById(n)) continue;
            let { value: l, valueType: c } =
                (i = a.typed_constant_value) != null ? i : {},
              d = !a.is_evaluable &&
                c === __dcg_shared_module_exports__["Number"] &&
                __dcg_shared_module_exports__["canDisplayAsFraction"](l);
            this._evaluations[n] = {
              error: a.error,
              ansId: void 0,
              typedConstantValue: a.typed_constant_value,
              showEvaluation: a.is_evaluable || d ||
                c === __dcg_shared_module_exports__["ListOfNumber"],
              isRationalizableConstant: d,
            };
          }
          let o;
          for (let n of this.getExpressionOrder()) {
            let a = this._evaluations[n];
            o && a && (a.ansId = o), o = n;
          }
          typeof this.onEvaluationUpdate == "function" &&
            this.onEvaluationUpdate();
        };
    }
    reloadState() {
      this.setState(this.getState());
    }
    getFunctionDefinition() {
      return !!this.functionDefinition;
    }
    enableFunctionDefinition() {
      this.functionDefinition = true, this.reloadState();
    }
    disableFunctionDefinition() {
      this.functionDefinition = false, this.reloadState();
    }
    getReplaceRoundWithReciprocal() {
      return !!this.replaceRoundWithReciprocal;
    }
    enableReplaceRoundWithReciprocal() {
      this.replaceRoundWithReciprocal = true, this.reloadState();
    }
    disableReplaceRoundWithReciprocal() {
      this.replaceRoundWithReciprocal = false, this.reloadState();
    }
  };
  var E1 = class {
    constructor(e, t) {
      this.keyboardMode = "main";
      this.fontSize = 16;
      this.invertedColors = false;
      this.backgroundColor = "";
      this.textColor = "";
      this.projectorMode = false;
      this.capExpressionSize = false;
      this.decimalToFraction = true;
      this.settingsMenu = true;
      this.settingsMenuOpen = false;
      this.language = "en";
      this.brailleMode = "none";
      this.sixKeyInput = false;
      this.brailleControls = true;
      this.brailleExpressionDownload = true;
      this.replaceCommaWith10Exp = false;
      this.typingAsteriskWritesTimesSymbol = false;
      this.stateStack = new su();
      this.dispatcher = new U0();
      this.s = Ip(() => this.language);
      this.raw = Gs;
      this.dispatch = (e) => {
        Wx("dispatch", { type: e.type }), this.dispatcher.dispatch(e);
        let t;
        for (; t = this._queuedCallbacks.shift();) t();
      };
      this._queuedCallbacks = [];
      this.logEvent = (e) => {};
      this.stateStack = new su(),
        this.dispatcher = new U0(),
        this.options = e,
        this.model = new S1({
          evaluationMode: this.options.evaluationMode,
          additionalFunctions: this.options.additionalFunctions,
          disableParentheses: this.options.disableParentheses,
          functionDefinition: this.options.functionDefinition,
          replaceRoundWithReciprocal: this.options.replaceRoundWithReciprocal,
          workerPool: t.workerPool,
        }),
        this.model.setComplexMode(e.complex),
        this.model.setDegreeMode(e.degreeMode),
        this.setLanguage(e.language),
        this.setBrailleMode(e.brailleMode),
        this.setSixKeyInput(e.sixKeyInput),
        this.setBrailleControls(e.brailleControls),
        this.setBrailleExpressionDownload(e.brailleExpressionDownload),
        this.setReplaceCommaWith10Exp(e.replaceCommaWith10Exp),
        this.setReplaceRoundWithReciprocal(e.replaceRoundWithReciprocal),
        this.setTypingAsteriskWritesTimesSymbol(
          e.typingAsteriskWritesTimesSymbol,
        ),
        this.setProjectorMode(e.projectorMode),
        this.setCapExpressionSize(e.capExpressionSize),
        this.setDecimalToFraction(e.decimalToFraction),
        this.invertedColors = e.invertedColors,
        this.backgroundColor = e.backgroundColor,
        this.textColor = e.textColor,
        this.settingsMenu = e.settingsMenu,
        this.model.onEvaluationUpdate = () => this.dispatch({ type: "render" }),
        this.settingsProxy = t.settingsProxy,
        this.syncPublicSettings(),
        this.hookUpDispatcher(),
        this.containerSize = { width: 0, height: 0 };
    }
    runAfterDispatch(e) {
      this._queuedCallbacks.push(e);
    }
    enqueueEvent(e) {
      this.runAfterDispatch(() => {
        this.onEventEmitted && this.onEventEmitted(e);
      });
    }
    getSettingsMenu() {
      return this.settingsMenu;
    }
    getBrailleMode() {
      return this.brailleMode;
    }
    renderAsBraille() {
      return this.brailleMode !== "none";
    }
    setBrailleMode(e) {
      this.brailleMode = e;
    }
    getSixKeyInput() {
      return this.sixKeyInput;
    }
    setSixKeyInput(e) {
      this.sixKeyInput = e;
    }
    getBrailleControls() {
      return this.brailleControls;
    }
    setBrailleControls(e) {
      this.brailleControls = e;
    }
    getBrailleExpressionDownload() {
      return this.brailleExpressionDownload;
    }
    setBrailleExpressionDownload(e) {
      this.brailleExpressionDownload = e;
    }
    getRestrictedEditing() {
      return this.options.restrictedEditing;
    }
    getKeyboardMode() {
      return this.keyboardMode;
    }
    getFontSize() {
      return this.fontSize;
    }
    getInvertedColors() {
      return this.invertedColors;
    }
    hasBackgroundColor() {
      return this.getBackgroundColor() !== "#ffffff";
    }
    getBackgroundColor() {
      return __dcg_shared_module_exports__["Id"](
        this.backgroundColor || "#fff",
      );
    }
    hasTextColor() {
      return this.getTextColor() !== "#000000";
    }
    getTextColor() {
      return __dcg_shared_module_exports__["Id"](
        this.textColor || "#000",
      );
    }
    getAdditionalFunctions() {
      return this.options.additionalFunctions;
    }
    getDisableParentheses() {
      return this.options.disableParentheses;
    }
    getTypingSlashWritesDivisionSymbol() {
      return this.options.typingSlashWritesDivisionSymbol;
    }
    setTypingAsteriskWritesTimesSymbol(e) {
      this.typingAsteriskWritesTimesSymbol = e;
    }
    getTypingAsteriskWritesTimesSymbol() {
      return this.typingAsteriskWritesTimesSymbol;
    }
    setProjectorMode(e) {
      this.projectorMode = e;
    }
    isProjectorMode() {
      return this.projectorMode;
    }
    getReplaceCommaWith10Exp() {
      return this.replaceCommaWith10Exp;
    }
    setReplaceCommaWith10Exp(e) {
      this.replaceCommaWith10Exp = e;
    }
    getReplaceRoundWithReciprocal() {
      return this.model.getReplaceRoundWithReciprocal();
    }
    setReplaceRoundWithReciprocal(e) {
      e
        ? this.model.enableReplaceRoundWithReciprocal()
        : this.model.disableReplaceRoundWithReciprocal();
    }
    setCapExpressionSize(e) {
      this.capExpressionSize = e;
    }
    getCapExpressionSize() {
      return this.capExpressionSize;
    }
    setDecimalToFraction(e) {
      this.decimalToFraction = e;
    }
    setLanguage(e) {
      e !== "en" && !_T(e)
        ? __dcg_shared_module_exports__["qe"].warn(
          `Translation for '${e}' isn't currently available. Using '${this.language}' instead.`,
        )
        : this.language = e;
    }
    getLanguage() {
      return this.language;
    }
    getDecimalToFraction() {
      return this.decimalToFraction;
    }
    isScientificCalc() {
      let e = this.options.evaluationMode;
      return e === "scientific" || e === "singleExpressionScientific";
    }
    isFourFunctionCalc() {
      return this.options.evaluationMode === "fourFunction" ||
        this.options.evaluationMode === "singleExpressionFourFunction";
    }
    getAllowLinks() {
      return this.options.links;
    }
    canUndo() {
      return this.stateStack.canUndo();
    }
    canRedo() {
      return this.stateStack.canRedo();
    }
    undo(e) {
      if (!this.canUndo()) return;
      this.stateStack.undo();
      let t = this.stateStack.getState();
      e.restoreFocus || (t = { ...t, ui: { focus: void 0 } }),
        this.model.setState(t),
        this.enqueueEvent("change");
    }
    redo(e) {
      if (!this.canRedo()) return;
      this.stateStack.redo();
      let t = this.stateStack.getState();
      e.restoreFocus || (t = { ...t, ui: { focus: void 0 } }),
        this.model.setState(t),
        this.enqueueEvent("change");
    }
    clearHistory() {
      this.stateStack.clear();
    }
    canBackspace() {
      let e = this.model.getFocusedExpression();
      return e &&
        (e.latex.length > 0 || this.model.getNumberOfExpressions() > 1);
    }
    focusLastExpression() {
      this.model.focusLastExpression();
    }
    shouldRender() {
      return this.containerSize.width > 0 &&
        this.containerSize.height > 0;
    }
    canClear() {
      return this.model.canClear();
    }
    shouldShowClear() {
      return this.model.shouldShowClear();
    }
    enableSettingsMenu() {
      this.settingsMenu = true;
    }
    disableSettingsMenu() {
      this.closeSettingsMenu(), this.settingsMenu = false;
    }
    closeSettingsMenu() {
      this.settingsMenuOpen = false;
    }
    toggleSettingsMenu() {
      this.settingsMenuOpen = !this.settingsMenuOpen;
    }
    isSettingsMenuOpen() {
      return this.settingsMenuOpen;
    }
    isLastExpressionEmpty() {
      return this.model.isLastExpressionEmpty();
    }
    createAtEnd() {
      this.model.createAtEnd();
    }
    clearFocusedExpression() {
      this.model.clearFocusedExpression();
    }
    setLatexById(e, t) {
      this.model.setLatexById(e, t);
    }
    setLatexAndBrailleById(e, t, o) {
      this.model.setLatexAndBrailleById(e, t, o);
    }
    setLatexOfFocusedExpression(e) {
      this.model.setLatexOfFocusedExpression(e);
    }
    toggleFractionEvaluationById(e) {
      this.model.setFractionEvaluation(
        e,
        !this.model.getExpressionById(e).displayAsFraction,
      );
    }
    conditionallyCopyPrevious(e) {
      this.model.conditionallyCopyPrevious(e);
    }
    createBlankAfterId(e) {
      this.model.createBlankAfterId(e);
    }
    backspaceAtFrontOfId(e) {
      this.model.backspaceAtFrontOfId(e);
    }
    areStatesDifferentEnoughForUndoRedo(e, t) {
      let o = { focus: void 0 };
      return __dcg_shared_module_exports__["E"]({ ...e, ui: o }, {
        ...t,
        ui: o,
      });
    }
    commitUndoRedoDebounced() {
      let e = this.model.getState(), t = this.stateStack.getState();
      if (this.areStatesDifferentEnoughForUndoRedo(e, t)) return;
      let o = new Date().getTime();
      o - this._lastDebouncedTime < 1e3
        ? this.stateStack.replaceState(e)
        : this.stateStack.addState(e),
        this._lastDebouncedTime = o,
        this.enqueueEvent("change");
    }
    commitUndoRedoSynchronously() {
      let e = this.model.getState(), t = this.stateStack.getState();
      this.areStatesDifferentEnoughForUndoRedo(e, t) ||
        (this._lastDebouncedTime = 0,
          this.stateStack.addState(e),
          this.enqueueEvent("change"));
    }
    updateKeyboardMode(e) {
      this.keyboardMode = e;
    }
    getFocusedMathquill() {
      if (this.model.getFocusedExpressionId()) {
        return Fe.getFocusedMathquill();
      }
    }
    ensureMathquillIsFocusedAndReturnFocusedMathquill() {
      let e = this.getFocusedMathquill();
      if (e) return e;
      if (
        this.isLastExpressionEmpty() && !this.model.isSingleExpression()
          ? this.createAtEnd()
          : this.focusLastExpression(),
          this.onEventEmitted && this.onEventEmitted("render"),
          e = this.getFocusedMathquill(),
          !e
      ) throw new Error("No focused mathquill found");
      return e;
    }
    typeIntoFocusedMathquill(e) {
      e = e.replace(/\r|\n/g, "");
      let t = this.ensureMathquillIsFocusedAndReturnFocusedMathquill();
      t && Fe.canAcceptText(t, this.getCapExpressionSize(), e) &&
        (t.typedText(e),
          this.setLatexOfFocusedExpression(t.latex()),
          this.model.markShouldDebounceUndoRedo());
    }
    pressKeyInFocusedMathquill(e) {
      if (this.getBrailleMode() !== "none") return;
      let t = this.ensureMathquillIsFocusedAndReturnFocusedMathquill();
      if (!t) return;
      let { key: o, source: i, evt: n } = e;
      if (o === "Up" || o === "Down" || o === "Left" || o === "Right") {
        let a = i === "keypad"
            ? Fe.temporarilyOverrideLeftRightIntoCommandGoes(t, void 0)
            : void 0,
          s = Fe.applyArrowKeyAndReturnIfWasAtBounds(t, o, n);
        a == null || a(), s && this.moveFocusInDirection(o);
      } else {o === "Enter"
          ? (n && (n.preventDefault(), n.stopPropagation()), this.handleEnter())
          : o === "Backspace"
          ? this.attemptToMoveFocusWithBackspace() ||
            (t.keystroke(o, n), this.setLatexOfFocusedExpression(t.latex()))
          : o === "Delete"
          ? (t.keystroke(o, n), this.setLatexOfFocusedExpression(t.latex()))
          : (t.keystroke(o, n), this.setLatexOfFocusedExpression(t.latex()));}
    }
    moveFocusInDirection(e) {
      let t = this.model.getFocusedExpressionId();
      t &&
        (e === "Up"
          ? this.model.focusPrevById(t)
          : e === "Down" && this.model.focusNextById(t));
    }
    handleEnter() {
      if (this.model.isSingleExpression()) return;
      let e = this.model.getFocusedExpressionId();
      e &&
        (this.conditionallyCopyPrevious(e), this.createBlankAfterId(e));
    }
    attemptToMoveFocusWithBackspace() {
      let e = this.model.getFocusedExpression();
      if (!e) return false;
      let { latex: t, id: o } = e;
      return t === "" ? (this.backspaceAtFrontOfId(o), true) : false;
    }
    executeCommandInFocusedMathquill(e) {
      let t = this.ensureMathquillIsFocusedAndReturnFocusedMathquill();
      t &&
        (ZI(t, e, { capExpressionSize: this.getCapExpressionSize() }),
          this.setLatexOfFocusedExpression(t.latex()));
    }
    syncPublicSettings() {
      this.settingsProxy.setProperty("language", this.language),
        this.settingsProxy.setProperty("fontSize", this.fontSize),
        this.settingsProxy.setProperty(
          "degreeMode",
          this.model.getDegreeMode(),
        ),
        this.settingsProxy.setProperty(
          "invertedColors",
          this.invertedColors,
        ),
        this.settingsProxy.setProperty(
          "backgroundColor",
          this.backgroundColor,
        ),
        this.settingsProxy.setProperty("textColor", this.textColor),
        this.settingsProxy.setProperty("brailleMode", this.brailleMode),
        this.settingsProxy.setProperty("sixKeyInput", this.sixKeyInput),
        this.settingsProxy.setProperty(
          "brailleControls",
          this.brailleControls,
        ),
        this.settingsProxy.setProperty(
          "brailleExpressionDownload",
          this.brailleExpressionDownload,
        ),
        this.settingsProxy.setProperty(
          "projectorMode",
          this.projectorMode,
        ),
        this.settingsProxy.setProperty(
          "capExpressionSize",
          this.capExpressionSize,
        ),
        this.settingsProxy.setProperty(
          "decimalToFraction",
          this.decimalToFraction,
        ),
        this.settingsProxy.setProperty(
          "qwertyKeyboard",
          this.options.qwertyKeyboard,
        ),
        this.settingsProxy.setProperty("links", this.options.links),
        this.settingsProxy.setProperty("settingsMenu", this.settingsMenu),
        this.settingsProxy.setProperty(
          "functionDefinition",
          this.model.getFunctionDefinition(),
        ),
        this.settingsProxy.setProperty(
          "replaceCommaWith10Exp",
          this.replaceCommaWith10Exp,
        ),
        this.settingsProxy.setProperty(
          "replaceRoundWithReciprocal",
          this.model.getReplaceRoundWithReciprocal(),
        ),
        this.settingsProxy.setProperty(
          "typingAsteriskWritesTimesSymbol",
          this.typingAsteriskWritesTimesSymbol,
        );
    }
    getDegreeMode() {
      return this.model.getDegreeMode();
    }
    hookUpDispatcher() {
      this.dispatcher.register((e) => {
        this.enqueueEvent("render");
        let t = false, o = this.getRestrictedEditing();
        switch (e.type) {
          case "update-options": {
            this.options = { ...this.options, ...e.options };
            break;
          }
          case "keypad/shift":
            {
              let s;
              switch (this.keyboardMode) {
                case "qwerty":
                  s = "capitalQwerty";
                  break;
                case "capitalQwerty":
                  s = "qwerty";
                  break;
                case "letters":
                  s = "capitalLetters";
                  break;
                case "capitalLetters":
                  s = "letters";
                  break;
                default:
                  s = "qwerty";
              }
              this.updateKeyboardMode(s);
            }
            break;
          case "undo":
            o ||
              (this.undo({
                restoreFocus: e.source === "keyboard-shortcut",
              }),
                t = true);
            break;
          case "redo":
            o ||
              (this.redo({
                restoreFocus: e.source === "keyboard-shortcut",
              }),
                t = true);
            break;
          case "clear-history":
            this.clearHistory();
            break;
          case "set-state-from-api":
            e.opts.allowUndo || this.clearHistory(),
              this.model.setStateFromAPI(e.state);
            break;
          case "main":
            this.updateKeyboardMode("main");
            break;
          case "ABC":
            this.options.qwertyKeyboard
              ? this.updateKeyboardMode("qwerty")
              : this.updateKeyboardMode("letters");
            break;
          case "functions":
            this.updateKeyboardMode("functions");
            break;
          case "degrees":
            this.model.setDegreeMode(!this.model.getDegreeMode());
            break;
          case "update-degree-mode":
            this.model.setDegreeMode(!!e.mode);
            break;
          case "update-font-size":
            let i = e.size;
            if (typeof i != "number" && (i = parseInt(i, 10)), isNaN(i)) {
              return;
            }
            this.fontSize = i;
            break;
          case "update-inverted-colors":
            this.invertedColors = !!e.mode;
            break;
          case "update-background-color":
            this.backgroundColor = e.color;
            break;
          case "update-text-color":
            this.textColor = e.color;
            break;
          case "update-projector-mode":
            this.setProjectorMode(!!e.mode);
            break;
          case "update-cap-expression-size":
            this.setCapExpressionSize(!!e.mode);
            break;
          case "update-decimal-to-fraction":
            this.setDecimalToFraction(!!e.mode);
            break;
          case "update-language":
            this.setLanguage(e.language);
            break;
          case "set-blank":
            e.opts.allowUndo || this.clearHistory(),
              this.model.clear(),
              this.focusLastExpression();
            break;
          case "clear":
            this.model.clearFocusedExpression();
            break;
          case "set-braille-mode":
            let n = e.mode;
            n !== "nemeth" && n !== "ueb" && n !== "none"
              ? __dcg_shared_module_exports__["qe"].warn(
                `Valid Braille modes are 'nemeth', 'none', and 'ueb'. You passed '${n}'.`,
              )
              : (this.model.clearCachedBrailleValues(),
                this.setBrailleMode(e.mode));
            break;
          case "set-six-key-input":
            this.setSixKeyInput(!!e.useSixKeyInput);
            break;
          case "set-braille-controls":
            this.setBrailleControls(!!e.value);
            break;
          case "set-braille-expression-download":
            this.setBrailleExpressionDownload(!!e.mode);
            break;
          case "set-replace-comma-with-10-exp":
            this.setReplaceCommaWith10Exp(!!e.replace);
            break;
          case "set-replace-round-with-reciprocal":
            this.setReplaceRoundWithReciprocal(!!e.replace);
            break;
          case "set-typing-asterisk-writes-times-symbol":
            this.setTypingAsteriskWritesTimesSymbol(!!e.mode);
            break;
          case "update-latex":
            this.model.markShouldDebounceUndoRedo(),
              this.setLatexById(e.id, e.latex);
            break;
          case "update-latex-from-braille":
            this.model.markShouldDebounceUndoRedo(),
              this.setLatexAndBrailleById(e.id, e.latex, e.braille);
            break;
          case "focusin":
            this.model.setFocusedById(e.id, true);
            break;
          case "focusout":
            this.model.setFocusedById(e.id, false);
            break;
          case "focus-first-expression":
            this.model.focusFirstExpression();
            break;
          case "focus-prev-expression":
            this.moveFocusInDirection("Up");
            break;
          case "focus-next-expression":
            this.moveFocusInDirection("Down");
            break;
          case "focus-last-expression":
            this.model.focusLastExpression();
            break;
          case "insert-blank-expression":
            this.handleEnter();
            break;
          case "backspace-from-braille":
            this.attemptToMoveFocusWithBackspace();
            break;
          case "keypad/type-text":
            this.typeIntoFocusedMathquill(e.text);
            break;
          case "keypad/press-key":
            this.pressKeyInFocusedMathquill(e);
            break;
          case "keypad/custom-command":
            this.executeCommandInFocusedMathquill(e.command);
            break;
          case "keypad/123":
          case "keypad/abc":
          case "keypad/audio-trace":
            break;
          case "enable-settings-menu":
            this.enableSettingsMenu();
            break;
          case "disable-settings-menu":
            this.disableSettingsMenu();
            break;
          case "toggle-settings-menu":
            this.toggleSettingsMenu();
            break;
          case "close-settings-menu":
            this.closeSettingsMenu();
            break;
          case "render":
            break;
          case "ui/container-resized":
            this.containerSize = e.size;
            break;
          case "toggle-fraction-evaluation":
            this.toggleFractionEvaluationById(e.id);
            break;
          case "toggle-complex-mode":
            this.isComplexModeAllowed() &&
              this.model.setComplexMode(e.enabled);
            break;
          case "toggle-complex-allowed":
            this.options.allowComplex = e.enabled;
            break;
          default:
            return e;
        }
        this.runAfterDispatch(() => this.syncPublicSettings()),
          t ||
          (this.model.getShouldDebounceUndoRedo()
            ? (this.commitUndoRedoDebounced(),
              this.model.clearShouldDebounceUndoRedo())
            : this.commitUndoRedoSynchronously());
      });
    }
    getMathquillConfig() {
      let e = this.getAdditionalFunctions(),
        t = this.isFourFunctionCalc() &&
          (!e || e.indexOf("fraction") === -1);
      return {
        typingAsteriskWritesTimesSymbol: this
          .getTypingAsteriskWritesTimesSymbol(),
        typingSlashWritesDivisionSymbol: this
          .getTypingSlashWritesDivisionSymbol(),
        disableCopyPaste: this.getRestrictedEditing(),
        autoCommands: Pu({ disallowFrac: t }),
        ...Vf(),
      };
    }
    isComplexModeEnabled() {
      return this.model.getComplexMode() && this.isComplexModeAllowed();
    }
    isComplexModeAllowed() {
      return this.options.evaluationMode === "scientific" &&
        this.options.allowComplex;
    }
    canDisplayEvaluationAsFraction(e) {
      return this.getDecimalToFraction() &&
        this.model.canDisplayEvaluationAsFraction(e);
    }
    shouldDisplayEvaluationAsFraction(e) {
      return this.canDisplayEvaluationAsFraction(e) &&
        this.model.getExpressionById(e).displayAsFraction;
    }
    getEvaluationDigits() {
      return this.isScientificCalc() ? 10 : 7;
    }
    getLabelOptionsForExpression(e) {
      let t = this.model.getExpressionTypedConstantValue(e);
      return (t == null ? void 0 : t.valueType) ===
          __dcg_shared_module_exports__["Complex"]
        ? {
          ...__dcg_shared_module_exports__[
            "DEFAULT_COMPLEX_EVALUATION_LABEL_OPTIONS"
          ],
          digits: Math.min(
            this.getEvaluationDigits(),
            __dcg_shared_module_exports__[
              "DEFAULT_COMPLEX_EVALUATION_LABEL_OPTIONS"
            ].digits,
          ),
        }
        : {
          digits: this.getEvaluationDigits(),
          bigCutoff: 1e9,
          displayAsFraction: this.shouldDisplayEvaluationAsFraction(e),
        };
    }
    getEvaluationMode() {
      return this.options.evaluationMode;
    }
  };
  mg();
  var yr = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var ma = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  qt();
  var kj = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    nr = class extends kj.Class {
      init() {
        this.controller = this.props.controller(),
          this.model = this.controller.model,
          this.dispatch = this.controller.dispatch,
          this.s = this.controller.s;
      }
    };
  var $t = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: cu, Input: Cpe, Textarea: Spe } = $t.Components,
    T1 = class extends nr {
      constructor() {
        super(...arguments), this.lastBrailleModeDuringFocusChange = "none";
      }
      getAriaLabel() {
        let e = this.getIndex() + 1 + "";
        return this.s("shared-calculator-narration-expression-index", {
          index: e,
        });
      }
      didUpdate() {
        this.renderAnsValue();
      }
      didMountMQ(e) {
        this.mq = e;
      }
      getExp() {
        return this.model.getExpressionById(this.props.id());
      }
      getLatex() {
        return this.getExp().latex;
      }
      getValue() {
        return this.model.getExpressionValue(this.props.id());
      }
      getBraille() {
        let e = this.getExp().braille;
        if (e !== "") return e;
        {
          let t = qb(this.getLatex(), this.controller.getBrailleMode());
          return t.isError ? "" : sa.toExpandedBrailleAscii(t.value);
        }
      }
      getIndex() {
        return this.model.getExpressionIndex(this.props.id());
      }
      getShowEvaluation() {
        return this.model.shouldShowEvaluationForExpression(
          this.props.id(),
        );
      }
      isFractionEvaluation() {
        return this.getExp().displayAsFraction;
      }
      toggleFractionEvaluation() {
        this.dispatch({
          type: "toggle-fraction-evaluation",
          id: this.props.id(),
        });
      }
      getFractionDisplayAriaLabel() {
        return this.controller.shouldDisplayEvaluationAsFraction(
            this.props.id(),
          )
          ? this.controller.s(
            "basic-calculator-narration-convert-to-decimal",
          )
          : this.controller.s(
            "basic-calculator-narration-convert-to-fraction",
          );
      }
      getError() {
        let e = this.model.getExpressionError(this.props.id());
        return e && this.getLatex().length > 0
          ? Fl(e, this.controller.getLanguage())
          : "";
      }
      showError() {
        return !!this.getError();
      }
      getFractionMessage() {
        return this.controller.shouldDisplayEvaluationAsFraction(
            this.props.id(),
          )
          ? this.s("basic-calculator-label-convert-to-decimal")
          : this.s("basic-calculator-label-convert-to-fraction");
      }
      getIsFocused() {
        return !this.controller.isSettingsMenuOpen() &&
          this.model.isExpressionFocused(this.props.id());
      }
      onFocusedChanged(e) {
        let t = this.controller.getBrailleMode(),
          o = t !== this.lastBrailleModeDuringFocusChange;
        this.lastBrailleModeDuringFocusChange = t,
          !(!this.getExp() || o) &&
          (e
            ? this.dispatch({ type: "focusin", id: this.props.id() })
            : this.dispatch({ type: "focusout", id: this.props.id() }));
      }
      onMQReflow() {
        this.cachedRenderedAnsString = void 0, this.renderAnsValue();
      }
      renderAnsValue() {
        if (!this.mq) return;
        let e = this.model.getExpressionAnsId(this.props.id()), t;
        if (e !== void 0) {
          let o = this.controller.getLabelOptionsForExpression(e),
            i = this.model.getExpressionTypedConstantValue(e);
          switch (i == null ? void 0 : i.valueType) {
            case __dcg_shared_module_exports__["Complex"]:
              t = __dcg_shared_module_exports__["complexNumberLabel"](i.value, {
                ...o,
                digits: 5,
                scientificNotationDigits: 3,
              }, "html");
              break;
            case __dcg_shared_module_exports__["Number"]:
              t = __dcg_shared_module_exports__["truncatedHTMLLabel"](
                i.value,
                o,
              );
              break;
            default:
              __dcg_shared_module_exports__["isList"](
                i == null ? void 0 : i.valueType,
              ) && (t = "[...]");
              break;
          }
        }
        t !== this.cachedRenderedAnsString &&
          (this.mq.querySelectorAll(".dcg-mq-ans").forEach((o) => {
            t
              ? (o.classList.remove("dcg-invalid"), o.innerHTML = t)
              : (o.classList.add("dcg-invalid"),
                o.innerHTML =
                  '<i class="dcg-icon-error" aria-hidden="true"></i>');
          }),
            this.cachedRenderedAnsString = t);
      }
      getEvaluationLatex() {
        let e = this.props.id();
        if (
          this.model.isRationalizableConstant(e) &&
          !this.controller.shouldDisplayEvaluationAsFraction(e)
        ) return "";
        let t = this.controller.getLabelOptionsForExpression(e),
          o = this.model.getExpressionTypedConstantValue(e),
          i;
        switch (o == null ? void 0 : o.valueType) {
          case __dcg_shared_module_exports__["Complex"]:
            i = __dcg_shared_module_exports__["complexNumberLabel"](
              o.value,
              t,
              "latex",
            );
            break;
          case __dcg_shared_module_exports__["Number"]:
            i = __dcg_shared_module_exports__["truncatedLatexLabel"](
              o.value,
              t,
            );
            break;
          default:
            if (
              __dcg_shared_module_exports__["isList"](
                o == null ? void 0 : o.valueType,
              )
            ) return `\\mathrm{${o.value.length}\\ element\\ list}`;
            break;
        }
        return (i === "undefined" || i === void 0) &&
          (i = "\\mathrm{undefined}"),
          `=${i}`;
      }
      getEvaluationBraille() {
        let e = this.getEvaluationLatex(),
          t = qb(e, this.controller.getBrailleMode());
        return t.isError ? "" : sa.toExpandedBrailleAscii(t.value);
      }
      didMountBrailleInput(e) {
        this.brailleInputNode = e;
      }
      didUnmountBrailleInput() {
        this.brailleInputNode = void 0;
      }
      handleBrailleFocus(e) {
        let t = e.target;
        t && setTimeout(this.bindIfMounted(() => {
          t.setSelectionRange(0, 0);
        }));
      }
      handleBrailleKeydown(e) {
        !e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey &&
          (ke(e) === xa
            ? (this.forceModelFocus(),
              this.dispatch({ type: "focus-prev-expression" }),
              e.preventDefault())
            : ke(e) === Kn
            ? (this.forceModelFocus(),
              this.dispatch({ type: "focus-next-expression" }),
              e.preventDefault())
            : ke(e) === xg
            ? (this.forceModelFocus(),
              this.dispatch({ type: "insert-blank-expression" }),
              e.preventDefault())
            : ke(e) === _u &&
              document.activeElement === this.brailleInputNode &&
              this.getBraille() === "" &&
              (this.dispatch({ type: "backspace-from-braille" }),
                e.preventDefault()));
      }
      forceModelFocus() {
        document.activeElement !== this.brailleInputNode &&
          this.onFocusedChanged(true);
      }
      getPostLabel() {
        let e = this.props.id(),
          t = this.controller.getLabelOptionsForExpression(e);
        if (this.showError()) return this.getError();
        if (this.getShowEvaluation()) {
          let o = this.model.getExpressionTypedConstantValue(e), i = "";
          switch (o == null ? void 0 : o.valueType) {
            case __dcg_shared_module_exports__["Complex"]:
              i = __dcg_shared_module_exports__["complexNumberLabel"](
                o.value,
                t,
              );
              break;
            case __dcg_shared_module_exports__["Number"]:
              i = __dcg_shared_module_exports__["truncatedLatexLabel"](
                o.value,
                t,
              );
              break;
            default:
              if (
                __dcg_shared_module_exports__["isList"](
                  o == null ? void 0 : o.valueType,
                )
              ) return `${o.value.length} element list`;
              break;
          }
          return "equals " + Ao(i != null ? i : "undefined");
        }
        return "";
      }
      onBrailleInput(e) {
        this.controller.isSettingsMenuOpen() &&
          this.controller.dispatch({ type: "close-settings-menu" });
        let t = YT(
            sa.coerceToSixDotCells(e),
            this.controller.getBrailleMode(),
          ),
          o = t.isError ? "" : t.value;
        (!this.controller.getCapExpressionSize() || Of(o) <= zb) &&
          this.controller.dispatch({
            type: "update-latex-from-braille",
            latex: o,
            braille: e,
            id: this.props.id(),
          });
      }
      getIndexSubscript() {
        return `_{${this.getIndex() + 1}}`;
      }
      onMountContainer(e) {
        this.containerNode = e;
      }
      onTapContainer(e) {
        e.target === this.containerNode && !this.getShowEvaluation() &&
          !this.showError() && this.forceModelFocus();
      }
      template() {
        return $t.createElement(
          "div",
          {
            class: () => ({
              "dcg-basic-expression": true,
              "dcg-focused": this.getIsFocused(),
              "dcg-braille-io": this.controller.renderAsBraille(),
            }),
            onTap: this.bindFn(this.onTapContainer),
            onMount: this.bindFn(this.onMountContainer),
          },
          $t.createElement(cu, {
            predicate: () => this.controller.renderAsBraille(),
          }, () =>
            $t.createElement(
              "div",
              { class: $t.const("dcg-braille-input") },
              $t.createElement(Ug, {
                ariaLabel: () => {
                  let e = qb(
                    `eq${this.getIndexSubscript()}`,
                    this.controller.getBrailleMode(),
                  );
                  return e.isError ? "" : sa.toExpandedBrailleAscii(e.value);
                },
                didMount: this.bindFn(this.didMountBrailleInput),
                didUnmount: this.bindFn(this.didUnmountBrailleInput),
                onFocusedChanged: this.bindFn(this.onFocusedChanged),
                shouldFocus: this.bindFn(this.getIsFocused),
                onKeyDown: this.bindFn(this.handleBrailleKeydown),
                onInput: this.bindFn(this.onBrailleInput),
                sixKeyInput: () => this.controller.getSixKeyInput(),
                value: () => this.getBraille(),
                isStatic: this.const(false),
              }),
            )),
          $t.createElement(
            cu,
            { predicate: () => this.controller.renderAsBraille() },
            () =>
              $t.createElement(
                "div",
                { class: $t.const("dcg-braille-evaluation-container") },
                $t.createElement(
                  cu,
                  { predicate: () => this.getShowEvaluation() },
                  () =>
                    $t.createElement(
                      "div",
                      { class: $t.const("dcg-braille-evaluation") },
                      $t.createElement(Cpe, {
                        readOnly: this.const(true),
                        class: this.const("dcg-braille-evaluation-inner"),
                        value: () => this.getEvaluationBraille(),
                        onFocus: this.bindFn(this.handleBrailleFocus),
                        onKeyDown: this.bindFn(this.handleBrailleKeydown),
                        onInput: () => {},
                      }),
                    ),
                ),
                $t.createElement(
                  cu,
                  { predicate: () => this.showError() },
                  () =>
                    $t.createElement(
                      "div",
                      { class: $t.const("dcg-braille-error") },
                      $t.createElement(
                        "div",
                        { class: $t.const("dcg-basic-expression-error") },
                        $t.createElement("i", {
                          class: $t.const("dcg-icon-error"),
                          "aria-hidden": $t.const("true"),
                        }),
                      ),
                      $t.createElement(Spe, {
                        readOnly: this.const(true),
                        class: this.const("dcg-braille-error-inner"),
                        value: () => this.getError(),
                        onFocus: this.bindFn(this.handleBrailleFocus),
                        onKeyDown: this.bindFn(this.handleBrailleKeydown),
                        onInput: () => {},
                      }),
                    ),
                ),
              ),
          ),
          $t.createElement(
            cu,
            { predicate: () => this.controller.renderAsBraille() },
            () =>
              $t.createElement(
                "div",
                {
                  class: $t.const("dcg-exp-mathquill-container"),
                  didMount: this.bindFn(this.didMountMQ),
                  onTap: this.bindFn(this.forceModelFocus),
                },
                $t.createElement(nt, {
                  latex: () => this.getLatex(),
                  config: this.const({}),
                  onReflow: this.bindFn(this.onMQReflow),
                }),
              ),
          ),
          $t.createElement(
            cu,
            { predicate: () => !this.controller.renderAsBraille() },
            () =>
              $t.createElement(
                "div",
                {
                  class: $t.const("dcg-exp-mathquill-container"),
                  didMount: this.bindFn(this.didMountMQ),
                },
                $t.createElement(Fe, {
                  latex: () => this.getLatex(),
                  onReflow: this.bindFn(this.onMQReflow),
                  isFocused: this.bindFn(this.getIsFocused),
                  capExpressionSize: () =>
                    this.controller.getCapExpressionSize(),
                  config: this.bindFn(this.getMQConfig),
                  getAriaLabel: () => this.getAriaLabel(),
                  getAriaPostLabel: () => this.getPostLabel(),
                  hasError: () => false,
                  onUserPressedKey: (e, t) => {
                    this.controller.isSettingsMenuOpen() &&
                    this.controller.dispatch({
                      type: "close-settings-menu",
                    }),
                      this.dispatch({
                        type: "keypad/press-key",
                        key: e,
                        evt: t,
                        source: "keyboard",
                      });
                  },
                  onUserTypedText: (e) =>
                    this.dispatch({ type: "keypad/type-text", text: e }),
                  onUserChangedLatex: (e) => {
                    this.dispatch({
                      type: "update-latex",
                      id: this.props.id(),
                      latex: e,
                    });
                  },
                  onFocusedChanged: this.bindFn(this.onFocusedChanged),
                  disableSpace: () => this.controller.getRestrictedEditing(),
                }),
              ),
          ),
          $t.createElement(
            "div",
            { class: $t.const("dcg-exp-output-container") },
            $t.createElement(
              cu,
              {
                predicate: () =>
                  this.showError() && !this.controller.renderAsBraille(),
              },
              () =>
                $t.createElement(Di, {
                  error: this.bindFn(this.getError),
                  gravity: this.const("w"),
                }),
            ),
            $t.createElement(
              cu,
              { predicate: () => this.getShowEvaluation() },
              () =>
                $t.createElement(
                  "div",
                  {
                    class: () => ({
                      "dcg-basic-expression-value": true,
                      "dcg-basic-evaluation-gray": this.model
                        .isEvaluationList(this.props.id()),
                    }),
                  },
                  $t.createElement(nt, {
                    config: this.const({}),
                    latex: () => this.getEvaluationLatex(),
                  }),
                  $t.createElement(cu, {
                    predicate: () =>
                      this.controller.canDisplayEvaluationAsFraction(
                        this.props.id(),
                      ),
                  }, () =>
                    $t.createElement(
                      Le,
                      {
                        tooltip: this.bindFn(this.getFractionMessage),
                        gravity: this.const("s"),
                      },
                      $t.createElement(
                        "span",
                        {
                          role: $t.const("button"),
                          tabIndex: $t.const("0"),
                          "aria-label": this.bindFn(
                            this.getFractionDisplayAriaLabel,
                          ),
                          class: () => ({
                            "dcg-basic-fraction-toggle": true,
                            "dcg-selected": this.isFractionEvaluation(),
                          }),
                          onTap: this.bindFn(
                            this.toggleFractionEvaluation,
                          ),
                        },
                        $t.createElement("i", {
                          class: $t.const("dcg-icon-fraction"),
                          "aria-hidden": $t.const("true"),
                        }),
                      ),
                    )),
                ),
            ),
          ),
        );
      }
      getMQConfig() {
        return this.controller.getMathquillConfig();
      }
    };
  var { For: Epe, If: Tpe } = ma.Components,
    D1 = class extends nr {
      constructor() {
        super(...arguments),
          this.didShowAnswerHint = false,
          this.didHideAnswerHint = false;
      }
      template() {
        return ma.createElement(
          "div",
          {
            class: ma.const("dcg-basic-list-container"),
            role: ma.const("region"),
            "aria-label": () =>
              this.controller.s(
                "shared-calculator-narration-expression-list",
              ),
            didMount: this.bindFn(this.didMountContainer),
          },
          ma.createElement(
            "div",
            {
              class: ma.const("dcg-basic-list-placeholder"),
              didMount: this.bindFn(this.didMountPlaceholder),
            },
            ma.createElement(Tpe, {
              predicate: this.bindFn(this.showAnswerHint),
            }, () =>
              ma.createElement(
                "div",
                { class: ma.const("dcg-answer-hint") },
                () => this.controller.s("basic-calculator-label-answer-hint"),
                ma.createElement("i", {
                  class: ma.const("dcg-icon-curved-arrow"),
                }),
              )),
          ),
          ma.createElement(
            "div",
            {
              class: () => ({
                "dcg-basic-list": true,
                "dcg-projector-mode": this.controller.isProjectorMode(),
              }),
            },
            ma.createElement(Epe, {
              each: () => this.model.getExpressionOrder(),
            }, (e) =>
              ma.createElement(T1, {
                controller: this.props.controller,
                id: this.const(e),
              })),
          ),
        );
      }
      didMountPlaceholder(e) {
        ee(e).on("dcg-tap", Jr);
      }
      showAnswerHint() {
        if (this.didHideAnswerHint) return false;
        let e = this.model.getExpressionOrder()[0];
        return this.model.shouldShowEvaluationForExpression(e) ||
            this.didShowAnswerHint
          ? (this.didShowAnswerHint = true,
            this.model.getNumberOfExpressions() > 1 ||
              this.model.getExpressionLatex(e) === ""
              ? (this.didHideAnswerHint = true, false)
              : true)
          : false;
      }
      didUpdate() {
        if (!this.container) return;
        let e = this.container.querySelector(".dcg-focused");
        e && tc(e, this.container, 50);
      }
      didMountContainer(e) {
        this.container = e;
      }
    };
  var Co = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var bs = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { For: Dpe } = bs.Components,
    px = class extends bs.Class {
      template() {
        return bs.createElement(
          "tr",
          null,
          bs.createElement(
            "td",
            null,
            bs.createElement(Dpe, {
              each: () => this.getBrailleAscii(this.props.latex()),
              key: (e) => e.key,
            }, (e) =>
              bs.createElement("span", {
                class: bs.const("dcg-key-press"),
              }, () => e.char)),
          ),
          bs.createElement(
            "td",
            { class: bs.const("dcg-braille-font") },
            () => this.getBrailleUnicode(this.props.latex()),
          ),
          bs.createElement(
            "td",
            null,
            bs.createElement(nt, {
              config: this.const({}),
              latex: () => this.props.latex(),
            }),
          ),
        );
      }
      getBrailleAscii(e) {
        let t = sa.toExpandedBrailleAscii(this.getBrailleUnicode(e)),
          o = [];
        for (let i = 0; i < t.length; i++) {
          o.push({ char: t[i], key: i + ")" + t[i] });
        }
        return o;
      }
      getBrailleUnicode(e) {
        let t;
        return this.props.brailleMode() === "nemeth"
          ? t = lp(e)
          : this.props.brailleMode() === "ueb" && (t = cp(e)),
          t && t.value ? t.value : "";
      }
    };
  var Gm = class extends nr {
    template() {
      return Co.createElement(
        "div",
        {
          class: () => ({
            "dcg-braille-io-keypad-container": true,
            "dcg-has-background-color": this.controller
              .hasBackgroundColor(),
          }),
        },
        Co.createElement(
          "div",
          { class: Co.const("dcg-braille-io-keypad") },
          Co.createElement(
            "div",
            { class: Co.const("dcg-braille-description") },
            Co.createElement("div", {
              class: Co.const("dcg-braille-title"),
            }, () =>
              this.controller.s(
                "basic-calculator-text-braille-mode-is-on",
                { mode: this.brailleType() },
              )),
            Co.createElement("div", {
              class: Co.const("dcg-braille-info-text"),
            }, () =>
              this.controller.s(
                "basic-calculator-text-how-to-type-braille",
              )),
            Co.createElement("div", {
              class: Co.const("dcg-btn-blue"),
              role: Co.const("button"),
              tabIndex: Co.const(0),
              onTap: () =>
                this.controller.dispatch({
                  type: "set-braille-mode",
                  mode: "none",
                }),
            }, () =>
              this.controller.s(
                "basic-calculator-button-turn-braille-mode-off",
                { mode: this.brailleType() },
              )),
          ),
          Co.createElement(
            "div",
            { class: Co.const("dcg-braille-examples-table-container") },
            Co.createElement(
              "table",
              { class: Co.const("dcg-braille-examples-table") },
              Co.createElement(
                "tr",
                null,
                Co.createElement("th", null, () =>
                  this.controller.s(
                    "basic-calculator-heading-braille-table-type-this",
                  )),
                Co.createElement("th", null, () => this.brailleType()),
                Co.createElement(
                  "th",
                  null,
                  () =>
                    this.controller.s(
                      "basic-calculator-heading-braille-table-typeset",
                    ),
                ),
              ),
              Co.createElement(px, {
                brailleMode: () => this.controller.getBrailleMode(),
                latex: this.const("2+2"),
              }),
              Co.createElement(px, {
                brailleMode: () => this.controller.getBrailleMode(),
                latex: this.const("\\frac{1}{2}"),
              }),
              Co.createElement(px, {
                brailleMode: () => this.controller.getBrailleMode(),
                latex: this.const("\\sqrt{4}"),
              }),
            ),
            Co.createElement(
              "div",
              { class: Co.const("dcg-more-examples-link") },
              Co.createElement("a", {
                href: () =>
                  "https://www.desmos.com/braille-examples?" +
                  this.controller.getBrailleMode(),
                target: Co.const("_blank"),
              }, () =>
                this.controller.s(
                  "basic-calculator-link-view-braille-examples",
                )),
            ),
          ),
        ),
      );
    }
    brailleType() {
      return this.controller.getBrailleMode() === "nemeth"
        ? "Nemeth"
        : this.controller.getBrailleMode() === "ueb"
        ? "UEB"
        : "";
    }
  };
  var qo = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Lm = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Bc = class extends Cm {
    template() {
      return Lm.createElement(
        "div",
        {
          class: Lm.const("dcg-keypad-control-bar dcg-do-not-blur"),
          role: Lm.const("group"),
          "aria-label": () =>
            this.controller.s(
              "shared-calculator-narration-keypad-controlbar",
            ),
        },
        Lm.createElement("div", {
          class: Lm.const("dcg-keypad-control-bar-contents"),
        }, this.props.children),
      );
    }
  };
  var ux = __dcg_shared_module_exports__["defineDefaultExport"](ne()),
    _o = class extends ux.Class {
      template() {
        return ux.createElement("div", {
          class: () => ({
            "dcg-keypad-control-btn": true,
            "dcg-disabled": this.isDisabled(),
            "dcg-selected": !this.isDisabled() && this.isSelected(),
            "dcg-selectable-btn": !this.isDisabled() &&
              this.isSelectable(),
            "dcg-narrow-control-btn": this.props.narrowButton &&
              this.props.narrowButton(),
          }),
          didMount: this.bindFn(this.didMount),
          role: ux.const("button"),
          "aria-disabled": () => this.isDisabled() || void 0,
          "aria-label": () => this.getAriaLabel(),
          "dcg-command": this.props.command,
          onTap: this.bindFn(this.handleTap),
          "aria-pressed": () =>
            !this.hasPopup() && !this.isDisabled() && this.isSelectable()
              ? this.isSelected()
              : void 0,
          "aria-expanded": () =>
            this.hasPopup() && !this.isDisabled() ? this.isSelected() : void 0,
          tabIndex: this.bindFn(this.getTabIndex),
        }, this.props.children);
      }
      getTabIndex() {
        if (!this.isDisabled()) {
          return this.props.ignoreInTabOrder &&
              this.props.ignoreInTabOrder()
            ? -1
            : 0;
        }
      }
      handleTap(e) {
        this.isDisabled() || this.props.onTap(e);
      }
      getAriaLabel() {
        return this.props.ariaLabel
          ? this.props.ariaLabel()
          : this.props.command();
      }
      hasPopup() {
        var e, t;
        return !!((t = (e = this.props).ariaPopup) != null && t.call(e));
      }
      isDisabled() {
        var e, t;
        return !!((t = (e = this.props).disabled) != null && t.call(e));
      }
      isSelected() {
        var e, t;
        return !!((t = (e = this.props).selected) != null && t.call(e));
      }
      isSelectable() {
        var e, t;
        return !!((t = (e = this.props).selectable) != null && t.call(e));
      }
      didMount(e) {
        this.props.didMount && this.props.didMount(e);
      }
    };
  var lo = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var Yd = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  function kpe() {
    if (!NS) return false;
    let r = navigator.userAgent.match(/Version\/(\d+)/);
    return !r || !r[1] ? false : parseFloat(r[1]) < 11;
  }
  function _j() {
    return !Y5 && !kpe() &&
      typeof document.createElement("a").download != "undefined";
  }
  function Ij() {
    return _j() || navigator.msSaveBlob !== void 0;
  }
  var k1 = class extends Yd.Class {
    init() {
      this.supportsDirectDownload = _j();
    }
    template() {
      return Yd.createElement(
        "a",
        {
          role: Yd.const("button"),
          tabIndex: () => this.props.enabled() ? 0 : -1,
          "aria-disabled": () => this.props.enabled() ? void 0 : true,
          class: () => {
            var e, t, o, i, n, a;
            return {
              "dcg-download-button": true,
              "dcg-btn-blue":
                ((t = (e = this.props).buttonType) == null
                  ? void 0
                  : t.call(e)) === "primary",
              "dcg-btn-blue-outline":
                ((i = (o = this.props).buttonType) == null
                  ? void 0
                  : i.call(o)) === "secondary",
              "dcg-primary-link":
                ((a = (n = this.props).buttonType) == null
                  ? void 0
                  : a.call(n)) === "link",
              "dcg-disabled": !this.props.enabled(),
            };
          },
          didMount: this.bindFn(this.didMountDownload),
          didUnmount: this.bindFn(this.didUnmountDownload),
          didUpdate: this.bindFn(this.didUpdate),
          download: () =>
            this.supportsDirectDownload ? this.props.filename() : void 0,
          onTap: (e) => {
            var o, i;
            if (
              (i = (o = this.props).triggerLogEvent) == null || i.call(o),
                this.supportsDirectDownload || !navigator.msSaveOrOpenBlob
            ) return;
            let t = this.props.data();
            t &&
              (navigator.msSaveOrOpenBlob(t, this.props.filename()),
                e.preventDefault());
          },
        },
        Yd.createElement("i", {
          class: Yd.const("dcg-icon-download"),
          "aria-hidden": Yd.const("true"),
        }),
        Yd.createElement("span", null, () => this.props.text()),
      );
    }
    didMountDownload(e) {
      this.downloadLink = e, this.didUpdate();
    }
    didUnmountDownload() {
      this.revokeBlobURL();
    }
    didUpdate() {
      this.updateDownloadURL(),
        this.cachedObjectURL &&
        (this.downloadLink.href = this.cachedObjectURL);
    }
    updateDownloadURL() {
      if (this.revokeBlobURL(), !this.supportsDirectDownload) return;
      let e = this.props.data();
      e && (this.cachedObjectURL = URL.createObjectURL(e));
    }
    revokeBlobURL() {
      this.cachedObjectURL && URL.revokeObjectURL(this.cachedObjectURL);
    }
  };
  qt();
  function xA(r, e, t = false) {
    if (t && (r = r.replace(/ /g, "\\ ")), e === "none") return r;
    let o = e === "nemeth" ? lp(r) : cp(r);
    return o.isError ? "" : sa.toBrailleAscii(o.value);
  }
  function Aj(r, e) {
    if (e === "none") return "";
    let t = [];
    t.push(xA("Expression List", e, true)), t.push(""), t.push("");
    for (let o of r.getExpressionOrder()) {
      let i = _pe("" + (r.getExpressionIndex(o) + 1), e),
        n = r.getExpressionLatex(o),
        a = r.getExpressionValue(o);
      a !== void 0 && (n += `=${a}`), t.push(`${i}  ${xA(n, e, false)}`);
    }
    return t.join(`
`);
  }
  function _pe(r, e) {
    return e === "nemeth"
      ? `${xA(r, e, false)}_4`
      : e === "ueb"
      ? xA(`${r}.`, e, false)
      : "";
  }
  var { If: _1 } = lo.Components,
    wA = class extends nr {
      template() {
        return lo.createElement(
          "div",
          {
            class: () => ({
              "dcg-settings-dropdown": true,
              "dcg-popover": true,
              "dcg-point-left": this.controller.containerSize.height <= 420,
            }),
            role: lo.const("region"),
            "aria-label": lo.const("Settings Menu"),
            didMount: this.bindFn(this.didMountSettingsDropdown),
            didUnmount: this.bindFn(this.didUnmountSettingsDropdown),
          },
          lo.createElement(
            "div",
            { class: lo.const("dcg-popover-interior") },
            lo.createElement(
              "div",
              {
                class: () => ({
                  "dcg-settings-menu-option": true,
                  "dcg-displaysize-container": true,
                }),
              },
              lo.createElement(vo, {
                ariaGroupLabel: () =>
                  this.controller.s(
                    "shared-calculator-narration-settings-display-size",
                  ),
                staticConfig: this.bindFn(this.getProjectorModeOptions),
              }),
            ),
            lo.createElement(
              mt,
              {
                onChange: this.bindFn(this.onToggleInvertedColors),
                checked: () => this.controller.getInvertedColors(),
                class: this.const(
                  "dcg-settings-menu-option dcg-do-not-blur dcg-reverse-contrast",
                ),
              },
              lo.createElement("span", {
                class: lo.const("dcg-checkbox-label"),
              }, () =>
                this.controller.s(
                  "basic-calculator-label-reverse-contrast",
                )),
            ),
            lo.createElement(_1, {
              predicate: () => this.controller.getBrailleControls(),
            }, () =>
              lo.createElement(
                "div",
                null,
                lo.createElement(
                  mt,
                  {
                    onChange: this.bindFn(this.onToggleBrailleMode),
                    checked: () => this.controller.renderAsBraille(),
                    class: this.const(
                      "dcg-settings-menu-option dcg-do-not-blur dcg-braille-mode",
                    ),
                  },
                  lo.createElement("span", {
                    class: lo.const("dcg-checkbox-label"),
                  }, () =>
                    this.controller.s(
                      "shared-calculator-narration-braille-mode",
                    )),
                ),
                lo.createElement(_1, {
                  predicate: () => this.controller.renderAsBraille(),
                }, () =>
                  lo.createElement(
                    "div",
                    {
                      class: () => ({
                        "dcg-settings-menu-option": true,
                        "dcg-braille-container": true,
                      }),
                    },
                    lo.createElement(Gh, {
                      showBrailleNote: this.const(false),
                      controller: this.props.controller,
                    }),
                    lo.createElement(
                      "div",
                      {
                        class: lo.const("dcg-braille-options-container"),
                      },
                      lo.createElement(_1, {
                        predicate: () =>
                          !Df && Ij() &&
                          this.controller.getBrailleExpressionDownload(),
                      }, () =>
                        lo.createElement(k1, {
                          data: () => {
                            let e = Aj(
                              this.model,
                              this.controller.getBrailleMode(),
                            );
                            return new Blob([e], { type: "text/plain" });
                          },
                          enabled: this.const(true),
                          filename: this.const("desmos-equations.brl"),
                          text: () =>
                            this.controller.s(
                              "basic-calculator-link-download-braille-equations",
                            ),
                          buttonType: this.const("link"),
                        })),
                    ),
                  )),
              )),
            lo.createElement(_1, {
              predicate: () => this.controller.isComplexModeAllowed(),
            }, () =>
              lo.createElement(Lh, {
                controller: this.props.controller,
                isComplexModeEnabled: () =>
                  this.controller.isComplexModeEnabled(),
                toggleComplexMode: this.bindFn(this.onToggleComplexMode),
                product: this.const("scientific"),
              })),
            lo.createElement(_1, {
              predicate: () => !!this.getVersionNumber(),
            }, () =>
              lo.createElement(
                "div",
                { class: lo.const("dcg-version-number") },
                lo.const("Version: "),
                () => this.getVersionNumber(),
              )),
          ),
        );
      }
      getProjectorModeOptions() {
        return [{
          key: "default",
          label: () => "A",
          ariaLabel: () =>
            this.controller.s(
              "shared-calculator-narration-settings-display-size-default",
            ),
          class: () => "dcg-displaysize-default",
          selected: () => !this.getProjectorMode(),
          onSelect: () => this.onSelectProjectorModeOption(false),
        }, {
          key: "large",
          label: () => "A",
          ariaLabel: () =>
            this.controller.s(
              "shared-calculator-narration-settings-display-size-large",
            ),
          class: () => "dcg-displaysize-large",
          selected: () => this.getProjectorMode(),
          onSelect: () => this.onSelectProjectorModeOption(true),
        }];
      }
      onSelectProjectorModeOption(e) {
        this.controller.dispatch({
          type: "update-projector-mode",
          mode: e,
        });
      }
      getVersionNumber() {
        let e = window;
        if (e && e.AppBridge) return e.AppBridge.versionNumber;
      }
      didUnmountSettingsDropdown() {
        ee(document).off(".dcg-settings-view");
      }
      didMountSettingsDropdown(e) {
        this.settingsGroupNode = e,
          ee(document).on("dcg-tapstart.dcg-settings-view", (t) => {
            t.target.closest(".dcg-basic-settings-container") ||
              this.controller.dispatch({ type: "close-settings-menu" });
          }),
          ee(document).on("keydown.dcg-settings-view", (t) => {
            if (
              ke(t) === "Esc" &&
              (this.controller.dispatch({ type: "close-settings-menu" }),
                this.controller.dispatch({
                  type: "focus-last-expression",
                })), ke(t) === "Tab" && !t.altKey && !t.metaKey && !t.ctrlKey
            ) {
              let o = document.activeElement,
                i = this.props.settingsButtonNode(),
                n = [...this.settingsGroupNode.querySelectorAll(
                  ".dcg-settings-menu-option",
                )].slice(-1)[0];
              !t.shiftKey && o === n
                ? (i.focus(), t.preventDefault(), t.stopPropagation())
                : t.shiftKey && o === i &&
                  (n.focus(), t.preventDefault(), t.stopPropagation());
            }
          });
      }
      onToggleBrailleMode() {
        this.controller.dispatch({
          type: "set-braille-mode",
          mode: this.controller.renderAsBraille() ? "none" : "nemeth",
        });
      }
      onToggleInvertedColors() {
        let e = !this.controller.getInvertedColors();
        this.controller.dispatch({
          type: "update-inverted-colors",
          mode: e,
        });
      }
      onToggleComplexMode() {
        this.controller.dispatch({
          type: "toggle-complex-mode",
          enabled: !this.controller.isComplexModeEnabled(),
        });
      }
      getProjectorMode() {
        return this.controller.isProjectorMode();
      }
    };
  var ic = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: Ape } = ic.Components,
    hx = class extends nr {
      template() {
        let r = this.props.controller();
        return ic.createElement(
          "div",
          { class: ic.const("dcg-basic-settings-container") },
          ic.createElement(
            _o,
            {
              didMount: (e) => this.settingsButtonNode = e,
              command: this.const("settings"),
              ariaLabel: () =>
                r.s("basic-calculator-narration-controlbar-settings"),
              onTap: this.bindFn(this.onToggleSettingsMenu),
              selected: () => this.controller.isSettingsMenuOpen(),
              ariaPopup: this.const(true),
            },
            ic.createElement("i", {
              class: ic.const("dcg-icon-wrench"),
              "aria-hidden": ic.const("true"),
            }),
          ),
          ic.createElement(Ape, {
            predicate: () => this.controller.isSettingsMenuOpen(),
          }, () =>
            ic.createElement(wA, {
              controller: this.props.controller,
              settingsButtonNode: () => this.settingsButtonNode,
            })),
        );
      }
      onToggleSettingsMenu() {
        this.controller.dispatch({ type: "toggle-settings-menu" });
      }
    };
  var { If: I1, IfElse: Mpe } = qo.Components,
    vA = class extends nr {
      template() {
        let r = this.props.controller();
        return qo.createElement(
          Bc,
          { controller: this.props.controller },
          qo.createElement(
            I1,
            { predicate: () => this.showUndoRedo() },
            () =>
              qo.createElement(
                _o,
                {
                  command: this.const("undo"),
                  disabled: () => !r.canUndo(),
                  ariaLabel: () =>
                    r.s("basic-calculator-narration-controlbar-undo"),
                  onTap: (e) =>
                    r.dispatch({
                      type: "undo",
                      source: e.device === "keyboard"
                        ? "button-keyboard"
                        : "button-tap",
                    }),
                },
                qo.createElement("i", {
                  class: qo.const("dcg-icon-undo"),
                  "aria-hidden": qo.const("true"),
                }),
              ),
          ),
          qo.createElement(
            I1,
            { predicate: () => this.showUndoRedo() },
            () =>
              qo.createElement(
                _o,
                {
                  command: this.const("redo"),
                  disabled: () => !r.canRedo(),
                  ariaLabel: () =>
                    r.s("basic-calculator-narration-controlbar-redo"),
                  onTap: (e) =>
                    r.dispatch({
                      type: "redo",
                      source: e.device === "keyboard"
                        ? "button-keyboard"
                        : "button-tap",
                    }),
                },
                qo.createElement("i", {
                  class: qo.const("dcg-icon-redo"),
                  "aria-hidden": qo.const("true"),
                }),
              ),
          ),
          Mpe(() => r.shouldShowClear(), {
            true: () =>
              qo.createElement(_o, {
                command: this.const("clear"),
                ariaLabel: () =>
                  r.s("basic-calculator-narration-controlbar-clear"),
                onTap: () => r.dispatch({ type: "clear" }),
              }, () => r.s("basic-calculator-button-controlbar-clear")),
            false: () =>
              qo.createElement(
                _o,
                {
                  command: this.const("clearall"),
                  disabled: () => !r.canClear(),
                  ariaLabel: () =>
                    r.s(
                      "basic-calculator-narration-controlbar-clear-all",
                    ),
                  onTap: () =>
                    r.dispatch({
                      type: "set-blank",
                      opts: { allowUndo: true },
                    }),
                },
                () => r.s("basic-calculator-button-controlbar-clear-all"),
              ),
          }),
          qo.createElement(
            I1,
            {
              predicate: () => !this.showUndoRedo(),
            },
            () =>
              qo.createElement("div", {
                class: qo.const("dcg-spacer-2"),
              }),
          ),
          qo.createElement(I1, {
            predicate: () => r.getBrailleMode() === "none",
          }, () =>
            qo.createElement(
              _o,
              {
                command: this.const("backspace"),
                ariaLabel: () =>
                  r.s("basic-calculator-narration-controlbar-backspace"),
                disabled: () => !r.canBackspace(),
                onTap: () =>
                  r.dispatch({
                    type: "keypad/press-key",
                    key: "Backspace",
                    source: "keypad",
                  }),
              },
              qo.createElement("i", {
                class: qo.const("dcg-icon-delete"),
                "aria-hidden": qo.const("true"),
              }),
            )),
          qo.createElement(
            I1,
            {
              predicate: () => this.props.controller().getSettingsMenu(),
            },
            () => qo.createElement(hx, { controller: this.props.controller }),
          ),
        );
      }
      showUndoRedo() {
        return !(this.controller.getRestrictedEditing() ||
          this.controller.getDisableParentheses());
      }
      onToggleSettingsMenu() {
        this.controller.dispatch({ type: "toggle-settings-menu" });
      }
    };
  var Ks = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { Switch: Mj } = Ks.Components,
    A1 = class extends nr {
      template() {
        return Ks.createElement(
          "div",
          {
            role: Ks.const("region"),
            "aria-label": () => this.s("shared-calculator-narration-keypad"),
          },
          Ks.createElement(
            Or,
            { controller: this.props.controller },
            Ks.createElement(
              $e,
              null,
              Ks.createElement(Mj, {
                key: this.bindFn(this.getTopLeftButtons),
              }, (e) => {
                switch (e) {
                  case "parens":
                    return I(this, "(", { colspan: this.parenColspan() });
                  case "undoredo":
                    return I(this, "undo", {
                      colspan: this.parenColspan(),
                      disabled: () => !this.controller.canUndo(),
                    });
                  case "none":
                    return to(this.parenColspan());
                }
              }),
              Ks.createElement(Mj, {
                key: this.bindFn(this.getTopLeftButtons),
              }, (e) => {
                switch (e) {
                  case "parens":
                    return I(this, ")", { colspan: this.parenColspan() });
                  case "undoredo":
                    return I(this, "redo", {
                      colspan: this.parenColspan(),
                      disabled: () => !this.controller.canRedo(),
                    });
                  case "none":
                    return to(this.parenColspan());
                }
              }),
              this.makeAdditionalFunctionKey(0),
              this.makeAdditionalFunctionKey(1),
              I(this, "division"),
            ),
            Ks.createElement(
              $e,
              null,
              I(this, "7", { style: "highlight" }),
              I(this, "8", { style: "highlight" }),
              I(this, "9", { style: "highlight" }),
              I(this, "multiplication"),
            ),
            Ks.createElement(
              $e,
              null,
              I(this, "4", { style: "highlight" }),
              I(this, "5", { style: "highlight" }),
              I(this, "6", { style: "highlight" }),
              I(this, "-"),
            ),
            Ks.createElement(
              $e,
              null,
              I(this, "1", { style: "highlight" }),
              I(this, "2", { style: "highlight" }),
              I(this, "3", { style: "highlight" }),
              I(this, "+"),
            ),
            Ks.createElement(
              $e,
              null,
              I(this, "0", { style: "highlight" }),
              I(this, ".", { style: "highlight" }),
              I(this, "ans"),
              I(this, "enter", { style: "blue" }),
            ),
          ),
        );
      }
      getTopLeftButtons() {
        return this.showParens()
          ? "parens"
          : this.controller.getRestrictedEditing()
          ? "none"
          : "undoredo";
      }
      showParens() {
        return !this.controller.getDisableParentheses();
      }
      parenColspan() {
        return this.controller.getAdditionalFunctions().length > 1 ? .5 : 1;
      }
      makeAdditionalFunctionKey(e) {
        let t = this.controller.getAdditionalFunctions()[e];
        return t === "exponent"
          ? I(this, "a^b")
          : t === "percent"
          ? I(this, "%")
          : t === "sqrt"
          ? I(this, "sqrt")
          : t === "fraction"
          ? I(this, "a/b")
          : void 0;
      }
    };
  var Gi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: AR, IfElse: Gpe } = Gi.Components,
    CA = class extends nr {
      template() {
        let r = this.props.controller();
        return Gi.createElement(
          Bc,
          { controller: this.props.controller },
          Gi.createElement(_o, {
            command: this.const("main"),
            selected: () => r.getKeyboardMode() === "main",
            disabled: () => this.controller.renderAsBraille(),
            selectable: this.const(true),
            onTap: () => r.dispatch({ type: "main" }),
            ariaLabel: () => r.s("basic-calculator-narration-controlbar-main"),
          }, () => r.s("basic-calculator-button-controlbar-main")),
          Gi.createElement(_o, {
            command: this.const("ABC"),
            selected: () =>
              ["qwerty", "capitalQwerty", "letters"].indexOf(
                r.getKeyboardMode(),
              ) !== -1,
            disabled: () => this.controller.renderAsBraille(),
            selectable: this.const(true),
            ariaLabel: () => r.s("basic-calculator-narration-controlbar-abc"),
            onTap: () => r.dispatch({ type: "ABC" }),
          }, () => r.s("basic-calculator-button-controlbar-abc")),
          Gi.createElement(_o, {
            command: this.const("functions"),
            selected: () =>
              ["functions", "restrictedFunctions"].indexOf(
                r.getKeyboardMode(),
              ) !== -1,
            ariaLabel: () =>
              r.s("basic-calculator-narration-controlbar-functions"),
            disabled: () => this.controller.renderAsBraille(),
            selectable: this.const(true),
            onTap: () => r.dispatch({ type: "functions" }),
          }, () => r.s("basic-calculator-button-controlbar-func")),
          Gi.createElement(rc, {
            setup: this.const({
              type: "basic",
              controller: this.controller,
            }),
          }),
          Gi.createElement(AR, {
            predicate: () => !this.controller.getRestrictedEditing(),
          }, () =>
            Gi.createElement(
              _o,
              {
                command: this.const("undo"),
                disabled: () => !r.canUndo(),
                ariaLabel: () =>
                  r.s("basic-calculator-narration-controlbar-undo"),
                onTap: (e) =>
                  r.dispatch({
                    type: "undo",
                    source: e.device === "keyboard"
                      ? "button-keyboard"
                      : "button-tap",
                  }),
              },
              Gi.createElement("i", {
                class: Gi.const("dcg-icon-undo"),
                "aria-hidden": Gi.const("true"),
              }),
            )),
          Gi.createElement(AR, {
            predicate: () => !this.controller.getRestrictedEditing(),
          }, () =>
            Gi.createElement(
              _o,
              {
                command: this.const("redo"),
                disabled: () => !r.canRedo(),
                ariaLabel: () =>
                  r.s("basic-calculator-narration-controlbar-redo"),
                onTap: (e) =>
                  r.dispatch({
                    type: "redo",
                    source: e.device === "keyboard"
                      ? "button-keyboard"
                      : "button-tap",
                  }),
              },
              Gi.createElement("i", {
                class: Gi.const("dcg-icon-redo"),
                "aria-hidden": Gi.const("true"),
              }),
            )),
          Gpe(() => r.shouldShowClear(), {
            true: () =>
              Gi.createElement(_o, {
                command: this.const("clear"),
                ariaLabel: () =>
                  r.s("basic-calculator-narration-controlbar-clear"),
                onTap: () => r.dispatch({ type: "clear" }),
              }, () => r.s("basic-calculator-button-controlbar-clear")),
            false: () =>
              Gi.createElement(
                _o,
                {
                  command: this.const("clearall"),
                  disabled: () => !r.canClear(),
                  ariaLabel: () =>
                    r.s(
                      "basic-calculator-narration-controlbar-clear-all",
                    ),
                  onTap: () =>
                    r.dispatch({
                      type: "set-blank",
                      opts: { allowUndo: true },
                    }),
                },
                () => r.s("basic-calculator-button-controlbar-clear-all"),
              ),
          }),
          Gi.createElement(
            AR,
            {
              predicate: () => this.props.controller().getSettingsMenu(),
            },
            () => Gi.createElement(hx, { controller: this.props.controller }),
          ),
        );
      }
    };
  var vl = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var gx = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var M1 = class extends nr {
    template() {
      return gx.createElement(
        Or,
        { controller: this.props.controller },
        gx.createElement(
          $e,
          null,
          I(this, "A"),
          I(this, "B"),
          I(this, "C"),
          I(this, "D"),
          I(this, "E"),
          I(this, "F"),
          I(this, "G"),
          I(this, "H"),
          I(this, "I"),
          I(this, "J"),
        ),
        gx.createElement(
          $e,
          null,
          I(this, "K"),
          I(this, "L"),
          I(this, "M"),
          I(this, "N"),
          I(this, "O"),
          I(this, "P"),
          I(this, "Q"),
          I(this, "R"),
          I(this, "S"),
          I(this, "T"),
        ),
        gx.createElement(
          $e,
          null,
          I(this, "=", { style: "highlight" }),
          I(this, ","),
          I(this, "U"),
          I(this, "V"),
          I(this, "W"),
          I(this, "X"),
          I(this, "Y"),
          I(this, "Z"),
          I(this, "pi"),
          I(this, "backspace", { style: "highlight" }),
        ),
        gx.createElement(
          $e,
          null,
          I(this, "shift", { style: "highlight", colspan: 2 }),
          I(this, "("),
          I(this, ")"),
          I(this, "["),
          I(this, "]"),
          I(this, "!"),
          I(this, "'"),
          I(this, "enter", { style: "blue", colspan: 2 }),
        ),
      );
    }
  };
  var Uc = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var G1 = class extends nr {
    template() {
      return Uc.createElement(
        Or,
        { controller: this.props.controller },
        Uc.createElement(
          $e,
          null,
          I(this, "Q"),
          I(this, "W"),
          I(this, "E"),
          I(this, "R"),
          I(this, "T"),
          I(this, "Y"),
          I(this, "U"),
          I(this, "I"),
          I(this, "O"),
          I(this, "P"),
        ),
        Uc.createElement(
          $e,
          null,
          Uc.createElement("div", {
            class: Uc.const("dcg-half-width-placeholder"),
          }),
          I(this, "A"),
          I(this, "S"),
          I(this, "D"),
          I(this, "F"),
          I(this, "G"),
          I(this, "H"),
          I(this, "J"),
          I(this, "K"),
          I(this, "L"),
          Uc.createElement("div", {
            class: Uc.const("dcg-half-width-placeholder"),
          }),
        ),
        Uc.createElement(
          $e,
          null,
          I(this, "=", { style: "highlight" }),
          I(this, "Z"),
          I(this, "X"),
          I(this, "C"),
          I(this, "V"),
          I(this, "B"),
          I(this, "N"),
          I(this, "M"),
          I(this, ","),
          I(this, "backspace", { style: "highlight" }),
        ),
        Uc.createElement(
          $e,
          null,
          I(this, "shift", { style: "highlight", colspan: 1.5 }),
          I(this, "("),
          I(this, ")"),
          I(this, "["),
          I(this, "]"),
          I(this, "!"),
          I(this, "'"),
          I(this, "pi"),
          I(this, "enter", { style: "blue", colspan: 1.5 }),
        ),
      );
    }
  };
  var Fn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { IfElse: Lpe } = Fn.Components,
    L1 = class extends nr {
      template() {
        return Fn.createElement(
          "div",
          { class: Fn.const("dcg-sci-func-keypad") },
          Fn.createElement(
            Or,
            { controller: this.props.controller },
            Fn.createElement(
              $e,
              null,
              I(this, "sin"),
              I(this, "cos"),
              I(this, "tan"),
              Fn.createElement("div", {
                class: Fn.const("dcg-partition-placeholder"),
              }),
              I(this, "a^b"),
              I(this, "sqrt"),
              I(this, "nthroot"),
            ),
            Fn.createElement(
              $e,
              null,
              I(this, "arcsin"),
              I(this, "arccos"),
              I(this, "arctan"),
              Fn.createElement("div", {
                class: Fn.const("dcg-partition-placeholder"),
              }),
              I(this, "e^x"),
              I(this, "abs"),
              Lpe(() => this.controller.getReplaceRoundWithReciprocal(), {
                true: () => I(this, "a^{-1}"),
                false: () => I(this, "round"),
              }),
            ),
            Fn.createElement(
              $e,
              null,
              I(this, "mean"),
              I(this, "stdev"),
              I(this, "stdevp"),
              Fn.createElement("div", {
                class: Fn.const("dcg-partition-placeholder"),
              }),
              I(this, "ln"),
              I(this, "log"),
              I(this, "backspace", { style: "highlight" }),
            ),
            Fn.createElement(
              $e,
              null,
              I(this, "nPr"),
              I(this, "nCr"),
              I(this, "!"),
              Fn.createElement("div", {
                class: Fn.const("dcg-partition-placeholder"),
              }),
              I(this, "e"),
              I(this, "pi"),
              I(this, "enter", { style: "blue" }),
            ),
          ),
        );
      }
    };
  var Nn = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { IfElse: Ppe } = Nn.Components,
    P1 = class extends nr {
      template() {
        return Nn.createElement(
          "div",
          {
            class: Nn.const(
              "dcg-sci-func-keypad dcg-sci-func-keypad--complex",
            ),
          },
          Nn.createElement(
            Or,
            { controller: this.props.controller },
            Nn.createElement(
              $e,
              null,
              I(this, "sin"),
              I(this, "cos"),
              I(this, "tan"),
              Nn.createElement("div", {
                class: Nn.const("dcg-partition-placeholder"),
              }),
              I(this, "%"),
              I(this, "pi"),
              I(this, "e"),
              I(this, "e^x"),
            ),
            Nn.createElement(
              $e,
              null,
              I(this, "arcsin"),
              I(this, "arccos"),
              I(this, "arctan"),
              Nn.createElement("div", {
                class: Nn.const("dcg-partition-placeholder"),
              }),
              I(this, "real"),
              I(this, "imag"),
              I(this, "conj"),
              I(this, "arg"),
            ),
            Nn.createElement(
              $e,
              null,
              I(this, "mean"),
              I(this, "stdev"),
              I(this, "stdevp"),
              Nn.createElement("div", {
                class: Nn.const("dcg-partition-placeholder"),
              }),
              I(this, "ln"),
              I(this, "log"),
              I(this, "sqrt"),
              I(this, "backspace", { style: "highlight" }),
            ),
            Nn.createElement(
              $e,
              null,
              I(this, "nPr"),
              I(this, "nCr"),
              I(this, "!"),
              Nn.createElement("div", {
                class: Nn.const("dcg-partition-placeholder"),
              }),
              I(this, "abs"),
              Ppe(() => this.controller.getReplaceRoundWithReciprocal(), {
                true: () => I(this, "a^{-1}"),
                false: () => I(this, "round"),
              }),
              I(this, "nthroot"),
              I(this, "enter", { style: "blue" }),
            ),
          ),
        );
      }
    };
  var ai = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { IfElse: Gj } = ai.Components,
    V1 = class extends nr {
      template() {
        return ai.createElement(
          Or,
          { controller: this.props.controller },
          ai.createElement(
            $e,
            null,
            I(this, "a^2"),
            I(this, "a^b"),
            I(this, "|a|"),
            ai.createElement("div", {
              class: ai.const("dcg-partition-placeholder"),
            }),
            I(this, "7", { style: "highlight" }),
            I(this, "8", { style: "highlight" }),
            I(this, "9", { style: "highlight" }),
            I(this, "division"),
            ai.createElement("div", {
              class: ai.const("dcg-partition-placeholder"),
            }),
            Gj(() => {
              var e, t;
              return (t = (e = this.controller).isComplexModeEnabled) ==
                  null
                ? void 0
                : t.call(e);
            }, { true: () => I(this, "i"), false: () => I(this, "%") }),
            I(this, "a/b"),
          ),
          ai.createElement(
            $e,
            null,
            I(this, "sqrt"),
            I(this, "nthroot"),
            I(this, "pi"),
            ai.createElement("div", {
              class: ai.const("dcg-partition-placeholder"),
            }),
            I(this, "4", { style: "highlight" }),
            I(this, "5", { style: "highlight" }),
            I(this, "6", { style: "highlight" }),
            I(this, "multiplication"),
            ai.createElement("div", {
              class: ai.const("dcg-partition-placeholder"),
            }),
            I(this, "left", { style: "highlight" }),
            I(this, "right", { style: "highlight" }),
          ),
          ai.createElement(
            $e,
            null,
            I(this, "sin"),
            I(this, "cos"),
            I(this, "tan"),
            ai.createElement("div", {
              class: ai.const("dcg-partition-placeholder"),
            }),
            I(this, "1", { style: "highlight" }),
            I(this, "2", { style: "highlight" }),
            I(this, "3", { style: "highlight" }),
            I(this, "-"),
            ai.createElement("div", {
              class: ai.const("dcg-partition-placeholder"),
            }),
            to(.5),
            I(this, "backspace", { style: "highlight", colspan: 1.5 }),
          ),
          ai.createElement(
            $e,
            null,
            I(this, "("),
            I(this, ")"),
            Gj(() => this.controller.getReplaceCommaWith10Exp(), {
              true: () => I(this, "10^n"),
              false: () => I(this, ","),
            }),
            ai.createElement("div", {
              class: ai.const("dcg-partition-placeholder"),
            }),
            I(this, "0", { style: "highlight" }),
            I(this, ".", { style: "highlight" }),
            I(this, "ans"),
            I(this, "+"),
            ai.createElement("div", {
              class: ai.const("dcg-partition-placeholder"),
            }),
            I(this, "enter", { style: "blue", colspan: 2 }),
          ),
        );
      }
    };
  var mx = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var O1 = class extends nr {
    template() {
      return mx.createElement(
        Or,
        { controller: this.props.controller },
        mx.createElement(
          $e,
          null,
          I(this, "a"),
          I(this, "b"),
          I(this, "c"),
          I(this, "d"),
          I(this, "e"),
          I(this, "f"),
          I(this, "g"),
          I(this, "h"),
          I(this, "i"),
          I(this, "j"),
        ),
        mx.createElement(
          $e,
          null,
          I(this, "k"),
          I(this, "l"),
          I(this, "m"),
          I(this, "n"),
          I(this, "o"),
          I(this, "p"),
          I(this, "q"),
          I(this, "r"),
          I(this, "s"),
          I(this, "t"),
        ),
        mx.createElement(
          $e,
          null,
          I(this, "=", { style: "highlight" }),
          I(this, ","),
          I(this, "u"),
          I(this, "v"),
          I(this, "w"),
          I(this, "x"),
          I(this, "y"),
          I(this, "z"),
          I(this, "pi"),
          I(this, "backspace", { style: "highlight" }),
        ),
        mx.createElement(
          $e,
          null,
          I(this, "shift", { style: "highlight", colspan: 2 }),
          I(this, "("),
          I(this, ")"),
          I(this, "["),
          I(this, "]"),
          I(this, "!"),
          I(this, "'"),
          I(this, "enter", { style: "blue", colspan: 2 }),
        ),
      );
    }
  };
  var zc = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var R1 = class extends nr {
    template() {
      return zc.createElement(
        Or,
        { controller: this.props.controller },
        zc.createElement(
          $e,
          null,
          I(this, "q"),
          I(this, "w"),
          I(this, "e"),
          I(this, "r"),
          I(this, "t"),
          I(this, "y"),
          I(this, "u"),
          I(this, "i"),
          I(this, "o"),
          I(this, "p"),
        ),
        zc.createElement(
          $e,
          null,
          zc.createElement("div", {
            class: zc.const("dcg-half-width-placeholder"),
          }),
          I(this, "a"),
          I(this, "s"),
          I(this, "d"),
          I(this, "f"),
          I(this, "g"),
          I(this, "h"),
          I(this, "j"),
          I(this, "k"),
          I(this, "l"),
          zc.createElement("div", {
            class: zc.const("dcg-half-width-placeholder"),
          }),
        ),
        zc.createElement(
          $e,
          null,
          I(this, "=", { style: "highlight" }),
          I(this, "z"),
          I(this, "x"),
          I(this, "c"),
          I(this, "v"),
          I(this, "b"),
          I(this, "n"),
          I(this, "m"),
          I(this, ","),
          I(this, "backspace", { style: "highlight" }),
        ),
        zc.createElement(
          $e,
          null,
          I(this, "shift", { style: "highlight", colspan: 1.5 }),
          I(this, "("),
          I(this, ")"),
          I(this, "["),
          I(this, "]"),
          I(this, "!"),
          I(this, "'"),
          I(this, "pi"),
          I(this, "enter", { style: "blue", colspan: 1.5 }),
        ),
      );
    }
  };
  var { SwitchUnion: Vpe, IfElse: Ope } = vl.Components,
    F1 = class extends nr {
      template() {
        return vl.createElement(
          "div",
          {
            role: vl.const("region"),
            "aria-label": () => this.s("shared-calculator-narration-keypad"),
          },
          Vpe(() => this.controller.getKeyboardMode(), {
            qwerty: () =>
              vl.createElement(R1, { controller: this.props.controller }),
            letters: () =>
              vl.createElement(O1, { controller: this.props.controller }),
            capitalQwerty: () =>
              vl.createElement(G1, { controller: this.props.controller }),
            capitalLetters: () =>
              vl.createElement(M1, { controller: this.props.controller }),
            functions: () =>
              Ope(() => this.controller.isComplexModeEnabled(), {
                true: () =>
                  vl.createElement(P1, {
                    controller: this.props.controller,
                  }),
                false: () =>
                  vl.createElement(L1, {
                    controller: this.props.controller,
                  }),
              }),
            main: () =>
              vl.createElement(V1, { controller: this.props.controller }),
          }),
        );
      }
    };
  var yi = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: SA } = yi.Components,
    EA = class extends nr {
      template() {
        let r = this.props.controller();
        return yi.createElement(
          Bc,
          { controller: this.props.controller },
          yi.createElement(SA, {
            predicate: () => !this.controller.getRestrictedEditing(),
          }, () =>
            yi.createElement(
              _o,
              {
                command: this.const("undo"),
                disabled: () => !r.canUndo(),
                ariaLabel: () =>
                  r.s("basic-calculator-narration-controlbar-undo"),
                onTap: (e) =>
                  r.dispatch({
                    type: "undo",
                    source: e.device === "keyboard"
                      ? "button-keyboard"
                      : "button-tap",
                  }),
              },
              yi.createElement("i", {
                class: yi.const("dcg-icon-undo"),
                "aria-hidden": yi.const("true"),
              }),
            )),
          yi.createElement(SA, {
            predicate: () => !this.controller.getRestrictedEditing(),
          }, () =>
            yi.createElement(
              _o,
              {
                command: this.const("redo"),
                disabled: () => !r.canRedo(),
                ariaLabel: () =>
                  r.s("basic-calculator-narration-controlbar-redo"),
                onTap: (e) =>
                  r.dispatch({
                    type: "redo",
                    source: e.device === "keyboard"
                      ? "button-keyboard"
                      : "button-tap",
                  }),
              },
              yi.createElement("i", {
                class: yi.const("dcg-icon-redo"),
                "aria-hidden": yi.const("true"),
              }),
            )),
          yi.createElement(_o, {
            command: this.const("clear"),
            ariaLabel: () => r.s("basic-calculator-narration-controlbar-clear"),
            onTap: () => r.dispatch({ type: "clear" }),
          }, () => r.s("basic-calculator-button-controlbar-clear")),
          yi.createElement(
            SA,
            {
              predicate: () => this.controller.getRestrictedEditing(),
            },
            () =>
              yi.createElement("div", {
                class: yi.const("dcg-spacer-2"),
              }),
          ),
          yi.createElement(SA, {
            predicate: () => r.getBrailleMode() === "none",
          }, () =>
            yi.createElement(
              _o,
              {
                command: this.const("backspace"),
                ariaLabel: () =>
                  r.s("basic-calculator-narration-controlbar-backspace"),
                disabled: () => !r.canBackspace(),
                onTap: () =>
                  r.dispatch({
                    type: "keypad/press-key",
                    key: "Backspace",
                    source: "keypad",
                  }),
              },
              yi.createElement("i", {
                class: yi.const("dcg-icon-delete"),
                "aria-hidden": yi.const("true"),
              }),
            )),
        );
      }
    };
  var Xd = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var N1 = class extends nr {
    template() {
      return Xd.createElement(
        "div",
        {
          role: Xd.const("region"),
          "aria-label": () => this.s("shared-calculator-narration-keypad"),
        },
        Xd.createElement(
          Or,
          { controller: this.props.controller },
          Xd.createElement(
            $e,
            null,
            I(this, "(", { colspan: this.parenColspan() }),
            I(this, ")", { colspan: this.parenColspan() }),
            this.makeAdditionalFunctionKey(1),
          ),
          Xd.createElement(
            $e,
            null,
            I(this, "7", { style: "highlight" }),
            I(this, "8", { style: "highlight" }),
            I(this, "9", { style: "highlight" }),
            I(this, "division"),
          ),
          Xd.createElement(
            $e,
            null,
            I(this, "4", { style: "highlight" }),
            I(this, "5", { style: "highlight" }),
            I(this, "6", { style: "highlight" }),
            I(this, "multiplication"),
          ),
          Xd.createElement(
            $e,
            null,
            I(this, "1", { style: "highlight" }),
            I(this, "2", { style: "highlight" }),
            I(this, "3", { style: "highlight" }),
            I(this, "-"),
          ),
          Xd.createElement(
            $e,
            null,
            I(this, "0", { style: "highlight" }),
            I(this, ".", {
              style: "highlight",
              colspan: this.dotColspan(),
            }),
            this.makeAdditionalFunctionKey(0),
            I(this, "+"),
          ),
        ),
      );
    }
    parenColspan() {
      return this.controller.getAdditionalFunctions().length === 2 ? 1.5 : 2;
    }
    dotColspan() {
      return this.controller.getAdditionalFunctions().length ? 1 : 2;
    }
    makeAdditionalFunctionKey(e) {
      let t = this.controller.getAdditionalFunctions()[e];
      return t === "exponent"
        ? I(this, "a^b")
        : t === "percent"
        ? I(this, "%")
        : t === "sqrt"
        ? I(this, "sqrt")
        : void 0;
    }
  };
  var si = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var { If: Lj } = si.Components,
    TA = class extends nr {
      template() {
        let r = this.props.controller();
        return si.createElement(
          Bc,
          { controller: this.props.controller },
          si.createElement(rc, {
            setup: this.const({
              type: "basic",
              controller: this.controller,
            }),
          }),
          si.createElement("div", { class: si.const("dcg-spacer") }),
          si.createElement(Lj, {
            predicate: () => !this.controller.getRestrictedEditing(),
          }, () =>
            si.createElement(
              _o,
              {
                command: this.const("undo"),
                disabled: () => !r.canUndo(),
                ariaLabel: () =>
                  r.s("basic-calculator-narration-controlbar-undo"),
                onTap: (e) =>
                  r.dispatch({
                    type: "undo",
                    source: e.device === "keyboard"
                      ? "button-keyboard"
                      : "button-tap",
                  }),
              },
              si.createElement("i", {
                class: si.const("dcg-icon-undo"),
                "aria-hidden": si.const("true"),
              }),
            )),
          si.createElement(Lj, {
            predicate: () => !this.controller.getRestrictedEditing(),
          }, () =>
            si.createElement(
              _o,
              {
                command: this.const("redo"),
                disabled: () => !r.canRedo(),
                ariaLabel: () =>
                  r.s("basic-calculator-narration-controlbar-redo"),
                onTap: (e) =>
                  r.dispatch({
                    type: "redo",
                    source: e.device === "keyboard"
                      ? "button-keyboard"
                      : "button-tap",
                  }),
              },
              si.createElement("i", {
                class: si.const("dcg-icon-redo"),
                "aria-hidden": si.const("true"),
              }),
            )),
          si.createElement("div", { class: si.const("dcg-spacer") }),
          si.createElement(_o, {
            narrowButton: this.const(true),
            command: this.const("clear"),
            ariaLabel: () => r.s("basic-calculator-narration-controlbar-clear"),
            onTap: () => r.dispatch({ type: "clear" }),
          }, () => r.s("basic-calculator-button-controlbar-clear")),
          si.createElement(
            _o,
            {
              narrowButton: this.const(true),
              command: this.const("backspace"),
              ariaLabel: () =>
                r.s("basic-calculator-narration-controlbar-backspace"),
              onTap: () =>
                r.dispatch({
                  type: "keypad/press-key",
                  key: "Backspace",
                  source: "keypad",
                }),
            },
            si.createElement("i", {
              class: si.const("dcg-icon-delete"),
              "aria-hidden": si.const("true"),
            }),
          ),
        );
      }
    };
  var ia = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var B1 = class extends nr {
    template() {
      return ia.createElement(
        Or,
        { controller: this.props.controller },
        ia.createElement(
          $e,
          null,
          I(this, "("),
          I(this, ")"),
          I(this, "x^2"),
          I(this, "sqrt"),
          ia.createElement("div", {
            class: ia.const("dcg-partition-placeholder"),
          }),
          I(this, "x^3"),
          I(this, "x^y"),
          I(this, "ythroot"),
        ),
        ia.createElement(
          $e,
          null,
          I(this, "7", { style: "highlight" }),
          I(this, "8", { style: "highlight" }),
          I(this, "9", { style: "highlight" }),
          I(this, "division"),
          ia.createElement("div", {
            class: ia.const("dcg-partition-placeholder"),
          }),
          I(this, "pi"),
          I(this, "e^x"),
          I(this, "!"),
        ),
        ia.createElement(
          $e,
          null,
          I(this, "4", { style: "highlight" }),
          I(this, "5", { style: "highlight" }),
          I(this, "6", { style: "highlight" }),
          I(this, "multiplication"),
          ia.createElement("div", {
            class: ia.const("dcg-partition-placeholder"),
          }),
          I(this, "log"),
          I(this, "ln"),
          I(this, "|x|"),
        ),
        ia.createElement(
          $e,
          null,
          I(this, "1", { style: "highlight" }),
          I(this, "2", { style: "highlight" }),
          I(this, "3", { style: "highlight" }),
          I(this, "-"),
          ia.createElement("div", {
            class: ia.const("dcg-partition-placeholder"),
          }),
          I(this, "sin"),
          I(this, "cos"),
          I(this, "tan"),
        ),
        ia.createElement(
          $e,
          null,
          I(this, "0", { style: "highlight" }),
          I(this, ".", { style: "highlight" }),
          I(this, "x/y"),
          I(this, "+"),
          ia.createElement("div", {
            class: ia.const("dcg-partition-placeholder"),
          }),
          I(this, "arcsin"),
          I(this, "arccos"),
          I(this, "arctan"),
        ),
      );
    }
  };
  var { If: U1, IfElse: DA } = yr.Components,
    z1 = class extends nr {
      template() {
        return yr.createElement(
          U1,
          { predicate: () => this.controller.shouldRender() },
          () =>
            yr.createElement(
              "div",
              {
                class: this.const(cf),
                style: yr.const(
                  "width: 100%; height: 100%; position: relative;",
                ),
              },
              yr.createElement(
                "div",
                {
                  class: () => ({
                    "dcg-calc-basic-main-wrapper": true,
                    "dcg-narrow": this.controller.containerSize.width < 570,
                    "dcg-narrower": this.controller.containerSize.width < 380,
                    "dcg-short": this.controller.containerSize.height <= 540,
                    "dcg-scientific-calculator": this.controller
                      .isScientificCalc(),
                    "dcg-four-function-calculator": this.controller
                      .isFourFunctionCalc(),
                    "dcg-container": true,
                  }),
                  onKeyDown: this.bindFn(this.handleRootKeydown),
                  didMount: this.bindFn(this.didMountRoot),
                  "x-ms-format-detection": yr.const("none"),
                  style: () => ({
                    "--dcg-custom-background-color":
                      this.controller.hasBackgroundColor()
                        ? this.controller.getBackgroundColor()
                        : void 0,
                    "--dcg-custom-text-color": this.controller.hasTextColor()
                      ? this.controller.getTextColor()
                      : void 0,
                  }),
                },
                yr.createElement(
                  "div",
                  {
                    role: yr.const("application"),
                    "aria-label": () =>
                      this.controller.isScientificCalc()
                        ? this.controller.s(
                          "basic-calculator-narration-calc-description-scientific",
                        )
                        : this.controller.isFourFunctionCalc()
                        ? this.controller.s(
                          "basic-calculator-narration-calc-description-fourfunction",
                        )
                        : "",
                    class: () => ({
                      "dcg-calc-basic-main": true,
                      "dcg-inverted-colors": this.controller
                        .getInvertedColors(),
                      "dcg-projector-mode": this.controller
                        .isProjectorMode(),
                      "dcg-ipad": tl,
                      "dcg-has-background-color": this.controller
                        .hasBackgroundColor(),
                      "dcg-no-hyperlinks": !this.controller
                        .getAllowLinks(),
                    }),
                    style: () => ({
                      "font-size": `${this.controller.getFontSize()}px`,
                      filter: this.controller.getInvertedColors()
                        ? "invert(100%)"
                        : "none",
                    }),
                  },
                  yr.createElement(D1, {
                    controller: this.props.controller,
                  }),
                  yr.createElement(U1, {
                    predicate: () =>
                      this.controller.isScientificCalc() &&
                      this.model.isSingleExpression(),
                  }, () =>
                    yr.createElement(
                      "div",
                      null,
                      yr.createElement(TA, {
                        controller: this.props.controller,
                      }),
                      yr.createElement(
                        "div",
                        { class: yr.const("dcg-basic-keypad-container") },
                        DA(() => this.controller.renderAsBraille(), {
                          true: () =>
                            yr.createElement(Gm, {
                              controller: this.props.controller,
                            }),
                          false: () =>
                            yr.createElement(B1, {
                              controller: this.props.controller,
                            }),
                        }),
                      ),
                    )),
                  yr.createElement(U1, {
                    predicate: () =>
                      this.controller.isScientificCalc() &&
                      !this.model.isSingleExpression(),
                  }, () =>
                    yr.createElement(
                      "div",
                      null,
                      yr.createElement(CA, {
                        controller: this.props.controller,
                      }),
                      yr.createElement(
                        "div",
                        { class: yr.const("dcg-basic-keypad-container") },
                        DA(() => this.controller.renderAsBraille(), {
                          true: () =>
                            yr.createElement(Gm, {
                              controller: this.props.controller,
                            }),
                          false: () =>
                            yr.createElement(F1, {
                              controller: this.props.controller,
                            }),
                        }),
                      ),
                    )),
                  yr.createElement(U1, {
                    predicate: () =>
                      this.controller.isFourFunctionCalc() &&
                      this.model.isSingleExpression(),
                  }, () =>
                    yr.createElement(
                      "div",
                      null,
                      yr.createElement(EA, {
                        controller: this.props.controller,
                      }),
                      yr.createElement(
                        "div",
                        { class: yr.const("dcg-basic-keypad-container") },
                        DA(() => this.controller.renderAsBraille(), {
                          true: () =>
                            yr.createElement(Gm, {
                              controller: this.props.controller,
                            }),
                          false: () =>
                            yr.createElement(N1, {
                              controller: this.props.controller,
                            }),
                        }),
                      ),
                    )),
                  yr.createElement(U1, {
                    predicate: () =>
                      this.controller.isFourFunctionCalc() &&
                      !this.model.isSingleExpression(),
                  }, () =>
                    yr.createElement(
                      "div",
                      null,
                      yr.createElement(vA, {
                        controller: this.props.controller,
                      }),
                      yr.createElement(
                        "div",
                        { class: yr.const("dcg-basic-keypad-container") },
                        DA(() => this.controller.renderAsBraille(), {
                          true: () =>
                            yr.createElement(Gm, {
                              controller: this.props.controller,
                            }),
                          false: () =>
                            yr.createElement(A1, {
                              controller: this.props.controller,
                            }),
                        }),
                      ),
                    )),
                ),
              ),
            ),
        );
      }
      didMountRoot(e) {
        nw(e);
      }
      handleRootKeydown(e) {
        let t = Ko(e), o = this.controller.model;
        if (Zx(e)) {
          return this.dispatch({
            type: "undo",
            source: "keyboard-shortcut",
          }),
            false;
        }
        if (ew(e)) {
          return this.dispatch({
            type: "redo",
            source: "keyboard-shortcut",
          }),
            false;
        }
        if (
          e.altKey !== Zo && e.metaKey === Zo && !e.ctrlKey &&
          e.shiftKey && t === "A" &&
          this.controller.getDecimalToFraction()
        ) {
          let i = o.getFocusedExpression();
          i && o.canDisplayEvaluationAsFraction(i.id) &&
            (e.preventDefault(),
              e.stopPropagation(),
              this.controller.dispatch({
                type: "toggle-fraction-evaluation",
                id: i.id,
              }),
              this.controller.runAfterDispatch(() => {
                o.getFocusedExpression().displayAsFraction
                  ? xe(
                    this.controller.s(
                      "shared-calculator-narration-show-as-fraction",
                    ),
                  )
                  : xe(
                    this.controller.s(
                      "shared-calculator-narration-show-as-decimal",
                    ),
                  );
              }));
        } else if (!e.metaKey && !e.shiftKey) {
          if (!e.ctrlKey && !e.altKey && ke(e) === _u) {
            if (
              !document.activeElement || wp(document.activeElement)
            ) {
              return false;
            }
          } else if (e.ctrlKey === Zo && e.altKey === !Zo) {
            if (t === "N") {
              return this.controller.getBrailleControls()
                ? (this.dispatch({
                  type: "set-braille-mode",
                  mode: "nemeth",
                }),
                  xe(
                    this.controller.s(
                      "shared-calculator-narration-hotkey-braille-mode-nemeth",
                    ),
                  ),
                  false)
                : void 0;
            }
            if (t === "U") {
              return this.controller.getBrailleControls()
                ? (this.dispatch({
                  type: "set-braille-mode",
                  mode: "ueb",
                }),
                  xe(
                    this.controller.s(
                      "shared-calculator-narration-hotkey-braille-mode-ueb",
                    ),
                  ),
                  false)
                : void 0;
            }
            if (t === "Q" || t === "X") {
              return this.controller.getBrailleControls()
                ? (this.dispatch({
                  type: "set-braille-mode",
                  mode: "none",
                }),
                  xe(
                    this.controller.s(
                      "shared-calculator-narration-hotkey-braille-mode-off",
                    ),
                  ),
                  false)
                : void 0;
            }
            if (t === "6") {
              if (!this.controller.getBrailleControls()) return;
              let i = !this.controller.getSixKeyInput();
              return this.dispatch({
                type: "set-six-key-input",
                useSixKeyInput: i,
              }),
                xe(
                  i
                    ? this.controller.s(
                      "basic-calculator-narration-hotkey-six-key-input-on",
                    )
                    : this.controller.s(
                      "basic-calculator-narration-hotkey-six-key-input-off",
                    ),
                ),
                false;
            } else if (t === "D") {
              return this.controller.isScientificCalc()
                ? (e.preventDefault(),
                  this.controller.dispatch({ type: "degrees" }),
                  xe(
                    o.getDegreeMode()
                      ? this.controller.s(
                        "basic-calculator-narration-controlbar-degrees",
                      )
                      : this.controller.s(
                        "basic-calculator-narration-controlbar-radians",
                      ),
                  ),
                  false)
                : void 0;
            }
          }
        }
        return true;
      }
    };
  var bx = __dcg_shared_module_exports__["defineDefaultExport"](ne());
  var q1 = class {
    constructor(e) {
      this.eventModel = new Kl();
      if (this.rootElt = e, !e) {
        throw new Error("must pass an HTMLElement to the API");
      }
    }
    setupDomChangeDetector(e) {
      this.autoSize = e,
        mI(this.rootElt),
        this.domChangeDetector = new Yg(this.rootElt, (t) => {
          switch (t.type) {
            case "added":
              this.view = this.onCreateView(), this.onResizeView(t.size);
              break;
            case "removed":
              this.onDestroyView(), this.view = void 0;
              break;
            case "resized":
              this.onResizeView(t.size);
              break;
          }
        }),
        this.autoSize !== false
          ? this.domChangeDetector.startWatching()
          : this.domChangeDetector.checkForChanges();
    }
    detach() {
      __dcg_shared_module_exports__["qe"].warn(
        ".detach() is deprecated. It should no longer be necessary",
      );
    }
    destroy() {
      this.view && this.onDestroyView(), this.domChangeDetector.destroy();
      function e(i) {
        __dcg_shared_module_exports__["qe"].warn(
          "You've destroyed this API instance. You can no longer call ." +
            i + "()",
        );
      }
      let t = {}, o = this;
      for (; o;) {
        Object.getOwnPropertyNames(o).forEach((n) => t[n] = true),
          o = Object.getPrototypeOf(o);
      }
      for (let i in t) {
        typeof this[i] == "function"
          ? this[i] = e.bind(this, i)
          : this.hasOwnProperty(i) && delete this[i];
      }
      this.destroy = function () {};
    }
    resize() {
      this.domChangeDetector.checkForChanges();
    }
    updateView() {
      this.view && document.body &&
        document.body.contains(this.rootElt) && this.view.update();
    }
    triggerEvent(e, t) {
      this.eventModel.triggerEvent(e, t);
    }
    observeEvent(e, t) {
      this.eventModel.observeEvent(e, t);
    }
    unobserveEvent(e) {
      this.eventModel.unobserveEvent(e);
    }
  };
  var Rpe = {
      allowComplex: true,
      autosize: true,
      backgroundColor: "#fff",
      brailleControls: true,
      brailleExpressionDownload: true,
      brailleMode: "none",
      capExpressionSize: false,
      complex: false,
      decimalToFraction: true,
      degreeMode: false,
      functionDefinition: true,
      invertedColors: false,
      language: "en",
      links: true,
      projectorMode: false,
      qwertyKeyboard: true,
      replaceCommaWith10Exp: false,
      replaceRoundWithReciprocal: false,
      settingsMenu: true,
      sixKeyInput: false,
      textColor: "#000",
    },
    Fpe = {
      additionalFunctions: ["sqrt"],
      disableParentheses: false,
      evaluationMode: "scientific",
      restrictedEditing: false,
      typingAsteriskWritesTimesSymbol: false,
      typingSlashWritesDivisionSymbol: false,
    },
    Npe = [
      "allowComplex",
      "backgroundColor",
      "brailleControls",
      "brailleExpressionDownload",
      "brailleMode",
      "capExpressionSize",
      "complex",
      "decimalToFraction",
      "degreeMode",
      "functionDefinition",
      "invertedColors",
      "language",
      "links",
      "projectorMode",
      "qwertyKeyboard",
      "replaceCommaWith10Exp",
      "replaceRoundWithReciprocal",
      "settingsMenu",
      "sixKeyInput",
      "textColor",
      "restrictedEditing",
      "typingAsteriskWritesTimesSymbol",
      "fontSize",
    ];
  GB();
  var fx = class extends q1 {
    constructor(e) {
      super(e);
    }
    init(e) {
      e = __dcg_shared_module_exports__["Jc"](e),
        e.backgroundColor &&
        !__dcg_shared_module_exports__["Jd"](e.backgroundColor) &&
        (__dcg_shared_module_exports__["qe"].warn(
          "Invalid backgroundColor. Background color must be a 3- or 6-character hex color (e.g. #cde or #ffaaaa)",
        ),
          delete e.backgroundColor),
        e.textColor &&
        !__dcg_shared_module_exports__["Jd"](e.textColor) &&
        (__dcg_shared_module_exports__["qe"].warn(
          "Invalid textColor. Text color must be a 3- or 6-character hex color (e.g. #000 or #001111)",
        ),
          delete e.textColor),
        e.allowComplex ||
        (e.complex &&
          __dcg_shared_module_exports__["qe"].warn(
            "complex: true is not compatible with allowComplex: false. Forcing complex: false",
          ),
          delete e.complex),
        e.complex && e.degreeMode &&
        (__dcg_shared_module_exports__["qe"].warn(
          "degreeMode: true is not compatible with complex: true. Forcing degreeMode: false",
        ),
          delete e.degreeMode);
      let t = { ...Fpe, ...Rpe, ...e };
      this.settings = new cs();
      let o = { workerPool: cx, settingsProxy: this.settings };
      this.controller = new E1(t, o),
        this.controller.onEventEmitted = (i) => {
          i === "render" && this.updateView(), this.triggerEvent(i, void 0);
        },
        this.setupDomChangeDetector(t.autosize);
    }
    onCreateView() {
      return bx.mountToNode(z1, this.rootElt, {
        controller: bx.const(this.controller),
      });
    }
    setState(e, t) {
      t || (t = {}),
        !this.controller.isComplexModeAllowed() && e.settings.complex &&
        (e = { ...e, settings: { ...e.settings, complex: false } }),
        this.controller.dispatch({
          type: "set-state-from-api",
          state: e,
          opts: { allowUndo: !!t.allowUndo },
        });
    }
    getState() {
      return __dcg_shared_module_exports__["Jc"](
        this.controller.model.getPersistedState(),
      );
    }
    undo() {
      this.controller.dispatch({ type: "undo", source: "api" });
    }
    redo() {
      this.controller.dispatch({ type: "redo", source: "api" });
    }
    clearHistory() {
      this.controller.dispatch({ type: "clear-history" });
    }
    setBlank(e) {
      e || (e = {}),
        this.controller.dispatch({
          type: "set-blank",
          opts: { allowUndo: !!e.allowUndo },
        });
    }
    updateSettings(e) {
      e = __dcg_shared_module_exports__["Jc"](e),
        (!e.allowComplex && !this.controller.isComplexModeAllowed() ||
          this.controller.getEvaluationMode() !== "scientific") &&
        (delete e.complex, delete e.allowComplex);
      for (let t of Npe) {
        if (t in e) {
          switch (t) {
            case "fontSize":
              let o = e[t];
              if (o === void 0) continue;
              this.controller.dispatch({
                type: "update-font-size",
                size: o,
              });
              break;
            case "invertedColors":
              let i = e[t];
              if (i === void 0) continue;
              this.controller.dispatch({
                type: "update-inverted-colors",
                mode: i,
              });
              break;
            case "backgroundColor":
              let n = e[t];
              if (
                n === void 0 || !__dcg_shared_module_exports__["Jd"](n)
              ) {
                __dcg_shared_module_exports__["qe"].warn(
                  "Invalid backgroundColor. Background color must be a 3- or 6-character hex color (e.g. #cde or #ffaaaa)",
                );
                continue;
              }
              this.controller.dispatch({
                type: "update-background-color",
                color: n,
              });
              break;
            case "textColor":
              let a = e[t];
              if (
                a === void 0 || !__dcg_shared_module_exports__["Jd"](a)
              ) {
                __dcg_shared_module_exports__["qe"].warn(
                  "Invalid textColor. Text color must be a 3- or 6-character hex color (e.g. #000 or #001111)",
                );
                continue;
              }
              this.controller.dispatch({
                type: "update-text-color",
                color: a,
              });
              break;
            case "degreeMode":
              let s = e[t];
              if (s === void 0) continue;
              this.controller.dispatch({
                type: "update-degree-mode",
                mode: s,
              });
              break;
            case "brailleMode":
              let l = e[t];
              this.controller.dispatch({
                type: "set-braille-mode",
                mode: l,
              });
              break;
            case "sixKeyInput":
              let c = e[t];
              if (c === void 0) continue;
              this.controller.dispatch({
                type: "set-six-key-input",
                useSixKeyInput: c,
              });
              break;
            case "brailleControls": {
              let w = e[t];
              if (w === void 0) continue;
              this.controller.dispatch({
                type: "set-braille-controls",
                value: w,
              });
              break;
            }
            case "brailleExpressionDownload":
              let d = e[t];
              if (d === void 0) continue;
              this.controller.dispatch({
                type: "set-braille-expression-download",
                mode: d,
              });
              break;
            case "projectorMode":
              let p = e[t];
              if (p === void 0) continue;
              this.controller.dispatch({
                type: "update-projector-mode",
                mode: p,
              });
              break;
            case "capExpressionSize":
              let h = e[t];
              if (h === void 0) continue;
              this.controller.dispatch({
                type: "update-cap-expression-size",
                mode: h,
              });
              break;
            case "language":
              let u = e[t];
              if (u === void 0) continue;
              this.controller.dispatch({
                type: "update-language",
                language: Ld(u),
              });
              break;
            case "settingsMenu":
              e.settingsMenu
                ? this.controller.dispatch({
                  type: "enable-settings-menu",
                })
                : this.controller.dispatch({
                  type: "disable-settings-menu",
                });
              break;
            case "qwertyKeyboard":
              {
                this.controller.dispatch({
                  type: "update-options",
                  options: { qwertyKeyboard: !!e.qwertyKeyboard },
                });
                let w = this.controller.getKeyboardMode();
                (w === "qwerty" || w === "letters") &&
                  this.controller.dispatch({ type: "ABC" });
              }
              break;
            case "functionDefinition":
              e.functionDefinition
                ? this.controller.model.enableFunctionDefinition()
                : this.controller.model.disableFunctionDefinition();
              break;
            case "links":
              this.controller.dispatch({
                type: "update-options",
                options: { links: !!e.links },
              });
              break;
            case "decimalToFraction":
              let f = e[t];
              if (f === void 0) continue;
              this.controller.dispatch({
                type: "update-decimal-to-fraction",
                mode: f,
              });
              break;
            case "replaceCommaWith10Exp":
              let y = e[t];
              if (y === void 0) continue;
              this.controller.dispatch({
                type: "set-replace-comma-with-10-exp",
                replace: y,
              });
              break;
            case "replaceRoundWithReciprocal":
              let C = e[t];
              if (C === void 0) continue;
              this.controller.dispatch({
                type: "set-replace-round-with-reciprocal",
                replace: C,
              });
              break;
            case "restrictedEditing": {
              this.controller.dispatch({
                type: "update-options",
                options: { restrictedEditing: !!e.restrictedEditing },
              });
              break;
            }
            case "typingAsteriskWritesTimesSymbol":
              let E = e[t];
              if (E === void 0) continue;
              this.controller.dispatch({
                type: "set-typing-asterisk-writes-times-symbol",
                mode: E,
              });
              break;
            case "allowComplex":
              this.controller.dispatch({
                type: "toggle-complex-allowed",
                enabled: !!e[t],
              });
              break;
            case "complex":
              this.controller.dispatch({
                type: "toggle-complex-mode",
                enabled: !!e[t],
              });
              break;
            default:
              console.warn(`Unsupported setting: ${t}`);
              break;
          }
        }
      }
    }
    focusFirstExpression() {
      this.controller.dispatch({ type: "focus-first-expression" });
    }
    onResizeView(e) {
      this.controller.dispatch({ type: "ui/container-resized", size: e });
    }
    onDestroyView() {
      bx.unmountFromNode(this.rootElt);
    }
    destroy() {
      this.controller.model.destroy(), super.destroy();
    }
  };
  var yx = class extends fx {
    constructor(e, t) {
      super(e), this.init(Bpe(t || {}));
    }
  };
  function Bpe(r) {
    if (
      r = __dcg_shared_module_exports__["Jc"](r),
        r.hasOwnProperty("typingSlashWritesDivisionSymbol") ||
        (r.typingSlashWritesDivisionSymbol = true),
        r.hasOwnProperty("typingAsteriskWritesTimesSymbol") ||
        (r.typingAsteriskWritesTimesSymbol = true),
        r.exponentButtonForSquareRoot &&
        (__dcg_shared_module_exports__["qe"].warn(
          `As of API version 1.0, the 'exponentButtonForSquareRoot' option is deprecated.Use 'additionalFunctions: "exponent"' instead.`,
        ),
          r.additionalFunctions = ["exponent"]),
        r.additionalFunctions
    ) {
      let e = r.additionalFunctions;
      typeof e == "string" && (e = [e]),
        e.length > 2 &&
        (__dcg_shared_module_exports__["qe"].warn(
          "additionalFunctions can only take up to 2 new functions. Using the first two.",
        ),
          e = e.slice(0, 2));
      let t = true;
      for (let o = 0; o < e.length; o++) {
        ["sqrt", "exponent", "percent", "fraction"].indexOf(e[o]) ===
            -1 &&
          (__dcg_shared_module_exports__["qe"].warn(
            "Unrecognized value: '" + e[o] +
              `' for 'additionalFunction'. Valid values are 'sqrt', 'percent', 'exponent', or 'fraction'. Using default ("sqrt")`,
          ),
            t = false);
      }
      r.additionalFunctions = t ? e : ["sqrt"];
    }
    return (!r.additionalFunctions || !r.additionalFunctions.length) &&
      (r.additionalFunctions = ["sqrt"]),
      r.singleExpression
        ? (r.evaluationMode = "singleExpressionFourFunction",
          r.disableParentheses &&
          (delete r.disableParentheses,
            __dcg_shared_module_exports__["qe"].warn(
              "Incompatible options: singleExpression can't be used in combination with disableParentheses. Ignoring disableParentheses.",
            )))
        : r.evaluationMode = "fourFunction",
      delete r.singleExpression,
      r.hasOwnProperty("decimalToFraction") || (r.decimalToFraction = false),
      r.language && (r.language = Ld(r.language)),
      delete r.allowComplex,
      delete r.complex,
      r;
  }
  var xx = class extends lu {
    constructor(e, t, o) {
      super(
        e,
        { ...t, allowComplex: false, product: "geometry-calculator" },
        o,
      ),
        this.setState(nf),
        this.clearHistory();
    }
  };
  var wx = class extends lu {
    constructor(e, t, o) {
      super(e, { ...t, product: "graphing" }, o);
    }
  };
  var kA = class {
    constructor(e, t) {
      let o = new Bp();
      for (let a in t) o.config.setProperty(a, t[a]);
      this.controller = new Im(o);
      let i = new Nh(e);
      this.controller.setEvaluator(i),
        i.readEvaluatorConfig = () => ({
          product: this.controller.getGraphSettings().config.product,
          beta3d: t.beta3d,
          evaluationMode: this.controller.isGeometry()
            ? "geometry"
            : "graphing",
          globalRandomSeed: o.randomSeed,
          includeFunctionParametersInRandomSeed:
            o.includeFunctionParametersInRandomSeed,
          degreeMode: o.degreeMode,
          restrictedFunctions: o.config.restrictedFunctions,
          distributions: o.config.distributions,
          pointsOfInterest: o.config.pointsOfInterest,
          plotSingleVariableImplicitEquations:
            o.config.plotSingleVariableImplicitEquations,
          plotImplicits: o.config.plotImplicits,
          plotInequalities: o.config.plotInequalities,
          sliders: o.config.sliders,
          actions: o.config.actions,
          recursion: !!o.config.recursion,
        }),
        i.onEvaluatorResults = (a) => {
          this.controller.dispatch({
            type: "on-evaluator-changes",
            changes: a.evaluationStates,
            timingData: a.timingData,
            eventUpdates: a.eventUpdates,
            dependencyOrder: a.dependencyOrder,
          });
        };
      let n = new cs({
        pixelCoordinates: {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          width: 0,
          height: 0,
        },
        mathCoordinates: {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          width: 0,
          height: 0,
        },
      });
      this.graphpaperBounds = n, this.evaluator = i, this.setBlank();
    }
    setBlank(e) {
      this.controller.dispatch({ type: "set-blank", opts: e });
    }
    tick() {
      this.evaluator.tick();
    }
    destroy() {
      this.evaluator.destroy();
    }
  };
  var vx = class {
    constructor(e) {
      this._calc = new kA(cx, DD({ ...e })),
        this.controller = this._calc.controller,
        this._sharedClockBusToken = Am(() => {
          this._calc.tick();
        });
    }
    destroy() {
      this._calc.destroy(), Mm(this._sharedClockBusToken);
      function e(i) {
        __dcg_shared_module_exports__["qe"].warn(
          "You've destroyed this API instance. You can no longer call ." +
            i + "()",
        );
      }
      let t = {}, o = this;
      for (; o;) {
        Object.getOwnPropertyNames(o).forEach((n) => t[n] = true),
          o = Object.getPrototypeOf(o);
      }
      for (let i in t) {
        typeof this[i] == "function"
          ? this[i] = e.bind(this, i)
          : this.hasOwnProperty(i) && delete this[i];
      }
      this.destroy = function () {};
    }
    setExpression(e) {
      let o = this.controller.getItemModel(e.id),
        i = o && o.type,
        n = uD(e, i, this.controller);
      if (n) {
        if (i) {
          this.controller.dispatch({
            type: "set-expression-properties-from-api",
            id: n.id,
            properties: n,
          });
        } else {
          if (n.type === "image") return;
          this.controller.dispatch({
            type: "add-item-to-end-from-api",
            state: n,
          });
        }
      }
    }
    setExpressions(e) {
      e.forEach(this.setExpression.bind(this));
    }
    removeExpression(e) {
      let t = e.id.toString();
      this.controller.dispatch({ type: "remove-item-by-id", id: t });
    }
    removeExpressions(e) {
      e.forEach(this.removeExpression.bind(this));
    }
    getState(e) {
      return this.controller.getState(e);
    }
    getExpressions() {
      return this.getState({ stripDefaults: false }).expressions.list.map(
        pD,
      );
    }
    setBlank(e) {
      this.controller.dispatch({ type: "set-blank", opts: e || {} });
    }
    setState(e, t) {
      this.controller.dispatch({
        type: "set-state",
        state: e,
        opts: t || {},
      });
    }
    HelperExpression(e) {
      let t = e && e.latex || "", o = new cs({ latex: t });
      return this.controller.dispatch({
        type: "add-helper-expression",
        state: {
          type: "helper-expression",
          id: this.controller.generateId(),
          latex: t,
          proxy: o,
        },
      }),
        o;
    }
    getHelperExpressions() {
      return this.controller.getHelperExpressions();
    }
    resize() {}
  };
  var Cx = class extends fx {
    constructor(e, t) {
      super(e), this.init(Upe(t || {}));
    }
  };
  function Upe(r) {
    return r = __dcg_shared_module_exports__["Jc"](r),
      r.singleExpression
        ? (r.evaluationMode = "singleExpressionScientific",
          delete r.allowComplex,
          delete r.complex)
        : r.evaluationMode = "scientific",
      delete r.singleExpression,
      r.language && (r.language = Ld(r.language)),
      r;
  }
  var H1;
  typeof Desmos != "undefined" ? H1 = Desmos : (H1 = {}, window.Desmos = H1);
  var qpe = { SMALL: "0.85", MEDIUM: "1", LARGE: "1.35" };
  function MR(...r) {
    return new wx(...r);
  }
  MR.prototype = wx.prototype;
  function GR(...r) {
    return new xx(...r);
  }
  GR.prototype = xx.prototype;
  function LR(...r) {
    return new vx(...r);
  }
  LR.prototype = vx.prototype;
  function Pj(...r) {
    return new yx(...r);
  }
  Pj.prototype = yx.prototype;
  function Vj(...r) {
    return new Cx(...r);
  }
  Vj.prototype = Cx.prototype;
  function Oj(...r) {
    return new dx(...r);
  }
  Oj.prototype = dx.prototype;
  var _A = {
    Colors: {
      RED: pE,
      BLUE: uE,
      GREEN: hE,
      ORANGE: mE,
      PURPLE: gE,
      BLACK: zf,
    },
    imageFileToDataURL: cD,
    supportedLanguages: ["en"].concat(
      typeof desmosLocaleData == "object" ? Object.keys(desmosLocaleData) : [],
    ),
    Styles: { ...DP, ...TP },
    ColumnModes: Sv,
    DragModes: kP,
    AxisArrowModes: __dcg_shared_module_exports__["pd"],
    FontSizes: hD,
    LabelSizes: qpe,
    LabelOrientations: _P,
    GraphingCalculator: MR,
    Calculator: MR,
    FourFunctionCalculator: Pj,
    ScientificCalculator: Vj,
    Geometry: GR,
    Calculator3D: Oj,
    Abraham: td,
    Private: {
      Abraham: td,
      Mathtools: sS,
      Graphtools: {
        ScalePair: __dcg_shared_module_exports__["jd"],
        getClippingGraphType: Rx,
        mapSegmentToCanvas: vu,
        computeDrawingCommandsForDOMLabel: UT,
        drawCommandsToCtx: zT,
      },
      MathquillConfig: { getAutoCommands: Pu, getAutoOperators: kG },
      Parser: __dcg_shared_module_exports__["fe"],
      extractSliderValueFromLatex: dw,
      __compareBranches: {
        getSliderMin: nl,
        getSliderMax: bc,
        valueTypes: __dcg_shared_module_exports__["valueTypes"],
        migrateGeoStateToCalcState: ug_migrateGeoStateToCalcState,
        Mathtools: sS,
      },
      GeometryBeta: GR,
      migrateGeoStateToCalcState: ug_migrateGeoStateToCalcState,
      HeadlessGraphingCalculator: LR,
      maybeNotifyUserChangedLatex: Fe.simulateUserChangedLatex,
      Fragile: {
        DCGView: zpe,
        PromptSliderView: Ec,
        Checkbox: mt,
        SegmentedControl: vo,
        MathquillView: Fe,
        InlineMathInputView: lr,
        StaticMathquillView: nt,
        Tooltip: Le,
        ExpressionOptionsMenuView: ny,
        ExpressionView: Wg,
        ImageIconView: $g,
        evaluateLatex: io,
        Keys: sr,
        getReconciledExpressionProps: __dcg_shared_module_exports__["Zc"],
        List: { moveItemsTo: Uu, removeItemById: Ag },
        currentLanguage: Zw,
      },
    },
    TestInternal: { fetchLanguage: (r) => qH(r) },
    MathQuill: gc,
    HeadlessGraphingCalculator: LR,
  };
  function K1(r) {
    let e = H1.enabledFeatures;
    return !e || e[r];
  }
  function Sx(r) {
    _A[r] = function () {
      throw new Error(
        "The Desmos " + r + " is not enabled for this API key.",
      );
    };
  }
  K1("GraphingCalculator") ||
    (Sx("GraphingCalculator"), Sx("Calculator"));
  K1("FourFunctionCalculator") || Sx("FourFunctionCalculator");
  K1("ScientificCalculator") || Sx("ScientificCalculator");
  K1("GeometryCalculator") || Sx("Geometry");
  K1("Calculator3D") || Sx("Calculator3D");
  for (let r in _A) _A.hasOwnProperty(r) && (H1[r] = _A[r]);
  qt();
  typeof Desmos == "undefined" && (Desmos = {});
  function Rj() {
    Desmos.$ = ee, Desmos.$.noConflict(true);
  }
  typeof Desmos == "undefined" && (Desmos = {});
  Rj();
  /*!
* jQuery JavaScript Library v3.6.0
* https://jquery.com/
*
* Includes Sizzle.js
* https://sizzlejs.com/
*
* Copyright OpenJS Foundation and other contributors
* Released under the MIT license
* https://jquery.org/license
*
* Date: 2021-03-02T17:08Z
  */
  /*!!
*  Canvas 2 Svg v1.0.19
*  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.
*
*  Licensed under the MIT license:
*  http://www.opensource.org/licenses/mit-license.php
*
*  Author:
*  Kerry Liu
*
*  Copyright (c) 2014 Gliffy Inc.
*
*  Modifications by Desmos:
*  - wrapped in AMD pattern
*  - added ctx.ellipse() method
*  - fixed image opacity bug
*  - added ability to add classNames to exported svg elements
*  - added ability to add named groups
*  - removed dominant-basline attribute. Editors appear to ignore it. Must solve baseline issues using transformations
  */
});
